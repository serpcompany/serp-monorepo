[
  {
    "owner": "graphile",
    "repo": "crystal",
    "content": "TITLE: Implementing Row-Level Security Policies in PostgreSQL (SQL)\nDESCRIPTION: Illustrates setting up Row-Level Security (RLS) in PostgreSQL. It requires enabling RLS on the target table (`my_table`) using `ALTER TABLE ... ENABLE ROW LEVEL SECURITY`. The snippet then demonstrates creating various policies (`manage_own`, `must_be_verified`, `admin_delete`, `friend_insert`) using `CREATE POLICY`. It covers applying policies to specific commands (`FOR ALL`, `FOR INSERT`, `FOR DELETE`), using `USING` clauses (conditions checked against existing rows for SELECT, UPDATE, DELETE) and `WITH CHECK` clauses (conditions checked against new/updated rows for INSERT, UPDATE), and defining `RESTRICTIVE` policies which must all pass along with at least one permissive policy. Assumes the existence of functions like `current_user_id()`, `current_user_is_verified()`, `current_user_is_admin()`, and `are_friends()`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n-- Without this line, even if you define security policies, they will not be enforced\nalter table my_table enable row level security;\n\ncreate policy manage_own on my_table for all using ( author_id = current_user_id() );\ncreate policy must_be_verified on my_table as restrictive for insert using ( current_user_is_verified() );\ncreate policy admin_delete on my_table for delete using ( current_user_is_admin() );\ncreate policy friend_insert on my_other_table for insert with check ( are_friends(author_id, user_id) );\n```\n\n----------------------------------------\n\nTITLE: Executing CRUD Mutations in PostGraphile (GraphQL)\nDESCRIPTION: These GraphQL examples illustrate how to perform Create, Update, and Delete operations using mutations automatically generated by PostGraphile for a `users` table. The first mutation creates a new user, the second updates an existing user identified by their primary key (`id`), and the third deletes a user identified by a unique key (`username`). Each mutation requests specific fields to be returned upon successful execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/crud-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n# Create a User and get back details of the record we created\nmutation {\n  createUser(\n    input: { user: { id: 1, name: \"Bilbo Baggins\", username: \"bilbo\" } }\n  ) {\n    user {\n      id\n      name\n      username\n      createdAt\n    }\n  }\n}\n\n# Update Bilbo using the user.id primary key\nmutation {\n  updateUserById(\n    input: { id: 1, userPatch: { about: \"An adventurous hobbit\" } }\n  ) {\n    user {\n      id\n      name\n      username\n      about\n      createdAt\n    }\n  }\n}\n\n# Delete Bilbo using the unique user.username column and return the mutation ID\nmutation {\n  deleteUserByUsername(input: { username: \"bilbo\" }) {\n    deletedUserId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of PostGraphile V5 Preset with V4 Migration and Database Settings - TypeScript\nDESCRIPTION: This comprehensive TypeScript configuration exhibits advanced migration from V4 to V5 for PostGraphile by integrating documented presets, explicit plugin setups, and PostgreSQL connection details. The snippet references V5-specific configuration keys (such as plugins, pgServices) and notes the transition from pluginHook to explicit plugin lists. It highlights how to append V4 plugin arrays and provides a template for including or excluding plugins as needed. Dependencies include postgraphile, postgraphile/presets/amber, postgraphile/presets/v4, and postgraphile/adaptors/pg; expected inputs are V4 options and lists of plugins for migration, outputting a ready-to-use configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport \"graphile-config\";\n\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\n// Use the 'pg' module to connect to the database\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    // The initial PostGraphile V5 preset\n    PostGraphileAmberPreset,\n\n    // Change the options and add/remove plugins based on your V4 configuration:\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n      appendPlugins: [\n        /*...*/\n      ],\n    }),\n\n    // Note some plugins are now \"presets\", e.g.\n    // `@graphile/simplify-inflection`, those should be listed here instead of `appendPlugins`\n  ],\n\n  plugins: [\n    /*\n     * If you were using `pluginHook` before, the relevant plugins will need\n     * listing here instead. You can also move the `appendPlugins` list here\n     * for consistency if you like.\n     */\n  ],\n\n  /*\n   * PostgreSQL database configuration.\n   *\n   * If you're using the CLI you can skip this and use the `-c` and `-s`\n   * options instead, but we advise configuring it here so all the modes of\n   * running PostGraphile can share it.\n   */\n  pgServices: [\n    makePgService({\n      // Database connection string:\n      connectionString: process.env.DATABASE_URL,\n      // List of schemas to expose:\n      schemas: [\"app_public\"],\n      // Superuser connection string, only needed if you're using watch mode:\n      // superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    }),\n  ],\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic 'registerUser' Mutation in TypeScript with Graphile/PostGraphile\nDESCRIPTION: This TypeScript code defines a Graphile plugin (`RegisterUserPlugin`) using `makeExtendSchemaPlugin`. It extends the GraphQL schema to add a `registerUser` mutation. The mutation takes username and email as input. Its payload (`RegisterUserPayload`) contains a `result` field, which is a union (`RegisterUserResult`) of `User`, `UsernameConflict`, or `EmailAddressConflict`. The mutation logic is implemented within the `plans` section, using `withPgClient` to interact with the PostgreSQL database inside a transaction. It attempts to insert a user and their email, handling potential unique constraint `DatabaseError`s (code '23505') by returning specific error objects. The `RegisterUserPayload` plan uses `polymorphicBranch` to resolve the union type based on the structure of the result from the mutation execution (checking `__typename` or `id`). A placeholder `sendEmail` function is also included.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { withPgClient } from \"@dataplan/pg\";\nimport { gql, makeExtendSchemaPlugin } from \"graphile-utils\";\nimport {\n  ObjectStep,\n  constant,\n  object,\n  ExecutableStep,\n  access,\n  polymorphicBranch,\n  list,\n} from \"postgraphile/grafast\";\nimport { DatabaseError } from \"pg\";\n\nexport const RegisterUserPlugin = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n  return {\n    typeDefs: gql`\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n\n      input RegisterUserInput {\n        username: String!\n        email: String!\n      }\n\n      type RegisterUserPayload {\n        result: RegisterUserResult\n        query: Query\n      }\n\n      union RegisterUserResult = User | UsernameConflict | EmailAddressConflict\n\n      type UsernameConflict {\n        message: String!\n        username: String!\n      }\n\n      type EmailAddressConflict {\n        message: String!\n        email: String!\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, { $input: { $username, $email } }) {\n          const $result = withPgClient(\n            executor,\n            list([$username, $email]),\n            async (pgClient, [username, email]) => {\n              try {\n                return await pgClient.withTransaction(async (pgClient) => {\n                  const {\n                    rows: [user],\n                  } = await pgClient.query<{\n                    id: string;\n                    username: string;\n                  }>({\n                    text: `\n                      insert into app_public.users (username)\n                      values ($1)\n                      returning *`,\n                    values: [username],\n                  });\n\n                  await pgClient.query({\n                    text: `\n                      insert into app_public.user_emails(user_id, email)\n                      values ($1, $2)`,\n                    values: [user.id, email],\n                  });\n\n                  await sendEmail(email, \"Welcome!\");\n\n                  return { id: user.id };\n                });\n              } catch (e) {\n                if (e instanceof DatabaseError && e.code === \"23505\") {\n                  if (e.constraint === \"unique_user_username\") {\n                    return {\n                      __typename: \"UsernameConflict\",\n                      message: `The username '${username}' is already in use`,\n                      username,\n                    };\n                  } else if (e.constraint === \"unique_user_email\") {\n                    return {\n                      __typename: \"EmailAddressConflict\",\n                      message: `The email address '${email}' is already in use`,\n                      email,\n                    };\n                  }\n                }\n                throw e;\n              }\n            },\n          );\n\n          return object({ result: $result });\n        },\n      },\n\n      RegisterUserPayload: {\n        __assertStep: ObjectStep,\n        result($data: ObjectStep) {\n          const $result = $data.get(\"result\");\n          return polymorphicBranch($result, {\n            UsernameConflict: {\n              // This is a `UsernameConflict` if the object has a `__typename` property.\n              match(obj) {\n                return obj.__typename === \"UsernameConflict\";\n              },\n              // In this case, we can just return the object itself as the step\n              // representing this polymorphic branch.\n              plan($obj) {\n                return $obj;\n              },\n            },\n            EmailAddressConflict: {\n              // If `match` is not specified, it defaults to checking\n              // `obj.__typename === 'EmailAddressConfict'`.\n              // If `plan` is not specified, it defaults to `($obj) => $obj`.\n            },\n            User: {\n              match(obj) {\n                return obj.id != null;\n              },\n              // In this case, we need to get the record from the database\n              // associated with the given user id.\n              plan($obj) {\n                const $id = access($obj, \"id\");\n                return users.get({ id: $id });\n              },\n            },\n          });\n        },\n        query() {\n          // The `Query` type just needs any truthy value.\n          return constant(true);\n        },\n      },\n\n      UsernameConflict: {\n        // Since User expects a step, our types must also expect a step. We\n        // don't care what the step is though.\n        __assertStep: ExecutableStep,\n      },\n      EmailAddressConflict: {\n        __assertStep: ExecutableStep,\n      },\n    },\n  };\n});\n\nasync function sendEmail(email: string, message: string) {\n  /*\n    Write your email-sending logic here. Note that we recommend you enqueue a\n    job to send the email rather than sending it directly; if you don't already\n    have a job queue then check out https://worker.graphile.org\n  */\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafast Context with JWT Processing for pgSettings (TypeScript)\nDESCRIPTION: Provides an example `grafast.context` configuration suitable for the PostGraphile CLI or scenarios without existing authentication middleware. It extracts the Node.js request object (`req`), retrieves headers, and specifically processes the `Authorization` header to verify a JWT using the `jsonwebtoken` library. If valid, it extracts the user ID (`claims.uid`) and sets it, along with other headers, as `pgSettings` (`myapp.user_id`, `myapp.headers.x_something`). Requires the `jsonwebtoken` library and a `JWT_SECRET` environment variable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"graphile.config.js\"\nimport jwt from \"jsonwebtoken\";\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\nexport default {\n  // ...\n\n  grafast: {\n    async context(requestContext, args) {\n      // Extract request details from the requestContext:\n      // highlight-next-line\n      const req = requestContext.node?.req;\n      // Or: const req = requestContext.expressv4?.req;\n      // Or: const ctx = requestContext.koav2?.ctx;\n      // Or: const req = requestContext.fastifyv4?.request;\n\n      const context = {\n        // Base settings for all requests:\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // Expose a specific header (if present) to PostgreSQL\n          // highlight-next-line\n          \"myapp.headers.x_something\": req?.getHeader(\"x-something\"),\n        },\n      };\n\n      // Process the authorization header, if present\n      const auth = req?.headers[\"authorization\"];\n      if (typeof auth === \"string\" && typeof JWT_SECRET === \"string\") {\n        const parts = auth.split(\" \");\n        if (parts.length === 2 && parts[0].toLowerCase() === \"bearer\") {\n          const token = parts[1];\n          const claims = jwt.verify(token, JWT_SECRET, {\n            algorithms: [\"HS256\", \"HS384\"],\n            audience: \"postgraphile\",\n            complete: false,\n          });\n          // Expose the user id from the request, if present\n          // highlight-next-line\n          context.pgSettings[\"myapp.user_id\"] = claims.uid;\n        }\n      }\n\n      return context;\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Table for PostGraphile\nDESCRIPTION: SQL code snippet demonstrating the creation of an `app_public.users` table in PostgreSQL. This table includes various column types (serial, citext, text, int, boolean, timestamptz), constraints (PRIMARY KEY, NOT NULL, UNIQUE, REFERENCES with ON DELETE CASCADE), and default values (DEFAULT false, DEFAULT now()). This structure serves as an example for PostGraphile's automatic schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/tables.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users (\n  id serial PRIMARY KEY,\n  username citext NOT NULL unique,\n  name text NOT NULL,\n  about text,\n  organization_id int NOT NULL\n    REFERENCES app_public.organizations ON DELETE CASCADE,\n  is_admin boolean NOT NULL DEFAULT false,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now()\n);\n```\n\n----------------------------------------\n\nTITLE: Assigning JWT Claims as PostgreSQL Session Variables - SQL\nDESCRIPTION: This snippet sets remaining JWT claims as PostgreSQL session-level variables under the 'jwt.claims' namespace using 'SET LOCAL'. Each claim (including standardized claims) is mapped to a session variable, making it available for database logic. '$claim_name' is the name of a claim, and '$claim_value' its corresponding value from the JWT. Requires a running transaction/session and PostgreSQL 9.2+. Values must be properly quoted and sanitized. There is no output; the claim is stored session-locally.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nset local jwt.claims.$claim_name to $claim_value;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using current_person Helper Function - PostgreSQL - SQL\nDESCRIPTION: Defines a SQL function in the forum_example schema to fetch the person identified by the current JWT \"person_id\" claim. This function relies on the current_setting function to access transaction-level configuration set by authentication in PostGraphile, casting the setting's string value to integer. It requires that a JWT with a person_id claim is supplied with the request, and is intended for use in both database logic and by PostGraphile. The function is stable and works only if the 'jwt.claims.person_id' setting exists; otherwise it returns no person. A descriptive SQL comment annotates the function's purpose.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_37\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.current_person() returns forum_example.person as $$\n  select *\n  from forum_example.person\n  where id = nullif(current_setting('jwt.claims.person_id', true), '')::integer\n$$ language sql stable;\n\ncomment on function forum_example.current_person() is 'Gets the person who was identified by our JWT.';\n```\n\n----------------------------------------\n\nTITLE: Initializing Express Server with PostGraphile - TypeScript\nDESCRIPTION: This TypeScript code initializes an HTTP server using Express, attaches a PostGraphile handler configured with imported presets, and logs status. It handles startup errors gracefully and listens on port 5050. Key dependencies are express, node:http, postgraphile, and the locally exported PostGraphile handler. Input parameters for connections and logging are managed via code and environment configs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from \\\"node:http\\\";\\nimport express from \\\"express\\\";\\nimport { grafserv } from \\\"postgraphile/grafserv/express/v4\\\";\\nimport { pgl } from \\\"./pgl.ts\\\";\\n\\nconst serv = pgl.createServ(grafserv);\\n\\nconst app = express();\\nconst server = createServer(app);\\nserver.once(\\\"listening\\\", () => {\\n  server.on(\\\"error\\\", (e) => void console.error(e));\\n});\\nserv.addTo(app, server).catch((e) => {\\n  console.error(e);\\n  process.exit(1);\\n});\\nserver.listen(5050);\\n\\nconsole.log(\\\"Server listening at http://localhost:5050\\\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Row Level Security on PostgreSQL Tables (SQL)\nDESCRIPTION: Enables Row Level Security (RLS) for the specified tables (`forum_example.person` and `forum_example.post`) in a PostgreSQL database. This is a prerequisite for defining specific access policies. Requires PostgreSQL 9.5 or later.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_39\n\nLANGUAGE: sql\nCODE:\n```\nalter table forum_example.person enable row level security;\nalter table forum_example.post enable row level security;\n```\n\n----------------------------------------\n\nTITLE: Building a \"myChannels\" Field Plugin with Context and Resource Lookup (TypeScript)\nDESCRIPTION: This example shows a complete PostGraphile plugin that adds a myChannels field to the Query root, returning all channels for the current user's organization. It uses context access, resource.get, resource.find, and step chaining. Dependencies include 'postgraphile/utils' and 'postgraphile/grafast'. The key parameters are the userId from context and the corresponding user/organization/channel relationships. Returned value is a PgSelectStep of matching channel rows.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context } from \"postgraphile/grafast\";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { users, channels } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get(\"userId\");\n          const $user = users.get({ id: $userId });\n          const $orgId = $user.get(\"organization_id\");\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema Using Graphile-Build in JavaScript\nDESCRIPTION: This snippet demonstrates how to build a GraphQL schema synchronously with the PostGraphile V5 toolchain. It highlights the use of 'resolvePreset' to process configuration, 'buildInflection' to manage naming conventions, 'gather' to collect schema input, and 'buildSchema' for construction. Dependencies include the 'graphile-config' and 'graphile-build' packages, and a preset configuration module. The input consists of the preset, gathered schema information, and a shared inflection object; output is a ready-to-use GraphQL schema without runtime introspection or plugin overhead.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { resolvePreset } from \"graphile-config\";\nimport { buildInflection, gather, buildSchema } from \"graphile-build\";\nimport preset from \"./graphile.config.js\";\n\nconst resolvedPreset = resolvePreset(preset);\nconst shared = { inflection: buildInflection(resolvedPreset) };\nconst input = await gather(resolvedPreset, shared);\nconst schema = buildSchema(resolvedPreset, input, shared);\n```\n\n----------------------------------------\n\nTITLE: Illustrating GraphQL Schema Changes After Applying Plugin (Diff)\nDESCRIPTION: This diff output compares the original GraphQL schema with the schema generated after applying the `OmitMutationsByDefaultPlugin`. Lines starting with `-` indicate elements removed from the original schema. The diff clearly shows the removal of various input types (e.g., `CreateForumInput`, `DeleteForumInput`, `UpdateQuizInput`), payload types (e.g., `CreateForumPayload`, `DeleteForumPayload`), and mutation fields within the root `Mutation` type that correspond to standard CRUD operations. This visually confirms the plugin's effect of omitting default mutations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -3,41 +3,6 @@\n \"\"\"\n scalar BigFloat\n \n-\"\"\"All input for the create `Forum` mutation.\"\"\"\n-input CreateForumInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `Forum` to be created by this mutation.\"\"\"\n-  forum: ForumInput!\n-}\n-\n-\"\"\"The output of our create `Forum` mutation.\"\"\"\n-type CreateForumPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `Forum` that was created by this mutation.\"\"\"\n-  forum: Forum\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"An edge for our `Forum`. May be used by Relay 1.\"\"\"\n-  forumEdge(\n-    \"\"\"The method to use when ordering `Forum`.\"\"\"\n-    orderBy: [ForumsOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): ForumsEdge\n-}\n-\n \"\"\"All input for the create `Post` mutation.\"\"\"\n input CreatePostInput {\n   \"\"\"\n@@ -79,120 +44,6 @@\n   ): PostsEdge\n }\n \n-\"\"\"All input for the create `QuizEntryAnswer` mutation.\"\"\"\n-input CreateQuizEntryAnswerInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `QuizEntryAnswer` to be created by this mutation.\"\"\"\n-  quizEntryAnswer: QuizEntryAnswerInput!\n-}\n-\n-\"\"\"The output of our create `QuizEntryAnswer` mutation.\"\"\"\n-type CreateQuizEntryAnswerPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `QuizEntryAnswer` that was created by this mutation.\"\"\"\n-  quizEntryAnswer: QuizEntryAnswer\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"Reads a single `QuizEntry` that is related to this `QuizEntryAnswer`.\"\"\"\n-  quizEntry: QuizEntry\n-\n-  \"\"\"An edge for our `QuizEntryAnswer`. May be used by Relay 1.\"\"\"\n-  quizEntryAnswerEdge(\n-    \"\"\"The method to use when ordering `QuizEntryAnswer`.\"\"\"\n-    orderBy: [QuizEntryAnswersOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): QuizEntryAnswersEdge\n-}\n-\n-\"\"\"All input for the create `QuizEntry` mutation.\"\"\"\n-input CreateQuizEntryInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `QuizEntry` to be created by this mutation.\"\"\"\n-  quizEntry: QuizEntryInput!\n-}\n-\n-\"\"\"The output of our create `QuizEntry` mutation.\"\"\"\n-type CreateQuizEntryPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `QuizEntry` that was created by this mutation.\"\"\"\n-  quizEntry: QuizEntry\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"Reads a single `User` that is related to this `QuizEntry`.\"\"\"\n-  user: User\n-\n-  \"\"\"Reads a single `Quiz` that is related to this `QuizEntry`.\"\"\"\n-  quiz: Quiz\n-\n-  \"\"\"An edge for our `QuizEntry`. May be used by Relay 1.\"\"\"\n-  quizEntryEdge(\n-    \"\"\"The method to use when ordering `QuizEntry`.\"\"\"\n-    orderBy: [QuizEntriesOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): QuizEntriesEdge\n-}\n-\n-\"\"\"All input for the create `Quiz` mutation.\"\"\"\n-input CreateQuizInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `Quiz` to be created by this mutation.\"\"\"\n-  quiz: QuizInput!\n-}\n-\n-\"\"\"The output of our create `Quiz` mutation.\"\"\"\n-type CreateQuizPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `Quiz` that was created by this mutation.\"\"\"\n-  quiz: Quiz\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"An edge for our `Quiz`. May be used by Relay 1.\"\"\"\n-  quizEdge(\n-    \"\"\"The method to use when ordering `Quiz`.\"\"\"\n-    orderBy: [QuizzesOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): QuizzesEdge\n-}\n-\n \"\"\"All input for the create `Topic` mutation.\"\"\"\n input CreateTopicInput {\n   \"\"\"\n@@ -351,66 +202,6 @@\n \"\"\"\n scalar Datetime\n \n-\"\"\"All input for the `deleteForumByNodeId` mutation.\"\"\"\n-input DeleteForumByNodeIdInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"\n-  The globally unique `ID` which will identify a single `Forum` to be deleted.\n-  \"\"\"\n-  nodeId: ID!\n-}\n-\n-\"\"\"All input for the `deleteForumBySlug` mutation.\"\"\"\n-input DeleteForumBySlugInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"An URL-safe alias for the `Forum`.\"\"\"\n-  slug: String!\n-}\n-\n-\"\"\"All input for the `deleteForum` mutation.\"\"\"\n-input DeleteForumInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-  id: Int!\n-}\n-\n-\"\"\"The output of our delete `Forum` mutation.\"\"\"\n-type DeleteForumPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `Forum` that was deleted by this mutation.\"\"\"\n-  forum: Forum\n-  deletedForumNodeId: ID\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"An edge for our `Forum`. May be used by Relay 1.\"\"\"\n-  forumEdge(\n-    \"\"\"The method to use when ordering `Forum`.\"\"\"\n-    orderBy: [ForumsOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): ForumsEdge\n-}\n-\n \"\"\"All input for the `deletePostByNodeId` mutation.\"\"\"\n input DeletePostByNodeIdInput {\n   \"\"\"\n@@ -465,159 +256,6 @@\n   ): PostsEdge\n }\n \n-\"\"\"All input for the `deleteQuizByNodeId` mutation.\"\"\"\n-input DeleteQuizByNodeIdInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"\n-  The globally unique `ID` which will identify a single `Quiz` to be deleted.\n-  \"\"\"\n-  nodeId: ID!\n-}\n-\n-\"\"\"All input for the `deleteQuizEntryAnswerByNodeId` mutation.\"\"\"\n-input DeleteQuizEntryAnswerByNodeIdInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"\n-  The globally unique `ID` which will identify a single `QuizEntryAnswer` to be deleted.\n-  \"\"\"\n-  nodeId: ID!\n-}\n-\n-\"\"\"All input for the `deleteQuizEntryAnswer` mutation.\"\"\"\n-input DeleteQuizEntryAnswerInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n-  clientMutationId: String\n-  id: Int!\n-}\n-\n-\"\"\"The output of our delete `QuizEntryAnswer` mutation.\"\"\"\n-type DeleteQuizEntryAnswerPayload {\n-  \"\"\"\n-  The exact same `clientMutationId` that was provided in the mutation input,\n-  unchanged and unused. May be used by a client to track mutations.\n-  \"\"\"\n-  clientMutationId: String\n-\n-  \"\"\"The `QuizEntryAnswer` that was deleted by this mutation.\"\"\"\n-  quizEntryAnswer: QuizEntryAnswer\n-  deletedQuizEntryAnswerNodeId: ID\n-\n-  \"\"\"\n-  Our root query field type. Allows us to run any query from our mutation payload.\n-  \"\"\"\n-  query: Query\n-\n-  \"\"\"Reads a single `QuizEntry` that is related to this `QuizEntryAnswer`.\"\"\"\n-  quizEntry: QuizEntry\n-\n-  \"\"\"An edge for our `QuizEntryAnswer`. May be used by Relay 1.\"\"\"\n-  quizEntryAnswerEdge(\n-    \"\"\"The method to use when ordering `QuizEntryAnswer`.\"\"\"\n-    orderBy: [QuizEntryAnswersOrderBy!] = [PRIMARY_KEY_ASC]\n-  ): QuizEntryAnswersEdge\n-}\n-\n-\"\"\"All input for the `deleteQuizEntryByNodeId` mutation.\"\"\"\n-input DeleteQuizEntryByNodeIdInput {\n-  \"\"\"\n-  An arbitrary string value with no semantic meaning. Will be included in the\n-  payload verbatim. May be used to track mutations by the client.\n-  \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating, Updating, and Deleting Users with Graphile Mutations (GraphQL)\nDESCRIPTION: This collection of GraphQL mutation examples demonstrates how to create, update, and delete user records using the auto-generated CRUD mutation fields provided by PostGraphile. Dependencies include a running PostGraphile server with a 'users' table, configured permissions, and enabled default mutations. Key parameters include 'input' payloads such as 'user', 'userPatch', and unique identifiers ('id', 'username'). These mutations will create a new user, update an existing user based on primary key, and delete a user by username, respectively. Results include the returned user fields or, in the case of deletion, the deleted user's ID. Certain mutations require the corresponding primary key or unique constraint to exist on the database table; insufficient permissions or configuration may prevent mutations from appearing in the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/crud-mutations.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n# Create a User and get back details of the record we created\\nmutation {\\n  createUser(\\n    input: { user: { id: 1, name: \\\"Bilbo Baggins\\\", username: \\\"bilbo\\\" } }\\n  ) {\\n    user {\\n      id\\n      name\\n      username\\n      createdAt\\n    }\\n  }\\n}\\n\\n# Update Bilbo using the user.id primary key\\nmutation {\\n  updateUserById(\\n    input: { id: 1, userPatch: { about: \\\"An adventurous hobbit\\\" } }\\n  ) {\\n    user {\\n      id\\n      name\\n      username\\n      about\\n      createdAt\\n    }\\n  }\\n}\\n\\n# Delete Bilbo using the unique user.username column and return the mutation ID\\nmutation {\\n  deleteUserByUsername(input: { username: \\\"bilbo\\\" }) {\\n    deletedUserId\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Table Structure (SQL)\nDESCRIPTION: This SQL snippet defines a relational table named 'users' within the 'app_public' schema. It demonstrates concepts such as primary keys, unique constraints, not-null requirements, foreign key relationships with cascading deletes, column types (including custom types like 'citext'), and automatic timestamp columns with default values. Dependencies include the existence of the referenced 'app_public.organizations' table and types like 'citext'. Inputs are the DDL statements, and the output is the creation of a robust, normalized users table ready for PostGraphile integration, with referential integrity and audit columns. The snippet assumes required types and referenced tables have been set up.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/tables.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users (\n  id serial PRIMARY KEY,\n  username citext NOT NULL unique,\n  name text NOT NULL,\n  about text,\n  organization_id int NOT NULL\n    REFERENCES app_public.organizations ON DELETE CASCADE,\n  is_admin boolean NOT NULL DEFAULT false,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now()\n);\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions in PostgreSQL - SQL\nDESCRIPTION: These SQL snippets demonstrate the recommended method for granting specific permissions to a role in PostgreSQL for use with PostGraphile. The examples show how to correctly assign SELECT, INSERT (with explicit columns), UPDATE (with explicit columns), and DELETE privileges on the 'users' table to the 'graphql_role'. Prerequisites include an existing table and role. Each command targets a different CRUD operation, and the explicit column specification for INSERT/UPDATE supports fine-grained security in PostGraphile. Input is a SQL GRANT command; output is an updated database privilege configuration. Limitation: Each example assumes the listed columns and roles exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/best-practices.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\\nGRANT SELECT ON users TO graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\\nGRANT INSERT (column_1, column_2, ...) ON users TO graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\\nGRANT UPDATE (column_a, column_b, ...) ON users TO graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\\nGRANT DELETE ON users TO graphql_role;\n```\n\n----------------------------------------\n\nTITLE: Setting Up a One-to-Many Relation Schema in PostgreSQL (SQL)\nDESCRIPTION: This SQL snippet demonstrates the creation of a one-to-many relationship by defining two tables and linking them using a foreign key. The example includes the creation of separate schemas, primary keys, unique constraints, and a reference from the child table (a.post) back to the parent (c.person), with an index for performance. Dependencies: PostgreSQL server, schemas 'a' and 'c' must not already exist. On execution, creates structure for efficient integration with PostGraphile or any ORM.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/relations.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema a;\ncreate schema c;\n\ncreate table c.person (\n  id serial primary key,\n  name varchar not null,\n  about text,\n  email varchar not null unique,\n  created_at timestamp default current_timestamp\n);\n\ncreate table a.post (\n  id serial primary key,\n  headline text not null,\n  body text,\n  -- `references` ðŸ‘‰  sets up the foreign key relation\n  author_id int4 references c.person(id)\n);\ncreate index on a.post (author_id);\n```\n\n----------------------------------------\n\nTITLE: Complete PostGraphile V5 Node.js HTTP Server Setup in TypeScript\nDESCRIPTION: A full example (`server.js`) combining previous steps: importing the config preset, initializing PostGraphile, importing the Node Grafserv adapter, creating the Grafserv instance, creating a standard Node.js HTTP server, attaching Grafserv using `serv.addTo()`, and starting the server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\nimport { postgraphile } from \"postgraphile\";\nimport { grafserv } from \"grafserv/node\"; // Adaptor for Node's HTTP server\nimport { createServer } from \"node:http\";\n\n// Create an HTTP server (with error handler)\nconst server = createServer();\nserver.on(\"error\", (e) => console.error(e));\n\n// Create a PostGraphile instance (pgl)\nconst pgl = postgraphile(preset);\n// Create a Grafserv (server adaptor) instance for this PostGraphile instance\nconst serv = pgl.createServ(grafserv);\n// Attach a request handler to the server\nserv.addTo(server);\n\n// Start the server\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Performing Access Control Checks Before Mutations using makeWrapPlansPlugin (JavaScript)\nDESCRIPTION: Illustrates how to use `makeWrapPlansPlugin` with `sideEffect` and `context` steps from `postgraphile/grafast` to implement pre-mutation access control in PostGraphile V5. It extracts an `isAdmin` flag from the GraphQL context for the `createUser` mutation. Before calling the original plan, a `sideEffect` step checks this flag; if the user is not an admin, it throws an error, preventing the mutation from executing. This pattern is primarily intended for Mutation fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nimport { sideEffect, context } from \"postgraphile/grafast\";\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\n\nconst plugin = makeWrapPlansPlugin({\n  Mutation: {\n    createUser(plan) {\n      // Extract the 'isAdmin' property from the GraphQL context\n      const $isAdmin = context().get(\"isAdmin\");\n\n      // If the user isn't an admin, throw an error\n      const $preCheck = sideEffect($isAdmin, (isAdmin) => {\n        if (!isAdmin) {\n          throw new Error(\"Abort\");\n        }\n      });\n\n      // Now call the underlying plans; these will never execute if the above throws\n      // NOTE: The example seems to miss `$preCheck` being used, typically it would be chained or checked.\n      // Assuming intent is to execute the check *before* the plan:\n      // sideEffect doesn't automatically halt execution in this structure;\n      // a more robust pattern might involve conditional logic or chaining.\n      // However, following the snippet's implied logic:\n      // The sideEffect *intends* to run before the plan, and throwing halts.\n      return plan();\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile Server with Amber & Lazy JWT Presets (TypeScript)\nDESCRIPTION: This TypeScript configuration file for PostGraphile extends the Amber and Lazy JWT presets, specifies the JWT token type, sets a JWT secret, and configures the API context to assign the database role using the request context or JWT claims. It expects the\\n\\\"postgraphile/presets/amber\\\" and \\\"postgraphile/presets/lazy-jwt\\\" dependencies. Key options like \\\"pgJwtTypes\\\" and \\\"pgJwtSecret\\\" must match those in the Postgres schema; the configuration is essential for correct authentication and authorization behavior.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \\\"postgraphile/presets/amber\\\";\nimport { PgLazyJWTPreset } from \\\"postgraphile/presets/lazy-jwt\\\";\n\nexport default {\n  extends: [PostGraphileAmberPreset, PgLazyJWTPreset],\n  gather: {\n    pgJwtTypes: \\\"forum_example.jwt_token\\\",\n  },\n  schema: {\n    pgJwtSecret: \\\"keyboard_kitten\\\", // REPLACE THIS!\n  },\n  grafast: {\n    context(requestContext, args) {\n      return {\n        pgSettings: {\n          role: \\\"forum_example_anonymous\\\",\n          // JWT may override the role:\n          ...args.contextValue?.pgSettings,\n        },\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Granting Select, Insert, Update, and Delete Permissions - PostgreSQL - SQL\nDESCRIPTION: This SQL snippet shows how to grant a set of fine-grained permissions (select, insert to specific columns, update to specific columns, and delete) on a table to a particular role. Requires the existence of the target table and roles in the Postgres database. Key parameters are the specific columns to be insertable or updatable, supporting principle of least privilege on data modification. The output is an updated permissions structure for the referenced table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/required-knowledge.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ngrant\n  select,\n  insert (column_1, column_2),\n  update (column_2, column_3),\n  delete\non my_table to app_visitor;\n```\n\n----------------------------------------\n\nTITLE: Integrating JWT Middleware and PostGraphile with pgSettings (JavaScript)\nDESCRIPTION: Demonstrates setting up an Express app that uses the previously defined `checkJwt` middleware to protect the `/graphql` endpoint. It then configures the `postgraphile` middleware, using the `pgSettings` option to extract the `scope` property from the verified JWT payload (available at `req.auth` after `checkJwt` runs) and make it available within PostgreSQL session settings as `user.permissions`. Requires `express`, `postgraphile`, `express-jwt`, and `jwks-rsa` dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\nconst checkJwt = jwt({\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n\nconst app = express();\n\n// Apply checkJwt to our graphql endpoint\napp.use(\"/graphql\", checkJwt);\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, process.env.DB_SCHEMA, {\n    pgSettings: (req) => {\n      const settings = {};\n      if (req.auth) {\n        settings[\"user.permissions\"] = req.auth.scope;\n      }\n      return settings;\n    },\n    // any other PostGraphile options go here\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Planning a Union Across Disparate Tables with pgUnionAll Â· TypeScript\nDESCRIPTION: Shows how to use 'pgUnionAll' to create a plan that combines separate tables (e.g., users and organizations) into a single unionized GraphQL interface or union type. The resource mapping allows fields to be resolved transparently for union queries. Dependencies include defined TableResources for each union type and the 'pgUnionAll' planner from Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst plans = {\n  Query: {\n    allPeopleAndOrganizations() {\n      const $list = pgUnionAll({\n        resourceByTypeName: {\n          Person: personResource,\n          Organization: organizationResource,\n        },\n      });\n      return $list;\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an 'acceptTeamInvite' Custom Mutation in PostgreSQL\nDESCRIPTION: Defines a PostgreSQL function `app_public.accept_team_invite` that acts as a custom mutation. It takes `team_id` as input, updates the `accepted_at` timestamp for the matching team member invitation for the current user (`app_public.current_user_id()`), and returns the updated `app_public.team_members` record. It uses `STRICT` to make `team_id` a required (non-null) argument and `SECURITY DEFINER` to execute with the permissions of the function owner, potentially bypassing RLS checks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-mutations.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.accept_team_invite(team_id integer)\nreturns app_public.team_members\nas $$\n  update app_public.team_members\n    set accepted_at = now()\n    where accepted_at is null\n    and team_members.team_id = accept_team_invite.team_id\n    and member_id = app_public.current_user_id()\n    returning *;\n$$ language sql volatile strict security definer;\n```\n\n----------------------------------------\n\nTITLE: Defining Insert/Update/Delete Policies for Posts with Owner Enforcement (SQL)\nDESCRIPTION: This snippet sets up RLS policies on the \\\"post\\\" table so that only the \\\"forum_example_person\\\" role can insert, update, or delete posts where they are the author. For inserts, a \\\"with check\\\" constraint enforces \\\"author_id\\\" matches the JWT \\\"person_id\\\". For updates and deletes, \\\"using\\\" validates access before the operation. These policies ensure users can only manage their own posts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_40\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy insert_post on forum_example.post for insert to forum_example_person\n  with check (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy update_post on forum_example.post for update to forum_example_person\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy delete_post on forum_example.post for delete to forum_example_person\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Integrating PostGraphile with Node's HTTP Server - JavaScript\nDESCRIPTION: This code integrates a PostGraphile server with the Node.js core 'http' server, creating an HTTP server, mounting the GraphQL server, handling errors, and listening on port 5678. It depends on 'node:http', 'postgraphile', and a configured PostGraphile instance. Inputs are environment and server configuration; output is a running HTTP server providing a GraphQL endpoint.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport { grafserv } from \"postgraphile/grafserv/node\";\nimport { pgl } from \"./pgl.js\";\n\nconst serv = pgl.createServ(grafserv);\n\nconst server = createServer();\nserver.once(\"listening\", () => {\n  server.on(\"error\", (e) => void console.error(e));\n});\n\nserv.addTo(server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\nserver.listen(5678);\n\nconsole.log(\"Server listening at http://localhost:5678\");\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Reference with @ref Smart Tag in PostGraphile (SQL)\nDESCRIPTION: This SQL snippet demonstrates how to add a singular custom relationship to a table using a @ref smart tag in a table comment for PostGraphile. The @ref tag defines a named reference (here: 'author') that traverses a provided foreign key path (via:(author_id)->people(id)), resulting in a singular relation to the 'people' table. Dependencies: underlying foreign key relation between 'posts.author_id' and 'people.id'; PostGraphile must parse the table comment. The 'author' reference will expose a corresponding field in the GraphQL schema. Outputs a GraphQL field; input requires correct smart tag placement. Constraints: the referenced path must exist as a database foreign key.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/refs.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table posts is $$\n  @ref author via:(author_id)->people(id) singular\n  $$;`\n```\n\n----------------------------------------\n\nTITLE: Integrating PostGraphile Middleware with Express.js in JavaScript\nDESCRIPTION: Shows how to use PostGraphile as middleware within an Express.js application. It highlights the recommended placement for other common middleware such as logging (`morgan`), compression (`compression`), and security (`helmet`) before the PostGraphile middleware. Requires `express` and `postgraphile` packages. Environment variables `DATABASE_URL` and `PORT` are used for configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/production.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\n/* Example middleware you might want to put in front of PostGraphile */\n// app.use(require('morgan')(...));\n// app.use(require('compression')({...}));\n// app.use(require('helmet')({...}));\n\napp.use(postgraphile(process.env.DATABASE_URL || \"postgres:///\"));\n\napp.listen(process.env.PORT || 3000);\n```\n\n----------------------------------------\n\nTITLE: Extracting JWT Claims and Headers for PostGraphile pgSettings (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use PostGraphile's CLI configuration context to extract a user ID from a JWT bearer token and surface an HTTP request header, assigning both as session settings to PostgreSQL. It leverages the jsonwebtoken library for JWT decoding, expects a JWT_SECRET environment variable, and accepts either Node.js, Express, Koa, or Fastify request contexts. The approach is compatible with CLI deployments, enhancing PostgreSQL security by passing claims and headers for use in policies or functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport jwt from \"jsonwebtoken\";\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\nexport default {\n  // ...\n\n  grafast: {\n    async context(requestContext, args) {\n      // Extract request details from the requestContext:\n      // highlight-next-line\n      const req = requestContext.node?.req;\n      // Or: const req = requestContext.expressv4?.req;\n      // Or: const ctx = requestContext.koav2?.ctx;\n      // Or: const req = requestContext.fastifyv4?.request;\n\n      const context = {\n        // Base settings for all requests:\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // Expose a specific header (if present) to PostgreSQL\n          // highlight-next-line\n          \"myapp.headers.x_something\": req?.getHeader(\"x-something\"),\n        },\n      };\n\n      // Process the authorization header, if present\n      const auth = req?.headers[\"authorization\"];\n      if (typeof auth === \"string\" && typeof JWT_SECRET === \"string\") {\n        const parts = auth.split(\" \");\n        if (parts.length === 2 && parts[0].toLowerCase() === \"bearer\") {\n          const token = parts[1];\n          const claims = jwt.verify(token, JWT_SECRET, {\n            algorithms: [\"HS256\", \"HS384\"],\n            audience: \"postgraphile\",\n            complete: false,\n          });\n          // Expose the user id from the request, if present\n          // highlight-next-line\n          context.pgSettings[\"myapp.user_id\"] = claims.uid;\n        }\n      }\n\n      return context;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Test Helpers in TypeScript\nDESCRIPTION: This TypeScript code defines helper functions (`test_helpers.ts`) to facilitate database testing with Jest. It includes functions for managing PostgreSQL connection pools (`poolFromUrl`), running tests within isolated transactions (`withDbFromUrl`, `withRootDb`), switching database roles/users (`becomeRoot`, `becomeUser`), and creating test data (`createUsers`). It utilizes the 'pg' library and requires a `TEST_DATABASE_URL` environment variable. An `afterAll` hook ensures connection pools are released after tests.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Pool, PoolClient } from \"pg\";\n\nif (!process.env.TEST_DATABASE_URL) {\n  throw new Error(\"Cannot run tests without a TEST_DATABASE_URL\");\n}\nexport const TEST_DATABASE_URL: string = process.env.TEST_DATABASE_URL;\n\nconst pools = {};\n\n// Make sure we release those pgPools so that our tests exit!\nafterAll(() => {\n  const keys = Object.keys(pools);\n  return Promise.all(\n    keys.map(async (key) => {\n      try {\n        const pool = pools[key];\n        delete pools[key];\n        await pool.end();\n      } catch (e) {\n        console.error(\"Failed to release connection!\");\n        console.error(e);\n      }\n    }),\n  );\n});\n\nconst withDbFromUrl = async <T>(url: string, fn: ClientCallback<T>) => {\n  const pool = poolFromUrl(url); // Assuming poolFromUrl is defined elsewhere or needs to be added\n  const client = await pool.connect();\n  await client.query(\"BEGIN ISOLATION LEVEL SERIALIZABLE;\");\n\n  try {\n    await fn(client);\n  } catch (e) {\n    // Error logging can be helpful:\n    if (typeof e.code === \"string\" && e.code.match(/^[0-9A-Z]{5}$/)) {\n      console.error([e.message, e.code, e.detail, e.hint, e.where].join(\"\\n\"));\n    }\n    throw e;\n  } finally {\n    await client.query(\"ROLLBACK;\");\n    await client.query(\"RESET ALL;\"); // Shouldn't be necessary, but just in case...\n    await client.release();\n  }\n};\n\nexport const withRootDb = <T>(fn: ClientCallback<T>) =>\n  withDbFromUrl(TEST_DATABASE_URL, fn);\n\nexport const becomeRoot = (client: PoolClient) => client.query(\"reset role\");\n\n/******************************************************************************\n **                                                                          **\n **     BELOW HERE, YOU'LL WANT TO CUSTOMISE FOR YOUR OWN DATABASE SCHEMA    **\n **                                                                          **\n ******************************************************************************/\n\n// Assuming ClientCallback is defined elsewhere, e.g.: type ClientCallback<T> = (client: PoolClient) => Promise<T>;\n// Assuming poolFromUrl is defined elsewhere, e.g.:\n/*\nconst poolFromUrl = (url: string): Pool => {\n  if (!pools[url]) {\n    pools[url] = new Pool({ connectionString: url });\n  }\n  return pools[url];\n};\n*/\n\nexport type User = {\n  id: string;\n  username: string;\n  _password?: string;\n  _email?: string;\n};\nexport type Organization = { id: string; name: string };\n\nexport const becomeUser = async (\n  client: PoolClient,\n  userOrUserId: User | string | null,\n) => {\n  await becomeRoot(client);\n  // Assuming createSession is defined elsewhere and returns { uuid: string } or similar\n  const session = userOrUserId\n    ? await createSession(\n        client,\n        typeof userOrUserId === \"object\" ? userOrUserId.id : userOrUserId,\n      )\n    : null;\n  await client.query(\n    `select set_config('role', $1::text, true),\n            set_config('jwt.claims.session_id', $2::text, true)`,\n    [process.env.DATABASE_VISITOR, session ? session.uuid : \"\"],\n  );\n};\n\n// Enables multiple calls to `createUsers` within the same test to still have\n// deterministic results without conflicts.\nlet userCreationCounter = 0;\nbeforeEach(() => {\n  userCreationCounter = 0;\n});\n\nexport const createUsers = async function createUsers(\n  client: PoolClient,\n  count: number = 1,\n  verified: boolean = true,\n) {\n  const users = [];\n  if (userCreationCounter > 25) {\n    throw new Error(\"Too many users created!\");\n  }\n  for (let i = 0; i < count; i++) {\n    const userLetter = \"abcdefghijklmnopqrstuvwxyz\"[userCreationCounter];\n    userCreationCounter++;\n    const password = userLetter.repeat(12);\n    const email = `${userLetter}${i || \"\"}@b.c`;\n    const user: User = (\n      await client.query(\n        `SELECT * FROM app_private.really_create_user(\n          username := $1,\n          email := $2,\n          email_is_verified := $3,\n          name := $4,\n          avatar_url := $5,\n          password := $6\n        )`,\n        [\n          `testuser_${userLetter}`,\n          email,\n          verified,\n          `User ${userLetter}`,\n          null,\n          password,\n        ],\n      )\n    ).rows[0];\n    expect(user.id).not.toBeNull(); // Assuming expect is available (Jest context)\n    user._email = email;\n    user._password = password;\n    users.push(user);\n  }\n  return users;\n};\n\n// Placeholder for createSession function if not defined elsewhere\n/*\nasync function createSession(client: PoolClient, userId: string): Promise<{ uuid: string }> {\n  // Implementation depends on your session management logic\n  const { rows } = await client.query('INSERT INTO app_private.sessions (user_id) VALUES ($1) RETURNING uuid', [userId]);\n  return rows[0];\n}\n*/\n\n// Placeholder for ClientCallback type if not defined elsewhere\ntype ClientCallback<T> = (client: PoolClient) => Promise<T>;\n```\n\n----------------------------------------\n\nTITLE: Registering a GraphQL Object Type with build.registerObjectType in JavaScript\nDESCRIPTION: Demonstrates using the `build.registerObjectType` method to register a new GraphQL object type named 'MyType'. It specifies a scope (`{ isMyType: true }`), a spec generator function defining fields (e.g., `meaningOfLife` using `graphql.GraphQLInt` and a `plan`), and an origin string for traceability. This is a core mechanism for adding types to the schema via Graphile Build plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/build-object.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n```js\nbuild.registerObjectType(\n  \"MyType\",\n  { isMyType: true },\n  () => {\n    return {\n      fields: {\n        meaningOfLife: {\n          type: graphql.GraphQLInt,\n          plan() {\n            return constant(42);\n          },\n        },\n      },\n    };\n  },\n  \"MyType from MyPlugin\",\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Executing a Create Mutation in PostGraphile (GraphQL)\nDESCRIPTION: Provides an example GraphQL `createUser` mutation to insert a new record into the `users` table. It specifies the input data (id, name, username) for the new user within the `input.user` object and requests specific fields (`id`, `name`, `username`, `createdAt`) of the newly created record in the response.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/crud-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n# Create a User and get back details of the record we created\nmutation {\n  createUser(\n    input: { user: { id: 1, name: \"Bilbo Baggins\", username: \"bilbo\" } }\n  ) {\n    user {\n      id\n      name\n      username\n      createdAt\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Delete Mutation by Unique Key in PostGraphile (GraphQL)\nDESCRIPTION: Presents an example GraphQL `deleteUserByUsername` mutation to remove a record from the `users` table, identified by a unique key (`username`). The input specifies the `username` of the user to delete, and the response requests the `deletedUserId` (likely the Node ID of the deleted record).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/crud-mutations.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n# Delete Bilbo using the unique user.username column and return the mutation ID\nmutation {\n  deleteUserByUsername(input: { username: \"bilbo\" }) {\n    deletedUserId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Function Arguments Using Function Name in SQL\nDESCRIPTION: Demonstrates creating a PostgreSQL function where an argument name (`id`) conflicts with a table column name (`users.id`). The conflict is resolved within the function body by prefixing the argument reference with the function's name (`get_user.id`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = get_user.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Handling Many-to-Many Relationships using Junction Table and SQL Function\nDESCRIPTION: Defines the necessary SQL structures for a many-to-many relationship between posts and authors. It creates `post` and `author` tables, and a junction table `post_author` with foreign keys referencing both `post` and `author`, and a composite primary key. A PostgreSQL function `post_authorsByPostId` is created, which accepts a `post` row (`p`) and returns a set of associated `author` rows by joining `author` and `post_author` tables based on the input post's ID. This function allows PostGraphile to expose the many-to-many relationship.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/relations.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n\ncreate table post (\n  id serial primary key,\n  headline text,\n  body text\n);\ncreate table author (\n  id serial primary key,\n  name text\n);\ncreate table post_author (\n  post_id integer references post,\n  author_id integer references author,\n  primary key (post_id, author_id)\n);\n\ncreate function \"post_authorsByPostId\"(p post)\nreturns setof author as $$\n  select author.*\n  from author\n  inner join post_author\n  on (post_author.author_id = author.id)\n  where post_author.post_id = p.id;\n$$ language sql stable;\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Case-Insensitive Search Function in PostgreSQL for GraphQL - SQL\nDESCRIPTION: Defines a SQL function 'search_posts' that returns a set of posts matching a search term in either the 'headline' or 'body' fields using the ILIKE operator for case-insensitive matches. The function is declared STABLE and returns SETOF post, making it compatible for exposure as a GraphQL connection/list. Requires a posts table and must be created in an introspected schema. Input is the 'search' string; output is a set of matching post rows. Non-optimal for large datasets due to lack of index usage on ILIKE with wildcards.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-queries.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- Columns unnecessary to this demo were omitted. You can find the full table in\n-- our forum example.\ncreate table post (\n  â€¦\n  headline         text not null,\n  body             text,\n  â€¦\n);\n\n-- Create the function named `search_posts` with a text argument named `search`.\n-- This will expose `Query.searchPosts(search: String!, ...)` to GraphQL.\ncreate function search_posts(search text)\n  -- This function will return a set of posts from the `post` table. The\n  -- `setof` part is important to PostGraphile, check out our Functions article\n  -- to learn why.\n  returns setof post as $$\n    -- Write our advanced query as a SQL query!\n    select *\n    from post\n    where\n      -- Use the `ILIKE` operator on both the `headline` and `body` columns. If\n      -- either return true, return the post.\n      headline ilike ('%' || search || '%') or\n      body ilike ('%' || search || '%')\n  -- End the function declaring the language we used as SQL and add the\n  -- `STABLE` marker so PostGraphile knows its a query and not a mutation.\n  $$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Query Fields for a Table with PostGraphile (GraphQL)\nDESCRIPTION: This GraphQL type snippet illustrates the root-level queries generated by PostGraphile for accessing user data, based on the 'users' table structure. The 'Query' type implements the Node interface and includes connection-based pagination (allUsers), unique key-based fetches (userById, userByUsername), and nodeId-based retrieval. Required dependency is a Graphile-based schema introspecting the underlying PostgreSQL database. Inputs are query arguments such as pagination predicates, orderings, and unique identifiers; outputs are user data or user connections. Limitations depend on underlying RBAC and unique constraints present in the table. This is an auto-generated representation for client queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/tables.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query implements Node {\n  allUsers(\n    first: Int\n    last: Int\n    offset: Int\n    before: Cursor\n    after: Cursor\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n    condition: UserCondition\n  ): UsersConnection\n\n  userById(id: Int!): User\n\n  userByUsername(username: String!): User\n\n  user(nodeId: ID!): User\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Custom PostgreSQL Functions via GraphQL in GraphQL\nDESCRIPTION: This block demonstrates how to invoke custom PostgreSQL functions exposed through PostGraphile as GraphQL root-level queries. It showcases the syntax for calling functions with and without arguments, and retrieving fields from row-type results. These operations require the GraphQL schema generated by PostGraphile, and expect functions matching those declared in SQL. Returned types depend on the underlying SQL function: scalars or records mapped to GraphQL types. Input arguments mirror SQL function parameters with automatic type mapping.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-queries.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  # For a function without arguments\n  myFunction\n\n  # For a function with arguments\n  myFunction(a: 1, b: 2)\n\n  # For a function that returns a row\n  myOtherFunction(a: 1, b: 2) {\n    id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Node IDs with specFromNodeId for Updates in PostGraphile V5 (JavaScript)\nDESCRIPTION: Illustrates replacing the V4 `build.getTypeAndIdentifiersFromNodeId` with the V5/Grafast `specFromNodeId` helper. This snippet shows how to obtain the Node ID handler for a specific type (`User`), use `specFromNodeId` to decode a GraphQL Node ID (`fieldArgs.$id`) into a specification object (e.g., `{id: $id}`), and then pass this specification to a Grafast step like `pgUpdateSingle` to target the correct database record for an update operation within a mutation plan.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst typeName = \"User\";\nconst handler = build.getNodeIdHandler(typeName);\n\nconst plans = {\n  Mutation: {\n    updateUser(parent, fieldArgs) {\n      const spec = specFromNodeId(handler, fieldArgs.$id);\n      const plan = object({ result: pgUpdateSingle(userSource, spec) });\n      fieldArgs.apply(plan);\n      return plan;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Table Named 'user' Using Reserved Keywords in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet shows how to create a table named 'user', which is a reserved keyword in PostgreSQL, by enclosing the name in double quotes. This step is necessary to avoid syntax errors when naming a table after a reserved word. This pattern is crucial when using non-plural or reserved names for database objects, and applies during schema definition and migrations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table \"user\" ( ... );\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Wrapper for Sorting/Filtering Non-Scalar Computed Columns\nDESCRIPTION: Provides an example of creating a primary SQL function `user_object` returning a composite type (`object`), and a wrapper function `user_object_field` that extracts a specific scalar field (`field`) from the result. The wrapper function is then annotated with `@sortable` (or could be `@filterable`) to enable sorting/filtering by this scalar field in the parent type's GraphQL schema. This pattern is used when the original computed column returns a non-scalar type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_34\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar function\nCREATE OR REPLACE FUNCTION user_object(user user) RETURNS object AS $$\nSELECT * FROM object where id = user.object_id;\n$$ language SQL STABLE;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\nCREATE OR REPLACE FUNCTION user_object_field(user user) RETURNS varchar AS $$\nSELECT (user_object(user)).field;\n$$ language SQL STABLE;\n\n-- don't forget the comments...\ncomment on function user_object_field() is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Creating Basic SELECT Policies for RLS-Enabled Tables (SQL)\nDESCRIPTION: Creates basic SELECT policies (`select_person`, `select_post`) that grant read access to all rows in the `forum_example.person` and `forum_example.post` tables. These policies use `USING (true)` which evaluates to true for all rows, effectively allowing any role with SELECT privileges on the table to see all data, counteracting the default-deny nature of enabled RLS.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_40\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy select_person on forum_example.person for select\n  using (true);\n\ncreate policy select_post on forum_example.post for select\n  using (true);\n```\n\n----------------------------------------\n\nTITLE: Complete PostGraphile HTTP Server Initialization with Node (TypeScript)\nDESCRIPTION: This full example shows all steps to initialize a PostGraphile server with Nodeâ€™s built-in HTTP module: importing configuration and dependencies, creating the PostGraphile and Grafserv instances, mounting request handlers, and listening on a specified port. Recommended for setting up a minimal yet production-ready GraphQL server using preset-driven configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\nimport { postgraphile } from \"postgraphile\";\nimport { grafserv } from \"grafserv/node\"; // Adaptor for Node's HTTP server\nimport { createServer } from \"node:http\";\n\n// Create an HTTP server (with error handler)\nconst server = createServer();\nserver.on(\"error\", (e) => console.error(e));\n\n// Create a PostGraphile instance (pgl)\nconst pgl = postgraphile(preset);\n// Create a Grafserv (server adaptor) instance for this PostGraphile instance\nconst serv = pgl.createServ(grafserv);\n// Attach a request handler to the server\nserv.addTo(server);\n\n// Start the server\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Foreign Key Indexes in PostgreSQL with SQL\nDESCRIPTION: This SQL script finds all foreign key constraints in a PostgreSQL database that do not have an associated index, which can degrade query performance. It defines a CTE for all indexed tables and their columns, then queries the constraints table to find foreign keys lacking proper indexing. No external dependencies are required outside of a working PostgreSQL installation. The input comes from database metadata, with the output being a list of tables/constraints missing indexes. It assumes access to the system catalogs and may require superuser or appropriate monitoring privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-indexes.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nwith indexed_tables as (\n  select\n      ns.nspname,\n      t.relname as table_name,\n      i.relname as index_name,\n      array_to_string(array_agg(a.attname), ', ') as column_names,\n      ix.indrelid,\n      string_to_array(ix.indkey::text, ' ')::smallint[] as indkey\n  from pg_class i\n  join pg_index ix on i.oid = ix.indrelid\n  join pg_class t on ix.indrelid = t.oid\n  join pg_namespace ns on ns.oid = t.relnamespace\n  join pg_attribute a on a.attrelid = t.oid\n  where a.attnum = any(ix.indkey)\n  and t.relkind = 'r'\n  and nspname not in ('pg_catalog')\n  group by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n  order by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n)\nselect\n  conrelid::regclass\n  ,conname\n  ,reltuples::bigint\nfrom pg_constraint pgc\njoin pg_class on (conrelid = pg_class.oid)\nwhere contype = 'f'\nand not exists(\n  select 1\n  from indexed_tables\n  where indrelid = conrelid\n  and conkey = indkey\n  or (array_length(indkey, 1) > 1 and indkey @> conkey)\n)\norder by reltuples desc;\n```\n\n----------------------------------------\n\nTITLE: Adding Field Data Generator via Graphile Builder Hook using JavaScript\nDESCRIPTION: This snippet shows how to use a Graphile Engine builder hook (`GraphQLObjectType:fields:field`) to add a data generator to a specific field. The hook intercepts the creation of fields, checks if the field is 'id' on 'MyObject', and if so, uses the `addDataGenerator` function (provided in the hook's context) to associate metadata. This approach allows for adding look-ahead information externally, for example, through a plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/look-ahead.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nfunction MyObjectAddIdDataGeneratorPlugin(builder) {\n  builder.hook(\n    \"GraphQLObjectType:fields:field\",\n    (field, _, { fieldName, Self, addDataGenerator }) => {\n      if (Self.name !== \"MyObject\" || fieldName !== \"id\") {\n        return field;\n      }\n      addDataGenerator(({ alias }) => {\n        return {\n          /* highlight-start */\n          map: (obj) => ({ [alias]: obj.ID }),\n        };\n      });\n      return field;\n    },\n    /* highlight-end */\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: NOTIFY Event for GraphQL Subscription Trigger (SQL)\nDESCRIPTION: This SQL snippet demonstrates manually broadcasting an event from PostgreSQL for a specific topic and payload using the NOTIFY command. The example is targeted for a new message creation in a forum. The topic 'forum:1:message' is the event channel and the JSON payload includes event metadata. This is typically executed via psql or a PostgreSQL client and is dependency-free, requiring only the database connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nNOTIFY \"forum:1:message\", '{\"event\": \"create\", \"sub\": 1, \"id\": 27}';\n```\n\n----------------------------------------\n\nTITLE: Basic GraphQL Mutation Operation Structure (GraphQL)\nDESCRIPTION: This snippet illustrates the minimal structure for invoking GraphQL mutation operations, as required when using the GraphiQL interface or other GraphQL clients. The 'mutation' keyword must precede the operation body; omitting it may result in interpreting the operation as a query rather than a mutation. This is mandatory for performing data modifications such as creating or updating resources in a GraphQL API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/crud-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\\n  createThing...\\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing HTTP Data to PostgreSQL with pgSettings - JavaScript\nDESCRIPTION: This snippet demonstrates configuring the PostGraphile middleware in JavaScript to inject custom variables into PostgreSQL's session using the `pgSettings` asynchronous function. It accesses properties from the incoming HTTP request (`req`), such as user session data and HTTP headers, which are then made available to PostgreSQL functions or policies through `current_setting`. Dependencies include an active Node.js environment, the PostGraphile library, and an authenticated Express or compatible HTTP server. Inputs are the request object; outputs are key-value pairs set as session variables accessible in Postgres. Values must be strings, with auto-conversion using JavaScript's String constructor if not.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nexport postgraphile(process.env.DATABASE_URL, schemaName, {\n  pgSettings: async req => ({\n    'user.id': `${req.session.passport.user}`,\n    'http.headers.x-something': `${req.headers['x-something']}`,\n    'http.method': `${req.method}`,\n    'http.url': `${req.url}`,\n    //...\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Authentication Function for JWT Generation\nDESCRIPTION: This SQL snippet defines a PostgreSQL function `my_public_schema.authenticate` that takes an email and password, verifies them against stored credentials in `my_private_schema.person_account`, and returns a record of type `my_public_schema.jwt_token` upon successful authentication. PostGraphile will automatically sign this returned record into a JWT string because the return type matches the `pgJwtTypes` configuration. The function uses `security definer` to run with the privileges of the user who defined it, allowing access to the private schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_public_schema.authenticate(\n  email text,\n  password text\n)\nreturns my_public_schema.jwt_token\nas $$\ndeclare\n  account my_private_schema.person_account;\nbegin\n  select a.* into account\n    from my_private_schema.person_account as a\n    where a.email = authenticate.email;\n\n  if account.password_hash = crypt(password, account.password_hash) then\n    return (\n      'person_role',\n      extract(epoch from now() + interval '7 days'),\n      account.person_id,\n      account.is_admin,\n      account.username\n    )::my_public_schema.jwt_token;\n  else\n    return null;\n  end if;\nend;\n$$ language plpgsql strict security definer;\n```\n\n----------------------------------------\n\nTITLE: Planning Composite Type Union Polymorphism with pgPolymorphic Â· TypeScript\nDESCRIPTION: Implements polymorphic resource resolution where the union specifier is a tuple of nullable IDs using 'pgPolymorphic'. The mapping object defines how to match and resolve entities for each variant based on which index is set. This approach is suitable for composite-type based polymorphic columns or function results, requiring resources and helpers like 'list' and 'pgPolymorphic'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst entityTypeMap = {\n  Person: {\n    match: (specifier) => specifier[0] != null,\n    plan: ($specifier) => personResource.get({ person_id: $specifier.at(0) }),\n  },\n  Post: {\n    match: (specifier) => specifier[1] != null,\n    plan: ($specifier) => postResource.get({ post_id: $specifier.at(1) }),\n  },\n  Comment: {\n    match: (specifier) => specifier[2] != null,\n    plan: ($specifier) => commentResource.get({ comment_id: $specifier.at(2) }),\n  },\n};\n\nconst plans = {\n  PersonBookmark: {\n    bookmarkedEntity($bookmark) {\n      const $item = $bookmark.get(\"bookmarked_entity\");\n      const $specifier = list([\n        $item.get(\"person_id\"),\n        $item.get(\"post_id\"),\n        $item.get(\"comment_id\"),\n      ]);\n      return pgPolymorphic($item, $specifier, entityTypeMap);\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic `registerUser` Mutation with Graphile Crystal (TypeScript)\nDESCRIPTION: This TypeScript code defines a Graphile Crystal plugin (`RegisterUserPlugin`) using `makeExtendSchemaPlugin` to add a `registerUser` mutation. The mutation attempts user and email insertion within a PostgreSQL transaction via `withPgClient` and `pgClient.withTransaction`. It specifically catches unique constraint violations (Postgres error code '23505') for username and email, returning custom error types (`UsernameConflict`, `EmailAddressConflict`). Successful registration returns the user's ID. The payload resolver uses `polymorphicBranch` to map the transaction result to the appropriate GraphQL type (`User`, `UsernameConflict`, or `EmailAddressConflict`). Dependencies include `@dataplan/pg`, `graphile-utils`, `postgraphile/grafast`, and `pg`. A placeholder `sendEmail` function is included.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { withPgClient } from \"@dataplan/pg\";\nimport { gql, makeExtendSchemaPlugin } from \"graphile-utils\";\nimport {\n  ObjectStep,\n  constant,\n  object,\n  ExecutableStep,\n  access,\n  polymorphicBranch,\n  list,\n} from \"postgraphile/grafast\";\nimport { DatabaseError } from \"pg\";\n\nexport const RegisterUserPlugin = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n  return {\n    typeDefs: gql`\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n\n      input RegisterUserInput {\n        username: String!\n        email: String!\n      }\n\n      type RegisterUserPayload {\n        result: RegisterUserResult\n        query: Query\n      }\n\n      union RegisterUserResult = User | UsernameConflict | EmailAddressConflict\n\n      type UsernameConflict {\n        message: String!\n        username: String!\n      }\n\n      type EmailAddressConflict {\n        message: String!\n        email: String!\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, { $input: { $username, $email } }) {\n          const $result = withPgClient(\n            executor,\n            list([$username, $email]),\n            async (pgClient, [username, email]) => {\n              try {\n                return await pgClient.withTransaction(async (pgClient) => {\n                  const {\n                    rows: [user],\n                  } = await pgClient.query<{\n                    id: string;\n                    username: string;\n                  }>({\n                    text: `\n                      insert into app_public.users (username)\n                      values ($1)\n                      returning *`,\n                    values: [username],\n                  });\n\n                  await pgClient.query({\n                    text: `\n                      insert into app_public.user_emails(user_id, email)\n                      values ($1, $2)`,\n                    values: [user.id, email],\n                  });\n\n                  await sendEmail(email, \"Welcome!\");\n\n                  return { id: user.id };\n                });\n              } catch (e) {\n                if (e instanceof DatabaseError && e.code === \"23505\") {\n                  if (e.constraint === \"unique_user_username\") {\n                    return {\n                      __typename: \"UsernameConflict\",\n                      message: `The username '${username}' is already in use`,\n                      username,\n                    };\n                  } else if (e.constraint === \"unique_user_email\") {\n                    return {\n                      __typename: \"EmailAddressConflict\",\n                      message: `The email address '${email}' is already in use`,\n                      email,\n                    };\n                  }\n                }\n                throw e;\n              }\n            },\n          );\n\n          return object({ result: $result });\n        },\n      },\n\n      RegisterUserPayload: {\n        __assertStep: ObjectStep,\n        result($data: ObjectStep) {\n          const $result = $data.get(\"result\");\n          return polymorphicBranch($result, {\n            UsernameConflict: {\n              // This is a `UsernameConflict` if the object has a `__typename` property.\n              match(obj) {\n                return obj.__typename === \"UsernameConflict\";\n              },\n              // In this case, we can just return the object itself as the step\n              // representing this polymorphic branch.\n              plan($obj) {\n                return $obj;\n              },\n            },\n            EmailAddressConflict: {\n              // If `match` is not specified, it defaults to checking\n              // `obj.__typename === 'EmailAddressConfict'`.\n              // If `plan` is not specified, it defaults to `($obj) => $obj`.\n            },\n            User: {\n              match(obj) {\n                return obj.id != null;\n              },\n              // In this case, we need to get the record from the database\n              // associated with the given user id.\n              plan($obj) {\n                const $id = access($obj, \"id\");\n                return users.get({ id: $id });\n              },\n            },\n          });\n        },\n        query() {\n          // The `Query` type just needs any truthy value.\n          return constant(true);\n        },\n      },\n\n      UsernameConflict: {\n        // Since User expects a step, our types must also expect a step. We\n        // don't care what the step is though.\n        __assertStep: ExecutableStep,\n      },\n      EmailAddressConflict: {\n        __assertStep: ExecutableStep,\n      },\n    },\n  };\n});\n\nasync function sendEmail(email: string, message: string) {\n  /*\n    Write your email-sending logic here. Note that we recommend you enqueue a\n    job to send the email rather than sending it directly; if you don't already\n    have a job queue then check out https://worker.graphile.org\n  */\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Soft-Deleting an Item by Node ID with Permission Check using PostGraphile in JavaScript\nDESCRIPTION: This snippet creates a custom mutation for soft-deleting an item from the 'app_public.items' table, protected by an ownership (user_id) constraint, using a GraphQL global node ID for identification. It uses PostGraphile's plugin system to define input, output, resolver logic, and transactional rollback in case of errors. Dependencies include PostGraphile, a valid 'pgClient', 'jwtClaims' in context, and a schema with soft-delete support. Input is a node ID and output is a boolean success flag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst DeleteItemByNodeIdPlugin = makeExtendSchemaPlugin((build) => {\n  const typeDefs = gql`\n    input DeleteItemInput {\n      nodeId: ID!\n    }\n    type DeleteItemPayload {\n      success: Boolean\n    }\n    extend type Mutation {\n      deleteItem(input: DeleteItemInput!): DeleteItemPayload\n    }\n  `;\n\n  const resolvers = {\n    Mutation: {\n      deleteItem: async (_query, args, context) => {\n        // jwtClaims is decrypted jwt token data\n        const { pgClient, jwtClaims } = context;\n\n        // Decode the node ID\n        const { Type, identifiers } = build.getTypeAndIdentifiersFromNodeId(\n          args.input.nodeId,\n        );\n\n        // Check it applies to our type\n        if (Type !== build.getTypeByName(\"Item\")) {\n          throw new Error(\"Invalid nodeId for Item\");\n        }\n\n        // Assuming there's a single primary-key column, the PK will\n        // be the first and only entry in identifiers.\n        const itemId = identifiers[0];\n\n        // All mutations that issue SQL must be wrapped in savepoints\n        await pgClient.query(\"SAVEPOINT graphql_mutation\");\n\n        try {\n          const { rowCount } = await pgClient.query(\n            `UPDATE app_public.items SET is_archived = true\n              WHERE id = $1\n              AND user_id = $2;`,\n            [itemId, jwtClaims.user_id],\n          );\n\n          return {\n            success: rowCount === 1,\n          };\n        } catch (e) {\n          await pgClient.query(\"ROLLBACK TO SAVEPOINT graphql_mutation\");\n          throw e;\n        } finally {\n          await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n        }\n      },\n    },\n  };\n\n  return {\n    typeDefs,\n    resolvers,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Inserting Multiple Records with Custom Mutation (SQL)\nDESCRIPTION: Defines a custom PostgreSQL type 'quiz_entry_input' for input, and a plpgsql function 'add_quiz_entry' that inserts a quiz entry and multiple answers atomically for a given quiz. The function takes a quiz ID and an array of answer records, creates a quiz entry for the current user, and iterates over the array, inserting each answer linked to the new entry. Returns the inserted quiz entry row. Dependencies: the user context function 'current_user_id()', existing 'quiz_entry' and 'quiz_entry_answer' tables, and the type 'quiz_entry_input'. Intended for use as a GraphQL mutation via PostGraphile. Input is quiz_id and an array of quiz_entry_input records; output is a quiz_entry row.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n/**\n * Occasionally you'll want to create a bunch of rows in different tables in a\n * single mutation. Here's an example of how to do that.\n *\n * Pretend we're registering quiz entries, and we want to store each answer in\n * its own table as we want to be able to operate on the answers independently\n * later.\n *\n * This means we want:\n *\n *  1. A mutation that takes input data for inserting one quiz entry and\n *  multiple answers.\n *  2. A function that inserts a new quiz entry, inserts an answer for each\n *  answer provided in the input data, and connects each answer to the created\n *  quiz entry.\n *  3. Finally, we want the function to return the inserted quiz entry itself.\n */\n\n/**\n * This type is used for input in the mutation\n */\ncreate type quiz_entry_input as (\n  question text,\n  answer int\n);\n\n/**\n * Here's the function that gets turned into a \"custom mutation\"\n */\ncreate function add_quiz_entry(\n  quiz_id int,\n  answers quiz_entry_input[]\n)\nreturns quiz_entry\nas $$\n  declare\n    q quiz_entry;\n    a quiz_entry_answer;\n  begin\n    insert into quiz_entry(user_id, quiz_id)\n      values(current_user_id(), quiz_id)\n      returning * into q;\n\n    foreach a in array answers loop\n      insert into quiz_entry_answer(quiz_entry_id, question, answer)\n        values (quiz_id, a.question, a.answer);\n    end loop;\n\n    return q;\n  end;\n$$ language plpgsql volatile strict set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Defining a Row-Level Security Policy using JWT Claims in SQL\nDESCRIPTION: This SQL snippet demonstrates creating a PostgreSQL Row-Level Security (RLS) policy named `update_if_author` on the `comments` table. This policy restricts `UPDATE` operations, allowing a row to be updated only if the `userId` column of that row matches the ID returned by the `current_user_id()` function (which retrieves the user ID from the JWT claims set in the session). Both the `USING` (rows visible) and `WITH CHECK` (rows that can be created/updated) clauses enforce this condition.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy update_if_author\n  on comments\n  for update\n  using (\"userId\" = current_user_id())\n  with check (\"userId\" = current_user_id());\n```\n\n----------------------------------------\n\nTITLE: Executing Typed GraphQL Documents with Type Safety in TypeScript\nDESCRIPTION: Presents a type-safe function for executing GraphQL operations where the input can be a TypedDocumentNode, often generated by graphql-codegen. The function validates the document, prepares execution arguments, and returns a strongly-typed response matching the query. Prerequisites are TypeScript, postgraphile, grafast, GraphQL typings, and optionally '@graphql-typed-document-node/core'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport type { DocumentNode, ExecutionResult } from \"postgraphile/graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { postgraphile } from \"postgraphile\";\nimport { execute, hookArgs } from \"postgraphile/grafast\";\nimport { validate } from \"postgraphile/graphql\";\nimport preset from \"./graphile.config.js\";\n\nconst pgl = postgraphile(preset);\n\nexport async function executeDocument<TData = any, TVariables = any>(\n  requestContext: Partial<Grafast.RequestContext>,\n  document: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n): Promise<ExecutionResult<TData, TVariables>> {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n\n  // Validate the GraphQL document against the schema:\n  const errors = validate(schema, document);\n  if (errors.length > 0) {\n    return { errors };\n  }\n\n  // Prepare the execution arguments:\n  const args = await hookArgs({\n    schema,\n    document,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n\n  // Execute the request using Grafast:\n  const result = await execute(args);\n\n  // Cast the result to the types implied by the TypedDocumentNode:\n  return result as ExecutionResult<TData, TVariables>;\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient SQL RLS Policy Check Using Set-Based Function\nDESCRIPTION: Presents an optimized approach for RLS in PostgreSQL. It defines a function (`current_user_organization_ids`) that returns the set of organization IDs the current user belongs to. The RLS policy on the `posts` table then efficiently filters rows by checking if the `organization_id` is `IN` the set returned by this function, allowing for better index usage and performance compared to per-row function calls. This function only needs to be called once per query.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user_organization_ids()\nreturns setof int as $$\n  select organization_id\n  from organization_members om\n  where om.user_id = current_user_id()\n$$ language sql stable;\n\ncreate policy select_my_organizations\n  for select on posts\n  using (organization_id IN (select current_user_organization_ids()));\n```\n\n----------------------------------------\n\nTITLE: Adding Root Query Field using makeExtendSchemaPlugin (TypeScript)\nDESCRIPTION: This snippet demonstrates defining a Graphile Build plugin using the `makeExtendSchemaPlugin` utility from `postgraphile/utils`. It adds a new root query field `httpBinHeaders` of type `JSON` by extending the `Query` type. The resolver for this field fetches data from 'https://httpbin.org/headers' using `node-fetch` and returns the JSON response. This is presented as the easier way to add root-level fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending-raw.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport fetch from \"node-fetch\";\n\nexport default makeExtendSchemaPlugin({\n  typeDefs: gql`\n    extend type Query {\n      httpBinHeaders: JSON\n    }\n  `,\n  resolvers: {\n    Query: {\n      async httpBinHeaders() {\n        const response = await fetch(\"https://httpbin.org/headers\");\n        return response.json();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Trigger for Message Insertion Events (SQL)\nDESCRIPTION: Adds a database trigger that uses the generic GraphQL subscription trigger function to emit events on message insertions. Specifies the event type as 'create', the topic template as 'forum:$1:message', and substitutes the NEW.forum_id for $1. Requires prior creation of the tg__graphql_subscription() function and PostgreSQL privileges. The trigger fires after each insert on 'messages', sending an event to the relevant channel.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\ncreate trigger _500_gql_insert\n  after insert on messages\n  for each row\n  execute function tg__graphql_subscription(\n    'create', -- the \"event\" string, useful for the client to know what happened\n    'forum:$1:message', -- the \"topic\" the event will be published to, as a template\n    'forum_id' -- If specified, `$1` above will be replaced with NEW.forum_id or OLD.forum_id from the trigger.\n  );\n```\n\n----------------------------------------\n\nTITLE: Custom Plugin to Make Forward Relation Fields Non-Nullable (TypeScript)\nDESCRIPTION: This TypeScript code defines a GraphileConfig.Plugin for PostGraphile that changes forward relation fields to be non-nullable when all participating columns are not null and the field is not a referencee. It hooks GraphQLObjectType_fields_field, checks context for relation details, and conditionally wraps types with GraphQLNonNull. Requires PostGraphile, GraphileConfig, and a PostGraphile build context. Inputs are field and context, outputs a potentially updated field definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst NonNullRelationsPlugin: GraphileConfig.Plugin = {\n  name: \"NonNullRelationsPlugin\",\n  description:\n    \"Makes foreign key fields non-nullable if their columns are all `not null`\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      // Hook a field that has already been defined\n      GraphQLObjectType_fields_field(field, build, context) {\n        const {\n          graphql: { GraphQLNonNull, getNullableType },\n          input: { pgRegistry },\n        } = build;\n        // Extract details about why this field was defined.\n        const { isPgSingleRelationField, pgRelationDetails } = context.scope;\n        // See if the field was defined for a singular relation\n        if (isPgSingleRelationField && pgRelationDetails) {\n          // If so, extract details about the relation\n          const { codec, relationName } = pgRelationDetails;\n          // Look up the relation in the registry\n          const relation = pgRegistry.pgRelations[codec.name][relationName];\n          // Determine if every column is non-null\n          const everyColumnIsNonNull = relation.localAttributes.every(\n            (attrName) => codec.attributes[attrName].notNull,\n          );\n          if (!relation.isReferencee && everyColumnIsNonNull) {\n            // If so, change the type of the field to be non-nullable\n            field.type = new GraphQLNonNull(getNullableType(field.type));\n          }\n        }\n        return field;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Chat Message Events with GraphQL using JavaScript\nDESCRIPTION: This snippet demonstrates how to define a GraphQL subscription operation in JavaScript, allowing clients to listen for new chat messages being added to a specific channel (e.g., channel 27). The subscription returns the message id, message text, author data (including id, name, and avatarUrl), and a timestamp for each new event. This example requires a GraphQL client that supports subscriptions, such as Apollo Client, and a compatible backend configured for supporting subscription queries. Inputs include a 'channel' argument; outputs are objects describing the new message event. The operation does not trigger on edits or other changes, only on new message additions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/realtime.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nsubscription {\n  chatMessageAdded(channel: 27) {\n    id\n    message\n    author { id name avatarUrl }\n    timestamp\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Plugin with Gra*fast* Plan Resolvers (TypeScript)\nDESCRIPTION: Provides a full example of a PostGraphile schema extension plugin. It defines a new `Query.myChannels` field and implements its plan resolver using Gra*fast* steps to fetch the user ID from context, find the user, get their organization ID, and finally find channels belonging to that organization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context } from \"postgraphile/grafast\";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { users, channels } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get(\"userId\");\n          const $user = users.get({ id: $userId });\n          const $orgId = $user.get(\"organization_id\");\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Defining One-to-Many Relationship Schema in SQL\nDESCRIPTION: Sets up an example database schema with two schemas (`a` and `c`) for demonstrating a one-to-many relationship. It creates a `person` table in schema `c` and a `post` table in schema `a`. The `post` table includes an `author_id` column which references the `id` column of the `c.person` table, establishing the foreign key relationship. An index is created on `a.post(author_id)` to optimize joins based on this relationship.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/relations.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema a;\ncreate schema c;\n\ncreate table c.person (\n  id serial primary key,\n  name varchar not null,\n  about text,\n  email varchar not null unique,\n  created_at timestamp default current_timestamp\n);\n\ncreate table a.post (\n  id serial primary key,\n  headline text not null,\n  body text,\n  -- `references` ðŸ‘‡  sets up the foreign key relation\n  author_id int4 references c.person(id)\n);\ncreate index on a.post (author_id);\n```\n\n----------------------------------------\n\nTITLE: Optimized RLS Policy Using Set-Based Filtering in SQL\nDESCRIPTION: Illustrates an optimized PostgreSQL RLS policy for the 'posts' table. It defines a function `current_user_organization_ids` that returns the set of all organization IDs the current user belongs to. The RLS policy `select_my_organizations` then efficiently filters posts by checking if the post's `organization_id` is `IN` this pre-fetched set, avoiding expensive per-row function calls. This is the recommended, more performant approach, allowing the database to use indexes effectively.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"Much better\"\ncreate function current_user_organization_ids()\nreturns setof int as $$\n  select organization_id\n  from organization_members om\n  where om.user_id = current_user_id()\n$$ language sql stable;\n\ncreate policy select_my_organizations\n  for select on posts\n  using (organization_id IN (select current_user_organization_ids()));\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function with Named Arguments (SQL)\nDESCRIPTION: Defines a PostgreSQL function `add` using `LANGUAGE sql` with named integer arguments (`a` and `b`). These names are used directly within the function body (`select a + b`). This is the recommended style for clarity and ensures predictable argument names in the resulting GraphQL schema generated by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  select a + b;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column using Smart Comments in SQL\nDESCRIPTION: Applies a `COMMENT` to the `my_column` column within `my_schema.my_table`. The `@deprecated` smart tag in the comment adds a deprecation reason ('Use myOtherColumn instead.') to the corresponding field in the GraphQL schema generated by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\n  E'@deprecated Use myOtherColumn instead.';\n```\n\n----------------------------------------\n\nTITLE: Securing Data Access with Views (SQL)\nDESCRIPTION: This SQL code secures sensitive user data by defining a 'personal_data_view' with the 'security_barrier' and 'check_option = cascaded' options. It ensures only rows matching the current authenticated user's ID are shown, using a special function 'current_user_id()'. Dependencies include a 'current_user_id()' function and the 'app_public' schema. Inputs are personal_data and person tables; output is a filtered view limited by user identity. Take care to implement the user-id function securely.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/views.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.person (\n  id serial primary key\n);\n\ncreate table app_public.personal_data (\n  id serial primary key,\n  secret1 text,\n  secret2 int,\n  person_id references app_public.person (id)\n);\n\ncreate view personal_data_view\n  with (security_barrier, check_option = 'cascaded')\n  as\n    select personal_data.*\n    from app_public.personal_data personal_data\n    where person_id = current_user_id()\n```\n\n----------------------------------------\n\nTITLE: Wrapping Individual GraphQL Field Resolvers Using makeWrapPlansPlugin (TypeScript)\nDESCRIPTION: This snippet demonstrates creating a schema plugin by passing a rules object to makeWrapPlansPlugin. The plugin wraps specific field resolvers, such as converting a user's email to lowercase in the resolver result. Required dependencies are the makeWrapPlansPlugin function from \"postgraphile/utils\" and the lambda helper from \"postgraphile/grafast\". Inputs include the rules object specifying which type/field pairs to wrap. Output is a customized PostGraphile plugin for field-level value transformation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\\nimport { lambda } from \"postgraphile/grafast\";\\n\\nexport default makeWrapPlansPlugin({\\n  User: {\\n    email(plan) {\\n      const $email = plan();\\n      return lambda($email, (email) => email.toLowerCase());\\n    },\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Wrapping All GraphQL Mutation Resolvers Matching a Filter (TypeScript)\nDESCRIPTION: This snippet shows how to universally wrap all mutation resolvers by defining a filter function that matches root mutation fields and an associated rule for logging execution context. Dependencies include makeWrapPlansPlugin and sideEffect from PostGraphile. The method takes a context, build, and field and injects before/after logging on mutation execution and results. This supports audit, debugging, or monitoring needs for all matched mutations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\\nimport { sideEffect } from \"postgraphile/grafast\";\\n\\n// Example: log before and after each mutation runs\\nexport default makeWrapPlansPlugin(\\n  (context) => {\\n    if (context.scope.isRootMutation) {\\n      return { scope: context.scope };\\n    }\\n    return null;\\n  },\\n  ({ scope }) =>\\n    (plan, _, fieldArgs) => {\\n      sideEffect(fieldArgs.getRaw(), (args) => {\\n        console.log(\\n          `Mutation '${scope.fieldName}' starting with arguments:`,\\n          args,\\n        );\\n      });\\n\\n      const $result = plan();\\n\\n      sideEffect($result, (result) => {\\n        console.log(`Mutation '${scope.fieldName}' result:`, result);\\n      });\\n\\n      return $result;\\n    },\\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Row-Level Policy Using JWT-Based User ID in PostgreSQL - SQL\nDESCRIPTION: Defines a PostgreSQL RLS policy 'update_if_author' for the 'comments' table, restricting UPDATEs to only those rows where '\"userId\"' matches 'current_user_id()'. Requires RLS enabled on table, the 'current_user_id' function available, and correct JWT setup. Ensures users can only modify their own comments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy update_if_author\n  on comments\n  for update\n  using (\"userId\" = current_user_id())\n  with check (\"userId\" = current_user_id());\n```\n\n----------------------------------------\n\nTITLE: Recommended Production Configuration for PostGraphile CLI - Bash\nDESCRIPTION: Configures the PostGraphile CLI for production with robust options for stability, logging, error reporting, and performance. It includes flags for resilient startup, disables unnecessary developer tools, and assumes that a permanent logging system is in place. The command requires $DATABASE_URL to be set and serves the 'app_public' schema. Most developer-centric and introspection endpoints are disabled for security and performance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --subscriptions \\\n  --retry-on-init-fail \\\n  --dynamic-json \\\n  --no-setof-functions-contain-nulls \\\n  --no-ignore-rbac \\\n  --extended-errors errcode \\\n  --append-plugins @graphile-contrib/pg-simplify-inflector \\\n  --disable-graphiql \\\n  --enable-query-batching \\\n  --disable-query-log \\\\ # our default logging has performance issues, but do make sure you have a logging system in place!\n  --legacy-relations omit \\\n  --connection $DATABASE_URL \\\n  --schema app_public\n```\n\n----------------------------------------\n\nTITLE: Generating a List of Objects using `each` in Graphile Crystal (TypeScript)\nDESCRIPTION: Illustrates transforming items in a list step (`$list`) into a new list of structured objects. It uses the `each` function along with the `object` helper and the `.get()` method on the item step (`$item`) to map original properties (`name`, `x`, `y`) to new attributes (`name`, `lng`, `lat`). The result is assigned to `$derivatives` and returned.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/each.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst $derivatives = each($list, ($item) =>\n  object({\n    name: $item.get(\"name\"),\n    lng: $item.get(\"x\"),\n    lat: $item.get(\"y\"),\n  }),\n);\nreturn $derivatives;\n```\n\n----------------------------------------\n\nTITLE: Disabling V4 Table Name Node Identifier in PostGraphile V5 Schema (JavaScript)\nDESCRIPTION: Shows how to configure the PostGraphile V5 preset to disable the V4 behavior of using table names for node identifiers, effectively replacing the functionality of the removed `PgNodeAliasPostGraphile` plugin. This setting is applied within the `schema` configuration block of the preset object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst preset = {\n  // ...\n  schema: {\n    // ...\n    pgV4UseTableNameForNodeIdentifier: false,\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Name and Result Field using Smart Comments in SQL\nDESCRIPTION: Applies a `COMMENT` to the `authenticate` function. It uses the `@resultFieldName` smart tag to name the output field in the mutation payload `token` and the `@name` tag to rename the mutation itself to `login` in the PostGraphile GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function authenticate(text, text) is\n  E'@resultFieldName token\\n@name login';\n```\n\n----------------------------------------\n\nTITLE: Creating a Scalar Computed Column Function in PostgreSQL (SQL)\nDESCRIPTION: Defines a PostgreSQL function, following Graphile conventions, for a table 'person', combining two fields into a computed scalar field ('full_name'). Required dependency is an existing 'person' table with 'given_name' and 'family_name' columns. The function takes a single row as an argument, returns a text value, must be created as STABLE, and will show up as a field in GraphQL through Graphile. Expects a 'person' row and outputs a single string; does not support sets or multiple return values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function person_full_name(person person) returns text as $$\n  select person.given_name || ' ' || person.family_name\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Querying with condition Enabled by @filterable in GraphQL\nDESCRIPTION: Illustrates querying fields in GraphQL enabled by the `@filterable` smart comment in SQL. It shows using the `condition` argument on fields derived from `SETOF` functions (`foo(condition: {firstName: \"Alice\"})`) and using computed column functions returning scalars as filter criteria within the parent type's `condition` argument (`allUsers(condition: {foo: \"FOO_VALUE\"})`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_33\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(condition: {firstName: \"Alice\"}) { ... }\n\n  # If the function return a scalar\n  allUsers(condition: {foo: \"FOO_VALUE\"}) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Role from JWT Claim - SQL\nDESCRIPTION: This snippet demonstrates how to set the PostgreSQL session role based on the 'role' claim from a JWT. It uses the 'SET LOCAL ROLE' command, allowing the database session to perform authorization checks as the correct user role. This requires that the database session has been initialized and that 'role' is a valid claim in the JWT and a valid PostgreSQL role. The value for $role must be properly sanitized and quoted if necessary. No output is produced; it affects the session context for the transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nset local role $role;\n```\n\n----------------------------------------\n\nTITLE: Extending Existing Graphile Config Scope Options in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to add a custom configuration option (`myNewConfigOption`) to an existing Graphile Config scope (`WorkerOptions`) using declaration merging. This allows plugins to introduce new settings within predefined configuration structures.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare global {\n  namespace GraphileConfig {\n    interface WorkerOptions {\n      myNewConfigOption?: string;\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing PostGraphile Integration Test Helpers (TypeScript)\nDESCRIPTION: This comprehensive helper module, written in TypeScript, establishes an integration testing environment for PostGraphile. It includes `setup` and `teardown` functions for managing resources like the database connection pool and GraphQL schema. The `runGraphQLQuery` function executes queries within a database transaction, mocking HTTP requests and handling PostGraphile context, allowing assertions and snapshot testing before rolling back changes. A `sanitize` function aids snapshot testing by masking dynamic values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { Request, Response } from \"express\";\nimport { ExecutionResult, graphql, GraphQLSchema } from \"graphql\";\nimport { Pool, PoolClient } from \"pg\";\nimport {\n  createPostGraphileSchema,\n  PostGraphileOptions,\n  withPostGraphileContext,\n} from \"postgraphile\";\n\nimport { getPostGraphileOptions } from \"../src/middleware/installPostGraphile\";\n\nconst MockReq = require(\"mock-req\");\n\nlet known: Record<string, { counter: number; values: Map<unknown, string> }> =\n  {};\nbeforeEach(() => {\n  known = {};\n});\n/*\n * This function replaces values that are expected to change with static\n * placeholders so that our snapshot testing doesn't throw an error\n * every time we run the tests because time has ticked on in it's inevitable\n * march toward the future.\n */\nexport function sanitize(json: any): any {\n  /* This allows us to maintain stable references whilst dealing with variable values */\n  function mask(value: unknown, type: string) {\n    if (!known[type]) {\n      known[type] = { counter: 0, values: new Map() };\n    }\n    const o = known[type];\n    if (!o.values.has(value)) {\n      o.values.set(value, `[${type}-${++o.counter}]`);\n    }\n    return o.values.get(value);\n  }\n\n  if (Array.isArray(json)) {\n    return json.map((val) => sanitize(val));\n  } else if (json && typeof json === \"object\") {\n    const result = { ...json };\n    for (const k in result) {\n      if (k === \"nodeId\" && typeof result[k] === \"string\") {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (\n        k === \"id\" ||\n        k === \"uuid\" ||\n        (k.endsWith(\"Id\") &&\n          (typeof json[k] === \"number\" || typeof json[k] === \"string\")) ||\n        (k.endsWith(\"Uuid\") && typeof k === \"string\")\n      ) {\n        result[k] = mask(result[k], \"id\");\n      } else if (\n        (k.endsWith(\"At\") || k === \"datetime\") &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"timestamp\");\n      } else if (\n        k.match(/^deleted[A-Za-z0-9]+Id$/) &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (k === \"email\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"email\");\n      } else if (k === \"username\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"username\");\n      } else {\n        result[k] = sanitize(json[k]);\n      }\n    }\n    return result;\n  } else {\n    return json;\n  }\n}\n\n// Contains the PostGraphile schema and rootPgPool\ninterface ICtx {\n  rootPgPool: Pool;\n  options: PostGraphileOptions<Request, Response>;\n  schema: GraphQLSchema;\n}\nlet ctx: ICtx | null = null;\n\nexport const setup = async () => {\n  const rootPgPool = new Pool({\n    connectionString: process.env.TEST_DATABASE_URL,\n  });\n\n  const options = getPostGraphileOptions({ rootPgPool });\n  const schema = await createPostGraphileSchema(\n    rootPgPool,\n    \"app_public\",\n    options,\n  );\n\n  // Store the context\n  ctx = {\n    rootPgPool,\n    options,\n    schema,\n  };\n};\n\nexport const teardown = async () => {\n  try {\n    if (!ctx) {\n      return null;\n    }\n    const { rootPgPool } = ctx;\n    ctx = null;\n    rootPgPool.end();\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\nexport const runGraphQLQuery = async function runGraphQLQuery(\n  query: string, // The GraphQL query string\n  variables: { [key: string]: any } | null, // The GraphQL variables\n  reqOptions: { [key: string]: any } | null, // Any additional items to set on `req` (e.g. `{user: {id: 17}}`)\n  checker: (\n    result: ExecutionResult,\n    context: { pgClient: PoolClient },\n  ) => void | ExecutionResult | Promise<void | ExecutionResult> = () => {}, // Place test assertions in this function\n) {\n  if (!ctx) throw new Error(\"No ctx!\");\n  const { schema, rootPgPool, options } = ctx;\n  const req = new MockReq({\n    url: options.graphqlRoute || \"/graphql\",\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    ...reqOptions,\n  });\n  const res: any = { req };\n  req.res = res;\n\n  const {\n    pgSettings: pgSettingsGenerator,\n    additionalGraphQLContextFromRequest,\n  } = options;\n  const pgSettings =\n    (typeof pgSettingsGenerator === \"function\"\n      ? await pgSettingsGenerator(req)\n      : pgSettingsGenerator) || {};\n\n  // Because we're connected as the database owner, we should manually switch to\n  // the authenticator role\n  if (!pgSettings.role) {\n    pgSettings.role = process.env.DATABASE_AUTHENTICATOR;\n  }\n\n  await withPostGraphileContext(\n    {\n      ...options,\n      pgPool: rootPgPool,\n      pgSettings,\n      pgForceTransaction: true,\n    },\n    async (context) => {\n      let checkResult;\n      const { pgClient } = context;\n      try {\n        // This runs our GraphQL query, passing the replacement client\n        const additionalContext = additionalGraphQLContextFromRequest\n          ? await additionalGraphQLContextFromRequest(req, res)\n          : null;\n        const result = await graphql(\n          schema,\n          query,\n          null,\n          {\n            ...context,\n            ...additionalContext,\n            __TESTING: true,\n          },\n          variables,\n        );\n        // Expand errors\n        if (result.errors) {\n          if (options.handleErrors) {\n            result.errors = options.handleErrors(result.errors);\n          } else {\n            // This does a similar transform that PostGraphile does to errors.\n            // It's not the same. Sorry.\n            result.errors = result.errors.map((rawErr) => {\n              const e = Object.create(rawErr);\n              Object.defineProperty(e, \"originalError\", {\n                value: rawErr.originalError,\n                enumerable: false,\n              });\n\n              if (e.originalError) {\n                Object.keys(e.originalError).forEach((k) => {\n                  try {\n                    e[k] = e.originalError[k];\n                  } catch (err) {\n                    // Meh.\n                  }\n                });\n              }\n              return e;\n            });\n          }\n        }\n\n        // This is were we call the `checker` so you can do your assertions.\n        // Also note that we pass the `replacementPgClient` so that you can\n        // query the data in the database from within the transaction before it\n        // gets rolled back.\n        checkResult = await checker(result, {\n          pgClient,\n        });\n\n        // You don't have to keep this, I just like knowing when things change!\n        expect(sanitize(result)).toMatchSnapshot();\n\n        return checkResult == null ? result : checkResult;\n      } finally {\n        // Rollback the transaction so no changes are written to the DB - this\n        // makes our tests fairly deterministic.\n        await pgClient.query(\"rollback\");\n      }\n    },\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Building a \"myChannels\" Field Plugin Using withPgClient for Custom SQL (TypeScript)\nDESCRIPTION: This is a full-featured PostGraphile plugin example that constructs a Query.myChannels field, but instead of using table joins, it retrieves organization_id via a custom SQL function using withPgClient. Dependencies include 'postgraphile/utils', 'postgraphile/grafast', and 'postgraphile/@dataplan/pg'. Key parameters are userId (from context), the executor (from pgExecutors or resource), and the SQL function name. Input is the GraphQL execution context; output is a PgSelectStep representing matched channels. The plugin ensures compatibility with the surrounding GraphQL schema and can be adapted for different custom SQL needs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context } from \"postgraphile/grafast\";\n// highlight-next-line\nimport { withPgClient } from \"postgraphile/@dataplan/pg\";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { channels } = build.input.pgRegistry.pgResources;\n  const executor = build.input.pgRegistry.pgExecutors.main;\n  // or: `const executor = channels.executor;`\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get(\"userId\");\n          // highlight-start\n          const $orgId = withPgClient(\n            executor,\n            $userId,\n            async (\n              // The PgClient instance, with all of the \"claims\" (if any) already set:\n              pgClient,\n              // This is the runtime data that the `$userId` step represented\n              userId,\n            ) => {\n              if (!userId) return null;\n\n              // Here we're using the standard `pgClient.query` function that\n              // all adaptors must provide, but if you're using an adaptor\n              // related to your ORM of choice, you could likely use its\n              // various methods to retrieve this value instead.\n              const result = await pgClient.query<{ id: number }>({\n                text: `select id from get_organization_for_user_id($1)`,\n                values: [userId],\n              });\n\n              // Return the 'id' value from the first (and only) row, if it exists:\n              return result.rows[0]?.id;\n            },\n          );\n          // highlight-end\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile (Beta) via npm using Bash\nDESCRIPTION: Installs the beta version of the `postgraphile` Node.js package locally within the current project directory using the Node Package Manager (npm). The `--save` flag (often implicit in modern npm versions) adds `postgraphile` as a dependency in the project's `package.json` file. Requires Node.js and npm.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save postgraphile@beta\n```\n\n----------------------------------------\n\nTITLE: Creating a Grafserv Server Instance via PostGraphile (TypeScript)\nDESCRIPTION: Creates a Grafserv server instance by connecting the imported Grafserv adaptor to the PostGraphile instance via the createServ method. This instance ('serv') provides request handling compatible with your selected JS server. The returned Grafserv instance exposes methods for request integration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst serv = pgl.createServ(grafserv);\n```\n\n----------------------------------------\n\nTITLE: Querying Users by Organization ID with loadMany - TypeScript\nDESCRIPTION: Defines GraphQL plan resolvers using TypeScript, leveraging loadMany to batch fetch users by organization ID and loadOne to fetch organizations for users. Utilizes JavaScript object destructuring and demonstrates functional composition for data fetching. Requires Graphile Crystal's planning and 'batchGetUsersByOrganizationId' and 'batchGetOrganizationById' backend functions. Inputs include query arguments and user objects; outputs are user and organization data.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst plans = {\n  Query: {\n    usersByOrganizationId(_, { $id }) {\n      return loadMany($id, batchGetUsersByOrganizationId);\n    },\n  },\n  User: {\n    organization($user) {\n      const $orgId = $user.get(\"organization_id\");\n      return loadOne($orgId, batchGetOrganizationById);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine Runtime and Environment Variables for Express App - YAML\nDESCRIPTION: This YAML snippet contains configuration for deploying a Node.js Express app using PostGraphile as library with Cloud SQL on GCP App Engine Flexible. It sets the runtime (Node.js), environment type (flex), and necessary environment variables for connecting to a PostgreSQL Cloud SQL instance. Required parameters include your user, host, password, database, and cloud_sql_instance connection string. Outputs are an application environment ready to boot and connect to the database. Dependencies: GCP App Engine project and properly provisioned Cloud SQL instance. Limitation: environment variables must be set securely and correctly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nruntime: nodejs\nenv: flex\n\nenv_variables:\n  PGUSER: \"your-database-user\"\n  PGHOST: \"/cloudsql/your-cloudsql-instance-connection-string\"\n  PGPASSWORD: \"your-password\"\n  PGDATABASE: \"your-database-name\"\n\nbeta_settings:\n  cloud_sql_instances: your-cloudsql-instance-connection-string\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Tables and a View for Authorization\nDESCRIPTION: This SQL snippet defines `person` and `personal_data` tables. It then creates a view `personal_data_view` with `security_barrier` and `check_option = 'cascaded'`. The view selects data from `app_public.personal_data` but filters it based on `person_id` matching the result of a hypothetical `current_user_id()` function (likely derived from JWT claims), effectively implementing row-level security.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/views.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.person (\n  id serial PRIMARY KEY\n);\n\nCREATE TABLE app_public.personal_data (\n  id serial PRIMARY KEY,\n  secret1 text,\n  secret2 int,\n  person_id references app_public.person (id)\n);\n\nCREATE VIEW personal_data_view\n  WITH (security_barrier, check_option = 'cascaded')\n  AS\n    SELECT personal_data.*\n    FROM app_public.personal_data personal_data\n    WHERE person_id = current_user_id()\n```\n\n----------------------------------------\n\nTITLE: SQL: Splitting Smart Tags and Description with Two Newlines - SQL\nDESCRIPTION: This snippet demonstrates using two consecutive newlines in a dollar-quoted SQL COMMENT block to separate the smart tags section from prose documentation. Any text after two newlines (including lines starting with @) will not be considered a smart tag; instead, it becomes description. Requires PostgreSQL. Input: multi-line COMMENT statement, output: parsed tags/description as per PostGraphile parser.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is $$\\n@name meta\\n@isImportant\\n@jsonField date timestamp\\n@jsonField name text\\n\\nThis field has a load of arbitrary tags.\\n@jsonField episode enum ONE=1 TWO=2\\n$$;\n```\n\n----------------------------------------\n\nTITLE: Querying a Computed Column via GraphQL (GraphQL)\nDESCRIPTION: Queries the 'person' type in GraphQL by ID, requesting both standard and computed fields. Assumes the server was set up with Graphile/PostGraphile and includes a computed column 'fullName' exposed through a matching PostgreSQL function. Input is an 'id'; output is the person object, including the dynamically computed 'fullName' field.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  personById(id: â€¦) {\n    # nodeId, id, ...\n\n    fullName # A computed column, but the client doesnâ€™t even know!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Row-Level Security with Policies (SQL)\nDESCRIPTION: This SQL snippet creates two RLS policies in PostgreSQL: one limiting person row visibility to the current user, and one allowing selection of all posts. Illustrates a scenario where foreign key constraints do not imply field non-nullability in API responses. Pre-requisite: PostgreSQL with current_user_id() defined. Applies to person, post tables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n-- Users can only see their own 'Person'\ncreate policy select_self on person for select using (id = current_user_id());\n-- Users can see all Posts\ncreate policy select_all on post for select using (true);\n```\n\n----------------------------------------\n\nTITLE: Enabling Live Queries in PostGraphile Library Usage (JavaScript)\nDESCRIPTION: Shows how to configure live queries when using PostGraphile as a library in a Node.js application (e.g., with Express). It involves setting the `live: true` option, providing the `ownerConnectionString` for elevated privileges needed for logical decoding, and adding the `@graphile/subscriptions-lds` plugin to the `appendPlugins` array within the PostGraphile configuration object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\napp.use(\n  postgraphile(process.env.AUTH_DATABASE_URL, SCHEMA, {\n    // ...\n\n    // Enable live support in PostGraphile\n    live: true,\n    // We need elevated privileges for logical decoding\n    ownerConnectionString: process.env.ROOT_DATABASE_URL,\n    // Add this plugin\n    appendPlugins: [\n      //...\n      require(\"@graphile/subscriptions-lds\").default,\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Express HTTP Server with PostGraphile Live Subscriptions - JavaScript\nDESCRIPTION: Demonstrates advanced setup for enabling PostGraphile's live websocket-based subscriptions prior to handling the first HTTP request. Relies on PostGraphile, Express, @graphile/pg-pubsub, and Node.js http. Requires configuration of plugin hooks and explicit server creation. Inputs include database URL, schemas, and options; outputs a server listening for both HTTP and GraphQL subscription connections. Limitations: requires proper ordering of middleware and that websocket middlewares manipulate only req/res properties.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_22\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst {\n  postgraphile,\n  makePluginHook,\n  enhanceHttpServerWithSubscriptions,\n} = require(\"postgraphile\");\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\");\nconst { createServer } = require(\"http\");\nconst express = require(\"express\");\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst app = express();\nconst rawHTTPServer = createServer(app);\n\nconst postgraphileOptions = {\n  pluginHook,\n  simpleSubscriptions: true,\n  websocketMiddlewares: [\n    // Add whatever middleware you need here, note that\n    // they should only manipulate properties on req/res,\n    // they must not sent response data. e.g.:\n    //\n    //   require('express-session')(),\n    //   require('passport').initialize(),\n    //   require('passport').session(),\n  ],\n};\n\nconst postgraphileMiddleware = postgraphile(\n  databaseUrl,\n  \"app_public\",\n  postgraphileOptions,\n);\n\napp.use(postgraphileMiddleware);\n\nenhanceHttpServerWithSubscriptions(rawHTTPServer, postgraphileMiddleware);\n\nrawHTTPServer.listen(parseInt(process.env.PORT, 10) || 3000);\n```\n\n----------------------------------------\n\nTITLE: Initializing Express Server with PostGraphile Middleware using JavaScript\nDESCRIPTION: Demonstrates a minimal Node.js Express application setup using the PostGraphile library. It requires `express` and `postgraphile`, configures the PostgreSQL connection details using environment variables (intended for use with Cloud SQL proxy via `PGHOST`), sets PostGraphile options, applies the `postgraphile` middleware to the Express app, and starts the server listening on port 8080.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\n// node-postgres Pool config (https://node-postgres.com/api/pool,\n// https://node-postgres.com/api/client)\nconst pgConfig = {\n  host: process.env.PGHOST || \"localhost\",\n  port: process.env.PGPORT || 5432,\n  user: process.env.PGUSER,\n  database: process.env.PGDATABASE,\n  password: process.env.PGPASSWORD,\n};\n\n// Your PostGraphile config:\n// https://www.graphile.org/postgraphile/usage-library/#api-postgraphilepgconfig-schemaname-options\nconst postgraphileOptions = {\n  /* ... */\n};\napp.use(postgraphile(pgConfig, \"public\", postgraphileOptions));\n\napp.listen(8080);\n```\n\n----------------------------------------\n\nTITLE: Creating User Registration Function in PL/pgSQL\nDESCRIPTION: Defines a PL/pgSQL function `forum_example.register_person` that handles user registration. It inserts user profile data into `forum_example.person` and creates a corresponding account in `forum_example_private.person_account`, securely hashing the password using the `pgcrypto` extension. The function runs with the privileges of the user who created it (`security definer`) and returns the newly created person record. Input parameters are `first_name`, `last_name`, `email`, and `password`. The `strict` keyword ensures it returns null if any input is null.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_21\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.register_person(\n  first_name text,\n  last_name text,\n  email text,\n  password text\n) returns forum_example.person as $$\ndeclare\n  person forum_example.person;\nbegin\n  insert into forum_example.person (first_name, last_name) values\n    (first_name, last_name)\n    returning * into person;\n\n  insert into forum_example_private.person_account (person_id, email, password_hash) values\n    (person.id, email, crypt(password, gen_salt('bf')));\n\n  return person;\nend;\n$$ language plpgsql strict security definer;\n\ncomment on function forum_example.register_person(text, text, text, text) is 'Registers a single user and creates an account in our forum.';\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Role from JWT Claim - SQL\nDESCRIPTION: This SQL snippet demonstrates how to assign the current PostgreSQL session role based on the \"role\" claim from a verified JWT. This mechanism is used to enforce database-level access control using the privileges associated with the mapped PostgreSQL role. The approach requires that the JWT contains a valid 'role' claim and that the PostgreSQL user has permission to switch roles via 'SET ROLE'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nset local role $role;\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom User Registration Mutation with Transaction in TypeScript\nDESCRIPTION: TypeScript code defining a custom `registerUser` mutation using `makeExtendSchemaPlugin`. It utilizes `withPgClientTransaction` to ensure atomicity when inserting user data into the database and sending a confirmation email. It defines the necessary input (`RegisterUserInput`) and payload (`RegisterUserPayload`) types and implements plan resolvers for the mutation and its payload fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { access, constant, object } from \"postgraphile/grafast\";\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\n\nexport const MyRegisterUserMutationPlugin = makeExtendSchemaPlugin((build) => {\n  const { sql } = build;\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n  return {\n    typeDefs: gql`\n      input RegisterUserInput {\n        name: String!\n        email: String!\n        bio: String\n      }\n\n      type RegisterUserPayload {\n        user: User\n        query: Query\n      }\n\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, fieldArgs) {\n          const $input = fieldArgs.getRaw(\"input\");\n          const $user = withPgClientTransaction(\n            executor,\n            $input,\n            async (pgClient, input) => {\n              // Our custom logic to register the user:\n              const {\n                rows: [user],\n              } = await pgClient.query({\n                text: `\n                  INSERT INTO app_public.users (name, email, bio)\n                  VALUES ($1, $2, $3)\n                  RETURNING *`,\n                values: [input.name, input.email, input.bio],\n              });\n\n              // Send the email. If this fails then the error will be caught\n              // and the transaction rolled back; it will be as if the user\n              // never registered\n              await mockSendEmail(\n                input.email,\n                \"Welcome to my site\",\n                `You're user ${user.id} - thanks for being awesome`,\n              );\n\n              // Return the newly created user\n              return user;\n            },\n          );\n\n          // To allow for future expansion (and for the `clientMutationId`\n          // field to work), we'll return an object step containing our data:\n          return object({ user: $user });\n        },\n      },\n\n      // The payload also needs plans detailing how to resolve its fields:\n      RegisterUserPayload: {\n        user($data) {\n          const $user = $data.get(\"user\");\n          // It would be tempting to return $user here, but the step class\n          // is not compatible with the auto-generated `User` type, so\n          // errors will occur. We must ensure that we return a compatible\n          // step, so we will retrieve the relevant record from the database:\n\n          // Get the '.id' property from $user:\n          const $userId = access($user, \"id\");\n\n          // Return a step representing this row in the database.\n          return users.get({ id: $userId });\n        },\n        query($user) {\n          // Anything truthy should work for the `query: Query` field.\n          return constant(true);\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Many-to-Many Relations via Join Table and Computed Column (SQL)\nDESCRIPTION: This SQL snippet covers the schema setup for a many-to-many relation using a join table and a computed column (function). The code defines two entities (post and author), a join table (post_author), and a function that returns all authors for a given post. Dependencies include PostgreSQL, and the SQL function uses 'STABLE' semantics for safe query integration. Inputs: None at declaration, but the function expects a 'post' record as parameter. Output: Authors linked to the post. Required for advanced GraphQL exposure via PostGraphile or similar frameworks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/relations.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate table post (\n  id serial primary key,\n  headline text,\n  body text\n);\ncreate table author (\n  id serial primary key,\n  name text\n);\ncreate table post_author (\n  post_id integer references post,\n  author_id integer references author,\n  primary key (post_id, author_id)\n);\n\ncreate function \"post_authorsByPostId\"(p post)\nreturns setof author as $$\n  select author.*\n  from author\n  inner join post_author\n  on (post_author.author_id = author.id)\n  where post_author.post_id = p.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL for Logical Decoding (INI)\nDESCRIPTION: Specifies the necessary PostgreSQL configuration settings within `postgresql.conf` to enable logical decoding, which is required for the `@graphile/subscriptions-lds` live query provider. `wal_level` must be set to `logical`, and `max_wal_senders` and `max_replication_slots` should be configured appropriately (e.g., 10 each) to allow connections for logical replication.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nwal_level = logical\nmax_wal_senders = 10\nmax_replication_slots = 10\n```\n\n----------------------------------------\n\nTITLE: Building Minimal GraphQL Schema by Omitting Relay Node Plugin - Graphile-Build JavaScript\nDESCRIPTION: This JavaScript snippet creates a minimal GraphQL schema by removing the NodePlugin from the list of default plugins provided to graphile-build's buildSchema function. It uses require to import necessary modules, filters out NodePlugin, builds the schema asynchronously, and prints it using printSchema from graphql/utilities. Dependencies include graphile-build (with its plugins) and graphql. The code expects no arguments; output is printed to the console and will be the resulting GraphQL schema without Relay Node support. Useful for customizing the GraphQL schema generation process in Node.js projects.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/omitting-plugins.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { buildSchema, defaultPlugins, NodePlugin } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nbuildSchema(defaultPlugins.filter((plugin) => plugin !== NodePlugin)).then(\n  (schema) => {\n    console.log(printSchema(schema));\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Role and Claims from Example JWT - SQL\nDESCRIPTION: This SQL sequence demonstrates setting both the session role and individual JWT claim values from the previous example JWT payload. Each 'set local' command updates the current database session for the transaction, assigning specific values from the JWT to variables and the session role. Prerequisites are an authenticated, transactional SQL session and that claim values are valid and properly escaped. This pattern should be repeated for each verified JWT claim.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nset local role user;\nset local jwt.claims.sub to 'postgraphql';\nset local jwt.claims.role to 'user';\nset local jwt.claims.user_id to 2;\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of loadMany for Friendships - TypeScript\nDESCRIPTION: Shows how to use loadMany with a user ID specifier and a callback to fetch friendships. Suitable for batch fetching friend relationships by user IDs. Requires a $user variable and a getFriendshipsByUserIds function. Input is a user ID, output is friendship records.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $userId = $user.get(\"id\");\nconst $friendships = loadMany($userId, getFriendshipsByUserIds);\n```\n\n----------------------------------------\n\nTITLE: Recommended Table/Column GRANT Statements in PostgreSQL\nDESCRIPTION: Provides examples of recommended SQL `GRANT` statements for a `graphql_role` when using PostGraphile. The best practice is to use table-level grants for `SELECT` and `DELETE` operations, and specific column-level grants for `INSERT` and `UPDATE` operations to maintain explicitness and control over modifications.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/best-practices.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\nGRANT SELECT ON users TO graphql_role;\n-- âœ… Fine\nGRANT INSERT (column_1, column_2, ...) ON users TO graphql_role;\n-- âœ… Fine\nGRANT UPDATE (column_a, column_b, ...) ON users TO graphql_role;\n-- âœ… Fine\nGRANT DELETE ON users TO graphql_role;\n```\n\n----------------------------------------\n\nTITLE: Authenticated Apollo Client Setup with JWT - JavaScript\nDESCRIPTION: Shows how to configure an Apollo GraphQL client in JavaScript to send JWTs with every request by intercepting and merging headers via the 'setContext' function. Dependencies: Apollo Client, setContext middleware. Expects the JWT to be retrieved by 'getJWTToken()'. Inputs: JWT token, outputs: authenticated ApolloClient.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst httpLink = createHttpLink({\n  uri: \"/graphql\",\n});\n\nconst authLink = setContext((_, { headers }) => {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  // return the headers to the context so httpLink can read them\n  return {\n    headers: {\n      ...headers,\n      // Only pass the authorization header if we have a JWT\n      ...(token ? { authorization: `Bearer ${token}` } : null),\n    },\n  };\n});\n\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Related Data with Conditional Filters - GraphQL\nDESCRIPTION: This GraphQL query retrieves a forum by its 'slug' and fetches topics under that forum where the 'authorId' equals 2. The query shows how to nest related entity queries and apply condition filters within Graphile/PostGraphile. Required dependencies include a schema that supports the forumBySlug and topics queries with filterable fields, as well as the pg-simplify-inflector plugin if simplified field names are desired. The inputs include the forum slug and topic authorId condition; outputs are forum details and an array of matching topic records.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/collections.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forumBySlug(slug: \"testimonials\") {\n    nodeId\n    id\n    name\n    topics(condition: { authorId: 2 }) {\n      nodes {\n        nodeId\n        id\n        title\n        body\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Single Row Insertion with pgInsertSingle in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `pgInsertSingle` to insert a single row into the specified `usersResource`. Attributes like `username` are provided directly as an object during the function call. The result, `$insertedUser`, represents the plan for the inserted row.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgInsertSingle.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $insertedUser = pgInsertSingle(usersResource, {\n  username: $username,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Strictly Non-Nullable Types and Queries in GraphQL Schema (GraphQL)\nDESCRIPTION: This GraphQL code snippet defines two simple object types (Numbers, Letters) where all fields are marked non-nullable, and a Query type that returns non-nullable instances of both. It is used in the documentation to illustrate how GraphQL null propagation operates when every field and parent is non-nullable, leading to the entire response becoming null if any single subfield fails. No external dependencies. Query fields: numbers, letters, each returning strict types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n# This is a bad practice GraphQL schema to demonstrate a point.\n\ntype Numbers {\n  one: Int!\n  two: Int!\n  three: Int!\n}\n\ntype Letters {\n  a: String!\n  b: String!\n  c: String!\n}\n\ntype Query {\n  numbers: Numbers!\n  letters: Letters!\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL statement_timeout per Transaction in PostGraphile (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to configure PostGraphile to set a `statement_timeout` for each transaction within the `graphile.config.mjs` file. It modifies the `grafast.context` function to return an object including the `statement_timeout` key with the desired timeout value in milliseconds (e.g., \"3000\"). This approach helps mitigate long-running queries on a per-request basis as part of DoS protection, but incurs the overhead of setting the timeout for every transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/production.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default {\n  // ...\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-next-line\n        statement_timeout: \"3000\",\n        // ...\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Session Variables from JWT Claims using SQL\nDESCRIPTION: This SQL snippet shows how PostGraphile might internally handle an authenticated JWT. Within a transaction, it sets the local session role using `set local role` and stores JWT claims like `role` and `user_id` as local configuration settings using `set local jwt.claims.*`. These settings are then available to SQL functions and RLS policies during the execution of the GraphQL query.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nbegin;\nset local role app_user;\nset local jwt.claims.role to 'app_user';\nset local jwt.claims.user_id to '2';\n\n-- PERFORM GRAPHQL QUERIES HERE\n\ncommit;\n```\n\n----------------------------------------\n\nTITLE: Configuring PgSimplifyInflectionPreset in a PostGraphile Project (JavaScript)\nDESCRIPTION: This snippet illustrates how to configure a PostGraphile project to use the '@graphile/simplify-inflection' preset via a JavaScript configuration file. It demonstrates importing the 'PgSimplifyInflectionPreset' and extending it within the PostGraphile config preset, thereby customizing generated field names for brevity. The configuration requires the '@graphile/simplify-inflection' package and is placed in the project's 'graphile.config.mjs'. Key parameters are the list of presets to extend.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/inflection.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PgSimplifyInflectionPreset } from \"@graphile/simplify-inflection\";\n\nconst preset = {\n  extends: [\n    PgSimplifyInflectionPreset,\n    //...\n  ],\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Native PostgreSQL Enum and Related Table (SQL)\nDESCRIPTION: Creates a PostgreSQL `ENUM` type named `animal_type` with values 'CAT', 'DOG', 'FISH'. Also creates a `pets` table with a column `type` referencing this enum, demonstrating the basic setup for PostGraphile's automatic enum mapping.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type animal_type as enum (\n  'CAT',\n  'DOG',\n  'FISH'\n);\ncreate table pets (\n  id serial primary key,\n  type animal_type not null,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Resource Options with makePgResourceOptions (TypeScript)\nDESCRIPTION: This code snippet configures PostgreSQL resource options in the Graphile Crystal framework using the makePgResourceOptions TypeScript helper function. It defines the resource name, associated executor, codec (type contract), source SQL fragment, and unique constraints. The snippet assumes the existence of executor, forumsCodec, and an sql tagged template function. Outputs a resource options object for registry construction; key parameters cover naming, execution context, result typing, and uniqueness metadata. This pattern enforces type safety and structured resource management for table-like database entities.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/resources.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst forumsResourceOptions = makePgResourceOptions({\n  name: \"forums\",\n  executor,\n  codec: forumsCodec,\n  from: sql`forums`,\n  uniques: [{ attributes: [\"id\"], isPrimary: true }],\n});\n```\n\n----------------------------------------\n\nTITLE: Constructing and Compiling Dynamic SQL Queries with pg-sql2 in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to use pg-sql2 to safely build dynamic SQL queries while preventing SQL injection. It covers key operations such as safely joining field identifiers, creating conditions with placeholders, using symbols for unique table aliasing, and compiling the query to text and values for execution. Dependencies include the pg-sql2 npm library and optionally the pg (node-postgres) library for query execution. Inputs include table and field names, as well as values for query conditions; outputs are a compiled SQL string and an array of replacement values. The snippet highlights composability and security best practices for SQL statement construction in Node.js environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { default: sql } = require(\"pg-sql2\");\n// or import sql from 'pg-sql2';\n\nconst tableName = \"user\";\nconst fields = [\"name\", \"age\", \"height\"];\n\n// sql.join is used to join fragments with a common separator, NOT to join tables!\nconst sqlFields = sql.join(\n  // sql.identifier safely escapes arguments and joins them with dots\n  fields.map((fieldName) => sql.identifier(tableName, fieldName)),\n  \", \",\n);\n\n// sql.value will store the value and instead add a placeholder to the SQL\n// statement, to ensure that no SQL injection can occur.\nconst sqlConditions = sql`created_at > NOW() - interval '3 years' and age > ${sql.value(\n  22,\n)}`;\n\n// This could be a full query, but we're going to embed it in another query safely\nconst innerQuery = sql`select ${sqlFields} from ${sql.identifier(\n  tableName,\n)} where ${sqlConditions}`;\n\n// Symbols are automatically assigned unique identifiers\nconst sqlAlias = sql.identifier(Symbol());\n\nconst query = sql`\nwith ${sqlAlias} as (${innerQuery})\nselect\n  (select json_agg(row_to_json(${sqlAlias})) from ${sqlAlias}) as all_data,\n  (select max(age) from ${sqlAlias}) as max_age\n`;\n\n// sql.compile compiles the query into an SQL statement and a list of values\nconst { text, values } = sql.compile(query);\n\nconsole.log(text);\n/* ->\nwith __local_0__ as (select \"user\".\"name\", \"user\".\"age\", \"user\".\"height\" from \"user\" where created_at > NOW() - interval '3 years' and age > $1)\nselect\n  (select json_agg(row_to_json(__local_0__)) from __local_0__) as all_data,\n  (select max(age) from __local_0__) as max_age\n*/\n\nconsole.log(values); // [ 22 ]\n\n// Then to run the query using `pg` module, do something like:\n// const { rows } = await pg.query(text, values);\n```\n\n----------------------------------------\n\nTITLE: Setting Local JWT Claims and Role in Postgres (SQL)\nDESCRIPTION: Illustrates how PostGraphile maps JWT claims into PostgreSQL session variables using the 'set local' statement, making JWT claim data accessible to SQL-based row-level security or business logic. The examples show setting claims individually, as well as setting the session role to match the 'role' claim for dynamic permission handling. Requires a running PostgreSQL instance configured with PostGraphile for the claims to take effect.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_29\n\nLANGUAGE: sql\nCODE:\n```\nset local jwt.claims.a to 1;\nset local jwt.claims.b to 2;\nset local jwt.claims.c to 3;\n```\n\nLANGUAGE: sql\nCODE:\n```\nselect current_setting('jwt.claims.a', true);\n```\n\nLANGUAGE: sql\nCODE:\n```\nset local role to 'forum_example_person';\nset local jwt.claims.role to 'forum_example_person';\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile via npx CLI\nDESCRIPTION: Demonstrates the easiest way to start PostGraphile using the npx command-line interface. This command connects to a specified PostgreSQL database using a connection string (`-c`), automatically restarts the server on schema changes (`--watch`), enables an enhanced GraphiQL interface (`--enhance-graphiql`), and supports dynamic JSON types (`--dynamic-json`). Users need to replace the placeholder user, password, and database name with their actual PostgreSQL credentials. Requires npx (typically included with Node.js/npm) and a running PostgreSQL database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx postgraphile -c 'postgres://user:pass@localhost/mydb' --watch --enhance-graphiql --dynamic-json\n```\n\n----------------------------------------\n\nTITLE: Retrieving Schema and Preset from PostGraphile Instance in JavaScript\nDESCRIPTION: Demonstrates how to asynchronously retrieve the GraphQL schema and the resolved configuration preset from an existing PostGraphile instance (`pgl`). This method is recommended as it supports watch mode by always fetching the latest schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { pgl } from \"./pgl.js\";\n\nconst { schema, resolvedPreset } = await pgl.getSchemaResult();\n```\n\n----------------------------------------\n\nTITLE: Batch Fetch Callback with Unary Dependency in Graphile (TypeScript)\nDESCRIPTION: This TypeScript snippet provides a callback function for use with loadOne that utilizes a passed-in unary dependency, e.g., a database client from context. It fetches users by IDs with optimized attribute selection and result reordering. The function supports dependency injection, which is critical for Graphile's plan optimization and allows for context-aware data fetches. It requires a dbClient and a helper to transform attributes to SQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function batchGetUserFromDbById(ids, { attributes, unary }) {\n  const dbClient = unary;\n\n  const rows = await dbClient.query(\n    sql`SELECT id, ${columnsToSql(attributes)} FROM users WHERE id = ANY($1);`,\n    [ids],\n  );\n\n  return ids.map((id) => rows.find((row) => row.id === id));\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting a PostGraphile Schema using graphile-export in TypeScript\nDESCRIPTION: This script demonstrates how to generate an executable schema file from a PostGraphile instance. It initializes PostGraphile with a configuration, retrieves the built schema, and then uses the `exportSchema` function from `graphile-export` to write the schema definition to an `.mjs` file. It specifies the export mode ('graphql-js') and includes an example of how to declare external modules (`jsonwebtoken`) needed by the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/exporting-schema.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { exportSchema } from \"graphile-export\";\nimport { postgraphile } from \"postgraphile\";\nimport config from \"./graphile.config.js\";\nimport * as jsonwebtoken from \"jsonwebtoken\";\n\nconst pgl = postgraphile(config);\nasync function main() {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n  const exportFileLocation = `${__dirname}/exported-schema.mjs`;\n  await exportSchema(schema, exportFileLocation, {\n    mode: \"graphql-js\",\n    // or:\n    // mode: \"typeDefs\",\n    modules: {\n      jsonwebtoken: jsonwebtoken,\n    },\n  });\n}\n\nmain()\n  .finally(() => pgl.release())\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating Schemas in PostgreSQL using SQL\nDESCRIPTION: Creates two distinct PostgreSQL schemas, `forum_example` for publicly accessible data and `forum_example_private` for internal or sensitive data. This separation helps organize database objects and manage permissions within the forum application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema forum_example;\ncreate schema forum_example_private;\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic TypeScript Configuration File\nDESCRIPTION: This snippet demonstrates creating a `graphile.config.ts` file using TypeScript. It includes necessary type imports for `graphile-config` and `postgraphile` to enable type checking and autocompletion. It defines a preset constant typed as `GraphileConfig.Preset` which extends the base `PostGraphileAmberPreset`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport \"graphile-config\";\nimport \"postgraphile\";\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Transforming a List of Users to Usernames with applyTransforms in TypeScript\nDESCRIPTION: This snippet demonstrates how to use each to create a step that maps a list of user objects to usernames, and then how to pass the transformed step through applyTransforms to ensure it reflects a list of usernames, not user objects, before supplying it as a dependency for another step. This is especially necessary when passing to downstream steps that require the finalized list values. Dependencies include steps created via each, and the performRemoteRequestWithUsernames consumer.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/applyTransforms.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This step still represents a list of user objects until it is paginated by\n// GraphQL; so if you pass it to another step as a dependency, that step will\n// receive the untransformed user objects.\nconst $untransformed = each($users, ($user) => $user.get(\"username\"));\n\n// This step forces the `listItem` transforms to take place, so now it truly\n// represents a list of usernames and is safe to pass as a dependency to other\n// steps.\nconst $usernames = applyTransforms($untransformed);\n\nreturn performRemoteRequestWithUsernames($usernames);\n```\n\n----------------------------------------\n\nTITLE: Authenticating User Credentials and Returning a JWT Token (PL/pgSQL)\nDESCRIPTION: Implements a SQL function in PL/pgSQL to authenticate users based on email and password, returning a composite JWT token on success. Uses 'pgcrypto' for password verification, and constructs the JWT claim object with a two-day expiry. Key dependencies: 'pgcrypto' extension and pre-existing person_account storage. Takes 'email' and 'password' as inputs, returns a JWT (composite type) or null. Input validation and secure handling are included.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_33\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\ncreate function forum_example.authenticate(\n  email text,\n  password text\n) returns forum_example.jwt_token as $$\ndeclare\n  account forum_example_private.person_account;\nbegin\n  select a.* into account\n  from forum_example_private.person_account as a\n  where a.email = $1;\n\n  if account.password_hash = crypt(password, account.password_hash) then\n    return ('forum_example_person', account.person_id, extract(epoch from (now() + interval '2 days')))::forum_example.jwt_token;\n  else\n    return null;\n  end if;\nend;\n$$ language plpgsql strict security definer;\n\ncomment on function forum_example.authenticate(text, text) is 'Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 2 days.';\n```\n\n----------------------------------------\n\nTITLE: Finding Missing Foreign Key Indexes in PostgreSQL using SQL\nDESCRIPTION: This SQL query identifies foreign key constraints in a PostgreSQL database that do not have a corresponding index on the referencing column(s). It uses a Common Table Expression (CTE) to list existing indexes and then checks against `pg_constraint` for foreign keys (`contype = 'f'`) lacking a matching index. The results are ordered by the estimated table size (`reltuples`) to prioritize larger tables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-indexes.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nWITH indexed_tables AS (\n  select\n      ns.nspname,\n      t.relname as table_name,\n      i.relname as index_name,\n      array_to_string(array_agg(a.attname), ', ') as column_names,\n      ix.indrelid,\n      string_to_array(ix.indkey::text, ' ')::smallint[] as indkey\n  FROM pg_class i\n  JOIN pg_index ix ON i.OID = ix.indrelid\n  JOIN pg_class t ON ix.indrelid = t.oid\n  JOIN pg_namespace ns ON ns.oid = t.relnamespace\n  JOIN pg_attribute a ON a.attrelid = t.oid\n  where a.attnum = ANY(ix.indkey)\n  and t.relkind = 'r'\n  and nspname not in ('pg_catalog')\n  group by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n  order by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n)\nSELECT\n  conrelid::regclass\n  ,conname\n  ,reltuples::bigint\nFROM pg_constraint pgc\nJOIN pg_class ON (conrelid = pg_class.oid)\nWHERE contype = 'f'\nAND NOT EXISTS(\n  SELECT 1\n  FROM indexed_tables\n  WHERE indrelid = conrelid\n  AND conkey = indkey\n  OR (array_length(indkey, 1) > 1 AND indkey @> conkey)\n)\nORDER BY reltuples DESC;\n```\n\n----------------------------------------\n\nTITLE: Querying Computed Columns with Graphile GraphQL - GraphQL\nDESCRIPTION: This snippet demonstrates a GraphQL query that retrieves a topic by its ID, including both the full body and a computed summary of the body. The 'bodySummary' field is resolved using a computed column in the database, showing the integration between GraphQL and custom SQL functions in Graphile. The query expects a topic with a specific ID and returns its body and summarized version.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  topic(id: 2) {\n    body\n    bodySummary\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Deprecated @omit Tag via SQL Comment - Table Mutation Actions\nDESCRIPTION: This SQL snippet adds a '@omit' tag to a table via SQL comment, configuring PostGraphile to prevent create, update, and delete GraphQL mutations for the referenced table. This method is part of the deprecated smart tag API, superseded by @behavior -*, and is intended purely for GraphQL schema customizations. Used for hiding database entities or actions from the GraphQL API without affecting database-level permissions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_24\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on table table_name is E'@omit create,update,delete';\n\n```\n\n----------------------------------------\n\nTITLE: Extending the GraphQL Schema and Creating a Business Logic Plugin in JavaScript/TypeScript\nDESCRIPTION: This comprehensive snippet creates a PostGraphile schema extension plugin that adds a 'topMovieTitles' resolver to the root Query type. The resolver demonstrates how to execute a GraphQL query from within a resolver, using generated types and integrating error handling. Dependencies include 'graphile-utils', 'postgraphile', and TypeScript type definitions generated by graphql-code-generator. Inputs are query arguments and backend context; output is a list of movie titles. The implementation separates schema definition, resolver logic, and utilizes both inline and imported query documents.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql, gql as gqlExtend } from 'graphile-utils';\nimport { Build } from 'postgraphile';\nimport {\n  GetMoviesQuery,\n  GetMoviesDocument,\n  GetMoviesQueryVariables,\n} from '../../generated/types';\n\n// doc: https://www.graphile.org/postgraphile/make-extend-schema-plugin/\nexport const BusinessLogicPlugin = makeExtendSchemaPlugin((build: Build) => {\n  const { graphql } = build;\n  return {\n    typeDefs: gqlExtend`\n      extend type Query {\n        topMovieTitles: [String!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        topMovieTitles: async (query, args, context, resolveInfo) => {\n          // Alternatively defined the query inline with intellisense support:\n          const inlineGetMoviesDocument = gql`\n            query Query {\n              __typename\n              movies(first: 3) {\n                nodes {\n                  id\n                  title\n                }\n              }\n            }\n          `;\n          const variables: GetMoviesQueryVariables = {\n            top: 3,\n          };\n\n          // execute the query\n          const queryResult = await graphql.execute<GetMoviesQuery>(\n            resolveInfo.schema,\n            GetMoviesDocument, // or: inlineGetMoviesDocument,\n            undefined,\n            context,\n            variables,\n          );\n\n          if (queryResult.errors) {\n            // do something in error case\n            throw queryResult.errors[0];\n          } else {\n            // the result can then be used to get the returned data\n            const allTitles = queryResult.data?.movies?.nodes.map(\n              movie => movie?.title,\n            );\n\n            return allTitles;\n          }\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Anonymous User Role in PostgreSQL\nDESCRIPTION: Creates a PostgreSQL role named `forum_example_anonymous` intended for unauthenticated users accessing the application via PostGraphile. This role does not have login privileges. It is then granted to the `forum_example_postgraphile` role, enabling the PostGraphile connection role to assume the permissions of the anonymous role.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_24\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_anonymous;\ngrant forum_example_anonymous to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Getting a Node by Global Object Identifier - TypeScript\nDESCRIPTION: This snippet demonstrates how to retrieve a GraphQL node by its global node ID using a map of handlers and a node ID string. The 'node' function combines the supplied handlers configuration with the provided ID to produce a step capable of resolving to the correct entity. It requires the 'handlers' configuration (mapping type names to handler specs) and a string node ID, typically sourced from a field argument. Returns a polymorphic step representing the resolved entity or null if not found.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $nodeIdString = fieldArgs.get(\"id\");\nconst $node = node(handlers, $nodeIdString);\n```\n\n----------------------------------------\n\nTITLE: Applying the Origin-Specific CORS Plugin in PostGraphile Middleware in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to utilize the `makeAllowedOriginTweak` factory function to generate and apply the origin-specific CORS plugin. It calls the factory with the desired origin ('https://graphql.rocks') and uses `makePluginHook` to create a plugin hook collection. This `pluginHook` is then passed as an option when initializing the PostGraphile middleware using the `postgraphile` function, effectively activating the custom CORS policy.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nconst pluginHook = makePluginHook([\n  makeAllowedOriginTweak(\"https://graphql.rocks\"),\n]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Foreign Key Constraint during Table Creation in SQL\nDESCRIPTION: Shows how to create a `users` table within the `app_public` schema, including an `organization_id` column. This column has a NOT NULL constraint and a foreign key constraint defined inline using `REFERENCES`, linking it to the `organizations` table in the same schema. The `ON DELETE CASCADE` clause ensures related users are deleted if an organization is deleted. An index is subsequently created on the `organization_id` column for performance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/relations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users (\n  -- ...\n  organization_id int NOT NULL\n    REFERENCES app_public.organizations ON DELETE CASCADE,\n  -- ...\n);\nCREATE INDEX ON app_public.users (organization_id);\n```\n\n----------------------------------------\n\nTITLE: Type Definitions for Null Sorting in orderByAscDesc (TypeScript)\nDESCRIPTION: Provides the type definitions for configuring NULL sorting in custom orderBy enum variants, detailing how different nulls settings control SQL output. NullsSortMethod and OrderByAscDescOptions enable fine-tuned handling of NULLS FIRST/LAST in the resulting query. These options ensure correct sort semantics and compatibility with pagination and nullable columns. Required for advanced plugins handling possible NULLs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type NullsSortMethod =\n  | \"first\"\n  | \"last\"\n  | \"first-iff-ascending\"\n  | \"last-iff-ascending\"\n  | undefined;\n\nexport interface OrderByAscDescOptions {\n  unique?: boolean;\n  nulls?: NullsSortMethod;\n  nullable?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Stringifying GraphQL Payloads with Grafast in TypeScript\nDESCRIPTION: This snippet illustrates how to import and use the 'stringifyPayload' and 'grafast' utilities from the Grafast package in a TypeScript project. It demonstrates invoking Grafast to process a GraphQL operation and then logging the optimized stringified result using 'stringifyPayload', which is recommended over the default 'JSON.stringify' when sending HTTP responses for improved efficiency. Dependencies include the 'grafast' library, and the main parameters are those passed to 'grafast' for execution; the output is the stringified result suitable for transmission.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/request-overview.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { stringifyPayload, grafast } from \\\"grafast\\\";\n\nconst result = await grafast(/*...*/);\nconsole.log(stringifyPayload(result));\n```\n\n----------------------------------------\n\nTITLE: Efficiently Archiving Forums with Bulk Updates in PostgreSQL (SQL)\nDESCRIPTION: Defines an SQL function `archive_forums` taking an array of forum IDs. It uses two `UPDATE` statements employing the `ANY` operator to update `forums` and `posts` tables in bulk based on the input `forum_ids`. This set-based approach is significantly more performant than looping through IDs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"More efficient\"\ncreate function archive_forums(forum_ids int[]) returns void as $$\n  update forums set is_archived = true where id = ANY(forum_ids);\n  update posts set is_archived = true where forum_id = ANY(forum_ids);\n$$ language sql volatile;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom Mutation Function in PostgreSQL\nDESCRIPTION: Demonstrates the basic syntax for creating a PostgreSQL function intended to be exposed as a GraphQL mutation by PostGraphile. It takes two integer arguments (`a`, `b`) and returns text. The function must be `VOLATILE` (which is the default) and defined in an introspected schema to be picked up by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-mutations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_function(a int, b int) returns text as $$ \\u2026 $$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Helper Function to Access JWT Claims\nDESCRIPTION: This SQL snippet defines a PostgreSQL helper function `current_user_id` that retrieves the user ID stored in the session configuration variable `jwt.claims.user_id`. It uses `current_setting('jwt.claims.user_id', true)` to safely access the setting (returning null if not set) and casts the result to an integer. This function can be conveniently used within RLS policies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user_id() returns integer as $$\n  select nullif(current_setting('jwt.claims.user_id', true), '')::integer;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL SETOF Function for PostGraphile - SQL\nDESCRIPTION: Defines an SQL function named 'my_function' that takes two integer parameters (a and b) and returns a set of rows from the 'person' table. This SETOF function is recognized by PostGraphile as a custom query and can be consumed by a GraphQL client via a connection. The function uses the STABLE property indicating it returns the same result for the same input during the same transaction. Dependencies: existing 'person' table in PostgreSQL; PostGraphile for GraphQL exposure. Input: integers a and b; Output: set of person records.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\n-- Assuming we already have a table named `person`â€¦\\nCREATE FUNCTION my_function(a int, b int) RETURNS SETOF person AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Creating pgCondition Child in AND Mode with andPlan - Graphile (JavaScript)\nDESCRIPTION: Illustrates the creation of an AND-grouped child pgCondition using the andPlan method. This is essential when combining multiple conditional clauses under an \"AND\" logic, allowing for precise query filtering. The method operates on a pgCondition instance and returns a new child pgCondition, enabling further chained conditions. It is designed for building up composite SQL statements programmatically.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.andPlan()\n```\n\n----------------------------------------\n\nTITLE: Creating a Plugin for Cross-table Ordering with makeAddPgTableOrderByPlugin (TypeScript)\nDESCRIPTION: Shows how to extend PostGraphile's table ordering by creating a plugin using makeAddPgTableOrderByPlugin, enabling ordering forums by the creation date of their latest associated post. Requires postgraphile/utils and postgraphile/@dataplan/pg packages, and TypeScript. The plugin uses SQL fragments for sub-selects and orderByAscDesc to generate ASC/DESC enum variants. It supports advanced order logic and adds LAST_POST_CREATED_AT_ASC and LAST_POST_CREATED_AT_DESC to the ForumOrderBy enum, with corresponding SQL ordering logic and type safety using a timestamptz codec.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  makeAddPgTableOrderByPlugin,\n  orderByAscDesc,\n} from \"postgraphile/utils\";\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\n/* TODO: test this plugin works! */\nexport default makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  ({ sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"lastPostInForum\"));\n    return orderByAscDesc(\n      \"LAST_POST_CREATED_AT\",\n      ($select) => {\n        const orderByFrag = sql`(\n          select ${sqlIdentifier}.created_at\n          from app_public.posts as ${sqlIdentifier}\n          where ${sqlIdentifier}.forum_id = ${$select.alias}.id\n          order by ${sqlIdentifier}.created_at desc\n          limit 1\n        )`;\n        return { fragment: orderByFrag, codec: TYPES.timestamptz };\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing an Update Mutation with Security Definer in PostgreSQL\nDESCRIPTION: This SQL snippet defines a custom mutation function `app_public.accept_team_invite` that updates a record in the `team_members` table. It uses `STRICT` to ensure the `team_id` argument is non-null and `SECURITY DEFINER` to potentially bypass RLS/GRANT checks by running with the definer's privileges. It returns the updated `team_members` record.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-mutations.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION app_public.accept_team_invite(team_id integer)\nRETURNS app_public.team_members\nAS $$\n  UPDATE app_public.team_members\n    SET accepted_at = now()\n    WHERE accepted_at IS NULL\n    AND team_members.team_id = accept_team_invite.team_id\n    AND member_id = app_public.current_user_id()\n    RETURNING *;\n$$ LANGUAGE sql VOLATILE STRICT SECURITY DEFINER;\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Mutation with Transaction using PostGraphile V5 (JavaScript)\nDESCRIPTION: This snippet shows how to define and implement a custom GraphQL mutation in PostGraphile V5 using `makeExtendSchemaPlugin`. It utilizes `withPgClientTransaction` from `@dataplan/pg` to acquire a transactional PostgreSQL client, execute SQL queries (e.g., `generate_series`), and return the results. The example demonstrates passing arguments, handling asynchronous operations, and structuring the mutation plan using Gra*fast*. Dependencies include `postgraphile/grafast`, `@dataplan/pg`, and `postgraphile/utils`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nimport { object } from \"postgraphile/grafast\";\n// highlight-next-line\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\nimport { makeExtendSchemaPlugin } from \"postgraphile/utils\";\n\nexport default makeExtendSchemaPlugin((build) => {\n  const { sql } = build;\n  /**\n   * The 'executor' tells us which database we're talking to.\n   * You can get this from the registry, the default executor name is `main`\n   * but you can override this and add extra sources/executors via the\n   * `pgServices` configuration option.\n   */\n  const executor = build.input.pgRegistry.pgExecutors.main;\n\n  return {\n    typeDefs: /* GraphQL */ `\n      input MyCustomMutationInput {\n        count: Int\n      }\n      type MyCustomMutationPayload {\n        numbers: [Int!]\n      }\n      extend type Mutation {\n        \"\"\"\n        An example mutation that doesn't really do anything; uses Postgres'\n        generate_series() to return a list of numbers.\n        \"\"\"\n        myCustomMutation(input: MyCustomMutationInput!): MyCustomMutationPayload\n      }\n    `,\n\n    plans: {\n      Mutation: {\n        myCustomMutation(_$root, { $input: { $count } }) {\n          /**\n           * This step dictates the data that will be passed as the second argument\n           * to the `withPgClientTransaction` callback. This is typically\n           * information about the field arguments, details from the GraphQL\n           * context, or data from previously executed steps.\n           */\n          const $data = object({\n            count: $count,\n          });\n\n          // Callback will be called with a client that's in a transaction,\n          // whatever it returns (plain data) will be the result of the\n          // `withPgClientTransaction` step; if it throws an error then the\n          // transaction will roll back and the error will be the result of the\n          // step.\n          // highlight-start\n          const $transactionResult = withPgClientTransaction(\n            executor,\n            $data,\n            async (client, data) => {\n              // The data from the `$data` step above\n              const { count } = data;\n\n              // Run some SQL\n              const { rows } = await client.query(\n                sql.compile(\n                  sql`select i from generate_series(1, ${sql.value(\n                    count ?? 1,\n                  )}) as i;`,\n                ),\n              );\n\n              // Do some asynchronous work (e.g. talk to Stripe or whatever)\n              await sleep(2);\n\n              // Maybe run some more SQL as part of the transaction\n              await client.query(sql.compile(sql`select 1;`));\n\n              // Return whatever data you'll need later\n              return rows.map((row) => row.i);\n            },\n          );\n          // highlight-end\n\n          return $transactionResult;\n        },\n      },\n      MyCustomMutationPayload: {\n        numbers($transactionResult) {\n          return $transactionResult;\n        },\n      },\n    },\n  };\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving SQL Records by Column and Batching Inputs with Grafast Step (TypeScript)\nDESCRIPTION: This code defines a custom Grafast step class 'RecordsByColumnStep' for batch retrieving records from a SQL table where a specified column matches a batched input value. It enables optional unary limiting through a 'setFirst' method, ensuring the limit parameter is consistent across the batch using unary dependencies. The constructor sets up dynamic dependencies, and the 'execute' method constructs and executes parameterized SQL queries using a provided 'executeSQL' function, mapping the results back to the batched input order. This requires Grafast and assumes the use of Node.js, along with an 'executeSQL' utility and potentially safe handling for SQL identifiers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class RecordsByColumnStep extends Step {\n  constructor(tableName, columnName, $columnValue) {\n    super();\n    this.tableName = tableName;\n    this.columnName = columnName;\n    this.columnValueDepIdx = this.addDependency($columnValue);\n  }\n\n  setFirst($first) {\n    this.firstDepId = this.addUnaryDependency($first);\n  }\n\n  async execute({ indexMap, values }) {\n    // Retrieve the values for the `$columnValue` dependency\n    const columnValueDep = values[this.columnValueDepIdx];\n\n    // We may or may not have added a `$first` limit:\n    const firstDep =\n      this.firstDepId !== undefined ? values[this.firstDepId] : undefined;\n\n    // firstDep, if it exists, is definitely a unary dep (!firstDep.isBatch), so\n    // we can retrieve its value directly:\n    const first = firstDep ? parseInt(firstDep.value, 10) : null;\n\n    // Create a `LIMIT` clause in our SQL if the user specified a `$first` limit:\n    const limitSQL = Number.isFinite(first) ? `limit ${first}` : ``;\n\n    // Create placeholders for each entry in our batch in the SQL:\n    const placeholders = indexMap(() => \"?\");\n    // The value from `$columnValue` for each index `i` in the batch\n    const columnValues = indexMap((i) => columnValueDep.at(i));\n\n    // Build the SQL query to execute:\n    const sql = `\\\n      select *\n      from ${this.tableName}\n      where ${this.columnName} in (${placeholders.join(\", \")})\n      ${limitSQL}\n    `;\n\n    // Execute the SQL query once for all values in the batch:\n    const rows = await executeSQL(sql, columnValues);\n\n    // Figure out which rows relate to which batched inputs:\n    return indexMap((i) =>\n      rows.filter((row) => row[this.columnName] === columnValues[i]),\n    );\n  }\n}\n\nfunction petsByOwnerId($ownerId) {\n  return new RecordsByColumnStep(\"pets\", \"owner_id\", $ownerId);\n}\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with a Subscription Field via makeExtendSchemaPlugin (TypeScript)\nDESCRIPTION: Defines a full subscription implementation using makeExtendSchemaPlugin in PostGraphile. Extends the Subscription type with a forumMessage(forumId: Int!) field, sets up resolvers for both streaming events and payload mapping. Uses grafast helpers to construct dynamic subscription topics, and jsonParse to convert event payloads. Requires PostGraphile, grafast, and the messages resource. Parameters include forumId as a subscription argument and event objects as payloads. Emits ForumMessageSubscriptionPayload containing event type and related message details; expects event payloads with 'event' and 'id' fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeExtendSchemaPlugin } from \"postgraphile/utils\";\nimport { context, lambda, listen } from \"postgraphile/grafast\";\nimport { jsonParse } from \"postgraphile/@dataplan/json\";\n\nconst MySubscriptionPlugin = makeExtendSchemaPlugin((build) => {\n  const { messages } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: /* GraphQL */ `\n      extend type Subscription {\n        forumMessage(forumId: Int!): ForumMessageSubscriptionPayload\n      }\n\n      type ForumMessageSubscriptionPayload {\n        event: String\n        message: Message\n      }\n    `,\n    plans: {\n      Subscription: {\n        forumMessage: {\n          subscribePlan(_$root, args) {\n            const $pgSubscriber = context().get(\"pgSubscriber\");\n            const $forumId = args.get(\"forumId\");\n            const $topic = lambda($forumId, (id) => `forum:${id}:message`);\n            return listen($pgSubscriber, $topic, jsonParse);\n          },\n          plan($event) {\n            return $event;\n          },\n        },\n      },\n      ForumMessageSubscriptionPayload: {\n        event($event) {\n          return $event.get(\"event\");\n        },\n        message($event) {\n          const $id = $event.get(\"id\");\n          return messages.get({ id: $id });\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions on Schema Objects - PostgreSQL - SQL\nDESCRIPTION: Assigns schema, table, sequence, and function privileges to different user roles in the forum_example schema. The code demonstrates revoking default function execute privileges, granting usage and access rights to anonymous and authenticated users, and restricting sensitive operations like registration to appropriate roles only. Key dependencies include the prior creation of underlying objects (schemas, tables, functions, sequences) and roles. This configuration ensures that users can only perform actions explicitly permitted, establishing a whitelist-based security model at the database level.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_38\n\nLANGUAGE: sql\nCODE:\n```\n-- after schema creation and before function creation\nalter default privileges revoke execute on functions from public;\n\ngrant usage on schema forum_example to forum_example_anonymous, forum_example_person;\n\ngrant select on table forum_example.person to forum_example_anonymous, forum_example_person;\ngrant update, delete on table forum_example.person to forum_example_person;\n\ngrant select on table forum_example.post to forum_example_anonymous, forum_example_person;\ngrant insert, update, delete on table forum_example.post to forum_example_person;\ngrant usage on sequence forum_example.post_id_seq to forum_example_person;\n\ngrant execute on function forum_example.person_full_name(forum_example.person) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.post_summary(forum_example.post, integer, text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.person_latest_post(forum_example.person) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.search_posts(text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.authenticate(text, text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.current_person() to forum_example_anonymous, forum_example_person;\n\ngrant execute on function forum_example.register_person(text, text, text, text) to forum_example_anonymous;\n```\n\n----------------------------------------\n\nTITLE: Building and Compiling Dynamic SQL Queries with pg-sql2 in JavaScript\nDESCRIPTION: Illustrates the core workflow of `pg-sql2`: importing the library, defining dynamic parts like table and field names, using `sql.identifier` for safe escaping, `sql.join` to combine multiple identifiers, `sql.value` for parameterizing user input to prevent SQL injection, composing nested queries using `sql` tagged template literals, creating unique aliases with `sql.identifier(Symbol())`, and finally using `sql.compile` to generate the SQL text and values array ready for execution via a database driver like `pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { default: sql } = require(\"pg-sql2\");\n// or import sql from 'pg-sql2';\n\nconst tableName = \"user\";\nconst fields = [\"name\", \"age\", \"height\"];\n\n// sql.join is used to join fragments with a common separator, NOT to join tables!\nconst sqlFields = sql.join(\n  // sql.identifier safely escapes arguments and joins them with dots\n  fields.map((fieldName) => sql.identifier(tableName, fieldName)),\n  \", \",\n);\n\n// sql.value will store the value and instead add a placeholder to the SQL\n// statement, to ensure that no SQL injection can occur.\nconst sqlConditions = sql`created_at > NOW() - interval '3 years' and age > ${sql.value(\n  22,\n)}`;\n\n// This could be a full query, but we're going to embed it in another query safely\nconst innerQuery = sql`select ${sqlFields} from ${sql.identifier(\n  tableName,\n)} where ${sqlConditions}`;\n\n// Symbols are automatically assigned unique identifiers\nconst sqlAlias = sql.identifier(Symbol());\n\nconst query = sql`\nwith ${sqlAlias} as (${innerQuery})\nselect\n  (select json_agg(row_to_json(${sqlAlias})) from ${sqlAlias}) as all_data,\n  (select max(age) from ${sqlAlias}) as max_age\n`;\n\n// sql.compile compiles the query into an SQL statement and a list of values\nconst { text, values } = sql.compile(query);\n\nconsole.log(text);\n/* ->\nwith __local_0__ as (select \"user\".\"name\", \"user\".\"age\", \"user\".\"height\" from \"user\" where created_at > NOW() - interval '3 years' and age > $1)\nselect\n  (select json_agg(row_to_json(__local_0__)) from __local_0__) as all_data,\n  (select max(age) from __local_0__) as max_age\n*/\n\nconsole.log(values); // [ 22 ]\n\n// Then to run the query using `pg` module, do something like:\n// const { rows } = await pg.query(text, values);\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Table with Constraints and Defaults (SQL)\nDESCRIPTION: Illustrates creating a `users` table in PostgreSQL. It showcases defining columns with types like `serial` (auto-incrementing primary key), `citext` (case-insensitive text, requires extension), `text`, and `timestamptz` (timestamp with time zone). Includes constraints like `primary key`, `not null`, `unique`, `check` (with regex validation using `~`), and default values using `default now()`. Note the recommendation to prefer `int generated always as identity` over `serial` for primary keys.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table users (\n  id serial primary key,\n  username citext not null unique check(username ~ '^[a-z][a-z0-9]+$'),\n  first_name text,\n  last_name text,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Schema Behavior for Lists/Connections in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to configure the default behavior for schema generation in Graphile Crystal using a preset object, typically within a `graphile.config.mjs` file. It sets the `defaultBehavior` property within the `schema` key to `\"-connection +list\"`. This specific configuration instructs Graphile Crystal to disable the generation of GraphQL connection fields (`-connection`) by default and instead enable the generation of simple list fields (`+list`) for collections of records. This allows users to prioritize simpler list structures over the more complex but feature-rich connection pattern if desired.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/connections.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"graphile.config.mjs\"\nconst preset = {\n  schema: {\n    defaultBehavior: \"-connection +list\",\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a User Primary Email as Computed Column (SQL)\nDESCRIPTION: Implements a computed column function 'users_primaryEmail' which, given a user row, returns the primary verified email for the current user or null for others. It reads from 'user_emails', restricts emails to those belonging to 'current_user_id()', and ensures emails are verified and ordered. It requires the functions 'current_user_id()', the 'users' and 'user_emails' tables, and must be installed in a PostgreSQL database. Result is 'text' or null. Should be declared on the same schema as users.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n/*\n * Returns the primary email of the\n * current user; for all other users\n * this function will return null.\n */\ncreate function \"users_primaryEmail\"(u users)\nreturns text\nas $$\n  select email\n  from user_emails\n  where user_id = current_user_id()\n  and user_id = u.id\n  and is_verified is true\n  order by id asc\n  limit 1;\n$$ language sql stable set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Querying Related Data Using loadOne and loadMany in Graphile (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates defining plan resolvers for a GraphQL schema using Graphile. The Query resolver uses loadOne to fetch a user by ID, and the User resolver uses loadMany to fetch friends of a user. The callbacks (batchGetUserById, batchGetFriendsByUserId) are responsible for the actual data fetching. Dependencies include the context retrieval and Graphile step functions. The snippet highlights the lack of ioEquivalence, meaning chained rather than parallel fetch execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst plans = {\n  Query: {\n    currentUser() {\n      const $currentUserId = context().get(\"userId\");\n      return loadOne($currentUserId, batchGetUserById);\n    },\n  },\n  User: {\n    friends($user) {\n      const $userId = $user.get(\"id\");\n      return loadMany($userId, batchGetFriendsByUserId);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Excluding Database Objects from Schema with @behavior Smart Tag\nDESCRIPTION: Illustrates the '@behavior -*' smart tag, usually placed in SQL comments. This tag instructs Graphile to completely omit the associated database object (e.g., table, column, function) and its default behaviors (like CRUD operations) from the generated GraphQL schema, effectively hiding it.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n@behavior -*\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Schema Using makeSchema in JavaScript\nDESCRIPTION: This snippet illustrates the updated way to build a GraphQL schema leveraging 'makeSchema' from PostGraphile V5. The preset configuration is imported and passed to 'makeSchema', which returns the constructed schema and the resolved preset. Dependencies include the 'postgraphile' package and a valid preset file. Inputs are the preset configuration, while outputs are both the schema and resolved preset objects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_19\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Dynamically Setting Update Attributes with pgUpdateSingle.set in TypeScript\nDESCRIPTION: Illustrates how to use the `.set(attr, $value)` method on the step returned by `pgUpdateSingle` to incrementally add attributes to be updated. This approach allows building the update statement dynamically, potentially based on conditions. The example shows setting 'username' and 'bio' attributes separately after initiating the update step.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgUpdateSingle.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $updatedUser = pgUpdateSingle(usersResource, { id: $id });\n$updatedUser.set(\"username\", $username);\n$updatedUser.set(\"bio\", $bio);\n\n// Roughly equivalent to:\n// `UPDATE users SET username = $1, bio = $2 WHERE id = $3;`\n```\n\n----------------------------------------\n\nTITLE: Importing grafserv for Different HTTP Servers - JavaScript\nDESCRIPTION: This snippet shows how to import the 'grafserv' function from the appropriate subpath of 'postgraphile' depending on the HTTP server framework (Express, Node.js, Koa, Fastify). It requires the 'postgraphile' npm package. Inputs are your choice of subpath; output is the grafserv function for use with your preferred framework.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\n// OR: import { grafserv } from \"postgraphile/grafserv/node\";\n// OR: import { grafserv } from \"postgraphile/grafserv/koa/v2\";\n// OR: import { grafserv } from \"postgraphile/grafserv/fastify/v4\";\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT and JWKS Middleware in Express - JavaScript\nDESCRIPTION: This snippet defines the 'checkJwt' authentication middleware for Express using the 'express-jwt' and 'jwks-rsa' libraries. It dynamically obtains signing keys from the Auth0 JWKS endpoint, enforces key caching and rate limits, and validates the token audience, issuer, and signature algorithm. The middleware ensures every incoming request to protected routes presents a verifiable JWT, attaching its payload to 'req.user' on success. Replace 'YOUR_DOMAIN' and 'YOUR_API_IDENTIFIER' with your Auth0 settings. Required dependencies: 'express-jwt', 'jwks-rsa', and a valid Auth0 configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\n// Authentication middleware. When used, the\n// Access Token must exist and be verified against\n// the Auth0 JSON Web Key Set.\n// On successful verification, the payload of the\n// decrypted Access Token is appended to the\n// request (`req`) as a `user` parameter.\nconst checkJwt = jwt({\n  // Dynamically provide a signing key\n  // based on the `kid` in the header and\n  // the signing keys provided by the JWKS endpoint.\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n\n  // Validate the audience and the issuer.\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Single-File Express-Based PostGraphile Server Setup - JavaScript\nDESCRIPTION: This complete JavaScript example demonstrates configuring and launching an ExpressJS server with PostGraphile. It creates the preset, sets up the service (including connection string from environment), initializes PostGraphile, Grafserv, Express, and HTTP server, handles errors and GraphQL subscriptions, and manages application startup and shutdown. Dependencies include 'express', 'postgraphile', 'node:http', and related PostGraphile modules. Inputs are environment variables, configuration, and server parameters; output is a running GraphQL server on the specified port.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport express from \"express\";\nimport { createServer } from \"node:http\";\nimport { postgraphile } from \"postgraphile\";\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\n\n// Which port do we want to listen for requests on?\nconst PORT = 5050;\n\n// Our PostGraphile configuration, we're going (mostly) with the defaults:\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [PostGraphileAmberPreset],\n  pgServices: [\n    makePgService({\n      connectionString: process.env.DATABASE_URL,\n      schemas: [\"public\"],\n    }),\n  ],\n  grafast: {\n    explain: true,\n  },\n};\n\n// Create our PostGraphile instance, `pgl`:\nconst pgl = postgraphile(preset);\n\n// Create our PostGraphile grafserv instance, `serv`:\nconst serv = pgl.createServ(grafserv);\n\nasync function main() {\n  // Create an express app:\n  const app = express();\n\n  // Create a Node HTTP server, and have the express app handle requests:\n  const server = createServer(app);\n\n  // If the server were to produce any errors after it has been successfully\n  // set up, log them:\n  server.once(\"listening\", () => {\n    server.on(\"error\", (e) => void console.error(e));\n  });\n\n  // Mount our grafserv instance inside of the Express app, also passing the\n  // reference to the Node.js server for use with websockets (for GraphQL\n  // subscriptions):\n  await serv.addTo(app, server);\n\n  // Start listening for HTTP requests:\n  server.listen(PORT, () => {\n    console.log(`Server listening at http://localhost:${PORT}`);\n  });\n}\n\n// Start the main process, exiting if an error occurs during setup.\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Masking Sensitive Fields Using Plan Wrapping (JavaScript, PostGraphile)\nDESCRIPTION: Shows how to use makeWrapPlansPlugin to control field-level data exposure by masking the 'email' field for unauthorized users. The logic retrieves both the current user's ID from context and the target user's ID, ensuring email is only returned to its owner. This technique requires PostGraphile V5, lambda, and context access; it expects the field to be nullable if data masking is performed, with outputs either exposing or hiding sensitive information based on identity checks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst plugin = makeWrapPlansPlugin({\n  User: {\n    email(plan, $user, args, info) {\n      // Get 'userId' from the GraphQL context\n      const $myUserId = context().get(\"userId\");\n\n      // Get the user's ID\n      const $theirUserId = $user.get(\"id\");\n\n      // Get the email via the original plan\n      const $email = plan();\n\n      // Now return a new plan that only returns the email if the IDs match\n      return lambda(\n        [$myUserId, $theirUserId, $email],\n        ([myUserId, theirUserId, email]) => {\n          if (myUserId === theirUserId) {\n            return email;\n          } else {\n            return null; // TODO: ensure the 'email' field is nullable!\n          }\n        },\n      );\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector in JavaScript (PostGraphile Plugin)\nDESCRIPTION: This JavaScript code sample defines a PostGraphile plugin that adds a new inflector method named 'enhanced', which appends 'Enhanced' to a given column name. The plugin exports an object conforming to the 'GraphileConfig.Plugin' structure and is intended for use with PostGraphile's plugin system. No external type declarations are needed in JavaScript. Inputs are the preset and a column name; output is the enhanced column name string. The plugin must be registered for the inflector to be available.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\\n  name: \\\"MyNewInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n  inflection: {\\n    add: {\\n      enhanced(preset, columnName) {\\n        return columnName + \\\"Enhanced\\\";\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Replacing the 'builtin' Inflector in Graphile Build (TypeScript)\nDESCRIPTION: This TypeScript plugin demonstrates how to replace an existing Graphile inflector, specifically the `builtin` inflector. It uses the `inflection.replace` property within the plugin definition. The replacement function receives the previous inflector function and the resolved preset as arguments, allowing modification or conditional fallback. This example changes the root query type name from 'Query' to 'RootQuery'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Import types for TypeScript, no need in JS\nimport \"graphile-config\";\nimport \"graphile-build\";\nimport \"graphile-build-pg\";\n\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\n  // Unique name for your plugin:\n  name: \"ReplaceInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      builtin(\n        // The previous version of this inflector, the one you're replacing\n        previous,\n\n        // The resolved configuration\n        preset,\n\n        // Everything from the 3rd paramater onward are the arguments to this inflector\n        text,\n      ) {\n        if (name === \"Query\") return \"RootQuery\";\n        return previous(text);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Simple Subscriptions via Express Middleware - PostGraphile (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates integrating PostGraphile with simple subscriptions enabled as an Express middleware using the pluginHook for the @graphile/pg-pubsub plugin. Required dependencies are express, postgraphile, and @graphile/pg-pubsub. It shows how to configure websocket middlewares for handling sessions. The 'databaseUrl', expected as a variable, should be defined elsewhere in your application environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile, makePluginHook } = require(\"postgraphile\");\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\");\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst postgraphileOptions = {\n  pluginHook,\n  subscriptions: true,\n  simpleSubscriptions: true,\n  websocketMiddlewares: [\n    // Add whatever middleware you need here, note that they should only\n    // manipulate properties on req/res, they must not sent response data. e.g.:\n    //\n    //   require('express-session')(),\n    //   require('passport').initialize(),\n    //   require('passport').session(),\n  ],\n};\n\nconst app = express();\napp.use(postgraphile(databaseUrl, \"app_public\", postgraphileOptions));\napp.listen(parseInt(process.env.PORT, 10) || 3000);\n```\n\n----------------------------------------\n\nTITLE: Switching Role and Setting Claims per Session - JavaScript\nDESCRIPTION: This snippet configures PostGraphile to set both the PostgreSQL session role and an application-specific JWT claim by returning an object from the `pgSettings` asynchronous function. The function takes the incoming request, extracts the user ID, and assigns 'visitor' to the 'role' variable and the user ID to 'jwt.claims.user_id'. Both keys use proper naming conventions to avoid conflicts with PostgreSQL extensions. This enables advanced access control and multi-tenancy support, and is dependent on roles and claims setup in the database and JWT policies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nexport postgraphile(process.env.DATABASE_URL, schemaName, {\n  pgSettings: async req => ({\n    'role': 'visitor',\n    'jwt.claims.user_id': `${req.user.id}`,\n    //...\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Table Enums with PostgreSQL Functions via Domains (SQL)\nDESCRIPTION: Demonstrates how to use PostgreSQL domains to link function arguments and return types to table-based enums (`stage_options`) for correct GraphQL typing in PostGraphile 4.14.0+. It shows two methods for domain definition: naming convention (`[enum_name]_enum_domain`) or using a smart comment (`@enum the_enum_table_it_references`). Includes example functions (`applicants_next_stage`, `applicants_by_stage`) using these domains. Requires the `stage_options` enum table and `applicants` table to exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table stage_options (\n  type text primary key\n);\ncomment on table stage_options is E'@enum';\ninsert into stage_options\n  (type) values\n  ('pending'),\n  ('round 1'),\n  ('round 2'),\n  ('rejected'),\n  ('hired');\n\n-- Either follow the convention of [enum_name]_enum_domain:\ncreate domain stage_options_enum_domain as text;\n-- or use any name for the domain and add a smart comment:\n-- create domain stage as text;\n-- comment on domain stage is E'@enum stage_options';\n\n-- This function will add a `nextStage` field to applicant with GraphQL type\n-- `StageOptions` (our table enum):\ncreate function applicants_next_stage(a applicants)\nreturns stage_options_enum_domain\nas $$\n  select (case\n    when a.stage = 'round 2' then 'hired'\n    else 'rejected'\n  end)::stage_options_enum_domain;\n$$ language sql stable;\n\n-- This function allows to filter applicants by `StageOptions` value:\ncreate function applicants_by_stage(wanted_stage stage_options_enum_domain)\nreturns setof applicants\nas $$\n  select * from applicants a where a.stage = wanted_stage\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Wrapping Multiple Mutation Plans for User Data Validation using makeWrapPlansPlugin (Method 1) in TypeScript\nDESCRIPTION: Shows how to use Method 1 of `makeWrapPlansPlugin` to apply the same validation logic to multiple mutation fields (`createUser`, `updateUser`, `updateUserById`, `updateUserByEmail`). It defines a helper function `validateUserData` which creates a plan wrapper. This wrapper uses `sideEffect` from `postgraphile/grafast` to call `assertValidUserData` on the relevant input argument before executing the original mutation plan via `plan()`. Dependencies include `makeWrapPlansPlugin` and `sideEffect`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sideEffect } from \"postgraphile/grafast\";\n\nfunction assertValidUserData(data) {\n  if (!data || data.username?.length === 0) {\n    throw new Error(\"Invalid data\");\n  }\n}\n\nconst validateUserData = (propName) => {\n  return (plan, $source, fieldArgs) => {\n    const $user = fieldArgs.getRaw([\"input\", propName]);\n\n    // Callback throws error if invalid\n    sideEffect($user, (user) => assertValidUserData(user));\n\n    return plan();\n  };\n};\n\nexport default makeWrapPlansPlugin({\n  Mutation: {\n    createUser: validateUserData(\"user\"),\n    updateUser: validateUserData(\"userPatch\"),\n    updateUserById: validateUserData(\"userPatch\"),\n    updateUserByEmail: validateUserData(\"userPatch\"),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client Cache for Object IDs (Apollo Client, TypeScript)\nDESCRIPTION: This TypeScript code sets up an Apollo Client instance with a custom cache policy that uses an object's `id` (or `nodeId`) as the cache key. Dependencies include `apollo-client`, `apollo-link-http`, and `apollo-cache-inmemory`. The `dataIdFromObject` function extracts `id` or `nodeId` to uniquely identify cached objects, supporting GraphQL schemas conforming to the global object identification spec. Replace 'id' with 'nodeId' if the schema uses that field for unique identification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/node-id.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport ApolloClient from \"apollo-client\";\nimport { HttpLink } from \"apollo-link-http\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\n\nconst cache = new InMemoryCache({\n  // highlight-next-line\n  dataIdFromObject: (object) => object.id || null,\n  // Or if you renamed 'id' to 'nodeId' then:\n  //   dataIdFromObject: (object) => object.nodeId || null,\n});\n\nexport const client = new ApolloClient({\n  link: new HttpLink(),\n  cache,\n});\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query Demonstrating Potential DoS Attack Vector\nDESCRIPTION: This GraphQL query illustrates how a deeply nested request can potentially lead to a Denial of Service (DoS) attack by demanding excessive server resources. It demonstrates fetching users, their posts, the comments on those posts, the authors of those comments, and repeating this pattern, potentially overwhelming the database and server. This example highlights the need for query complexity analysis or timeouts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/production.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nallUsers {\n  nodes {\n    postsByAuthorId {\n      nodes {\n        commentsByPostId {\n          userByAuthorId {\n            postsByAuthorId {\n              nodes {\n                commentsByPostId {\n                  userByAuthorId {\n                    postsByAuthorId {\n                      nodes {\n                        commentsByPostId {\n                          userByAuthorId {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating 'containsPostsByUserId' Condition Plugin in JavaScript\nDESCRIPTION: Example JavaScript plugin using `makeAddPgTableConditionPlugin` to filter `app_public.forums` based on whether they contain posts by a specific user ID. This involves generating an SQL `WHERE` clause with an `EXISTS` subquery checking the related `app_public.posts` table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/* TODO: test this plugin works! */\nmodule.exports = makeAddPgTableConditionPlugin(\n  \"app_public\",\n  \"forums\",\n  \"containsPostsByUserId\",\n  (build) => ({\n    description:\n      \"Filters the list of forums to only those which \" +\n      \"contain posts written by the specified user.\",\n    type: build.graphql.GraphQLInt,\n  }),\n  (value, helpers, build) => {\n    const { sql, sqlTableAlias } = helpers;\n    const sqlIdentifier = sql.identifier(Symbol(\"postsByUser\"));\n\n    // This is merged into the `WHERE` clause, so we end up with\n    // something like:\n    //\n    // ```sql\n    // SELECT ...\n    // FROM app_public.forums AS <sqlTableAlias>\n    // WHERE ...\n    // AND (\n    //   -- This is our returned fragment:\n    //   exists (select 1 from ...)\n    // )\n    // ```\n    return sql.fragment`exists(\n      select 1\n      from app_public.posts as ${sqlIdentifier}\n      where ${sqlIdentifier}.forum_id = ${sqlTableAlias}.id\n      and ${sqlIdentifier}.user_id = ${sql.value(value)}\n    )`;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Multi-Level Album and Track Data with Nested Genre - GraphQL\nDESCRIPTION: Performs a three-level nested GraphQL query to obtain albums filtered by artistId (127), each album's tracks, and each track's genre name. This pattern leverages PostGraphile's efficient join resolution and demonstrates moderate query complexity, serving about 1450 requests per second in benchmarks. The input parameter 'artistId' helps filter albums, and the expected output is a nested tree of albums, tracks, and genres.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/performance.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nquery albums_tracks_genre_some {\n  allAlbumsList(condition: { artistId: 127 }) {\n    artistId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Table Behavior using SQL Smart Comment\nDESCRIPTION: Uses a SQL `COMMENT` statement with the `@behavior` smart tag on the `users` table. The `-insert -delete` value instructs PostGraphile to omit the standard insert and delete mutations for this table from the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table users is\n  E'@behavior -insert -delete';\n```\n\n----------------------------------------\n\nTITLE: Setting Graphile Build Scopes for Types and Fields in TypeScript\nDESCRIPTION: Demonstrates customizing the Graphile Build \"scope\" for a GraphQL type (`MyObject`) and its field (`id`) within a `makeExtendSchemaPlugin`. It utilizes the special `__scope` key within the type's `plans` definition to set type-level scopes (e.g., `pgTypeResource`) and the `scope` key within an object defining the field's plan resolver to set field-level scopes (e.g., `pgFieldAttribute`). These scopes provide metadata used by other Graphile Build plugins to determine how to interact with or augment these schema elements.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\n\nconst schema = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      type MyObject {\n        id: Int\n      }\n    `,\n    plans: {\n      MyObject: {\n        // Graphile Build \"scope\" for the object type 'MyObject'\n        __scope: {\n          pgTypeResource: users,\n        },\n\n        id: {\n          // The Graphile Build \"scope\" for the 'MyObject.id' field\n          scope: {\n            pgFieldAttribute: users.codec.attributes.id,\n          },\n\n          // The plan resolver for the 'MyObject.id' field\n          plan($obj) {\n            return $obj.get(\"id\");\n          },\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Efficient RLS Policy Function Using Set Comparison in PostgreSQL (SQL)\nDESCRIPTION: Presents an improved, performant Row-Level Security (RLS) pattern. It defines an SQL function `current_user_organization_ids` that returns the set of all organization IDs the current user is a member of. The RLS policy (`select_members`) then uses this function once within an `IN` clause (`organization_id in (select current_user_organization_ids())`). This avoids per-row function calls, allowing PostgreSQL to optimize the check efficiently, often using indexes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"Much better - only a single function call\"\ncreate function current_user_organization_ids() returns setof int as $$\n  select organization_id\n  from memebrs\n  where user_id = current_user_id();\n$$ language sql stable security definer;\n\ncreate policy select_members\n  for select on members\n  using (\n    /* highlight-next-line */\n    organization_id in (select current_user_organization_ids())\n  );\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PetsCount Condition Plugin in TypeScript (V5, postgraphile/utils)\nDESCRIPTION: This TypeScript snippet demonstrates how to define a custom user filter based on pet count using makeAddPgTableConditionPlugin from postgraphile/utils under the newer V5 signature. It builds an input field (petCountAtLeast) and a condition generator leveraging the plan system. It requires dependencies such as postgraphile/utils, postgraphile/@dataplan/pg (for TYPES), and an up-to-date PostGraphile installation. The snippet shows how to safely handle planned input values with type-safe SQL placeholders.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \\\"postgraphile/utils\\\";\\nimport { TYPES } from \\\"postgraphile/@dataplan/pg\\\";\\n\\nconst PetsCountPlugin = makeAddPgTableConditionPlugin(\\n  { schemaName: \\\"graphile_utils\\\", tableName: \\\"users\\\" },\\n  \\\"petCountAtLeast\\\",\\n  (build) => ({\\n    description: \\\"Filters users to those that have at least this many pets\\\",\\n    type: build.graphql.GraphQLInt,\\n  }),\\n  (value, helpers) => {\\n    const { sqlTableAlias, sql, $condition } = helpers;\\n    const $val = value.get();\\n    return sql.fragment`(select count(*) from graphile_utils.pets where pets.user_id = ${sqlTableAlias}.id) >= ${$condition.placeholder(\\n      $val,\\n      TYPES.int,\\n    )}`;\\n  },\\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring .dockerignore for a Node.js Project - plaintext\nDESCRIPTION: This snippet provides a sample .dockerignore file tailored for Node.js applications, especially ones using PostGraphile. It lists files and directories that should be excluded from Docker context to prevent unnecessary files, such as environment files, source control folders, IDE settings, build outputs, and test directories, from being copied into the Docker image. This helps to reduce image size and improves build performance. No external dependencies are required; the file must be named .dockerignore and placed in the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-docker.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# .dockerignore\\n.env\\n.git\\n.github\\n.next\\n.vscode\\nnode_modules\\n\\n*Dockerfile*\\n*docker-compose*\\n\\n**/dist\\n**/__tests__\n```\n\n----------------------------------------\n\nTITLE: Calling GraphQL Operations from a Resolver in JavaScript\nDESCRIPTION: This snippet demonstrates how to invoke a nested GraphQL query from within another GraphQL resolver using JavaScript. It relies on having access to the 'graphql' function and the schema object, as well as a valid PostGraphile context. The function issues a query to retrieve a user's username by ID, handles the response, and returns the username. Required dependencies include the 'graphql' module and the 'build' object's context, and the expected input is arguments with 'userId'; output is the user's username. Ensure error handling is extended as necessary.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n/*\n * Assuming you have access to a `build` object, e.g. inside a\n * `makeExtendSchemaPlugin`, you can extract the `graphql` function\n * from the `graphql` library here like so:\n */\nconst {\n  graphql: { graphql },\n} = build;\n/*\n * Failing the above: `import { graphql } from 'graphql';` but beware of\n * duplicate `graphql` modules in your `node_modules` causing issues.\n */\n\nasync function myResolver(parent, args, context, info) {\n  // Whatever GraphQL query you wish to issue:\n  const document = /* GraphQL */ `\n    query MyQuery($userId: Int!) {\n      userById(id: $userId) {\n        username\n      }\n    }\n  `;\n  // The name of the operation in your query document (optional)\n  const operationName = \"MyQuery\";\n  // The variables for the query\n  const variables = { userId: args.userId };\n\n  const { data, errors } = await graphql(\n    info.schema,\n    document,\n    null,\n    context,\n    variables,\n    operationName,\n  );\n\n  // TODO: error handling\n\n  return data.userById.username;\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom CORS Plugin with PostGraphile Middleware (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to use the previously defined `makeAllowedOriginTweak` function to configure the PostGraphile middleware. It creates a plugin hook using `makePluginHook`, passing an instance of the CORS plugin configured for the origin 'https://graphql.rocks'. This `pluginHook` is then included in the options object passed to the `postgraphile` function when initializing the middleware.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nconst pluginHook = makePluginHook([\n  makeAllowedOriginTweak(\"https://graphql.rocks\"),\n]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Topic with Listen - Example Subscription (GraphQL)\nDESCRIPTION: This is an example GraphQL subscription operation showing how a client subscribes to a topic called \\\"hello\\\" using the listen field. The query demonstrates requesting nested object data, including a conditional fragment for type Foo. This can be used with GraphiQL or any compatible GraphQL client and requires the server to be running with subscriptions enabled.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  listen(topic: \"hello\") {\n    relatedNodeId\n    relatedNode {\n      nodeId\n      ... on Foo {\n        id\n        title\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending the GraphQL Schema for User Registration using PostGraphile Plugin in JavaScript\nDESCRIPTION: This snippet defines a custom mutation named 'registerUser' that registers a new user in the database and sends a welcome email. It uses PostGraphile's 'makeExtendSchemaPlugin' to define GraphQL type definitions and attach a resolver with transactional logic, leveraging the provided 'pgClient' and 'resolveInfo' to ensure consistency and return the appropriate data structure. Dependencies include PostGraphile, a PostgreSQL client in context, and a 'mockSendEmail' function. It expects user defined fields as input and outputs a custom payload; all error cases are wrapped in a sub-transaction for safety.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyRegisterUserMutationPlugin = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      input RegisterUserInput {\n        name: String!\n        email: String!\n        bio: String\n      }\n\n      type RegisterUserPayload {\n        user: User @pgField\n        query: Query\n      }\n\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n    `,\n    resolvers: {\n      Mutation: {\n        registerUser: async (_query, args, context, resolveInfo) => {\n          const { pgClient } = context;\n          // Start a sub-transaction\n          await pgClient.query(\"SAVEPOINT graphql_mutation\");\n          try {\n            // Our custom logic to register the user:\n            const {\n              rows: [user],\n            } = await pgClient.query(\n              `INSERT INTO app_public.users(\n                name, email, bio\n              ) VALUES ($1, $2, $3)\n              RETURNING *`,\n              [args.input.name, args.input.email, args.input.bio],\n            );\n\n            // Now we fetch the result that the GraphQL\n            // client requested, using the new user\n            // account as the source of the data. You\n            // should always use\n            // `resolveInfo.graphile.selectGraphQLResultFromTable` if you return database\n            // data from your custom field.\n            const [row] =\n              await resolveInfo.graphile.selectGraphQLResultFromTable(\n                sql.fragment`app_public.users`,\n                (tableAlias, queryBuilder) => {\n                  queryBuilder.where(\n                    sql.fragment`${tableAlias}.id = ${sql.value(user.id)}`,\n                  );\n                },\n              );\n\n            // Finally we send the email. If this\n            // fails then we'll catch the error\n            // and roll back the transaction, and\n            // it will be as if the user never\n            // registered\n            await mockSendEmail(\n              args.input.email,\n              \"Welcome to my site\",\n              `You're user ${user.id} - thanks for being awesome`,\n            );\n\n            // If the return type is a database record type, like User, then\n            // you would return `row` directly. However if it's an indirect\n            // interface such as a connection or mutation payload then\n            // you return an object with a `data` property. You can add\n            // additional properties too, that can be used by other fields\n            // on the result type.\n            return {\n              data: row,\n              query: build.$$isQuery,\n            };\n          } catch (e) {\n            // Oh noes! If at first you don't succeed,\n            // destroy all evidence you ever tried.\n            await pgClient.query(\"ROLLBACK TO SAVEPOINT graphql_mutation\");\n            throw e;\n          } finally {\n            // Release our savepoint so it doesn't conflict with other mutations\n            await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n          }\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with Random UUID Primary Key in PostgreSQL using SQL\nDESCRIPTION: Presents another alternative for the `person` table creation using fully random UUIDs (version 4) as primary keys. This requires enabling the `pgcrypto` extension and sets the default value for the `id` column (type `uuid`) to `gen_random_uuid()`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n\ncreate table forum_example.person (\n  id uuid primary key default gen_random_uuid(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Wrapping GraphQL Object Construction with Hooks in Graphile (JavaScript)\nDESCRIPTION: Demonstrates how the Graphile `newWithHooks` method allows plugins to intercept and modify object specifications by chaining hooks before constructing a new `GraphQLObjectType`. Shows the pattern of invocation using hooks as wrappers over the original object specification. No external dependencies required except standard Graphile and GraphQL modules. Input is the 'spec' object for the GraphQL type, and output is a constructed and possibly augmented type instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/hooks.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyType = newWithHooks(GraphQLObjectType, spec);\n```\n\n----------------------------------------\n\nTITLE: Querying Computed Columns with Arguments - Graphile GraphQL\nDESCRIPTION: This example demonstrates a GraphQL query that retrieves a topic's body and a computed summary, where the summary length is explicitly set using the 'maxLength' argument. The backend uses a computed column, implemented via a SQL function, that accepts this parameter to customize the summary length. The query expects the topic to be found by its ID and returns both body and adjusted summary fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  topic(id: 2) {\n    body\n    bodySummary(maxLength: 20)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Composite JWT Token Type in PostgreSQL (SQL)\nDESCRIPTION: Creates a composite type 'forum_example.jwt_token', used for encoding JWTs in PostGraphile. The type has 'role', 'person_id', and 'exp' properties suitable for permission and expiry handling. Required in the database before associating JWTs. Inputs are type column definitions; output is a registered composite type. Constraints: cannot store rows, only structures instances.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_32\n\nLANGUAGE: SQL\nCODE:\n```\ncreate type forum_example.jwt_token as (\n  role text,\n  person_id integer,\n  exp bigint\n);\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Forum Query\nDESCRIPTION: This JSON object represents the expected output structure for the GraphQL query fetching forum, topic, and post data. It shows the nested data for the 'cat-life' forum, including the first topic ('I love cats!'), its author ('user'), and the latest post within that topic by 'Bradley_A'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/relations.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forumBySlug\": {\n    \"name\": \"Cat Life\",\n    \"topics\": {\n      \"nodes\": [\n        {\n          \"id\": 4,\n          \"title\": \"I love cats!\",\n          \"bodySummary\": \"They're the best!\",\n          \"author\": {\n            \"id\": 1,\n            \"username\": \"user\"\n          },\n          \"posts\": {\n            \"nodes\": [\n              {\n                \"id\": 6,\n                \"author\": {\n                  \"id\": 3,\n                  \"username\": \"Bradley_A\"\n                },\n                \"body\": \"I love it when they completely ignore you until they want something. So much better than dogs am I rite?\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Default Database Executor in PostGraphile (TypeScript)\nDESCRIPTION: Demonstrates how to retrieve the default database executor, typically named 'main', from `build.input.pgRegistry.pgExecutors`. The executor is needed for operations like `withPgClient` that require explicit database connection information.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst executor = build.input.pgRegistry.pgExecutors.main;\n```\n\n----------------------------------------\n\nTITLE: Queuing a Job with Graphile Worker in SQL\nDESCRIPTION: This SQL snippet demonstrates how to add a job to the Graphile Worker queue using the `graphile_worker.add_job` function. It queues a task named 'hello' and passes a JSON payload containing a 'name' property. This is typically executed within a PostgreSQL function, trigger, or directly via a SQL client.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/background-tasks.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nselect graphile_worker.add_job('hello', json_build_object('name', 'Bobby Tables'));\n```\n\n----------------------------------------\n\nTITLE: Defining Global Behavior in a PostGraphile Plugin (Callback Method) (JavaScript)\nDESCRIPTION: Shows an alternative method for a PostGraphile plugin to modify global behavior using a callback function. This approach provides more control, allowing the plugin to explicitly combine its desired behavior (`\"-connection +list\"`) with the `currentBehavior` (which includes user-defined defaults), ensuring the user's configuration takes precedence.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/behavior.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst FavourListsPlugin = {\n  name: \"FavourListsPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    globalBehavior(currentBehavior, resolvedPreset) {\n      return [\"-connection +list\", currentBehavior];\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Bulk Insert Custom Mutation in PostgreSQL\nDESCRIPTION: Defines a PostgreSQL function `app_public.create_documents` for performing bulk inserts into the `app_public.document` table. It accepts the number of documents to create (`num`), their `type`, and `location`. Using `generate_series`, it inserts multiple rows based on the input parameters and returns the set of newly created documents via `returns setof app_public.document` and `returning *`. The `STRICT` keyword ensures all input arguments are non-nullable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-mutations.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.create_documents(num integer, type text, location text)\nreturns setof app_public.document\nas $$\n  insert into app_public.document (type, location)\n    select create_documents.type, create_documents.location\n    from generate_series(1, num) i\n    returning *;\n$$ language sql strict volatile;\n```\n\n----------------------------------------\n\nTITLE: Defining a JWT Composite Type in PostgreSQL\nDESCRIPTION: This SQL snippet defines a PostgreSQL composite type named `jwt_token` within the `my_public_schema`. This type represents the structure of the data that will be included as claims in the generated JWT payload, such as user role, expiration time, and user ID.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate type my_public_schema.jwt_token as (\n  role text,\n  exp integer,\n  person_id integer,\n  is_admin boolean,\n  username varchar\n);\n```\n\n----------------------------------------\n\nTITLE: Comparing GraphQL Queries Before and After Flattening (GraphQL)\nDESCRIPTION: This GraphQL snippet demonstrates two queries: 'Before' accesses nested person and address objects as generated from separate tables, while 'After' queries fields directly from the flattened 'personView'. It highlights structural changes in API shape after introducing a view. Inputs are unparameterized queries; outputs are the requested fields per query structure. These queries require a GraphQL schema where 'person' and 'personView' are both available.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/views.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery Before {\n  person {\n    id\n    address {\n      country\n      street\n    }\n  }\n}\n\nquery After {\n  personView {\n    id\n    country\n    street\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Grafast Plan Resolvers (TypeScript)\nDESCRIPTION: Presents the Grafast approach using plan resolvers for the same GraphQL schema. These functions are synchronous and operate during the planning phase. They don't fetch data directly but define 'steps' (e.g., `userById`, `$user.get`, `friendshipsByUserId`, `each`) that describe how to fetch the data later during the execution phase. Variables representing steps conventionally start with `$`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst planResolvers = {\n  Query: {\n    currentUser() {\n      return userById(context().get(\"currentUserId\"));\n    },\n  },\n  User: {\n    name($user) {\n      return $user.get(\"full_name\");\n    },\n    friends($user) {\n      const $friendships = friendshipsByUserId($user.get(\"id\"));\n      const $friends = each($friendships, ($friendship) =>\n        userById($friendship.get(\"friend_id\")),\n      );\n      return $friends;\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query Result with Custom Summary Length - JSON\nDESCRIPTION: This JSON snippet represents the result of a GraphQL query where the computed summary uses a custom 'maxLength' argument. The output shows the full body field and a summarized version of the body truncated to the specified maximum length. It exemplifies how computation and arguments are reflected in the API response structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"topic\": {\n    \"body\": \"PostGraphile is a powerful, idomatic, and elegant tool.\",\n    \"bodySummary\": \"PostGraphile is a...\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Query Functions in PostgreSQL for PostGraphile - SQL\nDESCRIPTION: Demonstrates creating PostgreSQL functions that can be automatically exposed as root-level custom queries in a PostGraphile-generated GraphQL schema. Functions must not return VOID, must be STABLE/IMMUTABLE, and should not take table types as their first argument. Each function becomes available in GraphQL as a query, with named arguments mapped to GraphQL arguments and return types corresponding to either scalars or records. Requires PostgreSQL and a PostGraphile setup with schema introspection enabled. Returns either a scalar value or a record, depending on the implementation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-queries.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql IMMUTABLE;\nCREATE FUNCTION my_other_function(a int, b int) RETURNS my_table AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile Plugins using CommonJS (Middleware)\nDESCRIPTION: This JavaScript code demonstrates importing the `postgraphile` library and server plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) using CommonJS `require` syntax. This approach is typically used when integrating PostGraphile as middleware in a Node.js application (e.g., with Express) in older Node environments or projects configured for CommonJS.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst { postgraphile, makePluginHook } = require(\"postgraphile\");\nconst { default: OperationHooks } = require(\"@graphile/operation-hooks\");\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\");\nconst { default: GraphilePro } = require(\"@graphile/pro\");\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an 'accept_team_invite' Secure Mutation Function (PostgreSQL, SQL)\nDESCRIPTION: Implements a secure custom mutation in PostgreSQL to accept a team invitation, returning updated team membership records. The function uses argument 'team_id', updates the 'accepted_at' timestamp, and ensures only unaccepted, authenticated members can execute it. Marked as STRICT (only called if arguments are non-null), VOLATILE, and SECURITY DEFINER (function runs as its creator, bypassing certain security layers). Used with PostGraphile to generate the 'acceptTeamInvite' mutation in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-mutations.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION app_public.accept_team_invite(team_id integer)\nRETURNS app_public.team_members\nAS $$\n  UPDATE app_public.team_members\n    SET accepted_at = now()\n    WHERE accepted_at IS NULL\n    AND team_members.team_id = accept_team_invite.team_id\n    AND member_id = app_public.current_user_id()\n    RETURNING *;\n$$ LANGUAGE sql VOLATILE STRICT SECURITY DEFINER;\n```\n\n----------------------------------------\n\nTITLE: Efficient RLS Policy Function Returning a Set (SQL)\nDESCRIPTION: Presents a much more performant approach for Row-Level Security (RLS). It defines a function `current_user_organization_ids` that returns a set of all `organization_id`s the current user is a member of. The `CREATE POLICY` statement then uses this function in its `USING` clause with an `IN` operator: `organization_id IN (select current_user_organization_ids())`. This ensures the function is called only once per query, allowing PostgreSQL to efficiently filter rows using the returned set of IDs, resulting in potentially thousands of times better performance compared to the per-row function call approach.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user_organization_ids() returns setof int as $$\n  select organization_id\n  from members\n  where user_id = current_user_id();\n$$ language sql stable security definer;\n\ncreate policy select_members\n  for select on members\n  using (\n    /* highlight-next-line */\n    organization_id in (select current_user_organization_ids())\n  );\n```\n\n----------------------------------------\n\nTITLE: Disabling Default CRUD Mutations in PostGraphile Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to modify the `graphile.config.mjs` file to prevent PostGraphile from automatically generating CRUD mutations. By setting `defaultBehavior` within the `schema` configuration to `\"-insert -update -delete\"`, these specific behaviors are disabled for all tables by default. This is useful when developers prefer to define custom mutations instead.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/crud-mutations.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  // ...\n  schema: {\n    defaultBehavior: \"-insert -update -delete\",\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example .env Configuration File for Database Connection - INI\nDESCRIPTION: This .env file example stores environment variables for PostGraphile, including the PostgreSQL connection string (to be customized) and the GRAPHILE_ENV setting. It should not be committed to version control. Inputs come from user-provided actual values for the connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_7\n\nLANGUAGE: INI\nCODE:\n```\n# Replace the contents of the square brackets with the details of your database\nDATABASE_URL=postgres://[username]:[password]@[host]:[port]/[database]\nGRAPHILE_ENV=development\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Test Helper Module in TypeScript\nDESCRIPTION: This TypeScript code defines a test helper module (`test_helper.ts`) for integration testing PostGraphile applications. It includes `setup` and `teardown` functions for managing resources like the database connection pool (`rootPgPool`) and GraphQL schema creation using `createPostGraphileSchema`. The core `runGraphQLQuery` function executes GraphQL queries within a managed transaction using `withPostGraphileContext`, allowing test assertions (`checker` function) and database state verification before automatically rolling back the transaction. A `sanitize` utility is also provided to stabilize snapshot tests by replacing dynamic values like IDs and timestamps. Dependencies include `express`, `graphql`, `pg`, `postgraphile`, `mock-req`, and type definitions. It requires configuration via environment variables and an imported `getPostGraphileOptions` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { Request, Response } from \"express\";\nimport { ExecutionResult, graphql, GraphQLSchema } from \"graphql\";\nimport { Pool, PoolClient } from \"pg\";\nimport {\n  createPostGraphileSchema,\n  PostGraphileOptions,\n  withPostGraphileContext,\n} from \"postgraphile\";\n\nimport { getPostGraphileOptions } from \"../src/middleware/installPostGraphile\";\n\nconst MockReq = require(\"mock-req\");\n\nlet known: Record<string, { counter: number; values: Map<unknown, string> }> =\n  {};\nbeforeEach(() => {\n  known = {};\n});\n/*\n * This function replaces values that are expected to change with static\n * placeholders so that our snapshot testing doesn't throw an error\n * every time we run the tests because time has ticked on in it's inevitable\n * march toward the future.\n */\nexport function sanitize(json: any): any {\n  /* This allows us to maintain stable references whilst dealing with variable values */\n  function mask(value: unknown, type: string) {\n    if (!known[type]) {\n      known[type] = { counter: 0, values: new Map() };\n    }\n    const o = known[type];\n    if (!o.values.has(value)) {\n      o.values.set(value, `[${type}-${++o.counter}]`);\n    }\n    return o.values.get(value);\n  }\n\n  if (Array.isArray(json)) {\n    return json.map((val) => sanitize(val));\n  } else if (json && typeof json === \"object\") {\n    const result = { ...json };\n    for (const k in result) {\n      if (k === \"nodeId\" && typeof result[k] === \"string\") {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (\n        k === \"id\" ||\n        k === \"uuid\" ||\n        (k.endsWith(\"Id\") &&\n          (typeof json[k] === \"number\" || typeof json[k] === \"string\")) ||\n        (k.endsWith(\"Uuid\") && typeof k === \"string\")\n      ) {\n        result[k] = mask(result[k], \"id\");\n      } else if (\n        (k.endsWith(\"At\") || k === \"datetime\") &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"timestamp\");\n      } else if (\n        k.match(/^deleted[A-Za-z0-9]+Id$/) &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (k === \"email\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"email\");\n      } else if (k === \"username\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"username\");\n      } else {\n        result[k] = sanitize(json[k]);\n      }\n    }\n    return result;\n  } else {\n    return json;\n  }\n}\n\n// Contains the PostGraphile schema and rootPgPool\ninterface ICtx {\n  rootPgPool: Pool;\n  options: PostGraphileOptions<Request, Response>;\n  schema: GraphQLSchema;\n}\nlet ctx: ICtx | null = null;\n\nexport const setup = async () => {\n  const rootPgPool = new Pool({\n    connectionString: process.env.TEST_DATABASE_URL,\n  });\n\n  const options = getPostGraphileOptions({ rootPgPool });\n  const schema = await createPostGraphileSchema(\n    rootPgPool,\n    \"app_public\",\n    options,\n  );\n\n  // Store the context\n  ctx = {\n    rootPgPool,\n    options,\n    schema,\n  };\n};\n\nexport const teardown = async () => {\n  try {\n    if (!ctx) {\n      return null;\n    }\n    const { rootPgPool } = ctx;\n    ctx = null;\n    rootPgPool.end();\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\nexport const runGraphQLQuery = async function runGraphQLQuery(\n  query: string, // The GraphQL query string\n  variables: { [key: string]: any } | null, // The GraphQL variables\n  reqOptions: { [key: string]: any } | null, // Any additional items to set on `req` (e.g. `{user: {id: 17}}`)\n  checker: (\n    result: ExecutionResult,\n    context: { pgClient: PoolClient },\n  ) => void | ExecutionResult | Promise<void | ExecutionResult> = () => {}, // Place test assertions in this function\n) {\n  if (!ctx) throw new Error(\"No ctx!\");\n  const { schema, rootPgPool, options } = ctx;\n  const req = new MockReq({\n    url: options.graphqlRoute || \"/graphql\",\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    ...reqOptions,\n  });\n  const res: any = { req };\n  req.res = res;\n\n  const {\n    pgSettings: pgSettingsGenerator,\n    additionalGraphQLContextFromRequest,\n  } = options;\n  const pgSettings =\n    (typeof pgSettingsGenerator === \"function\"\n      ? await pgSettingsGenerator(req)\n      : pgSettingsGenerator) || {};\n\n  // Because we're connected as the database owner, we should manually switch to\n  // the authenticator role\n  if (!pgSettings.role) {\n    pgSettings.role = process.env.DATABASE_AUTHENTICATOR;\n  }\n\n  await withPostGraphileContext(\n    {\n      ...options,\n      pgPool: rootPgPool,\n      pgSettings,\n      pgForceTransaction: true,\n    },\n    async (context) => {\n      let checkResult;\n      const { pgClient } = context;\n      try {\n        // This runs our GraphQL query, passing the replacement client\n        const additionalContext = additionalGraphQLContextFromRequest\n          ? await additionalGraphQLContextFromRequest(req, res)\n          : null;\n        const result = await graphql(\n          schema,\n          query,\n          null,\n          {\n            ...context,\n            ...additionalContext,\n            __TESTING: true,\n          },\n          variables,\n        );\n        // Expand errors\n        if (result.errors) {\n          if (options.handleErrors) {\n            result.errors = options.handleErrors(result.errors);\n          } else {\n            // This does a similar transform that PostGraphile does to errors.\n            // It's not the same. Sorry.\n            result.errors = result.errors.map((rawErr) => {\n              const e = Object.create(rawErr);\n              Object.defineProperty(e, \"originalError\", {\n                value: rawErr.originalError,\n                enumerable: false,\n              });\n\n              if (e.originalError) {\n                Object.keys(e.originalError).forEach((k) => {\n                  try {\n                    e[k] = e.originalError[k];\n                  } catch (err) {\n                    // Meh.\n                  }\n                });\n              }\n              return e;\n            });\n          }\n        }\n\n        // This is were we call the `checker` so you can do your assertions.\n        // Also note that we pass the `replacementPgClient` so that you can\n        // query the data in the database from within the transaction before it\n        // gets rolled back.\n        checkResult = await checker(result, {\n          pgClient,\n        });\n\n        // You don't have to keep this, I just like knowing when things change!\n        expect(sanitize(result)).toMatchSnapshot();\n\n        return checkResult == null ? result : checkResult;\n      } finally {\n        // Rollback the transaction so no changes are written to the DB - this\n        // makes our tests fairly deterministic.\n        await pgClient.query(\"rollback\");\n      }\n    },\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Manually Configuring `pgServices` in PostGraphile (JavaScript)\nDESCRIPTION: Demonstrates how to manually configure the `pgServices` array in a PostGraphile configuration. This involves importing the necessary `pg` module and adaptor (`@dataplan/pg/adaptors/pg`), defining service details like name, schemas, context keys (`pgSettingsKey`, `withPgClientKey`), and setting up the database connection pool via `adaptorSettings` using an environment variable (`process.env.DATABASE_URL`) for the connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as pg from \"pg\";\nimport * as adaptor from \"@dataplan/pg/adaptors/pg\";\n\nconst pgServices = [\n  {\n    name: \"main\",\n    schemas: [\"app_public\"],\n    pgSettingsKey: \"pgSettings\",\n    withPgClientKey: \"withPgClient\",\n    adaptor,\n    adaptorSettings: {\n      pool: new pg.Pool({ connectionString: process.env.DATABASE_URL }),\n      // superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Example JWT Access Token Payload - JSON\nDESCRIPTION: This snippet shows an example payload for an Auth0-issued JWT access token used by the authentication middleware. It demonstrates the typical claims such as 'iss' (issuer), 'sub' (subject), 'aud' (audience), 'scope', and timestamps. Useful for developers to understand what data will be available to Back-End or PostGraphile via the authentication context. The 'scope' value can be used for fine-grained permission checks at the database or application level.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"iss\": \"https://YOUR_DOMAIN/\",\n  \"sub\": \"CLIENT_ID@clients\",\n  \"aud\": \"YOUR_API_IDENTIFIER\",\n  \"iat\": 1555808706,\n  \"exp\": 1555895106,\n  \"azp\": \"CLIENT_ID\",\n  \"scope\": \"read:schema\", // scopes a.k.a. permissions\n  \"gty\": \"client-credentials\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Batch Fetch Callback for loadOne in Graphile (TypeScript)\nDESCRIPTION: This TypeScript function provides an example implementation of a callback for loadOne or loadMany, designed to efficiently fetch user data in batches from a SQL database. It demonstrates how to leverage attributes requested by the plan step, and ensures result order matches the input IDs. The function depends on an SQL builder (columnsToSql), a database connection (db), and returns a Promise of user objects. All accessed attributes and input IDs are dynamically handled.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function batchGetUserById(ids, { attributes }) {\n  // Your business logic would be called here; e.g. this might be the same\n  // function that your DataLoaders would call, except we can pass additional\n  // information to it.\n\n  // For example, load from the database\n  const rows = await db.query(\n    sql`SELECT id, ${columnsToSql(attributes)} FROM users WHERE id = ANY($1);`,\n    [ids],\n  );\n\n  // Ensure you return the same number of results, and in the same order!\n  return ids.map((id) => rows.find((row) => row.id === id));\n}\n```\n\n----------------------------------------\n\nTITLE: Querying a Forum Collection with Pagination - GraphQL\nDESCRIPTION: This GraphQL query retrieves a list of forums with pagination, using the 'first' and 'offset' parameters to fetch a single forum starting from the second record. It is intended to demonstrate basic pagination against a forums collection. The query depends on a schema matching the examples repo and assumes use of the pg-simplify-inflector plugin, and the expected output consists of the forum nodeId, id, and name fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/collections.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forums(first: 1, offset: 1) {\n    nodes {\n      nodeId\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scalar and Connection Computed Columns via PostgreSQL Functions - SQL\nDESCRIPTION: Creates example schema tables ('users', 'friendships') and then demonstrates how to define a scalar computed column ('users_name') and a connection/list computed column ('users_friends'). The 'users_name' function concatenates first and last name, while 'users_friends' returns all users who are friends (based on the 'friendships' table). Required dependencies include the existence of both tables in the same schema, valid foreign keys, and compliance with function naming conventions. Inputs are user records and, for connections, use of 'SETOF'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table my_schema.users (\n  id serial not null primary key,\n  first_name varchar not null,\n  last_name varchar not null\n);\n\ncreate table my_schema.friendships (\n  user_id integer not null,\n  target_id integer not null,\n  primary key (user_id, target_id)\n);\n\n-- Creates `User.name` string field\ncreate function my_schema.users_name(u my_schema.users)\nreturns varchar as $$\n  select u.first_name || ' ' || u.last_name;\n$$ language sql stable;\n\n-- Creates `User.friends` connection\ncreate function my_schema.users_friends(u my_schema.users)\nreturns setof my_schema.users as $$\n  select users.*\n  from my_schema.users\n  inner join my_schema.friendships\n  on (friendships.target_id = users.id)\n  where friendships.user_id = u.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Creating a Parameterized Computed Column Function in PostgreSQL\nDESCRIPTION: Defines a PostgreSQL function `my_schema.users_greet` for the `users` table, demonstrating how to add parameters to computed columns. It accepts the required table row (`u`) and an additional `greeting` text parameter. This creates a `greet` computed column field in the GraphQL schema that accepts a `greeting` argument.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/computed-columns.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- Creates `User.greet(greeting: String)` string field\ncreate function my_schema.users_greet(\n  u my_schema.users,  --- required table type parameter, unexposed\n  greeting text       --- additional parameter, will be exposed\n) returns text as $$\n  select greeting || ', ' || u.first_name || ' ' || u.last_name || '!';\n$$ language sql stable strict;\n```\n\n----------------------------------------\n\nTITLE: Mounting Multiple PostGraphile Instances on Different Endpoints using JavaScript\nDESCRIPTION: This JavaScript code iterates over a map of service names and connection strings. For each service, it uses the `postgraphile` function to create middleware configured with a specific connection string, public schema, and distinct `graphqlRoute` and `graphiqlRoute` paths. This middleware is then mounted onto the application (`app`) using `app.use()`, effectively creating separate GraphQL endpoints for each service.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/multiple-schemas.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst services = {\n  notification: \"CONNECTION_STRING_TO_NOTIFICATION_SERVICE\",\n  user: \"CONNECTION_STRING_TO_USER_SERVICE\",\n};\n\nfor (const [service, connectionString] of Object.entries(services)) {\n  app.use(\n    postgraphile(connectionString, \"public\", {\n      graphiql: true,\n      graphqlRoute: `/${service}/graphql`,\n      graphiqlRoute: `/${service}/graphiql`,\n    }),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Standard Synchronous Steps in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet shows how a standard synchronous step is represented in a Grafast plan diagram. It uses a simple rectangular shape and displays the step class name (e.g., '__Value'), its unique ID (5), the bucket it belongs to (0), and step-specific metadata (e.g., 'á¸rootValueá³').\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    __Value5[\"__Value[5âˆˆ0]<br />á¸rootValueá³\"]:::plan\n    class __Value5 bucket0\n\n```\n\n----------------------------------------\n\nTITLE: Efficiently Setting Multiple PostgreSQL Session Variables using SQL\nDESCRIPTION: This SQL snippet presents a more efficient alternative for setting multiple PostgreSQL session configuration parameters within a single statement using the `set_config` function. This approach reduces database roundtrips compared to using multiple `set local` commands.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nselect set_config('role', 'app_user', true), set_config('user_id', '2', true), ...\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Unary Steps Using loadOne in Graphile (TypeScript)\nDESCRIPTION: This code demonstrates passing a 'unary step' (a value present exactly once per request, such as a context-provided database client) as a dependency to loadOne. The snippet shows obtaining author_id from a post, extracting dbClient from the request context, and issuing an optimized fetch. Different argument combinations illustrate Graphile's ability to merge plan dependencies and optimize fetches. Dependencies include context(), plan step construction, and the fetch callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $userId = $post.get(\"author_id\");\nconst $dbClient = context().get(\"dbClient\");\nconst $user = loadOne($userId, $dbClient, \"id\", batchGetUserFromDbById);\n// OR: const $user = loadOne($userId, $dbClient, batchGetUserFromDbById);\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function with Named Arguments\nDESCRIPTION: Defines the `add` function using explicitly named arguments (`a int`, `b int`), which is the recommended practice for functions intended to be exposed via PostGraphile. The arguments can be referenced by their names within the function body. This function is marked `IMMUTABLE` and `STRICT`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  select a + b;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n\n----------------------------------------\n\nTITLE: Enabling Sorting via @sortable Smart Comment in SQL (Deprecated)\nDESCRIPTION: Demonstrates applying the `@sortable` smart comment to SQL functions (`foo` and `users_foo`). This instructs PostGraphile to add ordering capabilities (`orderBy` argument) to the corresponding fields in the GraphQL schema. It applies to SETOF functions (makes the connection sortable) and scalar computed columns (allows sorting the parent table by this column). Note: `@sortable` is deprecated in favor of `@behavior +sort +sortBy`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_30\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@sortable';\ncomment on function users_foo(users) is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Creating a Request Body Manipulation Plugin in TypeScript\nDESCRIPTION: This TypeScript code defines a `QueryByNamePlugin` for PostGraphile. It intercepts incoming GraphQL requests using the `grafserv.middleware.processGraphQLRequestBody` hook. If the request body contains only an `id` (operation name) instead of a full `query`, the plugin looks up the corresponding GraphQL document from a predefined `documents` map and populates the `body.query`. This is primarily for demonstrating the plugin API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { SafeError } from \"grafast\";\n\nconst documents = Object.assign(Object.create(null), {\n  QueryName: `query QueryName { __typename }`,\n  WhoAmI: `query WhoAmI { currentUser { name } }`,\n  CreatePost: `mutation CreatePost($input: CreatePostInput!) { createPost(input: $input) { post { id title } } }`,\n});\n\nexport const QueryByNamePlugin: GraphileConfig.Plugin = {\n  name: \"QueryByNamePlugin\",\n  description: \"Only specify the query name and the query will be populated\",\n  version,\n\n  grafserv: {\n    middleware: {\n      processGraphQLRequestBody(next, event) {\n        const { body } = event;\n        const document = documents[body.id];\n        if (!document) {\n          throw new SafeError(\n            `QueryByNamePlugin couldn't find query '${body.id}'`,\n            { statusCode: 400 },\n          );\n        } else {\n          body.query = document;\n        }\n        return next();\n      },\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Composite Type and Applying @interface mode:union Smart Tags\nDESCRIPTION: Creates a PostgreSQL composite type `polymorphic.applications` to define the structure of the shared fields for an interface. A comment on this type uses `@interface mode:union` and `@name Application` to declare it as the basis for the 'Application' GraphQL interface. Comments on `aws_applications` and `gcp_applications` tables use `@implements Application` to link them to this interface.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n-- Declare a composite type to detail the common fields\ncreate type polymorphic.applications as (\n  id int,\n  name text,\n  last_deployed timestamptz\n);\n\n-- Mark this composite type as an interface named Application\ncomment on type polymorphic.applications is $$\n  @interface mode:union\n  @name Application\n  $$;\n\n-- Have our tables implement this interface\ncomment on table polymorphic.aws_applications is $$\n  @implements Application\n  $$;\ncomment on table polymorphic.gcp_applications is $$\n  @implements Application\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with OmitMutationsByDefaultPlugin via Shell\nDESCRIPTION: This shell command executes PostGraphile using `npx`. It uses the `--append-plugins` option to load both the `@graphile-contrib/pg-simplify-inflector` plugin and the custom `OmitMutationsByDefaultPlugin.js` located in a specific path relative to the current working directory (`pwd`). The command connects to the `graphile_org_demo` database (`-c`) and targets the `app_public` schema (`-s`), applying the mutation omission logic defined in the custom plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx postgraphile --append-plugins @graphile-contrib/pg-simplify-inflector,`pwd`/examples/plugins/0400_customisation/OmitMutationsByDefaultPlugin.js -c graphile_org_demo -s app_public\n```\n\n----------------------------------------\n\nTITLE: Creating Filtered and Flattened Views in PostgreSQL (SQL)\nDESCRIPTION: These snippets showcase the creation of views in PostgreSQL to abstract business logic and join table data, improving the API design for consumption in PostGraphile. The code creates dedicated tables and then defines views to either filter by certain criteria (such as film kind) or flatten joined information (such as person and address). Dependencies include an existing PostgreSQL database and properly defined tables. Key parameters include table and view names, as well as query predicates for filtering. Inputs are DDL statements, outputs are materialized views accessible via SQL and GraphQL. Limitations include PostgreSQL's inability to natively infer complex table relationships on views.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/views.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.films (\n  id serial PRIMARY KEY,\n  name text,\n  release_year int,\n  kind text\n);\n\nCREATE VIEW comedies AS\n    SELECT *\n    FROM app_public.films\n    WHERE kind = 'Comedy';\n```\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.person (\n  id serial PRIMARY KEY\n);\n\nCREATE TABLE app_public.address (\n  person_id int PRIMARY KEY REFERENCES app_public.person,\n  country text,\n  street text,\n);\n\nCREATE VIEW person_view AS\n  SELECT person.id, address.country, address.street\n  FROM app_public.person person\n  INNER JOIN app_public.address\n  ON person.id = address.person_id;\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Middleware in JavaScript\nDESCRIPTION: This snippet demonstrates how to create the PostGraphile middleware instance using the `postgraphile` function. It requires the `postgraphile` library and takes the database connection string (e.g., from `process.env.DATABASE_URL`), the target schema ('public'), and an optional configuration object as arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\n\nconst middleware = postgraphile(process.env.DATABASE_URL, \"public\", {\n  /* ... options here ... */\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Documentation using SQL COMMENT Command\nDESCRIPTION: Example of the standard SQL `COMMENT` command. When applied to database objects like tables, views, columns, or constraints, Graphile can automatically use these comments as the descriptions for the corresponding types, fields, etc., in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT\n```\n\n----------------------------------------\n\nTITLE: Executing a Custom Mutation in GraphQL\nDESCRIPTION: This GraphQL snippet demonstrates how to call the custom mutation generated from the `my_function` PostgreSQL function. PostGraphile follows the Relay Input Object Mutations Specification, wrapping the function arguments within an `input` object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  myFunction(input: { a: 1, b: 2 }) {\n    text\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @primaryKey via JSON5 - Virtual Primary Key\nDESCRIPTION: This JSON5 configuration assigns a virtual 'primaryKey' smart tag to view 'my_view', simulating a primary key (single or composite) for GraphQL purposes. PostGraphile interprets this to expose 'id' as the unique identifier. Dependencies are PostGraphile and usage of smart tags. Inputs are view or class names and column identifiers. This does not create physical constraints in the database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_15\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_view: {\n        tags: {\n          primaryKey: \"id\",\n          // or:\n          //   primaryKey: \"type,identifier\"\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a SQL Table and a Filtering View\nDESCRIPTION: This SQL snippet defines a `films` table within the `app_public` schema and then creates a view named `comedies`. The view selects all columns from the `films` table but filters the results to include only rows where the `kind` column is 'Comedy', demonstrating view usage for data abstraction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/views.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.films (\n  id serial PRIMARY KEY,\n  name text,\n  release_year int,\n  kind text\n);\n\nCREATE VIEW comedies AS\n    SELECT *\n    FROM app_public.films\n    WHERE kind = 'Comedy';\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Soft-Delete Mutation with Node ID and Authorization in TypeScript\nDESCRIPTION: TypeScript code implementing a `deleteItem` mutation that performs a soft-delete based on a GraphQL Node ID. It uses `makeExtendSchemaPlugin`, defines input/payload types, decodes the Node ID using `specFromNodeId`, retrieves JWT claims from the context using `context().get()`, and performs the database update within a transaction using `withPgClientTransaction`, checking for ownership before archiving.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context, list, specFromNodeId, object } from \"postgraphile/grafast\";\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\n\nconst DeleteItemByNodeIdPlugin = makeExtendSchemaPlugin((build) => {\n  // We need the nodeId handler for the Item type so that we can decode the ID.\n  const handler = build.getNodeIdHandler(\"Item\")!;\n\n  // Extract the executor from the items resource\n  const { items } = build.input.pgRegistry.pgResources;\n  const { executor } = items;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n\n  return {\n    typeDefs: gql`\n      input DeleteItemInput {\n        id: ID!\n      }\n      type DeleteItemPayload {\n        success: Boolean\n      }\n      extend type Mutation {\n        deleteItem(input: DeleteItemInput!): DeleteItemPayload\n      }\n    `,\n\n    plans: {\n      Mutation: {\n        deleteItem(_, fieldArgs) {\n          // jwtClaims is decrypted jwt token data\n          const $jwtClaims = context().get(\"jwtClaims\");\n\n          // Read the input.id value from the arguments\n          const $nodeId = fieldArgs.getRaw([\"input\", \"id\"]);\n\n          // Decode the node ID, to something like: `{ id: $someStep }`\n          const spec = specFromNodeId(handler, $nodeId);\n          const $itemId = spec.id;\n\n          const $success = withPgClientTransaction(\n            executor,\n            // Passing a `list` step allows us to pass more than one dependency\n            // through to our callback:\n            list([$jwtClaims, $itemId]),\n            async (pgClient, [jwtClaims, itemId]) => {\n              if (!itemId || !jwtClaims?.user_id) {\n                return false;\n              }\n              const {\n                rows: [row],\n              } = await pgClient.query(\n                ` UPDATE app_public.items\n                  SET is_archived = true\n                  WHERE id = $1\n                  AND user_id = $2\n                  RETURNING *;`,\n                [itemId, jwtClaims.user_id],\n              );\n              return !!row;\n            },\n          );\n\n          // Since we're returning this data in the same shape as the payload\n          // and the payload's fields don't need specific step classes, we don't\n          // need to implement plan resolvers on the payload.\n          return object({ success: $success });\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT Verification Middleware Using express-jwt and jwks-rsa - JavaScript\nDESCRIPTION: Sets up JWT authentication middleware for Express by using express-jwt, which verifies JWTs against public keys fetched dynamically from an Auth0 JWKS endpoint via jwks-rsa. Key parameters: 'secret' is generated via 'jwksRsa.expressJwtSecret' with caching and rate limiting; 'audience' and 'issuer' are enforced to match the expected application and Auth0 tenant; 'algorithms' restrict verification to RS256. Requires prior installation of express-jwt and jwks-rsa packages. The configured middleware can be used to protect GraphQL or REST endpoints, and on success attaches the decoded JWT payload as the 'user' property on the request object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\n// Authentication middleware. When used, the\n// Access Token must exist and be verified against\n// the Auth0 JSON Web Key Set.\n// On successful verification, the payload of the\n// decrypted Access Token is appended to the\n// request (`req`) as a `user` parameter.\nconst checkJwt = jwt({\n  // Dynamically provide a signing key\n  // based on the `kid` in the header and\n  // the signing keys provided by the JWKS endpoint.\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n\n  // Validate the audience and the issuer.\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Querying a Computed Column Using SQL Field Syntax - SQL\nDESCRIPTION: Shows how to query a computed column in PostgreSQL using both the field-selection syntax ('person.person_full_name') and the functional syntax ('person_full_name(person)'). Both approaches retrieve the computed full name for a record with a specific ID, highlighting the interchangeability and convenience of computed columns in SQL contexts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nselect\n  person.id,\n  person.person_full_name as full_name\n  -- or, equivalently:\n  -- person_full_name(person) as full_name\nfrom person\nwhere id = $1;\n```\n\n----------------------------------------\n\nTITLE: Querying a Table for All Rows using Grafast Resource (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use a Grafast resource (users) to create a PgSelectStep representing all rows in the PostgreSQL table. It is typically used within a plan resolver to further filter, map, or return results compatible with PostGraphile-generated GraphQL types. Dependencies are the PostGraphile-generated build object exposing pgResources.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $users = users.find();\n//    ^ PgSelectStep - represents a set of rows\n```\n\n----------------------------------------\n\nTITLE: Customizing Enum Table Name in GraphQL with Smart Comments - SQL\nDESCRIPTION: Applies a smart comment to give a custom name for the enum representation of the 'animal_type' table in the GraphQL schema. Uses '@enum' to mark the table as an enum and '@enumName' to override its GraphQL name. Requires a table named 'animal_type' and runs in a PostgreSQL environment with PostGraphile interpreting smart comments. Inputs are table name and the specific comment string; the result affects the GraphQL type naming.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/enums.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table animal_type is E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Retrieving a GraphQL Type with build.getTypeByName in JavaScript\nDESCRIPTION: Shows how to retrieve a previously registered GraphQL type using the `build.getTypeByName` method. This function takes the type name ('MyType' in this example) as an argument and returns the corresponding GraphQL type object, which might have been registered earlier using methods like `registerObjectType`. This is essential for referencing types during schema construction.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/build-object.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n```js\nconst MyType = build.getTypeByName(\"MyType\");\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Related Connection Field (Reviews) to Product Type in JavaScript\nDESCRIPTION: JavaScript code demonstrating how to add a connection field (`reviews: ReviewConnection`) to an existing type (`Product`) using `makeExtendSchemaPlugin`. The plan resolver fetches related reviews using `pgResources`, filters them by `product_id`, and correctly returns a `connection(...)` step as required for GraphQL connections.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { connection } from \"postgraphile/grafast\";\n\nexport const MyProductReviewsPlugin = makeExtendSchemaPlugin((build) => {\n  const { reviews } = build.input.pgRegistry.pgResources;\n\n  return {\n    typeDefs: gql`\n      extend type Product {\n        reviews: ReviewConnection\n      }\n    `,\n    plans: {\n      Product: {\n        reviews($product) {\n          const $productId = $product.get(\"id\");\n          const $reviews = reviews.find();\n          $reviews.where(sql`${$reviews}.product_id = ${$productId}`);\n\n          // highlight-next-line\n          return connection($reviews);\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column using SQL Smart Comment\nDESCRIPTION: Uses a SQL `COMMENT` statement with the `@deprecated` smart tag to mark the `my_column` column of the `my_schema.my_table` table as deprecated in the GraphQL schema, providing a reason.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\n  E'@deprecated Use myOtherColumn instead.';\n```\n\n----------------------------------------\n\nTITLE: Granting Specific SQL Permissions on a Table to a Role\nDESCRIPTION: Shows how to grant permissions on a PostgreSQL table (`my_table`) to a specific role (`app_visitor`) using the `GRANT` statement. It demonstrates granting `SELECT`, `DELETE`, and column-specific `INSERT` and `UPDATE` permissions. The example emphasizes the recommendation to whitelist specific columns for `INSERT` and `UPDATE` operations rather than granting broad table-level permissions, especially when used with PostGraphile's `--no-ignore-rbac` option.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ngrant\n  select,\n  insert (column_1, column_2),\n  update (column_2, column_3),\n  delete\non my_table to app_visitor;\n```\n\n----------------------------------------\n\nTITLE: Configuring Collection Types on Function via @simpleCollections in SQL (Deprecated)\nDESCRIPTION: Applies the `@simpleCollections both` smart comment to the `search_people` function. This tells PostGraphile to generate both simple list and Relay connection fields if this function returns a set, overriding the global setting. Note: `@simpleCollections` is deprecated in favor of `@behavior`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_29\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function search_people(query text) is\n  E'@simpleCollections both';\n```\n\n----------------------------------------\n\nTITLE: Applying @notNull Smart Tag in SQL - Virtual Constraint\nDESCRIPTION: This snippet uses a PostgreSQL comment to apply the '@notNull' smart tag to a column 'my_view.my_column'. PostGraphile reads this to treat the specified column as non-nullable in GraphQL schema generation, regardless of the actual database column definition. The comment-based approach requires no JSON5 config and works directly within SQL schema migrations. Only affects the GraphQL API layer.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_14\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on column my_view.my_column is E'@notNull`;\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Filtering via @filterable Smart Comment in SQL (Deprecated)\nDESCRIPTION: Shows applying the `@filterable` smart comment to SQL functions (`foo` and `users_foo`). This enables PostGraphile to add filtering capabilities (`condition` argument or field usage within a condition) to the corresponding fields in the GraphQL schema. It applies to SETOF functions (adds a `condition` argument) and scalar computed columns (allows filtering the parent table by this column's value). Note: `@filterable` is deprecated in favor of `@behavior +filter +filterBy`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_32\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@filterable';\ncomment on function users_foo(users) is E'@filterable';\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Test Helpers in TypeScript\nDESCRIPTION: Defines TypeScript helper functions (`test_helpers.ts`) for database testing with Jest and the `pg` library. It includes functions for managing connection pools (`poolFromUrl`), running tests within isolated serializable transactions (`withDbFromUrl`, `withRootDb`), managing user roles (`becomeRoot`, `becomeUser`), and creating test data (`createUsers`). Requires the `pg` library and a `TEST_DATABASE_URL` environment variable. Includes Jest setup (`beforeEach`) and teardown (`afterAll`) logic for resource management and test determinism.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { Pool, PoolClient } from \"pg\";\n\nif (!process.env.TEST_DATABASE_URL) {\n  throw new Error(\"Cannot run tests without a TEST_DATABASE_URL\");\n}\nexport const TEST_DATABASE_URL: string = process.env.TEST_DATABASE_URL;\n\nconst pools = {};\n\n// Make sure we release those pgPools so that our tests exit!\nafterAll(() => {\n  const keys = Object.keys(pools);\n  return Promise.all(\n    keys.map(async (key) => {\n      try {\n        const pool = pools[key];\n        delete pools[key];\n        await pool.end();\n      } catch (e) {\n        console.error(\"Failed to release connection!\");\n        console.error(e);\n      }\n    }),\n  );\n});\n\nconst withDbFromUrl = async <T>(url: string, fn: ClientCallback<T>) => {\n  const pool = poolFromUrl(url);\n  const client = await pool.connect();\n  await client.query(\"BEGIN ISOLATION LEVEL SERIALIZABLE;\");\n\n  try {\n    await fn(client);\n  } catch (e) {\n    // Error logging can be helpful:\n    if (typeof e.code === \"string\" && e.code.match(/^[0-9A-Z]{5}$/)) {\n      console.error([e.message, e.code, e.detail, e.hint, e.where].join(\"\\n\"));\n    }\n    throw e;\n  } finally {\n    await client.query(\"ROLLBACK;\");\n    await client.query(\"RESET ALL;\"); // Shouldn't be necessary, but just in case...\n    await client.release();\n  }\n};\n\nexport const withRootDb = <T>(fn: ClientCallback<T>) =>\n  withDbFromUrl(TEST_DATABASE_URL, fn);\n\nexport const becomeRoot = (client: PoolClient) => client.query(\"reset role\");\n\n/******************************************************************************\n **                                                                          **\n **     BELOW HERE, YOU'LL WANT TO CUSTOMISE FOR YOUR OWN DATABASE SCHEMA    **\n **                                                                          **\n ******************************************************************************/\n\nexport type User = {\n  id: string;\n  username: string;\n  _password?: string;\n  _email?: string;\n};\nexport type Organization = { id: string; name: string };\n\nexport const becomeUser = async (\n  client: PoolClient,\n  userOrUserId: User | string | null,\n) => {\n  await becomeRoot(client);\n  const session = userOrUserId\n    ? await createSession(\n        client,\n        typeof userOrUserId === \"object\" ? userOrUserId.id : userOrUserId,\n      )\n    : null;\n  await client.query(\n    `select set_config('role', $1::text, true),\n            set_config('jwt.claims.session_id', $2::text, true)`,\n    [process.env.DATABASE_VISITOR, session ? session.uuid : \"\"],\n  );\n};\n\n// Enables multiple calls to `createUsers` within the same test to still have\n// deterministic results without conflicts.\nlet userCreationCounter = 0;\nbeforeEach(() => {\n  userCreationCounter = 0;\n});\n\nexport const createUsers = async function createUsers(\n  client: PoolClient,\n  count: number = 1,\n  verified: boolean = true,\n) {\n  const users = [];\n  if (userCreationCounter > 25) {\n    throw new Error(\"Too many users created!\");\n  }\n  for (let i = 0; i < count; i++) {\n    const userLetter = \"abcdefghijklmnopqrstuvwxyz\"[userCreationCounter];\n    userCreationCounter++;\n    const password = userLetter.repeat(12);\n    const email = `${userLetter}${i || \"\"}@b.c`;\n    const user: User = (\n      await client.query(\n        `SELECT * FROM app_private.really_create_user(\n          username := $1,\n          email := $2,\n          email_is_verified := $3,\n          name := $4,\n          avatar_url := $5,\n          password := $6\n        )`,\n        [\n          `testuser_${userLetter}`,\n          email,\n          verified,\n          `User ${userLetter}`,\n          null,\n          password,\n        ],\n      )\n    ).rows[0];\n    expect(user.id).not.toBeNull();\n    user._email = email;\n    user._password = password;\n    users.push(user);\n  }\n  return users;\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming a Table using SQL Smart Comment\nDESCRIPTION: Creates a table named `original_table` and then uses a SQL `COMMENT` statement with the `@name` smart tag to instruct PostGraphile to expose this table as `renamed_table` in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table original_table (\n  col1 int\n);\n\ncomment on table original_table is E'@name renamed_table';\n```\n\n----------------------------------------\n\nTITLE: Adding a Fake Unique Constraint with SQL - PostGraphile - SQL\nDESCRIPTION: Demonstrates how to add a unique constraint to a table using SQL, as a reference for the equivalent smart tag (@unique) in PostGraphile. This code requires a PostgreSQL-compatible database and appropriate table definitions. The statement takes a table and makes a combination of columns unique, returning an error if duplicates are present. Constraints can only be applied where ALTER TABLE is allowed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_32\n\nLANGUAGE: sql\nCODE:\n```\n-- `@unique col1,col2` is roughly equivalent to:\nALTER TABLE foo ADD CONSTRAINT fake_unique UNIQUE (col1, col2);\n```\n\n----------------------------------------\n\nTITLE: Setting Authentication Context for GraphQL Query in PostgreSQL - SQL\nDESCRIPTION: Shows SQL commands to establish role and claim context within a PostgreSQL transaction using 'set local', followed by a note about batching config via 'set_config'. Intended for authenticated session setup before executing GraphQL queries. Requires PostgreSQL, context variables must match JWT claims.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nbegin;\nset local role app_user;\nset local jwt.claims.role to 'app_user';\nset local jwt.claims.user_id to '2';\n\n-- WE PERFORM GRAPHQL QUERIES HERE\n\ncommit;\n```\n\nLANGUAGE: sql\nCODE:\n```\nselect set_config('role', 'app_user', true), set_config('user_id', '2', true), ...\n```\n\n----------------------------------------\n\nTITLE: Defining JWT Verification Middleware with express-jwt and jwks-rsa (JavaScript)\nDESCRIPTION: Defines the `checkJwt` middleware using `express-jwt`. It configures `jwks-rsa` to fetch the public key dynamically from the specified Auth0 JWKS URI (`jwksUri`) based on the token's `kid` header. It also validates the token's audience (`audience`) and issuer (`issuer`) and specifies the expected signing algorithm (`RS256`). Requires `express-jwt` and `jwks-rsa` dependencies. Placeholders `YOUR_DOMAIN` and `YOUR_API_IDENTIFIER` must be replaced with actual Auth0 configuration values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\n// Authentication middleware. When used, the\n// Access Token must exist and be verified against\n// the Auth0 JSON Web Key Set.\n// On successful verification, the payload of the\n// decrypted Access Token is appended to the\n// request (`req`) as a `user` parameter.\nconst checkJwt = jwt({\n  // Dynamically provide a signing key\n  // based on the `kid` in the header and\n  // the signing keys provided by the JWKS endpoint.\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n\n  // Validate the audience and the issuer.\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafast Context for Role and User ID pgSettings (JavaScript)\nDESCRIPTION: Illustrates configuring `grafast.context` in `graphile.config.js` to set default and conditional `pgSettings`. It sets the PostgreSQL `role` to 'visitor' for all requests and attempts to extract the user object from an Express request (`requestContext.expressv4?.req.user`). If a user exists, it adds the user's ID as a `jwt.claims.user_id` setting within `pgSettings`. Note the explicit conversion of `user.id` to a string using `String()`, as `pgSettings` values are best provided as strings.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```js title=\"graphile.config.js\"\nexport default {\n  grafast: {\n    context(requestContext, args) {\n      // Base context used for all GraphQL requests\n      const context = {\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // highlight-next-line\n          role: \"visitor\",\n        },\n      };\n\n      // Extract the current user from the Express request:\n      // highlight-next-line\n      const user = requestContext.expressv4?.req.user;\n\n      // If there's a user, pass additional data to Postgres:\n      if (user) {\n        // highlight-next-line\n        context.pgSettings[\"jwt.claims.user_id\"] = String(user.id);\n      }\n\n      return context;\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Triggering Events and Cancelling Subscriptions in PostgreSQL - SQL\nDESCRIPTION: Demonstrates how to use SQL to insert a new row into app_public.foo, trigger a pg_notify event to PostGraphile subscribers, and subsequently cancel all subscriptions using a notification with a specific topic. Requires PostgreSQL with the pg_notify function and JSON capabilities. Input involves SQL execution, and expected output is a subscription event reception and, after cancellation, no further notifications.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_20\n\nLANGUAGE: SQL\nCODE:\n```\ninsert into app_public.foo (title) values ('Howdy!') returning *;\nselect pg_notify(\n  'postgraphile:hello',\n  json_build_object(\n    '__node__', json_build_array(\n      'foos',\n      (select max(id) from app_public.foo)\n    )\n  )::text\n);\n```\n\nLANGUAGE: SQL\nCODE:\n```\nselect pg_notify(\n  'CANCEL_ALL_SUBSCRIPTIONS',\n  json_build_object()::text\n);\n```\n\n----------------------------------------\n\nTITLE: Using pgSelect placeholder() for Dynamic Query Values in TypeScript\nDESCRIPTION: Illustrates incorporating the value of another step (`$username`, retrieved from field arguments via `fieldArgs.get()`) into an SQL query condition. The `$users.placeholder($username, TYPES.citext)` method creates an SQL fragment (`frag`) that references the value of `$username`. This fragment is then safely embedded in the `WHERE` clause using the `sql` tagged template literal. Requires `usersResource`, `fieldArgs`, `TYPES`, and `sql`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst $users = usersResource.find();\nconst tbl = $users.alias;\n\nconst $username = fieldArgs.get(\"username\");\nconst frag = $users.placeholder($username, TYPES.citext);\n\n$users.where(sql`${tbl}.username = ${frag}`);\n```\n\n----------------------------------------\n\nTITLE: Adding Table Documentation via SQL Comments - SQL\nDESCRIPTION: This snippet demonstrates how to add documentation and smart tags to a PostgreSQL table using the SQL COMMENT ON TABLE statement. The comment contains a smart tag '@name' to rename the table in the generated API and a description explaining the table's purpose. Dependencies include access to the PostgreSQL database and sufficient privileges to add comments. The input is the table name and the comment block, and the result is that both documentation and smart tag annotations become available to PostGraphile for schema generation. This pattern can be customized for other object types, respecting comment and tag format constraints.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TABLE users IS $$\n@name people\nRepresents the people that can log in to our application.\n$$;\n```\n\n----------------------------------------\n\nTITLE: Setting Visitor Role and Mapping JWT Claims to pgSettings (JavaScript)\nDESCRIPTION: This JavaScript snippet configures a PostGraphile context function to set the role as visitor and store a user_id from a JWT claim using the Express req.user object. It starts from the base context, always applies a visitor role, and, if a user exists, adds jwt.claims.user_id to the pgSettings for consumption in PostgreSQL security policies. Designed for integration with an Express.js authentication middleware. It emphasizes string coercion of user IDs and proper session isolation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  grafast: {\n    context(requestContext, args) {\n      // Base context used for all GraphQL requests\n      const context = {\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // highlight-next-line\n          role: \"visitor\",\n        },\n      };\n\n      // Extract the current user from the Express request:\n      // highlight-next-line\n      const user = requestContext.expressv4?.req.user;\n\n      // If there's a user, pass additional data to Postgres:\n      if (user) {\n        // highlight-next-line\n        context.pgSettings[\"jwt.claims.user_id\"] = String(user.id);\n      }\n\n      return context;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Illustrating Hook Application Equivalence in JavaScript\nDESCRIPTION: This JavaScript snippet conceptually demonstrates how `newWithHooks` applies registered hooks. It shows that calling `newWithHooks(GraphQLObjectType, spec)` is functionally equivalent to sequentially applying registered hook functions (`hook1`, `hook2`, `hook3`) to the original specification (`spec`) before passing it to the `GraphQLObjectType` constructor. This highlights the wrapper-like nature of hooks.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/hooks.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst MyType = newWithHooks(GraphQLObjectType, spec);\n\n// is equivalent to:\n\nconst MyType = new GraphQLObjectType(hook3(hook2(hook1(spec))));\n```\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments Using Dollar Quoting - SQL\nDESCRIPTION: This SQL snippet shows how to annotate a database column with a smart comment containing multiple smart tags and arbitrary documentation using PostgreSQL's dollar-quoting for clean multi-line formatting. Dependencies: PostgreSQL, knowledge of COMMENT ON syntax. Input is a COMMENT statement for a table column; output is the storage and subsequent parsing of the comment for PostGraphile schema customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is $$\\n@name meta\\n@isImportant\\n@jsonField date timestamp\\n@jsonField name text\\n@jsonField episode enum ONE=1 TWO=2\\nThis field has a load of arbitrary tags.\\n$$;\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @notNull Constraints via Tag File (JSON5)\nDESCRIPTION: This JSON5 snippet shows how to add a virtual @notNull constraint on a column using a tag file for PostGraphile. The object structure uses the attribute path for targeting the column and sets the 'notNull' tag to true. This is used to make columns non-nullable in the generated GraphQL schema without changing the SQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_26\n\nLANGUAGE: json5\nCODE:\n```\nattribute: {\n  \"my_view.my_column\": {\n    tags: {\n      notNull: true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using loadMany with ioEquivalence for a List Step - TypeScript\nDESCRIPTION: Demonstrates loadMany with a list of input steps and an array ioEquivalence parameter, mapping output fields 'organization_id' and 'user_id' to the input organization and user IDs. Batch fetches posts or memberships by multiple keys. Inputs are arrays of IDs; output is member posts.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $posts = loadMany(\n  list([$organizationId, $userId]),\n  // States that:\n  // - $post.get('organization_id') should return $organizationId directly, and\n  // - $post.get('user_id') should return $userId directly\n  [\"organization_id\", \"user_id\"],\n  batchGetMemberPostsByOrganizationIdAndUserId,\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing 'idIn' Custom Condition with makeAddPgTableConditionPlugin in TypeScript\nDESCRIPTION: Shows how to use `makeAddPgTableConditionPlugin` to create a custom filter condition named `idIn` for the `app_public.forums` table. This condition allows filtering forums based on a provided list of integer IDs using a SQL `ANY` clause. It requires `postgraphile/utils` and `postgraphile/@dataplan/pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-condition-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \"postgraphile/utils\";\nimport { TYPES, listOfCodec } from \"postgraphile/@dataplan/pg\";\n\nexport default makeAddPgTableConditionPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  \"idIn\",\n  (build) => {\n    const { GraphQLList, GraphQLNonNull, GraphQLInt } = build.graphql;\n    return {\n      description: \"Filters to records matching one of these ids\",\n      // This is graphql-js for `[Int!]`; assumes you're using\n      // an integer primary key.\n      type: new GraphQLList(new GraphQLNonNull(GraphQLInt)),\n      applyPlan(\n        $condition /* : PgConditionStep<PgSelectStep<any>> */,\n        value /* : FieldArgs */,\n      ) {\n        const $ids = value.get();\n        $condition.where(\n          sql`${$condition.alias}.id = ANY(${$condition.placeholder(\n            $ids,\n            listOfCodec(TYPES.int),\n          )})`,\n        );\n      },\n    };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a SQL Function Returning SETOF for Connections\nDESCRIPTION: Demonstrates creating a `STABLE` SQL function `my_function` that returns `SETOF person`. This return type allows PostGraphile to expose the function's results as a GraphQL connection, enabling pagination and efficient handling of potentially large result sets.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_17\n\nLANGUAGE: sql\nCODE:\n```\n```sql\n-- Assuming we already have a table named `person`â€¦\nCREATE FUNCTION my_function(a int, b int) RETURNS SETOF person AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Graphile License Environment Variable in Windows Console\nDESCRIPTION: This command shows how to set the `GRAPHILE_LICENSE` environment variable in the Windows Console (cmd.exe). Setting this variable enables premium Graphile plugins. The `set` command defines the variable for the current console session, and the `&` operator allows running the `postgraphile` command immediately afterward in the same line.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_4\n\nLANGUAGE: batch\nCODE:\n```\n```bash\n# Windows Console\nset GRAPHILE_LICENSE=\"license_key_from_graphile_store\" & postgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Search Query Function for Forum Posts in PostgreSQL SQL\nDESCRIPTION: This snippet provides an end-to-end example for building a text search GraphQL query backed by a PostgreSQL function. It first defines a simplified 'post' table, then implements 'search_posts', a function accepting a search term to filter posts based on 'headline' and 'body' content using the case-insensitive ILIKE operator. Marked STABLE to qualify as a query, it returns SETOF post, exposing results as a connection or list in GraphQL. This function relies solely on standard PostgreSQL features and requires a 'post' table with appropriate columns. Performance may be limited on large tables due to wildcard searches.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-queries.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\n-- Columns unnecessary to this demo were omitted. You can find the full table in\n-- our forum example.\ncreate table post (\n  â€¦\n  headline         text not null,\n  body             text,\n  â€¦\n);\n\n-- Create the function named `search_posts` with a text argument named `search`.\n-- This will expose `Query.searchPosts(search: String!, ...)` to GraphQL.\ncreate function search_posts(search text)\n  -- This function will return a set of posts from the `post` table. The\n  -- `setof` part is important to PostGraphile, check out our Functions article\n  -- to learn why.\n  returns setof post as $$\n    -- Write our advanced query as a SQL query!\n    select *\n    from post\n    where\n      -- Use the `ILIKE` operator on both the `headline` and `body` columns. If\n      -- either return true, return the post.\n      headline ilike ('%' || search || '%') or\n      body ilike ('%' || search || '%')\n  -- End the function declaring the language we used as SQL and add the\n  -- `STABLE` marker so PostGraphile knows its a query and not a mutation.\n  $$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Extending `Product` type with custom field resolver in JavaScript\nDESCRIPTION: Demonstrates creating a PostGraphile plugin using `makeExtendSchemaPlugin` to add a `priceInAuCents` field to the `Product` type. The resolver plan accesses the `price_in_us_cents` column value from the current record using `$product.get()`. It then uses the `loadOne` Grafast step to batch-process currency conversion via a custom asynchronous function `convertUsdToAud`, which might involve external API calls.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { loadOne } from \"postgraphile/grafast\";\nimport { getExchangeRate } from \"./myBusinessLogic.mjs\";\n\n// highlight-start\nasync function convertUsdToAud(values) {\n  const usdToAud = await getExchangeRate(\"USD\", \"AUD\");\n  return values.map((usd) => usd * usdToAud);\n}\n// highlight-end\n\nexport const MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n  return {\n    typeDefs: gql`\n      extend type Product {\n        priceInAuCents: Int!\n      }\n    `,\n    plans: {\n      Product: {\n        priceInAuCents($product) {\n          // highlight-next-line\n          const $cents = $product.get(\"price_in_us_cents\");\n          // highlight-next-line\n          return loadOne($cents, convertUsdToAud);\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Table and Column Privileges for GraphQL Roles - SQL\nDESCRIPTION: This section presents examples of properly granting SELECT, INSERT, UPDATE, and DELETE privileges on tables and specific columns to a role ('graphql_role'), as well as examples of patterns to avoid. Properly scoping privileges helps prevent access issues in GraphQL and maintains database integrity. Requires a PostgreSQL user with sufficient privileges and the presence of the 'users' table and desired columns. Intended to be used as SQL commands executed on a PostgreSQL server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/best-practices.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- âœ… Fine\ngrant select on users to graphql_role;\n-- âœ… Fine\ngrant insert (column_1, column_2, ...) on users to graphql_role;\n-- âœ… Fine\ngrant update (column_a, column_b, ...) on users to graphql_role;\n-- âœ… Fine\ngrant delete on users to graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- ðŸ›‘ DO NOT USE\ngrant select (column_a, column_b) on users to graphql_role;\n-- ðŸ›‘ DO NOT USE\ngrant insert on users to graphql_role;\n-- ðŸ›‘ DO NOT USE\ngrant update on users to graphql_role;\n```\n\n----------------------------------------\n\nTITLE: Discouraged GRANT Statement Patterns in PostgreSQL\nDESCRIPTION: Illustrates SQL `GRANT` patterns that should be avoided with PostGraphile. Column-level `SELECT` grants are particularly problematic as they interfere with `SELECT *`, `RETURNING *`, and passing row types to functions (used for computed columns). Table-level `INSERT`/`UPDATE` grants are also discouraged because they lack the recommended explicitness about which columns can be modified.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/best-practices.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- ðŸ›‘ DO NOT USE\nGRANT SELECT (column_a, column_b) ON users TO graphql_role;\n-- ðŸ›‘ DO NOT USE\nGRANT INSERT ON users TO graphql_role;\n-- ðŸ›‘ DO NOT USE\nGRANT UPDATE ON users TO graphql_role;\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Chat Message Events in PostGraphile with GraphQL (JavaScript)\nDESCRIPTION: Demonstrates how to use a GraphQL subscription operation to receive real-time updates whenever a new chat message is added to a specific channel. This snippet is intended for use in client-side applications interfacing with PostGraphile subscriptions. The key parameter \\`channel: 27\\` filters the subscription to only the specified channel, and the client receives the message's id, content, author info, and timestamp upon relevant events. Requires a GraphQL subscription-capable backend (such as PostGraphile core) and compatible client libraries (e.g., Apollo Client). Input is the subscription definition; output is a stream of chat messages added to the channel.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/realtime.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nsubscription {\n  chatMessageAdded(channel: 27) {\n    id\n    message\n    author { id name avatarUrl }\n    timestamp\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Graphile V5 with CLI Preset and Database Connection - Bash\nDESCRIPTION: This snippet demonstrates how to run the Graphile V5 API using the postgraphile (or pgl) CLI command with explicit flags for the preset, connection string, schema, and the explain mode. It assumes you have Graphile/PostGraphile CLI installed, and your PostgreSQL server is accessible at the provided URI. The flags specify which Graphile preset to use (such as \"amber\"), the PostgreSQL database to connect to, target schemas, and whether explain output is enabled. Inputs include connection parameters and chosen preset; outputs are a running Graphile API server listening on default or provided network settings. Ensure your PostgreSQL instance and network permissions allow connection from the host where this command is executed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -P postgraphile/presets/amber -c postgres:///my_db_name -s public -e\n# or: pgl -P pgl/amber -c postgres:///my_db_name -s public -e\n```\n\n----------------------------------------\n\nTITLE: Setting Derived Column Values in Mutations using makeWrapPlansPlugin (JavaScript)\nDESCRIPTION: Demonstrates using `makeWrapPlansPlugin` to intercept a `createPost` mutation plan in PostGraphile V5. It retrieves the underlying `PgInsertSingleStep` from the plan result, calculates a derived `name` value using a `lambda` step from `$firstName` and `$lastName` arguments, and sets this derived value on the insert step before returning the original plan result. This replaces the V4 workaround of overriding arguments and doesn't require the derived field in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nmakeWrapPlansPlugin({\n  Mutation: {\n    // This same pattern works for 'update' mutations too\n    createPost(plan, $source, { $firstName, $lastName }) {\n      // Call the original plan\n      const $planResult = plan();\n\n      // Get a reference to the `PgInsertSingleStep`.\n      // Remember: it's a step, it has not executed yet, so we can still\n      // augment what it will do.\n      const $insert = $planResult.get(\"result\");\n\n      // We have a legacy 'name' field that needs populating; build it from\n      // each tuple of firstName/lastName fields:\n      const $name = lambda(\n        [$firstName, $lastName],\n        ([firstName, lastName]) => `${firstName} ${lastName}`,\n        // Our callback is synchronous and won't throw\n        true,\n      );\n\n      // Now set this as the value of 'name' in the PgInsertSingleStep:\n      $insert.set(\"name\", $name);\n\n      // Our result is the same as before (otherwise dependent plans may fail)\n      return $planResult;\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering in GraphQL using Array Wrapper and Connection Filter\nDESCRIPTION: Shows a GraphQL query example using the `filter` argument (typically provided by plugins like `postgraphile-plugin-connection-filter`) to filter `allUsers`. The filter targets the `object_fields` array (generated by the `user_object_fields` SQL wrapper function) and uses the `contains` operator to find users who own an object where the `field` value is 'foo'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_36\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # get all users who own an object with field == 'foo'\n  allUsers(filter: { object_fields: { contains: \"foo\" } }) {\n    nodes {\n      id\n      # ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracted Description Text After Double Newline Separator - Plaintext\nDESCRIPTION: This snippet presents the documentation string area extracted from a smart comment placed after the double-newline separator. It demonstrates that any content following the empty line, even lines starting with '@', are considered part of the description and not as smart tags. Input: a COMMENT with both tag and non-tag sections; output: extracted documentation text.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nThis field has a load of arbitrary tags.\\n@jsonField episode enum ONE=1 TWO=2\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Stable SQL Function for Addition (SQL)\nDESCRIPTION: Creates a basic PostgreSQL function named `add` that accepts two integer arguments (`a` and `b`) and returns their sum as an integer. The function is written in SQL and marked as `stable`, indicating it does not modify the database and returns the same result for the same arguments within a transaction. This serves as a basic example of function definition syntax.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\n select a + b\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Defining User Registration Function in PostgreSQL (PL/pgSQL)\nDESCRIPTION: This PL/pgSQL function registers a new user by inserting their profile into `forum_example.person` and their account details (email and hashed password) into `forum_example_private.person_account`. It utilizes the `pgcrypto` extension for password hashing (`crypt`, `gen_salt`) and returns the created person record. The function is declared `strict` (null input yields null output) and `security definer` (runs with creator's privileges), granting it elevated permissions but requiring caution against security vulnerabilities.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_21\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.register_person(\n  first_name text,\n  last_name text,\n  email text,\n  password text\n) returns forum_example.person as $$\ndeclare\n  person forum_example.person;\nbegin\n  insert into forum_example.person (first_name, last_name) values\n    (first_name, last_name)\n    returning * into person;\n\n  insert into forum_example_private.person_account (person_id, email, password_hash) values\n    (person.id, email, crypt(password, gen_salt('bf')));\n\n  return person;\nend;\n$$ language plpgsql strict security definer;\n\ncomment on function forum_example.register_person(text, text, text, text) is 'Registers a single user and creates an account in our forum.';\n```\n\n----------------------------------------\n\nTITLE: Stitching Schema with makeGrafastSchema - TypeScript\nDESCRIPTION: Combines the previously defined typeDefs and plans into a complete GraphQL schema using grafast's makeGrafastSchema helper. Requires grafast as a dependency and expects typeDefs and plans objects to be populated. Inputs are the schema definition and plan resolvers; output is a constructed executable schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { makeGrafastSchema } = require(\"grafast\");\n\nconst schema = makeGrafastSchema({\n  typeDefs,\n  plans,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Replacing GraphQL Import with Grafast in JavaScript\nDESCRIPTION: Demonstrates how to substitute the default GraphQL.js 'graphql' import with the optimized Grafast alternative. This involves replacing the original 'graphql' import statement with a Grafast import and aliasing it as 'graphql' for seamless integration. There are no required dependencies beyond having 'grafast' installed; the key parameter is the module name in the import statement, ensuring the rest of the codebase continues to work without modification. The code expects an ECMAScript module environment, and the change is limited to the import statement.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/README.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-import { graphql } from \"graphql\";\n+import { grafast as graphql } from \"grafast\";\n```\n\n----------------------------------------\n\nTITLE: Integrating PostGraphile Middleware with Express (JavaScript)\nDESCRIPTION: Demonstrates the basic setup of an Express.js application using the `postgraphile` library as middleware. It initializes Express, configures the PostgreSQL connection details (`pgConfig`) using environment variables (sourced from `app.yaml` in GCP), sets PostGraphile options, integrates the middleware via `app.use()`, and starts the Express server listening on port 8080 (standard for GCP App Engine). This setup requires `express` and `postgraphile` node modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\n// node-postgres Pool config (https://node-postgres.com/api/pool,\n// https://node-postgres.com/api/client)\nconst pgConfig = {\n  host: process.env.PGHOST || \"localhost\",\n  port: process.env.PGPORT || 5432,\n  user: process.env.PGUSER,\n  database: process.env.PGDATABASE,\n  password: process.env.PGPASSWORD,\n};\n\n// Your PostGraphile config:\n// https://www.graphile.org/postgraphile/usage-library/#api-postgraphilepgconfig-schemaname-options\nconst postgraphileOptions = {\n  /* ... */\n};\napp.use(postgraphile(pgConfig, \"public\", postgraphileOptions));\n\napp.listen(8080);\n```\n\n----------------------------------------\n\nTITLE: Illustrating Naming Conflict in PL/pgSQL Upsert Functions\nDESCRIPTION: Defines an `upsert_value` function using `plpgsql` to insert or update a row in `my_table`. This snippet highlights a potential error scenario where `on conflict (id)` is ambiguous, as PL/pgSQL cannot determine if `id` refers to the table column or the function argument in this context. The function is marked `volatile` because it modifies data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate function upsert_value(id int, value text) returns void as $$\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    on conflict (id) -- This will error\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n\n----------------------------------------\n\nTITLE: Defining Tables, Junction, and Function with nodeId Variants (SQL)\nDESCRIPTION: This SQL snippet defines two entity tables, a junction table, and a function to insert into the junction using references between entities. It demonstrates use of the PostGraphile smart tag comments to bind GraphQL global object identifier variants (`@arg0variant nodeId`, `@arg1variant nodeId`) to function arguments. Prerequisites include a PostgreSQL database with PostGraphile smart comments feature. The function returns the inserted row from the `junction` table and expects `entity_a` and `entity_b` row values as input.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/node-id.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table entity_a(\n  id uuid primary key\n);\n\ncreate table entity_b(\n  id uuid primary key\n);\n\ncreate table junction(\n  a_id uuid REFERENCES entity_a(id),\n  b_id uuid REFERENCES entity_b(id),\n  primary key (a_id, b_id)\n);\n\ncreate function add_junction_entry(a entity_a, b entity_b) returns junction as $$\n  insert into junction values (a.id, b.id) returning *;\n$$ language sql volatile;\n\ncomment on function add_junction_entry(a entity_a, b entity_b) is $$\n  @arg0variant nodeId\n  @arg1variant nodeId\n$$;\n```\n\n----------------------------------------\n\nTITLE: Adding PostGraphile Service to Docker Compose\nDESCRIPTION: Updates the `docker-compose.yml` file to include the `graphql` service definition. This configures the container name, restart policy, image source (building from the `./graphql` context), environment file (`.env`), dependency on the `db` service, network connection, port mapping (host 5433 to container 5433), and the command to run PostGraphile with connection details, port, schema, and appended plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db: [...]\n\n    graphql:\n        container_name: forum-example-graphql\n        restart: always\n        image: forum-example-graphql\n        build:\n            context: ./graphql\n        env_file:\n            - ./.env\n        depends_on:\n            - db\n        networks:\n            - network\n        ports:\n            - 5433:5433\n        command: [\"--connection\", \"${DATABASE_URL}\", \"--port\", \"5433\", \"--schema\", \"public\", \"--append-plugins\", \"postgraphile-plugin-connection-filter\"]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Test Helpers for PostgreSQL in TypeScript\nDESCRIPTION: This TypeScript module provides reusable helpers to manage and isolate database context during Jest tests, including pooled Postgres connection management, transaction handling, and utilities for simulating different user roles and creating test users. It requires the pg Node.js module and environment variables for configuration. The major features include transaction scoping, clean connection release, and test utilities tailored for customizable user and organization schemas. Inputs involve callback functions and user objects/identifiers; outputs are isolated database operations and created test users. The module assumes PostgreSQL with certain expected database schema functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Pool, PoolClient } from \"pg\";\\n\\nif (!process.env.TEST_DATABASE_URL) {\\n  throw new Error(\"Cannot run tests without a TEST_DATABASE_URL\");\\n}\\nexport const TEST_DATABASE_URL: string = process.env.TEST_DATABASE_URL;\\n\\nconst pools = {};\\n\\n// Make sure we release those pgPools so that our tests exit!\\nafterAll(() => {\\n  const keys = Object.keys(pools);\\n  return Promise.all(\\n    keys.map(async (key) => {\\n      try {\\n        const pool = pools[key];\\n        delete pools[key];\\n        await pool.end();\\n      } catch (e) {\\n        console.error(\"Failed to release connection!\");\\n        console.error(e);\\n      }\\n    }),\\n  );\\n});\\n\\nconst withDbFromUrl = async <T>(url: string, fn: ClientCallback<T>) => {\\n  const pool = poolFromUrl(url);\\n  const client = await pool.connect();\\n  await client.query(\"BEGIN ISOLATION LEVEL SERIALIZABLE;\");\\n\\n  try {\\n    await fn(client);\\n  } catch (e) {\\n    // Error logging can be helpful:\\n    if (typeof e.code === \"string\" && e.code.match(/^[0-9A-Z]{5}$/)) {\\n      console.error([e.message, e.code, e.detail, e.hint, e.where].join(\"\\n\"));\\n    }\\n    throw e;\\n  } finally {\\n    await client.query(\"ROLLBACK;\");\\n    await client.query(\"RESET ALL;\"); // Shouldn't be necessary, but just in case...\\n    await client.release();\\n  }\\n};\\n\\nexport const withRootDb = <T>(fn: ClientCallback<T>) =>\\n  withDbFromUrl(TEST_DATABASE_URL, fn);\\n\\nexport const becomeRoot = (client: PoolClient) => client.query(\"reset role\");\\n\\n/******************************************************************************\\n **                                                                          **\\n **     BELOW HERE, YOU'LL WANT TO CUSTOMISE FOR YOUR OWN DATABASE SCHEMA    **\\n **                                                                          **\\n ******************************************************************************/\\n\\nexport type User = {\\n  id: string;\\n  username: string;\\n  _password?: string;\\n  _email?: string;\\n};\\nexport type Organization = { id: string; name: string };\\n\\nexport const becomeUser = async (\\n  client: PoolClient,\\n  userOrUserId: User | string | null,\\n) => {\\n  await becomeRoot(client);\\n  const session = userOrUserId\\n    ? await createSession(\\n        client,\\n        typeof userOrUserId === \"object\" ? userOrUserId.id : userOrUserId,\\n      )\\n    : null;\\n  await client.query(\\n    `select set_config('role', $1::text, true),\\n            set_config('jwt.claims.session_id', $2::text, true)`,\\n    [process.env.DATABASE_VISITOR, session ? session.uuid : \"\"],\\n  );\\n};\\n\\n// Enables multiple calls to `createUsers` within the same test to still have\\n// deterministic results without conflicts.\\nlet userCreationCounter = 0;\\nbeforeEach(() => {\\n  userCreationCounter = 0;\\n});\\n\\nexport const createUsers = async function createUsers(\\n  client: PoolClient,\\n  count: number = 1,\\n  verified: boolean = true,\\n) {\\n  const users = [];\\n  if (userCreationCounter > 25) {\\n    throw new Error(\"Too many users created!\");\\n  }\\n  for (let i = 0; i < count; i++) {\\n    const userLetter = \"abcdefghijklmnopqrstuvwxyz\"[userCreationCounter];\\n    userCreationCounter++;\\n    const password = userLetter.repeat(12);\\n    const email = `${userLetter}${i || \"\"}@b.c`;\\n    const user: User = (\\n      await client.query(\\n        `SELECT * FROM app_private.really_create_user(\\n          username := $1,\\n          email := $2,\\n          email_is_verified := $3,\\n          name := $4,\\n          avatar_url := $5,\\n          password := $6\\n        )`,\\n        [\\n          `testuser_${userLetter}`,\\n          email,\\n          verified,\\n          `User ${userLetter}`,\\n          null,\\n          password,\\n        ],\\n      )\\n    ).rows[0];\\n    expect(user.id).not.toBeNull();\\n    user._email = email;\\n    user._password = password;\\n    users.push(user);\\n  }\\n  return users;\\n};\n```\n\n----------------------------------------\n\nTITLE: Specifying the Mutation Operation Type in GraphQL Requests\nDESCRIPTION: Illustrates the necessity of using the `mutation` keyword at the beginning of a GraphQL request when executing mutation operations like `createThing`. Omitting this keyword causes GraphQL to interpret the request as a `query`, which will fail if the root field (`createThing` in this example) is defined under the Mutation type, not the Query type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/crud-mutations.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createThing...\n}\n```\n\n----------------------------------------\n\nTITLE: Appending the pg-simplify-inflector Plugin via PostGraphile CLI (Shell)\nDESCRIPTION: This shell command demonstrates how to run PostGraphile with the `@graphile-contrib/pg-simplify-inflector` plugin appended. This plugin modifies the default inflection rules to generate shorter, potentially more intuitive names for relations in the GraphQL schema, such as changing `userByAuthorId` to `author`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/inflection.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npostgraphile --append-plugins @graphile-contrib/pg-simplify-inflector\n```\n\n----------------------------------------\n\nTITLE: Configuring 'pgStrictFunctions' in PostGraphile (graphile.config.mjs)\nDESCRIPTION: Demonstrates setting the `pgStrictFunctions` option to `true` within the `gather` settings in a PostGraphile configuration file (`graphile.config.mjs`). This configuration makes all function arguments mandatory (non-null) in the generated GraphQL schema unless they have a default value, effectively treating functions as if they were marked `STRICT` but allowing optional arguments if defaults are provided.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-mutations.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  // ...\n  gather: {\n    pgStrictFunctions: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming Entities using JSON5 Smart Tags File\nDESCRIPTION: Configures PostGraphile via `postgraphile.tags.json5` to rename the `post` class (table/view) to `message` and the `search_posts` procedure (function) to `returnPostsMatching` in the GraphQL schema using the `@name` smart tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      post: {\n        tags: {\n          name: \"message\",\n        },\n      },\n    },\n    procedure: {\n      search_posts: {\n        tags: {\n          name: \"returnPostsMatching\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Extend Schema Plugin with makeExtendSchemaPlugin - JavaScript\nDESCRIPTION: This code snippet demonstrates how to define a Graphile plugin using the makeExtendSchemaPlugin function from the graphile-utils library in JavaScript. It shows how to use helpers from the build object and return typeDefs and resolvers for schema extension. Dependencies include graphile-utils and an understanding of the Graphile build system. The MyPlugin module, when exported, can be added to a PostGraphile instance via CLI or as a library plugin. The typeDefs and resolvers define new or extended GraphQL schema types and logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\n\nconst MyPlugin = makeExtendSchemaPlugin((build) => {\n  // Get any helpers we need from `build`\n  const { pgSql: sql, inflection } = build;\n\n  return {\n    typeDefs: gql`...`,\n    resolvers: {\n      /*...*/\n    },\n  };\n});\n\nmodule.exports = MyPlugin;\n```\n\n----------------------------------------\n\nTITLE: Querying Track Data with PostGraphile - GraphQL\nDESCRIPTION: This GraphQL query retrieves the first 20 tracks using the allTracksList root field, fetching their trackId and name attributes. It is used as a simple benchmark scenario for measuring how many basic queries PostGraphile can handle per second. Inputs include an optional 'first' parameter to limit results; the expected output is an object with an array of tracks, each containing 'trackId' and 'name'. Dependencies: a GraphQL API generated by PostGraphile over a PostgreSQL database containing track data. Limitations include simplicityâ€”no nested or related data is fetched.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/performance.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery tracks_media_first_20 {\n  allTracksList(first: 20) {\n    trackId\n    name\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Fields in a GraphQL Schema - GraphQL - graphql\nDESCRIPTION: This GraphQL query demonstrates requesting data from the Numbers and Letters fields, each with multiple child fields. It showcases how errors in one field (e.g. numbers.three) can affect the overall response depending on nullability. Used for explanatory and test purposes. Input: no variables; Output: queried objects. No dependencies; limitation: target schema must match the types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/why-nullable.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n\"{\\n  numbers {\\n    one\\n    two\\n    three\\n  }\\n  letters {\\n    a\\n    b\\n    c\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring pgStrictFunctions for Required Arguments (JavaScript)\nDESCRIPTION: Sets the 'pgStrictFunctions' configuration to true in the graphile.config.mjs file, instructing PostGraphile to treat all PostgreSQL function arguments as required unless a default is specified. This setting modifies GraphQL mutation argument generation for functions, making non-default arguments mandatory and defaulted arguments optional. The example is implemented in ECMAScript module syntax and depends on PostGraphile's configuration schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-mutations.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  // ...\n  gather: {\n    pgStrictFunctions: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Granting a Role to Another Role in PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates how to grant an existing PostgreSQL role (e.g., 'editor') to another role (e.g., 'admin'), providing the target role with the permissions of the granted role. Requires a connected PostgreSQL instance and sufficient privileges. Inputs are role names, and output is permission assignment at the database level. The command also enables the granted role to assume the permissions or switch to the granted role within a session.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/default-role.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ngrant editor to admin;\n```\n\n----------------------------------------\n\nTITLE: Overriding Table Name with Smart Tag in PostgreSQL (SQL)\nDESCRIPTION: This snippet demonstrates the use of a PostgreSQL COMMENT statement to add a smart tag for renaming a table in PostGraphile's generated GraphQL schema. The smart tag '@name message' overrides the default name mapping for the 'post' table, making it appear as 'message' in the GraphQL API. No additional dependencies are required except for access to a PostgreSQL database; key parameters are the table to be renamed and the smart tag provided.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/inflection.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TABLE post IS E'@name message';\n```\n\n----------------------------------------\n\nTITLE: Enabling Row Level Security in Postgres Tables using SQL\nDESCRIPTION: This SQL snippet enables row level security on the forum_example.person and forum_example.post tables, allowing further refinement of access via RLS policies. This must be run after table creation but before policy definitions, and requires Postgres 9.5 or newer. No additional parameters are needed, but only roles explicitly permitted under subsequent policies will gain access, effectively revoking table-wide access by default.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_38\n\nLANGUAGE: sql\nCODE:\n```\nalter table forum_example.person enable row level security;\\nalter table forum_example.post enable row level security;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Users Table - SQL\nDESCRIPTION: This SQL snippet defines a typical 'users' table in the 'app_public' schema in PostgreSQL, which serves as the source for GraphQL type generation in PostGraphile. It demonstrates standard practices such as using unique constraints, foreign keys (with cascading deletes), required fields, and default values for timestamp and boolean fields. Dependencies include PostgreSQL server (with citext extension if 'citext' column type is used), and other referenced tables such as 'app_public.organizations'. The table expects standard user data as input and outputs rows with the defined constraints; errors may occur if required fields are missing or constraints are violated.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/tables.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.users (\n  id serial primary key,\n  username citext not null unique,\n  name text not null,\n  about text,\n  organization_id int not null\n    references app_public.organizations on delete cascade,\n  is_admin boolean not null default false,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Calling a Replaced Inflector in Graphile Build (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how code would typically call an inflector, like the `builtin` inflector modified in the previous example. It highlights that the arguments automatically supplied by the Graphile Build system (the previous inflector function and the preset) are not passed explicitly when calling the inflector; only the intended arguments (like `text`) are provided.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst text = inflection.builtin(\"Query\");\n```\n\n----------------------------------------\n\nTITLE: Loading Smart Tags from a Custom File Path in PostGraphile (JavaScript)\nDESCRIPTION: This JavaScript example illustrates configuring PostGraphile to load smart tags from a user-specified file, rather than the default postgraphile.tags.json5. By using makePgSmartTagsFromFilePlugin and providing the path to your config file (which can be .json5, .json, or .jsonc), you can flexibly choose the storage location and parser compatibility. This approach is especially useful when extending or integrating with different project setups. The dependency is postgraphile/utils; you must supply a valid file path as the argument to makePgSmartTagsFromFilePlugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags-file.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makePgSmartTagsFromFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [\n    makePgSmartTagsFromFilePlugin(\n      // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\n      \"/path/to/my/tags.file.json\",\n    ),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Queuing a Graphile Worker Job using SQL\nDESCRIPTION: Demonstrates how to add a job to the Graphile Worker queue directly from PostgreSQL using the `graphile_worker.add_job` function. It queues a task named 'hello' with a JSON payload containing a 'name' property set to 'Bobby Tables'. This approach allows database triggers or functions to initiate background tasks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/background-tasks.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT graphile_worker.add_job('hello', json_build_object('name', 'Bobby Tables'));\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Statement Timeout via pgSettings - PostGraphile Node.js (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to set a statement timeout for PostgreSQL queries on each request using the grafast context method of the PostGraphile library. It is used in a PostGraphile configuration file (e.g., graphile.config.mjs) and requires the PostGraphile library (with grafast integration) and Node.js environment. The key parameter is statement_timeout, which is set in milliseconds for every GraphQL request, helping to limit database resource usage during expensive queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/production.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default {\n  // ...\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-next-line\n        statement_timeout: \"3000\",\n        // ...\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Forum by Slug JSON Response Example - JSON\nDESCRIPTION: This JSON represents the typical response for the forumBySlug GraphQL query, showing the forum identified by the given slug. The object contains the nodeId, id, slug, name, and description corresponding to the forum 'testimonials'. No extra dependencies are needed; the structure follows the PostGraphile GraphQL response specification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/basic.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forumBySlug\": {\n    \"nodeId\": \"WyJmb3J1bXMiLDFd\",\n    \"id\": 1,\n    \"slug\": \"testimonials\",\n    \"name\": \"Testimonials\",\n    \"description\": \"How do you rate PostGraphile?\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @notNull Smart Tag in JSON5 - Virtual Constraint\nDESCRIPTION: This code snippet shows how to use a JSON5 configuration file to add a 'notNull' virtual constraint to a column 'my_view.my_column' using PostGraphile tags. The 'notNull' smart tag enforces that the field is treated as non-nullable at the GraphQL API layer. Requires PostGraphile's smart tags feature. No direct effect on the database schema; affects generated GraphQL types for input validation and schema accuracy.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_13\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      \"my_view.my_column\": {\n        tags: {\n          notNull: true,\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for makeAddPgTableOrderByPlugin Function\nDESCRIPTION: This TypeScript code defines the function signature for `makeAddPgTableOrderByPlugin`. It specifies the required arguments: `schemaName`, `tableName`, and `ordersGenerator` (a function returning order specifications), along with an optional `hint`. It also defines the structure for `MakeAddPgTableOrderByPluginOrders` (an object mapping enum value names to their configuration) and `OrderSpec` (a tuple defining the SQL fragment/column, direction, and nulls ordering).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makeAddPgTableOrderByPlugin(\n  schemaName: string,\n  tableName: string,\n  ordersGenerator: (build: Build) => MakeAddPgTableOrderByPluginOrders,\n  hint = `Adding orders with makeAddPgTableOrderByPlugin to \"${schemaName}\".\"${tableName}\"`,\n): Plugin;\n\ninterface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    value: {\n      alias?: string;\n      specs: Array<OrderSpec>;\n      unique: boolean;\n    };\n  };\n}\n\ntype OrderSpec = [string | SQL, boolean] | [string | SQL, boolean, boolean];\n```\n```\n\n----------------------------------------\n\nTITLE: Incrementally Setting Attributes with pgInsertSingle.set() in TypeScript\nDESCRIPTION: Shows how to use the `.set()` method on the result of `pgInsertSingle` (an insertion plan) to add attributes (`username`, `bio`) to be inserted. This allows building the insertion statement piece by piece before execution. The comment indicates this approach corresponds roughly to a specific SQL `INSERT` statement.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgInsertSingle.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $insertedUser = pgInsertSingle(usersResource);\n$insertedUser.set(\"username\", $username);\n$insertedUser.set(\"bio\", $bio);\n\n// Roughly equivalent to:\n// `INSERT INTO users (username, bio) VALUES ($1, $2);`\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Post Summary Function (SQL)\nDESCRIPTION: This SQL snippet defines a function `forum_example.post_summary` that generates a truncated summary of a post's body. It takes a `forum_example.post` row, an optional maximum length (default 50), and an optional omission string (default 'â€¦') as input. It returns the truncated body text or null if the body is null, is marked `stable`, and includes a comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.post_summary(\n  post forum_example.post,\n  length int default 50,\n  omission text default 'â€¦'\n) returns text as $$\n  select case\n    when post.body is null then null\n    else substr(post.body, 0, length) || omission\n  end\n$$ language sql stable;\n\ncomment on function forum_example.post_summary(forum_example.post, int, text) is 'A truncated version of the body for summaries.';\n```\n\n----------------------------------------\n\nTITLE: Installing @graphile/subscriptions-lds Node.js Package\nDESCRIPTION: Shows the command using `yarn` to add the `@graphile/subscriptions-lds` package as a project dependency. This package provides the realtime provider plugin for PostGraphile live queries based on logical decoding.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @graphile/subscriptions-lds\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Constraints - SQL\nDESCRIPTION: This SQL COMMENT attaches smart tags to a constraint, allowing you to set foreign field and field names on a constraint used by PostGraphile. The format employs escape string constants. Input: COMMENT ON CONSTRAINT; output: constraint meta reflected in PostGraphile's auto-generated schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint my_constraint on my_schema.my_table is\\n  E'@foreignFieldName foos\\\\n@fieldName bar\\\\nDocumentation here.';\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Field Function for Person's Full Name (SQL)\nDESCRIPTION: Defines a PostgreSQL function `person_full_name` in the `forum_example` schema. It accepts a `forum_example.person` row as input and returns the person's full name by concatenating the `first_name` and `last_name` columns. Marked as `stable`, PostGraphile interprets this as a computed field on the `Person` GraphQL type. A comment is added for documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_full_name(person forum_example.person) returns text as $$\n  select person.first_name || ' ' || person.last_name\n$$ language sql stable;\n\ncomment on function forum_example.person_full_name(forum_example.person) is 'A personâ€™s full name which is a concatenation of their first and last name.';\n```\n\n----------------------------------------\n\nTITLE: Creating a Schema in PostgreSQL - SQL\nDESCRIPTION: Demonstrates the creation of a new schema named 'app_public' using standard SQL syntax. No external dependencies are required beyond a PostgreSQL database connection with sufficient privileges. The statement is typically run within a psql session or SQL migration tool; it accepts the desired schema name as its key parameter and produces a new, namespaced container for database objects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/namespaces.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema app_public;\n```\n\n----------------------------------------\n\nTITLE: Comparing GraphQL Queries Before and After View Flattening\nDESCRIPTION: These two GraphQL queries illustrate the difference in structure when querying related tables directly versus querying a flattened view. The 'Before' query shows a nested structure accessing `address` through `person`, while the 'After' query accesses the flattened data directly from `personView`, resulting in a simpler query.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/views.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery Before {\n  person {\n    id\n    address {\n      country\n      street\n    }\n  }\n}\n\nquery After {\n  personView {\n    id\n    country\n    street\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting an Attribute from Deleted Row via pgDeleteSingle.get in TypeScript\nDESCRIPTION: This snippet shows how to retrieve a specific attribute, such as 'username', from the row deleted by pgDeleteSingle. The get method allows selection of any attribute from the deleted row using the SQL RETURNING clause. It requires that the attribute name be provided as a string and that the resource supports the attribute.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgDeleteSingle.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $username = $deletedUser.get(\"username\");\n```\n\n----------------------------------------\n\nTITLE: Setting Up Row-Level Security Policies - PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates how to enable row-level security on a target table and define a set of policies governing who can manage, insert, or delete rows based on user-provided or context-driven conditions. Dependencies are a PostgreSQL instance with tables and relevant user-defined functions (e.g., current_user_id, are_friends) implemented. Key parameters include policy types, affected operations, and policy logic. The outcome is more granular access control over data visibility and modification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/required-knowledge.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- Without this line, even if you define security policies, they will not be enforced\nalter table my_table enable row level security;\n\ncreate policy manage_own on my_table for all using ( author_id = current_user_id() );\ncreate policy must_be_verified on my_table as restrictive for insert using ( current_user_is_verified() );\ncreate policy admin_delete on my_table for delete using ( current_user_is_admin() );\ncreate policy friend_insert on my_other_table for insert with check ( are_friends(author_id, user_id) );\n```\n\n----------------------------------------\n\nTITLE: Calling a Potentially Replaced Inflector (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how application code calls an inflector, like `builtin`. The Graphile Build system internally manages passing the `previous` inflector function and the resolved `preset` to the actual implementation (which might be the original or a replacement provided by a plugin). The calling code only needs to provide the arguments specific to the inflector's purpose (e.g., the text 'Query').\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst text = inflection.builtin(\"Query\");\n```\n\n----------------------------------------\n\nTITLE: Creating the Forum Post Table with Constraints and Comments (SQL)\nDESCRIPTION: Defines the `post` table within the `forum_example` schema. It includes columns for ID (primary key), author ID (foreign key to `person`), headline (with length check), body, topic (using the custom `post_topic` enum), and creation timestamp. Comments are added to the table and columns for documentation, which PostGraphile can use for GraphQL descriptions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.post (\n  id               serial primary key,\n  author_id        integer not null references forum_example.person(id),\n  headline         text not null check (char_length(headline) < 280),\n  body             text,\n  topic            forum_example.post_topic,\n  created_at       timestamp default now()\n);\n\ncomment on table forum_example.post is 'A forum post written by a user.';\ncomment on column forum_example.post.id is 'The primary key for the post.';\ncomment on column forum_example.post.headline is 'The title written by the user.';\ncomment on column forum_example.post.author_id is 'The id of the author user.';\ncomment on column forum_example.post.topic is 'The topic this has been posted in.';\ncomment on column forum_example.post.body is 'The main body text of our post.';\ncomment on column forum_example.post.created_at is 'The time this post was created.';\n```\n\n----------------------------------------\n\nTITLE: Enabling Row Level Security in Postgres (SQL)\nDESCRIPTION: These SQL commands enable Row Level Security (RLS) on the \\\"person\\\" and \\\"post\\\" tables in the \\\"forum_example\\\" schema. Enabling RLS restricts data access per row rather than at the table level for all roles unless explicit policies are created. These statements are prerequisites for defining fine-grained policies that govern data visibility and manipulation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_37\n\nLANGUAGE: sql\nCODE:\n```\nalter table forum_example.person enable row level security;\nalter table forum_example.post enable row level security;\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Materialized Views - SQL\nDESCRIPTION: This snippet shows adding smart comments to a materialized view, including custom naming and operation omission tags in PostGraphile. Uses escape string constants for the COMMENT statement. Input: COMMENT on a materialized view. Output: schema changes reflected in PostGraphile's generated GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncomment on materialized view my_schema.mv_view is\\n  E'@name my_new_view_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Function to Compute Person's Full Name (SQL)\nDESCRIPTION: Creates a stable SQL function `forum_example.person_full_name` that accepts a `forum_example.person` record as input. It concatenates the `first_name` and `last_name` fields with a space in between and returns the result as text. A comment describing the function's purpose is also added. PostGraphile treats such functions as computed fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_full_name(person forum_example.person) returns text as $$\n  select person.first_name || ' ' || person.last_name\n$$ language sql stable;\n\ncomment on function forum_example.person_full_name(forum_example.person) is 'A personâ€™s full name which is a concatenation of their first and last name.';\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL API Route without Websockets in Nuxt using TypeScript\nDESCRIPTION: This code sets up a RESTful API route handler for GraphQL requests in a Nuxt application without websocket support. It utilizes the 'eventHandler' from the 'h3' framework and the initialized 'serv' instance from Grafserv. The handler processes incoming events by passing them to the 'handleGraphQLEvent' method of the shared server instance. Dependencies are 'h3' and the previously configured 'serv' export.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/nuxt.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { eventHandler } from \\\"h3\\\";\nimport { serv } from \\\"@/server/grafserv/serv\\\";\n\n// Create and export the `/api/graphql` route handler\nexport default eventHandler((event) => serv.handleGraphQLEvent(event));\n```\n\n----------------------------------------\n\nTITLE: Querying a Set-Returning Computed Column with Subquery Aggregation - SQL\nDESCRIPTION: Demonstrates querying a set-returning computed column ('person_favorite_posts') for each person using an array aggregation subquery. This example is relevant for PostGraphile users who want to fetch associated rows (e.g., posts) as an array, preventing N+1 row expansion by keeping the parent result set at one row per person. It expects a function returning SETOF and uses subselect syntax in SQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nselect\n  person.id,\n  array(\n    select posts.*\n    from person_favorite_posts(person) posts\n  ) as favorite_posts\nfrom person\nwhere id = $1;\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Triggers to Notify GraphQL Subscriptions in SQL\nDESCRIPTION: This SQL code creates two triggers, `_500_gql_update` and `_500_gql_update_member`, on the `app_public.users` and `app_public.organization_members` tables, respectively. Both triggers utilize the `app_public.graphql_subscription` function defined previously. They are configured to send notifications via `pg_notify` upon data changes (UPDATE for users, INSERT/UPDATE/DELETE for members), publishing specific event names ('userChanged', 'organizationsChanged') to dynamically generated topics ('graphql:user:$1') based on the user or member ID.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TRIGGER _500_gql_update\n  AFTER UPDATE ON app_public.users\n  FOR EACH ROW\n  EXECUTE PROCEDURE app_public.graphql_subscription(\n    'userChanged', -- the \"event\" string, useful for the client to know what happened\n    'graphql:user:$1', -- the \"topic\" the event will be published to, as a template\n    'id' -- If specified, `$1` above will be replaced with NEW.id or OLD.id from the trigger.\n  );\n\nCREATE TRIGGER _500_gql_update_member\n  AFTER INSERT OR UPDATE OR DELETE ON app_public.organization_members\n  FOR EACH ROW\n  EXECUTE PROCEDURE app_public.graphql_subscription('organizationsChanged', 'graphql:user:$1', 'member_id');\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with Dedicated Role via CLI\nDESCRIPTION: Demonstrates how to start the PostGraphile server from the command line, connecting to the PostgreSQL database using the specifically created `forum_example_postgraphile` role and its password. The `-c` flag specifies the connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://forum_example_postgraphile:xyz@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic V4 Options in PostGraphile V5 Preset (TypeScript)\nDESCRIPTION: Demonstrates how to use the `makeV4Preset` factory in a `graphile.config.js` file to translate PostGraphile V4 options into the V5 preset system. It combines the V4 preset with the `PostGraphileAmberPreset` and includes setup for PostgreSQL services using `makePgService`. This configuration requires the `postgraphile` and `@graphile/config` packages.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"graphile.config.js\"\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-start\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n    }),\n    // highlight-end\n  ],\n\n  pgServices: [\n    makePgService({\n      connectionString: process.env.DATABASE_URL,\n      schemas: [\"app_public\"],\n    }),\n  ],\n};\n\nexport default preset;\n```\n```\n\n----------------------------------------\n\nTITLE: Sending JWT with Apollo Client HTTP Link in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to configure Apollo Client using `createHttpLink` and `setContext` (from `@apollo/client/link/context`). It creates an `authLink` middleware that retrieves a JWT (using a placeholder `getJWTToken()` function) and adds it to the `Authorization` header as a Bearer token for outgoing GraphQL requests via HTTP. The header is only added if a token exists.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst httpLink = createHttpLink({\n  uri: \"/graphql\",\n});\n\nconst authLink = setContext((_, { headers }) => {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  // return the headers to the context so httpLink can read them\n  return {\n    headers: {\n      ...headers,\n      // Only pass the authorization header if we have a JWT\n      ...(token ? { authorization: `Bearer ${token}` } : null),\n    },\n  };\n});\n\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Planning an Update Mutation Using Node ID Handler - TypeScript\nDESCRIPTION: This snippet illustrates how to use a node ID handler to transform an ID into an entity spec and use it to plan a database update in a GraphQL mutation resolver. It shows the integration of 'specFromNodeId', a database update step, and result shaping with the option to apply additional mutation plans. The surrounding context expects a mutation type definition (such as 'updateUser') and a handler compatible with the entity. Useful for mutation planning logic where fetching and updating entities by global node ID is required. Dependencies: Graphile planning/execution environment, the userHandler, and 'pgUpdateSingle'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst typeDefs = /* GraphQL */ `\n  extend type Mutation {\n    updateUser(id: ID!, patch: UserPatch!): UpdateUserPayload\n  }\n`;\n\nconst plans = {\n  Mutation: {\n    updateUser(parent, { $id }) {\n      // Turn the $id into a specifier:\n      const spec = specFromNodeId(userHandler, $id);\n\n      // Now use this specifier to plan an update for this user:\n      const $result = pgUpdateSingle(userSource, spec);\n\n      // Leave space in our result so we can add more properties later:\n      const $payload = object({ result: $result });\n\n      // Apply all the plans from the 'patch' argument (omitted for brevity):\n      fieldArgs.apply($payload);\n\n      // Return the payload plan:\n      return $payload;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Schema Update for Computed Column primaryEmail - Diff\nDESCRIPTION: Displays a diff of changes in the GraphQL schema after introducing the computed column â€˜primaryEmailâ€™ via the previous SQL function. Illustrates the extension of the User-type node to include a â€˜primaryEmail: Stringâ€™ field, showing how database changes directly affect API output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -3130,6 +3130,7 @@\n     \"\"\"\n     condition: QuizEntryCondition\n   ): QuizEntriesConnection!\n+  primaryEmail: String\n }\n\n \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Representing and Escaping SQL Identifiers with sql.identifier in JavaScript\nDESCRIPTION: This function takes one or more SQL identifier strings and returns a safely escaped identifier expression. Each identifier is securely escaped to prevent SQL injection risks, and multiple identifiers are joined using dot notation (e.g., \\\"schema\\\".\\\"table\\\".\\\"column\\\"). Dependencies include a JavaScript environment and the containing SQL composition library. The expected parameters are one or more identifier names as strings, with the output being a single escaped identifier suitable for SQL queries. The main constraint is that this utility is for identifier values only, not for SQL data values.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-identifier.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nsql.identifier(ident, ...)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable PostgreSQL Trigger Function for GraphQL Subscriptions in SQL\nDESCRIPTION: This SQL code defines a PostgreSQL function `app_public.graphql_subscription` intended to be used by triggers. It accepts an event name, a topic template, and an optional attribute name as arguments. On trigger execution (INSERT, UPDATE, DELETE), it constructs a JSON payload containing the event and subject (derived from the specified attribute of the NEW or OLD row) and uses `pg_notify` to send this payload to the calculated topic. It handles potential topic changes during UPDATE operations to notify both old and new topics if necessary.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.graphql_subscription() returns trigger as $$\ndeclare\n  v_process_new bool = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE');\n  v_process_old bool = (TG_OP = 'UPDATE' OR TG_OP = 'DELETE');\n  v_event text = TG_ARGV[0];\n  v_topic_template text = TG_ARGV[1];\n  v_attribute text = TG_ARGV[2];\n  v_record record;\n  v_sub text;\n  v_topic text;\n  v_i int = 0;\n  v_last_topic text;\nbegin\n  -- On UPDATE sometimes topic may be changed for NEW record,\n  -- so we need notify to both topics NEW and OLD.\n  for v_i in 0..1 loop\n    if (v_i = 0) and v_process_new is true then\n      v_record = new;\n    elsif (v_i = 1) and v_process_old is true then\n      v_record = old;\n    else\n      continue;\n    end if;\n     if v_attribute is not null then\n      execute 'select $1.' || quote_ident(v_attribute)\n        using v_record\n        into v_sub;\n    end if;\n    if v_sub is not null then\n      v_topic = replace(v_topic_template, '$1', v_sub);\n    else\n      v_topic = v_topic_template;\n    end if;\n    if v_topic is distinct from v_last_topic then\n      -- This if statement prevents us from triggering the same notification twice\n      v_last_topic = v_topic;\n      perform pg_notify(v_topic, json_build_object(\n        'event', v_event,\n        'subject', v_sub\n      )::text);\n    end if;\n  end loop;\n  return v_record;\nend;\n$$ language plpgsql volatile set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with Serial ID in PostgreSQL using SQL\nDESCRIPTION: Defines the `person` table within the `forum_example` schema using a serial integer as the primary key. It includes columns for `first_name` (required text, max 80 chars), `last_name` (optional text, max 80 chars), `about` (text), and `created_at` (timestamp defaulting to the current time). Check constraints are used for basic data validation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.person (\n  id               serial primary key,\n  first_name       text not null check (char_length(first_name) < 80),\n  last_name        text check (char_length(last_name) < 80),\n  about            text,\n  created_at       timestamp default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via CLI Flag in Bash\nDESCRIPTION: Illustrates how to enable multiple PostGraphile server plugins using the `--plugins` command-line flag. This flag must be the first one passed to the `postgraphile` command. Plugins are specified as a comma-separated list.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```\npostgraphile --plugins \\\n  @graphile/operation-hooks,@graphile/pg-pubsub,@graphile/pro \\\n  -c postgres:///my_db\n```\n```\n\n----------------------------------------\n\nTITLE: Annotating PostgreSQL Enum Types with Smart Comments - SQL\nDESCRIPTION: Sets a comment on a PostgreSQL enum type, using PostGraphile smart comment syntax to provide metadata about the enum for GraphQL schema generation. The '@enumName' allows specifying a custom GraphQL enum name, and '@enumDescription' is also available. Requires a PostgreSQL environment and PostGraphile integration for effective use. The main parameter is the enum type name and the comment string, which customizes the GraphQL mapping for this enum type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/enums.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TYPE animal_type IS E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Defining Row Level Select Policies in Postgres SQL\nDESCRIPTION: This SQL snippet creates select policies on person and post tables to permit all roles to view all rows, effectively restoring select access when RLS is enabled. It uses the CREATE POLICY statement with a permissive using (true) clause. Prerequisites are that RLS is enabled on the target tables and the tables exist in forum_example schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_39\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy select_person on forum_example.person for select\\n  using (true);\\n\\ncreate policy select_post on forum_example.post for select\\n  using (true);\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Object Type in Graphile V5 (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to register a new object type within a Graphile Config plugin using the build.registerObjectType API during the schema init hook. It utilizes a custom inflector for naming, provides a spec callback for the type description and fields, and allows optional assertion of compatible step classes for advanced type safety. Dependencies include the GraphileConfig.Plugin object, scope for type-specific metadata, and access to an inflection utility. The registered type is available for downstream fields and arguments by name, ensuring deterministic schema construction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyPlugin: GraphileConfig.Plugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      init(_, build) {\n        const typeName = inflection.myInflector(\"MyInflectorInput\");\n\n        build.registerObjectType(\n          typeName,\n          {\n            /* add scope data here */\n          },\n          () => ({\n            // Here's the spec for the type\n            description: \"...\",\n            fields: {\n              //...\n            },\n\n            // If this type requires a particular step class, optionally\n            // specify it here:\n            //\n            //     assertStep: ObjectStep,\n            //\n            // Or if you prefer, you can make `assertStep` a callback that\n            // throws an error if the step passed is incompatible:\n            //\n            //     assertStep($step: ExecutableStep): asserts $step is ObjectStep {\n            //       if (!($step instanceof ObjectStep)) {\n            //         throw new Error(`Expected ObjectStep, instead received '${$step}'`);\n            //       }\n            //     },\n          }),\n          `Here you'd put a helpful phrase detailing why this type is being registered; useful when two types try and register with the same name`,\n        );\n\n        return _;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile via npx with Connection Strings using Bash\nDESCRIPTION: Demonstrates running the locally installed PostGraphile server using `npx`, which executes Node.js package binaries. Each example specifies the Amber preset (`-P postgraphile/presets/amber`) and a database connection string (`-c`). Examples include connecting to a local database `mydb`, a database requiring SSL (`ssl=true`), and a remote database `somedb` on `somehost:2345`. Requires Node.js, npx, and a local `postgraphile` installation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Connect to the `mydb` database within the local PostgreSQL server\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres:///mydb\"\n\n# Connect to a database that requires SSL/TLS\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres://securehost:5432/db?ssl=true\"\n\n# Connect to the `somedb` database within the PostgreSQL at somehost port 2345\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres://somehost:2345/somedb\"\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Plugin with makeExtendSchemaPlugin in TypeScript\nDESCRIPTION: Demonstrates the basic structure of a PostGraphile plugin using `makeExtendSchemaPlugin`. It extends the `Query` type with a `meaningOfLife` field, providing its implementation using the `plans` property and the `constant` helper from `postgraphile/grafast`. The example also shows how to access helpers like `sql` and `inflection` from the `build` object passed to the plugin callback. A commented-out section shows the equivalent implementation using traditional `resolvers`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { constant } from \"postgraphile/grafast\";\n\nexport const MyPlugin = makeExtendSchemaPlugin((build) => {\n  // Get any helpers we need from `build`\n  const { sql, inflection } = build;\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        meaningOfLife: Int\n      }\n    `,\n\n    plans: {\n      Query: {\n        meaningOfLife() {\n          return constant(42);\n        },\n      },\n    },\n\n    /*\n    // Though makeExtendSchemaPlugin and Grafast both support traditional\n    // resolvers, plan resolvers are preferred for a \"pure\" Grafast schema.\n    // Here's what the above would look like with traditional resolvers:\n    resolvers: {\n      Query: {\n        meaningOfLife() {\n          return 42;\n        },\n      },\n    },\n    */\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Renaming Entities using SQL Smart Comments\nDESCRIPTION: Uses SQL `COMMENT` statements with the `@name` smart tag to rename the `post` table to `message` and the `search_posts` function to `returnPostsMatching` in the generated PostGraphile GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table post is\n  E'@name message';\ncomment on function search_posts(text) is\n  E'@name returnPostsMatching';\n```\n\n----------------------------------------\n\nTITLE: Implementing the Plan for addTwoNumbers Using Lambda - TypeScript\nDESCRIPTION: Implements the plan for the addTwoNumbers field using grafast's lambda step. This code extracts arguments a and b, then applies a lambda operation to sum these values. It requires the grafast package and expects the surrounding schema to match the type definitions. Inputs are GraphQL field arguments; output is their sum.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst { lambda } = require(\"grafast\");\n\nconst plans = {\n  Query: {\n    addTwoNumbers(_, fieldArgs) {\n      const $a = fieldArgs.get(\"a\");\n      const $b = fieldArgs.get(\"b\");\n      return lambda([$a, $b], ([a, b]) => a + b);\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile Plugins (CommonJS) in JavaScript\nDESCRIPTION: Demonstrates how to import the `postgraphile` library, the `makePluginHook` utility, and specific server plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) using CommonJS `require` syntax in a Node.js environment (version 8 or later). This is typically done when integrating PostGraphile as middleware.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { postgraphile, makePluginHook } = require(\"postgraphile\");\nconst { default: OperationHooks } = require(\"@graphile/operation-hooks\");\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\");\nconst { default: GraphilePro } = require(\"@graphile/pro\");\n```\n\n----------------------------------------\n\nTITLE: Querying with Filtering in Graphile GraphQL API - GraphQL\nDESCRIPTION: This GraphQL code snippet demonstrates querying entities and functions for filtering, based on the presence of the @filterable smart comment in the underlying SQL. It provides an example of using the condition argument for table-row-returning functions and scalar computed columns, allowing users to limit results based on specific fields. This functionality requires a Graphile-powered GraphQL API with the relevant smart comments applied; expected output is a filtered collection of records.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_30\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(condition: {firstName: \"Alice\"}) { ... }\n\n  # If the function return a scalar\n  allUsers(condition: {foo: \"FOO_VALUE\"}) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Node Module Resolution - TypeScript\nDESCRIPTION: This code block shows how to configure TypeScript version 5.0.0+ for node16 or nodenext module resolution. This configuration is necessary for projects using grafast with TypeScript, allowing the project to correctly resolve the exports field in grafast's package.json. The setting should be added to the compilerOptions section of tsconfig.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n    \"moduleResolution\": \"node16\", // Or \"nodenext\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving JWT Claims from Session-Scoped GUCs in PostgreSQL (SQL)\nDESCRIPTION: These SQL commands demonstrate retrieving JWT claim values stored in session-scoped GUC variables after serialization. The example shows both 'select current_setting' and 'show' to access the value of the 'jwt.claims.user_id' parameter. Assumes the claim has already been set with 'SET LOCAL'; these functions are built-in to PostgreSQL and require no external dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nselect current_setting('jwt.claims.user_id');\n-- Orâ€¦\nshow jwt.claims.user_id;\n```\n\n----------------------------------------\n\nTITLE: Building a Basic GraphQL Schema with Graphile Build in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the fundamental usage of the `graphile-build` library. It imports the `buildSchema` function and `defaultPreset`, defines a basic preset (which can be extended with additional presets), asynchronously builds a GraphQL schema using this configuration, and then prints the resulting schema definition to the console using `printSchema` from the `graphql` library. It requires the `graphile-build` and `graphql` packages as dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { buildSchema, defaultPreset } from \"graphile-build\";\nimport { printSchema } from \"graphql\";\n\nconst preset = {\n  extends: [\n    defaultPreset,\n    // Add more presets here!\n  ],\n};\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgreSQL Schema, Table, and Validation Function - SQL\nDESCRIPTION: Prepares the PostgreSQL environment by creating necessary schemas (app_public, app_private), a table (app_public.foo), and a validation function (app_private.validate_subscription). Requires PostgreSQL with procedural language support. Accepts no parameters except for the function input, and lays groundwork for PostGraphile to work with the foo table and to cancel subscriptions on demand. Outputs creation statements for objects used in subscriptions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_18\n\nLANGUAGE: SQL\nCODE:\n```\ncreate schema if not exists app_public;\ncreate schema if not exists app_private;\n\ncreate table if not exists app_public.foo (\n id serial primary key,\n title text not null\n);\n\ncreate or replace function\n  app_private.validate_subscription(topic text)\n  returns text as\n$$\n select 'CANCEL_ALL_SUBSCRIPTIONS'::text;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Interpreting a Batch GraphQL Query Response Payload in JSON\nDESCRIPTION: This JSON snippet shows the structure of a response received from PostGraphile for a batched query request. The response is a JSON array where each element corresponds to the result of a query in the batch, containing either a `data` object on success or an `errors` array if a query failed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"data\": [...]\n  },\n  {\n    \"data\": [...]\n  },\n  {\n    \"errors\": [...]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Performing Access Checks with Side Effects in Mutation Plans (JavaScript, PostGraphile)\nDESCRIPTION: Illustrates how to implement access control in a mutation field plan by injecting a side effect using PostGraphile's 'sideEffect' and 'context' utilities. The snippet checks whether a user has admin rights via the GraphQL context and aborts the mutation if access is denied. Required dependencies are 'postgraphile/grafast' and 'postgraphile/utils'; inputs are extracted from context and outputs will short-circuit mutation execution if conditions aren't met.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { sideEffect, context } from \"postgraphile/grafast\";\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\n\nconst plugin = makeWrapPlansPlugin({\n  Mutation: {\n    createUser(plan) {\n      // Extract the 'isAdmin' property from the GraphQL context\n      const $isAdmin = context().get(\"isAdmin\");\n\n      // If the user isn't an admin, throw an error\n      const $preCheck = sideEffect($isAdmin, (isAdmin) => {\n        if (!isAdmin) {\n          throw new Error(\"Abort\");\n        }\n      });\n\n      // Now call the underlying plans; these will never execute if the above throws\n      return plan();\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Fields with Hooks using Graphile Build Context (JavaScript)\nDESCRIPTION: This example shows a Graphile Build plugin using the `GraphQLInputObjectType_fields` hook to add a new field (`helloWorld`) to input object types. It uses the `fieldWithHooks` function, destructured from the context object, to define the field's scope (`fieldName`, `isHelloWorldField`) and its specification (type and plan). Using `fieldWithHooks` allows other plugins to subsequently hook into this newly added field.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/context-object.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLInputObjectType_fields(fields, build, context) {\n        const {\n          extend,\n          graphql: { GraphQLNonNull, GraphQLString },\n        } = build;\n        // highlight-next-line\n        const { fieldWithHooks } = context;\n        // TODO: if (...) return fields;\n        return extend(\n          fields,\n          {\n            // highlight-start\n            helloWorld: fieldWithHooks(\n              // The scope\n              { fieldName: \"helloWorld\", isHelloWorldField: true },\n\n              // The spec generator\n              () => ({\n                type: new GraphQLNonNull(GraphQLString),\n                plan() {\n                  return constant(\"Hello World\");\n                },\n              }),\n            ),\n            // highlight-end\n          },\n          \"Adding helloWorld from 'MyPlugin'\",\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Specifying the Mutation Operation Type in GraphQL\nDESCRIPTION: This GraphQL snippet clarifies that when sending a mutation request, the operation type must be explicitly stated as `mutation`. If omitted, GraphQL defaults to interpreting the request as a `query`, which would lead to an error when trying to execute a mutation field like `createThing`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/crud-mutations.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createThing...\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Variable Conflict in PL/pgSQL Upsert Using use_column\nDESCRIPTION: Demonstrates how to resolve the variable substitution ambiguity in a PL/pgSQL `ON CONFLICT` clause. By adding the `#variable_conflict use_column` directive, PostgreSQL is explicitly instructed to interpret `id` within `on conflict (id)` as the table column, not the function argument.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate function upsert_value(id int, value text) returns void as $$\n#variable_conflict use_column\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    on conflict (id)\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n\n----------------------------------------\n\nTITLE: Running the PostGraphile Server (Bash)\nDESCRIPTION: This Bash command starts the PostGraphile server, connecting to the Postgres instance as the \\\"forum_example_postgraphile\\\" user with a specific password. Ensure that the referenced user, password, and schema are set up in the Postgres instance in advance. This command should be run in a terminal where PostGraphile is installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://forum_example_postgraphile:xyz@localhost\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic JavaScript Configuration File\nDESCRIPTION: This snippet shows a minimal `graphile.config.mjs` file using ES Modules. It imports the `PostGraphileAmberPreset` from `postgraphile/presets/amber` and exports a preset object that extends it. This serves as the basic configuration for PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [PostGraphileAmberPreset],\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Plugins using Yarn in Bash\nDESCRIPTION: Shows the command-line instruction for installing a PostGraphile plugin (e.g., `@graphile/operation-hooks`) using the `yarn add` package manager command.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn add @graphile/operation-hooks\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Computed Fields on GraphQL Person Type (GraphQL)\nDESCRIPTION: This partial GraphQL schema shows how PostGraphile integrates specific SQL functions as computed fields on the `Person` type. The `fullName` field corresponds to the `person_full_name` function, and `latestPost` corresponds to the `person_latest_post` function, demonstrating automatic schema generation based on database structure and functions that meet PostGraphile's criteria for computed fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\ntype Person {\n  id: Int!\n  firstName: String!\n  lastName: String\n  ...\n  fullName: String\n  latestPost: Post\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Processed Schema with makeProcessSchemaPlugin - TypeScript\nDESCRIPTION: This snippet demonstrates using makeProcessSchemaPlugin to create a plugin that exports the current GraphQL schema to a file using the graphile-export library. It requires postgraphile/utils and graphile-export as dependencies. The plugin processes the schema synchronously, invokes exportSchema to write to 'exported-schema.mjs' in the current working directory, and logs errors if file export fails. The schema is always returned unmodified, making this suitable for read-only side-effectful operations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-process-schema-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeProcessSchemaPlugin } from \"postgraphile/utils\";\nimport { exportSchema } from \"graphile-export\";\n\nconst ExportSchemaPlugin = makeProcessSchemaPlugin((schema) => {\n  exportSchema(schema, `${process.cwd()}/exported-schema.mjs`, {\n    mode: \"typeDefs\",\n  }).catch((e) => {\n    console.error(e);\n  });\n  return schema;\n});\n```\n\n----------------------------------------\n\nTITLE: Renaming Custom Types and Functions using Smart Comments in SQL\nDESCRIPTION: Creates a custom SQL type `flibble` and a function `getFlamble` returning a set of this type. `COMMENT` statements with the `@name` smart tag are then used to rename the type to `flamble` and the function to `allFlambles` within the PostGraphile GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate type flibble as (f text);\n\ncreate function getFlamble() returns SETOF flibble as $$\n    select (body)::flibble from post\n$$ language sql;\n\ncomment on type flibble is E'@name flamble';\ncomment on function getFlamble() is E'@name allFlambles';\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic PostgreSQL Function (SQL)\nDESCRIPTION: This SQL snippet creates a simple PostgreSQL function named `add` that takes two integer arguments (`a`, `b`) and returns their sum. It demonstrates the basic syntax for function creation using `$$` delimiters, specifying the return type, language (`sql`), and volatility (`stable`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\n select a + b\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Creating a Search Function Returning Table Rows in PostgreSQL\nDESCRIPTION: Provides an example of creating a PostgreSQL table `post` and a `STABLE` function `search_posts` that accepts a `search` text argument. The function performs a case-insensitive search using `ILIKE` on the `headline` and `body` columns and returns a `SETOF post` (a set of rows from the `post` table), which PostGraphile exposes as a connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-queries.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- Columns unnecessary to this demo were omitted. You can find the full table in\n-- our forum example.\ncreate table post (\n  \\u2026\n  headline         text not null,\n  body             text,\n  \\u2026\n);\n\n-- Create the function named `search_posts` with a text argument named `search`.\n-- This will expose `Query.searchPosts(search: String!, ...)` to GraphQL.\ncreate function search_posts(search text)\n  -- This function will return a set of posts from the `post` table. The\n  -- `setof` part is important to PostGraphile, check out our Functions article\n  -- to learn why.\n  returns setof post as $$\n    -- Write our advanced query as a SQL query!\n    select *\n    from post\n    where\n      -- Use the `ILIKE` operator on both the `headline` and `body` columns. If\n      -- either return true, return the post.\n      headline ilike ('%' || search || '%') or\n      body ilike ('%' || search || '%')\n  -- End the function declaring the language we used as SQL and add the\n  -- `STABLE` marker so PostGraphile knows its a query and not a mutation.\n  $$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Defining the 'makeAddPgTableConditionPlugin' Function Signature in TypeScript\nDESCRIPTION: Shows the TypeScript function signature for `makeAddPgTableConditionPlugin`. It details the parameters: `match` (specifying the target table by optional serviceName, schemaName, and tableName), `conditionFieldName` (the name for the new GraphQL condition field), and `fieldSpecGenerator` (a function returning the field config, including type and the `applyPlan` logic for modifying the SQL query).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-condition-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeAddPgTableConditionPlugin(\n  match: { serviceName?: string; schemaName: string; tableName: string },\n  conditionFieldName: string,\n  fieldSpecGenerator: (build: GraphileBuild.Build) => GraphileInputFieldConfig,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Querying a PostGraphile Connection from a SETOF Function\nDESCRIPTION: Shows an example GraphQL query targeting the `myFunction` (defined as returning `SETOF person`) exposed by PostGraphile. It requests the first two items (`first: 2`), pagination details (`pageInfo`), and data for each node within the connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_18\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql {2}\n{\n  myFunction(a: 1, b: 2, first: 2) {\n    pageInfo {\n      hasNextPage\n      hasPrevPage\n    }\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Websocket Support in PostGraphile (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to enable websocket support for GraphQL subscriptions in PostGraphile by modifying the `grafserv.websockets` option within the exported configuration object. The configuration should be placed in a `graphile.config.mjs` file at the root of your project. This setting allows subscribing clients to use websockets for real-time data transport. No external dependencies required beyond PostGraphile's configuration system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  //...\n  grafserv: {\n    websockets: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Native PostgreSQL Enum and Table Schema (SQL)\nDESCRIPTION: Shows how to create a native PostgreSQL `ENUM` type named `animal_type` with specific values ('CAT', 'DOG', 'FISH') and a `pets` table that uses this enum type for its `type` column. PostGraphile automatically maps such native enums to GraphQL enums.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/enums.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type animal_type as enum (\n  'CAT',\n  'DOG',\n  'FISH'\n);\ncreate table pets (\n  id serial primary key,\n  type animal_type not null,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Defining makeChangeNullabilityPlugin Function Signature and Rules Interface (TypeScript)\nDESCRIPTION: Defines the TypeScript function signature for `makeChangeNullabilityPlugin` and the associated `ChangeNullabilityRules` interface. The function takes a rules object and returns a `GraphileConfig.Plugin`. The interface specifies how to structure rules per type name, allowing nullability changes for fields directly or via an object specifying field and argument nullability.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-change-nullability-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeChangeNullabilityPlugin(\n  rules: ChangeNullabilityRules,\n): GraphileConfig.Plugin;\n\ninterface ChangeNullabilityRules {\n  [typeName: string]: {\n    [fieldName: string]:\n      | NullabilitySpecString\n      | {\n          type?: NullabilitySpecString;\n          args?: {\n            [argName: string]: NullabilitySpecString;\n          };\n        };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Loading TagsFilePlugin in PostGraphile with JavaScript\nDESCRIPTION: This snippet demonstrates how to include the TagsFilePlugin in your PostGraphile JavaScript configuration (commonly a graphile.config.mjs file). The plugin automatically loads and processes the postgraphile.tags.json5 file from your project directory, extracting tags and descriptions to customize your GraphQL schema generation. The only dependency is postgraphile/utils. The plugins array may include multiple plugins; TagsFilePlugin must be included for this behavior.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags-file.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { TagsFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [TagsFilePlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Filter and Order Condition Plugin in JavaScript\nDESCRIPTION: Example JavaScript plugin using `makeAddPgTableConditionPlugin` for the `app_public.quiz` table. It adds an `entryCountMin` condition that filters quizzes based on a minimum number of entries and also modifies the query to order results by the entry count using `queryBuilder.orderBy`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { makeAddPgTableConditionPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeAddPgTableConditionPlugin(\n  \"app_public\",\n  \"quiz\",\n  \"entryCountMin\",\n  (build) => ({\n    type: build.graphql.GraphQLInt,\n  }),\n  (value, { queryBuilder, sql, sqlTableAlias }) => {\n    if (value == null) {\n      return;\n    }\n\n    // Order the result set by the number of entries the quiz has\n    queryBuilder.orderBy(\n      sql.fragment`(select count(*) from app_public.quiz_entry where quiz_entry.quiz_id = ${sqlTableAlias}.id)`,\n      false,\n      false,\n    );\n\n    // Filter to only quizzes that have at least `value` entries.\n    return sql.fragment`(select count(*) from app_public.quiz_entry where quiz_entry.quiz_id = ${sqlTableAlias}.id) >= ${sql.value(\n      value,\n    )}`;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom OrderBy Plugin for PostGraphile â€“ TypeScript\nDESCRIPTION: Defines a TypeScript module that creates and exports a PostGraphile plugin using makeAddPgTableOrderByPlugin, enabling sorting of 'forums' based on the date of the latest post in each forum. The plugin uses orderByAscDesc to generate 'LAST_POST_CREATED_AT_ASC' and '_DESC' enum values, building a correlated subquery to retrieve the max created_at timestamp from related 'posts'. Dependencies include postgraphile/utils, postgraphile/@dataplan/pg, and a properly configured PostGraphile build pipeline. Parameters include the schema and table names to match, a closure describing the order logic, and optional ordering options. Outputs a GraphileConfig.Plugin object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  makeAddPgTableOrderByPlugin,\n  orderByAscDesc,\n} from \"postgraphile/utils\";\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\n/* TODO: test this plugin works! */\nexport default makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  ({ sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"lastPostInForum\"));\n    return orderByAscDesc(\n      \"LAST_POST_CREATED_AT\",\n      ($select) => {\n        const orderByFrag = sql`(\n          select ${sqlIdentifier}.created_at\n          from app_public.posts as ${sqlIdentifier}\n          where ${sqlIdentifier}.forum_id = ${$select.alias}.id\n          order by ${sqlIdentifier}.created_at desc\n          limit 1\n        )`;\n        return { fragment: orderByFrag, codec: TYPES.timestamptz };\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Asserting Step Types for GraphQL Objects with __assertStep in TypeScript\nDESCRIPTION: Shows how to define an `__assertStep` function within the `plans` configuration for a custom GraphQL object type (`MyObject`) using `makeExtendSchemaPlugin`. This function validates that the underlying Gra*fast* step instance (`$step`) representing the object is one of the expected step classes (e.g., `PgSelectSingleStep`, `PgInsertSingleStep`, `PgUpdateSingleStep`), throwing a descriptive error otherwise. This ensures type safety and helps catch mismatches early during the query planning phase, guaranteeing that field resolvers receive the expected step type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\n\nconst schema = makeExtendSchemaPlugin({\n  typeDefs: gql`\n    type MyObject {\n      id: Int\n    }\n  `,\n  plans: {\n    MyObject: {\n      assertStep($step) {\n        if ($step instanceof PgSelectSingleStep) return true;\n        if ($step instanceof PgInsertSingleStep) return true;\n        if ($step instanceof PgUpdateSingleStep) return true;\n        throw new Error(\n          `Type 'User' expects a step of type PgSelectSingleStep, PgInsertSingleStep ` +\n            `or PgUpdateSingleStep; but found step of type '${$step.constructor.name}'.`,\n        );\n      },\n      a($obj: PgSelectSingleStep | PgInsertSingleStep | PgUpdateSingleStep) {\n        return $obj.get(\"id\");\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Modifying Field Descriptions using Graphile Build Context Scope (JavaScript)\nDESCRIPTION: This snippet demonstrates a Graphile Build plugin hook (`GraphQLInputObjectType_fields_field`) that conditionally modifies the description of the `clientMutationId` field on mutation input objects. It utilizes the `scope` property (specifically `isMutationInput` and `fieldName`) from the context object to target the correct field and uses the `extend` utility from the build object to apply the description.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/context-object.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLInputObjectType_fields_field(\n        field,\n        { extend },\n        { scope: { isMutationInput, fieldName } },\n      ) {\n        // highlight-start\n        if (\n          !isMutationInput ||\n          fieldName !== \"clientMutationId\" ||\n          field.description != null\n        ) {\n          return field;\n        }\n        return extend(field, {\n          description:\n            \"An arbitrary string value with no semantic meaning. \" +\n            \"Will be included in the payload verbatim. \" +\n            \"May be used to track mutations by the client.\",\n        });\n        // highlight-end\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Default Condition in GraphQL\nDESCRIPTION: This GraphQL query demonstrates the default usage of the `condition` argument in PostGraphile to filter the `allForums` collection, retrieving only forums where the `creatorId` is 1. This illustrates the built-in filtering mechanism before introducing custom conditions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-condition-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery ForumsCreatedByUser1 {\n  allForums(condition: { creatorId: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Reversing a List using reverse() in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the usage of the 'reverse' function. It takes an existing list variable '$list' as input and assigns the newly created reversed list to the constant '$reversed'. The '$' prefix might indicate variables within a specific framework context like Graphile Crystal.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/reverse.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $reversed = reverse($list);\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Complex Album/Track/Genre Data with GraphQL\nDESCRIPTION: A more complex, 3-level nested GraphQL query fetching albums for a specific artist, including their tracks and associated genre names. This query serves as a benchmark demonstrating PostGraphile's performance (approx. 1450 requests/second) on moderately complex data retrieval.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/performance.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery albums_tracks_genre_some {\n  allAlbumsList(condition: { artistId: 127 }) {\n    artistId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Optional optimize() Method in Grafast Step (TypeScript)\nDESCRIPTION: This snippet defines the optional optimize method for a Step in the Grafast execution plan framework using TypeScript. The method takes an options object (with a stream property) and either returns a new or existing Step instance or itself if no replacement is needed. This interface enables steps to request additional ancestor work or self-replacement for optimization during plan construction. Inputs include the options object; the output is the resulting Step instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\noptimize(\n  options: { stream: StepStreamOptions | null }\n): Step\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Step Class (AddStep) - TypeScript\nDESCRIPTION: Defines a custom AddStep class that extends grafast's Step, with a constructor to register dependencies and an execute method to sum input values for each batch index. This snippet is for scenarios requiring custom step logic beyond grafast's built-ins. Requires grafast and an understanding of how dependency batching works in grafast execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { Step } = require(\"grafast\");\n\nclass AddStep extends Step {\n  constructor($a, $b) {\n    super();\n    this.addDependency($a);\n    this.addDependency($b);\n  }\n\n  execute({ indexMap, values: [aDep, bDep] }) {\n    return indexMap((i) => {\n      const a = aDep.at(i);\n      const b = bDep.at(i);\n      return a + b;\n    });\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Annotating Functions as Sortable in PostGraphile (SQL)\nDESCRIPTION: These SQL snippets show how to use the @sortable smart comment to make functions sortable within Graphile-generated schemas. Adding the comment on a function enables 'orderBy' arguments in the resulting GraphQL schema, letting users specify sorting on function return columns or computed scalars. This requires functions to return SETOF a table-like type or be scalar-returning computed columns. Dependencies: PostgreSQL functions; used by PostGraphile for schema enhancement.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@sortable';\ncomment on function users_foo(users) is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Creating Grafserv Lambda Handler for API Gateway v2 (Node.js)\nDESCRIPTION: This JavaScript snippet initializes a Grafserv instance using a predefined schema and preset configuration. It then exports an AWS Lambda handler function generated by `serv.createHandler()`, specifically designed for AWS API Gateway v2 integrations. Required dependencies include `grafserv/lambda/v1`, a local `./graphile.config.mjs` preset file, and a `./schema.mjs` schema definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/lambda.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { grafserv } from \"grafserv/lambda/v1\";\nimport preset from \"./graphile.config.mjs\";\nimport schema from \"./schema.mjs\";\n\n// Create a Grafserv instance\nconst serv = grafserv({ schema, preset });\n\n// Export a lambda handler for GraphQL\nexport const handler = serv.createHandler();\n```\n\n----------------------------------------\n\nTITLE: Adding TagsFilePlugin to PostGraphile Preset (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates adding the `TagsFilePlugin` to the `plugins` array within a `graphile.config.mjs` file. This plugin enables the use of a `postgraphile.tags.json5` file for defining Smart Tags, which is the recommended method for most users to customize the PostGraphile schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { TagsFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [TagsFilePlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring Tables with Foreign Keys and Non-Null Constraints - SQL\nDESCRIPTION: This SQL snippet defines two tables: person and post, where posts are associated with authors via a not-null author_id foreign key. It illustrates how relational database constraints (non-null and references) interact with API nullability choices, leading to nuanced visibility in the resulting GraphQL API. Requires a PostgreSQL-compatible environment and proper extensions for citext.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/why-nullable.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table person (\n  id serial primary key,\n  username citext not null\n);\n\ncreate table post (\n  id serial primary key,\n  author_id int not null references person on delete cascade,\n  body text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile in Watch Mode - Bash\nDESCRIPTION: Shows using the --watch flag with npx postgraphile to enable live updates of the GraphQL API as the database schemas change. Requires local installation and a valid configuration file or CLI flags. This setup is useful for development workflows.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres:///mydb\" --watch\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector with Type Declarations (TypeScript)\nDESCRIPTION: This TypeScript example demonstrates adding a new inflector named `enhanced`. It includes a Graphile plugin definition `MyNewInflectorPlugin` with the `inflection.add.enhanced` function. Crucially, it uses TypeScript's declaration merging (`declare global`) to extend the `GraphileBuild.Inflection` interface, making the new `enhanced` inflector known and type-safe throughout the project. The function takes the `preset` and a `columnName` and returns the column name appended with 'Enhanced'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Import types for TypeScript, no need in JS\nimport \"graphile-config\";\nimport \"graphile-build\";\nimport \"graphile-build-pg\";\n\ndeclare global {\n  namespace GraphileBuild {\n    interface Inflection {\n      /**\n       * Add documentation for your inflector here.\n       */\n      enhanced(this: Inflection, columnName: string): string;\n    }\n  }\n}\n\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\n  name: \"MyNewInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    add: {\n      enhanced(preset, columnName) {\n        return columnName + \"Enhanced\";\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Writing Jest Test Case Using Database Helpers in JavaScript\nDESCRIPTION: Demonstrates a Jest test case (`test(\"can delete self\", ...)` written in JavaScript, utilizing the previously defined TypeScript helper functions. The test uses `withRootDb` to obtain a PostgreSQL client (`pgClient`) and execute database operations within an isolated transaction. It employs `createUsers` to set up test data (a user), `becomeUser` to set the appropriate database role and session context for that user, and `pgClient.query` to run the SQL `DELETE` statement being tested. Finally, it uses Jest's `expect` function to assert that the user was successfully deleted.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { becomeUser, createUsers, withRootDb } from \"../test_helpers\";\n\ntest(\"can delete self\", () =>\n  withRootDb(async (pgClient) => {\n    const [user] = await createUsers(pgClient, 1);\n\n    await becomeUser(pgClient, user);\n    const {\n      rows: [deletedUser],\n    } = await pgClient.query(\n      \"delete from app_public.users where id = $1 returning *\",\n      [user.id],\n    );\n    expect(deletedUser).toBeTruthy();\n  }));\n```\n\n----------------------------------------\n\nTITLE: Converting GraphQL Query to a Live Subscription (GraphQL)\nDESCRIPTION: Illustrates how to convert a standard GraphQL query into a live query by changing the operation type keyword from `query` (implicit in the previous example) to `subscription`. When used with a PostGraphile instance configured for live queries, this subscription will automatically push updated results to the client whenever the underlying data for `allPeople` changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile using a Configuration File via npx using Bash\nDESCRIPTION: Runs the locally installed PostGraphile server using `npx` without command-line flags for configuration. PostGraphile automatically detects and loads its configuration from a `graphile.config.mjs` (or similar) file in the current working directory. Requires Node.js, npx, a local `postgraphile` installation, and a valid configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ npx postgraphile\n```\n\n----------------------------------------\n\nTITLE: Minimal PostGraphile Configuration File - JavaScript\nDESCRIPTION: A minimal graphile.config.mjs JavaScript configuration file for extending the PostGraphile Amber preset. Requires postgraphile package installed in the project. This enables standardized configuration without repeated CLI flags.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nexport default { extends: [PostGraphileAmberPreset] };\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Operation with grafast in TypeScript (Reusable Function)\nDESCRIPTION: Defines an async utility function in TypeScript for executing GraphQL queries using grafast. Accepts requestContext, source (the query string), optional variable values, and operation name. It retrieves the current schema and preset from the PostGraphile instance and returns the execution result. Dependencies: postgraphile, grafast, relevant typings.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport { grafast } from \"postgraphile/grafast\";\nimport preset from \"./graphile.config.js\";\n\n// Make a new PostGraphile instance:\nconst pgl = postgraphile(preset);\n// Or import a shared instance:\n//   import { pgl } from \"./pgl.js\"\n\n/**\n * Given a request context `requestContext`, GraphQL query text `source` and\n * optionally variable values and operation name, execute the given GraphQL\n * operation against our schema and return the result.\n */\nexport async function executeQuery(\n  requestContext: Partial<Grafast.RequestContext>,\n  source: string,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n) {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n  return await grafast({\n    schema,\n    source,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving 'pgSubscriber' from Context (TypeScript)\nDESCRIPTION: Illustrates obtaining the pgSubscriber pub/sub object from the GraphQL execution context using the context().get() helper. This object lets you subscribe to PostgreSQL events via LISTEN/NOTIFY. Dependency: PostGraphile with a supported PostgreSQL adaptor and pgSubscriber available in context. Used inside subscription plan resolver logic to initiate topic listening. Returns a reference to the pgSubscriber instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $pgSubscriber = context().get(\"pgSubscriber\");\n```\n\n----------------------------------------\n\nTITLE: Creating a Grafast GraphQL Schema from a Registry in TypeScript\nDESCRIPTION: This snippet illustrates building a GraphQL schema using `grafast` based on a pre-defined `@dataplan/pg` registry. It defines GraphQL type definitions (`typeDefs`) for Query, Forum, and Message types. It then defines resolver logic (`plans`) using the registry's resource accessors (`forums.get`, `messages.find`) or relation helpers (`$forum.manyRelation`, `$message.singleRelation`) to fetch data based on the schema structure. Finally, `makeGrafastSchema` combines the type definitions and plans into an executable schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/example.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst { forums, messages } = registry.pgResources;\n\nconst typeDefs = /* GraphQL */ `\n  type Query {\n    forumById(id: Int!): Forum\n  }\n\n  type Forum {\n    id: Int!\n    name: String!\n    messages: [Message!]!\n  }\n\n  type Message {\n    id: Int!\n    message: String!\n    forum: Forum!\n  }\n`;\n\nconst plans = {\n  Query: {\n    forumById(_, { $id }) {\n      return forums.get({ id: $id });\n    },\n  },\n  Forum: {\n    messages($forum) {\n      return messages.find({ forum_id: $forum.get(\"id\") });\n      // OR: return $forum.manyRelation(\"messages\");\n    },\n  },\n  Message: {\n    forum($message) {\n      return forums.get({ id: $message.get(\"forum_id\") });\n      // OR: return $message.singleRelation(\"forum\");\n    },\n  },\n};\n\nimport { makeGrafastSchema } from \"grafast\";\nconst schema = makeGrafastSchema({ typeDefs, plans });\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with jsonParse in TypeScript\nDESCRIPTION: Demonstrates how to use the jsonParse function to parse a JSON string in TypeScript, returning a JsonParseStep object that can be further accessed via .get(key) for objects or .at(index) for arrays. Requires the jsonParse utility and a JSON string input ($jsonString). Returns the parsed value or throws an error on invalid JSON, and returns null if the input is null. Input: $jsonString (string or null). Output: Parsed JSON value or null. Throws on parse errors. The JsonParseStep can be chained for data access as described.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-json/jsonParse.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $parsed = jsonParse($jsonString);\n```\n\n----------------------------------------\n\nTITLE: Defining Not Null Constraint with Smart Tag in JSON5 - JSON5\nDESCRIPTION: Illustrates the application of the @notNull virtual constraint to a specific column using the JSON5 configuration format for 'postgraphile.tags.json5'. Sets the 'notNull' tag to true for 'my_view.my_column', ensuring non-nullability at the GraphQL layer. Requires integration with PostGraphile's smart tags processing. Input: configuration object, Output: modifies PostGraphile-generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_13\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      \"my_view.my_column\": {\n        tags: {\n          notNull: true,\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Restricting Email Field Visibility Based on Context (TypeScript)\nDESCRIPTION: This example creates a schema plugin that restricts access to the User.email field based on the currently authenticated user by conditionally returning null. It uses makeWrapPlansPlugin along with PostGraphile 'context' and 'lambda' helpers. The logic compares the requested user's ID with the current user's ID and only reveals the email when they match. Inputs are the plan resolver and parent/user context; output is either the email or null, masking sensitive information.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\\nimport { context, lambda } from \"postgraphile/grafast\";\\n\\nexport default makeWrapPlansPlugin({\\n  User: {\\n    email(plan, $user) {\\n      const $userId = $user.get(\"id\");\\n      const $currentUserId = context().get(\"jwtClaims\").get(\"user_id\");\\n      const $email = plan();\\n      return lambda(\\n        [$userId, $currentUserId, $email],\\n        ([userId, currentUserId, email]) =>\\n          userId === currentUserId ? email : null,\\n      );\\n    },\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Schema (V5) with makeSchema in JavaScript\nDESCRIPTION: This snippet presents the V5 method for creating a PostGraphile schema using `makeSchema` from the `postgraphile` package. It takes a configuration preset (imported from a file like `graphile.config.js`) as input and asynchronously returns an object containing the generated GraphQL schema and the resolved preset. This replaces the V4 `createPostGraphileSchema` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with JWT Configuration - Shell\nDESCRIPTION: Shows how to start PostGraphile with JWT authentication enabled, configuring both the JWT token identifier and secret, and the Postgres database connection. Requires PostGraphile CLI installed and a valid PostgreSQL connection URI. Main parameters include JWT schema/type, secret, DB credentials, and schema. This command-line sequence enables API authentication and JWT signing automatically.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npostgraphile \\\n  --jwt-token-identifier my_public_schema.jwt_token \\\n  --jwt-secret $JWT_SECRET \\\n  -c postgres://user:pass@host/dbname \\\n  -s my_public_schema\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Query Endpoints with makeExtendSchemaPlugin and selectGraphQLResultFromTable - PostGraphile - JavaScript\nDESCRIPTION: This example demonstrates the creation of a custom PostGraphile plugin that extends the GraphQL schema to provide three new query endpoints: randomUser, randomUsersConnection, and randomUsersList. The resolvers retrieve User data using resolveInfo.graphile.selectGraphQLResultFromTable, ordering results randomly and using QueryBuilder's orderBy and limit methods to control output. Express is used to serve the API, dependencies include postgraphile, graphile-utils, and express, and the inputs/outputs align with extended GraphQL types. The plugin is appended to PostGraphile via appendPlugins and can be adapted for similar resolver expansion patterns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { postgraphile } = require(\"postgraphile\");\nconst { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\nconst express = require(\"express\");\n\nconst app = express();\n\nconst MyRandomUserPlugin = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type Query {\n        # Individual record\n        randomUser: User\n\n        # Connection record\n        randomUsersConnection: UsersConnection\n\n        # List record\n        randomUsersList: [User!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        /*\n         * Individual record needs to return just one row but\n         * `selectGraphQLResultFromTable` always returns an array; so the\n         * resolver is responsible for turning the array into a single record.\n         */\n        randomUser: async (_query, args, context, resolveInfo) => {\n          // Remember: resolveInfo.graphile.selectGraphQLResultFromTable is where the PostGraphile\n          // look-ahead magic happens!\n          const rows = await resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n              queryBuilder.limit(1);\n            },\n          );\n          return rows[0];\n        },\n\n        /*\n         * Connection and list resolvers are identical; PostGraphile handles\n         * the complexities for you. We've simplified these down to a direct\n         * call to `selectGraphQLResultFromTable` but you may wish to wrap this\n         * with additional logic.\n         */\n        randomUsersConnection: (_query, args, context, resolveInfo) =>\n          resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n            },\n          ),\n        randomUsersList: (_query, args, context, resolveInfo) =>\n          resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n            },\n          ),\n      },\n    },\n  };\n});\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, [\"app_public\"], {\n    graphiql: true,\n    appendPlugins: [MyRandomUserPlugin],\n  }),\n);\napp.listen(3030);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Addition Function in PostgreSQL (SQL)\nDESCRIPTION: Creates a basic PostgreSQL function `add` using `LANGUAGE sql`. The function accepts two integer arguments (`a` and `b`) and returns their sum using a simple `SELECT` statement. It is marked `IMMUTABLE` (results depend only on inputs) and `STRICT` (returns NULL if any input is NULL).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  select a + b;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Graphile Build Inflection Plugin in JavaScript\nDESCRIPTION: Defines a simple Graphile Build plugin named 'FullNameToNamePlugin'. This plugin utilizes the inflection system's `replace.attribute` hook to rename any database column originally named 'full_name' to 'name' within the generated GraphQL schema. It checks the `details.attributeName` and returns 'name' if it matches 'full_name', otherwise, it calls the previous inflection function (`previous`) or defaults back to the original `details.attributeName`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n/** @type {GraphileConfig.Plugin} */\nconst FullNameToNamePlugin = {\n  name: \"FullNameToNamePlugin\",\n  inflection: {\n    replace: {\n      attribute(previous, options, details) {\n        if (details.attributeName === \"full_name\") {\n          return \"name\";\n        } else {\n          return previous?.(details) ?? details.attributeName;\n        }\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the makeChangeNullabilityPlugin Signature and Rules in TypeScript\nDESCRIPTION: This snippet presents the TypeScript function signature for `makeChangeNullabilityPlugin`, which takes a `ChangeNullabilityRules` object and returns a `GraphileConfig.Plugin`. It also defines the `ChangeNullabilityRules` interface, detailing how to specify nullability changes for types, fields, and arguments within the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-change-nullability-plugin.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction makeChangeNullabilityPlugin(\n  rules: ChangeNullabilityRules,\n): GraphileConfig.Plugin;\n\ninterface ChangeNullabilityRules {\n  [typeName: string]: {\n    [fieldName: string]:\n      | NullabilitySpecString\n      | {\n          type?: NullabilitySpecString;\n          args?: {\n            [argName: string]: NullabilitySpecString;\n          };\n        };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Schemas (SQL)\nDESCRIPTION: This SQL snippet creates two distinct schemas, `forum_example` and `forum_example_private`. Schemas act as namespaces within the database. `forum_example` is intended for publicly accessible objects exposed via PostGraphile, while `forum_example_private` is for internal data or functions not directly exposed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema forum_example;\ncreate schema forum_example_private;\n```\n\n----------------------------------------\n\nTITLE: Querying a Custom Mutation via GraphQL (GraphQL)\nDESCRIPTION: Demonstrates how to invoke the previously-defined PostgreSQL custom mutation from GraphQL using the Relay-compliant input object. The sample mutation provides integer values for parameters 'a' and 'b' and requests the 'text' field in the response. The GraphQL layer interfaces with the SQL function, passing parameters and returning structured results. Requires PostGraphile's GraphQL schema auto-generation based on introspected PostgreSQL functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  myFunction(input: { a: 1, b: 2 }) {\n    text\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Column Function with Custom Parameter - SQL\nDESCRIPTION: This SQL snippet defines a stable function 'topics_body_summary' which generates a text summary of a topic's body, using a custom maximum length parameter. When called, the function will truncate the text and append '...' if the body length exceeds this maximum; otherwise, it will return the full body. This function is designed to work as a computed column in a Graphile-backed GraphQL schema, supporting runtime argument customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.topics_body_summary(\n  t app_public.topics,\n  max_length int = 30\n)\nreturns text\nlanguage sql stable\nas $$\n  select case\n    when length(t.body) > max_length\n    then left(t.body, max_length - 3)\n           || '...'\n    else t.body\n    end;\n$$;\n```\n\n----------------------------------------\n\nTITLE: Migrating selectGraphQLResultFromTable Usage to V5 Resource Execution\nDESCRIPTION: Illustrates converting a V4 resolver that used `selectGraphQLResultFromTable` to call a PostgreSQL function (`match_user`) into a V5 plan. The V5 approach first identifies the `pgResource` corresponding to the function using `build.input.pgRegistry.pgResources.match_user`. It then defines a plan for the `Query.matchingUser` field that calls the resource's `execute` method, passing the `$searchText` argument step. This replaces the V4 helper and leverages Gra*fast*'s optimized data fetching, avoiding potential N+1 issues.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n module.exports = makeExtendSchemaPlugin((build) => {\n+  const matchUser = build.input.pgRegistry.pgResources.match_user;\n   return {\n     typeDefs: /* GraphQL */ `\n       type Query {\n         matchingUser(searchText: String!): User\n       }\n     `,\n-    resolvers: {\n-      Query: {\n-        matchingUser: async (parent, args, context, resolveInfo) => {\n-          const [row] = await resolveInfo.graphile.selectGraphQLResultFromTable(\n-            sql.fragment`(select * from match_user(${sql.value(\n-              args.searchText,\n-            )}))`, // Typically used sql.identifier for table/column names\n-            () => {}, // no-op callback for lookahead\n-          );\n-          return row;\n-        },\n-      },\n-    },\n+    plans: {\n+      Query: {\n+        matchingUser($parent, { $searchText }) {\n+          // Assumes matchUser function accepts a single text argument\n+          // The structure of the input object for execute depends on the resource definition\n+          // For a function expecting positional args: { 0: $searchText } or simply [$searchText]\n+          // For a function expecting named args: { step: $searchText } if arg name is 'step'\n+          // Assuming the function argument name matches the GraphQL argument name for simplicity here:\n+          return matchUser.execute({ searchText: $searchText }); // Adjust input based on actual function signature\n+        },\n+      },\n+    },\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: Querying PostgreSQL in a GraphQL Resolver with pgClient - JavaScript\nDESCRIPTION: This snippet demonstrates the use of the PostgreSQL client (pgClient) from the PostGraphile resolver context to execute queries within a GraphQL resolver in JavaScript. The pattern uses context.pgClient.query for parameterized queries. Its dependencies are having access to a running PostGraphile server and the context injection of pgClient. The inputs are the SQL statement and any variables; the expected output is a result object with rows. The code should only be used within the transaction lifecycle managed by PostGraphile resolvers, and not for transaction control commands like BEGIN or COMMIT.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { rows } = await context.pgClient.query(\n  sqlText, // e.g. \"select * from users where id = $1\"\n  optionalVariables, // e.g. [27]\n);\n```\n\n----------------------------------------\n\nTITLE: Comprehensive PostGraphile Configuration Example in TypeScript\nDESCRIPTION: This extensive TypeScript example (`graphile.config.ts`) demonstrates a more complex PostGraphile setup. It extends multiple presets (Amber, V4 compatibility, Relay), adds a plugin (`@grafserv/persisted`), and configures various scopes like `inflection`, `gather`, `schema`, `grafast`, `grafserv`, `ruru`, and `pgServices` with specific options like connection strings, schema exports, and persisted operations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=\"graphile.config.ts\"\n// Only needed for TypeScript types support\nimport \"postgraphile\";\n\n// The standard base preset to use, includes the main PostGraphile features\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\n// More presets you might want to mix in\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\nimport { PgRelayPreset } from \"postgraphile/presets/relay\";\n\n// Use the 'pg' module to connect to the database\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n// In case we want to customize the Ruru we render:\nimport { defaultHTMLParts } from \"postgraphile/grafserv/ruru/server\";\n\n// A plugin for the system to use for persisted operations support\nimport PersistedPlugin from \"@grafserv/persisted\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [\n    PostGraphileAmberPreset,\n    /* Add more presets here, e.g.: */\n    makeV4Preset({\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n      dynamicJson: true,\n      graphiql: true,\n      graphiqlRoute: \"/\",\n    }),\n    PgRelayPreset,\n  ],\n\n  plugins: [\n    /* Add plugins here, e.g.: */\n    PersistedPlugin,\n  ],\n\n  inflection: {\n    /* options for the inflection system */\n  },\n  gather: {\n    /* options for the gather phase, e.g.: */\n    pgStrictFunctions: true,\n    installWatchFixtures: true,\n  },\n  schema: {\n    /* options for the schema build phase, e.g.: */\n    retryOnInitFail: true,\n    exportSchemaSDLPath: `${process.cwd()}/latestSchema.graphql`,\n    exportSchemaIntrospectionResultPath: `${process.cwd()}/latestSchema.json`,\n    sortExport: true,\n  },\n  grafast: {\n    /* options for Grafast, including setting GraphQL context, e.g.: */\n    context: {\n      meaningOfLife: 42,\n    },\n    // explain: true, // DO NOT ENABLE IN PRODUCTION!\n  },\n  grafserv: {\n    /* options for Grafserv, e.g.: */\n    port: 5678,\n    graphqlPath: \"/graphql\",\n    websockets: true,\n    graphqlOverGET: true,\n    persistedOperationsDirectory: `${process.cwd()}/.persisted_operations`,\n    allowUnpersistedOperation: true,\n  },\n  ruru: {\n    /* options for customizing Ruru, e.g.: */\n    htmlParts: {\n      metaTags: defaultHTMLParts.metaTags + \"<!-- HELLO WORLD! -->\",\n    },\n  },\n  pgServices: [\n    /* list of PG database configurations, e.g.: */\n    makePgService({\n      // Database connection string, read from an environmental variable:\n      connectionString: process.env.DATABASE_URL,\n\n      // List of database schemas to expose:\n      schemas: [\"app_public\"],\n\n      // Enable LISTEN/NOTIFY:\n      pubsub: true,\n    }),\n  ],\n};\n\nexport default preset;\n```\n```\n\n----------------------------------------\n\nTITLE: Using JWT Middleware in an Express + PostGraphile API - JavaScript\nDESCRIPTION: Demonstrates full integration of the JWT-checking middleware in an Express application that exposes a GraphQL API via PostGraphile. After importing required libraries and configuring checkJwt with Auth0 and JWKS parameters, the Express app routes GraphQL requests through JWT authentication. The 'pgSettings' function maps JWT scopes to PostgreSQL session parameters (e.g., 'user.permissions'), which can be utilized in database-level security. Designed for Node.js apps needing Auth0 authentication for GraphQL endpoints via PostGraphile, with required dependencies on express, express-jwt, jwks-rsa, and postgraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\nconst checkJwt = jwt({\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n\nconst app = express();\n\n// Apply checkJwt to our graphql endpoint\napp.use(\"/graphql\", checkJwt);\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, process.env.DB_SCHEMA, {\n    pgSettings: (req) => {\n      const settings = {};\n      if (req.auth) {\n        settings[\"user.permissions\"] = req.auth.scope;\n      }\n      return settings;\n    },\n    // any other PostGraphile options go here\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with Enums Using makeExtendSchemaPlugin - JavaScript\nDESCRIPTION: Demonstrates how to define a GraphQL enum and extend existing GraphQL types via the makeExtendSchemaPlugin utility from PostGraphile. Utilizes the 'gql' template to declare an enum and type extension, and the 'plans' section to resolve values for the enum and related field. Dependencies include 'postgraphile/grafast' and 'postgraphile/utils'. Key parameters include typeDefs for SDL, enum values, and resolver logic. Inputs and outputs are determined by GraphQL query structure, and typical usage is to supplement the auto-generated schema with custom logic or types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/enums.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { constant } from \"postgraphile/grafast\";\nimport { gql, makeExtendSchemaPlugin } from \"postgraphile/utils\";\n\nconst myPlugin = makeExtendSchemaPlugin(() => ({\n  typeDefs: gql`\n    enum AnimalType {\n      \"\"\"\n      A feline animal\n      \"\"\"\n      CAT\n\n      \"\"\"\n      A canine animal\n      \"\"\"\n      DOG\n\n      \"\"\"\n      An aquatic animal\n      \"\"\"\n      FISH\n    }\n\n    extend type Pet {\n      type: AnimalType!\n    }\n  `,\n  plans: {\n    AnimalType: {\n      CAT: \"cat\",\n      DOG: \"dog\",\n      FISH: \"fish\",\n    },\n    Pet: {\n      type() {\n        /* TODO: add logic here */\n        return constant(\"cat\");\n      },\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Running an Exported PostGraphile Schema with Grafserv in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to set up and run a Node.js HTTP server using `grafserv` to serve a previously exported PostGraphile schema. It imports the exported schema module (`./exported-schema.mjs`) and the preset configuration (`./graphile.config.js`), demonstrating how to use the schema without the full PostGraphile build system. It depends on `postgraphile/grafserv/node`, `node:http`, the preset, and the exported schema file. The server listens on port 5555.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/exporting-schema.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { grafserv } from \"postgraphile/grafserv/node\";\nimport { createServer } from \"node:http\";\nimport preset from \"./graphile.config.js\";\nimport { schema } from \"./exported-schema.mjs\";\n\nconst server = createServer();\nconst serv = grafserv({ preset, schema });\nserv.addTo(server);\nserver.listen(5555);\nconsole.log(\"Listening on http://localhost:5555/\");\n```\n\n----------------------------------------\n\nTITLE: Mounting Multiple PostGraphile Schemas on Different Endpoints using Express (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates setting up an Express server to host multiple PostGraphile instances, each serving a different GraphQL schema associated with a specific PostgreSQL service ('admin', 'user'). Each instance is mounted on a unique endpoint path (e.g., '/admin/graphql', '/user/graphql') using the Grafserv Express adapter. It initializes an HTTP server, iterates over defined services, configures PostGraphile presets for each, creates Grafserv instances, and adds their route handlers to the Express app.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/multiple-schemas.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport postgraphile from \"postgraphile\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport userPreset from \"./graphile.config.mjs\";\n\n// Create an express app\nconst app = express();\n// (Add any Express middleware you want here.)\n\n// Create a Node HTTP server, mounting Express into it\nconst server = createServer(app);\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// Definitions of the PostgreSQL service we wish to expose via separate\n// GraphQL APIs:\nconst services = {\n  admin: \"postgres:///admin\",\n  user: \"postgres:///user\",\n};\n\n// Loop over the services, and add them to our Express app\nfor (const [service, connectionString] of Object.entries(services)) {\n  // Build a preset specifically for this service\n  const preset = {\n    extends: [userPreset],\n    pgServices: [makePgService({ connectionString })],\n    grafserv: {\n      graphqlPath: `/${service}/graphql`,\n      graphiqlPath: `/${service}`,\n    },\n  };\n  // Build a PostGraphile instance for this service\n  export const pgl = postgraphile(preset);\n  // Create the Grafserv instance for this PostGraphile instance using the Express adaptor\n  const serv = pgl.createServ(grafserv);\n  // Add the Grafserv instance's route handlers to the Express app, and register\n  // websockets if desired\n  await serv.addTo(app, server);\n  // TODO: check that enabling websockets on multiple grafservs via the same server doesn't cause any issues\n}\n\n// Start the Express server\nserver.listen(userPreset.grafserv?.port ?? 5678);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring `pgServices` using `makePgService` Helper (JavaScript)\nDESCRIPTION: Illustrates configuring PostGraphile's `pgServices` using the `makePgService` helper function from the `postgraphile/adaptors/pg` adaptor. This approach simplifies configuration by accepting common parameters like connection string, schemas, pub/sub setting, and superuser connection string, often sourced from environment variables (`process.env.DATABASE_URL`, `process.env.SUPERUSER_DATABASE_URL`), within a preset object (`GraphileConfig.Preset`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  // ...\n  pgServices: [\n    makePgService({\n      // Database connection string:\n      connectionString: process.env.DATABASE_URL,\n\n      // List of database schemas:\n      schemas: [\"app_public\"],\n\n      // Enable LISTEN/NOTIFY:\n      pubsub: true,\n\n      // Optional, only needed for `--watch` mode:\n      superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating People and Organizations Tables for GraphQL Union - SQL\nDESCRIPTION: Creates two independent tables, 'people' and 'organizations', each with a serial primary key and a unique constraint. These tables can be linked as union members in GraphQL. The tables are designed with compatibility in mind for being referenced elsewhere and for use with '@unionMember' PostGraphile tags.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.people (\n  person_id serial primary key,\n  username text not null unique\n);\n\ncreate table polymorphic.organizations (\n  organization_id serial primary key,\n  name text not null unique\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Computed Columns for Users in PostgreSQL (SQL)\nDESCRIPTION: Defines a database schema with users and friendships, and creates two computed-column functions: one for a concatenated display name and another for returning all friends as a set. Prerequisites: 'my_schema.users' and 'my_schema.friendships' tables. The functions follow Graphile conventions (first argument is the row type, special naming) and return either a string or a set of users. These become virtual fields in the GraphQL schema after integration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table my_schema.users (\n  id serial not null primary key,\n  first_name varchar not null,\n  last_name varchar not null\n);\n\ncreate table my_schema.friendships (\n  user_id integer not null,\n  target_id integer not null,\n  primary key (user_id, target_id)\n);\n\n-- Creates `User.name` string field\ncreate function my_schema.users_name(u my_schema.users)\nreturns varchar as $$\n  select u.first_name || ' ' || u.last_name;\n$$ language sql stable;\n\n-- Creates `User.friends` connection\ncreate function my_schema.users_friends(u my_schema.users)\nreturns setof my_schema.users as $$\n  select users.*\n  from my_schema.users\n  inner join my_schema.friendships\n  on (friendships.target_id = users.id)\n  where friendships.user_id = u.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Building Safe JavaScript Expressions Using Template Expressions in JavaScript\nDESCRIPTION: This snippet demonstrates the use of the 'te' function with a JavaScript tagged template literal. The function is designed to build parts or all of a JS expression, but enforces security by throwing an error if a non 'te' expression is interpolated. Direct inclusion of values not passed through the 'te' API leads to a runtime exception. No external dependencies are required beyond the implementation of 'te'. Inputs are template literals with embedded expressions, and the output is either the constructed expression or, if rules are violated, an exception; code injection is actively prevented.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nte`return 2 + ${1}`; // WILL THROW AN ERROR\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile for JWT Authentication (TypeScript)\nDESCRIPTION: Configures PostGraphileâ€™s JavaScript/TypeScript entrypoint to use a custom JWT configuration. Imports required amber and lazy-jwt presets, specifies the composite JWT type, and sets a secret for signing JWTs. The 'grafast.context' ensures that JWT-based roles from tokens will override default session roles. Dependencies: 'postgraphile/presets/amber' and 'postgraphile/presets/lazy-jwt' packages. Expected inputs include JWT tokens and overrideable Graphile context parameters.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { PgLazyJWTPreset } from \"postgraphile/presets/lazy-jwt\";\n\nexport default {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-next-line\n    PgLazyJWTPreset,\n  ],\n  gather: {\n    // highlight-next-line\n    pgJwtTypes: \"forum_example.jwt_token\",\n  },\n  schema: {\n    // highlight-next-line\n    pgJwtSecret: \"keyboard_kitten\", // REPLACE THIS!\n  },\n  grafast: {\n    context(requestContext, args) {\n      return {\n        pgSettings: {\n          role: \"forum_example_anonymous\",\n          // highlight-start\n          // JWT may override the role:\n          ...args.contextValue?.pgSettings,\n          // highlight-end\n        },\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Loading PostGraphile Plugins in a Library (JavaScript)\nDESCRIPTION: Illustrates how to load PostGraphile schema plugins when using PostGraphile as a library in a Node.js application. It shows requiring a plugin module (`postgraphile-plugin-connection-filter`) and passing it in an array to the `appendPlugins` option within the PostGraphile configuration object. Assumes usage within an Express-like framework (`app.use`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst ConnectionFilterPlugin = require(\"postgraphile-plugin-connection-filter\");\n//...\napp.use(\n  postgraphile(process.env.DATABASE_URL, \"app_public\", {\n    appendPlugins: [\n      ConnectionFilterPlugin,\n      /* add any more plugins you need here */\n    ],\n    graphiql: true,\n  }),\n);\n//...\n```\n\n----------------------------------------\n\nTITLE: Querying a View via GraphQL\nDESCRIPTION: This GraphQL query demonstrates how to fetch data from the `comedies` view created previously. It retrieves the `name` and `releaseYear` for the first 20 entries in the view, treating the view like a standard table within the GraphQL schema generated by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/views.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  comedies(first: 20) {\n    name\n    releaseYear\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functions Using JavaScript (PLv8) in PostgreSQL\nDESCRIPTION: Provides two examples of PostgreSQL functions written in JavaScript using the PLv8 extension (`LANGUAGE plv8`). The first defines a simple `add` function similar to previous examples. The second, `plv8_test`, demonstrates more complex logic: it takes arrays of keys and values, constructs a JavaScript object, and returns its JSON string representation. Both functions require the PLv8 extension to be installed and enabled.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\n```sql\n-- This does look the exact same as the PL/pgSQL exampleâ€¦\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  return a + b;\n$$ LANGUAGE plv8 IMMUTABLE STRICT;\n\n-- Hereâ€™s a better example from the plv8 repoâ€¦\nCREATE FUNCTION plv8_test(keys text[], vals text[]) RETURNS text AS $$\n  var object = {}\n  for (var i = 0; i < keys.length; i++) {\n    object[keys[i]] = vals[i]\n  }\n  return JSON.stringify(object)\n$$ LANGUAGE plv8 IMMUTABLE STRICT;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Operation Timeouts in Gra*fast* (JavaScript)\nDESCRIPTION: Demonstrates setting up planning and execution timeouts for GraphQL queries using Gra*fast*. The `preset` object is configured with `grafast.timeouts.planning` and `grafast.timeouts.execution` fields, specifying the maximum time allowed for planning and execution in milliseconds. This configuration helps prevent resource overuse by rejecting complex or slow operations if they exceed their allotted timeout values. Make sure to provide the `preset` as the second argument to `grafast()` or `execute()`, or in your Gra*fast* server's configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/production-considerations.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst preset = {\n  grafast: {\n    timeouts: {\n      /** Planning timeout in ms */\n      planning: 500,\n\n      /** Execution timeout in ms */\n      execution: 30_000,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile Security with Role and JWT Claims in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to initialize a PostGraphile schema with custom role and JWT claim settings, perform transactional GraphQL queries with per-transaction credentials, and correctly manage PostgreSQL client pooling. It leverages the 'pg' PostgreSQL client and PostGraphile's 'createPostGraphileSchema' function. Required dependencies are 'pg', 'postgraphile', and environment variables for database and JWT configuration. The 'runQuery' function dynamically sets the role and user_id claim locally for each transaction, executes a GraphQL operation, then cleans up the connection and transaction. Expected inputs are a GraphQL query and variables; the output is the query result. Proper error handling and resource release are demonstrated. The approach assumes superuser or suitable privileges for session configuration, and security depends on proper JWT secret management.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build-pg_versioned_docs/version-4/security.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst { createPostGraphileSchema } = require(\"postgraphile\");\nconst pg = require(\"pg\");\n\nconst pgPool = new pg.Pool(process.env.DATABASE_URL);\n\nasync function runQuery(query, variables) {\n  const schema = await createPostGraphileSchema(\n    process.env.DATABASE_URL,\n    [\"users_schema\", \"posts_schema\"],\n    {\n      dynamicJson: true,\n      jwtSecret: process.env.JWT_SECRET,\n      jwtPgTypeIdentifier: \"users_schema.jwt_type\",\n    },\n  );\n\n  // Fetch a postgres client from the pool\n  const pgClient = await pgPool.connect();\n\n  // Start a transaction so we can apply settings local to the transaction\n  /* highlight-next-line */\n  await pgClient.query(\"begin\");\n\n  try {\n    // The following statement is equivalent to (but faster than):\n    //    await pgClient.query(\"set local role to 'postgraphile_user'\");\n    //    await pgClient.query(\"set local jwt.claims.user_id to '27'\");\n    await pgClient.query(`select\n      /* highlight-start */\n      set_config('role', 'postgraphile_user', true),\n      set_config('jwt.claims.user_id', '27', true)\n      /* highlight-end */\n    `);\n    return await graphql(\n      schema,\n      query,\n      null,\n      /* highlight-start */\n      /* CONTEXT > */ {\n        pgClient: pgClient,\n      } /* < CONTEXT */,\n      /* highlight-end */\n      variables,\n    );\n  } finally {\n    // commit the transaction (or rollback if there was an error) to clear the local settings\n    /* highlight-next-line */\n    await pgClient.query(\"commit\");\n\n    // Release the pgClient back to the pool.\n    await pgClient.release();\n  }\n}\n\nrunQuery(\n  \"query MyQuery { allPosts { nodes { id, title, author: userByAuthorId { username } } } }\",\n)\n  .then((result) => {\n    console.dir(result);\n    pgPool.release();\n  })\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  });\n```\n\n----------------------------------------\n\nTITLE: Adding Documentation with SQL COMMENT Command\nDESCRIPTION: Shows the SQL `COMMENT` command, which is used to add documentation (comments) to database objects like tables, views, columns, and constraints. These comments can often be automatically picked up by PostGraphile/Crystal to populate GraphQL schema descriptions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT\n```\n\n----------------------------------------\n\nTITLE: Querying with Sorting in Graphile GraphQL API - GraphQL\nDESCRIPTION: The GraphQL snippet illustrates querying functions and entities affected by the @sortable smart comment, demonstrating how the orderBy argument can be used for sorting results by specified fields. This example covers two scenarios: functions returning sets of table rows (invoked with orderBy) and scalar-returning computed columns usable in table sort criteria. Dependencies are a Graphile-generated GraphQL API with applicable smart comments and user-facing fields as per function outputs. Inputs are GraphQL query documents; outputs are sorted result sets.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_28\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(orderBy: [ID_ASC]) { ... }\n  user(nodeId: ...) {\n    foo(orderBy: [ID_ASC]) { ... }\n  }\n\n  # If the function return a scalar\n  allUsers(orderBy: [FOO_ASC]) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Posts with Nested User and Comment Details using Fragments in GraphQL\nDESCRIPTION: An example GraphQL query demonstrating how PostGraphile, using graphile-build's look-ahead feature, compiles a complex, nested query involving posts, authors, comments, and user details (via fragments) into a single efficient SQL statement. This avoids the N+1 problem common in GraphQL APIs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/performance.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\n{\n  allPosts {\n    edges {\n      node {\n        id\n        title\n        author: userByAuthorId {\n          ...UserDetails\n        }\n        comments {\n          text\n          author: userByAuthorId {\n            ...UserDetails\n            recentComments {\n              date\n              post: postByPostId {\n                title\n                author {\n                  ...UserDetails\n                }\n              }\n              text\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfragment UserDetails on User {\n  id\n  username\n  bio: bioByUserId {\n    preamble\n    location\n    description\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Typing in TypeScript (json)\nDESCRIPTION: This tsconfig.json fragment mandates strict mode and noImplicitAny for maximum type safety in plugins migrated to PostGraphile V5. This eliminates loosely typed code and increases code reliability. Place these options in your compilerOptions block. Prerequisite: typescript 4.x or above.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"compilerOptions\\\": {\\n    // ...\\n    \\\"strict\\\": true,\\n    \\\"noImplicitAny\\\": true\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom Subscriptions in an Express App with PostGraphile Library (JavaScript)\nDESCRIPTION: This JavaScript code snippet shows how to integrate PostGraphile as middleware within an Express application and enable custom GraphQL subscriptions. It uses `makePluginHook` to include the `PgPubsub` plugin, sets the `subscriptions: true` option to activate the WebSocket server, appends the custom `MySubscriptionPlugin` via `appendPlugins`, and optionally configures `websocketMiddlewares` for handling session or authentication logic within the WebSocket connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile, makePluginHook } = require(\"postgraphile\");\nconst MySubscriptionPlugin = require(\"./MySubscriptionPlugin\"); // our plugin defined in previous step\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\"); // remember to install through yarn/npm\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst postgraphileOptions = {\n  pluginHook, // add the plugin hook. This will make the @pgSubscription avaiable in our schema definitions\n  subscriptions: true, // start the websocket server\n  appendPlugins: [MySubscriptionPlugin], // Load our plugin\n  websocketMiddlewares: [\n    // Add whatever middleware you need here, note that they should only\n    // manipulate properties on req/res, they must not sent response data. e.g.:\n    //\n    //   require('express-session')(),\n    //   require('passport').initialize(),\n    //   require('passport').session(),\n  ],\n};\n\nconst app = express();\napp.use(postgraphile(databaseUrl, \"app_public\", postgraphileOptions));\napp.listen(parseInt(process.env.PORT, 10) || 3000);\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Namespaced Tables and Functions - SQL\nDESCRIPTION: Illustrates how to create tables and functions within a specific schema and reference them in SQL statements by prepending the schema name. Dependencies include the existence of the specified schema (e.g., 'app_public') in the PostgreSQL database. Key parameters are the object definitions and calls, which must use schema-qualified naming. This approach organizes the database for clearer access control and modularity; the output varies by command (DDL or query).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/namespaces.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.users ( ... );\ncreate function app_public.best_user() ...;\n\nselect * from app_public.users;\nselect * from app_public.best_user();\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafast Context Callback in Graphile with JavaScript\nDESCRIPTION: Demonstrates how to provide a custom asynchronous context function for the Grafast configuration in 'graphile.config.js'. This function can perform asynchronous lookups (e.g., fetching the current user), add helpers to retrieve HTTP headers, and expose privileged database pools. Dependencies include a Node.js HTTP server with attached request objects, Passport.js (or similar), and a database connection pool. The input is the HTTP request context, and the output is an object merged into the GraphQL context for use in resolvers. Key constraints: avoid naming conflicts with reserved context keys and do not expose low-level request/response objects directly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  grafast: {\n    async context(requestContext, args) {\n      const req = requestContext.node?.req;\n      // You can perform asynchronous actions here if you need to; for example\n      // looking up the current user in the database.\n\n      // Return here things that your resolvers need\n      return {\n        // Return the current user from Passport.js or similar\n        user: req.user,\n\n        // Add a helper to get a header\n        getHeader(name) {\n          return req?.get(name);\n        },\n\n        // Give access to the database-owner PostgreSQL pool, for example to\n        // perform privileged actions\n        rootPgPool,\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Deprecated: Specifying PostgreSQL Adaptor via String (JavaScript)\nDESCRIPTION: Illustrates the previous method of configuring the PostgreSQL adaptor by providing its module path as a string within a configuration object. This approach is deprecated as of version 5.0.0-beta.26 due to issues with bundlability caused by dynamic imports and should be replaced with direct importing.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nadaptor: \"@dataplan/pg/adaptors/pg\"\n```\n\n----------------------------------------\n\nTITLE: Defining makeProcessSchemaPlugin Signature - TypeScript\nDESCRIPTION: This snippet presents the TypeScript function signature for makeProcessSchemaPlugin. It is a higher-order function that takes a synchronous schema processing callback, which receives a GraphQLSchema and returns either the same or an alternative schema. The function returns a GraphileConfig.Plugin, enabling integration within the PostGraphile ecosystem. The 'process' argument allows for schema inspection, validation, export, or modification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-process-schema-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction makeProcessSchemaPlugin(\n  process: (schema: GraphQLSchema) => GraphQLSchema,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Calling a Newly Added Inflector (JavaScript)\nDESCRIPTION: This JavaScript line demonstrates using a custom inflector method ('enhanced') added via a plugin. Only the argument relevant to the inflector is passed by the calling code (e.g., 'avatarUrl'), and the inflector system injects other required context. The code assumes 'inflection' is available and the plugin is registered. Output will be the string 'avatarUrlEnhanced'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst text = inflection.enhanced(\\\"avatarUrl\\\");\n```\n\n----------------------------------------\n\nTITLE: Example Grafast Field Plan Resolver Function in TypeScript\nDESCRIPTION: Provides a basic example of a field plan resolver function in TypeScript. The function accepts a parent step (`$parent`) and field arguments (`args`), retrieves a related step ('friends'), applies a limit based on an argument, and returns the modified step. It highlights the convention of prefixing step variables with '$'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-resolvers.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction plan_resolver(\n  $parent: ExecutableStep,\n  args: FieldArgs,\n): ExecutableStep {\n  const $friends = $parent.getRelation(\"friends\");\n  $friends.limit(args.get(\"limit\"));\n  return $friends;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Worker Task for Graphile Worker - JavaScript\nDESCRIPTION: This JavaScript snippet defines the worker module for the 'hello' job type in Graphile Worker. The module exports an async function receiving a payload and helper utilities as parameters. The function extracts the 'name' from the payload and logs a customized greeting using the provided logger. It assumes the Graphile Worker framework is present and that this file is placed according to the Graphile Worker tasks discovery convention (e.g., tasks/hello.js). Input is a JSON payload; output is side-effect logging. Limitations: the actual processing logic is very simple, and error handling is not included.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/background-tasks.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// tasks/hello.js\nmodule.exports = async (payload, helpers) => {\n  const { name } = payload;\n  helpers.logger.info(`Hello, ${name}`);\n};\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with makeExtendSchemaPlugin using SDL\nDESCRIPTION: Example GraphQL Schema Definition Language (SDL) used with the 'makeExtendSchemaPlugin' factory to add a new field 'random' of type Int to the root Query type. This demonstrates adding new fields and types programmatically via plugins within the Graphile ecosystem.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nextend type Query { random: Int }\n```\n\n----------------------------------------\n\nTITLE: Executing a Crystal Plan with Dependency Handling (Pseudocode)\nDESCRIPTION: This pseudocode outlines the `ExecutePlan` algorithm. It takes an `aether`, `plan`, `crystalContext`, `crystalObjects`, and `visitedPlans` as input. The algorithm handles recursion detection, checks for previously computed results in `crystalContext`, recursively executes dependency plans if needed, calls the plan's specific `execute` function with dependency results, memoizes the results in `crystalContext`, and returns the computed results for the given `crystalObjects`. Dependencies include the plan's own `execute` method and the structure of `crystalContext` for memoization.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_44\n\nLANGUAGE: pseudocode\nCODE:\n```\nExecutePlan(aether, plan, crystalContext, crystalObjects, visitedPlans):\n\n- If {visitedPlans} is not provided, initialize it to an empty list.\n- If {visitedPlans} contains {plan} throw new recursion error.\n- Push {plan} into {visitedPlans}.\n- Let {pendingCrystalObjects} be an empty list.\n- Let {result} be a list with the same length as {crystalObjects}.\n- For each {crystalObject} with index {i} in {crystalObjects}:\n  - Let {previousResult} be the entry for key {crystalObject}.{id} for key {plan} in\n    {crystalContext}.{resultByIdByPlan}.\n  - If {previousResult} does exists:\n    - Set {previousResult} as the {i}th indexed value of {result}.\n  - Otherwise:\n    - Push {crystalObject} onto {pendingCrystalObjects}.\n- If {pendingCrystalObjects} is not empty:\n  - Let {dependencyValuesList} be an empty list.\n  - For each {dependencyPlan} in {plan}.{dependencies}:\n    - Let {dependencyResult} be {ExecutePlan(aether, dependencyPlan, crystalContext, pendingCrystalObjects,\n      visitedPlans)}.\n    - Push {dependencyResult} onto {dependencyValuesList}.\n  - Let {values} be an empty list.\n  - For each index {i} in {pendingCrystalObjects}:\n    - Let {entry} be an empty list.\n    - For each {dependencyValues} in {dependencyValuesList}:\n      - Let {dependencyValue} be the {i}th entry in {dependencyValues}.\n      - Push {dependencyValue} onto {entry}.\n    - Push {entry} onto {values}.\n  - Let {execute} be the internal function provided by {plan} for executing the plan.\n  - Let {meta} be the entry for {plan} within {crystalContext}.{metaByPlan}.\n  - Let {pendingResults} be the result of calling {execute}, providing {values} and {meta}. (Note: the `execute` method\n    on plans is responsible for memoizing results into {meta}.)\n  - Assert the length of {pendingResults} should match the length of {pendingCrystalObjects}.\n  - For each {pendingCrystalObject} with index {i} in {pendingCrystalObjects}:\n    - Let {pendingResult} be the {i}th value in {pendingResults}.\n    - Let {j} be the index of {pendingCrystalObject} within {crystalObjects}.\n    - Set the value for key {pendingCrystalObject}.{id} for key {plan} in {crystalContext}.{resultByIdByPlan} to\n      {pendingResult}.\n    - Set {pendingResult} as the {j}th value of {result}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Declaring OrderBy TypeScript Interfaces for Graphile Plugins - TypeScript\nDESCRIPTION: These TypeScript interface and type declarations define the options and signatures for specifying ascending/descending order logic on PostgreSQL tables through Graphile plugins. They describe how to represent order options, null sorting strategies, the mapping of values, and flexible identity handling (string, SQL, or callback). Used as strong typing foundation for plugin authors, this enables both compile-time safety and consistent API usage. There are no runtime dependencies, but the types reference Graphile and SQL concepts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface OrderByAscDescOptions {\n  unique?: boolean;\n  nulls?: NullsSortMethod;\n}\n\nexport type NullsSortMethod =\n  | \"first\"\n  | \"last\"\n  | \"first-iff-ascending\"\n  | \"last-iff-ascending\"\n  | undefined;\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Steps with list() in Graphile Crystal (TypeScript)\nDESCRIPTION: This snippet shows how to declare multiple step dependencies ($isAdmin, $stripeId), and then aggregate results using list() before passing them to loadOne for further asynchronous handling. The list([$isAdmin, $stripeId]) pattern lets you gather several values and supply them as tuples to a callback, supporting advanced batching logic. Dependencies: Graphile Crystal, list(), object(), and loadOne, with expected usage of $user.get and $customer.get step resolutions.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $isAdmin = $user.get(\"admin\");\nconst $stripeId = $customer.get(\"stripe_id\");\nconst $last4 = loadOne(list([$isAdmin, $stripeId]), getLast4FromStripeIfAdmin);\n```\n\n----------------------------------------\n\nTITLE: Building Hooked GraphQL Types with newWithHooks - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to construct a new GraphQL type using the build object's newWithHooks method. It allows you to attach custom hooks that process the specification and add scope information via the provided parameters. Required dependencies may include the Graphile Engine and GraphQL standard types. The inputs include the GraphQL type constructor, a specification object, and an optional scope; the output is an instance of the built type, post-hook execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/build-object.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst MyType = newWithHooks(type, spec, scope);\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Bundling Exported PostGraphile V5 Schema in JavaScript\nDESCRIPTION: This JavaScript code defines a Webpack configuration recommended for bundling a PostGraphile V5 schema exported using `graphile-export`. It sets the mode to production, defines the entry point (`exported-schema.mjs`) and output (`exported-schema.webpacked.js` as a commonjs module), targets Node.js, and uses `TerserPlugin` for minification while preserving class names. Dependencies include `webpack` and `terser-webpack-plugin`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/bundling-webpack.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst webpack = require(\"webpack\");\nconst TerserPlugin = require(\"terser-webpack-plugin\");\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: \"./exported-schema.mjs\",\n  output: {\n    path: path.resolve(__dirname),\n    filename: \"exported-schema.webpacked.js\",\n    library: {\n      type: \"commonjs\",\n    },\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": JSON.stringify(\"production\"),\n      \"process.env.GRAPHILE_ENV\": JSON.stringify(\"production\"),\n    }),\n  ],\n  target: \"node\", // use require() & use NodeJs CommonJS style\n  externalsPresets: {\n    node: true, // in order to ignore built-in modules like path, fs, etc.\n  },\n  performance: {\n    maxEntrypointSize: 2000000,\n    maxAssetSize: 2000000,\n  },\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_classnames: true,\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Granting Roles with PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates how to create roles for application superusers and authenticators, as well as a visitor role, and how to grant role permissions. It requires a PostgreSQL environment where these roles do not already exist. Passwords and superuser privileges are specified inline, and roles are granted to others for RBAC. Input is DDL commands and the output is a set of roles defined in the current database cluster.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/required-knowledge.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate role my_superuser with login password 'password here' superuser;\ncreate role app_authenticator with login password 'password here' noinherit;\ncreate role app_visitor;\ngrant app_visitor to app_authenticator;\n```\n\n----------------------------------------\n\nTITLE: Defining Smart Tags in JSON5 for PostGraphile - JSON5\nDESCRIPTION: This snippet shows a representative structure for a 'postgraphile.tags.json5' file. It specifies the JSON5 schema for declaring metadata and smart tags for classes (tables), attributes (columns), and other PostgreSQL entities. The tags may provide descriptions, control field exposure, and associate additional metadata, supporting overriding and merging with previous definitions. The main entities are 'class', 'attribute', constraints, and procedures within a 'config' block.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags-file.md#_snippet_0\n\nLANGUAGE: json5\nCODE:\n```\n{\\n  version: 1,\\n  config: {\\n    /*\\n     * There can be entries here for:\\n     *\\n     * - `class`: for tables, composite types, views and materialized views\\n     * - `attribute`: for columns/attributes (of any 'class' type)\\n     * - `constraint`: for table constraints\\n     * - `procedure`: for functions/procedures\\n     */\\n    class: {\\n      /*\\n       * The next level describes the named type. We've just used the table\\n       * name \\\"post\\\" but it could be \\\"my_schema.post\\\" if you have multiple\\n       * tables with the same name and you don't want this rule to apply to\\n       * all of them.\\n       */\\n      post: {\\n        /*\\n         * This will override the description sourced from the PostgreSQL COMMENT.\\n         */\\n        description: \\\"A post within our forum.\\\",\\n\\n        /*\\n         * Add tags specific to the 'post' table here. You can omit this if you\\n         * don't want to add any tags.\\n         */\\n        tags: {\\n          foreignKey: [\\n            \\\"(default_user_id) references user (id)|@fieldName defaultUser\\\",\\n            \\\"(organization_id) references organization (id)|@fieldName organization\\\",\\n          ],\\n        },\\n\\n        /*\\n         * We've added a shortcut to class-types so you can tag/describe\\n         * columns at the same time of the class.\\n         */\\n        attribute: {\\n          /*\\n           * Assuming `body` is one of the columns in the 'post' table.\\n           */\\n          body: {\\n            /*\\n             * Optional description, if provided overrides the PostgreSQL\\n             * `COMMENT ON COLUMN post.body`.\\n             */\\n            description: \\\"The body of the post\\\",\\n            tags: {\\n              /*\\n               * Here we indicate that the 'body' field will not be available\\n               * in the update mutation.\\n               */\\n              omit: \\\"update\\\",\\n            },\\n          },\\n        },\\n      },\\n    },\\n  },\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Foreign Keys with @foreignKey Smart Tag\nDESCRIPTION: Illustrates the `@foreignKey` smart tag used to define 'virtual constraints' on database views. This allows PostGraphile/Crystal to generate relationship fields in the GraphQL schema based on the view's intended relations, even though views don't have actual foreign key constraints.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n@foreignKey\n```\n\n----------------------------------------\n\nTITLE: Creating PostGraphile Handler With Preset - TypeScript\nDESCRIPTION: This short TypeScript snippet imports the postgraphile server handler and a preset configuration to construct an exportable instance. The preset is loaded from the local configuration file. It is typically used to initialize server listeners or connect PostGraphile to an Express app.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgraphile } from \\\"postgraphile\\\";\\nimport preset from \\\"./graphile.config.ts\\\";\\n\\nexport const pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Defining Insert, Update, and Delete Row Level Policies for Posts in Postgres SQL\nDESCRIPTION: This SQL snippet defines RLS policies that only allow users to insert, update, or delete forum_example.post rows where the author_id matches their JWT claim. The insert policy uses with check (evaluated after insert), while update and delete use using (evaluated before action). This enforces strict ownership of post records, and depends on RLS being enabled, the forum_example_person role, and JWT configuration that provides person_id.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_41\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy insert_post on forum_example.post for insert to forum_example_person\\n  with check (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\\n\\ncreate policy update_post on forum_example.post for update to forum_example_person\\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\\n\\ncreate policy delete_post on forum_example.post for delete to forum_example_person\\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Specifying Named Return Types for PostgreSQL Functions\nDESCRIPTION: Example SQL fragment showing the recommended syntax (`returns setof named_type`) for defining the return type of a PostgreSQL function that yields multiple rows, each conforming to a predefined composite type (`named_type`). This approach is favored over anonymous table definitions for better schema integration and maintainability within Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nreturns setof named_type\n```\n\n----------------------------------------\n\nTITLE: Debugging PostGraphile with Node.js Inspector (Bash/Shell)\nDESCRIPTION: These shell commands illustrate how to launch PostGraphile or a custom Node.js server application using the Node.js `--inspect` flag. This enables the Node.js debugging protocol, allowing connection via tools like Chrome DevTools (`chrome://inspect`) for advanced debugging tasks such as setting breakpoints, inspecting memory, and stepping through server-side code execution. Examples cover globally installed, locally installed PostGraphile, and custom server scripts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/debugging.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# For globally installed PostGraphile:\nnode --inspect `which postgraphile` -c postgres://...\n\n# or for locally installed PostGraphile:\nnode --inspect node_modules/.bin/postgraphile -c postgres://...\n\n# or, if you have your own Node.js app in `server.js`:\nnode --inspect server.js\n```\n```\n\n----------------------------------------\n\nTITLE: Renaming Relationship Fields using JSON5 Smart Tags File\nDESCRIPTION: Configures PostGraphile via `postgraphile.tags.json5` to customize the names of fields generated from the foreign key constraint `my_table.my_constraint`. The local field (forward relation) is named `author` using `@fieldName`, and the remote field (backward relation) is named `threads` using `@foreignFieldName`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_7\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    constraint: {\n      \"my_table.my_constraint\": {\n        tags: {\n          foreignFieldName: \"threads\",\n          fieldName: \"author\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Extending the Graphile Build Object in V5 (TypeScript)\nDESCRIPTION: Explains how to add custom properties to the `GraphileBuild.Build` object in V5. It requires extending the global `GraphileBuild.Build` interface via declaration merging for type safety and then providing the runtime logic within a `build` hook to actually add the property.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Ensure that the types are imported for TypeScript\nimport \"graphile-build\";\nimport \"graphile-config\";\n\n// Extend the global GraphileBuild.Build type to add our 'flibble' attribute:\ndeclare global {\n  namespace GraphileBuild {\n    interface Build {\n      flibble: bool;\n    }\n  }\n}\n\n// And here's the plugin that actually adds the attribute at runtime:\nexport const FlibblePlugin: GraphileConfig.Plugin = {\n  name: \"FlibblePlugin\",\n  version: \"0.0.0\",\n  schema: {\n    hooks: {\n      build(build) {\n        build.flibble = true;\n        return build;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Plugin for Related Data Condition using TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates creating a PostGraphile plugin for the `app_public.forums` table that adds a `containsPostsByUserId` condition. This condition filters forums to include only those where a specific user (identified by an integer ID) has made posts in the related `app_public.posts` table. The `applyPlan` function uses a SQL `EXISTS` subquery to check for the presence of related posts matching the forum ID and user ID. Dependencies include `postgraphile/utils` and `postgraphile/@dataplan/pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-condition-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { makeAddPgTableConditionPlugin } from \"postgraphile/utils\";\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\nexport default makeAddPgTableConditionPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  \"containsPostsByUserId\",\n  (build) => {\n    const { sql } = build;\n    return {\n      description:\n        \"Filters the list of forums to only those which \" +\n        \"contain posts written by the specified user.\",\n      type: build.graphql.GraphQLInt,\n      applyPlan(\n        $condition /* : PgConditionStep<PgSelectStep<any>> */,\n        value /* : FieldArgs */,\n      ) {\n        const sqlIdentifier = sql.identifier(Symbol(\"postsByUser\"));\n        $condition.where(sql`exists(\n          select 1\n          from app_public.posts as ${sqlIdentifier}\n          where ${sqlIdentifier}.forum_id = ${$condition.alias}.id\n          and ${sqlIdentifier}.user_id = ${$condition.placeholder(\n            value.get(),\n            TYPES.int,\n          )}\n        )`);\n      },\n    };\n  },\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving JWT Claims in SQL - SQL\nDESCRIPTION: This SQL command retrieves the current value of a specific JWT claim from the PostgreSQL session. 'current_setting' with the second parameter 'true' returns the setting if it exists or null if not, enhancing security by preventing errors on missing claims. Requires prior initialization of JWT claims via PostGraphile session setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_30\n\nLANGUAGE: sql\nCODE:\n```\nselect current_setting('jwt.claims.a', true);\n```\n\n----------------------------------------\n\nTITLE: Explicitly Defining a VOLATILE PostgreSQL Function\nDESCRIPTION: Shows the explicit syntax for defining a `VOLATILE` function using the `VOLATILE` keyword. This clarifies the function's nature, indicating it might modify data or have other side effects. Such functions might be exposed as mutations by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql VOLATILE;\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema with graphile-build (JavaScript)\nDESCRIPTION: Demonstrates how to use the buildSchema function along with defaultPlugins from the graphile-build module to asynchronously generate a GraphQL schema, and then print its SDL representation with printSchema. Requires the graphile-build and graphql/utilities modules. The main parameters are an array of plugins (defaultPlugins) and optionally an options object. The main expects to output the schema's SDL to the console; the buildSchema method returns a promise resolving to the schema object.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/graphile-build.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { buildSchema, defaultPlugins } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nasync function main() {\n  /* highlight-next-line */\n  const schema = await buildSchema(defaultPlugins);\n  console.log(printSchema(schema));\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Exporting the GraphQL Collection Connection Builder in TypeScript\nDESCRIPTION: This TypeScript function declaration exports a generic factory for constructing a ConnectionStep plan around a provided collection fetch step. It accepts a collection step, an optional item mapping function, and an optional cursor mapping function. The function returns a typed ConnectionStep with all necessary generics, and assumes dependencies on types such as Step, ConnectionCapableStep, and ConnectionStep. It is intended to be integrated into systems requiring GraphQL cursor-based pagination and expects the collection step to support the connection methods previously described.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/connection.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function connection<\n  TItemStep extends Step,\n  TCursorStep extends Step,\n  TStep extends ConnectionCapableStep<TItemStep, TCursorStep>,\n  TNodeStep extends Step = Step,\n>(\n  $collection: TStep,\n  itemPlan?: ($item: TItemStep) => TNodeStep,\n  cursorPlan?: ($item: TItemStep) => Step<string | null>,\n): ConnectionStep<TItemStep, TCursorStep, TStep, TNodeStep>;\n```\n\n----------------------------------------\n\nTITLE: Using `sideEffect` with Multiple Dependencies (Object) in TypeScript\nDESCRIPTION: Demonstrates passing multiple dependencies to `sideEffect` using an object. The object maps string keys (`login`, `username`, `password`) to their corresponding steps (`$login`, `$username`, `$password`). The callback function receives the resolved values of these steps as an object `{ login, username, password }`, allowing access by name, which are then used to invoke the `login` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nsideEffect(\n  // Object of dependencies\n  { login: $login, username: $username, password: $password },\n  // becomes an object in callback:\n  ({ login, username, password }) => login(username, password),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Live Queries in Library Usage (JavaScript)\nDESCRIPTION: JavaScript code snippet showing how to configure PostGraphile as library middleware (e.g., within an Express app) to enable live queries. It involves setting the `live` option to `true`, providing an `ownerConnectionString` (typically from environment variables) with elevated privileges for logical decoding, and adding the `@graphile/subscriptions-lds` plugin to the `appendPlugins` array.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\napp.use(\n  postgraphile(process.env.AUTH_DATABASE_URL, SCHEMA, {\n    // ...\n\n    // Enable live support in PostGraphile\n    live: true,\n    // We need elevated privileges for logical decoding\n    ownerConnectionString: process.env.ROOT_DATABASE_URL,\n    // Add this plugin\n    appendPlugins: [\n      //...\n      require(\"@graphile/subscriptions-lds\").default,\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: PostGraphile Server Startup Output - Plaintext\nDESCRIPTION: Displays the typical console output indicating that the PostGraphile server has started successfully and shows the URL where the GraphQL endpoint is accessible. Confirms correct server operation and port assignment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nServer listening on port 5678 at http://127.0.0.1:5678/graphql\n```\n\n----------------------------------------\n\nTITLE: Installing graphile-build and graphql via npm\nDESCRIPTION: Installs the `graphile-build` and `graphql` packages as project dependencies using the Node Package Manager (npm). Both packages are required, as `graphile-build` utilizes the locally installed `graphql` version.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/getting-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save graphile-build graphql\n```\n\n----------------------------------------\n\nTITLE: Dropping PostGraphile Watch Schema in SQL\nDESCRIPTION: This SQL command removes the `postgraphile_watch` schema and all its dependent objects from the PostgreSQL database. This schema is typically added by PostGraphile when the `watchPg` option is enabled to monitor database schema changes, and this command is used for manual cleanup if needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nDROP SCHEMA postgraphile_watch CASCADE;\n```\n\n----------------------------------------\n\nTITLE: Setting Default Value for InputObject Field Based on Criteria - TypeScript\nDESCRIPTION: Hooks into PostGraphile's field-building for input object types to automatically set default values on fields named 'name' for input rows (excluding patch fields), defaulting to 'Bobby Tables' unless overridden by a smart comment tag. Uses the builder.hook('GraphQLInputObjectType:fields:field') pattern, and requires PostGraphile for operation. This applies only for create/update input objects where the PostgreSQL column is named 'name', setting the field's type as nullable to allow the default. Intended for use as a plugin for schema customization in TypeScript/JavaScript PostGraphile setups.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\\n * This plugin sets a defaultValue on all input object fields that match the\\n * given criteria (specifically the 'create' input types, for columns named\\n * 'name')\\n */\\nmodule.exports = function SetInputObjectDefaultValue(builder) {\\n  builder.hook(\\n    \\\"GraphQLInputObjectType:fields:field\\\",\\n    (field, build, context) => {\\n      const {\\n        scope: {\\n          isPgRowType,\\n          isInputType,\\n          isPgPatch,\\n          pgFieldIntrospection: attr,\\n        },\\n      } = context;\\n      if (\\n        !isPgRowType ||\\n        !isInputType ||\\n        isPgPatch ||\\n        !attr ||\\n        attr.kind !== \\\"attribute\\\" ||\\n        attr.name !== \\\"name\\\"\\n      ) {\\n        return field;\\n      }\\n\\n      return {\\n        ...field,\\n        type: build.graphql.getNamedType(field.type), // Since it has a default, it can be nullable\\n        defaultValue:\\n          // attr.tags.defaultValue: enables overriding this with a\\n          // `@defaultValue Alice Smith` smart comment\\n          attr.tags.defaultValue || \\\"Bobby Tables\\\",\\n      };\\n    },\\n  );\\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing a PostGraphile Instance - JavaScript\nDESCRIPTION: This code snippet demonstrates how to import a project-level preset and initialize a PostGraphile instance using JavaScript. It requires the 'postgraphile' npm package and a valid configuration preset. The exported 'pgl' object can be used to further create and serve GraphQL endpoints. Inputs include the imported preset configuration; the output is a ready-to-use PostGraphile instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\nimport { postgraphile } from \"postgraphile\";\n\n// Our PostGraphile instance:\nexport const pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Creating a SQL Table with a Reserved Keyword Name\nDESCRIPTION: Demonstrates how to create a PostgreSQL table when the desired table name, such as `user`, is a reserved SQL keyword. The table name must be enclosed in double quotes to be treated as an identifier rather than a keyword.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table \"user\" ( ... );\n```\n\n----------------------------------------\n\nTITLE: Example JWT Claim Payload - JSON\nDESCRIPTION: This JSON object represents a sample JWT payload containing standard ('sub', 'role') and custom ('user_id') claims. This serves to illustrate the structure of incoming JWTs whose claims will be mapped to PostgreSQL session variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sub\": \"postgraphql\",\n  \"role\": \"user\",\n  \"user_id\": 2\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Private User Account Table using SQL CREATE TABLE\nDESCRIPTION: Creates a new table named `person_account` within the `forum_example_private` schema to store sensitive user information. It includes columns for `person_id` (a foreign key referencing `forum_example.person`, establishing a one-to-one relationship and cascading deletes), `email` (unique, non-null, and validated with a regex), and `password_hash` (non-null, intended to store securely hashed passwords). Comments are added to document the table and its columns. This separation enhances security and follows good database design principles.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_19\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example_private.person_account (\n  person_id        integer primary key references forum_example.person(id) on delete cascade,\n  email            text not null unique check (email ~* '^.+@.+\\..+$'),\n  password_hash    text not null\n);\n\ncomment on table forum_example_private.person_account is 'Private information about a personâ€™s account.';\ncomment on column forum_example_private.person_account.person_id is 'The id of the person associated with this account.';\ncomment on column forum_example_private.person_account.email is 'The email address of the person.';\ncomment on column forum_example_private.person_account.password_hash is 'An opaque hash of the personâ€™s password.';\n```\n\n----------------------------------------\n\nTITLE: Creating a Secure Account Storage Table - PostgreSQL - SQL\nDESCRIPTION: This code snippet creates the 'forum_example_private.person_account' table to securely store user emails and password hashes, enforcing uniqueness and email format via CHECK constraints. It also sets up a one-to-one relationship with 'forum_example.person' via a primary key/foreign key reference with CASCADE on delete. The table and its columns are annotated with comments for maintainability. Dependencies include the referenced 'forum_example.person' table, and an external password hashing system is expected before storing data. Email and password_hash columns are required, with password_hash to be securely generated before insertion.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_19\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table forum_example_private.person_account (\n  person_id        integer primary key references forum_example.person(id) on delete cascade,\n  email            text not null unique check (email ~* '^.+@.+\\..+$'),\n  password_hash    text not null\n);\n\ncomment on table forum_example_private.person_account is 'Private information about a personâ€™s account.';\ncomment on column forum_example_private.person_account.person_id is 'The id of the person associated with this account.';\ncomment on column forum_example_private.person_account.email is 'The email address of the person.';\ncomment on column forum_example_private.person_account.password_hash is 'An opaque hash of the personâ€™s password.';\n```\n\n----------------------------------------\n\nTITLE: Integrating Auth0 Middleware and PostGraphile in Express - JavaScript\nDESCRIPTION: This snippet creates an Express application that applies the 'checkJwt' middleware to the '/graphql' endpoint for authentication. The GraphQL endpoint is served using PostGraphile, which leverages the 'pgSettings' option to propagate JWT payload fields, such as 'scope', into PostgreSQL session settings. Environmental variables 'DATABASE_URL' and 'DB_SCHEMA' must be defined for database connection. Required dependencies: 'express', 'express-jwt', 'jwks-rsa', and 'postgraphile'. Ensure 'checkJwt' is set up according to Auth0 documentation and your environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst jwt = require(\"express-jwt\");\nconst jwksRsa = require(\"jwks-rsa\");\n\n// ...\n\nconst checkJwt = jwt({\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://YOUR_DOMAIN/.well-known/jwks.json`,\n  }),\n  audience: \"YOUR_API_IDENTIFIER\",\n  issuer: `https://YOUR_DOMAIN/`,\n  algorithms: [\"RS256\"],\n});\n\nconst app = express();\n\n// Apply checkJwt to our graphql endpoint\napp.use(\"/graphql\", checkJwt);\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, process.env.DB_SCHEMA, {\n    pgSettings: (req) => {\n      const settings = {};\n      if (req.auth) {\n        settings[\"user.permissions\"] = req.auth.scope;\n      }\n      return settings;\n    },\n    // any other PostGraphile options go here\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Serializing JWT Claims to Postgres Settings - SQL\nDESCRIPTION: These SQL commands show how PostGraphile sets local PostgreSQL configuration variables based on the decoded claims from a JWT. Each claim (a, b, c) is dispatched to a custom session parameter (e.g., jwt.claims.a), enabling their use in PostgreSQL security policies and logic. No additional dependencies are required, but the claims must correspond to valid JWT values and PostGraphile configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_29\n\nLANGUAGE: sql\nCODE:\n```\nset local jwt.claims.a to 1;\\nset local jwt.claims.b to 2;\\nset local jwt.claims.c to 3;\n```\n\n----------------------------------------\n\nTITLE: Creating Function Using Variant Type for GraphQL Mutation - PostgreSQL SQL\nDESCRIPTION: This snippet demonstrates creating a PostgreSQL table 'example' and a function 'new_example_with_auto_id' that generates a UUID instead of taking it from input, then returns the inserted row. A comment adds the '@arg0variant patch' tag, instructing PostGraphile to expose the first function argument as a 'patch' variant GraphQL input type (excluding 'id'). Requires PostgreSQL and PostGraphile configuration. Useful for mutations that generate IDs server-side, with the patch variant excluding autogenerated columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_12\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example_with_auto_id(input example) returns example as $$\n  insert into example (id, name) values (gen_random_uuid(), input.name) returning *;\n$$ language sql volatile;\n\ncomment on function new_example_with_auto_id(input example) is\n  E'@arg0variant patch';\n\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Server Plugin for Origin-Specific CORS (JavaScript)\nDESCRIPTION: This JavaScript function `makeAllowedOriginTweak` creates a PostGraphile server plugin. The plugin hooks into the `postgraphile:http:handler` lifecycle event to set specific `Access-Control-*` HTTP headers on the response, thereby restricting CORS access to the provided `origin`. It explicitly sets allowed methods and headers required for typical GraphQL communication, including authorization and PostGraphile-specific headers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_11\n\nLANGUAGE: js\nCODE:\n```\n/**\n * This server plugin injects CORS headers to allow requests only from a specific origin.\n * /\n\nfunction makeAllowedOriginTweak(origin) {\n  return {\n    [\"postgraphile:http:handler\"](req, { res }) {\n      res.setHeader(\"Access-Control-Allow-Origin\", origin);\n      res.setHeader(\"Access-Control-Allow-Methods\", \"HEAD, GET, POST\");\n      res.setHeader(\n        \"Access-Control-Allow-Headers\",\n        [\n          \"Origin\",\n          \"X-Requested-With\",\n          // Used by `express-graphql` to determine whether to expose the GraphiQL\n          // interface (`text/html`) or not.\n          \"Accept\",\n          // Used by PostGraphile for auth purposes.\n          \"Authorization\",\n          // Used by GraphQL Playground and other Apollo-enabled servers\n          \"X-Apollo-Tracing\",\n          // The `Content-*` headers are used when making requests with a body,\n          // like in a POST request.\n          \"Content-Type\",\n          \"Content-Length\",\n          // For our 'Explain' feature\n          \"X-PostGraphile-Explain\",\n        ].join(\", \"),\n      );\n      res.setHeader(\n        \"Access-Control-Expose-Headers\",\n        [\"X-GraphQL-Event-Stream\"].join(\", \"),\n      );\n      return req;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Custom Server Plugin Hook in JavaScript\nDESCRIPTION: Provides a basic example of writing a custom PostGraphile server plugin (`MyPlugin`). This plugin implements the `cli:greeting` hook to add a custom message to the messages displayed when PostGraphile starts via the CLI. It utilizes the `chalk` library passed in the context for colored output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst MyPlugin = {\n  [\"cli:greeting\"](messages, { chalk }) {\n    return [...messages, `Hello ${chalk.blue(\"world\")}!`];\n  },\n};\n\nmodule.exports = MyPlugin;\n// or, for ES6 modules:\n// export default MyPlugin;\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Specific Operations with @behavior Smart Tag\nDESCRIPTION: Shows the '@behavior -[behaviorName]' smart tag syntax, using '-update' as an example. Placed in SQL comments, this tag selectively disables a specific default behavior (e.g., 'update' mutation) for a database object in the GraphQL schema, while allowing other behaviors (e.g., 'read', 'create', 'delete').\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n@behavior -update\n```\n\n----------------------------------------\n\nTITLE: Running Locally Installed PostGraphile with `npx` in Bash\nDESCRIPTION: Runs the locally installed `postgraphile` command using `npx` (which resolves the binary from `node_modules/.bin`). It applies the `postgraphile/presets/amber` preset, enables explain mode (`-e` for development, not recommended for production), and connects to the specified PostgreSQL database (`-c postgres:///mydb`). Requires PostGraphile to be previously installed in the project.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-cli.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx postgraphile -P postgraphile/presets/amber -e -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Grouping Items Using groupBy in Graphile - TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the groupBy utility to organize a collection of post records by the \\\"author_id\\\" field. It requires the groupBy function and a list of posts ($posts) as dependencies. The mapper ($post => $post.get(\\\"author_id\\\")) extracts the grouping key from each post object. The step outputs a Map whose keys are author IDs and values are arrays of posts for each author. The implementation assumes each post includes an accessible \\\"author_id\\\" property, and groupBy is compatible with the Graphile step interface.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/groupBy.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $groupedByAuthorId = groupBy($posts, ($post) => $post.get(\"author_id\"));\n```\n\n----------------------------------------\n\nTITLE: Composing Express Middleware with PostGraphile - JavaScript\nDESCRIPTION: This snippet demonstrates how to compose custom middleware (e.g., for authentication) with PostGraphile in Express. An example 'authMiddleware' function is created, which can process or authorize requests before passing them to PostGraphile. Dependencies: Express.js and postgraphile. Key parameters include the Express request (req), response (res), and next callback. Ensures middleware stacking so that authentication applies before GraphQL handling. Input: incoming HTTP requests; Output: authorized (or rejected) requests routed to the GraphQL endpoint.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/index.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Example middleware, does nothing\nfunction authMiddleware(req, res, next) {\n  //...\n  next();\n}\n// Mount middleware on the GraphQL endpoint\napp.use(\"/graphql\", authMiddleware);\n// Mount PostGraphile after this middleware\napp.use(postgraphile(connectionString, schema, options));\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile from the Command Line (Bash)\nDESCRIPTION: Demonstrates how to start the PostGraphile server using its command-line interface. The command connects to a PostgreSQL database specified by the connection string `postgres://forum_example_postgraphile:xyz@localhost`. Replace `xyz` with the actual password.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://forum_example_postgraphile:xyz@localhost\n```\n\n----------------------------------------\n\nTITLE: Customizing Root Operation Type Names via inflection Scope (JavaScript)\nDESCRIPTION: This plugin modifies how root GraphQL types (Query, Mutation, Subscription) are named by implementing the 'inflection.replace.builtin' method. When one of these operation type names is encountered, it is prefixed with 'Root'; otherwise, the prior naming logic is deferred to. Requires use within the Graphile Build plugin system and depends on the 'inflection' scope.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst RootNamingPlugin = {\n  name: \\\"RootNamingPlugin\\\",\n  version: \\\"0.0.0\\\",\n  description: \\\"Prefixes 'Root' to the root operation types\\\",\n\n  inflection: {\n    replace: {\n      builtin(previous, options, text) {\n        if ([\\\"Query\\\", \\\"Mutation\\\", \\\"Subscription\\\"].includes(text)) {\n          return `Root${text}`;\n        } else {\n          return previous(text);\n        }\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Amber Preset in TypeScript\nDESCRIPTION: This snippet shows the TypeScript equivalent of a minimal PostGraphile configuration in a `graphile.config.ts` file. It includes necessary type imports (`graphile-config`, `postgraphile`) for enhanced type checking and autocompletion. It imports and extends the `PostGraphileAmberPreset`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=\"graphile.config.ts\"\nimport \"graphile-config\";\nimport \"postgraphile\";\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n};\n\nexport default preset;\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Resource Name Conflict Error - Error Output - Text\nDESCRIPTION: This code snippet provides a sample error output that occurs when two resources (e.g. a table and a function) in a PostGraphile schema are assigned the same name. The error details clarify the source of the conflict and suggest where to find further information. There are no dependencies; this is an output excerpt users may encounter in their terminal or logs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/errors/2rc.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nError: Attempted to add a second resource named 'foo':\\n  First represented a function accepting 0 parameters and returning SQL type '\"bool\"'.\\n  Second represents a table/view/etc called '\"public\".\"foo\"'.\\n  Details: https://err.red/p2rc\n```\n\n----------------------------------------\n\nTITLE: Defining a Sample JWT Payload - JSON\nDESCRIPTION: This JSON snippet demonstrates a simple JWT payload with three claims (a, b, c), each assigned an integer value. In a real application, such a payload would be cryptographically signed and encoded as a JWT, then used by PostGraphile for transaction configuration and user identification. There are no dependencies for this data structure, but downstream validation and serialization are handled by the JWT consumer.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_28\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"a\\\": 1,\\n  \\\"b\\\": 2,\\n  \\\"c\\\": 3\\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Virtual @foreignKey via SQL Comment - Single and Multiple Keys\nDESCRIPTION: This SQL snippet shows how to add one or more '@foreignKey' tags to a materialized view by commenting on the view. Multiple constraints are separated by newlines. PostGraphile parses these to simulate relationships when generating GraphQL schemas. Only affects metadata for GraphQL, not the actual database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_19\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)';\n\n-- or if you want multiple foreignKeys\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)\\n@foreignKey (key_3, key_4) references some_other_table (key_3, key_4)';\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Disallowed Direct Value Interpolation in `sql` Tagged Template Literal (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates an *invalid* use case of the `sql` tagged template literal. Attempting to interpolate a raw, non-sql expression value (`1`) directly into the SQL string is disallowed to prevent SQL injection vulnerabilities and will result in an error being thrown. Values must be passed via approved helper functions or methods.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nsql`select ${1}`;\n```\n\n----------------------------------------\n\nTITLE: Disabling Default CRUD Mutations in PostGraphile Configuration (JavaScript)\nDESCRIPTION: Demonstrates how to disable the automatic generation of `insert`, `update`, and `delete` mutations in PostGraphile by modifying the `defaultBehavior` setting within the `graphile.config.mjs` configuration file. This prevents PostGraphile from adding these mutations to the schema, useful when preferring custom-defined mutations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/crud-mutations.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  // ...\n  schema: {\n    defaultBehavior: \"-insert -update -delete\",\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Relation Field Names using PostGraphile Tags File (JSON5)\nDESCRIPTION: Configures smart tags for a database constraint named `my_table.my_constraint` in the `postgraphile.tags.json5` file. The `@foreignFieldName` tag sets the name of the backward relation field to `threads`, and the `@fieldName` tag sets the name of the forward relation field to `author` in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_7\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    constraint: {\n      \"my_table.my_constraint\": {\n        tags: {\n          foreignFieldName: \"threads\",\n          fieldName: \"author\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Transformed Usernames from a GraphQL Plan Resolver in TypeScript\nDESCRIPTION: This snippet shows how to define a GraphQL resolver for an Organization type field 'usernames' by using each to map over user steps without applyTransforms, noting that Grafast handles the necessary transforms automatically when resolving a list field. It illustrates correct resolver implementation for efficiency and correctness, eliminating the need for explicit transformation in most resolver returns. Requires graphql-tag for gql, and access to users data.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/applyTransforms.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst typeDefs = gql`\n  type Organization {\n    usernames: [String!]\n  }\n`;\nconst plans = {\n  Organization: {\n    usernames($org) {\n      const $users = users.find({ organization_id: $org.get(\"id\") });\n      // No need to transform here:\n      return each($users, ($user) => $user.get(\"username\"));\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Recommended Development Configuration for PostGraphile CLI - Bash\nDESCRIPTION: Starts PostGraphile in watch mode with recommended flags for development, including support for GraphQL subscriptions, enhanced GraphiQL interface, batch queries, and exporting the schema. It expects the $DATABASE_URL environment variable to be set and uses the 'app_public' schema. The command demonstrates optional development features like advanced error formatting, improved inflector, and hot-reloading.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --subscriptions \\\n  --watch \\\n  --dynamic-json \\\n  --no-setof-functions-contain-nulls \\\n  --no-ignore-rbac \\\n  --show-error-stack=json \\\n  --extended-errors hint,detail,errcode \\\n  --append-plugins @graphile-contrib/pg-simplify-inflector \\\n  --export-schema-graphql schema.graphql \\\n  --graphiql \"/\" \\\n  --enhance-graphiql \\\n  --allow-explain \\\n  --enable-query-batching \\\n  --legacy-relations omit \\\n  --connection $DATABASE_URL \\\n  --schema app_public\n```\n\n----------------------------------------\n\nTITLE: Viewing Available Configuration Options with Graphile CLI\nDESCRIPTION: This shell command utilizes the `graphile` CLI tool to inspect the current configuration file and display all available options that can be set within the preset. The available options depend on the presets and plugins included in the configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ngraphile config options\n```\n\n----------------------------------------\n\nTITLE: Replacing an Inflector Using PostGraphile Plugin System (TypeScript)\nDESCRIPTION: This TypeScript snippet declares a PostGraphile plugin that replaces the 'builtin' inflector so that when asked for 'Query', it returns 'RootQuery' instead. The plugin is registered by exporting a constant object implementing the 'GraphileConfig.Plugin' interface. Dependencies include 'graphile-config', 'graphile-build', and 'graphile-build-pg'. Required parameters are the previous inflector, the resolved configuration preset, and the inflector arguments (e.g., text). It expects calls like 'inflection.builtin(\"Query\")' to return 'RootQuery'. The snippet preserves type safety for TypeScript. There are no additional constraints but the plugin should be used with PostGraphile V5 or later.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\\n  // Unique name for your plugin:\\n  name: \\\"ReplaceInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    replace: {\\n      builtin(\\n        // The previous version of this inflector, the one you're replacing\\n        previous,\\n\\n        // The resolved configuration\\n        preset,\\n\\n        // Everything from the 3rd paramater onward are the arguments to this inflector\\n        text,\\n      ) {\\n        if (name === \\\"Query\\\") return \\\"RootQuery\\\";\\n        return previous(text);\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Forum Update Mutation Inputs - GraphQL - GraphQL\nDESCRIPTION: These GraphQL input types outline the structures for updating Forum entities using different identifying fields: node ID, slug, or integer ID. Each input expects a patch of type ForumPatch, and may include a clientMutationId for client-side mutation tracking. The types ensure that required identifiers (nodeId, slug, or id) are provided for proper entity location. Limitations include strict adherence to input field types and requirements.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"All input for the `updateForumByNodeId` mutation.\"\"\"\ninput UpdateForumByNodeIdInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  The globally unique `ID` which will identify a single `Forum` to be updated.\n  \"\"\"\n  nodeId: ID!\n\n  \"\"\"\n  An object where the defined keys will be set on the `Forum` being updated.\n  \"\"\"\n  patch: ForumPatch!\n}\n\n\"\"\"All input for the `updateForumBySlug` mutation.\"\"\"\ninput UpdateForumBySlugInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  An object where the defined keys will be set on the `Forum` being updated.\n  \"\"\"\n  patch: ForumPatch!\n\n  \"\"\"An URL-safe alias for the `Forum`.\"\"\"\n  slug: String!\n}\n\n\"\"\"All input for the `updateForum` mutation.\"\"\"\ninput UpdateForumInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  An object where the defined keys will be set on the `Forum` being updated.\n  \"\"\"\n  patch: ForumPatch!\n  id: Int!\n}\n```\n\n----------------------------------------\n\nTITLE: Parsed JSON After Tags Section Split by Double Newline - JSON\nDESCRIPTION: This snippet depicts the resulting JSON tags object after inputting a multi-line smart comment using the double-newline split convention. It shows that only the lines before the blank line are parsed as tags. Requires a parser implementing the PostGraphile rules. Output contains the tags only for entries preceding double newlines.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"name\\\": \\\"meta\\\",\\n  \\\"isImportant\\\": true,\\n  \\\"jsonField\\\": [\\\"date timestamp\\\", \\\"name text\\\"]\\n}\n```\n\n----------------------------------------\n\nTITLE: Installing a PostGraphile Plugin using Yarn\nDESCRIPTION: This Bash command demonstrates how to install a PostGraphile server plugin, specifically `@graphile/operation-hooks`, using the Yarn package manager. Running this command adds the specified package as a dependency to the current project.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn add @graphile/operation-hooks\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Table and Column Metadata with Accessor Functions in pg-introspection (JavaScript)\nDESCRIPTION: This snippet exemplifies how to use pg-introspection accessor functions to extract metadata for a given table and its columns. Assumes that 'introspection' has already been populated per the earlier snippet. Frequently used functions include getAttributes, getAttribute, and getDescription, which yield information on table fields and structure. Inputs are a loaded introspection object and table/column names; returned outputs are metadata and descriptions as JavaScript objects and strings.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-introspection/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myTable = introspection.classes.find((rel) => rel.relname === \"my_table\");\nconst myTableAttributes = myTable.getAttributes();\nconst myColumn = myTable.getAttribute({ name: \"my_column\" });\nconst myColumnDescription = myColumn.getDescription();\n```\n\n----------------------------------------\n\nTITLE: Migrating @pgQuery Logic from V4 Fragment to V5 SQL Select Plan\nDESCRIPTION: Shows how to replace a V4 `@pgQuery` directive, which used an embedded SQL fragment via `embed` to concatenate a name and suffix, with a V5 plan. The V5 plan uses `$user.select()` with a `pg-sql2` tagged template literal (`sql`) to construct and execute an equivalent SQL expression (`${$user.getClassStep().alias}.name || ' ' || ${$user.placeholder($suffix, TYPES.text)}`). This safely incorporates the GraphQL argument `$suffix` into the SQL using placeholders. Dependencies include `postgraphile/utils` and `pg-sql2` (via `build.pgSql`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n module.exports = makeExtendSchemaPlugin(build => {\n   const { pgSql: sql } = build;\n   return {\n     typeDefs: gql`\n       extend type User {\n-        nameWithSuffix(suffix: String!): String! @pgQuery(\n-          fragment: ${embed(\n-            (queryBuilder, args) =>\n-              sql.fragment`(${queryBuilder.getTableAlias()}.name || ' ' || ${sql.value(\n-                args.suffix\n-              )}::text)`\n-          )}\n-        )\n+        nameWithSuffix(suffix: String!): String!\n       }\n     `,\n+    plans: {\n+      User: {\n+        nameWithSuffix($user, { $suffix }) {\n+          return $user.select(\n+            sql`${$user.getClassStep().alias}.name || ' ' || ${$user.placeholder($suffix, TYPES.text)}`,\n+            TYPES.text,\n+          );\n+        }\n+      }\n+    }\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: Annotating a Constraint with Smart Comments - SQL\nDESCRIPTION: This example attaches custom smart tags to a table constraint using COMMENT ON CONSTRAINT, potentially changing the foreign field or explicit field name exposed by PostGraphile. Prerequisites include the existence of the constraint and relevant table. The syntax may apply multiple tags and a human-readable description.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint my_constraint on my_schema.my_table is\\n  E'@foreignFieldName foos\\\\n@fieldName bar\\\\nDocumentation here.';\n```\n\n----------------------------------------\n\nTITLE: Adding Smart Tags to Virtual Foreign Key Constraints - PostGraphile - JSON\nDESCRIPTION: Demonstrates configuring a virtual foreign key with an additional smart tag (@fieldName) for naming, using a JSON smart tag configuration. The snippet is used in PostGraphile's smart tag JSON file and links columns from one object to another table, while also overriding the field name in the GraphQL schema. The pipe character is used to append further @-prefixed options. Requires PostGraphile and correctly named classes and fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_35\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  my_materialized_view: {\n    tags: {\n      foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)|@fieldName field_1\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Schema Hook in Graphile V5 (TypeScript)\nDESCRIPTION: Shows the V5 declarative approach to registering a schema hook within a plugin. The hook logic for `GraphQLObjectType_fields` is defined as a method directly inside the `schema.hooks` object. This contrasts with the V4 procedural style.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst ExamplePlugin: GraphileConfig.Plugin = {\n  name: \"ExamplePlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        //...\n        return fields;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Forums by Creation Date (GraphQL)\nDESCRIPTION: Demonstrates a GraphQL query requesting a list of forums sorted by their creation date in descending order using the built-in CREATED_AT_DESC orderBy enum. This presumes that the schema supports the allForums field with an orderBy input and the Forum type exposes id and name attributes. Requires schema support and appropriate permissions. Returns a list of forum nodes ordered from newest to oldest.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsNewestToOldest {\n  allForums(orderBy: [CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Documenting Command-Line Options for PostGraphile (Markdown)\nDESCRIPTION: This Markdown snippet documents the extensive set of CLI options available for the PostGraphile GraphQL server. It lists each flag, its required or optional value, and provides inline explanations of purpose, usage, defaults, and caveats. No executable code is present, but the detail level makes it a practical CLI reference. Inputs are expected as command-line flags. Outputs are operational changes in the PostGraphile server, as explained in this documentation. Limitations include being static documentation, not actual implementation, and requiring readers to apply the options in practice.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n### CLI options\n\nThere are more CLI options available to customise the GraphQL server (these are\nfrom <tt>postgraphile@<span></span>4.12.3</tt>):\n\n- `-V`, `--version`  \n  output the version number\n- `--plugins <string>`  \n  a list of PostGraphile server plugins (not Graphile Engine schema plugins) to\n  load; if present, must be the _first_ option\n- `-c`, `--connection <string>`  \n  the PostgreSQL database name or connection string. If omitted, inferred from\n  environmental variables (see\n  https://www.postgresql.org/docs/current/static/libpq-envars.html). Examples:\n  'db', 'postgres:///db', 'postgres://user:password@domain:port/db?ssl=true'\n- `-C`, `--owner-connection <string>`  \n  as `--connection`, but for a privileged user (e.g. for setting up watch\n  fixtures, logical decoding, etc); defaults to the value from `--connection`\n- `-s`, `--schema <string>`  \n  a Postgres schema to be introspected. Use commas to define multiple schemas\n- `-S`, `--subscriptions`  \n  Enable GraphQL support for subscriptions (you still need a subscriptions\n  plugin currently)\n- `--websockets <string>`  \n  Choose which websocket transport libraries to use. Use commas to define\n  multiple. Defaults to 'v0,v1' if `--subscriptions` or `--live` were passed,\n  '[]' otherwise\n- `--websocket-operations <operations>`  \n  Toggle which GraphQL websocket transport operations are supported:\n  'subscriptions' or 'all'. Defaults to 'subscriptions'\n- `-L`, `--live`  \n  [EXPERIMENTAL] Enables live-query support via GraphQL subscriptions (sends\n  updated payload any time nested collections/records change). Implies\n  --subscriptions\n- `-w`, `--watch`  \n  automatically updates your GraphQL schema when your database schema changes\n  (NOTE: requires DB superuser to install `postgraphile_watch` schema)\n- `-n`, `--host <string>`  \n  the hostname to be used. Defaults to `localhost`\n- `-p`, `--port <number>`  \n  the port to be used. Defaults to 5000\n- `-m`, `--max-pool-size <number>`  \n  the maximum number of clients to keep in the Postgres pool. defaults to 10\n- `-r`, `--default-role <string>`  \n  the default Postgres role to use when a request is made. supercedes the role\n  used to connect to the database\n- `--retry-on-init-fail`  \n  if an error occurs building the initial schema, this flag will cause\n  PostGraphile to keep trying to build the schema with exponential backoff\n  rather than exiting\n- `-j`, `--dynamic-json`  \n  [RECOMMENDED] enable dynamic JSON in GraphQL inputs and outputs. PostGraphile\n  uses stringified JSON by default\n- `-N`, `--no-setof-functions-contain-nulls`  \n  [RECOMMENDED] if none of your `RETURNS SETOF compound_type` functions mix\n  NULLs with the results then you may enable this to reduce the nullables in the\n  GraphQL schema\n- `-a`, `--classic-ids`  \n  use classic global id field name. required to support Relay 1\n- `-M`, `--disable-default-mutations`  \n  disable default mutations, mutation will only be possible through Postgres\n  functions\n- `--simple-collections <omit|both|only>`  \n  \"omit\" (default) - relay connections only, \"only\" - simple collections only\n  (no Relay connections), \"both\" - both\n- `--no-ignore-rbac`  \n  [RECOMMENDED] set this to exclude fields, queries and mutations that are not\n  available to any possible user (determined from the user in connection string\n  and any role they can become); this will be enabled by default in v5\n- `--no-ignore-indexes`  \n  [RECOMMENDED] set this to exclude filters, orderBy, and relations that would\n  be expensive to access due to missing indexes\n- `--include-extension-resources`  \n  by default, tables and functions that come from extensions are excluded; use\n  this flag to include them (not recommended)\n- `--show-error-stack [json|string]`  \n  show JavaScript error stacks in the GraphQL result errors (recommended in\n  development)\n- `--extended-errors <string>`  \n  a comma separated list of extended Postgres error fields to display in the\n  GraphQL result. Recommended in development: 'hint,detail,errcode'. Default:\n  none\n- `--append-plugins <string>`  \n  a comma-separated list of plugins to append to the list of Graphile Engine\n  schema plugins\n- `--prepend-plugins <string>`  \n  a comma-separated list of plugins to prepend to the list of Graphile Engine\n  schema plugins\n- `--skip-plugins <string>`  \n  a comma-separated list of Graphile Engine schema plugins to skip\n- `--read-cache <path>`  \n  [experimental] reads cached values from local cache file to improve startup\n  time (you may want to do this in production)\n- `--write-cache <path>`  \n  [experimental] writes computed values to local cache file so startup can be\n  faster (do this during the build phase)\n- `--export-schema-json <path>`  \n  enables exporting the detected schema, in JSON format, to the given location.\n  The directories must exist already, if the file exists it will be overwritten.\n- `--export-schema-graphql <path>`  \n  enables exporting the detected schema, in GraphQL schema format, to the given\n  location. The directories must exist already, if the file exists it will be\n  overwritten.\n- `--sort-export`  \n  lexicographically (alphabetically) sort exported schema for more stable\n  diffing.\n- `-X`, `--no-server`  \n  [experimental] for when you just want to use --write-cache or\n  --export-schema-* and not actually run a server (e.g. CI)\n- `-q`, `--graphql <path>`  \n  the route to mount the GraphQL server on. defaults to `/graphql`\n- `-i`, `--graphiql <path>`  \n  the route to mount the GraphiQL interface on. defaults to `/graphiql`\n- `--enhance-graphiql`  \n  [DEVELOPMENT] opt in to additional GraphiQL functionality (this may change\n  over time - only intended for use in development; automatically enables with\n  `subscriptions` and `live`)\n- `-b`, `--disable-graphiql`  \n  disables the GraphiQL interface. overrides the GraphiQL route option\n- `-o`, `--cors`  \n  enable generous CORS settings; disabled by default, if possible use a proxy\n  instead\n- `-l`, `--body-size-limit <string>`  \n  set the maximum size of the HTTP request body that can be parsed (default\n  100kB). The size can be given as a human-readable string, such as '200kB' or\n  '5MB' (case insensitive).\n- `--timeout <number>`  \n  set the timeout value in milliseconds for sockets\n- `--cluster-workers <count>`  \n  [experimental] spawn `<count>` workers to increase throughput\n- `--enable-query-batching`  \n  [experimental] enable the server to process multiple GraphQL queries in one\n  request\n- `--disable-query-log`  \n  disable logging queries to console (recommended in production)\n- `--allow-explain`  \n  [EXPERIMENTAL] allows users to use the Explain button in GraphiQL to view the\n  plan for the SQL that is executed (DO NOT USE IN PRODUCTION)\n- `-e`, `--jwt-secret <string>`  \n  the secret to be used when creating and verifying JWTs. if none is provided\n  auth will be disabled\n- `--jwt-verify-algorithms <string>`  \n  a comma separated list of the names of the allowed jwt token algorithms\n- `-A`, `--jwt-verify-audience <string>`  \n  a comma separated list of JWT audiences that will be accepted; defaults to\n  'postgraphile'. To disable audience verification, set to ''.\n- `--jwt-verify-clock-tolerance <number>`  \n  number of seconds to tolerate when checking the nbf and exp claims, to deal\n  with small clock differences among different servers\n- `--jwt-verify-id <string>`  \n  the name of the allowed jwt token id\n- `--jwt-verify-ignore-expiration`  \n  if `true` do not validate the expiration of the token defaults to `false`\n- `--jwt-verify-ignore-not-before`  \n  if `true` do not validate the notBefore of the token defaults to `false`\n- `--jwt-verify-issuer <string>`  \n  a comma separated list of the names of the allowed jwt token issuer\n- `--jwt-verify-subject <string>`  \n  the name of the allowed jwt token subject\n- `--jwt-role <string>`  \n  a comma seperated list of strings that create a path in the jwt from which to\n  extract the postgres role. if none is provided it will use the key `role` on\n  the root of the jwt.\n- `-t`, `--jwt-token-identifier <identifier>`  \n  the Postgres identifier for a composite type that will be used to create JWT\n  tokens\n- `--token <identifier>`  \n  [DEPRECATED] Use --jwt-token-identifier instead. This option will be removed\n  in v5.\n- `--secret <string>`  \n  [DEPRECATED] Use --jwt-secret instead. This option will be removed in v5.\n- `--jwt-audiences <string>`  \n  [DEPRECATED] Use --jwt-verify-audience instead. This option will be removed in\n  v5.\n- `--legacy-functions-only`  \n  [DEPRECATED] PostGraphile 4.1.0 introduced support for PostgreSQL functions\n  than declare parameters with IN/OUT/INOUT or declare RETURNS TABLE(...);\n  enable this flag to ignore these types of functions. This option will be\n  removed in v5.\n- `--legacy-relations <omit|deprecated|only>`  \n  some one-to-one relations were previously detected as one-to-many - should we\n  export 'only' the old relation shapes, both new and old but mark the old ones\n  as 'deprecated', or 'omit' the old relation shapes entirely\n- `--legacy-json-uuid`  \n  ONLY use this option if you require the v3 typenames 'Json' and 'Uuid' over\n  'JSON' and 'UUID'\n- `-h`, `--help`  \n  output usage information\n\nThe following options are not part of PostGraphile core, but are available from\nthe `@graphile/pg-pubsub` [subscriptions plugin](./subscriptions) (formerly the\npaid \"supporter\" plugin, but now fully free and open source - please consider\n[sponsoring us](https://graphile.org/sponsor/)!):\n\n- `-S`, `--simple-subscriptions` add simple subscription support\n- `--subscription-authorization-function [fn]` PG function to call to check user\n  is allowed to subscribe.\n\nThe following features and not part of PostGraphile core, but are available from\nthe Pro plugin - see [Go Pro!](/pricing) for more information.\n\n- `--read-only-connection <string>` <Pro /> <Spon /> âš¡ï¸[experimental] a PostgreSQL\n  connection string to use for read-only queries (i.e. not mutations)\n```\n\n----------------------------------------\n\nTITLE: Viewing Generated SQL via DEBUG Environment Variable (Bash/Shell)\nDESCRIPTION: These shell commands demonstrate how to set the `DEBUG` environment variable to enable detailed SQL query logging in PostGraphile. By setting `DEBUG` to `@dataplan/pg:PgExecutor:explain` before launching PostGraphile (using Bash, Windows Console, or PowerShell syntax), developers can see the exact SQL statements being executed, which helps in debugging database-related issues.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/debugging.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# Bash (Linux, macOS, etc)\nexport DEBUG=\"@dataplan/pg:PgExecutor:explain\"\npostgraphile -c postgres://...\n\n# Windows Console\nset DEBUG=@dataplan/pg:PgExecutor:explain & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:DEBUG='@dataplan/pg:PgExecutor:explain'; postgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Loading TagsFilePlugin with PostGraphile Configuration (JavaScript)\nDESCRIPTION: This JavaScript code snippet shows how to register the TagsFilePlugin in a PostGraphile configuration file (graphile.config.mjs) to automatically load and process a postgraphile.tags.json5 file from the current directory. The plugin allows extending\\/merging PostgreSQL entity tags and descriptions externally from schema files. The setup requires the 'postgraphile/utils' package, and the plugins array must include TagsFilePlugin. The tags file must be properly formatted and located at the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags-file.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { TagsFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [TagsFilePlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Bulk Inserting Join Table Records with JSON Arrays using PostGraphile in JavaScript\nDESCRIPTION: This snippet demonstrates how to perform bulk inserts into a join table ('persons_things') in PostgreSQL by accepting an array input from GraphQL, transforming it into a JSON array, and using Postgres's 'json_array_elements' function within a custom mutation resolver. It manages transaction boundaries explicitly and returns the resulting record IDs for further processing. Dependencies include PostGraphile, access to 'pgClient', and proper SQL schema for join tables. The mutation accepts person and thing IDs and outputs a payload containing the inserted join record references.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n...\n\ntypeDefs: gql`\n  input UpdatePersonsThingsInput {\n    personId: UUID!,\n    thingIds: [UUID!]!\n  }\n  type UpdatePersonThingsPayload {\n    personThings: [PersonThing!]\n  }\n  extend type Mutation {\n    updatePersonsThings(input: UpdatePersonsThingsInput!): UpdatePersonsThingsPayload\n  }\n`,\nresolvers: {\n  Mutation: {\n    updatePersonsThings: async (_query, { input: { personId, thingIds } }, { pgClient }, _resolveInfo) => {\n      await pgClient.query(\"SAVEPOINT graphql_mutation\");\n      try {\n        // Ensure proper formatting. This may not be necessary if not modifying the input\n        const elements = JSON.stringify(thingIds.map(thingId => ({ thingId, personId })));\n\n        // Bulk insert\n        const { rows } = await pgClient.query(`\n          INSERT INTO public.persons_things (person_id, thing_id)\n          SELECT\n            (el->>'personId')::uuid,\n            (el->>'thingId')::uuid\n          FROM json_array_elements($1::json) el\n          RETURNING id\n        `, [elements]);\n\n        // Return data for next layer to use\n        return { personThingIds: rows.map(({ id }) => id) };\n      } catch (e) {\n        await pgClient.query(\"ROLLBACK TO SAVEPOINT graphql_mutation\");\n        console.error(e);\n        throw e;\n      } finally {\n        await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n      }\n    },\n  },\n  UpdatePersonThingsPayload: {\n    personThings: ({ personThingIds }, _args, _context, { graphile: { selectGraphQLResultFromTable } }) => {\n      return selectGraphQLResultFromTable(\n        sql.fragment`public.persons_things`,\n        (tableAlias, queryBuilder) => {\n          queryBuilder.where(\n            sql.fragment`${tableAlias}.id = ANY (${sql.value(personThingIds)}::int[])`\n          );\n        }\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Graphile License Environment Variable in Bash\nDESCRIPTION: This Bash command demonstrates how to set the `GRAPHILE_LICENSE` environment variable on GNU/Linux and macOS systems. This variable is required to activate premium Graphile plugins. The `export` command makes the variable available to subsequent commands in the same shell session, such as the `postgraphile` CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# GNU/Linux and macOS bash:\nexport GRAPHILE_LICENSE=\"license_key_from_graphile_store\"\npostgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Queries with grafast in JavaScript\nDESCRIPTION: Illustrates how to execute a GraphQL query directly using grafast(), leveraging the previously obtained schema and resolved preset. The snippet takes as input the schema, resolvedPreset, a request context (for request details like headers), the GraphQL source string, and an optional variableValues object. Returns a result with possible data and errors.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { grafast } from \"postgraphile/grafast\";\n\nconst { data, errors } = await grafast({\n  schema,\n  resolvedPreset,\n  requestContext: {\n    // This is the \"request context\" - it is **NOT** the GraphQL context\n  },\n  source: /* GraphQL */ `\n    query MyQuery {\n      __typename\n    }\n  `,\n  variableValues: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Name and Result Field Name for Mutation Function via JSON5 - JSON5\nDESCRIPTION: This JSON5 snippet demonstrates how to alter both the name and the result field name for a custom mutation function using smart tags. Intended for a smart-tags JSON5 configuration. 'authenticate' will appear as the 'login' mutation returning a 'token' payload in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_9\n\nLANGUAGE: json5\nCODE:\n```\nprocedure: {\n  authenticate: {\n    tags: {\n      name: \"login\",\n      resultFieldName: \"token\",\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Field Removal Plugin Programmatically (PostGraphile, TypeScript)\nDESCRIPTION: This snippet defines a factory function, makeRemoveFieldPlugin, that returns a PostGraphile plugin removing a specific field from a specified GraphQL object type by hooking GraphQLObjectType_fields. The function takes the object and field name as arguments and mutates the fields object to delete the unwanted field. An example invocation (RemoveFooDotBarPlugin) shows how to remove the Foo.bar field. Designed for advanced schema customization; requires TypeScript, and PostGraphile's plugin/hooks system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending-raw.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction makeRemoveFieldPlugin(\n  objectName: string,\n  fieldName: string,\n): GraphileConfig.Plugin {\n  return {\n    name: `RemoveField_${objectName}_${fieldName}_Plugin`,\n    description: `Removes the ${objectName}.${fieldName} field from the GraphQL schema`,\n    version: \"0.0.0\",\n\n    schema: {\n      hooks: {\n        GraphQLObjectType_fields(fields, build, context) {\n          if (context.Self.name !== objectName) return fields;\n          delete fields[fieldName];\n          return fields;\n        },\n      },\n    },\n  };\n}\n\nexport const RemoveFooDotBarPlugin = makeRemoveFieldPlugin(\"Foo\", \"bar\");\n```\n\n----------------------------------------\n\nTITLE: Adding Root Query Field via Low-Level Plugin Hook (PostGraphile, TypeScript)\nDESCRIPTION: This snippet provides a PostGraphile plugin (AddHttpBinPlugin) that programmatically adds an httpBinHeaders field to the root Query using the low-level GraphQLObjectType_fields hook. It inspects context to restrict modification to the root query, retrieves the JSON type for the field, and fetches httpbin headers with node-fetch. Supports the jsonScalarAsString PostGraphile option for stringified JSON outputs. Exported as default for use in PostGraphile plugin lists. Written in TypeScript.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending-raw.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport fetch from \"node-fetch\";\n\nconst AddHttpBinPlugin = {\n  name: \"AddHttpBinPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(\n        fields, // Input object - the fields for this GraphQLObjectType\n        build, // Build object - handy utils\n        context, // Context object - used for filtering\n      ) {\n        const {\n          extend,\n          getTypeByName,\n          options: { jsonScalarAsString },\n        } = build;\n        const {\n          scope: { isRootQuery },\n        } = context;\n        if (!isRootQuery) {\n          // This isn't the object we want to modify:\n          // return the input object unmodified\n          return fields;\n        }\n\n        // We don't want to introduce a new JSON type as that will clash,\n        // so let's find the JSON type that other fields use:\n        const JSONType = getTypeByName(\"JSON\");\n\n        return extend(fields, {\n          httpBinHeaders: {\n            type: JSONType,\n            async resolve() {\n              const response = await fetch(\"https://httpbin.org/headers\");\n              if (jsonScalarAsString) {\n                // We've been told to provide JSON scalars in stringified format\n                return response.text();\n              } else {\n                // By default, we can just return a dynamic \"JSON\" scalar\n                return response.json();\n              }\n            },\n          },\n        });\n      },\n    },\n  },\n};\n\nexport default AddHttpBinPlugin;\n```\n\n----------------------------------------\n\nTITLE: Querying a Computed Column Field in GraphQL\nDESCRIPTION: Example GraphQL query demonstrating how to access the `fullName` computed column field on a `person` type. The query fetches a person by ID and includes the computed `fullName` field, generated by the `person_full_name` SQL function, in the selection set.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/computed-columns.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  personById(id: â€¦) {\n    # nodeId, id, ...\n\n    fullName # A computed column, but the client doesnâ€™t even know!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Graphile Configuration in TypeScript\nDESCRIPTION: Shows how to import the project's Graphile configuration preset from a `graphile.config.js` file using TypeScript. This preset object contains all the necessary configurations for PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\n```\n\n----------------------------------------\n\nTITLE: Migrating Plugin Definition from Hooks to Middleware in Graphile-config (diff)\nDESCRIPTION: This diff showcases the refactoring required when migrating from the deprecated `hooks.args` method to the new `middleware.prepareArgs` approach in the Graphile-config plugin system. The snippet indicates both TypeScript code changes and plugin API signature adjustments, including destructuring changes, enforcing explicit use of the `next()` function for middleware continuation. It is intended for plugin/package developers updating their plugin signatures to align with the newer, preferred middleware system, and requires understanding of the plugin object structure within the Graphile ecosystem.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/CHANGELOG.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n const plugin = {\n   grafast: {\n-    hooks: {\n+    middleware: {\n-      args({ args, ctx, resolvedPreset }) {\n+      prepareArgs(next, { args }) {\n+        const { requestContext: ctx, resolvedPreset } = args;\n         // ...\n+        return next();\n       }\n     }\n   }\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Forums List GraphQL Result (JSON)\nDESCRIPTION: This JSON object illustrates the result for the 'forumsAboutCats' connection query. The 'nodes' property provides an array of forum objects, each with a unique nodeId and detailed fields. This output is useful for validating Graphile's pluralized, filtered list queries backed by set-returning SQL functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forumsAboutCats\": {\n    \"nodes\": [\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDNd\",\n        \"id\": 3,\n        \"name\": \"Cat Life\",\n        \"slug\": \"cat-life\"\n      },\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDRd\",\n        \"id\": 4,\n        \"name\": \"Cat Help\",\n        \"slug\": \"cat-help\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting a Query to a Live Query Subscription in GraphQL\nDESCRIPTION: Shows how to make the previous GraphQL query \"live\" by changing the operation type from `query` to `subscription`. This allows the client to receive real-time updates when the underlying data for `allPeople` changes, facilitated by the PostGraphile live query mechanism.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending PostGraphile Query with makeExtendSchemaPlugin in TypeScript\nDESCRIPTION: Provides a basic example of using `makeExtendSchemaPlugin` to extend the GraphQL `Query` type. It defines a new field `meaningOfLife` using the `gql` helper and provides a corresponding plan resolver using `plans` that returns a constant value (42). It also includes a commented-out example demonstrating the equivalent functionality using traditional `resolvers`, although `plans` are recommended with Gra*fast*. Dependencies include `makeExtendSchemaPlugin`, `gql` from `postgraphile/utils`, and `constant` from `postgraphile/grafast`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { constant } from \"postgraphile/grafast\";\n\nexport const MyPlugin = makeExtendSchemaPlugin((build) => {\n  // Get any helpers we need from `build`\n  const { sql, inflection } = build;\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        meaningOfLife: Int\n      }\n    `,\n\n    plans: {\n      Query: {\n        meaningOfLife() {\n          return constant(42);\n        },\n      },\n    },\n\n    /*\n    // Though makeExtendSchemaPlugin and Grafast both support traditional\n    // resolvers, plan resolvers are preferred for a \"pure\" Grafast schema.\n    // Here's what the above would look like with traditional resolvers:\n    resolvers: {\n      Query: {\n        meaningOfLife() {\n          return 42;\n        },\n      },\n    },\n    */\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a JWT Claims Object (JSON, Authorization)\nDESCRIPTION: Demonstrates the structure of a basic JSON payload that will be encoded into a JWT for use with PostGraphile. The object contains user claims as key-value pairs. No code dependencies are required for this snippet, and the output is used as the basis for JWT creation and validation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_28\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"a\": 1,\n  \"b\": 2,\n  \"c\": 3\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Objects within a PostgreSQL Schema (SQL)\nDESCRIPTION: Provides examples of SQL commands for creating a table and a function within the `app_public` schema, and subsequently querying data from them. It illustrates the necessity of using schema-qualified names (e.g., `app_public.users`) to specify the target schema when creating or accessing objects within it.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/namespaces.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users ( ... );\nCREATE FUNCTION app_public.best_user() ...;\n\nSELECT * FROM app_public.users;\nSELECT * FROM app_public.best_user();\n```\n\n----------------------------------------\n\nTITLE: Configuring and Exporting Schema Extension Plugin with Graphile Utils (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import and use makeExtendSchemaPlugin and gql from the graphile-utils library to create and export a custom schema extension plugin. The exported plugin can customize or add GraphQL types and resolvers by specifying typeDefs and resolver logic, to be plugged into a Graphile/GraphQL schema build process. Dependencies: graphile-utils; Node.js environment. Key parameters: build (builder context provided by Graphile). Input: schema-building context. Output: plugin exporting schema extensions and resolvers. Limitations: typeDefs and resolvers must fit GraphQL/Graphile extensibility requirements.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst {\n  makeExtendSchemaPlugin,\n  gql,\n} = require('graphile-utils');\n\nconst MySchemaExtensionPlugin =\n  makeExtendSchemaPlugin(\n    build => ({\n      typeDefs: gql`...`,\n      resolvers: ...\n    })\n  );\n\nmodule.exports = MySchemaExtensionPlugin;\n```\n\n----------------------------------------\n\nTITLE: Using `withPgClient` for Custom SQL in a PostGraphile Plugin (TypeScript)\nDESCRIPTION: Demonstrates using the `withPgClient` step from `@dataplan/pg` within a PostGraphile plugin's plan resolver. It shows how to execute custom SQL (calling a hypothetical `get_organization_for_user_id` function) using a `PgClient` instance provided by the callback, integrating the result back into the Gra*fast* plan. Requires an executor and can take other steps as input (like `$userId`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context } from \"postgraphile/grafast\";\n// highlight-next-line\nimport { withPgClient } from \"postgraphile/@dataplan/pg\";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { channels } = build.input.pgRegistry.pgResources;\n  const executor = build.input.pgRegistry.pgExecutors.main;\n  // or: `const executor = channels.executor;`\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get(\"userId\");\n          // highlight-start\n          const $orgId = withPgClient(\n            executor,\n            $userId,\n            async (\n              // The PgClient instance, with all of the \"claims\" (if any) already set:\n              pgClient,\n              // This is the runtime data that the `$userId` step represented\n              userId,\n            ) => {\n              if (!userId) return null;\n\n              // Here we're using the standard `pgClient.query` function that\n              // all adaptors must provide, but if you're using an adaptor\n              // related to your ORM of choice, you could likely use its\n              // various methods to retrieve this value instead.\n              const result = await pgClient.query<{ id: number }>({\n                text: `select id from get_organization_for_user_id($1)`,\n                values: [userId],\n              });\n\n              // Return the 'id' value from the first (and only) row, if it exists:\n              return result.rows[0]?.id;\n            },\n          );\n          // highlight-end\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the Express/PostGraphile Server - Bash\nDESCRIPTION: This Bash command runs the project's 'npm start' script, which starts the server as defined in package.json. It depends on the start script having been set up accordingly. No input needed beyond project setup; output is the running server process.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_13\n\nLANGUAGE: Bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Singular Ref using @refVia in SQL\nDESCRIPTION: Shows how to create a polymorphic singular ref named 'author' on the 'log_entries' table, targeting a union type 'PersonOrOrganization'. Two `@refVia` tags define the routes: one maps the local 'person_id' to the 'person_id' in the 'people' table, and the other maps the local 'organization_id' to the 'organization_id' in the 'organizations' table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/refs.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:(person_id)->people(person_id)\n  @refVia author via:(organization_id)->organizations(organization_id)\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic GraphQL Types Using gql Helper - JavaScript\nDESCRIPTION: This snippet shows how to use the gql template literal helper from graphile-utils to dynamically define GraphQL schema types in JavaScript, including template string interpolation for names and reusable type definitions. The example illustrates embedding variables and other gql-tagged definitions within the schema. Required dependencies are graphile-utils and a runtime context for schema assembly. The output is an AST-ready GraphQL schema, with dynamic type names and composition, usable as input for makeExtendSchemaPlugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst nameOfType = \"MyType\"; // Or use the inflection system to generate a type\n\n// This tag interpolates the string `nameOfType` to allow dynamic naming of the\ntype.\nconst Type = gql`\n  type ${nameOfType} {\n    str: String\n    int: Int\n  }\n`;\n\n// This tag interpolates the entire definition in `Type` above.\nconst typeDefs = gql`\n  ${Type}\n\n  extend type Query {\n    fieldName: Type\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Merging Custom pgSettings in graphile.config.mjs (TypeScript)\nDESCRIPTION: This TypeScript snippet, intended for a `graphile.config.mjs` file, shows how to augment PostgreSQL session settings (`pgSettings`) using the `grafast.context` function. It merges any pre-existing settings found in `args.contextValue?.pgSettings` (potentially set by adapters or presets) with custom settings (like `statement_timeout`), ensuring that all necessary settings are applied for the database connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nexport default {\n  // ...\n\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-start\n        pgSettings: {\n          // If any pgSettings were already set, mix them in\n          ...args.contextValue?.pgSettings,\n          // Add our own settings\n          statement_timeout: \"10000\",\n        },\n        // highlight-end\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using jest-serializer-simple in a Jest Test\nDESCRIPTION: This JavaScript code demonstrates how to utilize the `jest-serializer-simple` within a Jest test case. To trigger the simplified serialization, the data (`data`) intended for the snapshot is wrapped within an object using the special key `__`. This results in a cleaner inline snapshot output without default Jest formatting.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-simple/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexpect({ __: data }).toMatchInlineSnapshot(`\n  {\n    forums: [\n      {\n        name: 'Cats',\n      },\n      {\n        name: 'Dogs',\n      },\n      {\n        name: 'Postgres',\n      },\n    ],\n  }\n`);\n```\n\n----------------------------------------\n\nTITLE: Writing a Jest Test Using Database Helpers in JavaScript\nDESCRIPTION: This JavaScript snippet shows an example Jest test case that utilizes the previously defined database helpers (`test_helpers.ts`). It uses `withRootDb` to wrap the test logic in a transaction, `createUsers` to set up a test user, `becomeUser` to set the appropriate database context, and then executes a database query (`delete from app_public.users`). Finally, it uses Jest's `expect` function to assert that the user was successfully deleted.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { becomeUser, createUsers, withRootDb } from \"../test_helpers\";\n\ntest(\"can delete self\", () =>\n  withRootDb(async (pgClient) => {\n    const [user] = await createUsers(pgClient, 1);\n\n    await becomeUser(pgClient, user);\n    const {\n      rows: [deletedUser],\n    } = await pgClient.query(\n      \"delete from app_public.users where id = $1 returning *\",\n      [user.id],\n    );\n    expect(deletedUser).toBeTruthy();\n  }));\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Foreign Key Constraints with @foreignKey Smart Tag\nDESCRIPTION: Illustrates the use of the '@foreignKey' smart tag, typically placed within SQL comments on a view definition. This tag defines 'virtual constraints', enabling Graphile to infer relationships between database views and other tables or views, thus generating corresponding relationship fields in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n@foreignKey\n```\n\n----------------------------------------\n\nTITLE: Renaming Schema Elements with @name Smart Tag\nDESCRIPTION: Demonstrates the '@name' smart tag, typically used in SQL comments associated with database objects. This tag allows developers to specify a custom name for the corresponding element (e.g., field, type) in the generated GraphQL schema, overriding the default name derived from the database object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n@name\n```\n\n----------------------------------------\n\nTITLE: Implementing an Inline Smart Tags Plugin using makeJSONPgSmartTagsPlugin - JavaScript\nDESCRIPTION: This code demonstrates how to implement an inline smart tags plugin without relying on the file system. Using 'makeJSONPgSmartTagsPlugin' from the 'graphile-utils' package, it exports a plugin object that directly embeds the smart tags configuration within the code. This method is suitable for bundlers/environments where file I/O is restricted (e.g., webpack).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags-file.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// MySmartTagsPlugin.js\\n\\nconst { makeJSONPgSmartTagsPlugin } = require(\\\"graphile-utils\\\");\\n\\nmodule.exports = makeJSONPgSmartTagsPlugin({\\n  version: 1,\\n  config: {\\n    class: {\\n      post: {\\n        tags: {\\n          omit: \\\"update\\\",\\n        },\\n      },\\n    },\\n  },\\n});\\n\n```\n\n----------------------------------------\n\nTITLE: Querying a Parameterized Computed Column Field in GraphQL\nDESCRIPTION: Example GraphQL query showing how to call the `greet` computed column field on a `user` type, passing a value for the `greeting` argument. This corresponds to the parameterized `my_schema.users_greet` SQL function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/computed-columns.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  userById(id: â€¦) {\n    greet(greeting: \"Greetings and salutations\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating PostGraphile Middleware with Express in JavaScript\nDESCRIPTION: Demonstrates setting up PostGraphile as middleware within an Express application. It requires 'express' and 'postgraphile', connects to a PostgreSQL database specified by `DATABASE_URL` or a default string, targets the 'public' schema, and enables features like `watchPg`, `graphiql`, and `enhanceGraphiql`. The server listens on `PORT` or default 3000.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\napp.use(\n  postgraphile(\n    process.env.DATABASE_URL || \"postgres://user:pass@host:5432/dbname\",\n    \"public\",\n    {\n      watchPg: true,\n      graphiql: true,\n      enhanceGraphiql: true,\n    },\n  ),\n);\n\napp.listen(process.env.PORT || 3000);\n```\n\n----------------------------------------\n\nTITLE: Querying Custom Functions in GraphQL\nDESCRIPTION: Shows how the previously defined PostgreSQL functions (`my_function` and `my_other_function`) would be queried using GraphQL. It illustrates querying a function without arguments, a function with named arguments, and accessing fields of a row returned by a function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-queries.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # For a function without arguments\n  myFunction\n\n  # For a function with arguments\n  myFunction(a: 1, b: 2)\n\n  # For a function that returns a row\n  myOtherFunction(a: 1, b: 2) {\n    id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enums Using an Enum Table Pattern (SQL)\nDESCRIPTION: Creates an `animal_type` table to store enum values (`type`) and optional descriptions. The `@enum` smart comment on the table signals PostGraphile to treat this table as a source for a GraphQL enum. The `pets` table references this enum table via a foreign key constraint, enforcing that `pets.type` must be one of the values in `animal_type.type`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/enums.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table animal_type (\n  type text primary key,\n  description text\n);\ncomment on table animal_type is E'@enum';\ninsert into animal_type (type, description) values\n  ('CAT', 'A feline animal'),\n  ('DOG', 'A canine animal'),\n  ('FISH', 'An aquatic animal');\n\ncreate table pets (\n  id serial primary key,\n  type text not null references animal_type,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Exportable Functions with Dependencies using Graphile Export\nDESCRIPTION: Introduces the `EXPORTABLE` wrapper function from the `graphile-export` library. It demonstrates how to define a function while explicitly passing its external dependencies (the variable `a`) as an array argument to `EXPORTABLE`, making the function's closure context trackable and exportable.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n> const { EXPORTABLE } = require(\"graphile-export\")\nundefined\n> const a = 7;\nundefined\n> const add = EXPORTABLE((a) => function add(b) { return a + b; }, [a]);\nundefined\n```\n\n----------------------------------------\n\nTITLE: Authenticating Users and Creating JWTs in PL/pgSQL - SQL/PLPGSQL\nDESCRIPTION: This PL/pgSQL function authenticates a user by email and password, returning a composite JWT token if successful or null otherwise. It checks the hashed password using PostgreSQL's 'crypt' from the 'pgcrypto' extension, sets the JWT's role, user ID, and expiration, and ensures the function runs with elevated privilege ('security definer'). Dependencies include the 'forum_example_private.person_account' table, 'pgcrypto', and the previously defined 'forum_example.jwt_token' type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_34\n\nLANGUAGE: plpgsql\nCODE:\n```\ncreate function forum_example.authenticate(\\n  email text,\\n  password text\\n) returns forum_example.jwt_token as $$\\ndeclare\\n  account forum_example_private.person_account;\\nbegin\\n  select a.* into account\\n  from forum_example_private.person_account as a\\n  where a.email = $1;\\n\\n  if account.password_hash = crypt(password, account.password_hash) then\\n    return ('forum_example_person', account.person_id, extract(epoch from (now() + interval '2 days')))::forum_example.jwt_token;\\n  else\\n    return null;\\n  end if;\\nend;\\n$$ language plpgsql strict security definer;\\n\\ncomment on function forum_example.authenticate(text, text) is 'Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 2 days.';\n```\n\n----------------------------------------\n\nTITLE: Defining Custom OrderBy Plugin for Average Value (V5, Graphile) - TypeScript\nDESCRIPTION: This code defines a V5-compatible implementation of the custom 'average pet id' OrderBy plugin for a 'users' table. The code demonstrates the updated signature (using a match object), Gra*fast* callback, and changes to accessing SQL and alias utilities. The order spec returns both a SQL fragment and a column codec, compatible with the V5 planning system. Dependencies are Graphile's V5 infrastructure (makeAddPgTableOrderByPlugin, orderByAscDesc, and appropriate build context). Inputs and customizations parallel the V4 version.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst OrderByAveragePetIdPlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"graphile_utils\", tableName: \"users\" },\n  (build) => {\n    const { sql } = build;\n    const sqlIdentifier = sql.identifier(Symbol(\"pet\"));\n\n    const customOrderBy = orderByAscDesc(\n      \"PET_ID_AVERAGE\", // this is a ridiculous and unrealistic column but it will serve for testing purposes\n      ($select) => {\n        const orderByFrag = sql`(\n            select avg(${sqlIdentifier}.id)\n            from graphile_utils.pets as ${sqlIdentifier}\n            where ${sqlIdentifier}.user_id = ${$select.alias}.id\n          )`;\n\n        return { fragment: orderByFrag, codec: TYPES.int };\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n\n    return customOrderBy;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Polymorphic Codecs for Relational Tables Â· TypeScript\nDESCRIPTION: Shows how to configure a Graphile resource codec to support relational table-based polymorphism. The snippet sets the 'polymorphic' property in the codec with 'mode: \"relational\"', specifying the type attribute and a mapping from type values to corresponding subtype relations. This approach ensures Graphile correctly resolves and loads the appropriate subtype via relations based on row type.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nitemResource.codec.polymorphic = {\n  mode: \"relational\",\n  typeAttributes: [\"type\"],\n  types: {\n    TOPIC: {\n      name: \"Topic\",\n      relationName: \"topic\",\n    },\n    POST: {\n      name: \"Post\",\n      relationName: \"post\",\n    },\n    DIVIDER: {\n      name: \"Divider\",\n      relationName: \"divider\",\n    },\n    CHECKLIST: {\n      name: \"Checklist\",\n      relationName: \"checklist\",\n    },\n    CHECKLIST_ITEM: {\n      name: \"ChecklistItem\",\n      relationName: \"checklistItem\",\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Testing User Self-Delete with Jest, pg, and Custom Database Helpers in JavaScript\nDESCRIPTION: This JavaScript code showcases a Jest test using helper utilities to create a test user, simulate login, and perform a deletion operation in a transactional context. It assumes auxiliary helpers for user creation and session simulation, and uses pg as the Postgres client. The test verifies the user can delete themselves and asserts successful deletion via the database. Inputs include the test helpers and a valid database; outputs are assertion results. The code is best run within a properly configured Jest environment connected to Postgres.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { becomeUser, createUsers, withRootDb } from \"../test_helpers\";\\n\\ntest(\"can delete self\", () =>\\n  withRootDb(async (pgClient) => {\\n    const [user] = await createUsers(pgClient, 1);\\n\\n    await becomeUser(pgClient, user);\\n    const {\\n      rows: [deletedUser],\\n    } = await pgClient.query(\\n      \"delete from app_public.users where id = $1 returning *\",\\n      [user.id],\\n    );\\n    expect(deletedUser).toBeTruthy();\\n  }));\n```\n\n----------------------------------------\n\nTITLE: Example JWT Payload - JSON\nDESCRIPTION: This JSON example shows a typical JWT claim set, including a subject ('sub'), user role ('role'), and custom claim ('user_id'). This payload would be decoded from a JWT and then serialized into PostgreSQL session variables as per the specification. No dependencies; purely for illustration of possible payload structure. The claims correspond directly to user identity and authorization context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sub\": \"postgraphql\",\n  \"role\": \"user\",\n  \"user_id\": 2\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scalar and Set-Returning Computed Column Functions in PostgreSQL\nDESCRIPTION: SQL script creating `users` and `friendships` tables within `my_schema`. It then defines two functions intended as computed columns for the `users` table: `users_name` returns a concatenated name string (scalar), and `users_friends` returns a set of related users based on friendships (exposed as a connection/list in GraphQL). Both functions are marked `STABLE`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/computed-columns.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table my_schema.users (\n  id serial not null primary key,\n  first_name varchar not null,\n  last_name varchar not null\n);\n\ncreate table my_schema.friendships (\n  user_id integer not null,\n  target_id integer not null,\n  primary key (user_id, target_id)\n);\n\n-- Creates `User.name` string field\ncreate function my_schema.users_name(u my_schema.users)\nreturns varchar as $$\n  select u.first_name || ' ' || u.last_name;\n$$ language sql stable;\n\n-- Creates `User.friends` connection\ncreate function my_schema.users_friends(u my_schema.users)\nreturns setof my_schema.users as $$\n  select users.*\n  from my_schema.users\n  inner join my_schema.friendships\n  on (friendships.target_id = users.id)\n  where friendships.user_id = u.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Creating Authentication Function in PostgreSQL - plpgsql\nDESCRIPTION: Defines a security definer function 'authenticate' in the 'my_public_schema' schema that accepts email and password, verifies credentials, and returns a 'jwt_token' type for successful authentication. Requires presence of 'person_account' in 'my_private_schema', row-level permissions, and the 'crypt' extension for password hashing. Returns a JWT token composite row or NULL if authentication fails, intended for integration with PostGraphile's JWT token generation system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_public_schema.authenticate(\n  email text,\n  password text\n) returns my_public_schema.jwt_token as $$\ndeclare\n  account my_private_schema.person_account;\nbegin\n  select a.* into account\n    from my_private_schema.person_account as a\n    where a.email = authenticate.email;\n\n  if account.password_hash = crypt(password, account.password_hash) then\n    return (\n      'person_role',\n      extract(epoch from now() + interval '7 days'),\n      account.person_id,\n      account.is_admin,\n      account.username\n    )::my_public_schema.jwt_token;\n  else\n    return null;\n  end if;\nend;\n$$ language plpgsql strict security definer;\n```\n\n----------------------------------------\n\nTITLE: Renaming a Table using Smart Comments in SQL\nDESCRIPTION: Creates a SQL table named `original_table` and then uses a `COMMENT` statement with the `@name` smart tag to specify that it should be exposed as `renamed_table` in the PostGraphile GraphQL schema. This demonstrates using SQL comments for schema customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table original_table (\n  col1 int\n);\n\ncomment on table original_table is E'@name renamed_table';\n```\n\n----------------------------------------\n\nTITLE: Filtering Arrays of Computed Fields in GraphQL (GraphQL)\nDESCRIPTION: This GraphQL query example illustrates using an array-valued field for filtering, enabled by the connection-filter plugin in Graphile. It finds all user entities that own at least one object where the field matches a value using the 'contains' array operator. Input is a filter argument; output is a connection or list of user nodes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_21\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # get all users who own an object with field == 'foo'\n  allUsers(filter: { object_fields: { contains: \"foo\" } }) {\n    nodes {\n      id\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Database Schema - SQL\nDESCRIPTION: This SQL initialization file sets up the schema for a simple forum application. It connects to the 'forum_example' database, creates 'user' and 'post' tables (with a foreign key relationship from 'post.author_id' to 'user.id'), and adds comments for documentation. No dependencies other than PostgreSQL. Inputs: none. Outputs: tables and constraints created. Limitations: expects to be run on initial database setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\\n\\n/*Create user table in public schema*/\\nCREATE TABLE public.user (\\n    id SERIAL PRIMARY KEY,\\n    username TEXT,\\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP\\n);\\n\\nCOMMENT ON TABLE public.user IS\\n'Forum users.';\\n\\n/*Create post table in public schema*/\\nCREATE TABLE public.post (\\n    id SERIAL PRIMARY KEY,\\n    title TEXT,\\n    body TEXT,\\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n    author_id INTEGER NOT NULL REFERENCES public.user(id)\\n);\\n\\nCOMMENT ON TABLE public.post IS\\n'Forum posts written by a user.';\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Debug Levels for PostGraphile - Bash\nDESCRIPTION: Shows how to enable multiple PostGraphile debug modules by configuring the DEBUG environment variable. Run these commands in Bash, Windows Console, or PowerShell to output relevant information including GraphQL queries, HTTP request status, and all SQL-related debug info. Modifying the debug facility allows targeted troubleshooting. Run PostGraphile or your server afterward in the same terminal.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Bash (Linux, macOS, etc)\nexport DEBUG=\\\"postgraphile:graphql,postgraphile:request,postgraphile:postgres*\\\"\npostgraphile -c postgres://...\n\n# Windows Console\nset DEBUG=postgraphile:graphql,postgraphile:request,postgraphile:postgres* & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:DEBUG = \\\"postgraphile:graphql,postgraphile:request,postgraphile:postgres*\\\"; postgraphile -c postgres://...\n\n```\n\n----------------------------------------\n\nTITLE: Querying One-to-Many Relations in PostGraphile (GraphQL)\nDESCRIPTION: This GraphQL snippet shows how to query a PostGraphile-generated API to retrieve all posts, including fields from related author records. It demonstrates the result of PostGraphile's relation handling, exposing joined data via inflected relation names. Input: None (example query). Output: Nested JSON structure with posts and their associated author information. Requires a corresponding schema and PostGraphile setup as above.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/relations.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPosts {\n    nodes {\n      headline\n      body\n\n      # this relation is automatically exposed\n      personByAuthorId {\n        id\n        name\n        about\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Node.js Server or PostGraphile with Chrome DevTools - Bash\nDESCRIPTION: Instructions for running a Node.js process (PostGraphile or custom server) in --inspect mode for debugging with Chrome DevTools. Use Bash or supported terminals. The commands are for global PostGraphile install, local PostGraphile install, or a custom Node.js server script. Attach Chrome at chrome://inspect. Useful for deep debugging such as stepping through source or breaking on exceptions during request lifecycle.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# For globally installed PostGraphile:\nnode --inspect `which postgraphile` -c postgres://...\n\n# or for locally installed PostGraphile:\nnode --inspect node_modules/.bin/postgraphile -c postgres://...\n\n# or, if you have your own Node.js app in `server.js`:\nnode --inspect server.js\n\n```\n\n----------------------------------------\n\nTITLE: Compiling a pg-sql2 Query for Execution in JavaScript\nDESCRIPTION: Demonstrates the final step of using `pg-sql2`: compiling a constructed `sql` query object using `sql.compile`. This function returns an object containing the parameterized SQL query string (`text`) and an array of corresponding values (`values`), ready to be passed to a database driver like `pg` for safe execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst query = sql`...`;\nconst { text, values } = sql.compile(query);\n\n// const { rows } = await pg.query(text, values);\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Test Helper Module (TypeScript)\nDESCRIPTION: This TypeScript code defines a test helper module (`test_helper.ts`) for integration testing a PostGraphile setup. It includes functions for setup (`setup`), teardown (`teardown`), sanitizing data for snapshot testing (`sanitize`), and running GraphQL queries (`runGraphQLQuery`) within a managed database transaction. The `runGraphQLQuery` function handles mocking requests, setting PostGraphile context (including pgSettings), executing the query, allowing custom assertions via a checker function, snapshotting results, and ensuring transaction rollback.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Request, Response } from \"express\";\nimport { ExecutionResult, graphql, GraphQLSchema } from \"graphql\";\nimport { Pool, PoolClient } from \"pg\";\nimport {\n  createPostGraphileSchema,\n  PostGraphileOptions,\n  withPostGraphileContext,\n} from \"postgraphile\";\n\nimport { getPostGraphileOptions } from \"../src/middleware/installPostGraphile\";\n\nconst MockReq = require(\"mock-req\");\n\nlet known: Record<string, { counter: number; values: Map<unknown, string> }> =\n  {};\nbeforeEach(() => {\n  known = {};\n});\n/*\n * This function replaces values that are expected to change with static\n * placeholders so that our snapshot testing doesn't throw an error\n * every time we run the tests because time has ticked on in it's inevitable\n * march toward the future.\n */\nexport function sanitize(json: any): any {\n  /* This allows us to maintain stable references whilst dealing with variable values */\n  function mask(value: unknown, type: string) {\n    if (!known[type]) {\n      known[type] = { counter: 0, values: new Map() };\n    }\n    const o = known[type];\n    if (!o.values.has(value)) {\n      o.values.set(value, `[${type}-${++o.counter}]`);\n    }\n    return o.values.get(value);\n  }\n\n  if (Array.isArray(json)) {\n    return json.map((val) => sanitize(val));\n  } else if (json && typeof json === \"object\") {\n    const result = { ...json };\n    for (const k in result) {\n      if (k === \"nodeId\" && typeof result[k] === \"string\") {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (\n        k === \"id\" ||\n        k === \"uuid\" ||\n        (k.endsWith(\"Id\") &&\n          (typeof json[k] === \"number\" || typeof json[k] === \"string\")) ||\n        (k.endsWith(\"Uuid\") && typeof k === \"string\")\n      ) {\n        result[k] = mask(result[k], \"id\");\n      } else if (\n        (k.endsWith(\"At\") || k === \"datetime\") &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"timestamp\");\n      } else if (\n        k.match(/^deleted[A-Za-z0-9]+Id$/) &&\n        typeof json[k] === \"string\"\n      ) {\n        result[k] = mask(result[k], \"nodeId\");\n      } else if (k === \"email\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"email\");\n      } else if (k === \"username\" && typeof json[k] === \"string\") {\n        result[k] = mask(result[k], \"username\");\n      } else {\n        result[k] = sanitize(json[k]);\n      }\n    }\n    return result;\n  } else {\n    return json;\n  }\n}\n\n// Contains the PostGraphile schema and rootPgPool\ninterface ICtx {\n  rootPgPool: Pool;\n  options: PostGraphileOptions<Request, Response>;\n  schema: GraphQLSchema;\n}\nlet ctx: ICtx | null = null;\n\nexport const setup = async () => {\n  const rootPgPool = new Pool({\n    connectionString: process.env.TEST_DATABASE_URL,\n  });\n\n  const options = getPostGraphileOptions({ rootPgPool });\n  const schema = await createPostGraphileSchema(\n    rootPgPool,\n    \"app_public\",\n    options,\n  );\n\n  // Store the context\n  ctx = {\n    rootPgPool,\n    options,\n    schema,\n  };\n};\n\nexport const teardown = async () => {\n  try {\n    if (!ctx) {\n      return null;\n    }\n    const { rootPgPool } = ctx;\n    ctx = null;\n    rootPgPool.end();\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\nexport const runGraphQLQuery = async function runGraphQLQuery(\n  query: string, // The GraphQL query string\n  variables: { [key: string]: any } | null, // The GraphQL variables\n  reqOptions: { [key: string]: any } | null, // Any additional items to set on `req` (e.g. `{user: {id: 17}}`)\n  checker: (\n    result: ExecutionResult,\n    context: { pgClient: PoolClient },\n  ) => void | ExecutionResult | Promise<void | ExecutionResult> = () => {}, // Place test assertions in this function\n) {\n  if (!ctx) throw new Error(\"No ctx!\");\n  const { schema, rootPgPool, options } = ctx;\n  const req = new MockReq({\n    url: options.graphqlRoute || \"/graphql\",\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    ...reqOptions,\n  });\n  const res: any = { req };\n  req.res = res;\n\n  const {\n    pgSettings: pgSettingsGenerator,\n    additionalGraphQLContextFromRequest,\n  } = options;\n  const pgSettings =\n    (typeof pgSettingsGenerator === \"function\"\n      ? await pgSettingsGenerator(req)\n      : pgSettingsGenerator) || {};\n\n  // Because we're connected as the database owner, we should manually switch to\n  // the authenticator role\n  if (!pgSettings.role) {\n    pgSettings.role = process.env.DATABASE_AUTHENTICATOR;\n  }\n\n  await withPostGraphileContext(\n    {\n      ...options,\n      pgPool: rootPgPool,\n      pgSettings,\n      pgForceTransaction: true,\n    },\n    async (context) => {\n      let checkResult;\n      const { pgClient } = context;\n      try {\n        // This runs our GraphQL query, passing the replacement client\n        const additionalContext = additionalGraphQLContextFromRequest\n          ? await additionalGraphQLContextFromRequest(req, res)\n          : null;\n        const result = await graphql(\n          schema,\n          query,\n          null,\n          {\n            ...context,\n            ...additionalContext,\n            __TESTING: true,\n          },\n          variables,\n        );\n        // Expand errors\n        if (result.errors) {\n          if (options.handleErrors) {\n            result.errors = options.handleErrors(result.errors);\n          } else {\n            // This does a similar transform that PostGraphile does to errors.\n            // It's not the same. Sorry.\n            result.errors = result.errors.map((rawErr) => {\n              const e = Object.create(rawErr);\n              Object.defineProperty(e, \"originalError\", {\n                value: rawErr.originalError,\n                enumerable: false,\n              });\n\n              if (e.originalError) {\n                Object.keys(e.originalError).forEach((k) => {\n                  try {\n                    e[k] = e.originalError[k];\n                  } catch (err) {\n                    // Meh.\n                  }\n                });\n              }\n              return e;\n            });\n          }\n        }\n\n        // This is were we call the `checker` so you can do your assertions.\n        // Also note that we pass the `replacementPgClient` so that you can\n        // query the data in the database from within the transaction before it\n        // gets rolled back.\n        checkResult = await checker(result, {\n          pgClient,\n        });\n\n        // You don't have to keep this, I just like knowing when things change!\n        expect(sanitize(result)).toMatchSnapshot();\n\n        return checkResult == null ? result : checkResult;\n      } finally {\n        // Rollback the transaction so no changes are written to the DB - this\n        // makes our tests fairly deterministic.\n        await pgClient.query(\"rollback\");\n      }\n    },\n  );\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Writing an Integration Test using Test Helpers (JavaScript)\nDESCRIPTION: This JavaScript snippet exemplifies how to write an integration test for a GraphQL query using the previously defined test helpers (`setup`, `teardown`, `runGraphQLQuery`). It follows a Jest-like pattern with `beforeAll` and `afterAll` hooks for setup and teardown. The test case calls `runGraphQLQuery`, providing the GraphQL query string, variables, mocked request properties (e.g., simulating a logged-in user for `pgSettings`), and a `checker` function for assertions on the response and database state.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js {9,24-25}\nconst { setup, teardown, runGraphQLQuery } = require(\"../test_helper\");\n\nbeforeAll(setup);\nafterAll(teardown);\n\ntest(\"GraphQL query nodeId\", async () => {\n  await runGraphQLQuery(\n    // GraphQL query goes here:\n    `{ __typename }`,\n\n    // GraphQL variables go here:\n    {},\n\n    // Any additional properties you want `req` to have (e.g. if you're using\n    // `pgSettings`) go here:\n    {\n      // Assuming you're using Passport.js / pgSettings, you could pretend\n      // to be logged in by setting `req.user` to `{id: 17}`:\n      user: { id: 17 },\n    },\n\n    // This function runs all your test assertions:\n    async (json, { pgClient }) => {\n      expect(json.errors).toBeFalsy();\n      expect(json.data.__typename).toEqual(\"Query\");\n\n      // If you need to, you can query the DB within the context of this\n      // function - e.g. to check that your mutation made the changes you'd\n      // expect.\n      const { rows } = await pgClient.query(\n        `SELECT * FROM app_public.users WHERE id = $1`,\n        [17],\n      );\n      if (rows.length !== 1) {\n        throw new Error(\"User not found!\");\n      }\n    },\n  );\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema Synchronously with Graphile Build V5 in JavaScript\nDESCRIPTION: This snippet demonstrates the V5 approach to building a GraphQL schema using `graphile-build`. It requires resolving a preset, building inflection, performing an asynchronous gather phase using `gather`, and then synchronously building the schema with `buildSchema`. Dependencies include `graphile-config`, `graphile-build`, and a configuration preset file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_17\n\nLANGUAGE: js\nCODE:\n```\nimport { resolvePreset } from \"graphile-config\";\nimport { buildInflection, gather, buildSchema } from \"graphile-build\";\nimport preset from \"./graphile.config.js\";\n\nconst resolvedPreset = resolvePreset(preset);\nconst shared = { inflection: buildInflection(resolvedPreset) };\nconst input = await gather(resolvedPreset, shared);\nconst schema = buildSchema(resolvedPreset, input, shared);\n```\n\n----------------------------------------\n\nTITLE: Omitting CRUD Operations via Graphile Smart Comments - SQL\nDESCRIPTION: These SQL snippets show how to use table-level comments with the @omit directive to disable specific CRUD operations (update, delete, and create) for a given table in the generated GraphQL schema via PostGraphile. The commands target a table named forum_example.book; after applying the comments, the affected operations become unavailable in the API. The only dependency is a PostgreSQL database and the use of Graphile/PostGraphile for GraphQL schema extraction. Inputs are standard SQL commands; outputs are schema changes which can be observed in GraphiQL. The feature is implemented via the Graphile/PostGraphile introspection process.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_25\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.book (\n  col1 int\n);\n\ncomment on table forum_example.book is E'@omit update,delete';\n```\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.book is E'@omit create,update,delete';\n```\n\n----------------------------------------\n\nTITLE: Initializing @dataplan/pg Adaptor with pg Module in TypeScript\nDESCRIPTION: This example illustrates setting up the `@dataplan/pg` adaptor specifically designed for the `pg` (node-postgres) module. It involves creating a `pg.Pool` instance, using `createWithPgClient` to generate the necessary `withPgClient` function for database interactions, and instantiating a `PgSubscriber` for potential real-time features using the same pool. These components are then packaged into a `graphqlContext` object, ready to be passed to the GraphQL execution engine (like `grafast`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/adaptors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as pg from \"pg\";\nimport { createWithPgClient, PgSubscriber } from \"@dataplan/pg/adaptors/pg\";\n\nconst pool = new pg.Pool({ connectionString: \"postgres:///pagila\" });\n\nconst withPgClient = createWithPgClient({ pool });\nconst pgSubscriber = new PgSubscriber(pool);\n\nconst graphqlContext = { withPgClient, pgSubscriber };\n\n// await grafast({ query: `...`, contextValue: graphqlContext });\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing 'containsPostsByUserId' Custom Condition with makeAddPgTableConditionPlugin in TypeScript\nDESCRIPTION: Provides an example of using `makeAddPgTableConditionPlugin` to create a `containsPostsByUserId` condition for the `app_public.forums` table. This condition filters forums to include only those where a specific user has posted, utilizing a SQL `EXISTS` subquery involving the `app_public.posts` table. It depends on `postgraphile/utils` and `postgraphile/@dataplan/pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-condition-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \"postgraphile/utils\";\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\nexport default makeAddPgTableConditionPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  \"containsPostsByUserId\",\n  (build) => {\n    const { sql } = build;\n    return {\n      description:\n        \"Filters the list of forums to only those which \" +\n        \"contain posts written by the specified user.\",\n      type: build.graphql.GraphQLInt,\n      applyPlan(\n        $condition /* : PgConditionStep<PgSelectStep<any>> */,\n        value /* : FieldArgs */,\n      ) {\n        const sqlIdentifier = sql.identifier(Symbol(\"postsByUser\"));\n        $condition.where(sql`exists(\n          select 1\n          from app_public.posts as ${sqlIdentifier}\n          where ${sqlIdentifier}.forum_id = ${$condition.alias}.id\n          and ${sqlIdentifier}.user_id = ${$condition.placeholder(\n            value.get(),\n            TYPES.int,\n          )}\n        )`);\n      },\n    };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Core and TypeScript Dependencies - Bash\nDESCRIPTION: This bash snippet installs required runtime and development dependencies for setting up an Express and PostGraphile project using TypeScript. It includes packages for server creation, Graphile presets, and TypeScript type definitions. No special configuration is needed prior to running the commands.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save express postgraphile@beta @graphile/simplify-inflection@beta\\nnpm install --save-dev typescript @tsconfig/node22 @types/express @types/node\n```\n\n----------------------------------------\n\nTITLE: GraphQL Example for getCurrentUser Query - GraphQL\nDESCRIPTION: This example demonstrates how to call the GraphQL field `getCurrentUser`, which presumably resolves to the PostgreSQL function defined earlier. It expects the session to be configured so that the current PostgreSQL user is set appropriately, often via the surrounding PostGraphile context. Input is a basic query with no variables, and output will be the username (e.g., 'visitor') depending on context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  getCurrentUser # returns visitor\n}\n```\n\n----------------------------------------\n\nTITLE: Example Empty JSONPgSmartTags Configuration (JSON5)\nDESCRIPTION: This JSON5 snippet illustrates the basic structure of a `JSONPgSmartTags` object, which is used as input for `makeJSONPgSmartTagsPlugin`. It includes the required `version` field (set to 1) and an empty `config` object containing keys for supported PostgreSQL entity kinds (`class`, `attribute`, `constraint`, `procedure`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_4\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {},\n    attribute: {},\n    constraint: {},\n    procedure: {},\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Plural Ref with Multiple Routes using @refVia in SQL\nDESCRIPTION: Illustrates defining a plural ref named 'relatedPeople' on the 'books' table that targets the 'Person' GraphQL type. It uses two `@refVia` tags to specify multiple paths: one through 'book_authors' then to 'people', and another through 'book_editors' then to 'people'. This allows relating books to people via both author and editor relationships.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/refs.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table books is $$\n  @ref relatedPeople to:Person\n  @refVia relatedPeople via:book_authors;people\n  @refVia relatedPeople via:book_editors;people\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Function Signature for orderByAscDesc Helper (TypeScript)\nDESCRIPTION: Displays the function signature for orderByAscDesc, which auto-generates paired ASC/DESC orderBy enum mappings for use in custom PostGraphile plugins. This helper takes a base enum name, a spec for the order (via column, expression, or callback), and optional sorting behaviors. It returns an orders object compatible with makeAddPgTableOrderByPlugin, reducing duplication in plugin logic. Dependencies include type definitions for SQL order specs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function orderByAscDesc(\n  baseName: string,\n  orderBySpec: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n\ntype OrderBySpecIdentity =\n  | string // Column name\n  | Omit<PgOrderSpec, \"direction\"> // Expression\n  | (($select: PgSelectStep) => Omit<PgOrderSpec, \"direction\">); // Callback, allows for joins/etc\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint with Graphile Export Plugin in JSONC\nDESCRIPTION: This snippet demonstrates how to configure ESLint by adding the graphile-export plugin and extending its recommended rule set using a JSON-compatible (with comments) syntax, as typically found in .eslintrc.js or .eslintrc.jsonc files. Key properties include the 'plugins' array, where 'graphile-export' should be listed, and the 'extends' array, where 'plugin:graphile-export/recommended' should be added. Inputs are ESLint configuration files, outputs are properly configured linting environments that enforce the export rules. Be aware that plugins and extends should already be installed as dependencies for this to work correctly.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/eslint-plugin-graphile-export/README.md#_snippet_0\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n  //...\n  \"plugins\": [\n    //...\n    \"graphile-export\",\n    //...\n  ],\n  \"extends\": [\n    // ...\n    \"plugin:graphile-export/recommended\",\n  ],\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile Server with Config File - Bash\nDESCRIPTION: Demonstrates starting the PostGraphile server using npx postgraphile, assuming the configuration is now stored in graphile.config.mjs. This allows for simplified CLI invocation with the configuration logic centralized in a file. Requires local install and valid graphile.config.mjs file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ npx postgraphile\n```\n\n----------------------------------------\n\nTITLE: Executing a GraphQL Query with Grafast in Schema-Only Mode (TypeScript)\nDESCRIPTION: Provides a complete example for executing a GraphQL query using grafast against a schema-only PostGraphile setup. It demonstrates how to pass the required schema, resolvedPreset, and requestContext. Inputs include a GraphQL source string and empty context; outputs are the result of the query execution. Requires grafast and postgraphile packages.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { grafast } from \"grafast\";\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n\nconst args = {\n  schema,\n  // highlight-next-line\n  resolvedPreset,\n  // highlight-next-line\n  requestContext: {},\n  source: /* GraphQL */ `\n    query MyQuery {\n      __typename\n    }\n  `,\n};\nconst result = await grafast(args);\nconsole.dir(result);\n```\n\n----------------------------------------\n\nTITLE: Replacing fieldArgs.get with fieldArgs.getRaw in Grafast\nDESCRIPTION: Explains the necessary replacement of the `fieldArgs.get(key)` method with `fieldArgs.getRaw(key)` in Grafast schemas. This change is due to the removal of `inputPlan`, which previously allowed plan resolvers on input fields. `fieldArgs.getRaw(key)` now provides the raw input value directly, as plan-time modifications on inputs are no longer supported.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/news/2025-03-24-grafast-0.1-beta.21.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfieldArgs.get(key)\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfieldArgs.getRaw(key)\n```\n\n----------------------------------------\n\nTITLE: Joining SQL Conditions with AND using sql.join() - JavaScript\nDESCRIPTION: This example shows how sql.join() can combine multiple SQL condition fragments using a custom delimiter, in this case ') and (', to construct a WHERE clause with grouped expressions. It depends on the sql-template-tag library for safely templating raw SQL. The inputs are an array of SQL condition fragments, and the output is a WHERE clause with each condition wrapped in parentheses and joined by 'AND'.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-join.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst arrayOfSqlConditions = [sql`a = 1`, sql`b = 2`, sql`c = 3`];\nsql`where (${sql.join(arrayOfSqlConditions, \") and (\")})`; // -> where (a = 1) and (b = 2) and (c = 3)\n```\n\n----------------------------------------\n\nTITLE: Querying Sanitized HTML Data with GraphQL\nDESCRIPTION: This GraphQL query demonstrates retrieving data from the 'a' table managed by the `SanitizeHTMLTypePlugin`. It selects the `id`, `t` (text), and `h` (html) fields for all nodes. The value returned for the `h` field will have been processed by the `sanitize` function (e.g., converted to uppercase) defined in the plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allAs {\n    nodes {\n      id\n      t\n      h\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Final Exportable Resolver Pattern Passing Dependencies (TypeScript)\nDESCRIPTION: Extends the previous example to explicitly enumerate the db dependency in both the factory argument and dependency array for EXPORTABLE. This matches the pattern required by Graphile Export for correct serialization. Inputs are the factory function, dependency, and array; output is the exportable resolver property.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfriends: EXPORTABLE((db) => async (user, args, context, resolveInfo) => {\n  return await db.friends.loadMany(user.id, context);\n}, [db]),\n```\n\n----------------------------------------\n\nTITLE: Adding a Parameterized Random Field to All Object Types (JavaScript)\nDESCRIPTION: This plugin globally extends every GraphQLObjectType by adding a 'random' field that returns a pseudo-random integer. The field accepts an optional 'sides' argument to control the range. It uses the 'extend' utility, reads options from the build object (allowing customization), and uses a 'plan' that computes the random value. No imports are required, but requires correct integration into the Graphile Build ecosystem.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// No imports required!\n\nconst MyRandomFieldPlugin = {\n  name: \"MyRandomFieldPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    GraphQLObjectType_fields(fields, build, context) {\n      const {\n        extend,\n        graphql: { GraphQLInt },\n        options: { myDefaultMin = 1, myDefaultMax = 100 },\n      } = build;\n      return extend(fields, {\n        random: {\n          type: GraphQLInt,\n          args: {\n            sides: {\n              type: GraphQLInt,\n            },\n          },\n          plan(_, fieldArgs) {\n            const $sides = fieldArgs.get(\"sides\");\n            return lambda(\n              $sides,\n              (sides) =>\n                Math.floor(\n                  Math.random() * ((sides ?? myDefaultMax) - myDefaultMin + 1),\n                ) + myDefaultMin,\n            );\n          },\n        },\n      });\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Member Name OrderBy Plugin (V5) in TypeScript\nDESCRIPTION: Presents the V5 version of the `OrderByMemberNamePlugin` using the `match` object syntax. The `ordersGenerator` callback leverages the `$organizationMemberships` step (representing the selection from `organization_memberships`). The `orderByAscDesc` helper's callback generates a SQL fragment to fetch the member's name from the `users` table using the step's alias and returns it along with the appropriate `codec` (`TYPES.text`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"organization_memberships\" },\n  ({ sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order spec callback:\n      ($organizationMemberships) => {\n        const fragment = sql.fragment`(\n          select ${sqlIdentifier}.name\n          from app_public.users as ${sqlIdentifier}\n          where ${sqlIdentifier}.id = ${$organizationMemberships.alias}.user_id\n          limit 1\n        )`;\n        return {\n          fragment,\n          codec: TYPES.text,\n        };\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via .postgraphilerc.js\nDESCRIPTION: Provides an example of enabling PostGraphile server plugins within a `.postgraphilerc.js` configuration file. Plugins are listed in an array assigned to the `plugins` key within the `options` object. This method allows for centralizing configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  options: {\n    plugins: [\n      \"@graphile/operation-hooks\",\n      \"@graphile/pg-pubsub\",\n      \"@graphile/pro\",\n    ],\n    connection: \"postgres:///my_db\",\n    schema: [\"app_public\"],\n    // ...\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Inefficient RLS Policy Using Per-Row Function Call in SQL\nDESCRIPTION: Demonstrates a poorly performing PostgreSQL RLS policy for the 'posts' table. It defines a function `current_user_is_member_of_organization` which checks if the current user is a member of a specific organization. This function is called for *each row* being checked by the RLS policy `select_my_organizations`, potentially leading to significant performance issues. This approach is explicitly discouraged due to its inefficiency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"BAD! DO NOT USE!\"\n-- Inefficient function, do not use!\ncreate function current_user_is_member_of_organization(org_id int)\nreturns bool as $$\n  select exists(\n    select 1\n    from organization_members om\n    where om.organization_id = current_user_is_member_of_organization.org_id\n    and om.user_id = current_user_id()\n  );\n$$ language sql stable;\n\n-- Poorly performing RLS policy that passes row data to a function, do not use!\ncreate policy select_my_organizations\n  for select on posts\n  using (current_user_is_member_of_organization(organization_id));\n```\n```\n\n----------------------------------------\n\nTITLE: Registering Numeric Types as Float in PostGraphile - TypeScript\nDESCRIPTION: Overrides the default type mapping for PostgreSQL NUMERIC/DECIMAL columns by registering the GraphQLFloat type instead of BigFloat throughout the schema to improve compatibility with older PostGraphile versions. Requires PostGraphile as a dependency and expects to be used as a plugin via module.exports. All NUMERIC/DECIMAL fields are mapped to floats, risking precision loss in exchange for compatibility. Intended for TypeScript/JavaScript environments and hooks the 'build' phase to register the override.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\\n * Use of this plugin is NOT recommended, please see\\n * PgSmallNumericToFloatPlugin for a more appropriate replacement if you need\\n * one.\\n *\\n * This plugin will have PostGraphile use `GraphQLFloat` instead of `BigFloat`\\n * for *all* DECIMAL / NUMERIC values, for making PostGraphile v4 slightly more\\n * backwards-compatible with v3.\\n *\\n * It's generally a bad idea to use floating point numbers to represent\\n * arbitrary precision numbers such as NUMERIC because loss of precision can\\n * occur.\\n */\\nmodule.exports = function PgNumericToFloatPlugin(builder) {\\n  builder.hook(\\\"build\\\", (build) => {\\n    // Register a type handler for NUMERIC / DECIMAL (oid = 1700), always\\n    // returning the GraphQLFloat type\\n    build.pgRegisterGqlTypeByTypeId(\\\"1700\\\", () => build.graphql.GraphQLFloat);\\n    return build;\\n  });\\n};\n```\n\n----------------------------------------\n\nTITLE: Importing makeJSONPgSmartTagsPlugin in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the import statement required to use the `makeJSONPgSmartTagsPlugin` function from the `postgraphile/utils` module. This function allows defining Smart Tags directly in code using a specific JSON-like object structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeJSONPgSmartTagsPlugin } from \"postgraphile/utils\";\n```\n\n----------------------------------------\n\nTITLE: Creating an Options Object using `object` in TypeScript (Graphile Crystal)\nDESCRIPTION: This TypeScript snippet demonstrates how to use the `object` function from Graphile Crystal. It constructs an object named `$fetchOptions`. The object's keys are `userId`, `first`, and `includeArchived`. The corresponding values are dynamically derived from the results of other steps (`$user.get(\\\"id\\\")`, `fieldArgs.get(\\\"first\\\")`) or set using a `constant` step.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/object.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $fetchOptions = object({\n  userId: $user.get(\"id\"),\n  first: fieldArgs.get(\"first\"),\n  includeArchived: constant(true),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Query for Movies Using GraphQL SDL\nDESCRIPTION: This snippet defines a GraphQL query using the Schema Definition Language to fetch the top movies with their IDs and titles. Intended for use with tools like graphql-code-generator to produce TypeScript types, this query expects a 'top' variable to limit returned results. It is stored in a .graphql file to be picked up during types/type generation or may be used as raw query in code.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_4\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetMovies($top: Int!) {\n  movies(first: $top) {\n    nodes {\n      id\n      title\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using Yarn\nDESCRIPTION: This command installs all necessary project dependencies defined in the `package.json` file using the Yarn package manager. It is the first step required to set up the development environment for the PostGraphile website.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Adding Not Null Constraint via Smart Comment - SQL\nDESCRIPTION: Shows how to set a virtual not-null constraint on a view column using a SQL comment and smart tag. The comment applies an E-prefixed string (for backslash escape support) with '@notNull' to 'my_view.my_column'. The effect is to expose this column as non-nullable in the GraphQL schema. This only affects PostGraphile, not database enforcement.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_14\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on column my_view.my_column is E'@notNull`;\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Trigger Function and Triggers for Automatic Timestamp Updates in SQL\nDESCRIPTION: Defines a PL/pgSQL function `forum_example_private.set_updated_at` that sets the `updated_at` column of the modified row (`new`) to the current timestamp. It then creates two triggers, `person_updated_at` and `post_updated_at`, which execute this function `BEFORE UPDATE` on each row of the `forum_example.person` and `forum_example.post` tables, respectively, ensuring the `updated_at` column reflects the time of the last update. The function is placed in a private schema (`forum_example_private`) for encapsulation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_18\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example_private.set_updated_at() returns trigger as $$\nbegin\n  new.updated_at := current_timestamp;\n  return new;\nend;\n$$ language plpgsql;\n\ncreate trigger person_updated_at before update\n  on forum_example.person\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n\ncreate trigger post_updated_at before update\n  on forum_example.post\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n```\n\n----------------------------------------\n\nTITLE: Documenting makeAddPgTableOrderByPlugin Function Signature â€“ TypeScript\nDESCRIPTION: Presents the TypeScript function signature for makeAddPgTableOrderByPlugin and the associated interface MakeAddPgTableOrderByPluginOrders. It specifies accepted parameters for the plugin generator (the table matcher, an orders generator callback, and an optional hint) and describes the expected return type and its structure. This is relevant for plugin authors needing to understand required arguments and returned types. No runtime dependencies; this is type/interface documentation for TypeScript/Pg plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeAddPgTableOrderByPlugin(\n  match: {\n    serviceName?: string;\n    schemaName: string;\n    tableName: string;\n  },\n  ordersGenerator: (\n    build: GraphileBuild.Build,\n  ) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): GraphileConfig.Plugin;\n\ninterface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    extensions: {\n      grafast: {\n        applyPlan($select: PgSelectStep): void;\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using the error Function in Graphile Crystal (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the usage of the `error` function from the Graphile Crystal library. It takes an Error object as input and returns a new function (`$error`) which, when invoked, will always throw the originally provided error. This pattern is noted as being similar to a `constant` function but for throwing errors.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/error.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $error = error(new Error(\"Error\"));\n```\n\n----------------------------------------\n\nTITLE: Executing Type-Safe GraphQL Query with `TypedDocumentNode` in TypeScript\nDESCRIPTION: Illustrates a type-safe GraphQL execution function `executeDocument` in TypeScript using `TypedDocumentNode` (typically generated by tools like GraphQL Code Generator). It follows the `hookArgs` pattern but accepts a typed document, validates it, prepares arguments, executes, and returns a type-safe result.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport type { DocumentNode, ExecutionResult } from \"postgraphile/graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { postgraphile } from \"postgraphile\";\nimport { execute, hookArgs } from \"postgraphile/grafast\";\nimport { validate } from \"postgraphile/graphql\";\nimport preset from \"./graphile.config.js\";\n\nconst pgl = postgraphile(preset);\n\nexport async function executeDocument<TData = any, TVariables = any>(\n  requestContext: Partial<Grafast.RequestContext>,\n  document: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n): Promise<ExecutionResult<TData, TVariables>> {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n\n  // Validate the GraphQL document against the schema:\n  const errors = validate(schema, document);\n  if (errors.length > 0) {\n    return { errors };\n  }\n\n  // Prepare the execution arguments:\n  const args = await hookArgs({\n    schema,\n    document,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n\n  // Execute the request using Grafast:\n  const result = await execute(args);\n\n  // Cast the result to the types implied by the TypedDocumentNode:\n  return result as ExecutionResult<TData, TVariables>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Simplify-Inflection Preset for PostGraphile - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to extend a PostGraphile configuration with the '@graphile/simplify-inflection' preset to generate shorter and more natural relation field names in the GraphQL schema. It requires installing the '@graphile/simplify-inflection' package. The configuration should be integrated into your graphile.config.mjs or equivalent project config file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/inflection.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { PgSimplifyInflectionPreset } from \"@graphile/simplify-inflection\";\n\nconst preset = {\n  extends: [\n    PgSimplifyInflectionPreset,\n    //...\n  ],\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming Entities and Procedures Using JSON5 Smart Tags - JSON5\nDESCRIPTION: This JSON5 snippet shows how to rename a table ('post') and a function ('search_posts') in the GraphQL schema using the 'name' smart tag. Used within a smart-tags JSON5 configuration file. Both 'class' and 'procedure' sections use smart tags to influence resulting field names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_6\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  post: {\n    tags: {\n      name: \"message\"\n    }\n  }\n},\nprocedure: {\n  search_posts: {\n    tags: {\n      name: \"returnPostsMatching\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Filtered Channels by OrganizationId (TypeScript)\nDESCRIPTION: This snippet demonstrates how to query the channels resource for all rows matching a particular organization_id. The argument is a key-value object where the key must match a column name and the value comes from a previously-resolved step. The output step represents multiple channel rows, suitable for list-type GraphQL fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $channels = channels.find({ organization_id: $organizationId });\n```\n\n----------------------------------------\n\nTITLE: Watching Schema Changes with SchemaBuilder in graphile-build (JavaScript)\nDESCRIPTION: Shows how to use getBuilder from graphile-build to instantiate a SchemaBuilder, then watch for schema changes using the watchSchema method. This pattern is suitable for applications that require live reloading or development mode features. Dependencies include graphile-build and (externally assumed) graphql/utilities. Core parameters are the defaultPlugins array and an options object (empty in this example). The onSchema callback logs the up-to-date schema to the console on change events. watchSchema is an async method that triggers the callback when schema changes are detected.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/graphile-build.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { getBuilder, defaultPlugins } = require(\"graphile-build\");\n\nasync function main() {\n  /* highlight-next-line */\n  const builder = await getBuilder(defaultPlugins, {});\n  function onSchema(schema) {\n    console.log(printSchema(schema));\n  }\n  /* highlight-next-line */\n  await builder.watchSchema(onSchema);\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple DEBUG Namespaces (Windows Console)\nDESCRIPTION: This Windows Console (cmd.exe) command sets the `DEBUG` environment variable to enable multiple debug namespaces (`graphile-build:warn,@dataplan/pg:*`) separated by commas. Running PostGraphile afterwards triggers logging for all specified namespaces.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_6\n\nLANGUAGE: batch\nCODE:\n```\n# Windows Console\nset DEBUG=graphile-build:warn,@dataplan/pg:* & postgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom Mutation Function in PostgreSQL\nDESCRIPTION: This SQL snippet shows the basic structure of a PostgreSQL function (`my_function`) designed to be recognized by PostGraphile as a custom mutation. It accepts two integer arguments (`a`, `b`) and returns text. The function must be `VOLATILE` (which is the default) and reside in an introspected schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-mutations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS text AS $$ â€¦ $$ LANGUAGE sql VOLATILE;\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile Presets and Services - TypeScript\nDESCRIPTION: This TypeScript configuration establishes Graphile and PostGraphile presets, including PostGraphileAmberPreset and PgSimplifyInflectionPreset, and defines how the PostgreSQL service is created using an environment variable. It exports a default preset object for consumption elsewhere. Dependencies include postgraphile, @graphile/simplify-inflection, and related typings. The preset is intended for import into server initialization code.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {} from \\\"graphile-config\\\";\\nimport \\\"postgraphile\\\";\\nimport { makePgService } from \\\"postgraphile/adaptors/pg\\\";\\nimport { PostGraphileAmberPreset } from \\\"postgraphile/presets/amber\\\";\\nimport { PgSimplifyInflectionPreset } from \\\"@graphile/simplify-inflection\\\";\\n\\nconst preset: GraphileConfig.Preset = {\\n  extends: [PostGraphileAmberPreset, PgSimplifyInflectionPreset],\\n  pgServices: [\\n    makePgService({\\n      connectionString: process.env.DATABASE_URL,\\n      schemas: [\\\"public\\\"],\\n    }),\\n  ],\\n  grafast: {\\n    explain: true,\\n  },\\n};\\n\\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Using pgPolymorphic to Resolve Polymorphic Relationships in TypeScript\nDESCRIPTION: This snippet demonstrates the final step of using `pgPolymorphic`. It passes the original record step (`$favourite`), the previously created specifier step (`$specifier`), and the entity type map (`personFavouriteEntityTypeMap`) to the `pgPolymorphic` function. This function uses the map and specifier to determine which type of related record (`Person`, `Post`, or `Comment`) the `$favourite` points to and returns a plan to fetch that specific record.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgPolymorphic.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nreturn pgPolymorphic($favourite, $specifier, personFavouriteEntityTypeMap);\n```\n\n----------------------------------------\n\nTITLE: Enforcing SSL for Heroku Postgres via PGSSLMODE (Environment Variable)\nDESCRIPTION: Demonstrates setting the `PGSSLMODE` environment variable to `require` to ensure SSL connections are used when connecting to Heroku Postgres. This is often set as a Heroku config variable (e.g., `heroku config:set PGSSLMODE=require`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nPGSSLMODE=require\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Code Generator for Persisted Queries using YAML\nDESCRIPTION: This YAML configuration snippet demonstrates how to set up `graphql-code-generator` to generate persisted query IDs. It specifies the schema and document locations, uses the `graphql-codegen-persisted-query-ids` plugin to output both client-side (`client.json`) and server-side (`server.json`) hash maps using the SHA256 algorithm, and includes a hook to run a custom script (`addToPersistedOperations.js`) after files are written.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nschema: \"schema.graphql\"\ndocuments: \"src/**/*.graphql\"\nhooks:\n  afterAllFileWrite:\n    - node addToPersistedOperations.js\ngenerates:\n  client.json:\n    plugins:\n      - graphql-codegen-persisted-query-ids:\n          output: client\n          algorithm: sha256\n  server.json:\n    plugins:\n      - graphql-codegen-persisted-query-ids:\n          output: server\n          algorithm: sha256\n```\n\n----------------------------------------\n\nTITLE: Disabling All Behaviors with @behavior -* Smart Tag\nDESCRIPTION: Shows the `@behavior -*` smart tag, used to prevent a database object (like a table or column) from having any default behaviors (e.g., query, insert, update, delete fields) added to the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n@behavior -*\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile V5 Preset with V4 Compatibility - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a PostGraphile V5 configuration file, leveraging the makeV4Preset factory to migrate familiar V4 options into the V5 graphile-config system. The setup combines the initial PostGraphileAmberPreset with V4 options and a PostgreSQL service definition via makePgService. Key parameters include database connection strings, schemas to expose, and typical V4 fields like simpleCollections and jwtPgTypeIdentifier. Requires packages: postgraphile, postgraphile/presets/amber, postgraphile/presets/v4, and postgraphile/adaptors/pg. The expected input is a set of V4 options, and the output is an exportable PostGraphile configuration preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-start\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n    }),\n    // highlight-end\n  ],\n\n  pgServices: [\n    makePgService({\n      connectionString: process.env.DATABASE_URL,\n      schemas: [\"app_public\"],\n    }),\n  ],\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Pub/Sub Events with listen in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates using the 'listen' function to subscribe to real-time events from a pub/sub system within Graphile Crystal. It first retrieves a 'pubsub' instance from the context, then calls 'listen' with the pubsub instance, the topic name 'my_event', and a callback function '($item) => doSomethingWith($item)' to process each incoming event payload '$item'. The function returns an event stream '$eventStream' representing the subscription.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/listen.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $pubsub = context().get(\"pubsub\");\nconst $eventStream = listen($pubsub, \"my_event\", ($item) =>\n  doSomethingWith($item),\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Schema with @pgQuery for Leaf Type using graphile-utils in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to use `makeExtendSchemaPlugin` to extend the `User` type with a computed scalar field `nameWithSuffix`. The `@pgQuery` directive is used with the `fragment` argument, which takes a function. This function receives the `queryBuilder` and field `args` and returns an `sql.fragment` that constructs the final string value by concatenating the user's name with the provided suffix argument directly in SQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_13\n\nLANGUAGE: js\nCODE:\n```\nconst { makeExtendSchemaPlugin, gql, embed } = require(\"graphile-utils\");\n\nmodule.exports = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type User {\n        nameWithSuffix(suffix: String!): String! @pgQuery(\n          fragment: ${embed(\n            (queryBuilder, args) =>\n              sql.fragment`(${queryBuilder.getTableAlias()}.name || ' ' || ${sql.value(\n                args.suffix,\n              )}::text)`,\n          )}\n        )\n      }\n    `,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Connection Methods for GraphQL Paging Utilities in TypeScript\nDESCRIPTION: This TypeScript code block contains interface method signatures for managing the state of cursor-based GraphQL connections. These methods include cloning the connection plan, computing page info, and setting pagination arguments like first, last, offset, before, and after. Dependencies include generic ConnectionStep, Step, and PageInfoCapableStep types, which must be available in the implementation context. Each method accepts typed parameters for flexible connection manipulation and expects a proper generic type structure to be maintained for integration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/connection.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n  /**\n   * Clone the plan; it's recommended that you add `$connection` as a\n   * dependency so that you can abort execution early in the case of errors\n   * (e.g. if the cursors cannot be parsed).\n   */\n  connectionClone(\n    $connection: ConnectionStep<TItemStep, TCursorStep, any, any>,\n    ...args: any[]\n  ): ConnectionCapableStep<TItemStep, TCursorStep>;\n\n  pageInfo(\n    $connection: ConnectionStep<\n      TItemStep,\n      TCursorStep,\n      ConnectionCapableStep<TItemStep, TCursorStep>,\n      any\n    >,\n  ): PageInfoCapableStep;\n\n  setFirst($step: Step<Maybe<number>> | number): void;\n  setLast($step: Step<Maybe<number>> | number): void;\n  setOffset($step: Step<Maybe<number>> | number): void;\n\n  parseCursor($step: Step<Maybe<string>>): TCursorStep;\n  setBefore($step: TCursorStep): void;\n  setAfter($step: TCursorStep): void;\n```\n\n----------------------------------------\n\nTITLE: Adding a WHERE Condition using pgSelect where() in TypeScript\nDESCRIPTION: Shows how to add a `WHERE` clause to filter the results of a `pgSelect` step (`$users`). It retrieves the table alias using `$users.alias`, then uses this alias within an SQL fragment (`sql`) to specify the condition (`${tbl}.username = 'Benjie'`). This condition is applied using the `$users.where()` method. Requires `usersResource` and the `sql` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst $users = usersResource.find();\nconst tbl = $users.alias;\n$users.where(sql`${tbl}.username = 'Benjie'`);\n```\n\n----------------------------------------\n\nTITLE: Creating Enums and Related Tables in PostgreSQL - SQL\nDESCRIPTION: Defines a PostgreSQL enum type and a table that uses this type for data integrity. The enum 'animal_type' is created to encapsulate possible animal types, and the 'pets' table stores pet data with the 'type' constrained to be one of the enum values. No external dependencies are required outside a running PostgreSQL instance and appropriate SQL permissions. Parameters include enum values and pet properties such as 'id', 'type', and 'name'. This pattern ensures data consistency at the database layer, and the enum type constrains the 'type' column to valid values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/enums.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type animal_type as enum (\n  'CAT',\n  'DOG',\n  'FISH'\n);\ncreate table pets (\n  id serial primary key,\n  type animal_type not null,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Plugin to Replace patchType Inflector in JavaScript\nDESCRIPTION: Provides a practical example of creating a PostGraphile plugin using `makeAddInflectorsPlugin` to override the default `patchType` inflector. This plugin changes the naming convention for patch types from `*Patch` to `*ChangeSet`. It requires setting the second argument of `makeAddInflectorsPlugin` to `true` to enable replacement.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-inflectors-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// MyInflectionPlugin.js\nconst { makeAddInflectorsPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeAddInflectorsPlugin(\n  {\n    patchType(typeName: string) {\n      return this.upperCamelCase(`${typeName}-change-set`);\n    },\n  },\n  /* Passing true here allows the plugin to overwrite\n   * existing inflectors.\n   */\n  true,\n);\n\n// Load this plugin with `postgraphile --append-plugins /path/to/MyInflectionPlugin.js`\n```\n\n----------------------------------------\n\nTITLE: Defining Tables with Foreign Key Relationships in PostgreSQL (SQL)\nDESCRIPTION: This SQL schema defines two tables: person and post. The post table has a non-nullable author_id foreign key referencing person. Demonstrates how referential integrity in the database does not guarantee GraphQL field visibility, especially under row-level security. Dependencies: PostgreSQL with citext extension. Key fields: person.id, post.author_id.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate table person (\n  id serial primary key,\n  username citext not null\n);\n\ncreate table post (\n  id serial primary key,\n  author_id int not null references person on delete cascade,\n  body text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Exposing HTTP Headers and User Data via PostGraphile pgSettings (TypeScript)\nDESCRIPTION: This TypeScript snippet configures a PostGraphile server using a custom grafast context callback to expose HTTP request headers and user authentication data to PostgreSQL through the pgSettings object. It extracts details from an Express.js request and ensures user and header information are accessible within PostgreSQL via current_setting. Dependencies include a Node.js/TypeScript environment, Express middleware, and PostGraphile in library mode. The pgSettings keys map HTTP context to PostgreSQL session variables, supporting both authenticated and unauthenticated users.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default {\n  // ...\n\n  grafast: {\n    async context(requestContext, args) {\n      // Extract request details from the requestContext:\n      // highlight-next-line\n      const req = requestContext.expressv4?.req;\n\n      return {\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // Expose a specific header (if present) to PostgreSQL\n          // highlight-next-line\n          \"myapp.headers.x_something\": req?.getHeader(\"x-something\"),\n          // Expose the user id from the request, if present\n          // highlight-next-line\n          \"myapp.user_id\": req?.user?.id,\n        },\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Joining and Filtering on Related Tables with pgSelect singleRelation in TypeScript\nDESCRIPTION: Demonstrates how to filter posts based on a condition on their related forum. `$posts.singleRelation(\"forum\")` forces a join to the related forum table and returns an SQL alias (`forumAlias`) for it. This alias is then used in the `$posts.where()` method with an SQL fragment to filter posts where the joined forum's `is_archived` column is false. Requires `postsResource` and the `sql` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst $posts = postsResource.find();\nconst forumAlias = $posts.singleRelation(\"forum\");\n$posts.where(sql`${forumAlias}.is_archived = false`);\nreturn $posts;\n\n// Result is something like:\n// `SELECT ... FROM posts LEFT JOIN forums ON (...) WHERE forums.is_archived = false`\n```\n\n----------------------------------------\n\nTITLE: Setting Local Role Using JWT Claim in PostgreSQL SQL\nDESCRIPTION: This SQL snippet demonstrates setting the current database role in a PostgreSQL session using the value of the 'role' claim extracted from a verified JWT. The operation uses the 'SET LOCAL ROLE' command to temporarily assume the specified role for the duration of the current transaction, thereby controlling permissions and authorization. No specific dependencies are required, but the user's role must exist in the PostgreSQL system, and this command is typically executed within a transaction in middleware or SQL client code.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nset local role $role;\n```\n\n----------------------------------------\n\nTITLE: Loading Smart Tags from a Custom File using makePgSmartTagsFromFilePlugin (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to use the makePgSmartTagsFromFilePlugin utility in a PostGraphile configuration to load a smart tags file from a non-default custom path. It supports loading from .json, .json5 or compatible files, and is useful when you want to keep tags in a different location or format. The implementation requires the 'postgraphile\\/utils' package and referencing the alternate path in the plugins array.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags-file.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makePgSmartTagsFromFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [\n    makePgSmartTagsFromFilePlugin(\n      // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\n      \"/path/to/my/tags.file.json\",\n    ),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting Smart Tags as JSON via Graphile Plugin - TypeScript\nDESCRIPTION: This TypeScript plugin for Graphile/PostGraphile traverses various introspection sources (such as classes, attributes, constraints, and procedures), extracts smart tags and descriptions, then structures and writes them as JSON to a smartTags.json file on disk. This aids migration between smart comments and smart tags by providing a unified export. The plugin depends on Node.js fs module, operates using the builder.hook API, and expects the incoming build object to have pgIntrospectionResultsByKind (as provided in typical Graphile internals). The only parameter is the builder (plugin API) object; outputs are saved to the file system, and logging is used for minimal error feedback.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/other.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst { writeFile } = require(\"fs\");\n\nmodule.exports = (builder) => {\n  builder.hook(\"init\", (_, build) => {\n    function sortStuff(a, b) {\n      const aSchema =\n        \"namespaceName\" in a ? a.namespaceName : a.class.namespaceName;\n      const bSchema =\n        \"namespaceName\" in b ? b.namespaceName : b.class.namespaceName;\n      return (\n        aSchema.localeCompare(bSchema) * 100 + a.name.localeCompare(b.name)\n      );\n    }\n    const smart = {\n      version: 1,\n      config: {\n        class: [...build.pgIntrospectionResultsByKind.class]\n          .sort(sortStuff)\n          .reduce((acc, pgClass) => {\n            let attribute = [...pgClass.attributes]\n              .sort((a, b) => a.name.localeCompare(b.name))\n              .reduce((acc, pgAttr) => {\n                const tags =\n                  Object.keys(pgAttr.tags).length > 0 ? pgAttr.tags : undefined;\n                if (pgAttr.description || tags) {\n                  acc[pgAttr.name] = {\n                    ...(pgAttr.description\n                      ? {\n                          description: pgAttr.description,\n                        }\n                      : {}),\n                    tags,\n                  };\n                }\n                return acc;\n              }, {});\n            if (Object.keys(attribute).length === 0) {\n              attribute = undefined;\n            }\n            let constraint = [...pgClass.constraints]\n              .sort(sortStuff)\n              .reduce((acc, pgConst) => {\n                if (pgConst.name.startsWith(\"FAKE_\")) {\n                  return acc;\n                }\n                const tags =\n                  Object.keys(pgConst.tags).length > 0\n                    ? pgConst.tags\n                    : undefined;\n                if (pgConst.class && (pgConst.description || tags)) {\n                  acc[pgConst.class.namespaceName + \".\" + pgConst.name] = {\n                    ...(pgConst.description\n                      ? {\n                          description: pgConst.description,\n                        }\n                      : {}),\n                    tags,\n                  };\n                }\n                return acc;\n              }, {});\n            if (Object.keys(constraint).length === 0) {\n              constraint = undefined;\n            }\n            const tags =\n              Object.keys(pgClass.tags).length > 0 ? pgClass.tags : undefined;\n            if (pgClass.description || tags || attribute)\n              acc[pgClass.namespaceName + \".\" + pgClass.name] = {\n                ...(pgClass.description\n                  ? {\n                      description: pgClass.description,\n                    }\n                  : {}),\n                tags,\n                attribute,\n                constraint,\n              };\n            return acc;\n          }, {}),\n        procedure: [...build.pgIntrospectionResultsByKind.procedure]\n          .sort(sortStuff)\n          .reduce((acc, pgProc) => {\n            if (pgProc.name.startsWith(\"FAKE_\")) {\n              return acc;\n            }\n            const tags =\n              Object.keys(pgProc.tags).length > 0 ? pgProc.tags : undefined;\n            if (pgProc.description || tags) {\n              acc[pgProc.namespaceName + \".\" + pgProc.name] = {\n                ...(pgProc.description\n                  ? {\n                      description: pgProc.description,\n                    }\n                  : {}),\n                tags,\n              };\n            }\n            return acc;\n          }, {}),\n      },\n    };\n    writeFile(\n      __dirname + \"/smartTags.json\",\n      JSON.stringify(smart, undefined, 2),\n      (e) => {\n        console.log(e);\n      },\n    );\n    return _;\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Referencing Objects within a PostgreSQL Schema (SQL)\nDESCRIPTION: Provides examples of SQL commands for creating a table and a function within the 'app_public' schema and subsequently querying them. It demonstrates using schema-qualified names (e.g., `app_public.users`) to access objects in non-default schemas. Assumes the 'app_public' schema exists.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/namespaces.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users ( ... );\nCREATE FUNCTION app_public.best_user() ...;\n\nSELECT * FROM app_public.users;\nSELECT * FROM app_public.best_user();\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple GraphQL Schema - TypeScript\nDESCRIPTION: Defines a GraphQL schema using the schema-first approach in TypeScript, with a Query type exposing an addTwoNumbers field that accepts two integer arguments. This string is intended for later use in schema construction. No dependencies except a JavaScript/TypeScript environment are required. The expected input is a GraphQL SDL definition, and it supports a basic sum operation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst typeDefs = /* GraphQL */ `\n  type Query {\n    addTwoNumbers(a: Int!, b: Int!): Int\n  }\n`;\n\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Plugin for 'idIn' Condition using TypeScript\nDESCRIPTION: This TypeScript code defines a PostGraphile plugin using `makeAddPgTableConditionPlugin` for the `app_public.forums` table. It adds a new condition field named `idIn`, which accepts an array of non-null integers (`[Int!]`). The `applyPlan` function implements the filtering logic by generating a SQL `WHERE` clause using `= ANY()` to match records where the `id` is present in the provided list. Dependencies include `postgraphile/utils` and `postgraphile/@dataplan/pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-condition-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { makeAddPgTableConditionPlugin } from \"postgraphile/utils\";\nimport { TYPES, listOfCodec } from \"postgraphile/@dataplan/pg\";\n\n/* TODO: test this plugin works! */\nexport default makeAddPgTableConditionPlugin(\n  { schemaName: \"app_public\", tableName: \"forums\" },\n  \"idIn\",\n  (build) => {\n    const { GraphQLList, GraphQLNonNull, GraphQLInt } = build.graphql;\n    return {\n      description: \"Filters to records matching one of these ids\",\n      // This is graphql-js for `[Int!]`; assumes you're using\n      // an integer primary key.\n      type: new GraphQLList(new GraphQLNonNull(GraphQLInt)),\n      applyPlan(\n        $condition /* : PgConditionStep<PgSelectStep<any>> */,\n        value /* : FieldArgs */,\n      ) {\n        const $ids = value.get();\n        $condition.where(\n          sql`${$condition.alias}.id = ANY(${$condition.placeholder(\n            $ids,\n            listOfCodec(TYPES.int),\n          )})`,\n        );\n      },\n    };\n  },\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Filtering in Graphile via @filterable Comment - SQL\nDESCRIPTION: This SQL code illustrates tagging PostgreSQL functions with the @filterable comment so PostGraphile exposes them with filtering capabilities in the generated GraphQL API. Handles both plain functions and computed columns, enabling condition or filter arguments depending on return types. Dependencies are a PostgreSQL schema, appropriate functions, and PostGraphile. Inputs are COMMENT ON FUNCTION statements; outputs manifest as filterable fields or connections in the API. Note: behavior varies on function return type (SETOF composite vs scalar/array).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_29\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@filterable';\ncomment on function users_foo(users) is E'@filterable';\n```\n\n----------------------------------------\n\nTITLE: Renaming Mutation and Result Field using SQL Smart Comments\nDESCRIPTION: Uses a SQL `COMMENT` statement with multiple smart tags for the `authenticate` function. It applies `@resultFieldName token` to name the field in the mutation payload and `@name login` to rename the mutation field itself in the PostGraphile GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function authenticate(text, text) is\n  E'@resultFieldName token\\n@name login';\n```\n\n----------------------------------------\n\nTITLE: Accessing GraphQL Context in Plan Resolvers with Grafast (TypeScript)\nDESCRIPTION: Demonstrates the usage of the `context()` function to obtain an object representing the GraphQL execution context within a plan resolver. This object enables type-safe extraction of properties from the context JSON, supporting methods such as `.get(key)` for objects and `.at(index)` for arrays. No external dependencies are needed beyond the Grafast library; the step is used in the context of building or resolving GraphQL execution plans. Input consists of the implicit execution context; outputs are `Step` instances containing the resolved values.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/context.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $context = context();\n```\n\n----------------------------------------\n\nTITLE: Generating a Plugin to Remove a Schema Field (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript function `makeRemoveFieldPlugin` that acts as a plugin generator. Given an object type name and a field name, it creates a Graphile Build plugin. This generated plugin uses the `GraphQLObjectType_fields` hook to check if the current object matches the provided name (`objectName`) and, if so, deletes the specified field (`fieldName`) from the fields object before returning it. An example usage `RemoveFooDotBarPlugin` is shown, generated by calling the function. The surrounding text notes that smart comments are often a better approach for removal.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending-raw.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nfunction makeRemoveFieldPlugin(\n  objectName: string,\n  fieldName: string,\n): GraphileConfig.Plugin {\n  return {\n    name: `RemoveField_${objectName}_${fieldName}_Plugin`,\n    description: `Removes the ${objectName}.${fieldName} field from the GraphQL schema`,\n    version: \"0.0.0\",\n\n    schema: {\n      hooks: {\n        GraphQLObjectType_fields(fields, build, context) {\n          if (context.Self.name !== objectName) return fields;\n          delete fields[fieldName];\n          return fields;\n        },\n      },\n    },\n  };\n}\n\nexport const RemoveFooDotBarPlugin = makeRemoveFieldPlugin(\"Foo\", \"bar\");\n```\n\n----------------------------------------\n\nTITLE: Customizing Error Masking in PostGraphile Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to customize the error masking behavior in PostGraphile within the `graphile.config.mjs` file. It defines a `maskError` function within the `grafserv` configuration object. This function logs the full error details (including the `originalError`) on the server console for debugging purposes. It then implements a more careful production-like approach: passing through `GraphQLError` instances and 'safe' errors, while masking other errors with a generic message containing a hash of the error string for easier grouping and identification in logs, ensuring sensitive details aren't leaked to the client.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { GraphQLError } from \"postgraphile/graphql\";\nimport { isSafeError } from \"postgraphile/grafast\";\nimport { createHash } from \"node:crypto\";\n\nconst sha1 = (text: string) =>\n  createHash(\"sha1\").update(text).digest(\"base64url\");\n\nexport default {\n  //...\n  grafserv: {\n    maskError(error) {\n      console.error(\"maskError was called with the following error:\");\n      console.error(error);\n      console.error(\"which had an originalError of:\");\n      console.error(error.originalError);\n\n      // You probably don't want this level of debugging in production as the\n      // results are sent to the client and it may leak implementation details\n      // you wish to keep private.\n      //\n      //   return error;\n\n      // Here's a more careful implementation:\n\n      if (error.originalError instanceof GraphQLError) {\n        return error;\n      } else if (\n        error.originalError != null &&\n        isSafeError(error.originalError)\n      ) {\n        return new GraphQLError(\n          error.originalError.message,\n          error.nodes,\n          error.source,\n          error.positions,\n          error.path,\n          error.originalError,\n          error.originalError.extensions ?? null,\n        );\n      } else {\n        // Hash so that similar errors can easily be grouped\n        const hash = sha1(String(error));\n        console.error(`Masked GraphQL error (hash: '${hash}')`, error);\n        return new GraphQLError(\n          `An error occurred (logged with hash: '${hash}')`,\n          error.nodes,\n          error.source,\n          error.positions,\n          error.path,\n          error.originalError,\n          // Deliberately wipe the extensions\n          {},\n        );\n      }\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Entity Behaviors and Schema Hooks in Graphile Plugin (TypeScript)\nDESCRIPTION: This snippet creates a Graphile plugin in TypeScript that registers custom entity behaviors on codecs and resources and reacts to these behaviors within GraphQL object type schema hooks. The 'schema.entityBehaviors' property sets default behavior for all codecs and conditionally adds a resource behavior based on the 'isUnique' property of resources. The 'hooks' property defines a handler for GraphQL object fields that checks if a specific codec behavior applies, allowing conditional augmentation of schema fields. Requires Graphile core, with dependencies on the plugin API and associated context objects. Inputs include schema entities and plugin configuration; output is modification of schema and GraphQL field behaviors. Modification is based on behavioral matching and is constrained by the plugin API's expected structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    // Register default behaviors (optional)\n    entityBehaviors: {\n      // Apply 'myCodecBehavior' by default to _all_ codecs\n      pgCodec: \"myCodecBehavior\",\n\n      // Apply 'myResourceBehavior' to resources with truthy `isUnique` (overrides defaults)\n      pgResource(behavior, resource) {\n        if (resource.isUnique) {\n          return [behavior, \"myResourceBehavior\"];\n        } else {\n          return behavior;\n        }\n      },\n    },\n\n    // Do something with behaviors (optional)\n    hooks: {\n      GraphQLObjectType_fields_field(field, build, context) {\n        const codec = context.scope.pgFieldCodec;\n        if (\n          !codec ||\n          !build.behavior.pgCodecMatches(codec, \"myCodecBehavior\")\n        ) {\n          return field;\n        }\n\n        // Behavior matches! Do stuff here...\n\n        return field;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic PostGraphile Server Plugin (CLI Greeting)\nDESCRIPTION: This JavaScript code provides a simple example of a custom PostGraphile server plugin. The plugin defines a hook for the `cli:greeting` event, which allows modifying the messages displayed when the PostGraphile CLI starts. It receives the existing messages array and the context (including the `chalk` library for styling) and returns a new array with an added greeting.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst MyPlugin = {\n  [\"cli:greeting\"](messages, { chalk }) {\n    return [...messages, `Hello ${chalk.blue(\"world\")}!`];\n  },\n};\n\nmodule.exports = MyPlugin;\n// or, for ES6 modules:\n// export default MyPlugin;\n```\n```\n\n----------------------------------------\n\nTITLE: Example Optimized SQL Generated by @dataplan/pg\nDESCRIPTION: Shows an example SQL query that `@dataplan/pg` might generate during its optimization phase. This demonstrates how multiple Gra*fast* steps accessing database resources can be combined into a single, efficient SQL query, avoiding multiple database round-trips.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\nselect ...\nfrom channels\nwhere organization_id = (\n  select users.organization_id\n  from users\n  where users.id = $1\n);\n```\n\n----------------------------------------\n\nTITLE: Adding an Inflector in a Graphile V5 Plugin (TypeScript)\nDESCRIPTION: Shows how to define a custom inflector (`allRowsConnection`) for naming connection fields in Graphile V5. It includes declaring the inflector's type signature using declaration merging and providing the implementation within the `inflection.add` section of a plugin definition. The implementation uses built-in inflection helpers like `this.connectionField`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Declare the type\ndeclare global {\n  namespace GraphileBuild {\n    interface Inflection {\n      /** Field name for a Connection field returning all rows from the resource. */\n      allRowsConnection(this: Inflection, resource: PgResource): string;\n    }\n  }\n}\n\n// Implement the inflector\nexport const PgAllRowsPlugin: GraphileConfig.Plugin = {\n  name: \"PgAllRowsPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    add: {\n      allRowsConnection(\n        options, // Additional argument, automatically passed by the system\n        resource, // This is the argument you defined in the types above\n      ) {\n        return this.connectionField(\n          this.camelCase(\n            `all-${this.pluralize(this._singularizedResourceName(resource))}`,\n          ),\n        );\n      },\n      // ...\n    },\n  },\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Referencing Parent Data in Where Clause: V4 vs V5 (TypeScript)\nDESCRIPTION: Compares PostGraphile V4 and V5 methods for filtering based on a parent record's attribute within a query's `where` clause. In V4, `queryBuilder.parentQueryBuilder` accesses the parent's alias directly for use in a SQL fragment. In V5, the parent step (`$parent`) retrieves the required attribute (`archived_at`), which is then converted into a placeholder (`archivedAtFrag`) using the current select step's (`$pgSelect`) `placeholder()` method. This placeholder is then used within the `where` clause's `sql` tagged template literal, allowing the planning system to manage value embedding.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// V4\nconst parentAlias = queryBuilder.parentQueryBuilder.getTableAlias();\nqueryBuilder.where(sql.fragment`${parentAlias}.archived_at is not true`);\n\n// V5\nconst $archivedAt = $parent.get(\"archived_at\");\nconst archivedAtFrag = $pgSelect.placeholder($archivedAt);\n$pgSelect.where(sql`${archivedAtFrag} is not true`);\n```\n\n----------------------------------------\n\nTITLE: Initializing a Node.js HTTP Server with Grafserv\nDESCRIPTION: This JavaScript snippet sets up a Node.js HTTP server using the `http` module. It initializes Grafserv with a provided schema (`schema.mjs`) and configuration preset (`graphile.config.mjs`). Grafserv's request handler is then attached to the HTTP server to process incoming GraphQL requests. Basic error handling is included for server errors and Grafserv attachment issues. Finally, the server starts listening on the port defined in the preset or defaults to 5678.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/node.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport { grafserv } from \"grafserv/node\";\nimport preset from \"./graphile.config.mjs\";\nimport schema from \"./schema.mjs\";\n\n// Create a Node HTTP server\nconst server = createServer();\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// Create a Grafserv instance\nconst serv = grafserv({ schema, preset });\n\n// Mount the request handler into a new HTTP server, and register websockets if\n// desired\nserv.addTo(server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\n// Start the Node server\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Debugging Full Record Retrieval with pgSelectSingle.record() - TypeScript\nDESCRIPTION: Illustrates using the record() method on pgSelectSingle to retrieve the complete user row object for debugging purposes. Assumes the presence of a usersResource and a sideEffect logging utility. Returns the full user record, which can be inspected or logged. Key input is a user identifier; output is a record-type step for additional introspection.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst plans = {\n  Query: {\n    getUserById(_, { $id }) {\n      const $user = usersResource.get({ id: $id });\n\n      // Get the full user object as a record and log it for debugging:\n      const $record = $user.record();\n      sideEffect($record, (user) => console.dir(user));\n\n      return $user;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-specific Step Planning for Polymorphism in Gra*fast* (TypeScript)\nDESCRIPTION: Defines the method signature 'planForType' in TypeScript for creating polymorphic-capable executable steps in Gra*fast*. Requires that the relevant step class implements this method to handle interface or union positions at planning time. The input is a 'GraphQLObjectType', and the output is an 'ExecutableStep' for the concrete type. This is necessary for supporting correct polymorphic planning and execution in queries involving interfaces or unions.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/polymorphism.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n  planForType(objectType: GraphQLObjectType): ExecutableStep;\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Role in PostGraphile Server - Bash\nDESCRIPTION: Shows how to launch the PostGraphile server with a specified default PostgreSQL role (default_role), which is used for unauthenticated users or when no role claim is present. Requires an existing PostgreSQL user for authentication and the desired default role in the database. Uses the '--default-role' option to restrict access for non-authenticated sessions. Inputs include a Postgres connection string and the default role name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/default-role.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb --default-role default_role\n\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Fields Using fieldWithHooks in Graphile Plugins (JavaScript)\nDESCRIPTION: Illustrates how to add a new custom field ('helloWorld') to GraphQL input object types using the 'fieldWithHooks' function from the context in a JavaScript plugin for Graphile Build. The hook utilizes build-provided utilities and GraphQL non-null/string types, returning an extended set of fields including the new field generated via the specified scope and specification function. Dependencies include Graphile Build, relevant GraphQL types, and the plugin registration. Parameters include the current field map, build utilities, and the full hook context. The extended fields object is returned, including the custom 'helloWorld' field with a constant resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/context-object.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLInputObjectType_fields(fields, build, context) {\n        const {\n          extend,\n          graphql: { GraphQLNonNull, GraphQLString },\n        } = build;\n        // highlight-next-line\n        const { fieldWithHooks } = context;\n        // TODO: if (...) return fields;\n        return extend(\n          fields,\n          {\n            // highlight-start\n            helloWorld: fieldWithHooks(\n              // The scope\n              { fieldName: \"helloWorld\", isHelloWorldField: true },\n\n              // The spec generator\n              () => ({\n                type: new GraphQLNonNull(GraphQLString),\n                plan() {\n                  return constant(\"Hello World\");\n                },\n              }),\n            ),\n            // highlight-end\n          },\n          \"Adding helloWorld from 'MyPlugin'\",\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Returning Anonymous Tables from PostgreSQL Functions\nDESCRIPTION: Shows the `returns table(...)` syntax for PostgreSQL functions, which defines an anonymous return type. This approach is generally discouraged in favor of returning named types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nreturns table(...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Typed GraphileConfig Preset with Plugins in TypeScript (ESM/TypeScript)\nDESCRIPTION: Implements a strongly-typed GraphileConfig.Preset in a TypeScript environment, benefiting from TypeScript's type safety. The preset imports dependencies using ESM syntax and type-only imports to enhance the developer experience. Key parameters include the \\\"plugins\\\" array and custom scopes such as \\\"someConfigOption\\\"; the export leverages TypeScript's \\\"export default\\\". Inputs: properly installed plugins; outputs: an object usable as a GraphileConfig preset. Requires the \\\"graphile-config\\\" type definitions; does not add \\\"graphile-config\\\" code to final output.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {} from \"graphile-config\";\nimport SomePlugin from \"some-plugin\";\n\nconst preset: GraphileConfig.Preset = {\n  plugins: [SomePlugin],\n  someScope: {\n    someConfigOption: 10,\n  },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Resulting GraphQL Schema PatchSet Renaming Diff (diff format)\nDESCRIPTION: This â€˜diffâ€™ snippet shows the line-by-line differences between the original and modified GraphQL schema after applying the PatchSet renaming plugin. It highlights all input types and mutation 'patch' arguments whose names have been altered from '*Patch' to '*PatchSet'. Inputs and outputs are schema definitions; this is for demonstration and documentation only, not executed code. Use this as a reference to understand the plugin's effects on a complex schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/inflector.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -979,7 +979,7 @@\n \"\"\"\n Represents an update to a `Forum`. Fields that are set will be updated.\n \"\"\"\n-input ForumPatch {\n+input ForumPatchSet {\n   id: Int\n\n   \"\"\"An URL-safe alias for the `Forum`.\"\"\"\n@@ -1573,7 +1573,7 @@\n }\n\n \"\"\"Represents an update to a `Post`. Fields that are set will be updated.\"\"\"\n-input PostPatch {\n+input PostPatchSet {\n   \"\"\"The body of the `Topic`, which Posts reply to.\"\"\"\n   body: Html\n }\n@@ -2043,7 +2043,7 @@\n \"\"\"\n Represents an update to a `QuizEntryAnswer`. Fields that are set will be updated.\n \"\"\"\n-input QuizEntryAnswerPatch {\n+input QuizEntryAnswerPatchSet {\n   id: Int\n   quizEntryId: Int\n   question: String\n@@ -2118,7 +2118,7 @@\n \"\"\"\n Represents an update to a `QuizEntry`. Fields that are set will be updated.\n \"\"\"\n-input QuizEntryPatch {\n+input QuizEntryPatchSet {\n   id: Int\n   userId: Int\n   quizId: Int\n@@ -2134,7 +2134,7 @@\n }\n\n \"\"\"Represents an update to a `Quiz`. Fields that are set will be updated.\"\"\"\n-input QuizPatch {\n+input QuizPatchSet {\n   id: Int\n   name: String\n   updatedAt: Datetime\n@@ -2317,7 +2317,7 @@\n \"\"\"\n Represents an update to a `Topic`. Fields that are set will be updated.\n \"\"\"\n-input TopicPatch {\n+input TopicPatchSet {\n   id: Int\n   forumId: Int\n   authorId: Int\n@@ -2394,7 +2394,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Forum` being updated.\n   \"\"\"\n-  patch: ForumPatch!\n+  patch: ForumPatchSet!\n }\n\n \"\"\"All input for the `updateForumBySlug` mutation.\"\"\"\n@@ -2408,7 +2408,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Forum` being updated.\n   \"\"\"\n-  patch: ForumPatch!\n+  patch: ForumPatchSet!\n\n   \"\"\"An URL-safe alias for the `Forum`.\"\"\"\n   slug: String!\n@@ -2425,7 +2425,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Forum` being updated.\n   \"\"\"\n-  patch: ForumPatch!\n+  patch: ForumPatchSet!\n   id: Int!\n }\n\n@@ -2468,7 +2468,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Post` being updated.\n   \"\"\"\n-  patch: PostPatch!\n+  patch: PostPatchSet!\n }\n\n \"\"\"All input for the `updatePost` mutation.\"\"\"\n@@ -2482,7 +2482,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Post` being updated.\n   \"\"\"\n-  patch: PostPatch!\n+  patch: PostPatchSet!\n   id: Int!\n }\n\n@@ -2531,7 +2531,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Quiz` being updated.\n   \"\"\"\n-  patch: QuizPatch!\n+  patch: QuizPatchSet!\n }\n\n \"\"\"All input for the `updateQuizEntryAnswerByNodeId` mutation.\"\"\"\n@@ -2550,7 +2550,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `QuizEntryAnswer` being updated.\n   \"\"\"\n-  patch: QuizEntryAnswerPatch!\n+  patch: QuizEntryAnswerPatchSet!\n }\n\n \"\"\"All input for the `updateQuizEntryAnswer` mutation.\"\"\"\n@@ -2564,7 +2564,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `QuizEntryAnswer` being updated.\n   \"\"\"\n-  patch: QuizEntryAnswerPatch!\n+  patch: QuizEntryAnswerPatchSet!\n   id: Int!\n }\n\n@@ -2610,7 +2610,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `QuizEntry` being updated.\n   \"\"\"\n-  patch: QuizEntryPatch!\n+  patch: QuizEntryPatchSet!\n }\n\n \"\"\"All input for the `updateQuizEntry` mutation.\"\"\"\n@@ -2624,7 +2624,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `QuizEntry` being updated.\n   \"\"\"\n-  patch: QuizEntryPatch!\n+  patch: QuizEntryPatchSet!\n   id: Int!\n }\n\n@@ -2668,7 +2668,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Quiz` being updated.\n   \"\"\"\n-  patch: QuizPatch!\n+  patch: QuizPatchSet!\n   id: Int!\n }\n\n@@ -2711,7 +2711,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Topic` being updated.\n   \"\"\"\n-  patch: TopicPatch!\n+  patch: TopicPatchSet!\n }\n\n \"\"\"All input for the `updateTopic` mutation.\"\"\"\n@@ -2725,7 +2725,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `Topic` being updated.\n   \"\"\"\n-  patch: TopicPatch!\n+  patch: TopicPatchSet!\n   id: Int!\n }\n\n@@ -2774,7 +2774,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserAuthentication` being updated.\n   \"\"\"\n-  patch: UserAuthenticationPatch!\n+  patch: UserAuthenticationPatchSet!\n }\n\n \"\"\"\n@@ -2790,7 +2790,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserAuthentication` being updated.\n   \"\"\"\n-  patch: UserAuthenticationPatch!\n+  patch: UserAuthenticationPatchSet!\n\n   \"\"\"The login service used, e.g. `twitter` or `github`.\"\"\"\n   service: String!\n@@ -2810,7 +2810,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserAuthentication` being updated.\n   \"\"\"\n-  patch: UserAuthenticationPatch!\n+  patch: UserAuthenticationPatchSet!\n   id: Int!\n }\n\n@@ -2853,7 +2853,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `User` being updated.\n   \"\"\"\n-  patch: UserPatch!\n+  patch: UserPatchSet!\n }\n\n \"\"\"All input for the `updateUserByUsername` mutation.\"\"\"\n@@ -2867,7 +2867,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `User` being updated.\n   \"\"\"\n-  patch: UserPatch!\n+  patch: UserPatchSet!\n\n   \"\"\"Public-facing username (or 'handle') of the user.\"\"\"\n   username: String!\n@@ -2889,7 +2889,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserEmail` being updated.\n   \"\"\"\n-  patch: UserEmailPatch!\n+  patch: UserEmailPatchSet!\n }\n\n \"\"\"All input for the `updateUserEmailByUserIdAndEmail` mutation.\"\"\"\n@@ -2903,7 +2903,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserEmail` being updated.\n   \"\"\"\n-  patch: UserEmailPatch!\n+  patch: UserEmailPatchSet!\n   userId: Int!\n\n   \"\"\"The users email address, in `a@b.c` format.\"\"\"\n@@ -2921,7 +2921,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `UserEmail` being updated.\n   \"\"\"\n-  patch: UserEmailPatch!\n+  patch: UserEmailPatchSet!\n   id: Int!\n }\n\n@@ -2962,7 +2962,7 @@\n   \"\"\"\n   An object where the defined keys will be set on the `User` being updated.\n   \"\"\"\n-  patch: UserPatch!\n+  patch: UserPatchSet!\n\n   \"\"\"Unique identifier for the user.\"\"\"\n   id: Int!\n@@ -3167,7 +3167,7 @@\n \"\"\"\n Represents an update to a `UserAuthentication`. Fields that are set will be updated.\n \"\"\"\n-input UserAuthenticationPatch {\n+input UserAuthenticationPatchSet {\n   id: Int\n\n   \"\"\"The login service used, e.g. `twitter` or `github`.\"\"\"\n@@ -3273,7 +3273,7 @@\n \"\"\"\n Represents an update to a `UserEmail`. Fields that are set will be updated.\n \"\"\"\n-input UserEmailPatch {\n+input UserEmailPatchSet {\n   id: Int\n   userId: Int\n\n@@ -3355,7 +3355,7 @@\n }\n\n \"\"\"Represents an update to a `User`. Fields that are set will be updated.\"\"\"\n-input UserPatch {\n+input UserPatchSet {\n   \"\"\"Unique identifier for the user.\"\"\"\n   id: Int\n\n```\n\n----------------------------------------\n\nTITLE: Example psql Error: Database Does Not Exist using Bash\nDESCRIPTION: Shows an example FATAL error message from `psql` when the connection to the PostgreSQL server is successful, but the default database it tried to connect to (often named after the OS user, e.g., 'username') does not exist. This output confirms the PostgreSQL server is running and reachable but the target database is missing.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///\"\n\npsql: FATAL:  database \"username\" does not exist\n```\n\n----------------------------------------\n\nTITLE: Safely Embedding Untrusted Strings with te.substring\nDESCRIPTION: Shows how `te.substring` escapes and safely embeds potentially untrusted string content within a string literal in the generated code. The second argument specifies the type of quote (`\"`, `'`, or `` ` ``) used for the surrounding string literal to ensure correct escaping.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\n// Some untrusted user input, could have anything in it\nconst untrusted = \"'\\\"` \\\\'\\\\\"\\\\` ${process.exit(1)}\";\n\n// Safely insert the untrusted input into a string\nconst code = te.run`return \"abc${te.substring(untrusted, '\"')}123\";`;\n\nassert.strictEqual(code, \"abc'\\\"` \\\\'\\\\\"\\\\` ${process.exit(1)}123\");\n```\n\n----------------------------------------\n\nTITLE: Function Signature for makeAddPgTableOrderByPlugin (TypeScript)\nDESCRIPTION: Presents the TypeScript API definition for makeAddPgTableOrderByPlugin, outlining required parameters for matching the target table and generating ordering logic, as well as the structure of the orders mapping. This function is central for plugin development, supporting extensible plugin creation through strongly-typed configuration. Dependencies are postgraphile types and plugin API contracts. Facilitates functional plugin generation and extensibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeAddPgTableOrderByPlugin(\n  match: {\n    serviceName?: string;\n    schemaName: string;\n    tableName: string;\n  },\n  ordersGenerator: (\n    build: GraphileBuild.Build,\n  ) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): GraphileConfig.Plugin;\n\ninterface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    extensions: {\n      grafast: {\n        applyPlan($select: PgSelectStep): void;\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Graphile Subscription Plugin (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a custom PostGraphile schema plugin using `makeExtendSchemaPlugin`, extending the `Subscription` type to add a `forumMessage` field. It demonstrates how to use `listen` with `pgSubscriber` and the topic pattern, subscribing to PostgreSQL events for forum messages, and parsing payloads as JSON. Dependencies: `postgraphile/utils`, `postgraphile/grafast`, and `postgraphile/@dataplan/json`. The code maps subscription events to schema fields and is meant for file/module scope in your server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeExtendSchemaPlugin } from \"postgraphile/utils\";\nimport { context, lambda, listen } from \"postgraphile/grafast\";\nimport { jsonParse } from \"postgraphile/@dataplan/json\";\n\nconst MySubscriptionPlugin = makeExtendSchemaPlugin((build) => {\n  const { messages } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: /* GraphQL */ `\n      extend type Subscription {\n        forumMessage(forumId: Int!): ForumMessageSubscriptionPayload\n      }\n\n      type ForumMessageSubscriptionPayload {\n        event: String\n        message: Message\n      }\n    `,\n    plans: {\n      Subscription: {\n        forumMessage: {\n          subscribePlan(_$root, args) {\n            const $pgSubscriber = context().get(\"pgSubscriber\");\n            const $forumId = args.get(\"forumId\");\n            const $topic = lambda($forumId, (id) => `forum:${id}:message`);\n            return listen($pgSubscriber, $topic, jsonParse);\n          },\n          plan($event) {\n            return $event;\n          },\n        },\n      },\n      ForumMessageSubscriptionPayload: {\n        event($event) {\n          return $event.get(\"event\");\n        },\n        message($event) {\n          const $id = $event.get(\"id\");\n          return messages.get({ id: $id });\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Using IO Equivalence with Object Steps in loadOne (TypeScript)\nDESCRIPTION: This TypeScript example illustrates how to use loadOne with an input as an object mapping (oids, uids) and an ioEquivalence object for member records. The fetch callback receives an array of objects whose properties correspond to the mapped input steps. The mapping allows direct association between output properties and their input steps for optimal resolver reuse. Dependencies include object() plan step, proper ioEquivalence object, and a batch fetch callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $member = loadOne(\n  object({ oid: $organizationId, uid: $userId }),\n  { oid: \"organization_id\", uid: \"user_id\" },\n  batchGetMemberByOrganizationIdAndUserId,\n);\n\n// - batchGetMemberByOrganizationIdAndUserId will be called with a list of\n//   objects; each object will have the key `oid` set to an organization id,\n//   and the key `uid` set to the user ID.\n// - Due to the io equivalence (2nd argument):\n//   - `$member.get(\"organization_id\")` will return the step used for `oid`\n//     (i.e. `$organizationId`) directly\n//   - Similarly `$member.get(\"user_id\")` will return `$userId` directly\n```\n\n----------------------------------------\n\nTITLE: Creating Log Entries Table Referring to Union Members - SQL\nDESCRIPTION: Defines a 'log_entries' table that contains foreign keys to both the 'people' and 'organizations' tables and uses a check constraint to ensure only one is present. This structure supports referencing a union type as required in advanced PostGraphile scenarios. Inputs must satisfy the mutual exclusivity check on the two FK columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.log_entries (\n  id serial primary key,\n  person_id int references polymorphic.people on delete cascade,\n  organization_id int references polymorphic.organizations on delete cascade,\n  text text not null,\n  constraint owned_by_person_or_organization check ((person_id is null) <> (organization_id is null))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Passwords and Returning JWTs in PL/pgSQL - SQL/PLPGSQL\nDESCRIPTION: This conditional PL/pgSQL block checks the provided password by hashing it with the existing password hash and comparing the result. If the password matches, the function returns a JWT composite; otherwise, it returns null, signaling authentication failure. It relies on the 'crypt' function from the 'pgcrypto' extension and on structured error handling in client code.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_36\n\nLANGUAGE: plpgsql\nCODE:\n```\nif account.password_hash = crypt(password, account.password_hash) then\\n  return ('forum_example_person', account.person_id)::forum_example.jwt_token;\\nelse\\n  return null;\\nend if;\n```\n\n----------------------------------------\n\nTITLE: Extending the Root Query Type with a Custom Field (JavaScript)\nDESCRIPTION: This plugin adds a new field 'meaningOfLife' to the root 'Query' type in the generated GraphQL schema. Implemented under the 'schema' scope, it hooks into 'GraphQLObjectType_fields', conditionally targeting the root query type, and introduces an integer field that always returns 42. Dependencies include the 'grafast' library for the 'constant' helper, and Graphile Build's schema hook system.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { constant } from \"grafast\";\n\nconst RootQueryFieldPlugin = {\n  name: \"RootQueryFieldPlugin\",\n  version: \"0.0.0\",\n  description: \"Adds a field to the root Query type\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // Only add the field to the root query type\n        if (!context.scope.isRootQuery) return fields;\n\n        // Add a field called `meaningOfLife`\n        fields.meaningOfLife = {\n          // It's an integer\n          type: build.graphql.GraphQLInt,\n\n          // When you call the field, you should always return the number '42'\n          plan() {\n            return constant(42);\n          },\n        };\n\n        return fields;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Converting applyPlan/inputPlan to apply/baked for Runtime Input Handling\nDESCRIPTION: Details the migration from plan-time resolvers (`applyPlan`, `inputPlan`) on input object fields to runtime steps (`applyInput`, `bakedInput`) in Grafast. Plan resolver methods must be renamed (`applyPlan` becomes `apply`, `inputPlan` becomes `baked`) and adapted for the runtime context, where `fieldArgs` is replaced by the field's direct runtime value. This shift moves recursive input processing from plan-time to runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/news/2025-03-24-grafast-0.1-beta.21.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napplyPlan\n```\n\nLANGUAGE: javascript\nCODE:\n```\ninputPlan\n```\n\nLANGUAGE: javascript\nCODE:\n```\napplyInput\n```\n\nLANGUAGE: javascript\nCODE:\n```\nbakedInput\n```\n\nLANGUAGE: javascript\nCODE:\n```\napply\n```\n\nLANGUAGE: javascript\nCODE:\n```\nbaked\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfieldArgs\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Bundling Exported PostGraphile V5 Schema in JavaScript\nDESCRIPTION: This Webpack configuration bundles a PostGraphile V5 schema previously exported using `graphile-export` (e.g., into `exported-schema.mjs`). It targets Node.js, sets the mode to production, defines entry and output paths (producing `exported-schema.webpacked.js` as a CommonJS library), uses `webpack.DefinePlugin` to set production environment variables, ignores Node.js built-in modules, and configures `TerserPlugin` for minification while preserving class names. Dependencies include `webpack`, `terser-webpack-plugin`, and `path`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/bundling-webpack.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst webpack = require(\"webpack\");\nconst TerserPlugin = require(\"terser-webpack-plugin\");\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: \"./exported-schema.mjs\",\n  output: {\n    path: path.resolve(__dirname),\n    filename: \"exported-schema.webpacked.js\",\n    library: {\n      type: \"commonjs\",\n    },\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": JSON.stringify(\"production\"),\n      \"process.env.GRAPHILE_ENV\": JSON.stringify(\"production\"),\n    }),\n  ],\n  target: \"node\", // use require() & use NodeJs CommonJS style\n  externalsPresets: {\n    node: true, // in order to ignore built-in modules like path, fs, etc.\n  },\n  performance: {\n    maxEntrypointSize: 2000000,\n    maxAssetSize: 2000000,\n  },\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_classnames: true,\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostgreSQL Databases - Bash\nDESCRIPTION: Shows usage of the psql command-line tool to connect to different PostgreSQL databases and hosts. Illustrates connecting both locally and remotely with authentication. Assumes valid database credentials and accessible servers. Connection strings must be adjusted for environment specifics.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ psql postgres:///testdb # Connects to the `testdb` database on your local machine\n$ psql \"postgres://user:password@somehost:2345/somedb\"  # Connects to the `somedb` database at `postgres://somehost:2345` using login with `user` and `password`\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple-Dependency Lambda Step in TypeScript\nDESCRIPTION: This snippet shows the TypeScript function signature for the `lambda` step designed to handle multiple input steps provided as an array. The `$input` parameter accepts an array of `ExecutableStep` objects. The callback function receives an array (`Tuple`) containing the resolved values from the input steps in the corresponding order. It also includes the optional `isSyncAndSafe` flag for potential optimization and returns an `ExecutableStep` representing the callback's result. Passing an array directly implicitly uses the `list()` step.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction lambda<Tuple extends [...any[]], R>(\n  // i.e. $input: ExecutableStep[],\n  $input: { [Index in keyof Tuple]: ExecutableStep<Tuple[Index]> },\n  callback: (input: Tuple) => R | Promise<R>,\n  isSyncAndSafe = false,\n): ExecutableStep<R>;\n```\n```\n\n----------------------------------------\n\nTITLE: Using the gql Helper with Interpolation in TypeScript\nDESCRIPTION: Demonstrates the usage of the `gql` template literal tag provided by `postgraphile/utils`. It shows how string variables (like `nameOfType`) can be interpolated directly into the SDL string to dynamically name types, and how other `gql` tagged templates (`Type`) can be embedded within a larger definition (`typeDefs`). This allows for modular and dynamic schema construction, often utilizing PostGraphile's inflection system for naming.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst nameOfType = \"MyType\"; // Or use the inflection system to generate a type\n\n// This tag interpolates the string `nameOfType` to allow dynamic naming of the\n// type.\nconst Type = gql`\n  type ${nameOfType} {\n    str: String\n    int: Int\n  }\n`;\n\n// This tag interpolates the entire definition in `Type` above.\nconst typeDefs = gql`\n  ${Type}\n\n  extend type Query {\n    fieldName: Type\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom random Field to All GraphQLObjectTypes (JavaScript)\nDESCRIPTION: This plugin adds a 'random' field (with an optional 'sides' integer argument) to every GraphQLObjectType by registering a hook on 'GraphQLObjectType_fields'. Using the 'plan' property, the field produces a pseudo-random integer between default or specified values. It utilizes Gra*fast*'s 'lambda', and parameters can be customized via build options. Requires Graphile Build, Gra*fast*, and appropriate build context.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// No imports required!\n\nconst MyRandomFieldPlugin = {\n  name: \\\"MyRandomFieldPlugin\\\",\n  version: \\\"0.0.0\\\",\n\n  schema: {\n    GraphQLObjectType_fields(fields, build, context) {\n      const {\n        extend,\n        graphql: { GraphQLInt },\n        options: { myDefaultMin = 1, myDefaultMax = 100 },\n      } = build;\n      return extend(fields, {\n        random: {\n          type: GraphQLInt,\n          args: {\n            sides: {\n              type: GraphQLInt,\n            },\n          },\n          plan(_, fieldArgs) {\n            const $sides = fieldArgs.get(\\\"sides\\\");\n            return lambda(\n              $sides,\n              (sides) =>\n                Math.floor(\n                  Math.random() * ((sides ?? myDefaultMax) - myDefaultMin + 1),\n                ) + myDefaultMin,\n            );\n          },\n        },\n      });\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Resolver Wrapper Function Signature in Graphile (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript type alias for a resolver wrapper function intended to augment or override the behavior of standard GraphQL resolvers in Graphile. The wrapper receives the original resolver as its first argument, enabling delegation with optional overrides for the standard GraphQL parameters (source, args, context, resolveInfo). The function can return a value or a promise, and is suitable for use cases requiring custom logic injection or conditional execution around resolvers. No dependencies are specified beyond standard GraphQL resolver types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype ResolverWrapperFn = (\n  resolve: GraphQLFieldResolver, // Delegates to the resolver we\\'re wrapping\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  resolveInfo: GraphQLResolveInfo,\n) => any;\n```\n\n----------------------------------------\n\nTITLE: Printing Resolved Configuration with graphile CLI\nDESCRIPTION: This shell command uses the `graphile` CLI tool to print the final, resolved configuration object after merging all extended presets and applying local settings from the `graphile.config.*` file. This is helpful for debugging configuration issues.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n```sh\ngraphile config print\n```\n```\n\n----------------------------------------\n\nTITLE: Using makeChangeNullabilityPlugin to Modify Schema Nullability in TypeScript\nDESCRIPTION: This example shows how to import and use the `makeChangeNullabilityPlugin` function from `postgraphile/utils`. It creates a plugin instance (`MyNullabilityPlugin`) configured to change the nullability of the `nodes` field on the `UsersConnection` type to be a non-nullable list of non-nullable items (`[!]!`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-change-nullability-plugin.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeChangeNullabilityPlugin } from \"postgraphile/utils\";\n\nconst MyNullabilityPlugin = makeChangeNullabilityPlugin({\n  UsersConnection: {\n    nodes: \"[!]!\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using orderByAscDesc with Custom Nulls Sorting for Movie Ratings\nDESCRIPTION: This code snippet demonstrates creating a custom order-by configuration using the `orderByAscDesc` helper, specifically for movie ratings. It defines `RATING_ASC` and `RATING_DESC` orderings based on the average rating calculated via a SQL subquery within a `sql.fragment`. Crucially, it uses the `{ nulls: 'last' }` option to ensure that movies with no reviews (resulting in a `null` average rating) appear at the end of the list when sorting, rather than potentially at the beginning when sorting descending.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst customOrderBy = orderByAscDesc(\n  \"RATING\",\n  (helpers) => {\n    const { queryBuilder } = helpers;\n\n    const orderByFrag = sql.fragment`(\n      select avg(${sqlIdentifier}.rating)\n      from app_public.movie_reviews as ${sqlIdentifier}\n      where ${sqlIdentifier}.movie_id = ${queryBuilder.getTableAlias()}.id\n    )`;\n\n    return orderByFrag;\n  },\n  { nulls: \"last\" },\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Single Scalar SQL Function for Graphile (SQL)\nDESCRIPTION: This SQL code defines the function 'app_public.random_number', which returns an integer when called by the GraphQL layer. The implementation uses a stable SQL function that always returns 4 (a humorous nod to XKCD#221). This function is a prerequisite for the 'randomNumber' field in the GraphQL schema and requires permissions to create functions in the 'app_public' schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.random_number() returns int\nlanguage sql stable\nas $$\n  select 4; -- Chosen by fair dice roll. Guaranteed to be random. XKCD#221\n$$;\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Output - JavaScript\nDESCRIPTION: Presents performance results for each schema execution mode based on recent benchmark runs: outputs the time taken for each approach, aiding comparison and decision-making. The results reflect total execution times for 10,000 runs using different resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/examples/users-and-friends/README.md#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n```\nGraphQL's execute / schemaDL: 7180ms\nGrafast's execute / schemaDL: 6551ms\nGrafast's execute / schemaGF: 5072ms\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring a @dataplan/pg Codec for Single-Table Polymorphism in TypeScript\nDESCRIPTION: Illustrates how to configure the `polymorphism` property on a `@dataplan/pg` resource codec to enable handling of single-table polymorphism directly via `pgSelect`. It specifies the mode (`single`), the attribute(s) used to determine the type (`typeAttributes`), and maps database type enum values (e.g., 'TOPIC') to GraphQL type names (e.g., 'Topic').\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nitemResource.codec.polymorphism = {\n  mode: \"single\",\n  typeAttributes: [\"type\"],\n  types: {\n    TOPIC: {\n      name: \"Topic\",\n    },\n    POST: {\n      name: \"Post\",\n    },\n    DIVIDER: {\n      name: \"Divider\",\n    },\n    CHECKLIST: {\n      name: \"Checklist\",\n    },\n    CHECKLIST_ITEM: {\n      name: \"ChecklistItem\",\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with Watch Mode using Bash\nDESCRIPTION: Runs the locally installed PostGraphile server using `npx`, connecting to the local 'mydb' database with the Amber preset. The `--watch` flag enables watch mode, causing PostGraphile to monitor the connected PostgreSQL database schemas for changes and automatically update the GraphQL API and restart the server when changes are detected. This is useful during development.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres:///mydb\" --watch\n```\n\n----------------------------------------\n\nTITLE: Defining `edgeDataPlan` for Connections in TypeScript\nDESCRIPTION: This TypeScript snippet, related to PR #1978, demonstrates the new `edgeDataPlan` feature for the `connection()` step. It shows how to define an `edgeDataPlan` function within the connection's configuration object to associate custom data with each edge (e.g., `{ item: $item, otherThing: $otherThing }`). The subsequent code shows how this associated data can be retrieved later using `$edge.data().get(\"otherThing\")` within related plans (like `FooEdge`).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nreturn connection($list, {\n  edgeDataPlan($item) {\n    return object({ item: $item, otherThing: $otherThing });\n  },\n});\n\n// ...\n\nconst plans = {\n  FooEdge: {\n    otherThing($edge) {\n      return $edge.data().get(\"otherThing\");\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: package.json Before Upgrading to PostGraphile V5 (json)\nDESCRIPTION: This snippet shows the package.json devDependencies before updating to PostGraphile V5. It lists the V4 alpha versions of graphile-build, graphile-build-pg, postgraphile, and postgraphile-plugin-connection-filter as devDependencies. This is the baseline configuration before running the upgrade steps. These dependencies should be updated to their corresponding beta versions for V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"devDependencies\\\": {\\n    \\\"graphile-build\\\": \\\"^4.12.0-alpha.0\\\",\\n    \\\"graphile-build-pg\\\": \\\"^4.12.0-alpha.0\\\",\\n    \\\"postgraphile\\\": \\\"^4.12.0-alpha.0\\\",\\n    \\\"postgraphile-plugin-connection-filter\\\": \\\"^2.2.0\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Middleware Interfaces in TypeScript\nDESCRIPTION: Defines the core TypeScript interfaces for a custom middleware system within `src/interfaces.ts`. It includes the `MyMiddleware` interface specifying the middleware methods (e.g., `someAction`), the `SomeActionEvent` interface for event data passed to the middleware, the `SomeActionResult` type for return values, and a helper `PromiseOrDirect` type. This structure establishes the contract for middleware functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/library-authors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"src/interfaces.ts\"\n// Define the middlewares that you support, their event type and their return type\nexport interface MyMiddleware {\n  someAction(event: SomeActionEvent): PromiseOrDirect<SomeActionResult>;\n}\ninterface SomeActionEvent {\n  someParameter: number;\n  /*\n   * Use a per-middleware-method interface to define the various pieces of\n   * data relevant to this event. **ALWAYS** use the event as an abstraction\n   * so that new information can be added in future without causing any\n   * knock-on consequences. Note that these parameters of the event may be\n   * mutated. The values here can be anything, they don't need to be simple\n   * values.\n   */\n}\n// Middleware wraps a function call; this represents whatever the function returns\ntype SomeActionResult = number;\n\nexport type PromiseOrDirect<T> = Promise<T> | T;\n```\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Types - SQL\nDESCRIPTION: This COMMENT statement attaches a smart comment to a PostgreSQL type, allowing the type to be renamed for PostGraphile purposes and documented for the schema. Dependencies: PostgreSQL. Input is COMMENT ON TYPE; output is a renamed and documented type in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on type my_schema.my_type is\\n  E'@name my_new_type_name\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Disabling the NodePlugin in Graphile Config (JavaScript)\nDESCRIPTION: This JavaScript code shows how to disable the global object identifier (NodePlugin) in a PostGraphile project by setting 'disablePlugins' to include 'NodePlugin' in the configuration object exported from 'graphile.config.mjs'. Input is the configuration file for PostGraphile, and output is the modified PostGraphile behavior with global object identification removed from the schema. Suitable for projects requiring custom cache key logic or a schema without nodeId/id fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/node-id.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  // ...\n  // highlight-next-line\n  disablePlugins: [\"NodePlugin\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Spinning Up Transactional Test Sessions in Postgres (SQL)\nDESCRIPTION: This SQL snippet demonstrates how to manually manage a database transaction for testing, including setting transaction-local variables such as role and jwt claims, executing function calls, and rolling back the transaction. Designed for use from a Postgres client (e.g., via a Node.js driver), it enables safe, isolated test execution with custom role contexts. Inputs include the role, JWT claims, and the SQL statement under test; outputs are the function's result set. All operations are rolled back, leaving the database unchanged after the test.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n-- start transaction\\nbegin;\\n\\n-- set relevant transaction settings; the `, true` means \"local\" - i.e. it'll\\n-- be rolled back with the transaction - do not forget to add this!\\nselect\\n  set_config('role', 'YOUR_GRAPHQL_ROLE_HERE', true),\\n  set_config('jwt.claims.user_id', 27, true),\\n  set_config...;\\n\\n-- run the SQL you want to test\\nselect * from my_function();\\n\\n-- rollback the transaction\\nrollback;\n```\n\n----------------------------------------\n\nTITLE: Static GraphQL Query with Variables (JavaScript)\nDESCRIPTION: Implements the recommended Gra*fast* usage pattern by defining a static query and providing variables separately. Here, `UserDetailsQuery` is a declared GraphQL document (using a tagged template comment) that expects a `userId` variable. The `getUserDetails` function then executes this query by passing both the query document and the variable object. This prevents injection and supports persisted operations, caching, and cost estimation. Requires a function like `runGraphQLQuery` that can execute queries with variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/production-considerations.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Declare the query once:\nconst UserDetailsQuery = /* GraphQL */ `\n  query UserDetails($userId: Int!) {\n    userById(id: $userId) {\n      username\n      avatarUrl\n    }\n  }\n`;\n\nfunction getUserDetails(userId) {\n  // Run the static query using the dynamic variable:\n  return runGraphQLQuery(UserDetailsQuery, { userId });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Runtime Modification with apply() in Grafast Step (TypeScript)\nDESCRIPTION: This detailed example demonstrates implementing the apply() method for a query-building Step in Grafast, supporting runtime modification via callback steps. The apply method tracks callback dependencies and ensures they are invoked in the execute() method using executionDetails. The implementation enables dynamic SQL query construction (such as dynamic orderBy clauses) and asynchronous data retrieval. Dependencies: grafast types (Step, ExecutionDetails, GrafastResultsList, Maybe), a runQuery utility for database operations. Key parameters: apply takes a Step of Maybe<Callback or Callback[]>, execute uses per-execution input values. Output: Promise of results mapped per input. Handles both single and multiple callbacks, ensures step dependency tracking.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Step, ExecutionDetails, GrafastResultsList, Maybe } from \"grafast\";\n\ninterface QueryBuilder {\n  orderBy(columnName: string, ascending?: boolean): void;\n}\n\ntype Callback = (queryBuilder: QueryBuilder) => void;\n\nclass MyQueryStep extends Step {\n  private applyDepIds: number[] = [];\n\n  // [...]\n  //   this.foreignKeyDepId = this.addDependency($fkey);\n  // [...]\n\n  // Handling `Step<Callback>` is enough for some use cases, but\n  // handling this combination is the most flexible.\n  apply($step: Step<Maybe<Callback | ReadonlyArray<Callback>>>) {\n    this.applyDepIds.push(this.addUnaryDependency($step));\n  }\n\n  async execute(\n    executionDetails: ExecutionDetails,\n  ): Promise<GrafastResultsList<Record<string, any>>> {\n    const { values, indexMap } = executionDetails;\n    const foreignKeyEV = values[this.foreignKeyDepId];\n\n    // Create a query builder to collect together the orderBy values\n    const orderBys: string[] = [];\n    const queryBuilder: QueryBuilder = {\n      orderBy(columnName, asc = true) {\n        orderBys.push(`${columnName} ${asc ? \"ASC\" : \"DESC\"}`);\n      },\n    };\n\n    // For each of the `apply()` callbacks, run it against the query builder\n    for (const applyDepId of this.applyDepIds) {\n      const callback = values[applyDepId].unaryValue();\n      if (Array.isArray(callback)) {\n        callback.forEach((cb) => cb(queryBuilder));\n      } else if (callback != null) {\n        callback(queryBuilder);\n      }\n    }\n\n    // Now we can use `orderBys` to build a query:\n    const query = `\n      select *\n      from my_table\n      where foreign_key = any($1)\n      order by ${orderBys}\n    `;\n\n    // Then we can fetch the data:\n    const allForeignKeys = indexMap((i) => foreignKeyEV.at(i));\n    const rows = await runQuery(query, [allForeignKeys]);\n\n    // And return the right data to go with each input value:\n    return indexMap((i) => {\n      const foreignKey = foreignKeyEV.at(i);\n      return rows.filter((r) => r.foreign_key === foreignKey);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using pgPolymorphic for Single-Table Polymorphism in TypeScript\nDESCRIPTION: Shows how the general `pgPolymorphic` function can be used for single-table polymorphism (within a nested `<details>` section). It requires defining a `itemsTypeMap` with `match` (checking the type value) and `plan` functions for each possible type. In this specific case, the `plan` functions simply return the original `$item` step since all data resides in that single row. This approach is presented as an alternative to codec configuration or `pgSingleTablePolymorphic`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst itemsTypeMap = {\n  Topic: {\n    match: (t) => t === \"TOPIC\",\n    plan: (_, $item) => $item,\n  },\n  Post: {\n    match: (t) => t === \"POST\",\n    plan: (_, $item) => $item,\n  },\n  Divider: {\n    match: (t) => t === \"DIVIDER\",\n    plan: (_, $item) => $item,\n  },\n  Checklist: {\n    match: (t) => t === \"CHECKLIST\",\n    plan: (_, $item) => $item,\n  },\n  ChecklistItem: {\n    match: (t) => t === \"CHECKLIST_ITEM\",\n    plan: (_, $item) => $item,\n  },\n};\n\n/******/\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      const $item = $comment.singleRelation(\"item\");\n      const $type = $item.get(\"type\");\n      return pgPolymorphic($item, $type, itemsTypeMap);\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Tables - SQL\nDESCRIPTION: This SQL COMMENT statement applies smart tags to a table using an escape string constant (E'...'). It demonstrates renaming a table and omitting update and delete operations via the @name and @omit tags, followed by a documentation string. Requires PostgreSQL. Input is a COMMENT targeting a table; output is schema customization for PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table my_schema.my_table is\\n  E'@name my_new_table_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile Server with CLI - Bash\nDESCRIPTION: Features several 'npx postgraphile' command examples for starting a PostGraphile server against various PostgreSQL connection strings. Includes options for SSL/TLS connections and different hosts/ports. Requires a valid config and installed PostGraphile. CLI options are tailored for different deployment environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Connect to the `mydb` database within the local PostgreSQL server\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres:///mydb\"\n\n# Connect to a database that requires SSL/TLS\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres://securehost:5432/db?ssl=true\"\n\n# Connect to the `somedb` database within the PostgreSQL at somehost port 2345\n$ npx postgraphile -P postgraphile/presets/amber -c \"postgres://somehost:2345/somedb\"\n```\n\n----------------------------------------\n\nTITLE: Accessing UserId from GraphQL Context with Grafast (TypeScript)\nDESCRIPTION: This snippet demonstrates how to retrieve the current userId from the GraphQL context inside a Grafast plan resolver using the context() step. No special dependencies are required beyond postgraphile/grafast. The context key 'userId' must be set earlier in the request lifecycle. Input is implied to be the resolver context; output is a step instance returning the userId at execution time.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $userId = context().get(\"userId\");\n```\n\n----------------------------------------\n\nTITLE: Mounting Multiple PostGraphile Schemas on Different Endpoints in Express (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to configure and run multiple independent PostGraphile instances within a single Node.js Express application. It defines separate PostgreSQL services ('admin', 'user'), creates a PostGraphile instance for each with distinct connection strings and endpoint paths using a base `userPreset`, and mounts them using the Grafserv Express adapter. This setup allows accessing different GraphQL schemas via unique URLs (e.g., `/admin/graphql`, `/user/graphql`). Dependencies include `express`, `postgraphile`, `grafserv`, and a custom `graphile.config.mjs` preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/multiple-schemas.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport postgraphile from \"postgraphile\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport userPreset from \"./graphile.config.mjs\";\n\n// Create an express app\nconst app = express();\n// (Add any Express middleware you want here.)\n\n// Create a Node HTTP server, mounting Express into it\nconst server = createServer(app);\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// Definitions of the PostgreSQL service we wish to expose via separate\n// GraphQL APIs:\nconst services = {\n  admin: \"postgres:///admin\",\n  user: \"postgres:///user\",\n};\n\n// Loop over the services, and add them to our Express app\nfor (const [service, connectionString] of Object.entries(services)) {\n  // Build a preset specifically for this service\n  const preset = {\n    extends: [userPreset],\n    pgServices: [makePgService({ connectionString })],\n    grafserv: {\n      graphqlPath: `/${service}/graphql`,\n      graphiqlPath: `/${service}`,\n    },\n  };\n  // Build a PostGraphile instance for this service\n  export const pgl = postgraphile(preset);\n  // Create the Grafserv instance for this PostGraphile instance using the Express adaptor\n  const serv = pgl.createServ(grafserv);\n  // Add the Grafserv instance's route handlers to the Express app, and register\n  // websockets if desired\n  await serv.addTo(app, server);\n  // TODO: check that enabling websockets on multiple grafservs via the same server doesn't cause any issues\n}\n\n// Start the Express server\nserver.listen(userPreset.grafserv?.port ?? 5678);\n```\n```\n\n----------------------------------------\n\nTITLE: Querying One-to-Many Relationship via Auto-Generated Field in GraphQL\nDESCRIPTION: Example GraphQL query demonstrating how PostGraphile automatically exposes a relationship field based on a foreign key. It queries all posts (`allPosts`), retrieving the `headline` and `body` for each post. Crucially, it also fetches the related author information (`id`, `name`, `about`) using the automatically generated `personByAuthorId` field, which corresponds to the `author_id` foreign key defined in the SQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/relations.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPosts {\n    nodes {\n      headline\n      body\n\n      # this relation is automatically exposed\n      personByAuthorId {\n        id\n        name\n        about\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Runtime Variables for Each JWT Claim (SQL)\nDESCRIPTION: This SQL snippet establishes dynamic configuration parameters for every decoded JWT claim by leveraging the 'SET LOCAL' command in PostgreSQL under a 'jwt.claims' namespace. For each claim, a 'set local jwt.claims.$claim_name to $claim_value;' statement is used, which temporarily assigns the claim to a session-local GUC (Grand Unified Configuration) variable. Requires PostgreSQL and that all variables be used within a session or transaction scope; claim values should be sanitized and properly quoted if needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nset local jwt.claims.$claim_name to $claim_value;\n```\n\n----------------------------------------\n\nTITLE: Defining a Forgot Password SQL Function for GraphQL Mutation (PL/pgSQL)\nDESCRIPTION: Creates a PostgreSQL function named 'forgot_password' using the PL/pgSQL language. This function takes an email (text) as input and returns a boolean, representing the core logic for the 'forgotPassword' mutation. An optional SQL comment utilizes Graphile's smart comments ('@resultFieldName success') to explicitly map the function's return value to the 'success' field in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-mutations.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forgot_password(email text)\nreturns boolean\nlanguage plpgsql volatile\nas $$\n  ...\n$$;\n-- Optionally rename the result field:\ncomment on function\n  forgot_password(email text)\n  is '@resultFieldName success';\n```\n\n----------------------------------------\n\nTITLE: Using PostGraphile Middleware with Node.js HTTP Module in JavaScript\nDESCRIPTION: Illustrates using the `postgraphile` middleware directly with Node.js's built-in `http` server. It requires 'http' and 'postgraphile'. The middleware is configured with the database connection string (`DATABASE_URL` or default), the 'public' schema, and options like `watchPg`, `graphiql`, and `enhanceGraphiql`. The HTTP server listens on `PORT` or default 3000.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst http = require(\"http\");\nconst { postgraphile } = require(\"postgraphile\");\n\nhttp\n  .createServer(\n    postgraphile(\n      process.env.DATABASE_URL || \"postgres://user:pass@host:5432/dbname\",\n      \"public\",\n      {\n        watchPg: true,\n        graphiql: true,\n        enhanceGraphiql: true,\n      },\n    ),\n  )\n  .listen(process.env.PORT || 3000);\n```\n\n----------------------------------------\n\nTITLE: Defining Smart Tags and Descriptions in JSON5 for PostGraphile\nDESCRIPTION: This JSON5 snippet exemplifies the format of the postgraphile.tags.json5 file used by PostGraphile's smart tags plugin to annotate and enhance schema entities. It structures configuration elements such as class, attribute, and constraint, enabling you to provide detailed descriptions and customizable tags for specific database objects (i.e. tables, columns). This file must use the .json5 extension, and supports both inline and nested configuration. The schema must include 'version' and 'config', and may describe any number of entities and their metadata.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags-file.md#_snippet_1\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    /*\n     * There can be entries here for:\n     *\n     * - `class`: for tables, composite types, views and materialized views\n     * - `attribute`: for columns/attributes (of any 'class' type)\n     * - `constraint`: for table constraints\n     * - `procedure`: for functions/procedures\n     */\n    class: {\n      /*\n       * The next level describes the named type. We\\'ve just used the table\n       * name \\\"post\\\" but it could be \\\"my_schema.post\\\" if you have multiple\n       * tables with the same name and you don\\'t want this rule to apply to\n       * all of them.\n       */\n      post: {\n        /*\n         * This will override the description sourced from the PostgreSQL COMMENT.\n         */\n        description: \"A post within our forum.\",\n\n        /*\n         * Add tags specific to the 'post' table here. You can omit this if you\n         * don't want to add any tags.\n         */\n        tags: {\n          foreignKey: [\n            \"(default_user_id) references user (id)|@fieldName defaultUser\",\n            \"(organization_id) references organization (id)|@fieldName organization\",\n          ],\n        },\n\n        /*\n         * We've added a shortcut to class-types so you can tag/describe\n         * columns at the same time of the class.\n         */\n        attribute: {\n          /*\n           * Assuming `body` is one of the columns in the 'post' table.\n           */\n          body: {\n            /*\n             * Optional description, if provided overrides the PostgreSQL\n             * `COMMENT ON COLUMN post.body`.\n             */\n            description: \"The body of the post\",\n            tags: {\n              /*\n               * Here we indicate that the 'body' field will not be available\n               * in the update mutation.\n               */\n              omit: \"update\",\n            },\n          },\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Testing PostgreSQL Connection - Bash\nDESCRIPTION: Demonstrates how to connect to a local PostgreSQL database using psql from the terminal. Shows expected failure when invoking a non-existent user database, useful for verifying PostgreSQL installation and default connection behavior. Input is the psql command with a postgres URI; output is failure message confirming progress.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n$ psql \\\"postgres:///\\\"\\n\\npsql: FATAL:  database \\\"username\\\" does not exist\\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Data Registry with @dataplan/pg in TypeScript\nDESCRIPTION: This snippet demonstrates configuring a data registry for PostgreSQL interaction using `@dataplan/pg`. It initializes a `PgExecutor` for database communication, defines `recordCodec`s for 'forums' and 'messages' tables specifying column types and constraints, creates `PgResourceOptions` linking codecs to tables and defining unique keys, and uses `makeRegistryBuilder` to assemble codecs, resources, and define relationships (one-to-many between forums and messages). Finally, it builds the registry.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/example.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { sql } from \"pg-sql2\";\nimport { context, object } from \"grafast\";\nimport {\n  PgExecutor,\n  TYPES,\n  makePgResourceOptions,\n  makeRegistry,\n  makeRegistryBuilder,\n  recordCodec,\n} from \"@dataplan/pg\";\n\n// The executor is responsible for talking to the database. If you have\n// multiple databases, you will have multiple executors (one per database).\nconst executor = new PgExecutor({\n  name: \"default\",\n  context() {\n    return object({ withPgClient: context().get(\"withPgClient\") });\n  },\n});\n\n// Represents the type of the 'forums' table:\nconst forumsCodec = recordCodec({\n  name: \"forums\",\n  identifier: sql`forums`,\n  attributes: {\n    id: {\n      codec: TYPES.uuid,\n      notNull: true,\n      hasDefault: true,\n    },\n    name: {\n      codec: TYPES.citext,\n      notNull: true,\n    },\n  },\n});\n\n// Represents the 'forums' table, including knowledge of its primary key:\nconst forumsResourceOptions = makePgResourceOptions({\n  name: \"forums\",\n  executor,\n  codec: forumsCodec,\n  from: sql`forums`,\n  uniques: [{ attributes: [\"id\"], isPrimary: true }],\n});\n\n// Represents the type of the 'messages' table:\nconst messagesCodec = recordCodec({\n  name: \"messages\",\n  identifier: sql`messages`,\n  attributes: {\n    id: {\n      codec: TYPES.int,\n      notNull: true,\n      hasDefault: true,\n    },\n    forum_id: {\n      codec: TYPES.int,\n      notNull: true,\n    },\n    message: {\n      codec: TYPES.text,\n      notNull: true,\n    },\n  },\n});\n\n// Represents the 'messages' table:\nconst messagesResourceOptions = makePgResourceOptions({\n  name: \"messages\",\n  executor,\n  codec: messagesCodec,\n  from: sql`messages`,\n  uniques: [{ isPrimary: true, attributes: [\"id\"] }],\n});\n\n// The builder tracks all the types so you end up with a strongly-typed registry\nconst builder = makeRegistryBuilder()\n  // First add our codecs\n  .addCodec(forumsCodec)\n  .addCodec(messagesCodec)\n\n  // Then add our resources\n  .addResource(forumsResourceOptions)\n  .addResource(messagesResourceOptions)\n\n  // A message relates to a single forum:\n  .addRelation(messagesCodec, \"forum\", forumsResourceOptions, {\n    localAttributes: [\"forum_id\"],\n    remoteAttributes: [\"id\"],\n    isUnique: true,\n  })\n\n  // A forum can have many messages:\n  .addRelation(forumsCodec, \"messages\", messagesResourceOptions, {\n    localAttributes: [\"id\"],\n    remoteAttributes: [\"forum_id\"],\n    // The foreign key reference is defined on 'messages', so we're the one\n    // that's referenced by a foreign key\n    isReferencee: true,\n  });\n\n// Finally build the registry:\nconst registry = makeRegistry(builder.getRegistryConfig());\n```\n\n----------------------------------------\n\nTITLE: Configuring Graphile to Use Both Amber and Relay Presets (JavaScript)\nDESCRIPTION: This JavaScript configuration snippet demonstrates how to extend a PostGraphile API with both the 'amber' and 'relay' preset modules by importing them and specifying them in the 'extends' array of the exported configuration object. This alters the schema to hide raw primary keys and rely on global object identifiers throughout. Dependencies are 'postgraphile/presets/amber' and 'postgraphile/presets/relay'. Input is a configuration file; output is a PostGraphile schema with relay-style nodeId usage. Useful for users wishing to follow Relay Global Object Identification best practices.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/node-id.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { PostGraphileRelayPreset } from \"postgraphile/presets/relay\";\n\nexport default {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-next-line\n    PostGraphileRelayPreset,\n    //...\n  ],\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Anonymous Role in PostGraphile (TypeScript)\nDESCRIPTION: This TypeScript code snippet shows a PostGraphile configuration file (`graphile.config.mjs`). It modifies the Grafast context to set the default PostgreSQL role to `forum_example_anonymous` using the `pgSettings` option. This ensures that requests without authentication information are processed using the privileges of the anonymous role.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\nexport default {\n  extends: [PostGraphileAmberPreset],\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-start\n        pgSettings: {\n          role: \"forum_example_anonymous\",\n        },\n        // highlight-end\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Deprecating a PostgreSQL Column with Smart Comments in SQL\nDESCRIPTION: This SQL snippet demonstrates how to use PostGraphile's smart comments feature to mark a database column as deprecated within the generated GraphQL schema. The comment includes the '@deprecated' tag followed by a deprecation reason, which will be reflected in the GraphQL documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column c.person.site is E'@deprecated Use `website` instead\\nThe user''s homepage';\n```\n\n----------------------------------------\n\nTITLE: Historical (Non-Example) List Transform Implementations in TypeScript\nDESCRIPTION: This TypeScript code shows early, discarded concepts for implementing list transformations like grouping (`groupBy`), filtering (`filter`), and aggregation (`aggregate`) using a reducer pattern. It defines a `ReduceCallback` type and provides potential implementations. This code is explicitly marked as **not for use** and serves only as historical context for the development of the final `listTransform` feature.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/pages/plans/listTransform.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\ntype ReduceCallback<TItemPlanData, TResult> = (\n  memo: TResult,\n  entireItemValue: unknown,\n  itemPlanData: TItemPlanData,\n) => TResult;\n\n// groupBy\nconst groupByPlan = groupBy($select, ($row) => $row.select(sql`array_idx`));\nconst groupByReduceInitialValue = [];\nconst groupByReduceCallback: ReduceCallback<TItemPlanData, Row[][]> = (\n  memo,\n  entireItemValue,\n  idx,\n) => {\n  if (!memo[idx]) {\n    memo[idx] = [];\n  }\n  memo[idx].push(entireItemValue);\n  return memo;\n};\n\n// filter\nconst filterPlan = filter($select, ($row) =>\n  lambda($row.get(\"archived_at\"), (archivedAt) => !archivedAt),\n);\nconst filterInitialValue = [];\nconst filterReduceCallback: ReduceCallback<TItemPlanData, Row[]> = (\n  memo,\n  entireItemValue,\n  include,\n) => {\n  if (include) {\n    memo.push(entireItemValue);\n  }\n  return memo;\n};\n\n// aggregation\nconst aggregatePlan = aggregate(\n  // List plan\n  $select,\n  // Item plan\n  ($row) => list($row.get(\"amount\"), $row.get(\"year\")),\n  // Reduce\n  (memo, [amount, year]) => {\n    memo.totalCount += 1;\n    memo.totalAmount += amount;\n    if (!memo.latestYear || year > memo.latestYear) {\n      memo.latestYear = year;\n    }\n    return memo;\n  },\n  // Finalize\n  (memo) => {\n    memo.averageAmount = memo.totalAmount / memo.totalCount;\n    return memo;\n  },\n);\nconst aggregationInitialValue = {\n  totalCount: 0,\n  totalAmount: 0,\n  averageAmount: 0,\n  latestYear: null,\n};\nconst aggregationReduceCallback: ReduceCallback<TItemPlanData, Row[]> = (\n  memo,\n  entireItemValue,\n  deps,\n) => {\n  return aggregatePlan.reduce(memo, deps);\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating INSERT/UPDATE/DELETE Policies Based on Author ID (SQL)\nDESCRIPTION: Defines Row Level Security policies for the `forum_example.post` table targeted at the `forum_example_person` role. The `insert_post` policy uses `WITH CHECK` to ensure new posts have an `author_id` matching the user's ID from the JWT claim. The `update_post` and `delete_post` policies use `USING` to restrict modifications/deletions to posts where the `author_id` matches the user's JWT `person_id`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_42\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy insert_post on forum_example.post for insert to forum_example_person\n  with check (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy update_post on forum_example.post for update to forum_example_person\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy delete_post on forum_example.post for delete to forum_example_person\n  using (author_id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Granting PostgreSQL Permissions for Forum Example Roles\nDESCRIPTION: This SQL snippet sets up access privileges for the `forum_example_anonymous` and `forum_example_person` roles. It first revokes default public execute permissions on functions. Then, it grants schema usage, table-level permissions (SELECT, UPDATE, DELETE, INSERT), sequence usage, and function execution permissions to the specified roles. Permissions are granted selectively based on whether the user is anonymous or logged in, establishing a basic security model.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_36\n\nLANGUAGE: sql\nCODE:\n```\n-- after schema creation and before function creation\nalter default privileges revoke execute on functions from public;\n\ngrant usage on schema forum_example to forum_example_anonymous, forum_example_person;\n\ngrant select on table forum_example.person to forum_example_anonymous, forum_example_person;\ngrant update, delete on table forum_example.person to forum_example_person;\n\ngrant select on table forum_example.post to forum_example_anonymous, forum_example_person;\ngrant insert, update, delete on table forum_example.post to forum_example_person;\ngrant usage on sequence forum_example.post_id_seq to forum_example_person;\n\ngrant execute on function forum_example.person_full_name(forum_example.person) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.post_summary(forum_example.post, integer, text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.person_latest_post(forum_example.person) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.search_posts(text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.authenticate(text, text) to forum_example_anonymous, forum_example_person;\ngrant execute on function forum_example.current_person() to forum_example_anonymous, forum_example_person;\n\ngrant execute on function forum_example.register_person(text, text, text, text) to forum_example_anonymous;\n```\n\n----------------------------------------\n\nTITLE: Querying Forum Post Search Function via GraphQL in GraphQL\nDESCRIPTION: This GraphQL query demonstrates how to call the 'searchPosts' function from the previous SQL definition. The 'search' argument is required and is mapped to the text parameter of the corresponding PostgreSQL function. 'first' enables pagination; 'pageInfo', 'totalCount', and 'nodes' are standard connection fields returned by PostGraphile. The query returns a page of post nodes containing 'headline' and 'body'. Requires a schema generated by PostGraphile with the function and underlying table defined.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-queries.md#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  searchPosts(search: \"Hello world\", first: 5) {\n    pageInfo {\n      hasNextPage\n    }\n    totalCount\n    nodes {\n      headline\n      body\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Foreign Key Indexes in PostgreSQL for PostGraphile\nDESCRIPTION: Demonstrates creating `users` and `things` tables with a foreign key relationship and explicitly adding an index on the `things.user_id` foreign key column using `CREATE INDEX`. This practice is strongly recommended to ensure efficient reverse relation lookups in PostGraphile, which might otherwise be omitted from the schema or perform poorly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/best-practices.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table users (id serial primary key);\ncreate table things (id serial primary key, user_id int not null references users);\n/* highlight-next-line */\ncreate index on things (user_id);\n```\n\n----------------------------------------\n\nTITLE: Initializing Koa V2 Server with Grafserv and Graphile Configuration - JavaScript\nDESCRIPTION: This snippet initializes a Koa v2 web server, integrates it with a Graphile-generated schema using Grafserv, and sets up websocket and HTTP handling on a configurable port. Dependencies include Koa, Node.js (http), grafserv, as well as project-local files for the graphile configuration and schema. The Koa app is prepared for additional middlewares, and error handling is established at both the server and application level. The port is resolved from the preset configuration or falls back to 5678 by default. No database or filesystem operations are shown, but websocket registration is supported via serv.addTo. Limitations include implicit reliance on valid project-local configuration (graphile.config.mjs, schema.mjs) and having necessary dependencies installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/koa.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createServer } from \\\"node:http\\\";\nimport Koa from \\\"koa\\\";\nimport { grafserv } from \\\"grafserv/koa/v2\\\";\nimport preset from \\\"./graphile.config.mjs\\\";\nimport schema from \\\"./schema.mjs\\\";\n\n// Create a Koa app\nconst app = new Koa();\n// (Add any Koa middleware you want here.)\n\n// Create a Node HTTP server, mounting Koa into it\nconst server = createServer(app);\nserver.on(\\\"error\\\", (e) => {\n  console.error(e);\n});\n\n// Create a Grafserv instance\nconst serv = grafserv({ schema, preset });\n\n// Add the Grafserv instance's route handlers to the Koa app, and register\n// websockets if desired\nserv.addTo(app, server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\n// Start the Koa server\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Initializing Grafserv Instance in Nuxt with TypeScript\nDESCRIPTION: This snippet shows how to create a shared Grafserv server instance for a Nuxt application using TypeScript. It imports the required schema and preset configuration, then uses the 'grafserv' function from the 'grafserv/h3/v1' package to construct the server instance. This server instance ('serv') is intended to be used across multiple API route handlers for consistent GraphQL handling. Dependencies include 'grafserv', a schema definition, and a preset configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/nuxt.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { grafserv } from \\\"grafserv/h3/v1\\\";\nimport preset from \\\"./graphile.config\\\";\nimport schema from \\\"./schema.mjs\\\";\n\n// Create a shared Grafserv instance\nexport const serv = grafserv({ schema, preset });\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile with Basic Options in TypeScript\nDESCRIPTION: This TypeScript example demonstrates extending the `PostGraphileAmberPreset` and configuring specific options. It sets the port number within the `grafserv` scope and defines a database connection using `makePgService` within the `pgServices` scope. It requires `postgraphile` for types and the `pg` adaptor.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport \"postgraphile\"; // To import the TypeScript types\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n  grafserv: { port: 5678 },\n  pgServices: [makePgService({ connectionString: \"postgres:///my_db\" })],\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming Mutation and Result Field using JSON5 Smart Tags File\nDESCRIPTION: Configures PostGraphile via `postgraphile.tags.json5` for the `authenticate` procedure (custom mutation function). It renames the mutation field to `login` using `@name` and specifies that the result field within the mutation payload should be named `token` using `@resultFieldName`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_8\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    procedure: {\n      authenticate: {\n        tags: {\n          name: \"login\",\n          resultFieldName: \"token\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Root Query Field using Low-Level Plugin Hooks (TypeScript)\nDESCRIPTION: This snippet shows how to create a Graphile Build plugin using the low-level hooks API to add a root query field. It defines a plugin `AddHttpBinPlugin` that hooks into `GraphQLObjectType_fields`. Inside the hook, it checks if the current object is the root query (`isRootQuery`). If so, it uses the `build` object utilities (`extend`, `getTypeByName`) to add the `httpBinHeaders` field. The resolver fetches data from 'https://httpbin.org/headers' and handles potential `jsonScalarAsString` options, returning either parsed JSON or raw text.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending-raw.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport fetch from \"node-fetch\";\n\nconst AddHttpBinPlugin = {\n  name: \"AddHttpBinPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(\n        fields, // Input object - the fields for this GraphQLObjectType\n        build, // Build object - handy utils\n        context, // Context object - used for filtering\n      ) {\n        const {\n          extend,\n          getTypeByName,\n          options: { jsonScalarAsString },\n        } = build;\n        const {\n          scope: { isRootQuery },\n        } = context;\n        if (!isRootQuery) {\n          // This isn't the object we want to modify:\n          // return the input object unmodified\n          return fields;\n        }\n\n        // We don't want to introduce a new JSON type as that will clash,\n        // so let's find the JSON type that other fields use:\n        const JSONType = getTypeByName(\"JSON\");\n\n        return extend(fields, {\n          httpBinHeaders: {\n            type: JSONType,\n            async resolve() {\n              const response = await fetch(\"https://httpbin.org/headers\");\n              if (jsonScalarAsString) {\n                // We've been told to provide JSON scalars in stringified format\n                return response.text();\n              } else {\n                // By default, we can just return a dynamic \"JSON\" scalar\n                return response.json();\n              }\n            },\n          },\n        });\n      },\n    },\n  },\n};\n\nexport default AddHttpBinPlugin;\n```\n\n----------------------------------------\n\nTITLE: Declaring Unique Constraints with Smart Tag in JSON5 - JSON5\nDESCRIPTION: Attaches virtual unique constraints to a view by specifying the 'unique' tag in a JSON5 configuration object. Can be a string for single column, or array for multiple/composite uniqueness. Prerequisite: the referenced columns must exist on the view. Inputs: unique column(s). Used by PostGraphile to mark GraphQL fields as unique, but does not enforce uniqueness at the DB level.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_20\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_view: {\n        tags: {\n          unique: [\"id\", \"org_id,slug\"],\n          // or:\n          //   unique: \"id\"\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Graphile Worker Task in JavaScript\nDESCRIPTION: Provides an example of a Graphile Worker task implementation in JavaScript (Node.js). This module exports an asynchronous function that receives the job payload and helper utilities. In this case, it extracts the 'name' from the payload and uses the `helpers.logger` to log a greeting. This file (e.g., `tasks/hello.js`) would be loaded by the Graphile Worker instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/background-tasks.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// tasks/hello.js\nmodule.exports = async (payload, helpers) => {\n  const { name } = payload;\n  helpers.logger.info(`Hello, ${name}`);\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating pgSettings Injection to V5 Configuration with grafast.context - TypeScript\nDESCRIPTION: This TypeScript snippet shows how to migrate dynamic pgSettings (settings per request) into the context object using the grafast.context configuration in PostGraphile V5. It extracts the HTTP request from the node context, invokes the pgSettings handler on it, and returns an object with the pgSettings property for downstream usage. The handler must be adapted from V4's form or redefined. The expected input is the V4 pgSettings function and request context; the output is an object compatible with gabast/Graphile context expectations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req } = ctx.node ?? {};\n      return {\n        pgSettings: pgSettings(req);\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile Temporarily with npx (Bash)\nDESCRIPTION: Demonstrates how to execute the `pgl` command (beta version) using `npx`, which avoids a permanent installation. It applies the 'amber' preset (`-P pgl/amber`), enables explain mode (`-e`), and connects to a PostgreSQL database specified by the connection string (`-c postgres:///mydb`). Requires Node.js and `npx` to be available. The connection string and schema name (`-s`) should be adjusted based on the user's specific database setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx pgl@beta -P pgl/amber -e -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Metadata using YAML Front Matter\nDESCRIPTION: This YAML front matter block defines metadata for a documentation page. It sets the 'layout' to 'page', specifies the URL 'path', sets the page 'title' to 'Database Function Gallery', and includes a custom flag 'showExamples' set to 'functions'. This metadata is typically used by static site generators to render the page.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/function-gallery.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: page\npath: /postgraphile/function-gallery/\ntitle: Database Function Gallery\nshowExamples: functions\n---\n```\n\n----------------------------------------\n\nTITLE: Defining Global Behavior in a PostGraphile Plugin (String Method) (JavaScript)\nDESCRIPTION: Illustrates how a PostGraphile plugin author can define global behavior modifications using a simple string. This plugin, `FavourListsPlugin`, prepends the behavior string `\"-connection +list\"` to the existing global behaviors, effectively suggesting lists over connections without overriding user-specific `defaultBehavior`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/behavior.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst FavourListsPlugin = {\n  name: \"FavourListsPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    globalBehavior: \"-connection +list\",\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Field Value from a Step Row (TypeScript)\nDESCRIPTION: This snippet retrieves the value of a database column ('organization_id') from an already-selected row ($user), using the get method on the step. It relies on the step being a PgSelectSingleStep and provides the column name as key. The returned step can be used as input to further querying steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $organizationId = $user.get(\"organization_id\");\n```\n\n----------------------------------------\n\nTITLE: Inefficiently Archiving Forums with Loops in PostgreSQL (PL/pgSQL)\nDESCRIPTION: Defines a PL/pgSQL function `archive_forums` that takes an array of forum IDs. It iterates through the IDs using `FOREACH`, executing separate `UPDATE` statements for `forums` and `posts` within the loop. This approach is explicitly marked as inefficient ('BAD!') due to the high number of individual SQL queries generated, especially with many input IDs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"BAD! Don't do this!\"\ncreate function archive_forums(forum_ids int[]) returns void as $$\ndeclare\n  target_forum_id int;\nbegin\n  /* BAD: looping should be avoided! */\n  foreach target_forum_id in array forum_ids loop\n    update forums set is_archived = true where id = target_forum_id;\n    update posts set is_archived = true where forum_id = target_forum_id;\n  end loop;\nend;\n$$ language plpgsql volatile;\n```\n```\n\n----------------------------------------\n\nTITLE: Switching Between PostGraphile Schemas on a Single Endpoint in Express (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates routing requests to different PostGraphile instances based on request properties, all served from a single endpoint using Express. It initializes separate PostGraphile instances ('admin', 'user') with distinct database connections, mounts them onto separate internal Express handlers, and uses a custom middleware to inspect the request (e.g., `req.user.isAdmin`) to dynamically invoke the correct handler, effectively switching the active GraphQL schema. Note that websockets and subscriptions are explicitly disabled in this example as potentially incompatible with this setup. Dependencies include `express`, `postgraphile`, `grafserv`, and a custom `graphile.config.mjs` preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/multiple-schemas.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// TODO: this is untested!\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport postgraphile from \"postgraphile\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport userPreset from \"./graphile.config.mjs\";\n\n// Create an express app\nconst app = express();\n// (Add any Express middleware you want here.)\n\n// Create a Node HTTP server, mounting Express into it\nconst server = createServer(app);\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// A preset shared between our services which disables websockets and\n// subscriptions since they are not supported\nconst commonPreset = {\n  extends: [userPreset],\n  grafserv: { websockets: false },\n  disablePlugins: [\"SubscriptionPlugin\"],\n};\n\n// The services we wish to switch between\nconst services = {\n  admin: {\n    handler: express(),\n    pgl: postgraphile({\n      extends: [commonPreset],\n      pgServices: [makePgService({ connectionString: \"postgres:///admin\" })],\n    }),\n  },\n  user: {\n    handler: express(),\n    pgl: postgraphile({\n      extends: [commonPreset],\n      pgServices: [makePgService({ connectionString: \"postgres:///user\" })],\n    }),\n  },\n};\n\n// Mount the PostGraphile instances into the handlers\nfor (const { handler, pgl } of Object.values(services)) {\n  const serv = pgl.createServ(grafserv);\n  serv.addTo(handler);\n}\n\n// Add a custom middleware to switch between these handlers\napp.use((req, res, next) => {\n  const isAdmin = req.user?.isAdmin;\n  if (isAdmin) {\n    services.admin.handler(req, res, next);\n  } else {\n    services.user.handler(req, res, next);\n  }\n});\n\n// Start the Express server\nserver.listen(userPreset.grafserv?.port ?? 5678);\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Custom 'containsPostsByUserId' Condition in GraphQL\nDESCRIPTION: This GraphQL query shows how to use the custom `containsPostsByUserId` condition (defined by the plugin in Example 2) on the `allForums` field. It filters the results to return only forums that contain posts made by the user with ID 1.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-condition-plugin.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery ForumsContainingPostsByUser1 {\n  allForums(condition: { containsPostsByUserId: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Loading a Single Record Using loadOne in Graphile (TypeScript)\nDESCRIPTION: These TypeScript snippets show the standard and advanced forms for calling loadOne, a utility for single-record data fetching. They demonstrate different argument combinations: passing a specifier step with an optional unary step, ioEquivalence, and a callback. The snippets highlight loadOne's flexibility to match different fetch and resolve patterns within Graphile plan construction. Dependencies include plan step constructors and fetch callbacks.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Basic usage:\nconst $record = loadOne($spec, callback);\n\n// Advanced usage:\nconst $record = loadOne($spec, $unaryStep, ioEquivalence, callback);\nconst $record = loadOne($spec, $unaryStep, callback);\nconst $record = loadOne($spec, ioEquivalence, callback);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Specific PostgreSQL Databases using Bash\nDESCRIPTION: Demonstrates connecting to specific PostgreSQL databases using the `psql` client with different connection string formats. The first example connects to a local database named `testdb` using the shorthand URI. The second example uses a full connection string to connect to a database named `somedb` on a potentially remote host `somehost` at port `2345`, authenticating as `user` with the specified `password`. Requires the `psql` client tool.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ psql postgres:///testdb # Connects to the `testdb` database on your local machine\n$ psql \"postgres://user:password@somehost:2345/somedb\"  # Connects to the `somedb` database at `postgres://somehost:2345` using login with `user` and `password`\n```\n\n----------------------------------------\n\nTITLE: Creating a Logged-in User Field with PostgreSQL Function (SQL)\nDESCRIPTION: Defines a SQL function named 'viewer' that retrieves the current logged-in user from the 'users' table by leveraging the auxiliary 'current_user_id()' function which is assumed to extract the user ID from the authentication context (e.g., JWT or session). This snippet is intended for use in PostGraphile to expose the current user in the GraphQL schema. The function requires the 'current_user_id()' function to be available and the 'users' table to have a matching 'id'. It returns a row of type 'users' and must be defined in a PostgreSQL database with a suitable search_path.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate function viewer()\nreturns users\nas $$\n  select *\n  from users\n  where id = current_user_id();\n  /*\n   * current_user_id() is a function\n   * that returns the logged in user's\n   * id, e.g. by extracting from the JWT\n   * or indicated via pgSettings.\n   */\n$$ language sql stable set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Applying Virtual @foreignKey via JSON5 Configuration - Single Key\nDESCRIPTION: This JSON5 snippet adds a virtual foreign key constraint to 'my_materialized_view' using the 'foreignKey' smart tag. It specifies that (key_1, key_2) columns reference another table (key_1, key_2). Dependencies are PostGraphile and JSON5-based configuration loading. Useful for relating materialized views to other tables for GraphQL schema generation and join optimization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_17\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)\",\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Subscribing to \"listen\" Topic Using GraphQL - GraphQL\nDESCRIPTION: Performs a GraphQL subscription to the listen field with a specified topic (\"hello\"), leveraging PostGraphile's simple subscriptions. Requires a GraphQL client capable of handling subscriptions. No parameters beyond the topic; expected output includes the related nodeId and details of nodes of type Foo matching the event. Waits for event triggers from the backend before returning data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_19\n\nLANGUAGE: GraphQL\nCODE:\n```\nsubscription {\n  listen(topic: \"hello\") {\n    relatedNodeId\n    relatedNode {\n      nodeId\n      ... on Foo {\n        id\n        title\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Generated GraphQL Product Type\nDESCRIPTION: Example GraphQL schema representation of the `Product` type automatically generated by PostGraphile from the corresponding `product` database table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\ntype Product {\n  id: UUID!\n  name: String!\n  priceInUsCents: Int!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Fields to GraphQL Context - JavaScript\nDESCRIPTION: This code defines the JavaScript object `postgraphileOptions` with an `additionalGraphQLContextFromRequest` async function. The function, receiving the HTTP `req` and `res` objects, returns custom fields (such as user information, header-access helpers, and privileged DB pools) to be merged into each GraphQL resolver's context. This approach enhances resolver data access and facilitates application logic, relying on Koa/Express compatibility and the presence of user and database pool objects. Care should be taken not to overwrite internal PostGraphile context keys.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_15\n\nLANGUAGE: js\nCODE:\n```\nconst postgraphileOptions = {\n  // ... other options here ...\n\n  async additionalGraphQLContextFromRequest(req, res) {\n    // You can perform asynchronous actions here if you need to; for example\n    // looking up the current user in the database.\n\n    // Return here things that your resolvers need\n    return {\n      // Return the current user from Passport.js or similar\n      user: req.user,\n\n      // Add a helper to get a header\n      getHeader(name) {\n        return req.get(name);\n      },\n\n      // Give access to the database-owner PostgreSQL pool, for example to\n      // perform privileged actions\n      rootPgPool,\n    };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom `registerUser` mutation in TypeScript\nDESCRIPTION: Provides a PostGraphile plugin using `makeExtendSchemaPlugin` to define a custom `registerUser` mutation. The implementation includes defining input (`RegisterUserInput`) and payload (`RegisterUserPayload`) types. The mutation plan uses `withPgClientTransaction` from `@dataplan/pg` to wrap database insertion (`INSERT INTO app_public.users`) and a side effect (simulated email sending) within a single transaction, ensuring atomicity. The payload resolvers demonstrate how to return the newly created user correctly using the appropriate Grafast step (`users.get`) and handle other payload fields like `query`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { access, constant, object } from \"postgraphile/grafast\";\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\n\nexport const MyRegisterUserMutationPlugin = makeExtendSchemaPlugin((build) => {\n  const { sql } = build;\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n  return {\n    typeDefs: gql`\n      input RegisterUserInput {\n        name: String!\n        email: String!\n        bio: String\n      }\n\n      type RegisterUserPayload {\n        user: User\n        query: Query\n      }\n\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, fieldArgs) {\n          const $input = fieldArgs.getRaw(\"input\");\n          const $user = withPgClientTransaction(\n            executor,\n            $input,\n            async (pgClient, input) => {\n              // Our custom logic to register the user:\n              const {\n                rows: [user],\n              } = await pgClient.query({\n                text: `\n                  INSERT INTO app_public.users (name, email, bio)\n                  VALUES ($1, $2, $3)\n                  RETURNING *`,\n                values: [input.name, input.email, input.bio],\n              });\n\n              // Send the email. If this fails then the error will be caught\n              // and the transaction rolled back; it will be as if the user\n              // never registered\n              await mockSendEmail(\n                input.email,\n                \"Welcome to my site\",\n                `You're user ${user.id} - thanks for being awesome`,\n              );\n\n              // Return the newly created user\n              return user;\n            },\n          );\n\n          // To allow for future expansion (and for the `clientMutationId`\n          // field to work), we'll return an object step containing our data:\n          return object({ user: $user });\n        },\n      },\n\n      // The payload also needs plans detailing how to resolve its fields:\n      RegisterUserPayload: {\n        user($data) {\n          const $user = $data.get(\"user\");\n          // It would be tempting to return $user here, but the step class\n          // is not compatible with the auto-generated `User` type, so\n          // errors will occur. We must ensure that we return a compatible\n          // step, so we will retrieve the relevant record from the database:\n\n          // Get the '.id' property from $user:\n          const $userId = access($user, \"id\");\n\n          // Return a step representing this row in the database.\n          return users.get({ id: $userId });\n        },\n        query($user) {\n          // Anything truthy should work for the `query: Query` field.\n          return constant(true);\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Sorting in Graphile via @sortable Comment - SQL\nDESCRIPTION: This code snippet demonstrates how to apply the @sortable smart comment to PostgreSQL functions so they are exposed with sorting capabilities in the PostGraphile-generated GraphQL schema. The provided SQL comments target both a plain function and a computed column function. Dependencies are standard PostgreSQL, functions that return SETOF a table-like type or scalars, and the PostGraphile framework. Inputs are SQL COMMENT statements, outputs are availability of orderBy arguments in the GraphQL API. Notable constraint: behavior depends on function return types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_27\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@sortable';\ncomment on function users_foo(users) is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Extending Product Type with Currency Conversion Field in JavaScript\nDESCRIPTION: JavaScript code using PostGraphile's `makeExtendSchemaPlugin` to add a `priceInAuCents` field to the `Product` type. It retrieves the base price using `$product.get(\"price_in_us_cents\")` and uses `loadOne` with a custom `convertUsdToAud` async function for efficient batch currency conversion.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { loadOne } from \"postgraphile/grafast\";\nimport { getExchangeRate } from \"./myBusinessLogic.mjs\";\n\n// highlight-start\nasync function convertUsdToAud(values) {\n  const usdToAud = await getExchangeRate(\"USD\", \"AUD\");\n  return values.map((usd) => usd * usdToAud);\n}\n// highlight-end\n\nexport const MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n  return {\n    typeDefs: gql`\n      extend type Product {\n        priceInAuCents: Int!\n      }\n    `,\n    plans: {\n      Product: {\n        priceInAuCents($product) {\n          // highlight-next-line\n          const $cents = $product.get(\"price_in_us_cents\");\n          // highlight-next-line\n          return loadOne($cents, convertUsdToAud);\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Function Signature and Type Declarations for makeJSONPgSmartTagsPlugin (TypeScript)\nDESCRIPTION: Specifies the function signature for makeJSONPgSmartTagsPlugin, including its parameters, types, and the structure of the JSONPgSmartTags object. The code details required and optional arguments as well as the subscription mechanism for live configuration updates. These types are necessary for users implementing custom smart tags plugins or leveraging advanced TypeScript support in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nfunction makeJSONPgSmartTagsPlugin(\n  jsonOrThunk: ThunkOrDirect<PromiseOrDirect<JSONPgSmartTags | null>>,\n  subscribeToJSONUpdatesCallback?: SubscribeToJSONPgSmartTagsUpdatesCallback | null,\n  details?: { name?: string; description?: string; version?: string },\n): GraphileConfig.Plugin;\n\ntype JSONPgSmartTags = {\n  version: 1;\n  config: {\n    [kind in PgSmartTagSupportedKinds]?: {\n      [identifier: string]: {\n        tags?: PgSmartTagTags;\n        description?: string;\n        attribute?: {\n          [attributeName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n        constraint?: {\n          [constraintName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n      };\n    };\n  };\n};\n\ntype SubscribeToJSONPgSmartTagsUpdatesCallback = (\n  cb: UpdateJSONPgSmartTagsCallback | null,\n) => void | Promise<void>;\n```\n\n----------------------------------------\n\nTITLE: Passing Options to graphile-build Schema Builder (JavaScript)\nDESCRIPTION: Demonstrates building a GraphQL schema using `graphile-build`. It passes the `defaultPlugins` and an options object `{ nodeIdFieldName: \"flibble\" }` to `buildSchema`. This option overrides the default field name ('id') for the Node interface identifier. The resulting schema is then printed to the console.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugin-options.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst { buildSchema, defaultPlugins } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nbuildSchema(defaultPlugins, { nodeIdFieldName: \"flibble\" }).then((schema) => {\n  console.log(printSchema(schema));\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Movie Ratings OrderBy via orderByAscDesc â€“ TypeScript\nDESCRIPTION: Implements a plugin const customOrderBy for sorting movies by average review rating, using orderByAscDesc in TypeScript. A correlated SQL subquery calculates the average rating for each movie from the 'movie_reviews' table, with the 'nulls' option set to 'last' so movies with no ratings appear at the end of sorted lists. Depends on PostGraphile infrastructure, access to the sql utility, and proper table modeling. Designed for advanced GraphQL API ordering logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst customOrderBy = orderByAscDesc(\n  \"RATING\",\n  ($select) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"movie_reviews\"));\n    return sql`(\n      select avg(${sqlIdentifier}.rating)\n      from app_public.movie_reviews as ${sqlIdentifier}\n      where ${sqlIdentifier}.movie_id = ${$select.alias}.id\n    )`;\n  },\n  { nulls: \"last\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Getting the Executor from a Database Resource in @dataplan/pg (TypeScript)\nDESCRIPTION: Shows an alternative way to get a database executor by accessing the `executor` property of a known `@dataplan/pg` resource (e.g., `channels.executor`). This is useful when the executor name is unknown or when working directly with a resource representing the target database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst executor = channels.executor;\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom Subscriptions via PostGraphile CLI in Shell\nDESCRIPTION: This shell command demonstrates how to start the PostGraphile server with custom subscriptions enabled using the command-line interface. It loads the necessary `@graphile/pg-pubsub` server plugin using `--plugins`, appends the custom schema plugin (`MySubscriptionPlugin.js`) using `--append-plugins`, enables the WebSocket server for subscriptions with `--subscriptions`, and specifies the database connection using `-c mydb`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npostgraphile \\\n  --plugins @graphile/pg-pubsub \\\n  --append-plugins `pwd`/MySubscriptionPlugin.js \\\n  --subscriptions \\\n  -c mydb\n```\n\n----------------------------------------\n\nTITLE: Accessing Table and Column Metadata with Graphile Accessors (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to use accessor functions on introspection result objects from Graphile. It demonstrates how to find a table by name, retrieve its attributes (columns), access a single attribute by name, and get that column's description. Requires Graphile's introspection result object, and presupposes accessor functions are available on the result. Parameters include table and column names used in the lookup. Outputs are references to schema metadata objects and their descriptions. Performance is optimized by caching findings after first access.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-introspection/accessors.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myTable = introspection.classes.find((rel) => rel.relname === \"my_table\");\nconst myTableAttributes = myTable.getAttributes();\nconst myColumn = myTable.getAttribute({ name: \"my_column\" });\nconst myColumnDescription = myColumn.getDescription();\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for Users by Organization Id - GraphQL\nDESCRIPTION: Provides a sample GraphQL query requesting users by organization ID, including nested user and organization fields. Intended to show the potential use case for plan resolvers utilizing loadMany in TypeScript. Input is an organization ID; output is a list of users and their organizations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_9\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  usersByOrganizationId(id: Int!) {\n    id\n    name\n    organization {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Newly Created PostgreSQL Database using Bash\nDESCRIPTION: Connects to the previously created 'mydb' database using the `psql` client and the shorthand connection URI `postgres:///mydb`. The output shows the `psql` version, help hint, and the interactive SQL prompt (`=#`), confirming a successful connection to the specified database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///mydb\"\npsql (14.*)\nType \"help\" for help.\n\n=#\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile with JWT and RLS Support (TypeScript)\nDESCRIPTION: Provides a PostGraphile configuration (`graphile.config.mjs`) using TypeScript. It utilizes the `PostGraphileAmberPreset` and `PgLazyJWTPreset` for streamlined setup. It specifies the JWT type (`forum_example.jwt_token`), the JWT secret (placeholder 'keyboard_kitten' requires replacement), and sets up a context function to define default PostgreSQL settings (`role: 'forum_example_anonymous'`) which can be overridden by settings derived from a valid JWT.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_43\n\nLANGUAGE: ts\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { PgLazyJWTPreset } from \"postgraphile/presets/lazy-jwt\";\n\nexport default {\n  extends: [PostGraphileAmberPreset, PgLazyJWTPreset],\n  gather: {\n    pgJwtTypes: \"forum_example.jwt_token\",\n  },\n  schema: {\n    pgJwtSecret: \"keyboard_kitten\", // REPLACE THIS!\n  },\n  grafast: {\n    context(requestContext, args) {\n      return {\n        pgSettings: {\n          role: \"forum_example_anonymous\",\n          // JWT may override the role:\n          ...args.contextValue?.pgSettings,\n        },\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL-Compliant Auth Error Response - JSON\nDESCRIPTION: This snippet illustrates a typical error response sent to GraphQL clients when no authorization token is provided or JWT validation fails. It is structured to match GraphQL error specifications, making it easier for front-end clients to handle authentication errors programmatically. It shows how the system will respond to failed authentication in practice.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"errors\": [\n    {\n      \"message\": \"No authorization token was found\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an IMMUTABLE PostgreSQL Function\nDESCRIPTION: Defines a function explicitly marked as `IMMUTABLE`. This is stricter than `STABLE`, indicating the function doesn't modify the database and *always* returns the same result for the same arguments, without relying on database lookups or external state. `IMMUTABLE` functions can be heavily optimized and are suitable for PostGraphile queries or computed columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql IMMUTABLE;\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Computed Column via PostgreSQL Function - SQL\nDESCRIPTION: Defines a function 'users_greet' which adds an exposed 'greet(greeting: String!)' computed column to the GraphQL type for a user. The function accepts both the user record and an exposed greeting parameter, returning a personalized message. Inputs are the user table row and a greeting (text); the output is the concatenated greeting. This snippet shows how to expose arguments for computed columns via function parameters.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n-- Creates `User.greet(greeting: String!)` string field\ncreate function my_schema.users_greet(\n  u my_schema.users,  --- required table type parameter, unexposed\n  greeting text       --- additional parameter, will be exposed\n) returns text as $$\n  select greeting || ', ' || u.first_name || ' ' || u.last_name || '!';\n$$ language sql stable strict;\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Live Queries via CLI (Shell)\nDESCRIPTION: Demonstrates enabling live queries using the PostGraphile command-line interface. It requires the `--live` flag, an `--owner-connection` string providing superuser or database owner privileges for accessing the replication stream, and appending the `--append-plugins @graphile/subscriptions-lds` option to load the realtime provider plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npostgraphile \\\n  --connection postgres://postgraphile_user:postgraphile_pass@host/db \\\n  --live \\\n  --owner-connection postgres://db_owner:db_owner_pass@host/db \\\n  --append-plugins @graphile/subscriptions-lds \\\n  ...\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Steps to loadMany Using list() - TypeScript\nDESCRIPTION: Demonstrates passing multiple input steps to loadMany via the list() combinator, allowing callback to receive batched tuples of scalar values for complex data loading. Useful when multiple unique keys are required for batch fetching. Inputs are the values of $a, $b, and $c; outputs are determined by the callback's implementation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $result = loadMany(list([$a, $b, $c]), callback);\n```\n\n----------------------------------------\n\nTITLE: Using Ruru GraphiQL via Command Line (bash)\nDESCRIPTION: Demonstrates how to launch the Ruru GraphiQL interface pointing to a local GraphQL server using npx. The command connects to the default PostGraphile Grafast-powered HTTP endpoint. Requires Node.js, npx, and at least local access to the /graphql API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nnpx ruru@beta -PSe http://localhost:5678/graphql\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Functions - SQL\nDESCRIPTION: This snippet demonstrates how to add a smart tag to a PostgreSQL function via a COMMENT, enabling custom naming for the generated GraphQL field and prose documentation. Requires matching argument types to disambiguate the function signature. Input: COMMENT ON FUNCTION. Output: function is exposed in PostGraphile schema with custom attributes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function my_function(arg_type_1, arg_type_2) is\\n  E'@name my_new_function_name\\\\nDocumentation here.';\n```\n\n----------------------------------------\n\nTITLE: Building and Printing a GraphQL Schema from a Preset (JavaScript)\nDESCRIPTION: This snippet shows how to import a custom preset and use it to build a GraphQL schema using the Graphile Build framework. It imports the necessary 'buildSchema' and 'printSchema' methods, loads the preset file, creates the schema asynchronously, and prints it. This can be incorporated into scripts or initialization code for schema building automation. Requires 'graphile-build' and 'graphql' packages and a valid preset file.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { buildSchema } from \"graphile-build\";\nimport { printSchema } from \"graphql\";\nimport preset from \"./graphile.config.mjs\";\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n```\n\n----------------------------------------\n\nTITLE: Adding Primary Key Tag via Smart Comment - SQL\nDESCRIPTION: Shows how to declare a primary key (single or composite) for a view using SQL comments and PostGraphile smart tags. The '@primaryKey' tag is applied to 'my_view' with either one or multiple columns named. Prerequisite: entity must be a view. This is trusted but not enforced unique constraint by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_16\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on view my_view is E'@primaryKey id';\n-- or\ncomment on view my_view is E'@primaryKey type,identifier';\n```\n\n----------------------------------------\n\nTITLE: Building a Basic Smart Tags Plugin Inline in JavaScript for PostGraphile\nDESCRIPTION: This JavaScript snippet demonstrates the creation of an inline PostGraphile smart tags plugin without reading from the file system, suitable for environments where filesystem access is restricted (like webpack). It uses makeJSONPgSmartTagsPlugin to directly inject the tags configuration as a JavaScript object. The returned plugin can be included in the plugins array of your PostGraphile setup. The key dependency is postgraphile/utils, and the plugin is configured entirely in memory.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags-file.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeJSONPgSmartTagsPlugin } from \"postgraphile/utils\";\n\nconst MySmartTagsPlugin = makeJSONPgSmartTagsPlugin({\n  version: 1,\n  config: {\n    class: {\n      post: {\n        tags: {\n          omit: \"update\",\n        },\n      },\n    },\n  },\n});\n\nexport default {\n  // ...\n  plugins: [MySmartTagsPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring Node.js App Startup Script for Express/PostGraphile - JSON\nDESCRIPTION: This JSON snippet configures the start script for a Node.js project using an Express app with PostGraphile as a library, specifying the entry point for application execution. Its only dependency is that 'src/index.js' exists and is implemented as the server entry point. Input: standard package.json with a 'start' script. Output: enables running 'npm start' to launch the server. Limitation: all file paths and referenced scripts must exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"start\": \"node src/index.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating PostGraphile with Preset Configuration (TypeScript)\nDESCRIPTION: This snippet initializes the PostGraphile engine by passing in the imported configuration preset. The returned PostGraphile instance (pgl) provides helper methods for further server integration. Dependencies: a valid preset configuration and the postgraphile package. The result is an instance ready for adaptor/server binding.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Synchronous Query Execution with grafastSync - TypeScript\nDESCRIPTION: Demonstrates executing a simple GraphQL query synchronously using grafastSync. The schema object is passed in along with a raw GraphQL query string. Dependencies include grafast and a previously built schema. Expected input: a schema and query; expected output: a JS object containing result data.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { grafastSync } = require(\"grafast\");\n\nconst result = grafastSync({\n  schema,\n  source: /* GraphQL */ `\n    {\n      addTwoNumbers(a: 40, b: 2)\n    }\n  `,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Understanding Step Class Changes: ExecutableStep Renamed to Step\nDESCRIPTION: Explains the renaming of the `ExecutableStep` base class to simply `Step` in Grafast. This consolidation occurred because `ModifierStep` (used for plan-time input field modifications) was removed and replaced by the runtime `Modifier` system, making the distinction between `BaseStep` and `ExecutableStep` unnecessary. An `ExecutableStep` export is temporarily retained for backward compatibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/news/2025-03-24-grafast-0.1-beta.21.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nExecutableStep\n```\n\nLANGUAGE: javascript\nCODE:\n```\nStep\n```\n\nLANGUAGE: javascript\nCODE:\n```\nModifierStep\n```\n\nLANGUAGE: javascript\nCODE:\n```\nModifier\n```\n\nLANGUAGE: javascript\nCODE:\n```\nBaseStep\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Plugin via Yarn - Shell Script\nDESCRIPTION: Demonstrates the installation of a beta version of the PostGraphile connection-filter plugin using yarn. Requires Node.js, yarn, and access to npm or a compatible package registry. The command installs the specified plugin at the @beta tag, ensuring that users receive the latest beta functionality for advanced connection filtering. Outputs updated package.json dependencies and installs the plugin for use in the codebase.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/index.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn add postgraphile-plugin-connection-filter@beta\n```\n\n----------------------------------------\n\nTITLE: Querying a Computed Column in GraphQL - GraphQL\nDESCRIPTION: Illustrates how a Graphile-generated GraphQL query can request a computed column ('fullName') alongside other properties for a 'person' entity. The query references the computed column without requiring clients to be aware that it is backed by a function, not a physical database column. This pattern applies to any computed column mapped by Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  personById(id: â€¦) {\n    # nodeId, id, ...\n\n    fullName # A computed column, but the client doesnâ€™t even know!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Subscription Query in GraphQL (JavaScript)\nDESCRIPTION: This code example demonstrates a GraphQL subscription operation for PostGraphile, showing how a client can receive new chat messages for a particular channel in real time. The snippet requires a GraphQL subscription-capable server and a client with subscription support. The parameter 'channel' filters messages to only those for channel 27; returned fields include id, message, author details, and timestamp. This operation is limited to new events (such as message addition) and will not trigger on edits or related updates.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/realtime.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nsubscription {\n  chatMessageAdded(channel: 27) {\n    id\n    message\n    author { id name avatarUrl }\n    timestamp\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Reusable Query Execution Function with `grafast()` in TypeScript\nDESCRIPTION: Provides a full example of an asynchronous TypeScript function `executeQuery` that encapsulates obtaining the schema/preset and executing a GraphQL query using `grafast()`. It takes request context, query source, variables, and operation name as input.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport { grafast } from \"postgraphile/grafast\";\nimport preset from \"./graphile.config.js\";\n\n// Make a new PostGraphile instance:\nconst pgl = postgraphile(preset);\n// Or import a shared instance:\n//   import { pgl } from \"./pgl.js\"\n\n/**\n * Given a request context `requestContext`, GraphQL query text `source` and\n * optionally variable values and operation name, execute the given GraphQL\n * operation against our schema and return the result.\n */\nexport async function executeQuery(\n  requestContext: Partial<Grafast.RequestContext>,\n  source: string,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n) {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n  return await grafast({\n    schema,\n    source,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Inline Plugin Tweaks for GraphiQL Branding in JavaScript\nDESCRIPTION: Illustrates how to make inline modifications using the server plugin system when using PostGraphile as middleware. This example defines a `graphiqlBrandingTweak` object that hooks into `postgraphile:graphiql:html` to modify the HTML of the GraphiQL interface, specifically changing the branding text by replacing HTML content and adding CSS.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n/**\n * This plugin override changes the branding piece of graphiql.\n * /\nconst graphiqlBrandingTweak = {\n  [\"postgraphile:graphiql:html\"](html) {\n    console.log(\"Applying GraphiQL Branding Tweak...\");\n    return html.replace(\n      \"</head>\",\n      '<style type=\"text/css\">div.topBar > div.title > div { visibility: hidden; display: none !important; } div.topBar > div.title::after { content: \"GraphiQL for MyCompany\" }</style></head>',\n    );\n  },\n};\nconst pluginHook = makePluginHook([graphiqlBrandingTweak]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Custom 'idIn' Condition Plugin in JavaScript\nDESCRIPTION: Example JavaScript code demonstrating how to use `makeAddPgTableConditionPlugin` to create a custom `idIn` condition for the `app_public.forums` table. This condition allows filtering forums by a list of provided integer primary keys using an SQL `ANY` clause.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/* TODO: test this plugin works! */\nmodule.exports = makeAddPgTableConditionPlugin(\n  \"app_public\",\n  \"forums\",\n  \"idIn\",\n  (build) => {\n    const { GraphQLList, GraphQLNonNull, GraphQLInt } = build.graphql;\n    return {\n      description: \"Filters to records matching one of these ids\",\n      // This is graphql-js for `[Int!]`; assumes you're using\n      // an integer primary key.\n      type: new GraphQLList(new GraphQLNonNull(GraphQLInt)),\n    };\n  },\n  (value, helpers, build) => {\n    const { sql, sqlTableAlias } = helpers;\n\n    // Note sqlTableAlias represents our table (app_public.forums),\n    // but because it might be requested more than once in the\n    // generated query we need to match this specific instance, so\n    // we use an alias.\n\n    // This SQL fragment will be merged into the `WHERE` clause, so\n    // it must be valid in that context.\n    return sql.fragment`${sqlTableAlias}.id = ANY (${sql.value(value)}::int[])`;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Computed Column to GraphQL Schema (GraphQL Diff)\nDESCRIPTION: Displays a diff for the addition of a computed column 'primaryEmail' of type String to the 'User' type in the schema. This is automatically picked up by PostGraphile from the registered SQL computed column. It documents the schema-level impact and no direct code execution is needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -3130,6 +3130,7 @@\n     \"\"\"\n     condition: QuizEntryCondition\n   ): QuizEntriesConnection!\n+  primaryEmail: String\n }\n\n \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Using the Graphile CLI to Inspect and Print Resolved Configuration (Shell)\nDESCRIPTION: Shows usage of the 'graphile' CLI tool (exclusive to project sponsors) to output available config options and print the fully resolved config. Assumes the 'graphile' CLI is installed and available via npx. Each command outputs either the option set or resolved preset structure in the shell for inspection, assisting in debugging or validation.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Output the options your config may contain\nnpx graphile config options\n# Print your resolved configuration\nnpx graphile config print\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Schema for Single-Table Polymorphism\nDESCRIPTION: Creates a PostgreSQL enum `polymorphic.item_type` and a table `polymorphic.single_table_items` containing shared fields and a `type` column to discriminate between different item types. This schema is intended for use with the `@interface mode:single` smart tag in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type polymorphic.item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\ncreate table polymorphic.single_table_items (\n  id serial primary key,\n\n  -- Rails-style polymorphic column\n  type polymorphic.item_type not null default 'POST'::polymorphic.item_type,\n\n  -- Shared attributes:\n  parent_id int references polymorphic.single_table_items on delete cascade,\n  root_topic_id int constraint single_table_items_root_topic_fkey references polymorphic.single_table_items on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz,\n\n  -- Attributes that may be used by one or more item subtypes.\n  title text,\n  description text,\n  note text,\n  color text\n);\n\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation Example to Trigger Subscription (GraphQL)\nDESCRIPTION: This GraphQL mutation creates a new message in a specific forum, which in turn triggers the previously-defined subscription. The client passes a structured input with the forum ID and message body; the server responds with a clientMutationId for tracking. Intended for testing real-time notification wiring in a GraphQL client or when integrating with automation. Make sure your server and triggers are properly configured to emit events before testing.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nmutation MyMutation {\n  createMessage(input: { message: { forumId: 1, body: \"Hello World!\" } }) {\n    clientMutationId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving JWT Claims from PostgreSQL Session - SQL\nDESCRIPTION: These SQL snippets show two equivalent methods for accessing the value of a previously set JWT claim in a PostgreSQL session. 'current_setting' retrieves the claim programmatically, while 'show' displays the current value in a similar fashion to environment variables. Both require the claim to be set in the session's 'jwt.claims' namespace, and will raise errors if the claim does not exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nselect current_setting('jwt.claims.user_id');\n-- Orâ€¦\nshow jwt.claims.user_id;\n\n```\n\n----------------------------------------\n\nTITLE: Documenting PostgreSQL Table and Columns using SQL\nDESCRIPTION: Adds descriptive comments to the `forum_example.person` table and its individual columns (`id`, `first_name`, `last_name`, `about`, `created_at`) using the `COMMENT ON` SQL command. This embedded documentation provides context and can be automatically utilized by database tools and libraries like PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.person is 'A user of the forum.';\ncomment on column forum_example.person.id is 'The primary unique identifier for the person.';\ncomment on column forum_example.person.first_name is 'The personâ€™s first name.';\ncomment on column forum_example.person.last_name is 'The personâ€™s last name.';\ncomment on column forum_example.person.about is 'A short description about the user, written by the user.';\ncomment on column forum_example.person.created_at is 'The time this person was created.';\n```\n\n----------------------------------------\n\nTITLE: Checking Password and Returning JWT or Null (PL/pgSQL)\nDESCRIPTION: Performs a password comparison using 'crypt' and conditionally returns a JWT composite or null. This part of the overall authentication process ensures that only correct credentials yield a valid token. Requires the 'pgcrypto' extension for crypt. Inputs: plaintext password and account record; output: composite JWT token or null.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_35\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\nif account.password_hash = crypt(password, account.password_hash) then\n  return ('forum_example_person', account.person_id)::forum_example.jwt_token;\nelse\n  return null;\nend if;\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile Server Startup Output\nDESCRIPTION: Shows typical console output indicating that the PostGraphile server has started successfully. It specifies the port (5678 in this example) and the local URL (`http://127.0.0.1:5678/graphql`) where the GraphQL endpoint is being served.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nServer listening on port 5678 at http://127.0.0.1:5678/graphql\n```\n\n----------------------------------------\n\nTITLE: Adding Foreign Key Constraint after Table Creation in SQL\nDESCRIPTION: Illustrates adding a named foreign key constraint (`users_organization_id_fkey`) to an existing `users` table using `ALTER TABLE ... ADD CONSTRAINT`. This constraint links the `organization_id` column in the `users` table to the primary key of the `organizations` table. The `ON DELETE CASCADE` behavior specifies that deleting a referenced organization row should also delete referencing user rows. An index is also created on the `users` table's `organization_id` column.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/relations.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nALTER TABLE users\n  ADD CONSTRAINT users_organization_id_fkey\n  FOREIGN KEY (organization_id)\n  REFERENCES organizations\n  ON DELETE CASCADE;\nCREATE INDEX ON users (organization_id);\n```\n\n----------------------------------------\n\nTITLE: Archiving Forums Efficiently Using a CTE in PostgreSQL (SQL)\nDESCRIPTION: Defines an SQL function `archive_forums` that archives forums and their associated posts using a single query with a Common Table Expression (CTE). It first updates the `forums` table based on the input `forum_ids`, returning the updated IDs in the `updated_forums` CTE. Then, it updates the `posts` table by joining with the `updated_forums` CTE, ensuring atomicity and efficiency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"Single query example\"\ncreate function archive_forums(forum_ids int[]) returns void as $$\n  with updated_forums as (\n    update forums\n    set is_archived = true\n    where id = ANY(forum_ids)\n    returning id\n  )\n    update posts\n    set is_archived = true\n    from updated_forums\n    where posts.forum_id = updated_forums.id;\n$$ language sql volatile;\n```\n```\n\n----------------------------------------\n\nTITLE: List of Available Keys for .postgraphilerc.js Options\nDESCRIPTION: Lists the configuration keys available within the `options` object returned by a `.postgraphilerc.js` file. Each key is shown with its expected type (e.g., `<string>`, `<integer>`, `true/false`) or its default value. This list covers various aspects like plugins, connection pooling, schema export, JWT settings, server configuration, and caching. Note that this interface is deprecated.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n```\n  appendPlugins: <string>\n  bodySizeLimit: <string>\n  classicIds = false\n  clusterWorkers: <integer>\n  connection: <string>\n  cors= false\n  defaultRole: <string>\n  disableDefaultMutations = false\n  disableGraphiql = false\n  disableQueryLog: true/false\n  dynamicJson = false\n  enableQueryBatching: true/false\n  exportSchemaGraphql: <path string>\n  exportSchemaJson: <path string>\n  extendedErrors = []\n  graphiql = '/graphiql'\n  graphql = '/graphql'\n  host = 'localhost'\n  includeExtensionResources = false\n  jwtAudiences: <string>\n  jwtRole = ['role']\n  jwtSecret: <string>\n  jwtSignOptions: {}\n  jwtTokenIdentifier\n  jwtVerifyAlgorithms: <string>\n  jwtVerifyAudience: <string>\n  jwtVerifyClockTolerance: <number>\n  jwtVerifyId: <string>\n  jwtVerifyIgnoreExpiration: true/false\n  jwtVerifyIgnoreNotBefore: true/false\n  jwtVerifyIssuer: <string>\n  jwtVerifySubject: <string>\n  legacyJsonUuid: true/false\n  maxPoolSize: <number>\n  plugins: <string>\n  port = 5000\n  prependPlugins: <string>\n  readCache: <path string>\n  schema: <string>\n  secret: <string>\n  showErrorStack: true/false\n  simpleCollections: [omit|both|only]\n  skipPlugins: <string>\n  timeout: <number>\n  token: : <string>\n  watch: true/false\n  writeCache: <path string>\n```\n```\n\n----------------------------------------\n\nTITLE: Serializing JWT Claims into PostgreSQL Session Settings (SQL)\nDESCRIPTION: Demonstrates how PostGraphile maps JWT claim values to local Postgres settings upon verifying the JWT. Each 'set local' statement assigns a claim value to a transaction-level variable, enabling the backend to access JWT information via Postgres settings. Requires PostgreSQL and a properly configured PostGraphile instance. Input values are the claim names and values from the JWT; the output is that these claims are accessible in the session context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_28\n\nLANGUAGE: SQL\nCODE:\n```\nset local jwt.claims.a to 1;\nset local jwt.claims.b to 2;\nset local jwt.claims.c to 3;\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via Middleware Options in JavaScript\nDESCRIPTION: Illustrates how to enable server plugins when using PostGraphile as middleware. It uses the `makePluginHook` utility function, passing an array of imported plugin objects, and provides the resulting `pluginHook` function in the PostGraphile options object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Only include as many plugins as you need. An empty array is also valid.\nconst pluginHook = makePluginHook([OperationHooks, PgPubsub, GraphilePro]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n\napp.use(postGraphileMiddleware);\n```\n\n----------------------------------------\n\nTITLE: Defining PgExecutor Context with grafast in TypeScript\nDESCRIPTION: This snippet demonstrates how to define the context for a `PgExecutor` instance in `@dataplan/pg`. It utilizes the `context` and `object` functions from the `grafast` library to retrieve `withPgClient` and `pgSettings` properties from the main GraphQL context during the planning phase. These properties are essential for the executor to interact with the database at runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/adaptors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { context, object } from \"grafast\";\nimport { PgExecutor } from \"@dataplan/pg\";\n\nconst executor = new PgExecutor({\n  name: \"default\",\n  context() {\n    return object({\n      withPgClient: context().get(\"withPgClient\"),\n      pgSettings: context().get(\"pgSettings\"),\n    });\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying TypeScript ESM Import Error Message - Plaintext\nDESCRIPTION: This snippet shows a typical Node.js error message when attempting to require a TypeScript ES module (`.ts` file) that exports ESM syntax, but is being loaded using CommonJS `require()`. It illustrates the importance of module type designations in `package.json` and appropriate loader handling. The message is expected as console output; developers must ensure module compatibility to avoid it.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-config/README.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nError [ERR_REQUIRE_ESM]: Must use import to load ES Module: /path/to/graphile.config.ts\nrequire() of ES modules is not supported.\nrequire() of /path/to/graphile.config.ts from /path/to/node_modules/graphile-config/dist/loadConfig.js is an ES module file as it is a .ts file whose nearest parent package.json contains \"type\": \"module\" which defines all .ts files in that package scope as ES modules.\nInstead change the requiring code to use import(), or remove \"type\": \"module\" from /path/to/package.json.\n```\n\n----------------------------------------\n\nTITLE: Executing a Custom Search Query in GraphQL\nDESCRIPTION: Demonstrates how to execute the `searchPosts` custom query in GraphQL. It passes the search term \"Hello world\" and uses pagination arguments (`first: 5`). The query requests page information (`pageInfo`), the total count (`totalCount`), and the `headline` and `body` fields for each node (post) found.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-queries.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  searchPosts(search: \"Hello world\", first: 5) {\n    pageInfo {\n      hasNextPage\n    }\n    totalCount\n    nodes {\n      headline\n      body\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Instance in TypeScript\nDESCRIPTION: Demonstrates creating a PostGraphile instance (`pgl`) by calling the `postgraphile` function with the imported configuration preset. In V5, this returns an instance with helper methods rather than a middleware function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Optimally Archiving Forums using a Single Query with CTE (SQL)\nDESCRIPTION: Illustrates an optimized `archive_forums` function using `LANGUAGE sql` and a Common Table Expression (CTE). It performs the archiving in a single SQL statement. The `updated_forums` CTE updates the `forums` table and uses `returning id` to capture the IDs of the updated forums. The main `UPDATE` statement then updates the `posts` table, joining with the `updated_forums` CTE to target the correct posts based on the forum IDs updated in the CTE. This approach is generally the most performant for related updates. The function takes an integer array `forum_ids` and returns `void`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate function archive_forums(forum_ids int[]) returns void as $$\n  with updated_forums as (\n    update forums\n    set is_archived = true\n    where id = ANY(forum_ids)\n    returning id\n  )\n    update posts\n    set is_archived = true\n    from updated_forums\n    where posts.forum_id = updated_forums.id;\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for Numbers and Letters (GraphQL)\nDESCRIPTION: This query requests all fields from the numbers and letters objects in the sample schema. Used to demonstrate the impact of errors and nullability in the result. No dependencies. Returns nested objects with three fields each. Format: { numbers { one, two, three } letters { a, b, c } }.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  numbers {\n    one\n    two\n    three\n  }\n  letters {\n    a\n    b\n    c\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Mutations via Deprecated @omit Tag in JSON5 - JSON5\nDESCRIPTION: Configures the deprecated 'omit' tag in JSON5 to prevent PostGraphile from generating create, update, and delete GraphQL mutations for a table. The value is a comma-separated list of actions. Used in 'class.tags' for 'table_name'. Best practice is now to use '@behavior -*', but this demonstrates legacy usage. Input: action name(s). Output: API will exclude specified mutation operations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_23\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      table_name: {\n        tags: {\n          omit: \"create,update,delete\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscription Authorization Logic - PostgreSQL Function (PL/pgSQL)\nDESCRIPTION: This PostgreSQL code defines a PL/pgSQL function for validating simple subscription authorization. The function accepts a topic name (always prefixed with 'postgraphile:') and either returns a string (to permit subscription) or raises an exception to deny it. Marked as VOLATILE and SECURITY DEFINER for security context. Use the --subscription-authorization-function flag or the subscriptionAuthorizationFunction option to activate. Insert your own logic where \\\"...\\\" is shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION\n  app_hidden.validate_subscription(topic text)\nRETURNS TEXT AS $$\nBEGIN\n  IF ... THEN\n    RETURN ...::text;\n  ELSE\n    RAISE EXCEPTION 'Subscription denied'\n      USING errcode = '.....';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile V5 Plugin Structure in TypeScript\nDESCRIPTION: A TypeScript example showing the equivalent PostGraphile V5 plugin structure for the V4 example. It demonstrates the declarative approach, exporting a `GraphileConfig.Plugin` object with keys like `name`, `inflection`, and `schema.hooks`. Hooks are defined as methods within the `hooks` object, replacing the V4 `builder.hook()` calls.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport type {} from \"postgraphile\";\n\nexport const MyPlugin: GraphileConfig.Plugin = {\n  name: \"MyPlugin\",\n\n  inflection: {\n    add: {\n      myInflector(stuff) {\n        return stuff + \"Stuff\";\n      },\n    },\n  },\n\n  schema: {\n    hooks: {\n      build(build) {\n        return build.extend(\n          build,\n          { myStuff: () => [\"my\", \"stuff\"] },\n          \"Adding myStuff to build\",\n        );\n      },\n\n      init(_, build) {\n        doSomethingWith(build.myStuff());\n        return _;\n      },\n\n      GraphQLObjectType_fields(fields, build, context) {\n        return build.extend(\n          fields,\n          { myField: { type: build.graphql.GraphQLString } },\n          \"Adding fields from MyPlugin\",\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile Plugins (ESM) in JavaScript\nDESCRIPTION: Shows the equivalent of importing PostGraphile and server plugins using ES2015 Module (ESM) `import` syntax. This syntax is preferred in modern JavaScript projects configured to use ES Modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { postgraphile, makePluginHook } from \"postgraphile\";\nimport OperationHooks from \"@graphile/operation-hooks\";\nimport PgPubsub from \"@graphile/pg-pubsub\";\nimport GraphilePro from \"@graphile/pro\";\n```\n\n----------------------------------------\n\nTITLE: Deploying to Heroku via Git Push (Library Setup) (Bash)\nDESCRIPTION: Pushes the local `master` branch to the 'heroku' remote repository, initiating the Heroku build and deployment process. This specific instance of the command is shown within the context of deploying an application that uses PostGraphile as a library.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit push heroku master\n```\n\n----------------------------------------\n\nTITLE: Comparison: Default vs. Smart-Tagged Collection Type Field Names - Graphile Diff\nDESCRIPTION: This diff shows the before-and-after state of GraphQL schema fields when the @listSuffix smart tag is applied to an entity. It illustrates how the field names generated by Graphile change depending on configuration. No dependencies required; serves to visually communicate the impact of smart tag usage and configuration options ('pgOmitListSuffix', 'simpleCollections').\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-  allCompanies(\n+  companiesConnection(\n```\n\nLANGUAGE: diff\nCODE:\n```\n-  allCompaniesList(\n+  companies(\n```\n\n----------------------------------------\n\nTITLE: Running and Rebuilding GraphQL Docker Containers Using Shell Commands\nDESCRIPTION: Provides shell commands for stopping, rebuilding, and relaunching Docker containers, specifically to reflect custom plugin integration in the GraphQL service. These commands are to be run from the repository root and assume a working docker-compose setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n# Shut down containers\n$ docker-compose down\n\n# Rebuild the GraphQL container\n$ docker-compose build graphql\n\n# Rerun containers\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic Types with GraphQL Interface and Types (GraphQL)\nDESCRIPTION: Demonstrates how to define a polymorphic GraphQL schema using an interface ('Animal') and concrete implementing object types ('Cat' and 'Dog'). Also illustrates declaring query fields returning the interface and its list, which sets up polymorphic positions for queries. This structure is required for Gra*fast* to perform polymorphic planning. Inputs are schema definitions; outputs are the resulting GraphQL types available to query.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/polymorphism.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ninterface Animal {\n  name: String!\n}\ntype Cat extends Animal {\n  name: String!\n  numberOfLives: Int!\n}\ntype Dog extends Animal {\n  name: String!\n  wagsTail: Boolean!\n}\ntype Query {\n  bestAnimal: Animal\n  randomAnimals: [Animal]\n}\n```\n\n----------------------------------------\n\nTITLE: Using loadMany with ioEquivalence for an Object Step - TypeScript\nDESCRIPTION: Shows loadMany usage with an object step as input and an object ioEquivalence parameter, mapping input object keys (oid, uid) to output fields ('organization_id', 'user_id'). Allows precise batched fetching keyed by complex identifiers. Depends on 'object()' helper and a corresponding batch function.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $posts = loadMany(\n  object({ oid: $organizationId, uid: $userId }),\n  // States that:\n  // - $post.get('organization_id') should return $organizationId directly (the value for the `oid` input), and\n  // - $post.get('user_id') should return $userId directly (the value for the `uid` input\n  { oid: \"organization_id\", uid: \"user_id\" },\n  batchGetMemberPostsByOrganizationIdAndUserId,\n);\n```\n\n----------------------------------------\n\nTITLE: Displaying Single Row GraphQL Result (JSON)\nDESCRIPTION: This JSON output demonstrates the typical return shape for the 'currentUser' GraphQL field, showing properties 'nodeId', 'id', and 'username'. This result format is standard for single-object lookups with custom SQL functions, and serves as an example for output verification or testing Graphile custom queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"currentUser\": {\n    \"nodeId\": \"WyJ1c2VycyIsMV0=\",\n    \"id\": 1,\n    \"username\": \"user\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Signature for Method 2 of makeWrapPlansPlugin in TypeScript\nDESCRIPTION: Specifies the TypeScript function signature for the second method of `makeWrapPlansPlugin`. This method uses a more dynamic approach, accepting a `filter` function and a `rule` function. The `filter` checks each field (`context`, `build`, `field`) and returns a truthy value (`T`) if it should be wrapped, or `null`. The `rule` function receives this truthy value (`match`) and returns the `PlanWrapperRule` or `PlanWrapperFn` for that field. It returns a `GraphileConfig.Plugin`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeWrapPlansPlugin<T>(\n  filter: (\n    context: GraphileBuild.ContextObjectFieldsField,\n    build: GraphileBuild.Build,\n    field: GrafastFieldConfig,\n  ) => T | null,\n  rule: (match: T) => PlanWrapperRule | PlanWrapperFn,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Defining a Composite Type Codec using recordCodec in TypeScript\nDESCRIPTION: Illustrates the usage of the `recordCodec` helper function to define a codec for a composite type, typically representing a database table (`app_public.forums`). It defines attributes (columns) with their respective codecs (e.g., `TYPES.uuid`, `TYPES.citext`), nullability constraints (`notNull`), default value indicators (`hasDefault`), and even computed attributes using SQL expressions (`expression`). Requires `sql` tagged template literal and `TYPES` from `@dataplan/pg`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/codecs.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst forumCodec = recordCodec({\n  name: \"forums\",\n  identifier: sql`app_public.forums`,\n  attributes: {\n    id: {\n      codec: TYPES.uuid,\n      notNull: true,\n      hasDefault: true,\n    },\n    name: {\n      codec: TYPES.citext,\n      notNull: true,\n    },\n    archived_at: {\n      codec: TYPES.timestamptz,\n    },\n    is_archived: {\n      codec: TYPES.boolean,\n      expression(alias) {\n        return sql`${alias}.archived_at is not null`;\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Debug Logging - Bash\nDESCRIPTION: This set of commands shows how to set DEBUG environment variables to enable SQL and error debug output in PostGraphile using various shells (Bash, Windows Console, Windows PowerShell). Replace 'postgres://...' with your actual Postgres connection string. Ensures SQL statements and errors are logged to the console. This is useful both in CLI and when integrating PostGraphile as Express middleware. Prefer these in development only.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Bash (Linux, macOS, etc)\nexport DEBUG=\\\"postgraphile:postgres\\\"\npostgraphile -c postgres://...\n\n# Windows Console\nset DEBUG=postgraphile:postgres & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:DEBUG='postgraphile:postgres'; postgraphile -c postgres://...\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Preset for Graphile Build (JavaScript)\nDESCRIPTION: This snippet demonstrates how to define a custom Graphile Build preset file in JavaScript, starting by extending the default preset provided by the library. The file exports a configuration object using the 'extends' property, allowing reuse and further customization of plugin configurations. This preset can be imported elsewhere and used to control Graphile Build behavior throughout your project.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defaultPreset } from \"graphile-build\";\n\nexport default {\n  extends: [defaultPreset],\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Posts, Users, Comments, and Bio Details - PostGraphile Look-Ahead - GraphQL\nDESCRIPTION: This comprehensive GraphQL query showcases how PostGraphile, using graphile-buildâ€™s look-ahead feature, can resolve deeply nested dataâ€”including posts, users, comments, authors, and user bio informationâ€”by compiling the entire query into a single SQL statement. The 'UserDetails' fragment is reused across different user fields to fetch id, username, and detailed bio information. Inputs: none (sample query structure); outputs: posts with full relational details. Dependencies: correct schema design in PostgreSQL and PostGraphileâ€™s automatic schema mapping. Limitation: accuracy and efficiency rely on database performance and presence of appropriate indexes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/performance.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPosts {\n    edges {\n      node {\n        id\n        title\n        author: userByAuthorId {\n          ...UserDetails\n        }\n        comments {\n          text\n          author: userByAuthorId {\n            ...UserDetails\n            recentComments {\n              date\n              post: postByPostId {\n                title\n                author {\n                  ...UserDetails\n                }\n              }\n              text\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfragment UserDetails on User {\n  id\n  username\n  bio: bioByUserId {\n    preamble\n    location\n    description\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of `each` Function in Graphile Crystal (TypeScript)\nDESCRIPTION: Demonstrates the fundamental syntax for using the `each` function in Graphile Crystal. It takes an existing list step (`$oldList`) and a mapper function (e.g., `($listItem) => doSomethingWith($listItem)`), returning a new list step (`$newList`) where each item has been transformed by the mapper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/each.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $newList = each($oldList, ($listItem) => doSomethingWith($listItem));\n```\n\n----------------------------------------\n\nTITLE: Defining Node.js Application Dependencies for PostGraphile - package.json\nDESCRIPTION: This JSON snippet represents the package.json file for the Node.js application that will run PostGraphile as a library. It declares metadata such as name, version, and author. The dependencies include postgraphile and postgraphile-plugin-connection-filter, which will be installed via npm. This configuration is essential for Node.js modules resolution and for Docker build steps that require module installation before running the service.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"name\\\": \\\"postgraphile-as-library\\\",\\n  \\\"version\\\": \\\"0.0.1\\\",\\n  \\\"description\\\": \\\"PostGraphile as a library in a dockerized Node.js application.\\\",\\n  \\\"author\\\": \\\"Alexis ROLLAND\\\",\\n  \\\"license\\\": \\\"Apache-2.0\\\",\\n  \\\"main\\\": \\\"server.js\\\",\\n  \\\"keywords\\\": [\\\"nodejs\\\", \\\"postgraphile\\\"],\\n  \\\"dependencies\\\": {\\n    \\\"postgraphile\\\": \\\"^4.5.5\\\",\\n    \\\"postgraphile-plugin-connection-filter\\\": \\\"^1.1.3\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Search Function Returning Custom Type Rows in PostgreSQL\nDESCRIPTION: Illustrates an alternative approach where a custom PostgreSQL type `post_search_result` is defined to specify the exact shape of the search results (headline, body). A comment with the `@notNull` smart tag is used to make the `headline` field non-nullable in the GraphQL schema. The `search_posts` function is modified to return `SETOF post_search_result`, selecting only the required columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-queries.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate type post_search_result as (\n  headline         text,\n  body             text\n);\ncomment on column post_search_result.headline is E'@notNull';\n\ncreate function search_posts(search text)\n  returns setof post_search_result as $$\n    select headline, body\n    from post\n    where\n      headline ilike ('%' || search || '%') or\n      body ilike ('%' || search || '%')\n  $$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Registering Schema Watchers using Event Emitters - JavaScript\nDESCRIPTION: This code demonstrates the use of the registerWatcher method of SchemaBuilder, providing sample implementations for handling schema change subscriptions and clean-up. The watcher attaches an event listener for change events invoking triggerRebuild, while the unwatcher removes it. Assumes the existence of an eventEmitter object supporting on and removeListener methods. Inputs include the triggerRebuild callback; the primary output is managed side-effects for schema rebuilding.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/schema-builder.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nbuilder.registerWatcher(\n  (triggerRebuild) => {\n    eventEmitter.on(\"change\", triggerRebuild);\n  },\n  (triggerRebuild) => {\n    eventEmitter.removeListener(\"change\", triggerRebuild);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Single-Key Reverse Relation Naming Change in Generated Type Definitions - Diff\nDESCRIPTION: This diff illustrates a breaking change to the field name for a single-key reference in a GraphQL type definition. The field, formerly named after the target table, is now named after the referencing key if it follows the 'foo_id' or 'foo_uuid' pattern. No dependencies required; the change clarifies relationship semantics in the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n-  user: User\n+  author: User\n```\n\n----------------------------------------\n\nTITLE: Executing a Forgot Password GraphQL Mutation\nDESCRIPTION: Defines a GraphQL mutation named 'forgotPassword' that accepts an email address within an input object. It requests the 'success' field in the response payload, indicating whether the password reset process was successfully initiated by the corresponding backend logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-mutations.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  forgotPassword(input: { email: \"benjie@example.com\" }) {\n    success\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Behavior using Smart Comments in SQL\nDESCRIPTION: Adds a `COMMENT` to the `users` table using the `@behavior` smart tag. The value `-insert -delete` instructs PostGraphile to exclude the default `insert` and `delete` mutations for this table from the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table users is\n  E'@behavior -insert -delete';\n```\n\n----------------------------------------\n\nTITLE: Creating a Private Table for User Accounts in PostgreSQL\nDESCRIPTION: Creates a new table `forum_example_private.person_account` designed to store private user account information. It includes a `person_id` column which is both the primary key and a foreign key referencing `forum_example.person(id)` with `on delete cascade`, establishing a one-to-one relationship. It also includes a unique `email` column with a regex check for basic format validation (`~* '^.+@.+\\..+$'`) and a `password_hash` column intended to store securely hashed passwords (not plaintext). Comments are added to the table and columns for documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_19\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example_private.person_account (\n  person_id        integer primary key references forum_example.person(id) on delete cascade,\n  email            text not null unique check (email ~* '^.+@.+\\..+$'),\n  password_hash    text not null\n);\n\ncomment on table forum_example_private.person_account is 'Private information about a personâ€™s account.';\ncomment on column forum_example_private.person_account.person_id is 'The id of the person associated with this account.';\ncomment on column forum_example_private.person_account.email is 'The email address of the person.';\ncomment on column forum_example_private.person_account.password_hash is 'An opaque hash of the personâ€™s password.';\n```\n\n----------------------------------------\n\nTITLE: Adding Configuration Options for a Graphile Plugin (TypeScript)\nDESCRIPTION: Illustrates how to define custom configuration options for a Graphile V5 plugin that users can set in their preset. It involves extending the `GraphileBuild.SchemaOptions` interface via declaration merging and adding JSDoc comments for documentation. These options are typically accessed via `build.options`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n  namespace GraphileBuild {\n    interface SchemaOptions {\n      /**\n       * The default option to use for the 'includeArchived' argument. Defaults to\n       * 'INHERIT' where feasible and 'NO' otherwise.\n       */\n      pgArchivedDefault?: \"INHERIT\" | \"NO\" | \"YES\" | \"EXCLUSIVELY\";\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example `Product` GraphQL Type generated by PostGraphile\nDESCRIPTION: Illustrates the potential GraphQL `Product` type automatically generated by PostGraphile based on the previously defined `product` SQL table schema. Fields like `id`, `name`, and `priceInUsCents` correspond to the table columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\ntype Product {\n  id: UUID!\n  name: String!\n  priceInUsCents: Int!\n}\n```\n\n----------------------------------------\n\nTITLE: Using pgSingleTablePolymorphic for Single-Table Polymorphism in TypeScript\nDESCRIPTION: Demonstrates an alternative approach (within a `<details>` section) to handling single-table polymorphism using the `pgSingleTablePolymorphic` helper function inside a plan resolver. This method involves retrieving the type identifier ('type'), mapping it to a GraphQL type name (using a helper `sqlTypeToGraphQLType`), and passing these along with the item step (`$item`) to `pgSingleTablePolymorphic`. This avoids modifying the source codec configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Map the SQL 'type' values to their GraphQL equivalents\nconst sqlTypeToGraphQLType = (type) =>\n  ({\n    TOPIC: \"Topic\",\n    POST: \"Post\",\n    DIVIDER: \"Divider\",\n    CHECKLIST: \"Checklist\",\n    CHECKLIST_ITEM: \"ChecklistItem\",\n  })[type] ?? null;\n// Or: `const sqlTypeToGraphQLType = pascalCase;`\n\n/******/\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      // Get the 'item' related to this comment\n      const $item = $comment.singleRelation(\"item\");\n\n      // Get the 'type' column from the item\n      const $type = $item.get(\"type\");\n\n      // Convert the 'type' value into the name of a GraphQL type\n      const $typeName = lambda($type, sqlTypeToGraphQLType);\n\n      // Return the polymorphic step representing this item\n      return pgSingleTablePolymorphic($typeName, $item);\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Starting an HTTP Server with PostGraphile Middleware - Node.js JavaScript\nDESCRIPTION: This JavaScript snippet creates an HTTP server using the built-in http module and attaches the postgraphile middleware for exposing a GraphQL API. The middleware is configured to connect to the database defined in the DATABASE_URL environment variable and exposes the public schema, with watchPg, graphiql, and enhanceGraphiql options enabled. PORT is read from the environment, allowing flexible runtime port assignment. Requires postgraphile and a compatible Node.js runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst http = require(\\\"http\\\");\\nconst { postgraphile } = require(\\\"postgraphile\\\");\\n\\nhttp\\n  .createServer(\\n    postgraphile(process.env.DATABASE_URL, \\\"public\\\", {\\n      watchPg: true,\\n      graphiql: true,\\n      enhanceGraphiql: true,\\n    }),\\n  )\\n  .listen(process.env.PORT);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using TagsFilePlugin in PostGraphile Configuration (JavaScript)\nDESCRIPTION: This snippet illustrates how to import the built-in TagsFilePlugin from PostGraphile utilities and add it to the plugins array in the graphile configuration file. The TagsFilePlugin loads smart tag configurations from a recommended postgraphile.tags.json5 file for schema customization. Requires the 'postgraphile/utils' package, and assumes the presence and correct formatting of a smart tags JSON5 file. The plugins array can include multiple plugins; only TagsFilePlugin is highlighted here.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { TagsFilePlugin } from \"postgraphile/utils\";\n\nexport default {\n  // ...\n  plugins: [TagsFilePlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Start Script for Express App in package.json (JSON)\nDESCRIPTION: Shows a minimal `package.json` structure for an Express application deploying PostGraphile on GCP. The key element is the `scripts.start` command (`node src/index.js`), which instructs GCP App Engine how to start the application by running the main JavaScript file using Node.js.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"start\": \"node src/index.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Field Arguments for Plans - Pseudocode\nDESCRIPTION: This snippet provides the pseudocode for tracking argument values for a given field in a GraphQL object, handling both static values and variables recursively. Each argument's plan is generated, allowing the system to monitor access and value resolution. It serves as an alternative to GraphQL's CoerceArgumentValues and supports further recursion as needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_19\n\nLANGUAGE: pseudocode\nCODE:\n```\nTrackedArguments(aether, objectType, field):\n\n- Let {trackedArgumentValues} be an empty unordered map.\n- Let {argumentValues} be the argument values provided in {field}.\n- Let {fieldName} be the name of {field}.\n- Let {argumentDefinitions} be the arguments defined by {objectType} for the field named {fieldName}.\n- For each {argumentDefinition} in {argumentDefinitions}:\n  - Let {argumentName} be the name of {argumentDefinition}.\n  - Let {argumentType} be the expected type of {argumentDefinition}.\n  - Let {defaultValue} be an AST representation of the default value for {argumentDefinition}.\n  - Let {argumentValue} be the value in {argumentValues} for key {argumentName}.\n  - Let {argumentPlan} be {InputPlan(aether, argumentType, argumentValue, defaultValue)}.\n  - Set {argumentPlan} as the value for key {argumentName} in {trackedArgumentValues}.\n- Return {trackedArgumentValues}.\n```\n\n----------------------------------------\n\nTITLE: Creating Relationally Polymorphic Tables - SQL\nDESCRIPTION: Defines a parent relational table 'relational_items' capturing shared fields and several child tables for specific types with their unique fields. Implements foreign keys to maintain referential integrity. Requires the 'polymorphic' schema and the enum type. This structure allows PostGraphile smart tags to implement relational polymorphism where each type references a child table for extra attributes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.relational_items (\n  id serial primary key,\n\n  -- This column is used to tell us which table we need to join to\n  type polymorphic.item_type not null default 'POST'::polymorphic.item_type,\n\n  -- Shared attributes (also 'id'):\n  parent_id int references polymorphic.relational_items on delete cascade,\n  root_topic_id int, -- constraint being created below\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz\n);\n\ncreate table polymorphic.relational_topics (\n  id int primary key references polymorphic.relational_items,\n  title text not null\n);\nalter table polymorphic.relational_items add constraint relational_items_root_topic_fkey foreign key (root_topic_id) references polymorphic.relational_topics on delete cascade;\ncreate table polymorphic.relational_posts (\n  id int primary key references polymorphic.relational_items,\n  title text not null,\n  description text default '-- Enter description here --',\n  note text\n);\ncreate table polymorphic.relational_dividers (\n  id int primary key references polymorphic.relational_items,\n  title text,\n  color text\n);\ncreate table polymorphic.relational_checklists (\n  id int primary key references polymorphic.relational_items,\n  title text not null\n);\ncreate table polymorphic.relational_checklist_items (\n  id int primary key references polymorphic.relational_items,\n  description text not null,\n  note text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using `next.callback` for Post-Action Logic in Graphile Config Middleware (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates a Graphile Config plugin (`MySpecialPlugin`) using `next.callback()` within its middleware for `someAction`. This pattern allows executing logic after the `next()` function completes, handling both success (`result`) and failure (`error`) cases. It avoids introducing promises unnecessarily, making the middleware potentially compatible with both synchronous and asynchronous actions. The example modifies the event before calling `next` and processes the result in the callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/middleware.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const MySpecialPlugin: GraphileConfig.Plugin = {\n  name: \"MySpecialPlugin\",\n  libraryName: {\n    middleware: {\n      someAction(next, event) {\n        console.log(`someAction(someParameter=${event.someParameter}) called`);\n        // Optionally mutate event\n        event.someParameter = event.someParameter * 2;\n\n        return next.callback((error, result) => {\n          if (error) {\n            console.error(`someAction() threw ${error}`);\n            // Handle the error somehow... Or just rethrow it.\n            throw error;\n          } else {\n            console.log(`someAction() returned ${result}`);\n            // Return `result` or a derivative thereof\n            return result / 2;\n          }\n        });\n      },\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Listen Subscription Field - GraphQL Schema\nDESCRIPTION: This GraphQL schema snippet defines the ListenPayload type and the listen field on the Subscription type for simple subscriptions. Required for enabling the generic channel-based subscriptions in your API. The 'topic' argument on listen is a non-null String, and the result type contains related query, node, and nodeId for event context. Integrate with an appropriate PostGraphile server that supports subscriptions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\ntype ListenPayload {\n  query: Query\n  relatedNode: Node\n  relatedNodeId: ID\n}\n\ntype Subscription {\n  listen(topic: String!): ListenPayload!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PostGraphile Dockerfile\nDESCRIPTION: Defines a Docker image for the PostGraphile service, starting from the `node:alpine` base image. It installs `postgraphile` and the `postgraphile-plugin-connection-filter` globally using npm, exposes port 5000, and sets the default command (`ENTRYPOINT`) to run `postgraphile` listening on all interfaces.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_13\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Install PostGraphile and PostGraphile connection filter plugin\nRUN npm install -g postgraphile\nRUN npm install -g postgraphile-plugin-connection-filter\n\nEXPOSE 5000\nENTRYPOINT [\"postgraphile\", \"-n\", \"0.0.0.0\"]\n```\n\n----------------------------------------\n\nTITLE: Defining DATABASE_URL for PostGraphile in .env File - Shell/Bash\nDESCRIPTION: This snippet demonstrates how to define the DATABASE_URL environment variable within a .env file to specify the PostgreSQL connection string for the PostGraphile container. It follows the Postgres URI syntax schema and is referenced by services needing DB access via Docker Compose. The input value should be updated to match deployment credentials, and the file must reside in the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n\"[...]\n# GRAPHQL\n# Parameters used by graphql container\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Globally with npm - Shell\nDESCRIPTION: Installs PostGraphile globally on the system using npm. This step is necessary to use the postgraphile command in terminal sessions, especially for beginners. Requires Node.js and npm installed; input is the install command. Output is standard npm installation output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ npm install -g postgraphile\n```\n```\n\n----------------------------------------\n\nTITLE: Planning a Single GraphQL Input Field (Pseudocode)\nDESCRIPTION: Describes the `PlanInputField` algorithm. It retrieves the custom plan resolver (`inputField.extensions.graphile.plan`) associated with an input field. It calls this resolver and, if a plan is returned, recursively calls `PlanInput` to handle the field's value according to its type.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_32\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanInputField(aether, inputField, trackedValuePlan, parentPlan):\n\n- Let {planResolver} be `inputField.extensions.graphile.plan`.\n- Assert: {planResolver} exists.\n- Let {inputFieldPlan} be the result of calling {planResolver}, providing {parentPlan}, {trackedValuePlan},\n  {aether}.{trackedContextPlan}.\n- If {inputFieldPlan} is not {null}:\n  - Let {inputFieldType} be the expected type of {inputField}.\n  - Note: the unwrapped type of {inputFieldType} must be an input object.\n  - Call {PlanInput(aether, inputFieldType, trackedValuePlan, inputFieldPlan)}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Defining Forums List SQL Function for Graphile (SQL)\nDESCRIPTION: This SQL function, 'app_public.forums_about_cats', returns a set of rows from 'app_public.forums' where the 'slug' matches the 'cat-%' pattern. The SQL function is used by Graphile to back the 'forumsAboutCats' field in the schema. It requires SELECT and EXECUTE permissions on the relevant tables and is implemented as a stable function for predictable query results.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.forums_about_cats()\nreturns setof app_public.forums\nlanguage sql stable\nas $$\n  select *\n  from app_public.forums\n  where slug like 'cat-%';\n$$;\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Object Type with Reference Implementation - GraphQL.js - JavaScript\nDESCRIPTION: This snippet shows how to define a new GraphQLObjectType using the vanilla GraphQL reference implementation. It constructs a new type called 'MyType' with its fields specified in a fields property. Inputs are the GraphQLObjectType class and field configuration, producing a type definition to integrate in a schema. The code requires the 'graphql' npm package (or equivalent in the runtime).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyType =\n/* highlight-next-line */\n  new GraphQLObjectType({\n    name: 'MyType',\n    fields: {\n      // ...\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.9\nDESCRIPTION: This snippet shows an update to project dependencies, specifically mentioning version '0.0.1-0.9' of the 'grafast' package within the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.9\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Schema for Relational Polymorphism\nDESCRIPTION: Creates a base table `polymorphic.relational_items` with common fields and a `type` column, plus separate tables (e.g., `polymorphic.relational_topics`, `polymorphic.relational_posts`) for type-specific data, linked via foreign keys. This schema is designed for the `@interface mode:relational` smart tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.relational_items (\n  id serial primary key,\n\n  -- This column is used to tell us which table we need to join to\n  type polymorphic.item_type not null default 'POST'::polymorphic.item_type,\n\n  -- Shared attributes (also 'id'):\n  parent_id int references polymorphic.relational_items on delete cascade,\n  root_topic_id int, -- constraint being created below\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz\n);\n\ncreate table polymorphic.relational_topics (\n  id int primary key references polymorphic.relational_items,\n  title text not null\n);\nalter table polymorphic.relational_items add constraint relational_items_root_topic_fkey foreign key (root_topic_id) references polymorphic.relational_topics on delete cascade;\ncreate table polymorphic.relational_posts (\n  id int primary key references polymorphic.relational_items,\n  title text not null,\n  description text default '-- Enter description here --',\n  note text\n);\ncreate table polymorphic.relational_dividers (\n  id int primary key references polymorphic.relational_items,\n  title text,\n  color text\n);\ncreate table polymorphic.relational_checklists (\n  id int primary key references polymorphic.relational_items,\n  title text not null\n);\ncreate table polymorphic.relational_checklist_items (\n  id int primary key references polymorphic.relational_items,\n  description text not null,\n  note text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a soft-delete mutation using Node ID in TypeScript\nDESCRIPTION: Illustrates a PostGraphile plugin for a `deleteItem` mutation that accepts a GraphQL Global Object Identifier (Node ID) via `DeleteItemInput`. The plan retrieves the current user's ID from JWT claims using `context().get(\"jwtClaims\")` and decodes the provided Node ID into its constituent parts (like the primary key) using `specFromNodeId` and the appropriate handler. It then uses `withPgClientTransaction` to perform a conditional update (`UPDATE app_public.items SET is_archived = true WHERE id = $1 AND user_id = $2`), effectively soft-deleting the item only if the current user is the owner. The result is wrapped in an `object` step matching the `DeleteItemPayload`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport { context, list, specFromNodeId, object } from \"postgraphile/grafast\";\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\n\nconst DeleteItemByNodeIdPlugin = makeExtendSchemaPlugin((build) => {\n  // We need the nodeId handler for the Item type so that we can decode the ID.\n  const handler = build.getNodeIdHandler(\"Item\")!;\n\n  // Extract the executor from the items resource\n  const { items } = build.input.pgRegistry.pgResources;\n  const { executor } = items;\n  // Or: `const executor = build.input.pgRegistry.pgExecutors.main;`\n\n  return {\n    typeDefs: gql`\n      input DeleteItemInput {\n        id: ID!\n      }\n      type DeleteItemPayload {\n        success: Boolean\n      }\n      extend type Mutation {\n        deleteItem(input: DeleteItemInput!): DeleteItemPayload\n      }\n    `,\n\n    plans: {\n      Mutation: {\n        deleteItem(_, fieldArgs) {\n          // jwtClaims is decrypted jwt token data\n          const $jwtClaims = context().get(\"jwtClaims\");\n\n          // Read the input.id value from the arguments\n          const $nodeId = fieldArgs.getRaw([\"input\", \"id\"]);\n\n          // Decode the node ID, to something like: `{ id: $someStep }`\n          const spec = specFromNodeId(handler, $nodeId);\n          const $itemId = spec.id;\n\n          const $success = withPgClientTransaction(\n            executor,\n            // Passing a `list` step allows us to pass more than one dependency\n            // through to our callback:\n            list([$jwtClaims, $itemId]),\n            async (pgClient, [jwtClaims, itemId]) => {\n              if (!itemId || !jwtClaims?.user_id) {\n                return false;\n              }\n              const {\n                rows: [row],\n              } = await pgClient.query(\n                ` UPDATE app_public.items\n                  SET is_archived = true\n                  WHERE id = $1\n                  AND user_id = $2\n                  RETURNING *;`,\n                [itemId, jwtClaims.user_id],\n              );\n              return !!row;\n            },\n          );\n\n          // Since we're returning this data in the same shape as the payload\n          // and the payload's fields don't need specific step classes, we don't\n          // need to implement plan resolvers on the payload.\n          return object({ success: $success });\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Graphile Plugin to Rename nodeId Fields (TypeScript)\nDESCRIPTION: This TypeScript code defines a custom Graphile plugin (IdToNodeIdPlugin) that overrides the default inflection methods to replace the global object identifier field name with 'nodeId' and coerce database attribute names to GraphQL-compliant ones. Dependencies include the 'GraphileConfig' interface from PostGraphile. The plugin can be used to customize schema generation, specifically for projects wishing to use 'nodeId' rather than the default 'id' or 'rowId'. Inputs are the schema-building context; output is a customized GraphQL schema field naming. Requires PostGraphile's plugin infrastructure and may require familiarity with PostGraphile's codec and extension system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/node-id.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst IdToNodeIdPlugin: GraphileConfig.Plugin = {\n  name: \"IdToNodeIdPlugin\",\n  version: \"1.0.0\",\n  inflection: {\n    replace: {\n      nodeIdFieldName() {\n        return \"nodeId\";\n      },\n      _attributeName(previous, options, details) {\n        const attribute = codec.attributes[attributeName];\n        const name = attribute.extensions?.tags?.name || attributeName;\n        return this.coerceToGraphQLName(name);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming a Table via Smart Tag - SQL\nDESCRIPTION: This SQL snippet shows how to assign a smart tag to a PostgreSQL table using the COMMENT command. The '@name message' annotation instructs PostGraphile's inflector subsystem to name the 'post' table type as 'message' when generating the schema. Requires smart tags to be enabled within PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/inflection.mdx#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TABLE post IS E'@name message';\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Schema (SQL)\nDESCRIPTION: Shows the SQL command to create a new database schema named 'app_public'. This schema is recommended in the document for organizing database objects intended for public exposure via tools like PostGraphile. Requires PostgreSQL database privileges to create schemas.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/namespaces.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE SCHEMA app_public;\n```\n\n----------------------------------------\n\nTITLE: Extracting PostGraphile Options for Testability in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates setting up a basic Express server using the `postgraphile` middleware. It emphasizes extracting PostGraphile configuration into a dedicated `postgraphileOptions` function, which is then exported. This pattern allows the options to be easily imported and reused in testing environments, separating configuration from server initialization. It requires the `express` and `postgraphile` libraries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\nfunction postgraphileOptions() {\n  return {\n    dynamicJson: true,\n  };\n}\nexports.postgraphileOptions = postgraphileOptions;\n\napp.use(\n  postgraphile(\n    process.env.DATABASE_URL || \"postgres:///\",\n    [\"app_public\"],\n    postgraphileOptions(),\n  ),\n);\n\napp.listen(process.env.PORT || 3000);\n```\n\n----------------------------------------\n\nTITLE: Embedding Ruru GraphQL Explorer Component in React - JavaScript\nDESCRIPTION: This snippet demonstrates importing the Ruru component from 'ruru-components', as well as the required CSS files from 'graphiql', the GraphiQL explorer plugin, and the local Ruru CSS. It shows how to render the Ruru component and connect it to a GraphQL endpoint at '/graphql' using the React.render method. Dependencies include React, ruru-components, graphiql, @graphiql/plugin-explorer, and their CSS assets; expected input is a running GraphQL API at the provided endpoint.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru-components/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Ruru } from \"ruru-components\";\nimport \"graphiql/graphiql.css\";\nimport \"@graphiql/plugin-explorer/dist/style.css\";\nimport \"ruru-components/ruru.css\";\n\nReact.render(<Ruru endpoint=\"/graphql\" />);\n```\n\n----------------------------------------\n\nTITLE: Defining and Enabling Row-Level Security Policies in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet activates row-level security on a table and defines multiple policies controlling access for various operations. It includes enabling RLS, creating permissive and restrictive policies for different actions (with 'using' and 'with check' clauses), and demonstrates conditional logic based on user state and relationships. Dependencies include user-defined functions such as 'current_user_id()', 'current_user_is_verified()', 'current_user_is_admin()', and 'are_friends()'. Proper configuration is required in a supported PostgreSQL database to enforce advanced, context-sensitive access control.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- Without this line, even if you define security policies, they will not be enforced\nalter table my_table enable row level security;\n\ncreate policy manage_own on my_table for all using ( author_id = current_user_id() );\ncreate policy must_be_verified on my_table as restrictive for insert using ( current_user_is_verified() );\ncreate policy admin_delete on my_table for delete using ( current_user_is_admin() );\ncreate policy friend_insert on my_other_table for insert with check ( are_friends(author_id, user_id) );\n```\n\n----------------------------------------\n\nTITLE: Illustrating Transactional Database Testing Pattern in SQL\nDESCRIPTION: This SQL snippet demonstrates the core pattern for testing database operations within a transaction. It begins a transaction, sets session-local configurations like 'role' and 'jwt.claims.user_id' (marked as local with 'true' to ensure rollback), executes the SQL function or query to be tested, and finally rolls back the transaction to leave the database state unchanged. This ensures test isolation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n-- start transaction\nbegin;\n\n-- set relevant transaction settings; the `, true` means \"local\" - i.e. it'll\n-- be rolled back with the transaction - do not forget to add this!\nselect\n  set_config('role', 'YOUR_GRAPHQL_ROLE_HERE', true),\n  set_config('jwt.claims.user_id', 27, true),\n  set_config...;\n\n-- run the SQL you want to test\nselect * from my_function();\n\n-- rollback the transaction\nrollback;\n```\n\n----------------------------------------\n\nTITLE: Creating a Graphile Plugin with Custom Scope, Middleware, and Preset in TypeScript\nDESCRIPTION: This comprehensive TypeScript example defines a Graphile Config plugin (`MySendgridPlugin`) that introduces a new `sendgrid` configuration scope via declaration merging. The plugin includes middleware (`foo`) that utilizes the configured `apiKey`. It also exports a preset (`MySendgridPreset`) which includes the plugin and provides default configuration values, including reading the API key from an environment variable.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=my-sendgrid-plugin.ts\ndeclare global {\n  namespace GraphileConfig {\n    interface Preset {\n      sendgrid?: SendgridOptions;\n    }\n\n    interface SendgridOptions {\n      apiKey?: string;\n      someOtherOption?: number;\n    }\n  }\n}\n\nexport const MySendgridPlugin: GraphileConfig.Plugin = {\n  name: \"MySendgridPlugin\",\n  libraryName: {\n    middleware: {\n      foo(next, event) {\n        new SendgridSdk(\n          // This assumes that the library passes in the resolved preset via\n          // `event.resolvedPreset`. This will vary depending on the library.\n          event.resolvedPreset.sendgrid?.apiKey,\n        ).makeSomeCall();\n      },\n    },\n  },\n};\n\nexport const MySendgridPreset: GraphileConfig.Preset = {\n  plugins: [MySendgridPlugin],\n  sendgrid: {\n    apiKey: process.env.SENDGRID_API_KEY,\n    someOtherOption: 2,\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Smart Tag Omission Rules with JSON5\nDESCRIPTION: Provides a JSON5 configuration example for `makeJSONPgSmartTagsPlugin` or `makePgSmartTagsFromFilePlugin`. It demonstrates how to apply the `omit` smart tag to prevent `created_at` and `updated_at` columns from appearing in create/update mutations across all tables by using non-fully qualified attribute identifiers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n```json5\n{\n  version: 1,\n  config: {\n    attribute: {\n      created_at: { tags: { omit: \"create,update\" } },\n      updated_at: { tags: { omit: \"create,update\" } },\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Subscribing to forumMessage via GraphQL Subscription (GraphQL)\nDESCRIPTION: GraphQL subscription query that listens for new forum messages for a given forumId. Waits for payloads from the 'forumMessage' subscription field as set up in the schema extension. No external dependencies, but requires backend subscription logic, websocket support, and database event triggers. When an event occurs, the subscription receives an object with the subscribed user's handle and event type. Inputs: forumId. Outputs: real-time event notification objects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\nsubscription MySubscription {\n  forumMessage(forumId: 1) {\n    user\n    event\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Trigger for Subscription Events (SQL)\nDESCRIPTION: This SQL command creates a trigger on the 'messages' table that fires the generic 'tg__graphql_subscription' function after each row insert. Arguments specify the event type ('create'), topic template, and the attribute for dynamic topic substitution. Meant to be run as a superuser or owner with trigger/function privileges. This trigger enables automatic NOTIFY for forum message creation subscriptions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TRIGGER _500_gql_insert\n  AFTER INSERT ON messages\n  FOR EACH ROW\n  EXECUTE FUNCTION tg__graphql_subscription(\n    'create', -- the \"event\" string, useful for the client to know what happened\n    'forum:$1:message', -- the \"topic\" the event will be published to, as a template\n    'forum_id' -- If specified, `$1` above will be replaced with NEW.forum_id or OLD.forum_id from the trigger.\n  );\n```\n\n----------------------------------------\n\nTITLE: Implementing Row-Level Security Policies in PostgreSQL - SQL\nDESCRIPTION: This SQL code snippet creates row-level security policies for granular access control: users may only select their own person record, but can see all posts. It demonstrates how database-level security choices affect GraphQL API visibility, sometimes converting inherently non-nullable relationships into nullable API fields. Used within PostgreSQL with RLS enabled.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/why-nullable.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- Users can only see their own 'Person'\ncreate policy select_self on person for select using (id = current_user_id());\n-- Users can see all Posts\ncreate policy select_all on post for select using (true);\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Function to Get Person's Latest Post (SQL)\nDESCRIPTION: Creates a stable SQL function `forum_example.person_latest_post` that accepts a `forum_example.person` record. It queries the `forum_example.post` table, filtering by the provided person's ID (`author_id = person.id`), orders the results by `created_at` descending, and returns the single latest post record (`limit 1`). A comment explains its purpose. PostGraphile treats such functions as computed fields returning the related record type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_latest_post(person forum_example.person) returns forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where post.author_id = person.id\n  order by created_at desc\n  limit 1\n$$ language sql stable;\n\ncomment on function forum_example.person_latest_post(forum_example.person) is 'Getâ€™s the latest post written by the person.';\n```\n\n----------------------------------------\n\nTITLE: Defining a Single-Table Polymorphism Schema in PostgreSQL\nDESCRIPTION: Provides a PostgreSQL schema example demonstrating single-table polymorphism. It defines an `item_type` enum and an `items` table containing a `type` column (referencing the enum) to distinguish between different logical types (Topic, Post, etc.) stored within the same table, along with shared and type-specific columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n```sql\ncreate type item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\ncreate table items (\n  id serial primary key,\n  type item_type not null default 'POST'::item_type,\n\n  -- Shared attributes:\n  parent_id int references items on delete cascade,\n  author_id int not null references people on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz,\n\n  -- Attributes that may be used by one or more item subtypes.\n  title text,\n  description text,\n  note text,\n  color text\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Node ID from a Node Entity - TypeScript\nDESCRIPTION: This snippet demonstrates how to expose a field resolver for a GraphQL entity to create a global node ID using the defined node ID handler. For a 'User' type, the resolver for 'id' uses 'nodeIdFromNode' with the user's handler and the user record to produce an encoded node ID string. Necessary in schemas using the Relay Node identification pattern. Prerequisites: properly configured handlers, correct context setup, and the 'nodeIdFromNode' utility function.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst typeDefs = /* GraphQL */ `\n  extend type User {\n    id: ID!\n  }\n`;\n\nconst planResolvers = {\n  User: {\n    id($user) {\n      return nodeIdFromNode(handlers.User, $user);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafserv Preset Options - JavaScript\nDESCRIPTION: This code snippet illustrates how to define a comprehensive 'preset' configuration object for Grafserv. The preset contains options related to ports, host binding, CORS, GraphQL paths, request handling, GraphiQL interface, and websocket support. All configuration keys must be specified according to Grafserv's documentation. The preset object is passed when creating a server instance. Required dependencies: none, but the structure must adhere to Grafserv's config schema. No direct output; this is an input parameter for server initialization.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst preset = {\n  grafserv: {\n    port: 5678,\n    host: \"0.0.0.0\",\n    dangerouslyAllowAllCORSRequests: false,\n    graphqlPath: \"/graphql\",\n    eventStreamPath: \"/graphql/stream\",\n    graphqlOverGET: true,\n    graphiql: true,\n    graphiqlPath: \"/\",\n    websockets: true,\n    maxRequestLength: 100000,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Finding Multiple Rows with `resource.find()` in Gra*fast*/@dataplan/pg (TypeScript)\nDESCRIPTION: Illustrates calling the `find()` method on a `@dataplan/pg` resource (`users`) to create a `PgSelectStep`. This step represents a collection of rows from the corresponding database table, typically used for lists or collections.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $users = users.find();\n//    ^ PgSelectStep - represents a set of rows\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Graphile V4 TypeScript\nDESCRIPTION: Illustrates the V4 procedural style of defining a schema hook. It uses the `builder.hook` method to register a function for the `GraphQLObjectType:fields` hook point. This function receives the fields, build object, and context as arguments and returns the modified fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst ExamplePlugin: Plugin = (builder) => {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    // ...\n    return fields;\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Ruru Explain Feature in PostGraphile Config (JavaScript)\nDESCRIPTION: This JavaScript configuration snippet for `graphile.config.mjs` enables the 'Explain' feature within the Ruru interface. Setting `grafast.explain` to `true` allows developers to inspect the Gra*fast* operation plan and the underlying SQL queries generated by PostGraphile directly in Ruru, which is useful for debugging query performance or logic. It's recommended to disable this in production due to potential information leakage.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/debugging.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"graphile.config.mjs\"\nexport default {\n  // ...\n  grafast: {\n    explain: true,\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with Random UUID PK (SQL)\nDESCRIPTION: This SQL snippet demonstrates another alternative for the `person` table's primary key, using fully random UUIDs generated by the `pgcrypto` extension. It ensures the extension is available and then defines the `id` column as type `uuid` with a default value generated by `gen_random_uuid()`. Other column definitions (`...`) are omitted for brevity but assumed to be similar to previous examples.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n\ncreate table forum_example.person (\n  id uuid primary key default gen_random_uuid(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Descriptions with Graphile Plugin Hooks (JavaScript)\nDESCRIPTION: Demonstrates how to use a custom JavaScript plugin to conditionally add a description to the 'clientMutationId' field on mutation input types in a Graphile-generated schema. The snippet shows a 'GraphQLInputObjectType_fields_field' hook using context 'scope' properties to target specific fields. Dependencies include Graphile Build, and the plugin must be registered appropriately in the Graphile setup. Key parameters include the field definition, build utilities (e.g., 'extend'), and context providing scope values. The output is a potentially extended field spec with a user-readable description if the conditions are met.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/context-object.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLInputObjectType_fields_field(\n        field,\n        { extend },\n        { scope: { isMutationInput, fieldName } },\n      ) {\n        // highlight-start\n        if (\n          !isMutationInput ||\n          fieldName !== \"clientMutationId\" ||\n          field.description != null\n        ) {\n          return field;\n        }\n        return extend(field, {\n          description:\n            \"An arbitrary string value with no semantic meaning. \" +\n            \"Will be included in the payload verbatim. \" +\n            \"May be used to track mutations by the client.\",\n        });\n        // highlight-end\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Heroku Application (Bash)\nDESCRIPTION: Uses the Heroku CLI command `heroku create` to provision a new application instance on the Heroku platform. Replace `myappname` with a unique desired name for the application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nheroku create myappname\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Key Relationships in PostgreSQL (SQL)\nDESCRIPTION: These SQL snippets illustrate the creation of one-to-many relationships between tables using the REFERENCES keyword in CREATE TABLE and ALTER TABLE statements. The code establishes a constraint linking a child table to a parent table, with optional cascading deletes. An index is also created on the foreign key column to support efficient queries, an essential requirement for PostGraphile's relation detection. Required: PostgreSQL (any version supporting standard constraints), and a basic understanding of SQL DDL. Input tables and referenced columns must exist; execution returns table and index creation status or errors on violation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/relations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.users (\n  -- ...\n  organization_id int not null\n    /* highlight-next-line */\n    references app_public.organizations on delete cascade,\n  -- ...\n);\ncreate index on app_public.users (organization_id);\n```\n\nLANGUAGE: sql\nCODE:\n```\nalter table users\n  add constraint users_organization_id_fkey\n  foreign key (organization_id)\n  references organizations\n  on delete cascade;\ncreate index on users (organization_id);\n```\n\n----------------------------------------\n\nTITLE: Integrating Grafserv with Express v4 in Node.js\nDESCRIPTION: This JavaScript snippet sets up a Node.js HTTP server using Express v4. It initializes Grafserv with a GraphQL schema (`schema.mjs`) and configuration presets (`graphile.config.mjs`), then integrates Grafserv's request handlers and WebSocket support into the Express application. Finally, it starts the server listening on the port specified in the preset or defaulting to 5678. Requires `node:http`, `express`, `grafserv/express/v4`, and local schema/config modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/express.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport { grafserv } from \"grafserv/express/v4\";\nimport preset from \"./graphile.config.mjs\";\nimport schema from \"./schema.mjs\";\n\n// Create an express app\nconst app = express();\n// (Add any Express middleware you want here.)\n\n// Create a Node HTTP server, mounting Express into it\nconst server = createServer(app);\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// Create a Grafserv instance\nconst serv = grafserv({ schema, preset });\n\n// Add the Grafserv instance's route handlers to the Express app, and register\n// websockets if desired\nserv.addTo(app, server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\n// Start the Express server\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Named Arguments (SQL)\nDESCRIPTION: Illustrates the recommended practice of defining PostgreSQL functions with named arguments (`a int, b int`). This allows referencing the arguments by their chosen names (`a`, `b`) directly within the function body, improving readability. Crucially for PostGraphile users, these names are used directly in the generated GraphQL schema, leading to a more understandable and maintainable API. The function calculates the sum of `a` and `b` and is `immutable` and `strict`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\n  select a + b;\n$$ language sql immutable strict;\n```\n\n----------------------------------------\n\nTITLE: Customizing Error Masking in PostGraphile (JavaScript)\nDESCRIPTION: This JavaScript code snippet demonstrates configuring a custom `maskError` function in `graphile.config.mjs` for PostGraphile. It logs detailed error information, including the `originalError`, to the server console for debugging purposes. The implementation shows how to handle different error types, returning `GraphQLError` instances directly or safe errors, while masking and hashing other errors before sending them to the client to prevent leaking sensitive information. Requires `postgraphile/graphql`, `postgraphile/grafast`, and `node:crypto`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/debugging.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"graphile.config.mjs\"\nimport { GraphQLError } from \"postgraphile/graphql\";\nimport { isSafeError } from \"postgraphile/grafast\";\nimport { createHash } from \"node:crypto\";\n\nconst sha1 = (text: string) =>\n  createHash(\"sha1\").update(text).digest(\"base64url\");\n\nexport default {\n  //...\n  grafserv: {\n    maskError(error) {\n      console.error(\"maskError was called with the following error:\");\n      console.error(error);\n      console.error(\"which had an originalError of:\");\n      console.error(error.originalError);\n\n      // You probably don't want this level of debugging in production as the\n      // results are sent to the client and it may leak implementation details\n      // you wish to keep private.\n      //\n      //   return error;\n\n      // Here's a more careful implementation:\n\n      if (error.originalError instanceof GraphQLError) {\n        return error;\n      } else if (\n        error.originalError != null &&\n        isSafeError(error.originalError)\n      ) {\n        return new GraphQLError(\n          error.originalError.message,\n          error.nodes,\n          error.source,\n          error.positions,\n          error.path,\n          error.originalError,\n          error.originalError.extensions ?? null,\n        );\n      } else {\n        // Hash so that similar errors can easily be grouped\n        const hash = sha1(String(error));\n        console.error(`Masked GraphQL error (hash: '${hash}')`, error);\n        return new GraphQLError(\n          `An error occurred (logged with hash: '${hash}')`,\n          error.nodes,\n          error.source,\n          error.positions,\n          error.path,\n          error.originalError,\n          // Deliberately wipe the extensions\n          {},\n        );\n      }\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Where Clause Graphile V5 TypeScript\nDESCRIPTION: Example of adding a WHERE condition in Graphile V5 using the Gra*fast* planning system. Instead of direct SQL manipulation, it retrieves the required value (`archived_at`) from the parent step (`$parent.get(\"archived_at\")`) and embeds this value (`$archivedAt`) into the `WHERE` clause of the current `PgSelectStep` (`$pgSelect`) using `sql` tagged template literal. This relies on the planning system to optimize the underlying SQL generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// V5\nconst $archivedAt = $parent.get(\"archived_at\");\n$pgSelect.where(sql`${$archivedAt} is not null`);\n```\n\n----------------------------------------\n\nTITLE: Configuring Extended V4 Options and Plugins in PostGraphile V5 Preset (TypeScript)\nDESCRIPTION: Provides a comprehensive example of a `graphile.config.js` file for migrating from V4 to V5. It shows how to integrate `makeV4Preset` with V4 options like `simpleCollections` and `jwtPgTypeIdentifier`, handle `appendPlugins`, replace `pluginHook` with the top-level `plugins` key, and configure PostgreSQL services using `makePgService`. It notes that some V4 plugins might now be presets in V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"graphile.config.js\"\nimport \"graphile-config\";\n\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\n// Use the 'pg' module to connect to the database\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    // The initial PostGraphile V5 preset\n    PostGraphileAmberPreset,\n\n    // Change the options and add/remove plugins based on your V4 configuration:\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n      appendPlugins: [\n        /*...*/\n      ],\n    }),\n\n    // Note some plugins are now \"presets\", e.g.\n    // `@graphile/simplify-inflection`, those should be listed here instead of `appendPlugins`\n  ],\n\n  plugins: [\n    /*\n     * If you were using `pluginHook` before, the relevant plugins will need\n     * listing here instead. You can also move the `appendPlugins` list here\n     * for consistency if you like.\n     */\n  ],\n\n  /*\n   * PostgreSQL database configuration.\n   *\n   * If you're using the CLI you can skip this and use the `-c` and `-s`\n   * options instead, but we advise configuring it here so all the modes of\n   * running PostGraphile can share it.\n   */\n  pgServices: [\n    makePgService({\n      // Database connection string:\n      connectionString: process.env.DATABASE_URL,\n      // List of schemas to expose:\n      schemas: [\"app_public\"],\n      // Superuser connection string, only needed if you're using watch mode:\n      // superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    }),\n  ],\n};\n\nexport default preset;\n```\n```\n\n----------------------------------------\n\nTITLE: Getting a Single Row with `resource.get()` in Gra*fast*/@dataplan/pg (TypeScript)\nDESCRIPTION: Demonstrates using the `get()` method on a `@dataplan/pg` resource (`users`) with a filter based on a unique constraint (e.g., `id`). This creates a `PgSelectSingleStep`, representing a single database row expected from the query. The filter value (`$userId`) is typically another Gra*fast* step.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst $user = users.get({ id: $userId });\n//    ^ PgSelectSingleStep - represents a single row\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js via Homebrew on macOS using Bash\nDESCRIPTION: Installs Node.js using the Homebrew package manager on macOS. Requires Homebrew to be installed first. This command fetches and installs the latest available stable Node.js version from the Homebrew repositories.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install node\n```\n\n----------------------------------------\n\nTITLE: Resolving Field Value with Crystal (Pseudocode)\nDESCRIPTION: Resolves a GraphQL field's value, potentially leveraging a Crystal plan. It establishes the execution context (`aether`), identifies the relevant plan, and checks if a plan exists for the current path. If no plan exists, it falls back to standard GraphQL resolution. If a plan exists, it retrieves or creates a batch, generates a Crystal object representation for the parent, gets the result from the batch (potentially asynchronously), and wraps the result using `CrystalWrap` before returning it.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_35\n\nLANGUAGE: pseudocode\nCODE:\n```\nResolveFieldValueCrystal(schema, document, operationName, variableValues, context, rootValue, field, parentObject,\nargumentValues, pathIdentity):\n\n- Let {fieldName} be the name of {field}.\n- Let {parentType} be the object type on which {field} is defined.\n- Let {returnType} be the expected type of {field}.\n- Let {aether} be {EstablishAether(schema, document, operationName, variableValues, context, rootValue)}.\n- Let {planId} be the value for key {pathIdentity} within {aether}.{planIdByPathIdentity}.\n- Let {plan} be the plan at index {planId} within {aether}.{plans}.\n- If {plan} is null:\n  - If {parentObject} is a crystal wrapped value:\n    - Let {objectValue} be the data within {parentObject}.\n  - Otherwise:\n    - Let {objectValue} be {parentObject}.\n  - Return {graphqlResolveFieldValue(parentType, objectValue, fieldName, argumentValues)}.\n- Otherwise:\n  - Let {id} be a new unique id.\n  - Let {batch} be {GetBatch(aether, pathIdentity, parentObject, variableValues, context, rootValue)}.\n  - Let {crystalContext} be {batch}.{crystalContext}.\n  - Let {plan} be {batch}.{plan}.\n  - If {parentObject} is a crystal object:\n    - Let {parentCrystalObject} be {parentObject}. (Note: for the most optimal execution, `rootValue` passed to graphql\n      should be a crystal object, this allows using {crystalContext} across the entire operation if plans are used\n      everywhere. Even more optimised would be if we can share the same {crystalContext} across multiple `rootValue`s\n      for multiple parallel executions (must be within the same aether) - e.g. as a result of multiple identical\n      subscription operations.)\n  - Otherwise:\n    - (Note: we need to \"fake\" that the parent was a plan. Because we may have lots of resolvers all called for the same\n      parent object, we use a map. This happens to mean that multiple values in the graph being the same object will be\n      merged automatically.)\n    - Let {parentPathIdentity} be the parent path for {pathIdentity}.\n    - Let {parentPlanId} be the value for key {parentPathIdentity} within {aether}.{planIdByPathIdentity}.\n    - Let {parentPlan} be the plan at index {parentPlanId} within {aether}.{plans}.\n    - Let {parentId} be {GetValuePlanId(aether, crystalContext, parentPlan, parentObject)}.\n    - Let {indexes} be an empty list.\n    - Let {parentCrystalObject} be {NewCrystalObject(parentPlan, parentPathIdentity, parentId, indexes, parentObject,\n      crystalContext)}.\n  - Let {result} be {GetBatchResult(batch, parentCrystalObject)} (note: could be asynchronous).\n  - ~~(Note: this field execution is identified as 'id', even if it's a nested list. Crystal abstracts away the list for\n    you, so the crystal object received will always have a non-list value stored under 'id', but each entry in the\n    returned results will have a different crystal object, all with the same 'id'. It's possible that 'id' is not the\n    right name to give this property since there will be many with the same value.)~~\n  - Return {CrystalWrap(crystalContext, plan, returnType, parentCrystalObject, pathIdentity, id, result)}.\n```\n\n----------------------------------------\n\nTITLE: Displaying Single Scalar GraphQL Result (JSON)\nDESCRIPTION: This JSON object is the expected result of the 'randomNumber' GraphQL query. It shows the numeric field returned as the root property aligned with the GraphQL field name. This format is useful for understanding how scalar results are returned from custom fields in Graphile-based APIs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ \"randomNumber\": 4 }\n```\n\n----------------------------------------\n\nTITLE: Example Standard GraphQL Query\nDESCRIPTION: A basic GraphQL query retrieving a list of people's names. This serves as a comparison point before demonstrating how to convert it into a live query subscription.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from GraphQL to Grafast API Usage - Diff (JavaScript ES Modules)\nDESCRIPTION: Demonstrates how to update import statements and function calls from graphql.js to grafast for API compatibility. It imports grafast's grafast and execute functions in place of graphql and execute, and adjusts the function call to use grafast in an async context. The main parameters are the GraphQL schema and context object. This mutation helps transition existing code to leverage Grafast's plan-based execution model.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/existing-schema.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-import { graphql, execute } from 'graphql';\n+import { grafast, execute } from 'grafast';\n\n-const result = await graphql({\n+const result = await grafast({\n   schema,\n   contextValue: {},\n   source: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL for Logical Decoding (INI)\nDESCRIPTION: Specifies the necessary settings within the `postgresql.conf` file to enable logical decoding, which is required for the `@graphile/subscriptions-lds` plugin. `wal_level` must be set to `logical`, and `max_wal_senders` and `max_replication_slots` should be increased to accommodate the replication connections PostGraphile will use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nwal_level = logical\nmax_wal_senders = 10\nmax_replication_slots = 10\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Repository and Prerequisites on Linux - Shell\nDESCRIPTION: Executes a series of shell commands to update the Linux package repository, install prerequisites, add Docker's official GPG key, and set up the Docker apt repository. No external dependencies beyond apt and curl. These prepare a Linux workstation for subsequent Docker installation. Inputs: none. Outputs: repository configuration files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt-get update\\n$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common\\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\\n$ sudo add-apt-repository \\\"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\\\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Simple Subscriptions via CLI - PostGraphile (bash)\nDESCRIPTION: This bash command shows how to run PostGraphile with the @graphile/pg-pubsub plugin and enable simple subscriptions using the --subscriptions and --simple-subscriptions flags. You must have PostGraphile and the pg-pubsub plugin installed. Replace 'mydb' with your own PostgreSQL connection string as needed. This configures the server to support GraphQL subscriptions via PostgreSQL NOTIFY/LISTEN.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --plugins @graphile/pg-pubsub \\\n  --subscriptions \\\n  --simple-subscriptions \\\n  -c mydb\n```\n\n----------------------------------------\n\nTITLE: Using Transactions with Local JWT Claims - SQL\nDESCRIPTION: This snippet showcases the use of a transaction block to scope session parameters set with 'SET LOCAL'. Inside the transaction ('BEGIN' to 'COMMIT'), the 'jwt.claims.user_id' value is available, but is cleared on 'COMMIT' or 'ROLLBACK', preventing session leakage. This is important for authentication and privacy. Assumes a PostgreSQL session with proper permissions. There is no output beyond the change in session state.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nbegin;\nset local jwt.claims.user_id to 2;\n\n-- Has access to `jwt.claims.user_id`\ncommit;\n\n-- Does not have access to `jwt.claims.user_id`\n```\n\n----------------------------------------\n\nTITLE: Enabling SQL Explain Logging via DEBUG Environment Variable (Bash)\nDESCRIPTION: This Bash command sets the `DEBUG` environment variable to `@dataplan/pg:PgExecutor:explain` before running PostGraphile. This specific debug namespace instructs the `@dataplan/pg` module to output detailed SQL execution plans (EXPLAIN results) to the console, aiding in diagnosing database-related issues.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Bash (Linux, macOS, etc)\nexport DEBUG=\"@dataplan/pg:PgExecutor:explain\"\npostgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: User Entity Node ID Handler Example - JavaScript\nDESCRIPTION: This example defines a 'userHandler' object that provides a full handler spec for the 'User' GraphQL type to resolve, match, encode, and retrieve user entities via node IDs. It specifies the object type ('User'), its associated codec, and implements functions for planning the node ID, matching specs, extracting identifiers, and retrieving records. Depends on the 'base64JSONCodec' and other steps/utilities such as 'constant', 'list', 'access', and 'pgResource.get'. Essential in any system supporting GraphQL's Node interface and global identification pattern.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst USER = \"User\";\n\nconst userHandler = {\n  typeName: USER,\n\n  codec: base64JSONCodec,\n\n  // Given a User record, return a step describing the data to be encoded by\n  // the codec:\n  plan($user: PgSelectSingleStep) {\n    return list([constant(USER), $user.get(\"id\")]);\n  },\n\n  // Given the data decoded by the codec, determine if the data is for our\n  // type. In this particular handler, the check looks at the first entry in\n  // the list to see if it matches our type name.\n  match(list) {\n    return list[0] === USER;\n  },\n\n  // Given a step representing decoded data that passes the `match` test above,\n  // return a specifier object that can be used to retrieve or reference\n  // this entity.\n  getSpec($list: ListStep<any[]>) {\n    return {\n      id: access($list, 1),\n    };\n  },\n\n  // Given a spec (the result of `getSpec` above), return a step that resolves\n  // to the entity (if found).\n  get(spec: any) {\n    return pgResource.get(spec);\n  },\n};\n\nconst handlers = {\n  User: userHandler,\n  // Add more handlers here\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom PostGraphile Plugin Metadata - JavaScript (package.json)\nDESCRIPTION: Defines the Node.js package metadata for the custom PostGraphile plugin including its name, version, and dependencies. It lists the essential dependencies required at runtime, notably 'graphile-utils' and 'postgraphile', key for plugin functionality. Standard fields like author, license, and entry point are also specified; adjust these as needed before deployment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"custom-plugin\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Custom plugin example for PostGraphile.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Alexis ROLLAND\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"graphile-utils\": \"^4.5.6\",\n    \"postgraphile\": \"^4.5.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering a Subscription Event using PostgreSQL NOTIFY (SQL)\nDESCRIPTION: Sends a PubSub event on the PostgreSQL channel 'forum:1:message' with a JSON payload, simulating a new message creation. Requires sufficient database privileges. The event can be picked up by any pgSubscriber listening to that channel, and the payload structured as an event object with 'event', 'sub', and 'id' fields. Used mainly for manual testing or custom notification triggering.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nNOTIFY \"forum:1:message\", '{\"event\": \"create\", \"sub\": 1, \"id\": 27}';\n```\n\n----------------------------------------\n\nTITLE: Rendering Table Footnote and Informational Alert - React (JavaScript)\nDESCRIPTION: This snippet renders a styled footnote for the pricing table, using a styled div and strong/sup markup, together with a contextually relevant message referencing PostGraphile production considerations. It includes an inline anchor link and is suitable for display below feature tables as a persistent or context-sensitive note. Dependencies are CSS modules (styles.footnoteText), standard React markup, and surrounding data context. The input is static and the output is a styled informational block below the table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n<div className={styles.footnoteText}>\n  <strong>\n    <sup>â€¡</sup>\n  </strong>{\" \"}\n  These features integrate deeply with PostGraphile V4 and have been optimized\n  for its nuances by the maintainer. If you wish to build and maintain\n  protections yourself rather than using the Pro plugin, refer to{\" \"}\n  <a href=\"/postgraphile/production/\">Production Considerations</a> for\n  information on how you might go about doing this.\n</div>\n```\n\n----------------------------------------\n\nTITLE: Mutating GraphQL API to Create a User - GraphQL\nDESCRIPTION: Shows a sample GraphQL mutation that creates a new user via the 'createUser' mutation. Accepts an input payload containing the user's username and returns user details including id, username, and createdDate. This is intended for use with the PostGraphile-generated schema after the custom plugin has been integrated.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_23\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createUser(input: { user: { username: \"Bob\" } }) {\n    user {\n      id\n      username\n      createdDate\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Naming Conflicts using Function Name Qualification in PostgreSQL\nDESCRIPTION: Defines the `get_user` function, again resolving the naming conflict between the argument `id` and the column `users.id`. This version disambiguates by qualifying the argument reference with the function name (`get_user.id`). It's marked `stable`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = get_user.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Calling a Newly Added Inflector in Graphile Build (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to call a newly added custom inflector, such as the `enhanced` inflector defined previously. Similar to replaced inflectors, the first argument (the preset) provided by the Graphile Build system to the inflector definition is hidden from the calling code. Only the arguments defined after the preset (e.g., `columnName`) are passed during the call.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst text = inflection.enhanced(\"avatarUrl\");\n```\n\n----------------------------------------\n\nTITLE: Modified Node Interface with Custom ID Field Name (GraphQL)\nDESCRIPTION: Displays the GraphQL `Node` interface definition resulting from building the schema with the `nodeIdFieldName` option set to \"flibble\". The standard `id: ID!` field is replaced by `flibble: ID!`, reflecting the customization passed during schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugin-options.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  flibble: ID!\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via CLI Flag\nDESCRIPTION: This command line example shows how to enable multiple PostGraphile plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) when running PostGraphile from the command line. It uses the `--plugins` flag, which must be the first argument passed, followed by a comma-separated list of plugin package names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n```\npostgraphile --plugins \\\n  @graphile/operation-hooks,@graphile/pg-pubsub,@graphile/pro \\\n  -c postgres:///my_db\n```\n```\n\n----------------------------------------\n\nTITLE: Installing wal2json PostgreSQL Extension via Shell\nDESCRIPTION: Provides shell commands to download the `wal2json` source code from GitHub, compile it, and install it into the PostgreSQL instance. This extension is a prerequisite for the `@graphile/subscriptions-lds` plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/eulerto/wal2json.git\ncd wal2json\nUSE_PGXS=1 make\nUSE_PGXS=1 make install\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via HTTPS with Yarn (Shell)\nDESCRIPTION: Triggers the website deployment using Yarn and the `deploy` script, intended for situations where SSH is not used. The `GIT_USER` environment variable must be set to the relevant GitHub username. This method typically relies on HTTPS authentication, potentially prompting for a password or Personal Access Token, to push the built site to the `gh-pages` branch.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Custom Inflection Plugin: Renaming Root Types (JavaScript)\nDESCRIPTION: This plugin implements the 'inflection' scope to customize how root GraphQL types are named. The 'replace.builtin' handler checks if the type name is 'Query', 'Mutation', or 'Subscription', and transforms it by prefixing 'Root'; otherwise, it falls back to the previous naming logic. Requires Graphile Build's inflection system and is intended to be included in the plugin list of a preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst RootNamingPlugin = {\n  name: \"RootNamingPlugin\",\n  version: \"0.0.0\",\n  description: \"Prefixes 'Root' to the root operation types\",\n\n  inflection: {\n    replace: {\n      builtin(previous, options, text) {\n        if ([\"Query\", \"Mutation\", \"Subscription\"].includes(text)) {\n          return `Root${text}`;\n        } else {\n          return previous(text);\n        }\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Wrapping a PostGraphile Resolver Using makeWrapResolversPlugin in Node.js\nDESCRIPTION: Defines a Node.js module that wraps the 'createUser' resolver using the graphile-utils makeWrapResolversPlugin function. The plugin logs input arguments and results before and after the original resolver executes. Place this in custom-plugin/index.js and ensure dependencies on graphile-utils and postgraphile are installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nconst { makeWrapResolversPlugin } = require(\"graphile-utils\");\n\n// Create custom wrapper for resolver createUser\nconst createUserResolverWrapper = () => {\n  return async (resolve, source, args, context, resolveInfo) => {\n    // You can do something before the resolver executes\n    console.info(\"Hello world!\");\n    console.info(args);\n\n    // Let resolver execute against database\n    const result = await resolve();\n\n    // You can do something after the resolver executes\n    console.info(\"Hello again!\");\n    console.info(result);\n\n    return result;\n  };\n};\n\n// Register custom resolvers\nmodule.exports = makeWrapResolversPlugin({\n  Mutation: {\n    createUser: createUserResolverWrapper(),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Schema Output with No-op Plugin Log\nDESCRIPTION: Shows the expected console output and resulting GraphQL schema when running the code that loads the `NoopPlugin`. It includes the console log message \"I don't do anything\" from the plugin, followed by the basic GraphQL schema structure generated by the default plugins, including the `Node` interface and `Query` type.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugins.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nI don't do anything\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  id: ID!\n\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    id: ID!\n  ): Node\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @graphile/subscriptions-lds Plugin (Shell)\nDESCRIPTION: Shell command using Yarn to install the `@graphile/subscriptions-lds` Node.js package. This plugin provides the realtime provider functionality for PostGraphile, enabling live queries by interfacing with PostgreSQL's logical decoding.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @graphile/subscriptions-lds\n```\n\n----------------------------------------\n\nTITLE: Enabling TypeScript ESM Loader via NODE_OPTIONS - Shell\nDESCRIPTION: This shell snippet demonstrates how to enable TypeScript ES Module support in Node.js by setting the `NODE_OPTIONS` environment variable to include the `ts-node/esm` loader. This is required when executing TypeScript files as ES modules. The script should be run in a POSIX-compatible shell before starting the Node.js process consuming the `.ts` config.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-config/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport NODE_OPTIONS=\"$NODE_OPTIONS --loader ts-node/esm\"\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile Beta with `pgl` via `npx` in Bash\nDESCRIPTION: Executes the beta version of the PostGraphile `pgl` command using `npx`, avoiding a permanent installation. It utilizes the `pgl/amber` preset, enables explain mode (`-e`) for development diagnostics, and specifies the PostgreSQL database connection string (`-c`). Replace `postgres:///mydb` with your actual database connection string and add `-s your_schema` if needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx pgl@beta -P pgl/amber -e -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic GraphQL Schema\nDESCRIPTION: Shows a basic GraphQL schema definition with a `Query` type having a `currentUser` field returning a `User`, and a `User` type with `name` and `friends` fields. This schema serves as the basis for comparing traditional and Grafast resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\ntype Query {\n  currentUser: User\n}\ntype User {\n  name: String!\n  friends: [User!]!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring makeAddPgTableConditionPlugin V5 Signature in TypeScript\nDESCRIPTION: This TypeScript snippet shows the updated V5 signature of makeAddPgTableConditionPlugin, reflecting the shift to the plan-based system and an optional condition generator. The function now accepts a match object (optionally including serviceName), a condition field name, a field spec generator, and an optional condition generator. The signature builds upon types from GraphileBuild, GraphileConfig, and related modules, so those packages must be present in the environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// V5 signature\\nfunction makeAddPgTableConditionPlugin(\\n  match: { serviceName?: string; schemaName: string; tableName: string },\\n  conditionFieldName: string,\\n  fieldSpecGenerator: (build: GraphileBuild.Build) => GraphileInputFieldConfig,\\n\\n  // OPTIONAL:\\n  conditionGenerator?: (\\n    value: FieldArgs,\\n    helpers: {\\n      $condition: PgConditionStep<PgSelectStep>;\\n      sql: typeof sql;\\n      sqlTableAlias: SQL;\\n      build: GraphileBuild.Build;\\n    },\\n  ) => SQL | null | undefined,\\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Querying Forums Ordered by Creation Date â€“ GraphQL\nDESCRIPTION: This GraphQL query retrieves a list of forums, ordered from newest to oldest by the 'created_at' field, utilizing the orderBy argument provided by PostGraphile. The query expects the 'allForums' connection field to support the orderBy input and will return each forum's 'id' and 'name'. It demonstrates PostGraphile's built-in ordering capabilities without any customizations. No dependencies are required beyond the GraphQL schema generated by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsNewestToOldest {\n  allForums(orderBy: [CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining postgraphile.tags.json5 Structure for Tagging Entities (JSON5)\nDESCRIPTION: This JSON5 snippet provides an example structure for a postgraphile.tags.json5 file, illustrating how to assign descriptions and custom tags to classes (tables, etc.), attributes (columns), and other entity types. The config supports schema-qualified entity targeting, description overrides, and tag merging. The format requires a version key and must be compatible with JSON5 features. Users must update the path and entity names accordingly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags-file.md#_snippet_1\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    /*\n     * There can be entries here for:\n     *\n     * - `class`: for tables, composite types, views and materialized views\n     * - `attribute`: for columns/attributes (of any 'class' type)\n     * - `constraint`: for table constraints\n     * - `procedure`: for functions/procedures\n     */\n    class: {\n      /*\n       * The next level describes the named type. We've just used the table\n       * name \"post\" but it could be \"my_schema.post\" if you have multiple\n       * tables with the same name and you don't want this rule to apply to\n       * all of them.\n       */\n      post: {\n        /*\n         * This will override the description sourced from the PostgreSQL COMMENT.\n         */\n        description: \"A post within our forum.\",\n\n        /*\n         * Add tags specific to the 'post' table here. You can omit this if you\n         * don't want to add any tags.\n         */\n        tags: {\n          foreignKey: [\n            \"(default_user_id) references user (id)|@fieldName defaultUser\",\n            \"(organization_id) references organization (id)|@fieldName organization\",\n          ],\n        },\n\n        /*\n         * We've added a shortcut to class-types so you can tag/describe\n         * columns at the same time of the class.\n         */\n        attribute: {\n          /*\n           * Assuming `body` is one of the columns in the 'post' table.\n           */\n          body: {\n            /*\n             * Optional description, if provided overrides the PostgreSQL\n             * `COMMENT ON COLUMN post.body`.\n             */\n            description: \"The body of the post\",\n            tags: {\n              /*\n               * Here we indicate that the 'body' field will not be available\n               * in the update mutation.\n               */\n              omit: \"update\",\n            },\n          },\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Querying User Details with Conditional Friendship Fetch (GraphQL)\nDESCRIPTION: This snippet demonstrates a GraphQL query that fetches the current user's basic information, and conditionally fetches a list of friends only if the `$includeFriends` boolean variable is `true`. It shows the use of the `@include` directive to dynamically control the GraphQL query plan. The main parameter, `$includeFriends`, is a boolean with a default value of `false`. The result will include friends data only if requested, optimizing network and backend work.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/eval.mdx#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetUserDetails($includeFriends: Boolean! = false) {\\n  currentUser {\\n    name\\n    avatarUrl\\n    friends(first: 100) @include(if: $includeFriends) {\\n      name\\n      avatarUrl\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Mutation Resolver using Raw Plugin API Hook (JavaScript)\nDESCRIPTION: This example demonstrates wrapping the `createLink` mutation resolver using the raw `GraphQLObjectType:fields:field` hook for advanced customization. It performs input validation (title length), uses `addArgDataGenerator` to ensure the created record's `id` is selected (aliased as `__createdRecordId`), calls the original resolver, executes a custom function (`performAnotherTask`) with the created ID after the original resolver completes, and finally returns the original result. This approach allows complex pre- and post-resolution logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction performAnotherTask(linkId) {\n  console.log(`We created link ${linkId}!`);\n}\n\nmodule.exports = function CreateLinkWrapPlugin(builder) {\n  builder.hook(\n    \"GraphQLObjectType:fields:field\",\n    (\n      field,\n      { pgSql: sql },\n      { scope: { isRootMutation, fieldName }, addArgDataGenerator },\n    ) => {\n      if (!isRootMutation || fieldName !== \"createLink\") {\n        // The 'GraphQLObjectType:fields:field' hook runs for every field on\n        // every object type in the schema. If it's not a field in the root\n        // mutation type, or the field isn't named 'createLink', we don't want\n        // to modify it in this hook - so return the input object unmodified.\n        return field;\n      }\n\n      // We're going to need link.id for our `performAnotherTask`; so we're going\n      // to abuse addArgDataGenerator to make sure that this field is ALWAYS\n      // requested, even if the user doesn't specify it. We're careful to alias\n      // the result to a field that begins with `__` as that's forbidden by\n      // GraphQL and thus cannot clash with a user's fields.\n      addArgDataGenerator(() => ({\n        pgQuery: (queryBuilder) => {\n          queryBuilder.select(\n            // Select this value from the result of the INSERT:\n            sql.query`${queryBuilder.getTableAlias()}.id`,\n            // And give it this name in the result data:\n            \"__createdRecordId\",\n          );\n        },\n      }));\n\n      // It's possible that `resolve` isn't specified on a field, so in that case\n      // we fall back to a default resolver.\n      const defaultResolver = (obj) => obj[fieldName];\n\n      // Extract the old resolver from `field`\n      const { resolve: oldResolve = defaultResolver, ...rest } = field;\n\n      return {\n        // Copy over everything except 'resolve'\n        ...rest,\n\n        // Add our new resolver which wraps the old resolver\n        async resolve(...resolveParams) {\n          // Perform some validation (or any other action you want to do before\n          // calling the old resolver)\n          const RESOLVE_ARGS_INDEX = 1;\n          const {\n            input: {\n              link: { title },\n            },\n          } = resolveParams[RESOLVE_ARGS_INDEX];\n          if (title.length < 3) {\n            throw new Error(\"Title is too short!\");\n          }\n\n          // Call the old resolver (you SHOULD NOT modify the arguments it\n          // receives unless you also manipulate the AST it gets passed as the\n          // 4th argument; which is quite a lot of effort) and store the result.\n          const oldResolveResult = await oldResolve(...resolveParams);\n\n          // Perform any tasks we want to do after the record is created.\n          await performAnotherTask(oldResolveResult.data.__createdRecordId);\n\n          // Finally return the result.\n          return oldResolveResult;\n        },\n      };\n    },\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Defining InputVariablePlan for Handling GraphQL Variables (Pseudocode)\nDESCRIPTION: Specifies the `InputVariablePlan` function for creating plans representing GraphQL variables. It handles potential non-null mismatches between the variable definition and usage, retrieves the tracked variable value plan from the `aether`, and correctly applies the `defaultValue` only if the variable is not provided (evaluates to `undefined`). It relies on GraphQL validation for type compatibility and coercion.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_13\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputVariablePlan(aether, variableName, variableType, inputType, defaultValue):\n\n- If {variableType} is a non-null type and {inputType} is not a non-null type:\n  - Let {unwrappedVariableType} be the inner type of {variableType}.\n  - Return {InputVariablePlan(aether, variableName, unwrappedVariableType, inputType, defaultValue)}.\n- Assert: {variableType} is equal to {inputType}.\n- Let {variableValuePlan} be {aether}.{trackedVariableValuesPlan}.{get(variableName)}.\n- If {defaultValue} does not exist:\n  - Return {variableValuePlan}.\n- Otherwise, if {variableValuePlan}.{evalIs(undefined)}:\n  - (Note: we're going to pretend no value was passed instead of the variable, so defaultValue should be used.)\n  - Return {InputPlan(aether, inputType, undefined, defaultValue)}.\n- Otherwise:\n  - (Note: {variableValuePlan} would eval to something other than {undefined}, so {defaultValue} will not be used.)\n  - Return {variableValuePlan}.\n\nNote: GraphQL validation will ensure that the type of the variable and input type are \"compatible\"; so the only\ndifference allowed is that the variable might be non-null when the input type is not.\n\nNote: The GraphQL algorithm {CoerceVariableValues} will ensure that the contents of the variables adhere to the expected\ntypes, so we do not need to perform coercion ourselves.\n```\n\n----------------------------------------\n\nTITLE: Installing Grafast and GraphQL via npm - Bash\nDESCRIPTION: Installs both grafast (beta) and graphql packages in your project using npm. These dependencies are necessary for running a GraphQL server with Grafast integration. No parameters are required, and the command should be executed in the root of your Node.js project directory.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/existing-schema.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save grafast@beta graphql\n```\n\n----------------------------------------\n\nTITLE: Defining Signatures for makeWrapPlansPlugin in TypeScript\nDESCRIPTION: Defines the two overloaded TypeScript function signatures for `makeWrapPlansPlugin`. Method 1 targets specific resolvers via a rules object/generator (`PlanWrapperRules` | `PlanWrapperRulesGenerator`). Method 2 uses a filter function to identify resolvers to wrap and a rule function to generate the wrapper logic. Both methods return a `GraphileConfig.Plugin`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Method 1: wrap individual resolvers of known fields\nfunction makeWrapPlansPlugin(\n  rulesOrGenerator: PlanWrapperRules | PlanWrapperRulesGenerator,\n): GraphileConfig.Plugin;\n\ninterface PlanWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\n  };\n}\n\ninterface PlanWrapperRule {\n  plan?: PlanWrapperFn;\n}\n\ntype PlanWrapperFn = (\n  plan: SmartFieldPlanResolver,\n  $source: ExecutableStep,\n  fieldArgs: FieldArgs,\n  info: FieldInfo,\n) => any;\n\ntype PlanWrapperRulesGenerator = (\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\n) => PlanWrapperRules;\n\n/****************************************/\n\n// Method 2: wrap all resolvers that match a filter function\nfunction makeWrapPlansPlugin<T>(\n  filter: (\n    context: GraphileBuild.ContextObjectFieldsField,\n    build: GraphileBuild.Build,\n    field: GrafastFieldConfig,\n  ) => T | null,\n  rule: (match: T) => PlanWrapperRule | PlanWrapperFn,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Compiling a Template Expression Fragment with te.compile - JavaScript\nDESCRIPTION: This code snippet showcases the use of `te.compile` to build a JavaScript template fragment into a code string with parameter references, without evaluating it. The compiled result contains the interpolated string and a references object. The snippet demonstrates how expressions can be turned into a compiled form for debugging or validation. Dependencies include the `te` template engine and the `assert` library. Inputs consist of values referenced via `te.ref`, with expected outputs being a compiled object of code and reference mappings. Important limitation: the fragment is not executed, only compiled.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fragment = te`return ${te.ref(1)} + ${te.ref(2)}`;\nconst result = te.compile(fragment);\n\nassert.deepEqual(result, {\n  string: `return _$$_ref_1 + _$$_ref_2`,\n  refs: { _$$_ref_1: 1, _$$_ref_2: 2 },\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring makeAddPgTableOrderByPlugin V4 Signatures and Structures - TypeScript\nDESCRIPTION: This group of TypeScript interfaces and type aliases specify the previous (V4) contract for creating a table OrderBy plugin in Graphile. It defines the function signature, how custom order objects map enum names to specific ordering spec logic, and flexible identity support (e.g., string, SQL, or callback form). The utility function orderByAscDesc is designed to simplify building conformant OrderBy spec objects using these types. Dependencies include Build objects, SQL fragments, and QueryBuilder types from Graphile/Postgres internals.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// V4 signature\nfunction makeAddPgTableOrderByPlugin(\n  schemaName: string,\n  tableName: string,\n  ordersGenerator: (build: Build) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): Plugin;\n\nexport interface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    value: {\n      alias?: string;\n      specs: Array<OrderSpec>;\n      unique: boolean;\n    };\n  };\n}\n\ntype OrderSpec =\n  | [OrderBySpecIdentity, boolean]\n  | [OrderBySpecIdentity, boolean, boolean];\n\ntype OrderBySpecIdentity =\n  | string\n  | SQL\n  | ((options: { queryBuilder: QueryBuilder }) => SQL);\n\nexport function orderByAscDesc(\n  baseName: string,\n  columnOrSqlFragment: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n```\n\n----------------------------------------\n\nTITLE: Equivalent Hook Application Pattern for GraphQL Object Construction (JavaScript)\nDESCRIPTION: Illustrates the underlying equivalence for the `newWithHooks` approach, showing how multiple hook functions are applied in sequence to the type specification prior to object construction. This code snippet expands upon the hook wrapping semantics by making explicit the order and composition of hooks as modifier functions. Assumes hook functions (`hook1`, `hook2`, `hook3`) are previously defined. Accepts a 'spec' input and finally returns an instance of `GraphQLObjectType` constructed from the fully modified spec.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/hooks.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyType = new GraphQLObjectType(hook3(hook2(hook1(spec))));\n```\n\n----------------------------------------\n\nTITLE: Enabling Live Queries via PostGraphile CLI\nDESCRIPTION: Demonstrates running PostGraphile from the command line with live query support enabled. Key flags include `--live`, `--owner-connection` for elevated privileges needed by logical decoding, and `--append-plugins` to add `@graphile/subscriptions-lds`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://postgraphile_user:postgraphile_pass@host/db \\\n  --live \\\n  --owner-connection postgres://db_owner:db_owner_pass@host/db \\\n  --append-plugins @graphile/subscriptions-lds \\\n  ...\n```\n\n----------------------------------------\n\nTITLE: Deploying Application to Heroku via Git Push (Bash)\nDESCRIPTION: Pushes the `master` branch of the local Git repository to the `heroku` remote repository. This action triggers Heroku's build and deployment process based on the project's configuration (e.g., `Procfile`, `package.json`). This command is used in the minimal CLI setup guide.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit push heroku master\n```\n\n----------------------------------------\n\nTITLE: Defining Node.js Start Script for Express/PostGraphile App using JSON\nDESCRIPTION: Shows the `scripts` section of a `package.json` file for an Express application using the PostGraphile library. The `start` script simply executes the main application file (`src/index.js`) using Node.js.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"start\": \"node src/index.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving an Empty Preset Configuration in TypeScript\nDESCRIPTION: Demonstrates the correct way to handle an empty preset configuration using `resolvePreset({})` as mandated in version 0.0.1-beta.12. Directly using an empty object literal `{}` as a `GraphileConfig.ResolvedPreset` is deprecated and no longer valid. This function ensures presets are correctly processed.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-config/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nresolvePreset({})\n```\n\n----------------------------------------\n\nTITLE: Triggering a Subscribed Event via GraphQL Mutation (GraphQL)\nDESCRIPTION: GraphQL mutation to create a new message, thereby triggering a subscription event for listeners. Inputs: message object with forumId and body. Outputs: mutation response confirming insertion. Requires backend logic to connect message creation with event publication (e.g., via PostgreSQL trigger function and pg_notify). Used in Ruru or other GraphQL clients for manual testing and demonstration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_7\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation MyMutation {\n  createMessage(input: { message: { forumId: 1, body: \"Hello World!\" } }) {\n    clientMutationId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Single Row via GraphQL (GraphQL)\nDESCRIPTION: This GraphQL query requests a single object field 'currentUser', retrieving its 'nodeId', 'id', and 'username' subfields. This showcases standard entity retrieval with custom Graphile SQL-backed function mapping. It depends on the GraphQL schema augmentation by the corresponding 'current_user()' SQL function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  currentUser {\n    nodeId\n    id\n    username\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Watching for Schema Changes with `watchPostGraphileSchema` in JavaScript\nDESCRIPTION: Illustrates using `watchPostGraphileSchema` to automatically regenerate the GraphQL schema when database changes are detected. It takes similar arguments to `createPostGraphileSchema` plus an `onNewSchema` callback function. This callback receives the newly generated schema each time it's updated. The function returns a promise that resolves to a `releaseWatcher` function, which can be called later to stop watching for changes. The initial schema is guaranteed to be passed to `onNewSchema` before the promise resolves.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nasync function main() {\n  let graphqlSchema;\n  const releaseWatcher = await watchPostGraphileSchema(\n    pgPool,\n    pgSchemas,\n    options,\n    (newSchema) => {\n      console.log(\"Generated new GraphQL schema\");\n      graphqlSchema = newSchema;\n    },\n  );\n  // graphqlSchema is **guaranteed** to be set here.\n\n  // ... do stuff with graphqlSchema\n\n  await releaseWatcher();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Behavior in Graphile Plugin Schema Hooks - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the old pattern for checking and applying entity behavior within a Graphile plugin's schema-building hook. The function extracts a relation from the context, computes a default behavior based on plugin-specific logic, aggregates custom behaviors from multiple extension sources, and evaluates if a specific behavior is active using the build.behavior.matches method. Dependencies include Graphile's schema hook context and extension aggregation utilities. Expected inputs are schema field definitions with possible extension sources, and the output is the conditional invocation of custom logic. Limitations involve the requirement to maintain the correct extension order and consistent logic across plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n\n  // Establish a default behavior, e.g. you might give it different default behavior\n  // depending on if the remote table is in the same schema or not\n  const defaultBehavior = someCondition(relation) ? \"behavior_if_true\" : \"behavior_if_false\";\n\n  // Now establish the user-specified behavior for the entity, inheriting from all the\n  // relevant places.\n  const behavior = getBehavior([\n    relation.remoteResource.codec.extensions,\n    relation.remoteResource.extensions,\n    relation.extensions\n  ]);\n\n  // Finally check this behavior string against `behavior_to_test`, being sure to apply\n  // the \"schema-time smart defaulting\" that we established in `defaultBehavior` above.\n  if (build.behavior.matches(behavior, \"behavior_to_test\", defaultBehavior)) {\n    doTheThing();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images for PostGraphile and PostgreSQL Services - Shell Commands\nDESCRIPTION: This shell snippet shows various docker-compose command-line invocations for building Docker images. It demonstrates building all images as defined in docker-compose.yml or selectively building the db and graphql images. Proper use of these commands ensures that the latest source and dependencies are included in Docker images prior to running containers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Build images for all services in docker-compose.yml\\n$ docker-compose build\\n\\n# You can also build images one by one\\n# For instance you can build the database image like this\\n$ docker-compose build db\\n\\n# And build the graphql image like this\\n$ docker-compose build graphql\n```\n\n----------------------------------------\n\nTITLE: Defining Ruru Playground Endpoint in Nuxt using TypeScript\nDESCRIPTION: This code snippet defines an API route for the Ruru GraphiQL playground interface within a Nuxt project. It sets up an event handler using 'h3', forwarding received events to the 'handleGraphiqlEvent' method of the shared Grafserv instance. This endpoint allows users to interact with and visualize the GraphQL schema through a web-based tool. The snippet depends on 'h3' and the exported 'serv' server instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/nuxt.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { eventHandler } from \\\"h3\\\";\nimport { serv } from \\\"@/server/grafserv/serv\\\";\n\n// Create and export the `/ruru` route handler\nexport default eventHandler((event) => serv.handleGraphiqlEvent(event));\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile Configuration Preset (TypeScript)\nDESCRIPTION: This snippet demonstrates importing your project's PostGraphile configuration preset from a JavaScript configuration file (graphile.config.js). Ensure the configuration file exists and exports a valid preset object. The imported preset is required as input for initializing PostGraphile or related tools in your application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\n```\n\n----------------------------------------\n\nTITLE: Adding PostGraphile Dependency with Yarn (Bash)\nDESCRIPTION: Adds the `postgraphile` Node.js package as a project dependency using the Yarn package manager (`yarn add`). This command downloads and installs the package into the project's `node_modules` directory and updates the `package.json` and `yarn.lock` files. Assumes Yarn is installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add postgraphile\n```\n\n----------------------------------------\n\nTITLE: Defining Example Database Schema in SQL\nDESCRIPTION: This SQL snippet defines two tables, `companies` and `beverages`, with primary keys and foreign key relationships. This schema is used as an example throughout the documentation to illustrate the field name changes introduced by the `@graphile/simplify-inflection` preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table companies (\n  id serial primary key,\n  name text not null\n);\ncreate table beverages (\n  id serial primary key,\n  company_id int not null references companies,\n  distributor_id int references companies,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Summarizing Backers using JSX Components (JSX)\nDESCRIPTION: Utilizes the `Sponsors` component with `level=\"backers\"` and a single `Sponsor` component with the `plain` prop to display a summary message about the number of additional individual backers. The `name` prop provides the text for the summary, and the `plain` prop likely results in a text-only rendering without an avatar or link. The section is enclosed in HTML comments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/sponsor.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Sponsors level=\"backers\">\n  <Sponsor name=\"plus 85 more backers...\" plain />\n</Sponsors>\n\n<!-- SPONSORS_END -->\n```\n\n----------------------------------------\n\nTITLE: Defining Custom OrderBy Plugin for Membership Name (V4, Graphile) - TypeScript\nDESCRIPTION: This code provides a V4 OrderBy plugin example that adds custom ordering by a member's name, utilizing a correlated subquery fragment. The ordering logic constructs a SQL fragment that selects a user's name for each membership record, enabling sorting by related data. It features callback-based SQL generation within the build context. Dependencies include Graphile's build object, the makeAddPgTableOrderByPlugin, and helper orderByAscDesc.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  \"app_public\",\n  \"organization_memberships\",\n  ({ pgSql: sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order fragment callback:\n      ({ queryBuilder }) => {\n        return sql.fragment`(\n          select ${sqlIdentifier}.name\n          from app_public.users as ${sqlIdentifier}\n          where ${sqlIdentifier}.id = ${queryBuilder.getTableAlias()}.user_id\n          limit 1\n        )`;\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Displaying Featured Sponsors using JSX Components (JSX)\nDESCRIPTION: Uses the custom `Sponsors` and `Sponsor` React components to render a visually distinct list of featured sponsors. The `level=\"featured\"` prop on `Sponsors` groups these sponsors, while individual `Sponsor` components display details like name, avatar (`avatar` prop), link (`href` prop), and indicate if it's a business (`business` prop). The section is enclosed in HTML comments for potential automated processing.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/sponsor.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<!-- SPONSORS_BEGIN -->\n\n<Sponsors level=\"featured\">\n  <Sponsor\n    name=\"The Guild\"\n    avatar=\"/images/sponsors/theguild.png\"\n    href=\"https://www.the-guild.dev/\"\n    business\n  />\n  <Sponsor\n    name=\"Dovetail\"\n    avatar=\"/images/sponsors/dovetail.png\"\n    href=\"https://dovetailapp.com/\"\n    business\n  />\n  <Sponsor\n    name=\"Stellate\"\n    avatar=\"/images/sponsors/Stellate.png\"\n    href=\"https://stellate.co/\"\n    business\n  />\n  <Sponsor\n    name=\"Steelhead\"\n    avatar=\"/images/sponsors/steelhead.svg\"\n    href=\"https://gosteelhead.com/\"\n    business\n  />\n  <Sponsor\n    name=\"LatchBio\"\n    avatar=\"/images/sponsors/latchbio.jpg\"\n    href=\"https://latch.bio/\"\n    business\n  />\n</Sponsors>\n```\n\n----------------------------------------\n\nTITLE: Documenting orderByAscDesc Helper Function â€“ TypeScript\nDESCRIPTION: Contains the TypeScript function signature for the orderByAscDesc helper, which simplifies creation of ascending and descending orderBy variants for PostGraphile. It takes a base enum name, an orderBySpec (which may be a string, order spec, or callback), and a unique/options argument to control behavior like null sorting or uniqueness. It also describes the related OrderBySpecIdentity type. This documentation is pivotal for plugin writers to implement custom ordering logic via concise definitions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function orderByAscDesc(\n  baseName: string,\n  orderBySpec: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n\ntype OrderBySpecIdentity =\n  | string // Column name\n  | Omit<PgOrderSpec, \"direction\"> // Expression\n  | (($select: PgSelectStep) => Omit<PgOrderSpec, \"direction\">); // Callback, allows for joins/etc\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Foreign Key Constraint in SQL\nDESCRIPTION: Demonstrates creating a table (`app_public.users`) with an `organization_id` column that includes a foreign key constraint referencing the `app_public.organizations` table, defined inline using the `REFERENCES` keyword. It specifies `ON DELETE CASCADE` behavior and includes the creation of an index on the foreign key column, which is recommended for PostGraphile performance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/relations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.users (\n  -- ...\n  organization_id int NOT NULL\n    /* highlight-next-line */\n    REFERENCES app_public.organizations ON DELETE CASCADE,\n  -- ...\n);\nCREATE INDEX ON app_public.users (organization_id);\n```\n\n----------------------------------------\n\nTITLE: Schema Introspection GraphQL Query Example - GraphQL\nDESCRIPTION: This GraphQL query can be run against any GraphQL schema to introspect the available query fields. It expects no input variables and outputs the available query root fields with their names and descriptions. Useful as a baseline UI test.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_15\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n        description\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose to Load Custom PostGraphile Plugin\nDESCRIPTION: Snippet of a `docker-compose.yml` file configuring the `graphql` service. It updates the `command` arguments for the PostGraphile container, specifically adding `custom-plugin` to the `--append-plugins` list, ensuring that the custom resolver wrapper defined earlier is loaded alongside the connection filter plugin when the service starts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_22\n\nLANGUAGE: yml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db:\n        [...]\n\n    graphql:\n        [...]\n        command:\n            [\n                \"--connection\",\n                \"${DATABASE_URL}\",\n                \"--port\",\n                \"5433\",\n                \"--schema\",\n                \"public\",\n                \"--append-plugins\",\n                \"postgraphile-plugin-connection-filter,custom-plugin\",\n            ]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Exporting PostGraphile Options in an Express Server (JavaScript)\nDESCRIPTION: This snippet shows an Express server setup where PostGraphile options are defined in a separate, exportable function (`postgraphileOptions`). This allows the options to be imported and reused in test environments. The server initializes the `postgraphile` middleware using these options and environment variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/testing-jest.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n```js {6-11,17}\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\nfunction postgraphileOptions() {\n  return {\n    dynamicJson: true,\n  };\n}\nexports.postgraphileOptions = postgraphileOptions;\n\napp.use(\n  postgraphile(\n    process.env.DATABASE_URL || \"postgres:///\",\n    [\"app_public\"],\n    postgraphileOptions(),\n  ),\n);\n\napp.listen(process.env.PORT || 3000);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Function with Auto-generated ID and Smart Tag Patch Variant - SQL\nDESCRIPTION: Defines a table and a function that generates a new UUID for 'id', requires only a 'name' in the input, and returns the inserted row. Adds a smart tag using a SQL comment to designate the 'patch' variant for the first argument, influencing GraphQL mutation argument types in PostGraphile. Prerequisite: 'gen_random_uuid()' must be available. The smart tag provides mutation customization in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_12\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example_with_auto_id(input example) returns example as $$\n  insert into example (id, name) values (gen_random_uuid(), input.name) returning *;\n$$ language sql volatile;\n\ncomment on function new_example_with_auto_id(input example) is\n  E'@arg0variant patch';\n```\n\n----------------------------------------\n\nTITLE: Filtering a List Plan with a Lambda Callback in Graphile Crystal (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates using the `filter` function to create a new list plan (`$filteredList`) from an existing one (`$oldList`). It applies a `lambda` function as the `filterCallback` to each item (`$listItem`), including only those whose resolved value is greater than 42. This requires the `filter` and `lambda` functions from Graphile Crystal and an existing list plan (`$oldList`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/filter.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $filteredList = filter($oldList, ($listItem) =>\n  lambda($listItem, (value) => value > 42, true),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Connecting to Default Local PostgreSQL Database using Bash\nDESCRIPTION: Attempts to connect to the local PostgreSQL server using the `psql` command-line client with a shorthand connection URI `postgres:///`. This URI typically defaults to connecting via a Unix domain socket or TCP to localhost:5432, using the current OS user as the database user and attempting to connect to a database with the same name. It's used here to verify PostgreSQL installation and server status.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npsql postgres:///\n```\n\n----------------------------------------\n\nTITLE: Wrapping Polymorphic Results for Gra*fast* Execution (TypeScript)\nDESCRIPTION: Declares the utility function 'polymorphicWrap' for wrapping runtime objects with type information, necessary for Gra*fast*'s runtime polymorphic branch resolution. Accepts a type name and optional data payload; returns a typed object suitable for Gra*fast*'s polymorphic execution workflow. Used to identify which type branch was used at runtime for polymorphic-capable steps. Inputs are the concrete type string and data; outputs are 'PolymorphicData' instances.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/polymorphism.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function polymorphicWrap<TType extends string>(\n  type: TType,\n  data?: unknown,\n): PolymorphicData<TType>;\n```\n\n----------------------------------------\n\nTITLE: Creating a Polymorphic Specifier Step in @dataplan/pg using TypeScript\nDESCRIPTION: This snippet defines a `$specifier` step using the `list` function from `@dataplan/pg`. It bundles the potential foreign key values (person ID, post ID, comment ID) extracted from a `$favourite` step into a single list, which will be used by `pgPolymorphic` to determine the type and ID of the related polymorphic record. It depends on a pre-existing `$favourite` step representing a row from the 'favourites' table.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgPolymorphic.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $specifier = list([\n  $favourite.get(\"liked_person_id\"),\n  $favourite.get(\"liked_post_id\"),\n  $favourite.get(\"liked_comment_id\"),\n]);\n```\n\n----------------------------------------\n\nTITLE: Applying CSS Module Class in JSX\nDESCRIPTION: This JSX snippet renders a `div` element. It applies the CSS class `graphileHeart` (defined in `common.module.css`) to the element using the `styles` object previously imported via CSS Modules. This ensures the styling is scoped and avoids global CSS conflicts. It contains an image element displaying the Graphile logo.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/community-chat.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div className={styles.graphileHeart}>\n\n![The Graphile logo - a stylized red heart](@site/static/img/graphile.optimized.centered.svg)\n\n</div>\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Types with CREATE TYPE in PostgreSQL\nDESCRIPTION: Highlights the `CREATE TYPE` SQL command. This command allows defining a named composite type (struct) in PostgreSQL. Using such a defined type as a function's return type, instead of the generic `record`, provides the necessary structure for PostGraphile compatibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-restrictions.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TYPE\n```\n\n----------------------------------------\n\nTITLE: Example JWT Payload Structure in JSON\nDESCRIPTION: This JSON snippet illustrates a typical JWT payload structure used with PostGraphile. It includes standard claims like `aud` (audience, identifying PostGraphile) and custom claims like `role` and `user_id`, which PostGraphile uses to set PostgreSQL session variables for authorization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"aud\": \"postgraphile\",\n  \"role\": \"app_user\",\n  \"user_id\": 27\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Environment Variables (INI)\nDESCRIPTION: Defines essential environment variables within a `.env` file, intended for use by the PostgreSQL Docker container. `POSTGRES_DB` specifies the name of the database to be created ('forum_example'), `POSTGRES_USER` sets the default superuser ('postgres'), and `POSTGRES_PASSWORD` sets the password for this user ('change_me'). Docker Compose automatically loads variables from a `.env` file in the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n# DB\n# Parameters used by db container\nPOSTGRES_DB=forum_example\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=change_me\n```\n\n----------------------------------------\n\nTITLE: Inspecting Graphile Export Metadata on Wrapped Functions\nDESCRIPTION: Demonstrates how `graphile-export` attaches hidden properties (`$exporter$factory` and `$exporter$args`) to the function wrapped by `EXPORTABLE`. These properties store the factory function and the captured dependency values ([7]), enabling Graphile Export to reconstruct the function with its necessary context during export.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\n> add.$exporter$factory.toString()\n'(a) => function add(b) { return a + b; }'\n> add.$exporter$args\n[ 7 ]\n```\n\n----------------------------------------\n\nTITLE: Creating a Factory Function for a Grafast Step Class in TypeScript\nDESCRIPTION: Illustrates the recommended pattern of defining a lowercase factory function (e.g., `add`) for a corresponding Grafast step class (e.g., `AddStep`). This function simplifies instantiation within plan resolvers, improving code readability and maintainability by hiding the `new` keyword and `Step` suffix.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction add($a, $b) {\n  return new AddStep($a, $b);\n}\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Context Type Definitions via Declaration Merging (TypeScript)\nDESCRIPTION: Shows how to make GraphQL plan resolver context values type-safe through TypeScript declaration merging. By extending the `Context` interface in the global Grafast namespace, developers can specify additional properties available on the context object (such as `currentUserId`). This enables strict typing for usages such as `context().get('currentUserId')`, catching type errors at compile time. This snippet relies on correct TypeScript project configuration and assumes integration with Grafast.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/context.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare global {\n  namespace Grafast {\n    interface Context {\n      currentUserId?: number;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin Using the V4 Functional API (typescript)\nDESCRIPTION: This TypeScript code defines a custom PostGraphile V4 plugin using the functional builder.hook approach. It sets up custom inflectors, adds new fields to build, performs initialization, and alters GraphQLObjectType fields. Dependencies include 'graphile-build'. The plugin receives a builder and uses builder.hook to register hooks at various schema build stages. Key inputs are builder and build objects; outputs are functionally extended inflection/build/fields. Suitable for V4 only.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Plugin } from \\\"graphile-build\\\";\\n\\nexport const MyPlugin: Plugin = (builder) => {\\n  builder.hook(\\\"inflection\\\", (inflection, build) => {\\n    return build.extend(inflection, {\\n      myInflector(stuff) {\\n        return stuff + \\\"Stuff\\\";\\n      },\\n    });\\n  });\\n\\n  builder.hook(\\\"build\\\", (build) => {\\n    return build.extend(\\n      build,\\n      { myStuff: () => [\\\"my\\\", \\\"stuff\\\"] },\\n      \\\"Adding myStuff to build\\\",\\n    );\\n  });\\n\\n  builder.hook(\\\"init\\\", (_, build) => {\\n    doSomethingWith(build.myStuff());\\n    return _;\\n  });\\n\\n  builder.hook(\\\"GraphQLObjectType:fields\\\", (fields, build, context) => {\\n    return build.extend(\\n      fields,\\n      { myField: { type: build.graphql.GraphQLString } },\\n      \\\"Adding fields from MyPlugin\\\",\\n    );\\n  });\\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Password and Returning JWT Token (PL/pgSQL)\nDESCRIPTION: Implements the logic for password hash validation and conditionally generates a JWT token. Checks if the supplied plain-text password, when encrypted, matches the stored hash; returns a JWT composite value on success or null on failure. Depends on the account record being fetched, the 'crypt' function from 'pgcrypto', and the JWT token type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_34\n\nLANGUAGE: plpgsql\nCODE:\n```\nif account.password_hash = crypt(password, account.password_hash) then\n  return ('forum_example_person', account.person_id)::forum_example.jwt_token;\nelse\n  return null;\nend if;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Number Transformer with sql.withTransformer() in pg-sql2 (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to define a custom transformer (`numberToValue`) for the `pg-sql2` library. The transformer checks if a value is a finite number and converts it to a SQL value using `sql.value()`. It then shows how to use this transformer with `sql.withTransformer()` to embed a number (42) directly into an SQL query fragment.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-with-transformer.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport sql, { type Transformer } from \"pg-sql2\";\n\nconst numberToValue: Transformer<number> = (sql, value) => {\n  if (typeof value === \"number\") {\n    if (!Number.isFinite(value)) {\n      throw new Error(\n        `${value} is not a finite number, so cannot safely be used in the SQL statement.`,\n      );\n    }\n    return sql.value(value);\n  } else {\n    return value;\n  }\n};\n\nconst stmt = sql.withTransformer(\n  numberToValue,\n  (sql) => sql`select * from users where id = ${42}`,\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Jest to use jest-serializer-simple\nDESCRIPTION: This JavaScript code snippet shows how to configure Jest to use the `jest-serializer-simple` serializer. It involves modifying the Jest configuration object (typically in `jest.config.js` or `package.json`) by adding the serializer's name to the `snapshotSerializers` array.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-simple/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  testEnvironment: \"node\",\n  snapshotSerializers: [`jest-serializer-simple`],\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Styling Utilities and CSS Modules in JavaScript\nDESCRIPTION: This snippet imports the `clsx` utility for conditional class names and two CSS modules (`common.module.css` and `pricing.module.css`) for styling components within a likely React/JSX-based documentation site (e.g., Docusaurus). `clsx` helps manage CSS class strings dynamically, while the imported styles objects allow scoped styling. These imports are prerequisites for applying styles defined in the respective CSS module files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport clsx from \"clsx\";\n\nimport styles from \"@site/src/css/common.module.css\";\nimport pricingStyles from \"./pricing.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Selecting SQL Expression Fragment Using pgSelectSingle - TypeScript\nDESCRIPTION: Demonstrates selecting a SQL expression value from a single user record using pgSelectSingle's select() method. Requires Graphile resource objects and access to a Postgres database. Parameters include a SQL fragment and a type codec, and the output is a step representing the evaluated SQL expression for that row. Limited to accessing only columns or expressions that the underlying pgSelect includes.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $user = usersResource.find({ id: constant(1) });\nconst $usernameLength = $user.select(sql`length(username)`, TYPES.int);\n```\n\n----------------------------------------\n\nTITLE: Creating the Person Table for a Forum - SQL\nDESCRIPTION: Creates a 'person' table in the 'forum_example' schema to represent forum users. Enforces data validation through constraints on 'first_name' and 'last_name', supports profile fields, and automatically timestamps record creation. The 'id' column is a serial primary key; all column definitions are intended to ensure data integrity and facilitate integration with PostGraphile APIs and documentation tools. Requires PostgreSQL; best created after the parent schema exists.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.person (\n  id               serial primary key,\n  first_name       text not null check (char_length(first_name) < 80),\n  last_name        text check (char_length(last_name) < 80),\n  about            text,\n  created_at       timestamp default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Grafserv Instance Using PostGraphile (JavaScript)\nDESCRIPTION: This short snippet demonstrates how to create a Grafserv-compatible service ('serv') by passing the imported 'grafserv' handler to the 'pgl.createServ' method. Assumes the prior initialization of the 'pgl' PostGraphile instance. The returned 'serv' object can be mounted onto HTTP servers. Requires the relevant Grafserv import and a PostGraphile instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-library.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst serv = pgl.createServ(grafserv);\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile Naming Conflict Error\nDESCRIPTION: Illustrates a typical error message from PostGraphile indicating a naming conflict. In this example, both an attribute field derived from a PgCodec ('subtask') and a singular relation ('taskByMyTask') tried to claim the name 'task' on the 'Subtask' GraphQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/errors/nc.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nError: A naming conflict has occurred - two entities have tried to define the same key 'task'.\n  The first entity was:\n    Adding 'task' attribute field to GraphQL type 'Subtask' (representing PgCodec 'subtask')\n  The second entity was:\n    Adding field to GraphQL type 'Subtask' for singular relation 'taskByMyTask'\n  Details: https://err.red/pnc\n```\n\n----------------------------------------\n\nTITLE: Installing and Listing Inflectors with Graphile CLI (Bash)\nDESCRIPTION: This snippet describes two CLI commands for managing PostGraphile development tools: one installs the 'graphile' package as a devDependency, and the second lists inflectors available in the project. These commands require npm, a Node.js environment, and access to the sponsors-only 'graphile' package. Inputs are the standard CLI commands; outputs include the inflector list printed to the terminal.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/inflection.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev graphile@beta\nnpx graphile inflection list\n```\n\n----------------------------------------\n\nTITLE: Creating a Grafserv Instance from a PostGraphile Instance - JavaScript\nDESCRIPTION: This snippet shows how to use a previously created PostGraphile instance to create a Grafserv server instance by passing it the grafserv handler. It depends on the PostGraphile instance ('pgl') and imported 'grafserv'. The resulting 'serv' object is used to integrate PostGraphile with HTTP servers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst serv = pgl.createServ(grafserv);\n```\n\n----------------------------------------\n\nTITLE: Running Grafast Simplified Query Plan Documentation - JavaScript\nDESCRIPTION: Runs a simplified query using Grafast and outputs the resulting plan diagram to a Mermaid markdown file (plan.mermaid). Requires Grafast and supporting files. Run by executing 'node index.mjs docs', producing a visual documentation artifact to aid schema comprehension.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/examples/users-and-friends/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnode index.mjs docs\n```\n\n----------------------------------------\n\nTITLE: Creating a Bulk Insert Mutation for Documents (PostgreSQL, SQL)\nDESCRIPTION: Provides a custom PostgreSQL function to insert multiple document rows in bulk based on the specified 'num', 'type', and 'location' parameters, returning all created records. Utilizes generate_series for batch creation and is marked STRICT and VOLATILE for use as a robust PostGraphile mutation. The function returns a SETOF app_public.document, and the mutation exposes required integer and text parameters in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-mutations.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION app_public.create_documents(num integer, type text, location text)\nRETURNS SETOF app_public.document\nAS $$\n  INSERT INTO app_public.document (type, location)\n    SELECT create_documents.type, create_documents.location\n    FROM generate_series(1, num) i\n    RETURNING *;\n$$ LANGUAGE sql STRICT VOLATILE;\n```\n\n----------------------------------------\n\nTITLE: Defining Nullability Specification String Type (TypeScript)\nDESCRIPTION: Exports a TypeScript type alias `NullabilitySpecString` which defines the allowed string literals for specifying field nullability. This syntax mirrors GraphQL SDL conventions, covering basic nullability (`\"\"`, `\"!\"`) and various levels of list nullability (e.g., `\"[]\"`, `\"[]!\"`, `\"[!]\"`, `\"[!]!\"`, and nested lists).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-change-nullability-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type NullabilitySpecString =\n  | \"\" // nullable\n  | \"!\" // non-nullable\n  | \"[]\" // nullable list of nullables\n  | \"[]!\" // non-nullable list of nullables\n  | \"[!\" // nullable list of non-nullables\n  | \"[!]!\"\n  | \"[[]]\"\n  | \"[[]]!\"\n  | \"[[]!]\"\n  | \"[[]!]!\"\n  | \"[[!]]\"\n  | \"[[!]]!\"\n  | \"[[!]!]\"\n  | \"[[!]!]!\";\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile Middleware for Live Queries in JavaScript\nDESCRIPTION: Example of using PostGraphile as Node.js middleware (e.g., within Express). It shows how to enable live queries (`live: true`), provide the necessary `ownerConnectionString`, and include the `@graphile/subscriptions-lds` plugin using `appendPlugins`. Requires the `@graphile/subscriptions-lds` package.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\napp.use(\n  postgraphile(process.env.AUTH_DATABASE_URL, SCHEMA, {\n    // ...\n\n    // Enable live support in PostGraphile\n    live: true,\n    // We need elevated privileges for logical decoding\n    ownerConnectionString: process.env.ROOT_DATABASE_URL,\n    // Add this plugin\n    appendPlugins: [\n      //...\n      require(\"@graphile/subscriptions-lds\").default,\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with UUID Primary Key using uuid-ossp - SQL\nDESCRIPTION: Demonstrates enabling the 'uuid-ossp' PostgreSQL extension and using it to create a 'person' table with UUID primary keys instead of serial integers. The 'id' column is set to a generated UUID via 'uuid_generate_v1mc()' by default, enabling globally unique, less guessable identifiers. Requires PostgreSQL and the 'uuid-ossp' extension; install extension first before the table creation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"uuid-ossp\";\n\ncreate table forum_example.person (\n  id uuid primary key default uuid_generate_v1mc(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Adding GraphQL Service to Docker Compose - YAML\nDESCRIPTION: This YAML snippet extends the Docker Compose configuration to add a 'graphql' service for the PostGraphile API container. It specifies container parameters, image build source, environment variable file, dependency on the database, network association, exposed ports, and PostGraphile-specific startup arguments. Requires Docker Compose version 3.3 or greater, and .env must be preconfigured. Updates to command arguments enable runtime customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n\"version: \\\"3.3\\\"\\nservices:\\n    db: [...]\\n\\n    graphql:\\n        container_name: forum-example-graphql\\n        restart: always\\n        image: forum-example-graphql\\n        build:\\n            context: ./graphql\\n        env_file:\\n            - ./.env\\n        depends_on:\\n            - db\\n        networks:\\n            - network\\n        ports:\\n            - 5433:5433\\n        command: [\\\"--connection\\\", \\\"${DATABASE_URL}\\\", \\\"--port\\\", \\\"5433\\\", \\\"--schema\\\", \\\"public\\\", \\\"--append-plugins\\\", \\\"postgraphile-plugin-connection-filter\\\"]\\n[...]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Launching PostGraphile with Basic Options - Bash\nDESCRIPTION: Runs the 'postgraphile' CLI with essential options: sets the PostgreSQL connection string, specifies schema, enables Relay, and enables dynamic JSON support. Requires PostgreSQL to be reachable. Key parameters are '-c' for the database URL, '-s' for schema, '-a' for Relay, and '-j' for dynamic JSON. The command starts an HTTP server exposing the GraphQL API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres:///mydb -s public -a -j\n```\n\n----------------------------------------\n\nTITLE: Retrieving Registered GraphQL Type by Name (JavaScript)\nDESCRIPTION: This snippet illustrates how to retrieve a previously registered GraphQL object type using the build object's getTypeByName method. The only dependency is the build context, and the 'MyType' string should correspond to a type previously registered via registerObjectType. The method takes a type name as a parameter and returns the corresponding GraphQL type object, enabling later use in schema construction or resolution steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/build-object.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyType = build.getTypeByName(\"MyType\");\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @primaryKey Constraint via SQL Comment (SQL)\nDESCRIPTION: These SQL snippets define a virtual primary key constraint on a view using smart comments, enabling Graphile to treat the specified columns as primary key(s) for that view. The syntax allows a single or multiple columns. This does not add actual uniqueness enforcement in PostgreSQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_29\n\nLANGUAGE: sql\nCODE:\n```\ncomment on view my_view is E'@primaryKey id';\n-- or\ncomment on view my_view is E'@primaryKey type,identifier';\n```\n\n----------------------------------------\n\nTITLE: Mounting Grafserv to a Node HTTP Server (JavaScript)\nDESCRIPTION: This example demonstrates mounting a Grafserv instance (from PostGraphile) onto Node's built-in HTTP server. It sets up an HTTP server, handles server errors, and uses 'serv.addTo' to attach the GraphQL handler. Successful startup is acknowledged on port 5678. Required dependencies are 'node:http', the chosen Grafserv adapter, and a previously initialized PostGraphile instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-library.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport { grafserv } from \"postgraphile/grafserv/node\";\nimport { pgl } from \"./pgl.js\";\n\nconst serv = pgl.createServ(grafserv);\n\nconst server = createServer();\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\nserv.addTo(server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\nserver.listen(5678);\n\nconsole.log(\"Server listening at http://localhost:5678\");\n```\n\n----------------------------------------\n\nTITLE: Issuing a Deep GraphQL Query for Testing DoS Protections - GraphQL\nDESCRIPTION: This code snippet presents a deeply nested GraphQL query, designed to illustrate how a resource-intensive query can be constructed to test or demonstrate the need for query complexity limits in PostGraphile. It does not require any particular frontend or server configuration but is used in the context of discussing DoS mitigation strategies. The query takes no parameters and returns a deeply nested user-post-comment relationship tree; excessive nesting like this can stress the server and database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/production.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nallUsers {\n  nodes {\n    postsByAuthorId {\n      nodes {\n        commentsByPostId {\n          userByAuthorId {\n            postsByAuthorId {\n              nodes {\n                commentsByPostId {\n                  userByAuthorId {\n                    postsByAuthorId {\n                      nodes {\n                        commentsByPostId {\n                          userByAuthorId {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing makePgSmartTagsPlugin with TypeScript\nDESCRIPTION: Shows how to import the `makePgSmartTagsPlugin` function from the `graphile-utils` package using TypeScript's `require`. This is the lowest-level and most versatile plugin generator, allowing smart tags to be applied based on custom rules and matcher functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst { makePgSmartTagsPlugin } = require(\"graphile-utils\");\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Graphile Worker Task Handler in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to define a task handler for Graphile Worker. The module exports an asynchronous function that will be executed when a job with the identifier 'hello' (matching the filename `tasks/hello.js` by convention, or explicitly defined) is processed by a worker instance. The function receives the job `payload` and `helpers` (including a logger) as arguments and performs the task logic, in this case logging a greeting.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/background-tasks.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// tasks/hello.js\nmodule.exports = async (payload, helpers) => {\n  const { name } = payload;\n  helpers.logger.info(`Hello, ${name}`);\n};\n```\n\n----------------------------------------\n\nTITLE: Testing Docker Installation - Shell\nDESCRIPTION: Runs the 'hello-world' Docker container to test Docker installation. Downloads and runs the image if not present. Input: none; output: a hello-world message confirming Docker functionality.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker run hello-world\n```\n\n----------------------------------------\n\nTITLE: Overriding Mutation Input Values in Graphile Mutation Plugins - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a Graphile plugin that automatically sets the 'updatedAt' field on the 'quiz' table's update mutation inputs if it is not already provided. It uses the Graphile \\'hook\\' system to wrap the mutation field resolver, making sure the field is set to the current timestamp. To use this plugin, it should be appended to the PostGraphile server with the appropriate configuration; it depends on PostGraphile internals, including the builder API and context properties such as 'isPgUpdateMutationField' and 'pgFieldIntrospection'. The plugin operates on fields related to the 'quiz' table and relies on the structure of arguments as generated for update mutations. Inputs must match the expected nested shape, and it may not generalize across schemas with different input structures.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/mutation-wrappers.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nmodule.exports = function SetInputObjectDefaultValue(builder) {\n  builder.hook(\"GraphQLObjectType:fields:field\", (field, build, context) => {\n    const {\n      scope: { isPgUpdateMutationField, pgFieldIntrospection: table },\n    } = context;\n    if (\n      !isPgUpdateMutationField ||\n      table.kind !== \"class\" ||\n      table.name !== \"quiz\"\n    ) {\n      return field;\n    }\n\n    const oldResolve = field.resolve;\n\n    return {\n      ...field,\n      resolve(_mutation, args, context, info) {\n        // Override the `updatedAt` field if it's not already set.\n        if (args.input.quizPatch.updatedAt == null) {\n          args.input.quizPatch.updatedAt = new Date().toISOString();\n        }\n        return oldResolve(_mutation, args, context, info);\n      },\n    };\n  });\n};\n\n// Tested via:\n// npx postgraphile --append-plugins @graphile-contrib/pg-simplify-inflector,`pwd`/examples/plugins/0300_mutation_wrappers/OverrideArgValuePlugin.js -c graphile_org_demo -s app_public\n```\n\n----------------------------------------\n\nTITLE: Adding Documentation Comments to Person Table (SQL)\nDESCRIPTION: This SQL snippet uses the `COMMENT ON` command to add descriptive comments to the `forum_example.person` table and its individual columns (`id`, `first_name`, `last_name`, `about`, `created_at`). These comments provide in-database documentation that can be utilized by tools like PostGraphile to enrich the generated API documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.person is 'A user of the forum.';\ncomment on column forum_example.person.id is 'The primary unique identifier for the person.';\ncomment on column forum_example.person.first_name is 'The personâ€™s first name.';\ncomment on column forum_example.person.last_name is 'The personâ€™s last name.';\ncomment on column forum_example.person.about is 'A short description about the user, written by the user.';\ncomment on column forum_example.person.created_at is 'The time this person was created.';\n```\n\n----------------------------------------\n\nTITLE: Setting Table-Level Pagination Cap via PostgreSQL Smart Comments - SQL\nDESCRIPTION: This SQL code snippet demonstrates attaching a smart comment to the 'users' table to enforce a pagination cap of 20. By using a smart comment with '@paginationCap 20', administrators can restrict maximum results returned per page when using cursor-based pagination in Graphile/PostGraphile, particularly when the Pro Plugin is enabled. This feature requires the Pro Plugin with smart comment support; the comment string can include additional descriptive text after the cap value. The 'users' table must exist in the database, and this will only take effect if your Graphile/PostGraphile instance is configured to process such smart comments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/production.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table users is\n  E'@paginationCap 20\\nSomeone who can log in.';\n```\n\n----------------------------------------\n\nTITLE: Enabling Extended Error Logging in PostGraphile CLI - Bash\nDESCRIPTION: This snippet illustrates how to use command-line options to output extended error information from PostGraphile. It requires the PostGraphile CLI. Replace the example extended error fields with your needs. Run this in any shell where PostGraphile is installed. The --extended-errors option can include parameters like severity, code, detail, etc. The output will be more verbose and is not recommended for production environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n--extended-errors severity,code,detail,hint,position,internalPosition,internalQuery,where,schema,table,column,dataType,constraint,file,line,routine\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Project Directory with npm - Bash\nDESCRIPTION: This bash snippet creates a new project directory, navigates into it, and initializes a Node.js project. It is the foundational step to prepare for installation of dependencies and project setup. No external dependencies beyond Node.js and npm are required. Inputs are user shell commands, output is a project folder with a package.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nmkdir postgraphile_express_typescript\\ncd postgraphile_express_typescript\\nnpm init -y\n```\n\n----------------------------------------\n\nTITLE: Typical Project Directory Structure for PostGraphile Express App - Bash\nDESCRIPTION: This output from a Bash command describes the file layout for a PostGraphile/Express project directory after setup. Not an executable snippet, but demonstrates expected files and folder hierarchy after running previous steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\npostgraphile_express/\n â”œâ”€â”€ .env\n â”œâ”€â”€ .gitignore\n â”œâ”€â”€ node_modules/\n â”œâ”€â”€ package-lock.json\n â”œâ”€â”€ package.json\n â””â”€â”€ server.js\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Logic with Graphile Config Middleware in TypeScript\nDESCRIPTION: This TypeScript snippet defines a Graphile Config plugin named `MySomeActionRetryPlugin`. It includes middleware for the `someAction` action within `myScopeName`. The middleware function implements a simple retry mechanism, attempting the underlying action up to three times with an incremental delay (backoff) between attempts if an error occurs. It uses `async`/`await` and calls `next()` to invoke the next middleware or the original action.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/middleware.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"my-some-action-retry-plugin.ts\"\nexport const MySomeActionRetryPlugin: GraphileConfig.Plugin = {\n  name: \"MySomeActionRetryPlugin\",\n  myScopeName: {\n    middleware: {\n      async someAction(next, event) {\n        console.log(`someAction(someParameter=${event.someParameter}) called`);\n\n        let error!: Error;\n        for (let attempts = 0; attempts < 3; attempts++) {\n          if (attempts > 0) {\n            // Wait a few milliseconds before trying again\n            await sleep(attempts * 5);\n          }\n          try {\n            return await next();\n          } catch (e) {\n            error = e;\n          }\n        }\n        throw error;\n      },\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile JWT Settings in JavaScript\nDESCRIPTION: This JavaScript configuration snippet for PostGraphile (`graphile.config.mjs`) sets up JWT handling. It extends the `PostGraphileAmberPreset`, specifies the composite type `my_public_schema.jwt_token` for JWT generation using `gather.pgJwtTypes`, and defines the JWT secret required for signing and verification using `schema.pgJwtSecret`, typically sourced from environment variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\nexport default {\n  extends: [PostGraphileAmberPreset],\n  gather: {\n    // highlight-next-line\n    pgJwtTypes: \"my_public_schema.jwt_token\",\n  },\n  schema: {\n    // highlight-next-line\n    pgJwtSecret: process.env.JWT_SECRET,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Flattening Joined Tables with Views (SQL)\nDESCRIPTION: This SQL snippet illustrates creating normalized person and address tables, then composing a view 'person_view' that flattens the data across a join. This makes consuming data in the API simpler and reduces nesting. Prerequisites are the existence of the 'app_public' schema and both tables. The expected output is a new view providing person IDs from the person table and country/street fields from the address table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/views.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.person (\n  id serial primary key\n);\n\ncreate table app_public.address (\n  person_id int primary key references app_public.person,\n  country text,\n  street text,\n);\n\ncreate view person_view as\n  select person.id, address.country, address.street\n  from app_public.person person\n  inner join app_public.address\n  on person.id = address.person_id;\n```\n\n----------------------------------------\n\nTITLE: Defining InputCoercionPlan for Input Type Coercion (Pseudocode)\nDESCRIPTION: Describes the `InputCoercionPlan` function, intended to create a plan that wraps an inner plan and applies input coercion rules based on a given `inputType`. Both its execution and evaluation methods involve retrieving the inner value and coercing it. The necessity of this plan is questioned, as coercion might be handled elsewhere (e.g., implicitly for lists, leaves already coerced).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_14\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputCoercionPlan(aether, inputType, innerPlan):\n\n- Let {plan} be {NewPlan(aether)}.\n- Add {innerPlan} to {plan}.{dependencies}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that:\n  - Let {results} be an empty list.\n  - For each input crystal object {crystalObject}:\n    - Let {innerValue} be the value associated with {innerPlan} within {crystalObject}.\n    - Let {coercedValue} be the result of coercing {innerValue} according to the input coercion rules of {inputType}.\n    - Add {coercedValue} to {results}.\n  - Return {results}.\n- Augment {plan} such that:\n  - Calls to `plan.eval()`:\n    - Let {innerValue} be the result of calling `innerPlan.eval()`.\n    - Let {coercedValue} be the result of coercing {innerValue} according to the input coercion rules of {inputType}.\n    - Return {coercedValue}.\n- Return {plan}.\n\nTODO: delete this plan? Leaves are already coerced; we coerce lists implicitly, maybe we don't need it? Really comes\ndown to variables, methinks.\n```\n\n----------------------------------------\n\nTITLE: Example of a Potentially Expensive GraphQL Query\nDESCRIPTION: Demonstrates a deeply nested GraphQL query example that retrieves related data across multiple levels (users, posts, comments). Such queries can be computationally expensive and potentially lead to Denial of Service (DoS) if not mitigated, illustrating a common security consideration for GraphQL APIs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/production.mdx#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nallUsers {\n  nodes {\n    postsByAuthorId {\n      nodes {\n        commentsByPostId {\n          userByAuthorId {\n            postsByAuthorId {\n              nodes {\n                commentsByPostId {\n                  userByAuthorId {\n                    postsByAuthorId {\n                      nodes {\n                        commentsByPostId {\n                          userByAuthorId {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Smart Tags Plugin - PostGraphile in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to load a custom smart tags plugin (such as the one defined using 'makeJSONPgSmartTagsPlugin') into PostGraphile by importing and appending it to the 'appendPlugins' array. The code requires the plugin from a local module, then passes it into PostGraphile library mode for smart tag integration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags-file.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst MySmartTagsPlugin = require(\\\"./MySmartTagsPlugin\\\");\\napp.use(\\n  postgraphile(DATABASE_URL, SCHEMAS, {\\n    // ...\\n    appendPlugins: [MySmartTagsPlugin],\\n  }),\\n);\\n\n```\n\n----------------------------------------\n\nTITLE: Adding Smart Tags to Virtual Constraints in JSON5 - JSON5\nDESCRIPTION: Demonstrates attaching additional smart tags (e.g., @fieldName) to a virtual foreignKey by appending a pipe (|) and the tag syntax. The example shows a single foreignKey and an extra fieldName tag for PostGraphile on 'my_materialized_view'. This customizes field exposure in the GraphQL API. Requires PostGraphile's tags system and supported metadata tags.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_22\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)|@fieldName field_1\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @unionMember Smart Tags for GraphQL Union - SQL\nDESCRIPTION: Annotates the 'people' and 'organizations' tables with '@unionMember', marking them as part of the 'PersonOrOrganization' GraphQL union type. No dependencies beyond the tables themselves. Ensures that GraphQL queries can treat records from these tables as union members.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.people is $$\n  @unionMember PersonOrOrganization\n  $$;\ncomment on table polymorphic.organizations is $$\n  @unionMember PersonOrOrganization\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Defining InputListPlan for Handling List Inputs (Pseudocode)\nDESCRIPTION: Defines the `InputListPlan` function for creating plans that represent GraphQL list inputs. It processes a list of input values, creating an `InputPlan` for each item. It handles the case where the input is the literal `null`. The plan provides an `at(index)` method to access individual item plans (returning a default plan for out-of-bounds access) and an `eval()` method to evaluate the entire list.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_16\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputListPlan(aether, inputType, inputValues):\n\n- Assert {inputType} is a list type.\n- Let {innerType} be the inner type of {inputType}.\n- Let {plan} be {NewPlan(aether)}.\n- Let {itemPlans} be an empty list.\n- If {inputValues} is a list, for each {inputValue} in {inputValues}:\n  - Let {innerPlan} be {InputPlan(aether, innerType, inputValue)}.\n  - Add {innerPlan} to {itemPlans}.\n- Let {outOfBoundsPlan} be {InputPlan(aether, innerType, undefined)}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that:\n  - Let {results} be an empty list.\n  - For each input crystal object {crystalObject}:\n    - If {inputValues} is the {null} literal:\n      - Add {null} to {results}.\n    - Otherwise:\n      - Let {list} be an empty list.\n      - For {itemPlan} in {itemPlans}:\n        - Let {value} be `itemPlan.eval()`.\n        - Add {value} to {list}.\n      - Add {list} to {results}.\n  - Return {results}.\n- Augment {plan} such that:\n  - Calls to `plan.at(index)`:\n    - Let {itemPlan} be the {index}th plan in {itemPlans}, or {outOfBoundsPlan} if {index} is out of bounds.\n    - Return {itemPlan}.\n  - Calls to `plan.eval()`:\n    - If {inputValues} is the {null} literal:\n      - Return {null}.\n    - Otherwise:\n      - Let {list} be an empty list.\n      - For {itemPlan} in {itemPlans}:\n        - Let {value} be `itemPlan.eval()`.\n        - Add {value} to {list}.\n      - Return {list}.\n- Return {plan}.\n\nNote: Though this may have variables for values within the list, it is not a variable itself (it has a known length in\nthe AST) thus we can return different plans for different elements in the list.\n```\n\n----------------------------------------\n\nTITLE: Applying PostGraphile @ref/@refVia Smart Tags to Reference a Union in SQL\nDESCRIPTION: Adds a comment to the `polymorphic.log_entries` table with PostGraphile smart tags. `@ref author to:PersonOrOrganization singular` defines a singular field named 'author' resolving to the 'PersonOrOrganization' union. `@refVia` tags specify how to resolve this field by mapping the `person_id` and `organization_id` foreign keys to the respective tables (`people` and `organizations`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:(person_id)->people(person_id)\n  @refVia author via:(organization_id)->organizations(organization_id)\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Global Numeric to Float Conversion - Diff\nDESCRIPTION: Displays the resulting GraphQL schema differences when the PgNumericToFloatPlugin is applied. Used for documentation and validation purposes to demonstrate the effect of the plugin on the schema. Shows BigFloat types replaced with Float and schema structure alterations. No direct dependenciesâ€”meant for comparison.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\\n+++ Modified GraphQL Schema\\n@@ -1,8 +1,3 @@\\n-\\\"\\\"\\\"\\n-A floating point number that requires more precision than IEEE 754 binary 64\\n-\\\"\\\"\\\"\\n-scalar BigFloat\\n-\\n \\\"\\\"\\\"All input for the create `Forum` mutation.\\\"\\\"\\\"\\n input CreateForumInput {\\n   \\\"\\\"\\\"\\n@@ -1863,8 +1858,8 @@\\n   id: Int!\\n   name: String!\\n   updatedAt: Datetime!\\n-  precision12Scale2: BigFloat\\n-  precision200Scale100: BigFloat\\n+  precision12Scale2: Float\\n+  precision200Scale100: Float\\n\\n   \\\"\\\"\\\"Reads and enables pagination through a set of `QuizEntry`.\\\"\\\"\\\"\\n   quizEntries(\\n@@ -1910,10 +1905,10 @@\\n   updatedAt: Datetime\\n\\n   \\\"\\\"\\\"Checks for equality with the objectâ€™s `precision12Scale2` field.\\\"\\\"\\\"\\n-  precision12Scale2: BigFloat\\n+  precision12Scale2: Float\\n\\n   \\\"\\\"\\\"Checks for equality with the objectâ€™s `precision200Scale100` field.\\\"\\\"\\\"\\n-  precision200Scale100: BigFloat\\n+  precision200Scale100: Float\\n }\\n\\n \\\"\\\"\\\"A connection to a list of `QuizEntry` values.\\\"\\\"\\\"\\n@@ -2129,8 +2124,8 @@\\n   id: Int\\n   name: String!\\n   updatedAt: Datetime\\n-  precision12Scale2: BigFloat\\n-  precision200Scale100: BigFloat\\n+  precision12Scale2: Float\\n+  precision200Scale100: Float\\n }\\n\\n \\\"\\\"\\\"Represents an update to a `Quiz`. Fields that are set will be updated.\\\"\\\"\\\"\\n@@ -2138,8 +2133,8 @@\\n   id: Int\\n   name: String\\n   updatedAt: Datetime\\n-  precision12Scale2: BigFloat\\n-  precision200Scale100: BigFloat\\n+  precision12Scale2: Float\\n+  precision200Scale100: Float\\n }\\n\\n \\\"\\\"\\\"A connection to a list of `Quiz` values.\\\"\\\"\\\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Heroku DATABASE_URL for RDS with SSL (Bash)\nDESCRIPTION: Sets the `DATABASE_URL` environment variable on Heroku to connect PostGraphile to an AWS RDS PostgreSQL database, explicitly enabling SSL via the `?ssl=true` parameter. Requires the Heroku CLI to be installed and logged in.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set DATABASE_URL=\"postgres://...rdshost.../db_name?ssl=true\"\n```\n\n----------------------------------------\n\nTITLE: Using pgSingleTablePolymorphic in TypeScript with @dataplan/pg\nDESCRIPTION: TypeScript code demonstrating the usage of the `pgSingleTablePolymorphic` function from `@dataplan/pg`. It retrieves an animal record using a `PgResource` (`animalsResource`), extracts the value from the 'type' column to determine the specific GraphQL type name, and then calls `pgSingleTablePolymorphic` with the type name step and the row data step to enable polymorphic resolution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSingleTablePolymorphic.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $animal = animalsResource.get({ id: constant(1) });\n\n// 'Cat', 'Dog' or 'Fish'; use a lambda step to transform the values if\n// necessary.\nconst $typeName = $animal.get(\"type\");\n\nreturn pgSingleTablePolymorphic($typeName, $animal);\n```\n\n----------------------------------------\n\nTITLE: Defining Product Table Schema in SQL\nDESCRIPTION: SQL script to create the `product` table in a PostgreSQL database. This table serves as the underlying data source for the `Product` type in the PostGraphile schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncreate table product (\n  id uuid primary key,\n  name text not null,\n  price_in_us_cents integer not null\n);\n```\n\n----------------------------------------\n\nTITLE: Extracting Entity Specification from Node ID - TypeScript\nDESCRIPTION: This snippet defines the 'specFromNodeId' function signature for extracting an entity specification from a Node ID using a handler. It takes a specialized handler and an executable or input step for the node ID string, and returns an entity specification object. Requires a properly constructed handler and assumes the node ID provided is compatible with the specified handler's type. Used primarily for planning mutations where the entity spec is needed without fetching the full entity.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction specFromNodeId(\n  handler: NodeIdHandler<any>,\n  $id: ExecutableStep<string> | AnyInputStep,\n): any;\n```\n\n----------------------------------------\n\nTITLE: Example Output for Forums Pagination Query - JSON\nDESCRIPTION: This JSON structure shows the result returned by the forums pagination GraphQL query. The output contains a 'forums' object with a 'nodes' array holding forum records, each with nodeId, id, and name fields. It is returned by the Graphile/PostGraphile server in response to the corresponding GraphQL request and is meant for illustrative purposes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/collections.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forums\": {\n    \"nodes\": [\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDJd\",\n        \"id\": 2,\n        \"name\": \"Feedback\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Field Description Using Context Scope in Graphile Crystal Hook (JavaScript)\nDESCRIPTION: This snippet shows how to use a Graphile Crystal hook for `GraphQLInputObjectType:fields:field`. It accesses `isMutationInput` and `fieldName` from the `scope` property within the hook's context to specifically target the `clientMutationId` field on mutation input types. If the field doesn't already have a description, it uses the `extend` utility to add one.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/context-object.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nbuilder.hook(\n  \"GraphQLInputObjectType:fields:field\",\n  (field, { extend }, { scope: { isMutationInput, fieldName } }) => {\n    if (\n      /* highlight-next-line */\n      !isMutationInput ||\n      fieldName !== \"clientMutationId\" ||\n      /* highlight-start */\n      field.description != null\n    ) {\n      return field;\n    }\n    return extend(field, {\n      /* highlight-end */\n      description:\n        \"An arbitrary string value with no semantic meaning. \" +\n        \"Will be included in the payload verbatim. \" +\n        \"May be used to track mutations by the client.\",\n    });\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Wrapping and Registering a custom GraphQL Resolver with PostGraphile - JavaScript\nDESCRIPTION: Implements a JavaScript module that uses 'graphile-utils' to wrap the 'createUser' GraphQL resolver, allowing custom pre- and post-processing logic (e.g., logging arguments and results). It defines and exports a wrapper via makeWrapResolversPlugin for integration into PostGraphile's plugin system. Requires installation of 'graphile-utils' and 'postgraphile' as dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst { makeWrapResolversPlugin } = require(\"graphile-utils\");\n\n// Create custom wrapper for resolver createUser\nconst createUserResolverWrapper = () => {\n  return async (resolve, source, args, context, resolveInfo) => {\n    // You can do something before the resolver executes\n    console.info(\"Hello world!\");\n    console.info(args);\n\n    // Let resolver execute against database\n    const result = await resolve();\n\n    // You can do something after the resolver executes\n    console.info(\"Hello again!\");\n    console.info(result);\n\n    return result;\n  };\n};\n\n// Register custom resolvers\nmodule.exports = makeWrapResolversPlugin({\n  Mutation: {\n    createUser: createUserResolverWrapper(),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote via SSH (Bash)\nDESCRIPTION: Adds the Heroku application `myappname` as a Git remote named `heroku` using the SSH protocol (`git@heroku.com:...`). This method requires the user to have uploaded their SSH public key to their Heroku account for authentication.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add heroku git@heroku.com:myappname.git\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Connection Query (GraphQL)\nDESCRIPTION: This GraphQL query demonstrates how PostGraphile exposes the set-returning SQL function `search_posts` as a queryable connection. It allows filtering via the `search` argument and pagination using `first`. The query retrieves edges containing cursors and nodes (posts) with their headline and body.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  searchPosts(search: \"Hello, world!\", first: 5) {\n    edges {\n      cursor\n      node {\n        headline\n        body\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pgServices using makePgService Helper in JavaScript\nDESCRIPTION: This snippet shows how to configure `pgServices` using the `makePgService` helper function from the `postgraphile/adaptors/pg` adaptor within a Graphile configuration preset. It populates the `pgServices` array by calling `makePgService` with common options like `connectionString`, `schemas`, `pubsub` (for LISTEN/NOTIFY), and `superuserConnectionString`, reading values from environment variables. This helper function simplifies the configuration process compared to manual setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  // ...\n  pgServices: [\n    makePgService({\n      // Database connection string:\n      connectionString: process.env.DATABASE_URL,\n\n      // List of database schemas:\n      schemas: [\"app_public\"],\n\n      // Enable LISTEN/NOTIFY:\n      pubsub: true,\n\n      // Optional, only needed for `--watch` mode:\n      superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile with Multiple Presets and Options in TypeScript\nDESCRIPTION: A comprehensive TypeScript configuration example showcasing the extension of multiple presets (`PostGraphileAmberPreset`, `makeV4Preset`, `PgRelayPreset`), inclusion of a plugin (`@grafserv/persisted`), and detailed configuration across various scopes like `inflection`, `gather`, `schema`, `grafast`, `grafserv`, `ruru`, and `pgServices`. It demonstrates setting options like V4 compatibility flags, Relay optimizations, schema export paths, Grafast context, Grafserv server settings (port, websockets, persisted operations), Ruru customization, and database connection details including schemas and pubsub activation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// Only needed for TypeScript types support\nimport \"postgraphile\";\n\n// The standard base preset to use, includes the main PostGraphile features\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\n// More presets you might want to mix in\nimport { makeV4Preset } from \"postgraphile/presets/v4\";\nimport { PgRelayPreset } from \"postgraphile/presets/relay\";\n\n// Use the 'pg' module to connect to the database\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n// In case we want to customize the Ruru we render:\nimport { defaultHTMLParts } from \"postgraphile/grafserv/ruru/server\";\n\n// A plugin for the system to use for persisted operations support\nimport PersistedPlugin from \"@grafserv/persisted\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [\n    PostGraphileAmberPreset,\n    /* Add more presets here, e.g.: */\n    makeV4Preset({\n      simpleCollections: \"both\",\n      jwtPgTypeIdentifier: '\"b\".\"jwt_token\"',\n      dynamicJson: true,\n      graphiql: true,\n      graphiqlRoute: \"/\",\n    }),\n    PgRelayPreset,\n  ],\n\n  plugins: [\n    /* Add plugins here, e.g.: */\n    PersistedPlugin,\n  ],\n\n  inflection: {\n    /* options for the inflection system */\n  },\n  gather: {\n    /* options for the gather phase, e.g.: */\n    pgStrictFunctions: true,\n    installWatchFixtures: true,\n  },\n  schema: {\n    /* options for the schema build phase, e.g.: */\n    retryOnInitFail: true,\n    exportSchemaSDLPath: `${process.cwd()}/latestSchema.graphql`,\n    exportSchemaIntrospectionResultPath: `${process.cwd()}/latestSchema.json`,\n    sortExport: true,\n  },\n  grafast: {\n    /* options for Grafast, including setting GraphQL context, e.g.: */\n    context: {\n      meaningOfLife: 42,\n    },\n    // explain: true, // DO NOT ENABLE IN PRODUCTION!\n  },\n  grafserv: {\n    /* options for Grafserv, e.g.: */\n    port: 5678,\n    graphqlPath: \"/graphql\",\n    websockets: true,\n    graphqlOverGET: true,\n    persistedOperationsDirectory: `${process.cwd()}/.persisted_operations`,\n    allowUnpersistedOperation: true,\n  },\n  ruru: {\n    /* options for customizing Ruru, e.g.: */\n    htmlParts: {\n      metaTags: defaultHTMLParts.metaTags + \"<!-- HELLO WORLD! -->\",\n    },\n  },\n  pgServices: [\n    /* list of PG database configurations, e.g.: */\n    makePgService({\n      // Database connection string, read from an environmental variable:\n      connectionString: process.env.DATABASE_URL,\n\n      // List of database schemas to expose:\n      schemas: [\"app_public\"],\n\n      // Enable LISTEN/NOTIFY:\n      pubsub: true,\n    }),\n  ],\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Implementing OrderBy Plugin with Join (V5) in TypeScript\nDESCRIPTION: Offers an alternative V5 solution for the `OrderByMemberNamePlugin` that demonstrates using Grafast's join capabilities, not possible in V4. Inside the `ordersGenerator`, it finds the `users` resource, then uses `$organizationMemberships.join` to perform an inner join to the `users` table (aliased as `member`). The `orderByAscDesc` callback then returns an order specification based directly on the joined user's name column (`${sqlIdentifier}.name`) and its codec.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"organization_memberships\" },\n  (build) => {\n    const {\n      sql,\n      input: {\n        pgRegistry: { pgResources },\n      },\n    } = build;\n    const usersSource = pgResources.find((s) => s.name === \"users\");\n    if (!usersSource) throw new Error(`Couldn't find users source`);\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order spec callback:\n      ($organizationMemberships) => {\n        $organizationMemberships.join({\n          type: \"inner\",\n          source: usersSource.source as SQL,\n          alias: sqlIdentifier,\n          conditions: [\n            sql`${sqlIdentifier}.id = ${$organizationMemberships.alias}.user_id`,\n          ],\n        });\n        return {\n          fragment: sql`${sqlIdentifier}.name`,\n          codec: usersSource.codec.columns[\"name\"].codec,\n        };\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring `package.json` Scripts and Engines for Heroku (JSON)\nDESCRIPTION: Provides an example snippet for a `package.json` file tailored for Heroku deployment. It includes a `build` script (e.g., for TypeScript compilation using `tsc`), a `start` script (typically `node server.js` to run the built application), and an `engines` section specifying the required Node.js version (e.g., `12.x`) for Heroku's runtime environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node server.js\",\n  },\n  \"engines\": {\n    \"node\": \"12.x\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine for PostGraphile Deployment - YAML\nDESCRIPTION: This YAML configuration specifies the deployment settings for a Node.js app running PostGraphile on Google App Engine. It includes Cloud SQL integration via beta_settings with a TCP-mapped unix socket, runtime environment, scaling, resource limits, health checks, file handlers, and exclusions for deployment. Dependencies include GCP project setup, a PostgreSQL Cloud SQL instance, and proper instance connection strings. Key parameters: cloud_sql_instances for DB connection, manual_scaling, and handlers for static files; expected inputs are your connection strings and resource specs. Outputs are an app prepared for GCP deployment. Constraints: values must match your GCP and DB setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nbeta_settings:\n  cloud_sql_instances: webstr-dev-######:us-central1:webstr-dev=tcp:5432\n\n# [START runtime]\nruntime: nodejs\nenv: flex\nthreadsafe: yes\nservice: wgraphile\n\nmanual_scaling:\n  instances: 1\nresources:\n  cpu: .5\n  memory_gb: .5\n  disk_size_gb: 10\n\nhealth_check:\n  enable_health_check: False\n\n# [END runtime]\n\nhandlers:\n  - url: /(.*)\n    static_files: ./\\1\n    upload: ./(.*)\n\n#  settings to keep gcloud from uploading files not required for deployment\nskip_files:\n  - ^node_modules$\n  - ^README\\..*\n  - ^package-lock.json\n  - \\.gitignore\n  - \\.es*\n  - ^\\.git$\n  - ^errors\\.log\n```\n\n----------------------------------------\n\nTITLE: Incorrect Permission Grants in PostgreSQL - SQL\nDESCRIPTION: These SQL code snippets exemplify wrong patterns for granting access in PostgreSQL from a PostGraphile perspective. The examples showcase column-level SELECT grants, as well as table-level INSERT and UPDATE grants without explicit columns. These patterns are discouraged due to limitations: they impede optimizations, block the use of '*' in queries, and prevent row-type operations, negatively affecting PostGraphile CRUD operations. The commands target the 'users' table and 'graphql_role'. Do not use these patterns; they are included as anti-patterns to avoid.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/best-practices.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- ðŸ›‘ DO NOT USE\\nGRANT SELECT (column_a, column_b) ON users TO graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- ðŸ›‘ DO NOT USE\\nGRANT INSERT ON users TO graphql_role;\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- ðŸ›‘ DO NOT USE\\nGRANT UPDATE ON users TO graphql_role;\n```\n\n----------------------------------------\n\nTITLE: Using pgUnionAll to Combine Vulnerability Data in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates configuring and using the `pgUnionAll` function to combine data from two different vulnerability resources (`firstPartyVulnerabilitiesResource` and `thirdPartyVulnerabilitiesResource`). It defines shared attributes like `cvss_score`, applies ordering based on this attribute in descending order, filters results where `cvss_score` is greater than 6 using a `where` condition with a SQL fragment, and sets up limit/offset pagination.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgUnionAll.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $vulnerabilities = pgUnionAll({\n  executor: firstPartyVulnerabilitiesResource.executor,\n  resourceByTypeName: {\n    FirstPartyVulnerability: firstPartyVulnerabilitiesResource,\n    ThirdPartyVulnerability: thirdPartyVulnerabilitiesResource,\n  },\n  attributes: {\n    cvss_score: {\n      codec: TYPES.float,\n    },\n  },\n});\n$vulnerabilities.orderBy({\n  attribute: \"cvss_score\",\n  direction: \"DESC\",\n});\n$vulnerabilities.where({\n  attribute: \"cvss_score\",\n  callback: (alias) =>\n    sql`${alias} > ${$vulnerabilities.placeholder(constant(6), TYPES.float)}`,\n});\n$vulnerabilities.setFirst(2);\n$vulnerabilities.setOffset(2);\n```\n\n----------------------------------------\n\nTITLE: Creating and Granting Anonymous Role in PostgreSQL (SQL)\nDESCRIPTION: This SQL snippet first creates a role named `forum_example_anonymous` intended for unauthenticated users (it has no login privilege). Then, it grants this anonymous role to the `forum_example_postgraphile` role, enabling the PostGraphile service (connected as `forum_example_postgraphile`) to assume the `forum_example_anonymous` role for requests from users who are not logged in.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_24\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_anonymous;\ngrant forum_example_anonymous to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Resolver Wrapper with graphile-utils in JavaScript\nDESCRIPTION: Implements a custom PostGraphile plugin using `makeWrapResolversPlugin` from `graphile-utils`. It defines a wrapper function `createUserResolverWrapper` that intercepts the `createUser` mutation, logs information before and after the original resolver executes, and then registers this wrapper to modify the behavior of the `createUser` mutation within the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nconst { makeWrapResolversPlugin } = require(\"graphile-utils\");\n\n// Create custom wrapper for resolver createUser\nconst createUserResolverWrapper = () => {\n  return async (resolve, source, args, context, resolveInfo) => {\n    // You can do something before the resolver executes\n    console.info(\"Hello world!\");\n    console.info(args);\n\n    // Let resolver execute against database\n    const result = await resolve();\n\n    // You can do something after the resolver executes\n    console.info(\"Hello again!\");\n    console.info(result);\n\n    return result;\n  };\n};\n\n// Register custom resolvers\nmodule.exports = makeWrapResolversPlugin({\n  Mutation: {\n    createUser: createUserResolverWrapper(),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Local JWT Claim in Transaction Block - SQL\nDESCRIPTION: This SQL snippet demonstrates how to set a claim (user_id) for only the duration of a transaction block using 'set local'. This ensures that the claim persists solely within the transaction, and is not available after commit or rollback, thereby enhancing session isolation and security.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nbegin;\nset local jwt.claims.user_id to 2;\n\n-- Has access to `jwt.claims.user_id`\ncommit;\n\n-- Does not have access to `jwt.claims.user_id`\n\n```\n\n----------------------------------------\n\nTITLE: Sending JWT with Relay Network Layer in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to configure the network layer for Relay. The `fetchQuery` function retrieves a JWT (using a placeholder `getJWTToken()` function) and includes it in the `Authorization` header as a Bearer token within the fetch request options when making GraphQL POST requests.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nfunction fetchQuery( operation, variables, cacheConfig, uploadables) {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n      authorization: token ? `Bearer ${token}` : \"\",\n    },\n    body: JSON.stringify({\n      query: operation.text, // GraphQL text from input\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  });\n}\n\nconst environment = new Environment({\n  network: Network.create(fetchQuery),\n  store: new Store(new RecordSource()),\n});\n```\n\n----------------------------------------\n\nTITLE: Inefficiently Archiving Forums using Loops (PL/pgSQL)\nDESCRIPTION: Demonstrates a poorly performing PostgreSQL function `archive_forums` written in PL/pgSQL. It iterates through an array of `forum_ids` using a `FOREACH` loop and executes separate `UPDATE` statements for `forums` and `posts` within each iteration. This approach is explicitly discouraged ('BAD! Don't do this!') due to potential performance issues caused by executing numerous individual SQL queries, especially with a large number of IDs. The function takes an integer array `forum_ids` and returns `void`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate function archive_forums(forum_ids int[]) returns void as $$\ndeclare\n  target_forum_id int;\nbegin\n  /* BAD: looping should be avoided! */\n  foreach target_forum_id in array forum_ids loop\n    update forums set is_archived = true where id = target_forum_id;\n    update posts set is_archived = true where forum_id = target_forum_id;\n  end loop;\nend;\n$$ language plpgsql volatile;\n```\n\n----------------------------------------\n\nTITLE: Defining grafast Context Callback in graphile.config.js (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates defining an asynchronous `grafast.context` function within a `graphile.config.js` file. It accesses the underlying Node.js request object (`requestContext.node?.req`) to extract data (like `req.user`) and defines helper functions (`getHeader`) or includes shared resources (`rootPgPool`) to be made available within the GraphQL execution context for plan resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  grafast: {\n    async context(requestContext, args) {\n      const req = requestContext.node?.req;\n      // You can perform asynchronous actions here if you need to; for example\n      // looking up the current user in the database.\n\n      // Return here things that your resolvers need\n      return {\n        // Return the current user from Passport.js or similar\n        user: req.user,\n\n        // Add a helper to get a header\n        getHeader(name) {\n          return req?.get(name);\n        },\n\n        // Give access to the database-owner PostgreSQL pool, for example to\n        // perform privileged actions\n        rootPgPool,\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying a Computed Column with Arguments via GraphQL (GraphQL)\nDESCRIPTION: Demonstrates querying a computed-column GraphQL field that expects an argument by passing the named 'greeting' parameter. Assumes PostGraphile generated 'greet' field based on an underlying SQL function. Expects a user 'id' and greeting string, returns a personalized greeting. Useful for testing function argument plumbing from GraphQL clients.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  userById(id: â€¦) {\n    greet(greeting: \"Greetings and salutations\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Computed Field with V5 JavaScript Lambda Plan\nDESCRIPTION: Presents an alternative, more performant V5 plan for the `nameWithSuffix` field compared to the SQL expression approach. This plan uses a `lambda` step to concatenate the user's name (retrieved via `$user.get(\\\"name\\\")`) and the provided suffix directly in JavaScript. Requires the `lambda` function from Gra*fast*.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n+    plans: {\n+      User: {\n+        nameWithSuffix($user, { $suffix }) {\n+          return lambda(\n+            [$user.get(\"name\"), $suffix],\n+            ([name, suffix]) => `${name} ${suffix}`,\n+          );\n+        },\n+      },\n+    },\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Tables and Functions with Composite Arguments - SQL\nDESCRIPTION: Demonstrates creating a PostgreSQL table and a function accepting a composite type as an argument. The table 'example' has a UUID primary key and a non-null text name. The function 'new_example' inserts a new record (using provided id and name) and returns the inserted row. No external dependencies are needed, but the 'example' table must exist. Inputs: 'input' of type 'example'. Output: inserted 'example' row. All columns are required.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_11\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example(input example) returns example as $$\n  insert into example (id, name) values (input.id, input.name) returning *;\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Creating PostGraphile Login Role in PostgreSQL (SQL)\nDESCRIPTION: This SQL command creates a new PostgreSQL role named `forum_example_postgraphile`. The `login` option allows this role to connect to the database, and the `password 'xyz'` option sets its password. This role is intended for the PostGraphile service connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_22\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_postgraphile login password 'xyz';\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Column Function - SQL\nDESCRIPTION: This SQL snippet defines a stable function named 'topics_body_summary' in the 'app_public' schema, intended to generate a summarized version of a topic's body text. The function accepts a row from 'app_public.topics' and an optional maximum length parameter, truncating and appending '...' if the body exceeds the length. It returns a text value and is intended as the backend implementation for the 'bodySummary' computed column exposed to GraphQL queries via Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate function app_public.topics_body_summary(\n  t app_public.topics,\n  max_length int = 30\n)\nreturns text\nlanguage sql stable\nas $$\n  select case\n    when length(t.body) > max_length\n    then left(t.body, max_length - 3) || '...'\n    else t.body\n    end;\n$$;\n```\n\n----------------------------------------\n\nTITLE: Implementing the execute Method for an AddStep Grafast Class in TypeScript\nDESCRIPTION: Demonstrates the implementation of the `execute` method for a hypothetical `AddStep` Grafast class. It uses destructuring to access `indexMap` and the dependency values (`aDep`, `bDep`). It then iterates using `indexMap`, retrieves values for each index using `at(i)`, performs the addition, and returns the resulting list.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n  execute({ indexMap, values: [aDep, bDep] }) {\n    return indexMap((i) => {\n      const a = aDep.at(i);\n      const b = bDep.at(i);\n      return a + b;\n    });\n  }\n```\n\n----------------------------------------\n\nTITLE: Handling Many-to-Many Relations with SQL Function\nDESCRIPTION: Provides a method for handling many-to-many relationships in PostGraphile using a junction table and a custom SQL function. It defines `post`, `author`, and a junction table `post_author`. A SQL function `post_authorsByPostId` is created, which accepts a `post` record and returns the corresponding set of `author` records by joining through the `post_author` table. PostGraphile can expose this function as a relation field.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/relations.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table post (\n  id serial primary key,\n  headline text,\n  body text\n);\ncreate table author (\n  id serial primary key,\n  name text\n);\ncreate table post_author (\n  post_id integer references post,\n  author_id integer references author,\n  primary key (post_id, author_id)\n);\n\ncreate function \"post_authorsByPostId\"(p post)\nreturns setof author as $$\n  select author.*\n  from author\n  inner join post_author\n  on (post_author.author_id = author.id)\n  where post_author.post_id = p.id;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Defining Type and Field Scopes in makeExtendSchemaPlugin using TypeScript\nDESCRIPTION: Illustrates how to assign or override Graphile Build scopes for types and fields within a `makeExtendSchemaPlugin`. The `__scope` property within the type's `plans` entry sets the scope for the `MyObject` type, linking it to a PostgreSQL resource. The `scope` property within the field definition object sets the scope for the `MyObject.id` field, linking it to a specific attribute. These scopes allow other Graphile Build plugins to interact with or augment these schema elements.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\n\nconst schema = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      type MyObject {\n        id: Int\n      }\n    `,\n    plans: {\n      MyObject: {\n        // Graphile Build \"scope\" for the object type 'MyObject'\n        __scope: {\n          pgTypeResource: users,\n        },\n\n        id: {\n          // The Graphile Build \"scope\" for the 'MyObject.id' field\n          scope: {\n            pgFieldAttribute: users.codec.attributes.id,\n          },\n\n          // The plan resolver for the 'MyObject.id' field\n          plan($obj) {\n            return $obj.get(\"id\");\n          },\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Foreign Key Indexes in PostgreSQL - SQL\nDESCRIPTION: This SQL query detects foreign key constraints in a PostgreSQL database that lack corresponding indexes on the referencing columns. It utilizes PostgreSQL system catalog tables (pg_constraint, pg_class, pg_index, etc.) to identify missing indexes, grouping by related namespace and table names. The output lists unindexed foreign keys, suggesting which tables and constraints may require indexing for performance improvements. Requires access to a running PostgreSQL instance with sufficient privileges to query system catalogs. Inputs: None (operates on current database). Outputs: A result set of unindexed foreign keys ordered by estimated row count. Limitations: Only works for PostgreSQL and assumes no schema filtering beyond excluding 'pg_catalog'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-indexes.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nWITH indexed_tables AS (\n  select\n      ns.nspname,\n      t.relname as table_name,\n      i.relname as index_name,\n      array_to_string(array_agg(a.attname), ', ') as column_names,\n      ix.indrelid,\n      string_to_array(ix.indkey::text, ' ')::smallint[] as indkey\n  FROM pg_class i\n  JOIN pg_index ix ON i.OID = ix.indrelid\n  JOIN pg_class t ON ix.indrelid = t.oid\n  JOIN pg_namespace ns ON ns.oid = t.relnamespace\n  JOIN pg_attribute a ON a.attrelid = t.oid\n  where a.attnum = ANY(ix.indkey)\n  and t.relkind = 'r'\n  and nspname not in ('pg_catalog')\n  group by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n  order by\n      ns.nspname,\n      t.relname,\n      i.relname,\n      ix.indrelid,\n      ix.indkey\n)\nSELECT\n  conrelid::regclass\n  ,conname\n  ,reltuples::bigint\nFROM pg_constraint pgc\nJOIN pg_class ON (conrelid = pg_class.oid)\nWHERE contype = 'f'\nAND NOT EXISTS(\n  SELECT 1\n  FROM indexed_tables\n  WHERE indrelid = conrelid\n  AND conkey = indkey\n  OR (array_length(indkey, 1) > 1 AND indkey @> conkey)\n)\nORDER BY reltuples DESC;\n```\n\n----------------------------------------\n\nTITLE: Launching Express/Graphile API Server with Custom PG Connection - JavaScript\nDESCRIPTION: This JavaScript snippet sets up an Express server configured with PostGraphile middleware using custom PostgreSQL pool parameters, supporting flexible database connection via environment variables (for GCP Cloud SQL). The dependencies are express, postgraphile, and node-postgres (used internally). Key parameters: pgService object for connection info, and postgraphile middleware options. Input: environment variables or hardcoded defaults. Output: Listens on port 8080, exposing the PostGraphile API. Limitation: Schemas and options must be specified as per your application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\n// node-postgres Pool config (https://node-postgres.com/api/pool,\n// https://node-postgres.com/api/client)\nconst pgService = {\n  host: process.env.PGHOST || \"localhost\",\n  port: process.env.PGPORT || 5432,\n  user: process.env.PGUSER,\n  database: process.env.PGDATABASE,\n  password: process.env.PGPASSWORD,\n};\n\n// Your PostGraphile config:\n// https://www.graphile.org/postgraphile/usage-library/#api-postgraphilepgservice-schemaname-options\nconst postgraphileOptions = {\n  /* ... */\n};\napp.use(postgraphile(pgService, \"public\", postgraphileOptions));\n\napp.listen(8080);\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Plugin in graphile.config.mjs (JavaScript)\nDESCRIPTION: This JavaScript code snippet demonstrates how to load a custom plugin (`MyPlugin` imported from `./myPlugin.mjs`) into PostGraphile. It shows the configuration within a `graphile.config.mjs` file, specifically adding the imported plugin to the `plugins` array in the exported configuration object. This integrates the custom plugin's functionality into the PostGraphile build process.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport MyPlugin from \"./myPlugin.mjs\";\n\nexport default {\n  // ...\n  plugins: [MyPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Introducing New GraphQL Field Argument Hooks\nDESCRIPTION: Mentions the introduction of two new hooks, `GraphQLObjectType_fields_field_args_arg` and `GraphQLInterfaceType_fields_field_args_arg`, intended to resolve plugin ordering issues related to field arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nGraphQLObjectType_fields_field_args_arg\nGraphQLInterfaceType_fields_field_args_arg\n```\n\n----------------------------------------\n\nTITLE: Selecting a Set-Returning Computed Column in SQL (SQL)\nDESCRIPTION: Retrieves an array of related records using a set-returning computed column. Assumes the existence of a function 'person_favorite_posts(person)' that returns a set, relating persons to their favorite posts. Selects the person's id and an array of posts derived from the computed column. Input is a person 'id'; output is a single row with favorite_posts as an array.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nselect\n  person.id,\n  array(\n    select posts.*\n    from person_favorite_posts(person) posts\n  ) as favorite_posts\nfrom person\nwhere id = $1;\n```\n\n----------------------------------------\n\nTITLE: Getting or Creating Execution Batch (Pseudocode)\nDESCRIPTION: Retrieves an existing batch for a given path identity from the `aether` context or creates a new one if none exists. If a new batch is created, it initializes a Crystal context (either reusing the parent's or creating a new one via `NewCrystalContext`), creates the batch object using `NewBatch`, caches it in `aether`, and schedules its asynchronous execution via `ExecuteBatch`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_40\n\nLANGUAGE: pseudocode\nCODE:\n```\nGetBatch(aether, pathIdentity, parentObject, variableValues, context, rootValue):\n\n- Let {batch} be the value for key {pathIdentity} within {aether}.{batchByPathIdentity}.\n- If {batch} is null:\n  - If {parentCrystalObject} is a crystal object:\n    - Let {crystalContext} be {parentCrystalObject}.{crystalContext}.\n  - Otherwise:\n    - Let {crystalContext} be {NewCrystalContext(aether, variableValues, context, rootValue)}.\n  - Let {batch} be {NewBatch(aether, pathIdentity, crystalContext)}.\n  - Set {batch} as the value for key {pathIdentity} within {aether}.{batchByPathIdentity}.\n  - Schedule {ExecuteBatch(aether, batch, crystalContext)} to occur soon (but asynchronously). (Note: when batch is\n    executed it will delete itself from aether.batchByPathIdentity.)\n- Return {batch}.\n```\n\n----------------------------------------\n\nTITLE: Using `sideEffect` with No Dependencies in TypeScript\nDESCRIPTION: Shows an example of calling `sideEffect` without any input steps. `null` is passed as the first argument. The callback function takes no parameters and performs a side effect, in this case, logging the current timestamp to the console. This is useful for side effects that don't depend on other computed values in the plan.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nsideEffect(null, () => console.log(new Date().toISOString()));\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing PetsCountPlugin with makeAddPgTableConditionPlugin in Graphile V5 (TypeScript)\nDESCRIPTION: Presents the Graphile V5 TypeScript equivalent of the `PetsCountPlugin` example. It demonstrates using the updated `makeAddPgTableConditionPlugin` signature. The condition generator receives `FieldArgs` (`value`) and uses `value.get()` to obtain a step representing potential input values. This step is incorporated into the SQL fragment using `$condition.placeholder` along with its type (`TYPES.int`), aligning with V5's plan-based execution model.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \"postgraphile/utils\";\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\nconst PetsCountPlugin = makeAddPgTableConditionPlugin(\n  { schemaName: \"graphile_utils\", tableName: \"users\" },\n  \"petCountAtLeast\",\n  (build) => ({\n    description: \"Filters users to those that have at least this many pets\",\n    type: build.graphql.GraphQLInt,\n  }),\n  (value, helpers) => {\n    const { sqlTableAlias, sql, $condition } = helpers;\n    const $val = value.get();\n    return sql.fragment`(select count(*) from graphile_utils.pets where pets.user_id = ${sqlTableAlias}.id) >= ${$condition.placeholder(\n      $val,\n      TYPES.int,\n    )}`;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using loadMany with ioEquivalence for a Scalar Step - TypeScript\nDESCRIPTION: Illustrates how to specify ioEquivalence for a scalar step so that the output field 'user_id' directly maps to the input specifier value ($userId), optimizing deduplication and batch fetching. Depends on corresponding callback logic to handle keys accordingly.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $posts = loadMany(\n  $userId,\n  // States that $post.get('user_id') should return $userId directly, since it\n  // will have the same value.\n  \"user_id\",\n  friendshipsByUserIdCallback,\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Ruru using Yarn (Shell)\nDESCRIPTION: Installs the beta version of the `ruru` package globally or locally using the Yarn package manager. This step is necessary before running `ruru` directly from the command line as shown in subsequent examples.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add ruru@beta\n```\n\n----------------------------------------\n\nTITLE: Switching Between PostGraphile Schemas on a Single Endpoint using JavaScript Middleware\nDESCRIPTION: This JavaScript example first initializes two separate PostGraphile instances (`notification` and `user`) by calling `postgraphile` with their respective connection strings and configurations. It then defines a middleware function using `app.use()`. Inside the middleware, a condition (`someCondition`) is checked on the incoming request (`req`). Based on the condition's result, the request is forwarded to either the `notification` service's middleware or the `user` service's middleware using the `next` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/multiple-schemas.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst services = {\n  notification: postgraphile(\n    \"CONNECTION_STRING_TO_NOTIFICATION_SERVICE\",\n    \"public\",\n    {\n      graphiql: true,\n    },\n  ),\n  user: postgraphile(\n    \"CONNECTION_STRING_TO_USER_SERVICE\",\n    \"public\",\n    {\n      graphiql: true,\n    }\n  ),\n};\n\napp.use((req, res, next) => {\n  if (someCondition) {\n    services.notification(req, res, next);\n  } else {\n    services.user(req, res, next);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Person Type with Deprecated Fields - GraphQL - GraphQL\nDESCRIPTION: This GraphQL schema definition snippet illustrates how to mark a field as deprecated in a Person type. Comments explain that the 'firstName' field should be replaced with 'name', and the field description is given as well. The input is a schema definition, and outputs include introspective support for the Person type with deprecation hints available to tools. There are no direct dependencies but requires a GraphQL-compliant environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Person {\n  /* highlight-next-line */\n  # @deprecated Use 'name' instead\n  # The person's first name\n  firstName: String\n\n  #...\n```\n\n----------------------------------------\n\nTITLE: Querying New and Deprecated Relations with GraphQL\nDESCRIPTION: Shows how to query both the old and new GraphQL API interfaces for related data, reflecting changes in PostGraphile v4. No dependencies beyond a compatible GraphQL endpoint. Demonstrates deprecated one-to-many and new direct one-to-one lookups, relevant to those migrating queries that reference table relationships. Inputs include a query with parameter 'id', and outputs are nested nodes with 'name' fields; no authentication setup is shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v3-migration.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  fooById(id: 1) {\n    # Old interface - deprecated\n    # Note: this connection can only return at most one result so doesn't\n    # deserve a connection\n    barsByFooId {\n      edges {\n        node {\n          name\n        }\n      }\n    }\n\n    # New interface - no more indirection!\n    barByFooId {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `sideEffect` with a Single Dependency in TypeScript\nDESCRIPTION: Illustrates how to use `sideEffect` with one input step. It retrieves a `$logout` step from the context (presumably representing a logout function) and passes it to `sideEffect`. The callback receives the resolved `logout` function and invokes it. This pattern is typical for triggering actions based on context or other steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $logout = context().get(\"logout\");\nsideEffect($logout, (logout) => logout());\n```\n```\n\n----------------------------------------\n\nTITLE: Running Docker Containers with Docker Compose\nDESCRIPTION: Provides shell commands using `docker-compose up` to create and start the containers defined in the `docker-compose.yml` file. Options include running in the foreground, running in detached mode (`-d`) in the background, and starting only specific services (`db`, `graphql`). It notes that Docker automatically creates a volume for database persistence on the first run.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n# Run containers for all services in docker-compose.yml\n$ docker-compose up\n\n# Run containers as daemon (in background)\n$ docker-compose up -d\n\n# Run only the database container as daemon\n$ docker-compose up -d db\n\n# Run only the GraphQL container as daemon\n$ docker-compose up -d graphql\n```\n\n----------------------------------------\n\nTITLE: Attaching Grafserv to an Express Server (JavaScript)\nDESCRIPTION: This snippet demonstrates how to integrate PostGraphile's Grafserv instance into an Express.js application. It creates an Express app, sets up an HTTP server, and uses 'serv.addTo' to connect the GraphQL server, with basic error handling. Prerequisites include Express, node's HTTP module, the correct Grafserv adapter, and an initialized PostGraphile instance. The server listens on port 5678 and logs an informational startup message.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-library.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport { pgl } from \"./pgl.js\";\n\nconst serv = pgl.createServ(grafserv);\n\nconst app = express();\nconst server = createServer(app);\nserver.on(\"error\", () => {});\nserv.addTo(app, server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\nserver.listen(5678);\n\nconsole.log(\"Server listening at http://localhost:5678\");\n```\n\n----------------------------------------\n\nTITLE: Querying Deeply Nested Album, Track, and Artist Data with Multiple Joins - GraphQL\nDESCRIPTION: Executes a very deep GraphQL query fetching albums by a specific artistId, their tracks, associated genres, and recursively all albums/tracks for each artist, including media type and genre information. This heavy example benchmarks at 550 requests per second and highlights PostGraphile's ability to flatten large, nested queries into single SQL statements to minimize latency. Accepts 'artistId' as the main filter and returns a deeply structured response covering albums, tracks, media types, and genre details.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/performance.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery prisma_deeplyNested {\n  allAlbumsList(condition: { artistId: 127 }) {\n    albumId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n    artistByArtistId {\n      albumsByArtistIdList {\n        tracksByAlbumIdList {\n          mediaTypeByMediaTypeId {\n            name\n          }\n          genreByGenreId {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering a Subscription Update with Custom Node Data - SQL (JSON Payload)\nDESCRIPTION: This SQL snippet calls pg_notify with a payload constructed using json_build_object and json_build_array to include node information in the notification. The example targets the 'postgraphile:hello' topic and provides a Node reference for integration with the listen GraphQL subscription. It illustrates how to link an event with an affected row (here, a Foo with id=32) for richer client subscriptions. Requires appropriate permissions in PostgreSQL and knowledge of your application\\'s Node structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\nselect pg_notify(\n  'postgraphile:hello',\n  json_build_object(\n    '__node__', json_build_array(\n      'foos', -- IMPORTANT: this is not always exactly the table name; base64\n              -- decode an existing nodeId to see what it should be.\n      32      -- The primary key (for multiple keys, list them all).\n    )\n  )::text\n);\n```\n\n----------------------------------------\n\nTITLE: Alternative Manual Start of the Node.js/Express Server - Bash\nDESCRIPTION: This Bash command directly runs the Node.js server using the '.env' file for environment variable settings, bypassing npm scripts. Requires Node.js v20+ for '--env-file'. Outputs a running Express/PostGraphile server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_14\n\nLANGUAGE: Bash\nCODE:\n```\nnode --env-file=./.env server.js\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint for graphile-export Plugin in JavaScript\nDESCRIPTION: Shows an example `.eslintrc.js` file snippet demonstrating how to enable the `eslint-plugin-graphile-export` by adding it to the `plugins` array and extending the recommended configuration (`plugin:graphile-export/recommended`) in the `extends` array.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// .eslintrc.js\nmodule.exports = {\n  //...\n  plugins: [\n    //...\n    \"graphile-export\",\n    //...\n  ],\n  extends: [\n    //...\n    \"plugin:graphile-export/recommended\",\n    //...\n  ],\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Extending PostGraphile Product Type with Foreign Exchange Price - JavaScript\nDESCRIPTION: This in-depth example shows how to extend the PostGraphile-generated Product GraphQL type with an additional computed price field in AUD (Australian Dollars), using a third-party currency conversion library. The plugin adds a new schema field to Product via typeDefs and provides a resolver that uses external Node.js logic to compute the field. Dependencies are postgraphile, graphile-utils, a running PostgreSQL backend, an external currency conversion library, and Express for HTTP serving. Inputs include the product's priceInUsCents field and environment configuration. The output is a new field in the GraphQL schema, priceInAuCents, and the constraint is that the new field requires access to the relevant table column, as ensured by @requires directive.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { postgraphile } = require(\"postgraphile\");\nconst { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\nconst express = require(\"express\");\nconst { convertUsdToAud } = require(\"ficticious-npm-library\");\n\nconst MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n  return {\n    typeDefs: gql`\n      extend type Product {\n        priceInAuCents: Int! @requires(columns: [\"price_in_us_cents\"])\n      }\n    `,\n    resolvers: {\n      Product: {\n        priceInAuCents: async (product) => {\n          // Note that the columns are converted to fields, so the case changes\n          // from `price_in_us_cents` to `priceInUsCents`\n          const { priceInUsCents } = product;\n          return await convertUsdToAud(priceInUsCents);\n        },\n      },\n    },\n  };\n});\n\nconst app = express();\napp.use(\n  postgraphile(process.env.DATABASE_URL, [\"app_public\"], {\n    graphiql: true,\n    appendPlugins: [MyForeignExchangePlugin],\n  }),\n);\napp.listen(3030);\n```\n\n----------------------------------------\n\nTITLE: Joining SQL Conditions with sql.join in pg-sql2 JavaScript\nDESCRIPTION: Illustrates using `sql.join` in `pg-sql2` to combine an array of SQL condition fragments with a specific delimiter like `\") and (\"`. This is useful for constructing complex `WHERE` clauses dynamically by joining individual conditions.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst arrayOfSqlConditions = [sql`a = 1`, sql`b = 2`, sql`c = 3`];\nsql`where (${sql.join(arrayOfSqlConditions, \") and (\")})`; // -> where (a = 1) and (b = 2) and (c = 3)\n```\n\n----------------------------------------\n\nTITLE: Combining Plans Using list Function in TypeScript\nDESCRIPTION: This snippet demonstrates using the list function to merge individual plan instances ($a, $b, $c) into a single ListStep, allowing positional access and standard list operations. The dependencies are the $a, $b, $c variables (representing plans) and the list function from the appropriate library or module. The result, $abcTuple, can be accessed via .at(index), .first(), and .last() methods; the input is an array of plans and the output is a ListStep containing those values. Ensure all plan objects and the list function are properly imported before use.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/list.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $abcTuple = list([$a, $b, $c]);\n```\n\n----------------------------------------\n\nTITLE: Passing Values into GraphQL Context for Grafast (TypeScript)\nDESCRIPTION: Demonstrates configuration for passing runtime values (like db) into the GraphQL context in a Grafast (Graphile/Fastify) environment. By specifying a context factory in the preset, dependencies become available in resolvers' context argument, supporting the pure pattern shown previously. Inputs are base context and db; output is enhanced context.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {} from \"grafast\";\n// highlight-next-line\nimport { db } from \"./runtime/db\";\n\nexport const preset: GraphileConfig.Preset = {\n  grafast: {\n    // highlight-next-line\n    context: (ctx) => ({ db }),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Converting @requires Directive from V4 to V5 Plans in JavaScript\nDESCRIPTION: Shows the migration of a `makeExtendSchemaPlugin` definition from PostGraphile V4 to V5. It replaces the V4 `@requires` directive and resolver logic with a V5 plan that uses `$product.get('price_in_us_cents')` and a `lambda` step from `postgraphile/grafast` to compute the `priceInAuCents` field. Dependencies include `postgraphile/utils`, `ficticious-npm-library`, and `postgraphile/grafast`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n```diff title=\"V4 -> V5 conversion\"\n-const { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\n+const { makeExtendSchemaPlugin, gql } = require(\"postgraphile/utils\");\n const { convertUsdToAud } = require(\"ficticious-npm-library\");\n+const { lambda } = require('postgraphile/grafast');\n\n-const MyForeignExchangePlugin = makeExtendSchemaPlugin((build, options) => {\n+const MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n+  const { options } = build;\n   return {\n     typeDefs: gql`\n       extend type Product {\n-        priceInAuCents: Int! @requires(columns: [\"price_in_us_cents\"])\n+        priceInAuCents: Int!\n       }\n     `,\n-    resolvers: {\n+    plans: {\n       Product: {\n-        priceInAuCents: async (product) => {\n-          // Note that the columns are converted to fields, so the case changes\n-          // from `price_in_us_cents` to `priceInUsCents`\n-          const { priceInUsCents } = product;\n-          return await convertUsdToAud(priceInUsCents);\n-        },\n+        priceInAuCents($product) {\n+          const $cents = $product.get('price_in_us_cents');\n+          return lambda($cents, cents => convertUsdToAud(cents));\n+        },\n       },\n     },\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: Determining Previous Pagination Availability Using SQL EXISTS Clause - SQL\nDESCRIPTION: This SQL snippet checks for the existence of rows prior to the current cursor by using an EXISTS subquery. It is used to determine the hasPreviousPage field in a paginated GraphQL connection response. The query leverages appropriate WHERE clauses (including filters and inverse 'after' condition) to efficiently check for previous records, returning a boolean. It assumes the implementation will properly substitute <source>, <filters>, and the 'after' condition.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/pages/plans/pgPageInfo.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nselect exists(\n  select 1\n  from <source>\n  where <filters>\n  and <inverse of \\\"after\\\" condition>\n) as has_previous_page\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile V4 Plugin (JavaScript)\nDESCRIPTION: Illustrates the structure of a PostGraphile V4 plugin (`V4AddQueryFourFieldPlugin.js`). V4 plugins were functions accepting a `builder` object and used hooks like `GraphQLObjectType:fields` to modify the schema, often defining `resolve` functions for fields. Note: This code is for V4 and will not work with V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// Version 4 example; will not work with V5!\n// highlight-start\nmodule.exports = (builder) => {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    // highlight-end\n    const {\n      graphql: { GraphQLInt },\n    } = build;\n    const { Self } = context;\n    if (Self.name !== \"Query\") return fields;\n    return build.extend(\n      fields,\n      {\n        four: {\n          type: GraphQLInt,\n          // highlight-start\n          resolve() {\n            return 4;\n          },\n          // highlight-end\n        },\n      },\n      \"Adding Query.four\",\n    );\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript to Support Node.js Exports â€“ JSON\nDESCRIPTION: This JSON snippet illustrates how to set the 'moduleResolution' option in your TypeScript configuration to either 'node16' or 'nodenext'. This setting is required to ensure that the TypeScript compiler understands the 'exports' field present in modern Node.js package.json files. This configuration is necessary if you wish to use TypeScript v5.0.0+ effectively with PostGraphile and related packages; it modifies how modules and package entrypoints are resolved, particularly pertinent when dependencies use the export maps feature. The key input is the value of the 'moduleResolution' option, and the output is proper TypeScript module resolution; omitting this step may lead to failed imports or type errors.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/requirements.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n    \\\"moduleResolution\\\": \\\"node16\\\", // Or \\\"nodenext\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Re-initializing the PostgreSQL Database\nDESCRIPTION: Provides a sequence of shell commands to completely reset the PostgreSQL database state when schema changes in `/db/init` need to be applied. This involves stopping containers (`docker-compose down`), listing Docker volumes (`docker volume ls`), removing the specific database volume (`docker volume rm <volume_name>`), removing the database Docker image to force a rebuild (`docker rmi db`), and then restarting the services (`docker-compose up`), which rebuilds the image and runs the initialization scripts against a fresh volume.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n# Stop running containers\n$ docker-compose down\n\n# List Docker volumes\n$ docker volume ls\n\n# Delete volume\n$ docker volume rm <your_repository_name>_db\n\n# Delete database image to force rebuild\n$ docker rmi db\n\n# Run containers (will automatically rebuild the image)\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Creating a Node.js HTTP Server with PostGraphile Library in JavaScript\nDESCRIPTION: Defines a basic Node.js HTTP server in `server.js`. It imports the `postgraphile` library, creates an HTTP server, and uses `postgraphile` middleware configured with the database connection string (`process.env.DATABASE_URL`), the schema name ('public'), and options to enable database watching (`watchPg`), the GraphiQL interface (`graphiql`), and enhanced GraphiQL features (`enhanceGraphiql`). The server listens on the port specified by the `PORT` environment variable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst http = require(\"http\");\\nconst { postgraphile } = require(\"postgraphile\");\\n\\nhttp\\n  .createServer(\\n    postgraphile(process.env.DATABASE_URL, \"public\", {\\n      watchPg: true,\\n      graphiql: true,\\n      enhanceGraphiql: true,\\n    })\\n  )\\n  .listen(process.env.PORT);\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector in PostGraphile Plugin (JavaScript)\nDESCRIPTION: This JavaScript snippet defines a plugin that adds a new inflector called 'enhanced', which appends 'Enhanced' to a given column name. The inflector is registered using the inflection.add property. The function receives the preset (hidden) and the columnName as arguments, and outputs the enhanced string. No dependencies outside GraphileConfig.Plugin are explicitly required for the JS variant. Intended for simple extension scenarios.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\\n  name: \\\"MyNewInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n  inflection: {\\n    add: {\\n      enhanced(preset, columnName) {\\n        return columnName + \\\"Enhanced\\\";\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Using `sideEffect` with Multiple Dependencies (Tuple) in TypeScript\nDESCRIPTION: Demonstrates passing multiple dependencies to `sideEffect` using an array (tuple). The array contains the steps `$login`, `$username`, and `$password`. The callback function receives the resolved values of these steps as a tuple `[login, username, password]` in the corresponding order, which are then used to invoke the `login` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nsideEffect(\n  // Tuple of dependencies\n  [$login, $username, $password],\n  // becomes a tuple in callback:\n  ([login, username, password]) => login(username, password),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile to Forbid Null Rows in SETOF Functions (TypeScript)\nDESCRIPTION: This TypeScript/JavaScript config snippet, suitable for a graphile.config.mjs file, shows how to set schema.pgForbidSetofFunctionsToReturnNull to true. This instructs PostGraphile to treat table-returning SQL functions as non-nullable if you guarantee they wonâ€™t return NULL rows. Pre-requisites: a PostGraphile or GraphileConfig-aware project. Accepts schema configuration object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nexport default {\n  // ...\n  schema: {\n    pgForbidSetofFunctionsToReturnNull: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Advanced Custom OrderBy Plugin with Join (V5, Graphile) - TypeScript\nDESCRIPTION: This advanced V5 OrderBy plugin example illustrates how a join can be added to the ordering logic, something not possible in V4. The code programmatically locates the relevant 'users' resource, throws if absent, forms a join on the fly, and then sorts by the user's name column. SQL fragments and codecs are used precisely, leveraging new V5 extensibility for multi-table orderings. Inputs include table/schema names and the build context for accessing registry resources. Dependencies include Graphile's V5 API and plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"organization_memberships\" },\n  (build) => {\n    const {\n      sql,\n      input: {\n        pgRegistry: { pgResources },\n      },\n    } = build;\n    const usersSource = pgResources.find((s) => s.name === \"users\");\n    if (!usersSource) throw new Error(`Couldn't find users source`);\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order spec callback:\n      ($organizationMemberships) => {\n        $organizationMemberships.join({\n          type: \"inner\",\n          source: usersSource.source as SQL,\n          alias: sqlIdentifier,\n          conditions: [\n            sql`${sqlIdentifier}.id = ${$organizationMemberships.alias}.user_id`,\n          ],\n        });\n        return {\n          fragment: sql`${sqlIdentifier}.name`,\n          codec: usersSource.codec.columns[\"name\"].codec,\n        };\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Querying One-to-One Relationships (v4 Direct Access) in GraphQL\nDESCRIPTION: This GraphQL query demonstrates the improved way to query one-to-one relationships in PostGraphile v4. It allows direct access to the related `bar` object (`barByFooId`) and its fields (`name`) from the `foo` object, eliminating the need for the connection (`edges`/`node`) boilerplate.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  fooById(id: 1) {\n    barByFooId {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Joining SQL Identifiers with sql.join in pg-sql2 JavaScript\nDESCRIPTION: Shows how to use `sql.join` in `pg-sql2` to combine an array of SQL fragments, specifically `sql.identifier` results, into a comma-separated list suitable for a `SELECT` clause. This ensures each identifier is properly escaped before joining.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst arrayOfSqlFields = [\"a\", \"b\", \"c\", \"d\"].map((n) => sql.identifier(n));\nsql`select ${sql.join(arrayOfSqlFields, \", \")}`; // -> select \"a\", \"b\", \"c\", \"d\"\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Plugin to Graphile Service Configuration - docker-compose.yml\nDESCRIPTION: Demonstrates how to configure the 'graphql' service in docker-compose.yml to use the custom PostGraphile plugin via the '--append-plugins' parameter. The command array specifies the database connection, port, schema, and additional plugins required at runtime. Assumes that required environment variables like DATABASE_URL are set and that the custom-plugin is properly installed globally.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db:\n        [...]\n\n    graphql:\n        [...]\n        command:\n            [\n                \"--connection\",\n                \"${DATABASE_URL}\",\n                \"--port\",\n                \"5433\",\n                \"--schema\",\n                \"public\",\n                \"--append-plugins\",\n                \"postgraphile-plugin-connection-filter,custom-plugin\",\n            ]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Creating Table and Function with Composite Type Argument - PostgreSQL SQL\nDESCRIPTION: This snippet creates a PostgreSQL table named 'example' with an 'id' (UUID primary key) and 'name' (non-null text), followed by a function 'new_example' that inserts a row based on an 'example' composite-type argument and returns the inserted row. Dependencies are PostgreSQL with UUID extension and permission to define tables/functions. The function takes a single typed argument matching the table structure and returns a row of the same type, useful as a mutation entrypoint for GraphQL. Input parameters map directly to table columns, and outputs are all columns of the new row.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_11\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example(input example) returns example as $$\n  insert into example (id, name) values (input.id, input.name) returning *;\n$$ language sql volatile;\n\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Query with `grafast()` in JavaScript\nDESCRIPTION: Illustrates executing a GraphQL query using the `grafast()` function. This function simplifies execution by accepting the schema, resolved preset, request context, query source, and variables, automatically handling GraphQL context creation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { grafast } from \"postgraphile/grafast\";\n\nconst { data, errors } = await grafast({\n  schema,\n  resolvedPreset,\n  requestContext: {\n    // This is the \"request context\" - it is **NOT** the GraphQL context\n  },\n  source: /* GraphQL */ `\n    query MyQuery {\n      __typename\n    }\n  `,\n  variableValues: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Using the gql Helper for Dynamic Type Definitions in TypeScript\nDESCRIPTION: Illustrates how to use the `gql` helper from `postgraphile/utils` to construct GraphQL schema definitions dynamically. It shows interpolating a string variable (`nameOfType`) to define a type name and interpolating another `gql` tag (`Type`) within a larger definition (`typeDefs`). This is useful for integrating with PostGraphile's inflection system or creating reusable schema parts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst nameOfType = \"MyType\"; // Or use the inflection system to generate a type\n\n// This tag interpolates the string `nameOfType` to allow dynamic naming of the\n// type.\nconst Type = gql`\n  type ${nameOfType} {\n    str: String\n    int: Int\n  }\n`;\n\n// This tag interpolates the entire definition in `Type` above.\nconst typeDefs = gql`\n  ${Type}\n\n  extend type Query {\n    fieldName: Type\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Omitting Table from Mutations Using JSON5 Smart Tags - JSON5\nDESCRIPTION: This JSON5 snippet configures a class (table) to omit create, update, and delete operations in the GraphQL schema using the 'omit' smart tag. Intended to be placed in PostGraphile's smart-tags.json5 file. The tag's value is a comma-separated string of operations to omit.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_11\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  table_name: {\n    tags: {\n      omit: \"create,update,delete\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Ruru API Route Handler in Next.js with JavaScript\nDESCRIPTION: This snippet illustrates the creation of the `/api/ruru` endpoint handler, which typically serves the Ruru GraphiQL interface. Similar to the GraphQL handler, it imports the shared `serv` instance from `utils/grafserv.mjs`. It then calls `serv.createRuruHandler()` to generate the specific handler function, which is exported as the default export for the Next.js API route (`pages/api/ruru.mjs`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/next.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// pages/api/ruru.mjs\nimport { serv } from \"../../utils/grafserv.mjs\";\n\n// Create and export the `/ruru` route handler\nconst handler = serv.createRuruHandler();\nexport default handler;\n```\n\n----------------------------------------\n\nTITLE: Running Linter and Auto-Fixing with Yarn\nDESCRIPTION: Runs the `lint:fix` script using Yarn, which likely utilizes a linting tool (like ESLint or Prettier) to check code style and quality, automatically fixing any detected issues where possible. This command should be run before submitting pull requests to ensure code consistency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn lint:fix\n```\n\n----------------------------------------\n\nTITLE: Comprehensive PostGraphile Configuration with Watch - JavaScript\nDESCRIPTION: A JavaScript graphile.config.mjs configuration file providing settings equivalent to CLI invocation with the --watch flag. It imports PostGraphileAmberPreset and makePgService, sets up the pgServices, and enables watch mode. Requires postgraphile package and access to the specified PostgreSQL database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [PostGraphileAmberPreset],\n  pgServices: [makePgService({ connectionString: \"postgres:///mydb\" })],\n  grafserv: { watch: true },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Checking Node.js Version using Bash\nDESCRIPTION: Checks the currently installed Node.js version using the `--version` flag. This command requires Node.js to be installed and accessible in the system's PATH environment variable. It outputs the installed version string (e.g., v16.20.0) to the standard output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode --version\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for JWT Verification (Bash)\nDESCRIPTION: Demonstrates how to install the required Node.js packages (`express`, `express-jwt`, `jwks-rsa`) using either the Yarn or npm package manager. These packages are essential for setting up the Express server and implementing JWT verification with JWKS.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add express express-jwt jwks-rsa\n# Or:\nnpm install --save express express-jwt jwks-rsa\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema Using Graphile Build Toolkit - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to programmatically construct a GraphQL schema using the 'graphile-build' toolkit, leveraging default and custom presets for extensible plugin configuration. It imports the necessary build and print utilities, defines a preset (here, based on the default), constructs the schema asynchronously, and prints the resulting schema string to the console. Required dependencies include 'graphile-build' for schema generation and 'graphql' for schema output; the code expects at least Node.js 14+ to support top-level await. The 'preset' parameter can be customized for further extensibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { buildSchema, defaultPreset } from \"graphile-build\";\nimport { printSchema } from \"graphql\";\n\nconst preset = {\n  extends: [\n    defaultPreset,\n    // Add more presets here!\n  ],\n};\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n```\n\n----------------------------------------\n\nTITLE: Applying Validation Logic to Multiple Mutation Resolvers (TypeScript)\nDESCRIPTION: This TypeScript code creates a schema plugin that adds user data validation to several mutation resolvers using makeWrapPlansPlugin. It defines a reusable function to assert user validity and uses sideEffect to enforce validation before mutations occur. Dependencies include makeWrapPlansPlugin and sideEffect from PostGraphile, and the rules object maps multiple mutations to the validation logic. Each mutation ensures user data integrity prior to execution, throwing an error if data is invalid.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { sideEffect } from \"postgraphile/grafast\";\\n\\nfunction assertValidUserData(data) {\\n  if (!data || data.username?.length === 0) {\\n    throw new Error(\"Invalid data\");\\n  }\\n}\\n\\nconst validateUserData = (propName) => {\\n  return (plan, $source, fieldArgs) => {\\n    const $user = fieldArgs.getRaw([\"input\", propName]);\\n\\n    // Callback throws error if invalid\\n    sideEffect($user, (user) => assertValidUserData(user));\\n\\n    return plan();\\n  };\\n};\\n\\nexport default makeWrapPlansPlugin({\\n  Mutation: {\\n    createUser: validateUserData(\"user\"),\\n    updateUser: validateUserData(\"userPatch\"),\\n    updateUserById: validateUserData(\"userPatch\"),\\n    updateUserByEmail: validateUserData(\"userPatch\"),\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Renaming Table and Function Using SQL Smart Comments - SQL\nDESCRIPTION: This SQL snippet attaches @name smart comments to a table and a function, instructing PostGraphile to map 'post' to 'message' and 'search_posts' to 'returnPostsMatching' in the GraphQL schema. Used on PostgreSQL objects before running PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table post is\n  E'@name message';\ncomment on function search_posts(text) is\n  E'@name returnPostsMatching';\n```\n\n----------------------------------------\n\nTITLE: Running a Node.js Server with an Exported PostGraphile Schema in TypeScript\nDESCRIPTION: This script demonstrates how to run a GraphQL server using a previously exported PostGraphile schema. It imports the `grafserv` adaptor for Node.js, the exported schema (`exported-schema.mjs`), and the original configuration preset. It creates an HTTP server and attaches `grafserv`, configured with the preset and the *exported* schema, eliminating the need for PostGraphile's schema building process at runtime. The server then listens on the specified port.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/exporting-schema.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { grafserv } from \"postgraphile/grafserv/node\";\nimport { createServer } from \"node:http\";\nimport preset from \"./graphile.config.js\";\nimport { schema } from \"./exported-schema.mjs\";\n\nconst server = createServer();\nconst serv = grafserv({ preset, schema });\nserv.addTo(server);\nserver.listen(5555);\nconsole.log(\"Listening on http://localhost:5555/\");\n```\n\n----------------------------------------\n\nTITLE: Authenticated Apollo WebSocketLink Setup with JWT - JavaScript\nDESCRIPTION: Configures an Apollo WebSocketLink for subscriptions, injecting the JWT in the 'authorization' param on websocket connection setup. Dependencies: Apollo WebSocketLink, getJWTToken(). Inputs: JWT token, outputs: wsLink instance for authenticated websocket communication.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// get the authentication token from wherever you store it\nconst token = getJWTToken();\n\nconst wsLink = new WebSocketLink({\n  uri: \"ws://localhost:3000/graphql\",\n  options: {\n    reconnect: true,\n    connectionParams: token\n      ? {\n          authorization: `Bearer ${token}`,\n        }\n      : {},\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Ignore File for Node.js Projects - Dockerfile\nDESCRIPTION: This snippet is an example .dockerignore file that specifies which files and directories should be excluded from the built Docker context for a Node.js-based server project. Omitting these items ensures smaller images, faster builds, and avoids accidentally including development files such as source control, local configuration, test suites, or build artifacts. It requires Docker to be installed and used in a Node.js repository, and should be placed as .dockerignore in the project root. Inputs are the patterns listed, and output is exclusion of matching files from the build context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-docker.md#_snippet_0\n\nLANGUAGE: dockerfile\nCODE:\n```\n# .dockerignore\\n.env\\n.git\\n.github\\n.next\\n.vscode\\nnode_modules\\n\\n*Dockerfile*\\n*docker-compose*\\n\\n**/dist\\n**/__tests__\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile Resource Conflict Error Message\nDESCRIPTION: This snippet displays a typical error message from PostGraphile indicating a resource naming conflict. It occurs when two distinct database entities (e.g., a function and a table) are inflected to the same name during schema generation, preventing successful build. The message details the conflicting entities and provides a link for more information.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/errors/2rc.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n```\nError: Attempted to add a second resource named 'foo':\n  First represented a function accepting 0 parameters and returning SQL type '\"bool\"'.\n  Second represents a table/view/etc called '\"public\".\"foo\"'.\n  Details: https://err.red/p2rc\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Dependency Lambda Step in TypeScript\nDESCRIPTION: This snippet shows the TypeScript function signature for the `lambda` step with a single input step (`ExecutableStep`). It takes an input step, a callback function that processes the resolved value of the input step (potentially returning a Promise), and an optional `isSyncAndSafe` boolean flag. This flag optimizes performance if the callback is guaranteed to be synchronous, safe, and non-throwing. The function returns a new `ExecutableStep` representing the result of applying the callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction lambda<T, R>(\n  $input: ExecutableStep<T>,\n  callback: (input: T) => R | Promise<R>,\n  isSyncAndSafe = false,\n): ExecutableStep<R>;\n```\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Query Type for a PostgreSQL Table\nDESCRIPTION: GraphQL schema definition illustrating the `Query` type fields generated by PostGraphile for the example `app_public.users` table. It includes `allUsers` for fetching collections with pagination/filtering/ordering, `userById` and `userByUsername` for fetching single records by unique constraints, and `user` for fetching by the globally unique `nodeId`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/tables.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query implements Node {\n  allUsers(\n    first: Int\n    last: Int\n    offset: Int\n    before: Cursor\n    after: Cursor\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n    condition: UserCondition\n  ): UsersConnection\n\n  userById(id: Int!): User\n\n  userByUsername(username: String!): User\n\n  user(nodeId: ID!): User\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Deeply Nested Album, Track, Media, and Genre Data - PostGraphile - GraphQL\nDESCRIPTION: This advanced GraphQL query demonstrates accessing multiple layers of related data via deeply nested relationships, starting from albums filtered by artist, traversing tracks, genres, and recursively fetching additional albums, tracks, genres, and media types via associated artist relationships. It is used as a heavy-load benchmark to test PostGraphile's ability to merge deep, complex GraphQL queries into a single SQL statement. Inputs: artist filtering condition; outputs: nested structures of albums, tracks, genre names, media types, etc. Dependency: a normalized database schema handled by PostGraphile. Limitation: performance may depend on underlying database indexes and join efficiency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/performance.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery prisma_deeplyNested {\n  allAlbumsList(condition: { artistId: 127 }) {\n    albumId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n    artistByArtistId {\n      albumsByArtistIdList {\n        tracksByAlbumIdList {\n          mediaTypeByMediaTypeId {\n            name\n          }\n          genreByGenreId {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutation Field Nullability and Error Propagation (GraphQL)\nDESCRIPTION: This mutation demonstrates the effect of marking root mutation fields as non-nullable. It performs two mutations: createSecret and someOtherMutation. If someOtherMutation fails, the entire mutation response would become null if fields are non-nullable, illustrating a potential data loss in the returned response. No dependencies. Contains two root mutation operations with input objects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/why-nullable.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createSecret(input: {label: \"Foo\"}) { secret }\n  someOtherMutation(input: {...}) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Enum Table GraphQL Name via Smart Comment (SQL)\nDESCRIPTION: Shows how to apply the `@enumName` smart comment to an enum table (`animal_type`) to control the generated GraphQL enum name, setting it to `TypeOfAnimal`. This requires the `animal_type` table to be previously defined and marked with `@enum`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table animal_type is E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Inefficient RLS Policy Function Accepting Row Data in PostgreSQL (SQL)\nDESCRIPTION: Demonstrates an inefficient Row-Level Security (RLS) pattern. It defines an SQL function `current_user_is_member_of` that checks membership for a specific `target_organization_id`. This function is then used within an RLS policy (`select_members`) by passing the `members.organization_id` column value. This is flagged as 'BAD!' because the function might be called repeatedly, once for each distinct `organization_id` or potentially for every row being checked, leading to poor performance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n```sql title=\"BAD! Uses row data in function call\"\ncreate function current_user_is_member_of(target_organization_id int) returns boolean as $$\n  select exists(\n    select 1\n    from memebrs\n    where organization_id = target_organization_id\n    and user_id = current_user_id()\n  );\n$$ language sql stable security definer;\n\ncreate policy select_members\n  for select on members\n  using (\n    /* highlight-next-line */\n    current_user_is_member_of(members.organization_id)\n  );\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine for PostGraphile CLI Deployment (YAML)\nDESCRIPTION: Defines the GCP App Engine flexible environment configuration (`app.yaml`) for deploying PostGraphile using the CLI. It specifies the Node.js runtime, sets up Cloud SQL instance connection via `beta_settings` for connecting to the PostgreSQL database, defines scaling/resources, disables default health checks, and configures file skipping for optimized deployment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nbeta_settings:\n  cloud_sql_instances: webstr-dev-######:us-central1:webstr-dev=tcp:5432\n\n# [START runtime]\nruntime: nodejs\nenv: flex\nthreadsafe: yes\nservice: wgraphile\n\nmanual_scaling:\n  instances: 1\nresources:\n  cpu: .5\n  memory_gb: .5\n  disk_size_gb: 10\n\nhealth_check:\n  enable_health_check: False\n\n# [END runtime]\n\nhandlers:\n  - url: /(.*)\n    static_files: ./\\1\n    upload: ./(.*)\n\n#  settings to keep gcloud from uploading files not required for deployment\nskip_files:\n  - ^node_modules$\n  - ^README\\..*\n  - ^package-lock.json\n  - \\.gitignore\n  - \\.es*\n  - ^\\.git$\n  - ^errors\\.log\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Plugin via PostGraphile CLI (Shell)\nDESCRIPTION: This shell command demonstrates how to load a custom Graphile Engine plugin into PostGraphile. It uses the `--append-plugins` flag to specify the path to the plugin file (`add-http-bin-plugin.js`) and the `-c` flag to provide the PostgreSQL connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npostgraphile --append-plugins `pwd`/add-http-bin-plugin.js -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Retrieving Serialized JWT Claim in SQL (SQL)\nDESCRIPTION: Queries a transaction-scoped Postgres setting containing a deserialized JWT claim value. The function 'current_setting' fetches the value for 'jwt.claims.a' (set previously), returning it as text or null if not set. Requires a previously established 'set local jwt.claims.a'. The output is the current claim value or null; the input is the claim setting key.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_29\n\nLANGUAGE: SQL\nCODE:\n```\nselect current_setting('jwt.claims.a', true);\n```\n\n----------------------------------------\n\nTITLE: Manually Configuring pgServices in JavaScript\nDESCRIPTION: This snippet demonstrates the manual configuration of the `pgServices` array for PostGraphile. It imports the `pg` module and the `@dataplan/pg` adaptor, then defines a service named \"main\", specifying the schemas to use, context keys (`pgSettingsKey`, `withPgClientKey`), the adaptor module, and adaptor-specific settings like a `pg.Pool` instance created using an environment variable for the connection string. This approach provides fine-grained control over the service definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport * as pg from \"pg\";\nimport * as adaptor from \"@dataplan/pg/adaptors/pg\";\n\nconst pgServices = [\n  {\n    name: \"main\",\n    schemas: [\"app_public\"],\n    pgSettingsKey: \"pgSettings\",\n    withPgClientKey: \"withPgClient\",\n    adaptor,\n    adaptorSettings: {\n      pool: new pg.Pool({ connectionString: process.env.DATABASE_URL }),\n      // superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Documenting NullsSortMethod and OrderByAscDescOptions Types â€“ TypeScript\nDESCRIPTION: Describes the types and options available for customizing NULL sorting behavior in orderByAscDesc. The NullsSortMethod union type lists valid values (such as \"first\" or \"last\"), while the OrderByAscDescOptions interface defines available flags including uniqueness, nulls handling, and nullability. Intended for developers implementing precise ordering control through PostGraphile plugins. No code executes; defines types/interfaces only.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type NullsSortMethod =\n  | \"first\"\n  | \"last\"\n  | \"first-iff-ascending\"\n  | \"last-iff-ascending\"\n  | undefined;\n\nexport interface OrderByAscDescOptions {\n  unique?: boolean;\n  nulls?: NullsSortMethod;\n  nullable?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Enum Type for Post Topics (SQL)\nDESCRIPTION: Defines a PostgreSQL enumeration type named `post_topic` within the `forum_example` schema. This type restricts values to 'discussion', 'inspiration', 'help', or 'showcase', intended for categorizing forum posts. PostGraphile automatically converts this database enum into a corresponding GraphQL enum type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate type forum_example.post_topic as enum (\n  'discussion',\n  'inspiration',\n  'help',\n  'showcase'\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function using LANGUAGE sql (SQL)\nDESCRIPTION: Provides a basic example of a PostgreSQL function `add` created using `LANGUAGE sql`. This function accepts two integer arguments, `a` and `b`, and returns their sum calculated via a `SELECT` statement. It is marked `immutable` (meaning its result depends only on its arguments and is stable over time) and `strict` (meaning it returns null if any argument is null). This demonstrates the simplest way to define functions when the logic can be expressed in a single SQL query.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\n  select a + b;\n$$ language sql immutable strict;\n```\n\n----------------------------------------\n\nTITLE: Declaring a No-Operation Plugin (JavaScript)\nDESCRIPTION: This snippet defines a minimal Graphile Build plugin object in JavaScript. It includes just the required metadata properties: name, version, and description, but does not implement any plugin scopes such as 'inflection', 'gather', or 'schema'. This kind of plugin is inert by design and can be included in plugin lists for structural or demonstration purposes.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/plugins.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst NoopPlugin = {\n  name: \"NoopPlugin\",\n  version: \"0.0.0\",\n  description: \"Does nothing\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining an EXPORTABLE Function (TypeScript - After ESLint Fix)\nDESCRIPTION: This TypeScript snippet demonstrates the post-autofix version of the EXPORTABLE function pattern. The function now explicitly declares its dependency on variable 'a' by adding '[a]' as a second parameter, ensuring that all external references are properly managed for export. Key parameters include the exported function (with its own arguments) and the explicit dependencies array. The output is enhanced by the ESLint plugin for improved clarity and correctness in code exportability.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/eslint.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst add = EXPORTABLE(\n  // highlight-next-line\n  (a) =>\n    function add(b) {\n      return a + b;\n    },\n  // highlight-next-line\n  [a],\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Plan Structure - Pseudocode\nDESCRIPTION: This pseudocode outlines how to create a new plan object with properties for dependencies, children, finalized state, IDs, and linkage into the aether's plan list. This foundational structure is a prerequisite for all later plan-building routines, establishing unique IDs and group context. It must be called before assembling plan-specific logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_20\n\nLANGUAGE: pseudocode\nCODE:\n```\nNewPlan(aether):\n\n- Let {plan} be an empty object.\n- Let {plan}.{dependencies} be an empty list. (Note: this is plans this plan will need the data from in order to\n  execute.)\n- Let {plan}.{children} be an empty list. (Note: this is plans that this plan might execute; currently it's the expected\n  way that polymorphic plans (see {GetPolymorphicObjectPlanForType()}) might work.)\n- Let {plan}.{finalized} be {false}.\n- Let {plan}.{groupId} be {aether}.{groupId}.\n- Let {plan}.{id} be the length of {aether}.{plans}.\n- Push {plan} onto {aether}.{plans} (Note: it will have {plan}.{id} as its index within {aether}.{plans}).\n- Return {plan}.\n```\n\n----------------------------------------\n\nTITLE: Setting GRAPHILE_LICENSE Environment Variable in Bash/Shell\nDESCRIPTION: Demonstrates setting the `GRAPHILE_LICENSE` environment variable, required for premium Graphile plugins, across different shell environments: Bash (Linux/macOS), Heroku CLI, Windows Command Prompt, and Windows PowerShell.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# GNU/Linux and macOS bash:\nexport GRAPHILE_LICENSE=\"license_key_from_graphile_store\"\npostgraphile -c postgres://...\n\n# Heroku\nheroku config:set GRAPHILE_LICENSE=\"license_key_from_graphile_store\" -a my_heroku_app\n\n# Windows Console\nset GRAPHILE_LICENSE=\"license_key_from_graphile_store\" & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:GRAPHILE_LICENSE=\"license_key_from_graphile_store\"; postgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Finding Filtered Rows with `resource.find()` in Gra*fast*/@dataplan/pg (TypeScript)\nDESCRIPTION: Illustrates calling the `find()` method on a `@dataplan/pg` resource (`channels`) with a filter condition (`organization_id: $organizationId`). The filter value (`$organizationId`) is another Gra*fast* step, allowing dynamic filtering based on previously fetched data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst $channels = channels.find({ organization_id: $organizationId });\n```\n\n----------------------------------------\n\nTITLE: Implementing Enums Using a Dedicated Table and Smart Comment (SQL)\nDESCRIPTION: Creates an `animal_type` table to hold enum values ('CAT', 'DOG', 'FISH') and their descriptions. The `@enum` smart comment signals PostGraphile to treat this table as a source for a GraphQL enum. A `pets` table references `animal_type` via a foreign key, enforcing the enum constraint at the database level. This approach is useful when native PostgreSQL enums are too restrictive and requires PostGraphile 4.8.0+.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table animal_type (\n  type text primary key,\n  description text\n);\ncomment on table animal_type is E'@enum';\ninsert into animal_type (type, description) values\n  ('CAT', 'A feline animal'),\n  ('DOG', 'A canine animal'),\n  ('FISH', 'An aquatic animal');\n\ncreate table pets (\n  id serial primary key,\n  type text not null references animal_type,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Resources from PgRegistry (TypeScript)\nDESCRIPTION: This snippet extracts table resources (organizations, users, channels) from the pgResources registry attached to the build object within a PostGraphile plugin. This enables later queries like find/get on these resources, allowing typed and optimized access to PostgreSQL tables via Grafast. The main prerequisite is that PostGraphile and Grafast are properly initialized and introspected tables have resources present.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { organizations, users, channels } = build.input.pgRegistry.pgResources;\n```\n\n----------------------------------------\n\nTITLE: Using EXPORTABLE for Graphile Export in JavaScript\nDESCRIPTION: The `EXPORTABLE` identifier is used within the `graphile-export` system. It likely wraps functions or values to make them recognizable and processable during the export process. It now accepts a `nameHint` argument and helps automatically detect invalid export configurations, requiring users to wrap methods needing export.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/CHANGELOG.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nEXPORTABLE\n```\n\n----------------------------------------\n\nTITLE: Visualizing Request Flow with Mermaid Sequence Diagram - Mermaid\nDESCRIPTION: This snippet provides a Mermaid sequence diagram that visualizes the request/response flow between a Node.js server framework, a custom Grafserv adaptor, and the Grafserv core. This diagram clarifies the request normalization process, handling for POST requests (including body fetching), and the response cycle. No software dependencies are required beyond the ability to interpret Mermaid syntax. The input is the Mermaid diagram syntax; the output is a descriptive chart useful for implementers designing their own Grafserv adaptors. Limitations include the diagram's inability to enforce or validate actual interface contractsâ€”it is informational documentation only.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/index.mdx#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n  participant Server as Server Framework\n  participant Adaptor as Grafserv Adaptor\n  participant Grafserv as Grafserv Core\n  Server->>Adaptor: Framework request object\n  Adaptor->>Grafserv: Normalized request digest<br/>(method, path, headers, etc)\n  opt For POST requests\n    Grafserv--)Adaptor: Get request body\n    Adaptor--)Server: Fetch body\n    Server--)Adaptor: Framework specific body<br/>(Buffer, JSON, text, etc)\n    Adaptor--)Grafserv: Normalized body\n  end\n  Grafserv-)Grafserv: Compute GraphQL Result\n  Grafserv->>Adaptor: Grafserv response<br/>(JSON, text, stream, etc)\n  Adaptor->>Server: Framework response\n```\n\n----------------------------------------\n\nTITLE: Initializing PgExecutor with Options (TypeScript)\nDESCRIPTION: This code snippet demonstrates the creation of a PgExecutor instance in TypeScript, passing a unique executor name and a context initialization callback. The context function returns an object that provides the withPgClient context and optionally pgSettings, used by resources to connect and interact with the PostgreSQL database. Dependencies include the PgExecutor class, a context getter function, and the object utility function. Inputs are an object with name and context properties; output is an executor instance ready for resource assignment. This pattern underlies the connection management for Graphile Crystal resources.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/resources.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst executor = new PgExecutor({\n  name: \"default\",\n  context() {\n    return object({\n      withPgClient: context().get(\"withPgClient\"),\n      // pgSettings: context().get(\"pgSettings\"),\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Comparing Lambda with LoadOne (Single Dependency) in TypeScript\nDESCRIPTION: This snippet shows an alternative implementation using `loadOne` for the index conversion task previously demonstrated with `lambda`. Unlike `lambda`, which processes items individually, `loadOne` provides a callback that receives an array (`allN`) of all input values (`$zeroBasedIndex`) at once. The callback then uses `map` to apply the transformation (`n + 1`) to each element. This approach facilitates batching and is generally preferred over `lambda` unless the operation is trivial.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $oneBasedIndex = loadOne($zeroBasedIndex, (allN) =>\n  allN.map((n) => n + 1),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Building PostGraphile GraphQL API Container - Dockerfile\nDESCRIPTION: This Dockerfile creates a minimal Node.js-based container image for running PostGraphile as a GraphQL API for PostgreSQL. It installs both the core PostGraphile package and the 'postgraphile-plugin-connection-filter' to enhance filtering capabilities. The container exposes port 5000 by default but is intended to be configurable; entrypoint launches PostGraphile listening on 0.0.0.0, making it accessible to linked services.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_12\n\nLANGUAGE: dockerfile\nCODE:\n```\n\"FROM node:alpine\\nLABEL description=\\\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\\\"\\n\\n# Install PostGraphile and PostGraphile connection filter plugin\\nRUN npm install -g postgraphile\\nRUN npm install -g postgraphile-plugin-connection-filter\\n\\nEXPOSE 5000\\nENTRYPOINT [\\\"postgraphile\\\", \\\"-n\\\", \\\"0.0.0.0\\\"]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Joining tamedevil Fragments with te.join to Build an Object\nDESCRIPTION: Demonstrates using `te.join` to concatenate an array of `te` fragments (representing key-value pairs) with a specified delimiter (\", \"). This allows for dynamically constructing parts of the code, such as the properties of an object literal.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nconst keysAndValues = [\"a\", \"b\", \"c\", \"d\"].map(\n  (n, i) => te`${te.safeKeyOrThrow(n)}: ${te.literal(i)}`,\n);\nconst obj = te.run`return { ${te.join(keysAndValues, \", \")} }`;\n\nassert.deepEqual(obj, { a: 0, b: 1, c: 2, d: 3 });\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Graphile Config Plugins and Presets in TypeScript\nDESCRIPTION: This snippet demonstrates the basic structure for defining Graphile Config plugins (`PluginA`, `PluginB`, `PluginC`) and presets (`Preset1`, `Preset2`) in TypeScript. It shows how presets can include plugins and extend other presets. The resulting plugin order `[PluginA, PluginB, PluginC]` is determined by preset resolution in this case, as no explicit `before` or `after` properties are used.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=graphile.config.ts\nimport type {} from \"graphile-config\";\n\nconst PluginA: GraphileConfig.Plugin = { name: \"PluginA\" };\nconst PluginB: GraphileConfig.Plugin = { name: \"PluginB\" };\nconst PluginC: GraphileConfig.Plugin = { name: \"PluginC\" };\n\nconst Preset1: GraphileConfig.Preset = {\n  plugins: [PluginA],\n};\n\nconst Preset2: GraphileConfig.Preset = {\n  extends: [Preset1],\n  plugins: [PluginB, PluginC],\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving Specific Attribute with pgInsertSingle.get() in TypeScript\nDESCRIPTION: Illustrates retrieving a specific attribute (`id`) from the row inserted by `pgInsertSingle` using the `.get()` method on the insertion plan (`$insertedUser`). This leverages the `INSERT ... RETURNING ...` SQL syntax internally to fetch the value after insertion. The result `$id` is a `PgClassExpressionStep` representing the requested attribute.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgInsertSingle.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $id = $insertedUser.get(\"id\");\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Anonymous Role in PostGraphile (TypeScript)\nDESCRIPTION: Shows how to configure PostGraphile (using TypeScript configuration) to default to the `forum_example_anonymous` role for incoming requests. This is achieved by setting the `pgSettings.role` property within the `grafast.context` function in the `graphile.config.mjs` file. This ensures unauthenticated users operate with limited privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\nexport default {\n  extends: [PostGraphileAmberPreset],\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-start\n        pgSettings: {\n          role: \"forum_example_anonymous\",\n        },\n        // highlight-end\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating pgCondition Child in EXISTS Mode with existsPlan - Graphile (JavaScript)\nDESCRIPTION: Applies the existsPlan method on a pgCondition, instantiating a child pgCondition that produces an SQL EXISTS(...) condition, useful for subquery-based filtering. The method accepts an options parameter for configuration. This facilitates complex SQL condition building, such as checking the existence of related rows, within Graphile's query planner.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.existsPlan(options)\n```\n\n----------------------------------------\n\nTITLE: Defining a Product Type in GraphQL Schema - GraphQL\nDESCRIPTION: This GraphQL type definition snippet demonstrates how PostGraphile translates a PostgreSQL product table into a Product GraphQL type. It includes fields for id (UUID), name (String), and priceInUsCents (Int), all required. It is intended as an output type for queries and is inferred via introspection from the SQL schema. Requires proper Postgres schema setup and PostGraphile/Graphile Engine for code generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_5\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Product {\n  id: UUID!\n  name: String!\n  priceInUsCents: Int!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating User and Login Roles in PostgreSQL - SQL\nDESCRIPTION: Shows two equivalent ways to create a new PostgreSQL role (admin) with login privileges, establishing it as a user. Dependencies: PostgreSQL 9.x or later. These commands both create a role named 'admin' that can authenticate with a password. No parameters required; just change 'admin' to desired username. Output is a new login-capable role.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/default-role.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate role admin login;\ncreate user admin;\n\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn - Shell\nDESCRIPTION: This shell command installs all Node.js dependencies for the project using the Yarn package manager. It must be run in the project root directory before starting development or building. Running this command sets up node_modules based on package.json and yarn.lock, preparing the project for local development, builds, or deployment steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn\n```\n```\n\n----------------------------------------\n\nTITLE: Querying GraphQL Schema Result from PostGraphile in JavaScript\nDESCRIPTION: Demonstrates how to asynchronously obtain the current GraphQL schema and resolved preset from a PostGraphile instance. By calling getSchemaResult(), the snippet ensures the freshest version of the schema is retrieved (important for watch mode). The function expects an imported pgl instance and returns an object with 'schema' and 'resolvedPreset'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { pgl } from \"./pgl.js\";\n\nconst { schema, resolvedPreset } = await pgl.getSchemaResult();\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with Random UUID Primary Key using pgcrypto - SQL\nDESCRIPTION: Illustrates how to create a 'person' table in PostgreSQL using the 'pgcrypto' extension to generate random UUID primary keys. The 'id' column defaults to 'gen_random_uuid()', offering strong randomness and collision resistance for identifiers. This approach requires PostgreSQL with the 'pgcrypto' extension enabled.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n\ncreate table forum_example.person (\n  id uuid primary key default gen_random_uuid(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an Inline GraphQL Query Using gql Template in JavaScript\nDESCRIPTION: Here an inline GraphQL query is defined within a JavaScript module using the gql template tag from graphile-utils. This can be used within JavaScript or TypeScript code for direct invocation of GraphQL requests. Dependencies include the 'graphile-utils' package. The query fetches up to 3 movies and returns their IDs and titles, returning a typed document object for further use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"graphile-utils\";\n\n// inside some function:\n\nconst GetMoviesDocument = gql`\n  query Query {\n    __typename\n    movies(first: 3) {\n      nodes {\n        id\n        title\n      }\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Integrating PostGraphile with Express and HTTP Server - JavaScript\nDESCRIPTION: This snippet demonstrates how to wire a PostGraphile instance with Express and Node's HTTP server, including error handling and server startup. Dependencies include 'express', 'node:http', 'postgraphile', and an existing PostGraphile instance. Takes the configured app/server instances as input, mounts the GraphQL server, and outputs a running server with GraphQL available on port 5678.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport { pgl } from \"./pgl.js\";\n\nconst serv = pgl.createServ(grafserv);\n\nconst app = express();\nconst server = createServer(app);\nserver.once(\"listening\", () => {\n  server.on(\"error\", (e) => void console.error(e));\n});\nserv.addTo(app, server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\nserver.listen(5678);\n\nconsole.log(\"Server listening at http://localhost:5678\");\n```\n\n----------------------------------------\n\nTITLE: Defining Smart Comment Syntax for PostGraphile - SQL\nDESCRIPTION: This snippet demonstrates the formatting for smart comments within PostgreSQL, showing the use of tags (e.g., @name, @isImportant, @jsonField) and regular description text. Tags can have payloads (string values) or be boolean, and all such tags must precede the non-tag description in the comment. PostGraphile will parse such comments accordingly, aggregating repeated tags into arrays. No dependencies besides PostgreSQL COMMENT statements; expected input is a comment block, output is the parsed tags and description.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n@name meta\\n@isImportant\\n@jsonField date timestamp\\n@jsonField name text\\n@jsonField episode enum ONE=1 TWO=2\\nThis field has a load of arbitrary tags.\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Database using Bash\nDESCRIPTION: Creates a new PostgreSQL database named 'mydb' using the `createdb` command-line utility. This utility is typically installed alongside the PostgreSQL server or client tools. Requires appropriate permissions within the PostgreSQL server to create databases.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ createdb mydb\n```\n\n----------------------------------------\n\nTITLE: Creating a SQL Function to Retrieve Custom pgSettings (SQL)\nDESCRIPTION: This SQL snippet defines a function get_x_something that retrieves the value of a custom session setting (myapp.headers.x_something) provided from the Node.js/PostGraphile context. It uses current_setting to access the value and nullif to ensure a NULL return if the setting is missing or empty. Prerequisites include a PostgreSQL database with Graphile/PostGraphile integration. The function returns text and is intended to be used in database queries or security policies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_12\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function get_x_something() returns text as $$\n  /* highlight-next-line */\n  select nullif(current_setting('myapp.headers.x_something', true), '')::text;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Configuring docker-compose to Use a Custom PostGraphile Plugin in YAML\nDESCRIPTION: Shows how to enhance the docker-compose configuration to append the custom plugin and connection filter to the GraphQL service. The graphql container receives connection and port parameters, the database URL, target schema, and the plugin list. Prerequisites: the custom plugin must be installed and available globally before running the service.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_22\n\nLANGUAGE: yml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db:\n        [...]\n\n    graphql:\n        [...]\n        command:\n            [\n                \"--connection\",\n                \"${DATABASE_URL}\",\n                \"--port\",\n                \"5433\",\n                \"--schema\",\n                \"public\",\n                \"--append-plugins\",\n                \"postgraphile-plugin-connection-filter,custom-plugin\",\n            ]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic Singular Reference Using @ref and @refVia in PostGraphile (SQL)\nDESCRIPTION: This SQL snippet provides an example of creating a polymorphic singular reference using a @ref smart tag with multiple @refVia entries in a table comment for PostGraphile. The @ref tag sets the GraphQL field name ('author'), the polymorphic type ('to:PersonOrOrganization'), and singular nature; each @refVia offers a route to either persons or organizations via matching foreign key columns. Dependencies: tables (people, organizations) and corresponding columns (person_id, organization_id) correctly referenced; PostGraphile. Produces a single 'author' field in GraphQL, resolving to either type depending on which foreign key is populated.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/refs.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:(person_id)->people(person_id)\n  @refVia author via:(organization_id)->organizations(organization_id)\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Loading Default Graphile Engine Plugins in JavaScript\nDESCRIPTION: Demonstrates initializing the Graphile schema build process by importing `buildSchema` and `defaultPlugins` from `graphile-build`. It spreads the default plugins into an array, optionally allowing for more plugins to be added, builds the schema asynchronously, and then prints the generated GraphQL schema using `printSchema` from `graphql/utilities`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugins.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst { buildSchema, defaultPlugins } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nconst plugins = [\n  ...defaultPlugins,\n  // Add more plugins here!\n];\n\nbuildSchema(plugins).then((schema) => {\n  console.log(printSchema(schema));\n});\n```\n\n----------------------------------------\n\nTITLE: Wrapping SETOF Composite Computed Columns with Array for Filtering (SQL)\nDESCRIPTION: This block demonstrates wrapping a non-scalar SETOF function by a new function returning an array, allowing array-based filtering using Graphile's connection-filter. The wrapper function leverages ARRAY_AGG and is annotated as @sortable to be filterable in GraphQL. The surrounding context notes that this is necessary when a function returns multiple composite values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_20\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar setof function\nCREATE OR REPLACE FUNCTION user_objects(user user) RETURNS SETOF object AS $$\nSELECT * FROM object where owner_id = user.id; -- one user, many objects\n$$ language SQL STABLE;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\nCREATE OR REPLACE FUNCTION user_object_fields(user user) RETURNS varchar[] AS $$\nSELECT ARRAY_AGG((user_objects(user)).field);\n$$ language SQL STABLE;\n\n-- don't forget the comments...\ncomment on function user_object_fields() is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Non-Login Roles and Users - SQL\nDESCRIPTION: These SQL statements show how to create a role that cannot log in, either by omitting LOGIN ('create role editor;') or explicitly setting NOLOGIN ('create user editor nologin;'). Both approaches result in a role with no login capability. Dependencies: PostgreSQL. Parameters: Role/user name ('editor'), NOLOGIN property. Input: SQL commands. Output: Role/user created that cannot authenticate directly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/default-role.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate role editor;\ncreate user editor nologin;\n```\n\n----------------------------------------\n\nTITLE: Applying Smart Tags for Relational Polymorphism - SQL\nDESCRIPTION: Adds a smart tag comment to the parent table indicating interface mode 'relational' and mapping each polymorphic type value to a reference table. This aids PostGraphile in resolving the correct child table to fulfill relational polymorphism at query time. Prerequisites include all child tables and parent created beforehand, and the type discriminator column must exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.relational_items is $$\n  @interface mode:relational type:type\n  @type TOPIC references:relational_topics\n  @type POST references:relational_posts\n  @type DIVIDER references:relational_dividers\n  @type CHECKLIST references:relational_checklists\n  @type CHECKLIST_ITEM references:relational_checklist_items\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Evolution of Plan Resolver Hooking (TypeScript)\nDESCRIPTION: The migration away from `applyPlan`/`inputPlan` initially involved a `context.addToPlanResolver` hook (now obsolete). This approach was later replaced by the new `inputApply()` step. Field arguments retain `applyPlan`, but input object fields do not.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\napplyPlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninputPlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\ncontext.addToPlanResolver // Obsolete hook\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninputApply() // New step for input processing\n```\n\n----------------------------------------\n\nTITLE: Creating Node.js Server with PostGraphile Middleware in server.js\nDESCRIPTION: Implements a simple Node.js HTTP server in `graphql/src/server.js` using the built-in `http` module. It integrates the `postgraphile` library as middleware, connecting to the database specified by the `DATABASE_URL` environment variable and exposing the 'public' schema. Key PostGraphile options enabled include `watchPg` for schema change detection, `graphiql` for the interactive API explorer, and `enhanceGraphiql`. The server listens on the port defined by the `PORT` environment variable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst http = require(\"http\");\nconst { postgraphile } = require(\"postgraphile\");\n\nhttp\n  .createServer(\n    postgraphile(process.env.DATABASE_URL, \"public\", {\n      watchPg: true,\n      graphiql: true,\n      enhanceGraphiql: true,\n    }),\n  )\n  .listen(process.env.PORT);\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client Cache with nodeId for Object Identification (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to set up Apollo Client with a custom InMemoryCache strategy that uses the 'nodeId' property from GraphQL responses as a globally unique cache key. It imports 'ApolloClient', 'HttpLink', and 'InMemoryCache', then configures the cache with the 'dataIdFromObject' function, returning the object's 'nodeId' or null. Dependencies include 'apollo-client', 'apollo-link-http', and 'apollo-cache-inmemory'. Expected input is GraphQL response objects containing a 'nodeId' field. The client can then uniquely cache and identify GraphQL objects. This works best with GraphQL APIs adhering to the Global Object Identification spec.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/node-id.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ApolloClient from \\\"apollo-client\\\";\nimport { HttpLink } from \\\"apollo-link-http\\\";\nimport { InMemoryCache } from \\\"apollo-cache-inmemory\\\";\n\nconst cache = new InMemoryCache({\n  dataIdFromObject: (object) => object.nodeId || null,\n});\n\nexport const client = new ApolloClient({\n  link: new HttpLink(),\n  cache,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Postgres Role from JWT - SQL\nDESCRIPTION: These SQL commands illustrate how PostGraphile changes the transaction role and sets the role claim when a 'role' property is present in the JWT. This mechanism ties JWT-based authentication to Postgres' powerful role management for granular access control. Requires the roles to be pre-defined in the database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_31\n\nLANGUAGE: sql\nCODE:\n```\nset local role to 'forum_example_person';\\nset local jwt.claims.role to 'forum_example_person';\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization-Scoped Views in PostgreSQL (SQL)\nDESCRIPTION: This snippet illustrates how to use PostgreSQL views with security features to enforce authorization at the database level, restricting access to sensitive data based on the current user. It defines tables for person and personal data, and creates a view with 'security_barrier' and 'check_option' options to only select rows matching the current user's ID. Dependencies include the 'current_user_id()' function for row-level security and existing tables. Inputs are DDL and DML for table/view creation, outputs are views that enforce security checks in SQL and expose filtered data to GraphQL. Limitations include requirement for the supporting user ID function, and proper smart tags or configuration in PostGraphile to integrate the view securely.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/views.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.person (\n  id serial PRIMARY KEY\n);\n\nCREATE TABLE app_public.personal_data (\n  id serial PRIMARY KEY,\n  secret1 text,\n  secret2 int,\n  person_id references app_public.person (id)\n);\n\nCREATE VIEW personal_data_view\n  WITH (security_barrier, check_option = 'cascaded')\n  AS\n    SELECT personal_data.*\n    FROM app_public.personal_data personal_data\n    WHERE person_id = current_user_id()\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile with Database Service and Server Port in TypeScript\nDESCRIPTION: This TypeScript snippet provides a simple example of a `graphile.config.ts` file. It extends the Amber preset, configures the Grafserv server to listen on port 5678, and sets up a PostgreSQL service connection using `makePgService` with a specified connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=\"graphile.config.ts\"\nimport \"postgraphile\"; // To import the TypeScript types\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n  grafserv: { port: 5678 },\n  pgServices: [makePgService({ connectionString: \"postgres:///my_db\" })],\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Example Custom Query Functions in PostgreSQL\nDESCRIPTION: Demonstrates two basic PostgreSQL functions intended to be exposed as custom queries by PostGraphile. `my_function` returns an integer and is marked `IMMUTABLE`. `my_other_function` returns a row of type `my_table` and is marked `STABLE`. Both accept two integer arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-queries.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ \\u2026 $$ LANGUAGE sql IMMUTABLE;\nCREATE FUNCTION my_other_function(a int, b int) RETURNS my_table AS $$ \\u2026 $$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Helper Function to Extract Current User ID from JWT Claims in PostgreSQL - SQL\nDESCRIPTION: Implements a SQL helper function 'current_user_id' that returns the integer user ID from the session's 'jwt.claims.user_id' config variable, using 'current_setting'. Requires PostgreSQL 9.6+, as 'current_setting' with 'missing_ok' is used. Output is the current user's ID as integer, or null if absent.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user_id() returns integer as $$\n  select nullif(current_setting('jwt.claims.user_id', true), '')::integer;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Querying with IO Equivalence Using loadOne in Graphile (TypeScript)\nDESCRIPTION: This TypeScript snippet updates the previous plan resolver to use the ioEquivalence argument ('id') in loadOne. This improvement allows the system to optimize data fetching by recognizing the equivalence between the user ID input and the resulting record's 'id' field, thus enabling parallel rather than chained data fetching. The dependencies are similar, relying on Graphile plan steps and the optimized callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst plans = {\n  Query: {\n    currentUser() {\n      const $currentUserId = context().get(\"userId\");\n      return loadOne($currentUserId, 'id', batchGetUserById);\n    },\n  },\n  User: {\n    friends($user) {\n      const $userId = $user.get(\"id\");\n      return loadMany($userId, batchGetFriendsByUserId);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema for Forum Example (SQL)\nDESCRIPTION: SQL script (`00-database.sql`) designed to be executed during PostgreSQL container initialization. It connects to the specified database (`forum_example`), then creates the `public.user` and `public.post` tables with appropriate columns, types, primary keys, and a foreign key constraint linking posts to users. Comments are included to describe the purpose of each table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\n\n/*Create user table in public schema*/\nCREATE TABLE public.user (\n    id SERIAL PRIMARY KEY,\n    username TEXT,\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCOMMENT ON TABLE public.user IS\n'Forum users.';\n\n/*Create post table in public schema*/\nCREATE TABLE public.post (\n    id SERIAL PRIMARY KEY,\n    title TEXT,\n    body TEXT,\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    author_id INTEGER NOT NULL REFERENCES public.user(id)\n);\n\nCOMMENT ON TABLE public.post IS\n'Forum posts written by a user.'\n```\n\n----------------------------------------\n\nTITLE: Sorting GraphQL Object Type Fields Alphabetically - Graphile Plugin - TypeScript\nDESCRIPTION: This TypeScript snippet defines a GraphileConfig.Plugin named \"SortFieldsAlphabetically\" that sorts fields of GraphQL object types alphabetically. It is to be added last to the plugin list (or declared with proper 'after' dependencies) to ensure other plugins have registered their fields before sorting. The 'GraphQLObjectType_fields' hook sorts the field entries by key using locale-aware comparison. Key inputs include the 'fields' object representing all GraphQL fields; output is a reordered object with fields alphabetized. Prerequisites are the GraphileConfig.Plugin framework and TypeScript support.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/versioning-policy.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Make sure this is the last plugin to be added, and if necessary add\n// `after: [...]` to it containing a list of the names of all the plugins that\n// add fields.\nconst SortFieldsAlphabetically: GraphileConfig.Plugin = {\n  name: \"SortFieldsAlphabetically\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields) {\n        const entries = Object.entries(fields);\n        entries.sort(([a], [z]) => a.localeCompare(z, \"en-US\"));\n        return Object.fromEntries(entries);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Comparing Array.reduce Performance Patterns in JavaScript\nDESCRIPTION: Illustrates three methods for creating an object from an array in JavaScript using `Array.reduce` and a `for...of` loop, highlighting performance differences. The first uses object spread (`...`) which is slower due to creating new objects. The second mutates the accumulator object within `reduce`, which is faster. The third uses a standard `for...of` loop, which is typically the fastest and avoids the overhead of the `reduce` callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n// Slow:\nconst result = [\"a\", \"b\", \"c\"].reduce(\n  (memo, letter) => ({ ...memo, [letter]: true }),\n  {},\n);\n\n// Faster:\nconst result = [\"a\", \"b\", \"c\"].reduce((memo, letter) => {\n  memo[letter] = true;\n  return memo;\n}, {});\n\n// Fastest:\nconst result = {};\nfor (const letter of [\"a\", \"b\", \"c\"]) {\n  result[letter] = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Composing and Extending GraphileConfig Presets for Library Usage (TypeScript)\nDESCRIPTION: Shows how to compose and extend GraphileConfig presets by importing and including default presets (e.g., from graphile-worker) and introducing additional options in specific scopes. TypeScript enforces type-safety via the GraphileConfig.Preset type annotation. The preset uses an \\\"extends\\\" array for composition and a \\\"worker\\\" scope for options (such as connectionString). Requires the library providing the base preset as a dependency. Outputs a fully resolved preset via \\\"export default\\\".\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerPreset } from \"graphile-worker\";\n\nconst preset: GraphileConfig.Preset = {\n  extends: [WorkerPreset],\n  worker: {\n    connectionString: \"postgres:///my_db\",\n  },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Instance with Preset (JavaScript)\nDESCRIPTION: This snippet demonstrates how to initialize a PostGraphile instance using a preset configuration file. The 'preset' is imported locally and passed to the 'postgraphile' factory, exporting the initialized instance ('pgl') for reuse elsewhere. Dependencies include the 'postgraphile' package and a valid configuration file. The output is a PostGraphile instance ready to set up servers or fetch schemas.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-library.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport preset from \"./graphile.config.js\";\nimport { postgraphile } from \"postgraphile\";\n\n// Our PostGraphile instance:\nexport const pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Disabling NodePlugin in PostGraphile Configuration (JavaScript)\nDESCRIPTION: This JavaScript module disables the default NodePlugin from PostGraphile when exporting configuration, effectively removing global object identifier support from the GraphQL schema. It should be placed in `graphile.config.mjs` and is applicable when working with the `postgraphile/presets/amber` preset. The 'disablePlugins' array can include additional plugins as needed, but here it specifically targets the 'NodePlugin'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/node-id.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  // ...\n  // highlight-next-line\n  disablePlugins: [\"NodePlugin\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Field Function for Person's Latest Post (SQL)\nDESCRIPTION: Defines a PostgreSQL function `person_latest_post` in the `forum_example` schema. It accepts a `forum_example.person` row and returns the entire row (`forum_example.post`) of the most recent post created by that person, determined by ordering by `created_at` descending and limiting to 1. Marked `stable`, PostGraphile treats this as a computed field returning a related object. A comment describes its purpose.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_latest_post(person forum_example.person) returns forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where post.author_id = person.id\n  order by created_at desc\n  limit 1\n$$ language sql stable;\n\ncomment on function forum_example.person_latest_post(forum_example.person) is 'Getâ€™s the latest post written by the person.';\n```\n\n----------------------------------------\n\nTITLE: Creating the Forum Post Table (SQL)\nDESCRIPTION: This SQL code defines the `forum_example.post` table. It includes columns for an ID, author reference (foreign key to `person`), headline, body, topic (using the custom `post_topic` enum), and creation timestamp. It also adds descriptive comments to the table and its columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.post (\n  id               serial primary key,\n  author_id        integer not null references forum_example.person(id),\n  headline         text not null check (char_length(headline) < 280),\n  body             text,\n  topic            forum_example.post_topic,\n  created_at       timestamp default now()\n);\n\ncomment on table forum_example.post is 'A forum post written by a user.';\ncomment on column forum_example.post.id is 'The primary key for the post.';\ncomment on column forum_example.post.headline is 'The title written by the user.';\ncomment on column forum_example.post.author_id is 'The id of the author user.';\ncomment on column forum_example.post.topic is 'The topic this has been posted in.';\ncomment on column forum_example.post.body is 'The main body text of our post.';\ncomment on column forum_example.post.created_at is 'The time this post was created.';\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Server Plugin for Origin-Specific CORS in JavaScript\nDESCRIPTION: This JavaScript function `makeAllowedOriginTweak` acts as a factory to create a PostGraphile server plugin. The plugin hooks into the `postgraphile:http:handler` event to inject specific CORS headers into the HTTP response, restricting access to the specified `origin`. It sets headers like `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, and `Access-Control-Expose-Headers` to enforce the desired CORS policy.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\n/**\n * This server plugin injects CORS headers to allow requests only from a specific origin.\n */\n\nfunction makeAllowedOriginTweak(origin) {\n  return {\n    [\"postgraphile:http:handler\"](req, { res }) {\n      res.setHeader(\"Access-Control-Allow-Origin\", origin);\n      res.setHeader(\"Access-Control-Allow-Methods\", \"HEAD, GET, POST\");\n      res.setHeader(\n        \"Access-Control-Allow-Headers\",\n        [\n          \"Origin\",\n          \"X-Requested-With\",\n          // Used by `express-graphql` to determine whether to expose the GraphiQL\n          // interface (`text/html`) or not.\n          \"Accept\",\n          // Used by PostGraphile for auth purposes.\n          \"Authorization\",\n          // Used by GraphQL Playground and other Apollo-enabled servers\n          \"X-Apollo-Tracing\",\n          // The `Content-*` headers are used when making requests with a body,\n          // like in a POST request.\n          \"Content-Type\",\n          \"Content-Length\",\n          // For our 'Explain' feature\n          \"X-PostGraphile-Explain\",\n        ].join(\", \"),\n      );\n      res.setHeader(\n        \"Access-Control-Expose-Headers\",\n        [\"X-GraphQL-Event-Stream\"].join(\", \"),\n      );\n      return req;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing 'ID' and 'ROW_ID' Identifiers in Inflection Changes\nDESCRIPTION: References specific identifiers 'ID' and 'ROW_ID' which are subject to naming changes in the Amber preset due to inflection modifications. This highlights potential schema differences users might encounter after updating.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`ID`\n```\n\nLANGUAGE: markdown\nCODE:\n```\n`ROW_ID`\n```\n\n----------------------------------------\n\nTITLE: Defining Users Table Structure - PostgreSQL - SQL\nDESCRIPTION: This snippet creates a users table with fields for id, username, first name, last name, and timestamp columns for creation and updates. Dependencies include PostgreSQL with the citext extension enabled for case-insensitive text, and default values and constraints for key columns. Key parameters define column types, uniqueness, and validation via regex on usernames. Inputs are standard SQL DDL, and the output is a table suitable for PostGraphile, with constraints offering robust schema safety.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/required-knowledge.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table users (\n  id serial primary key,\n  username citext not null unique check(username ~ '^[a-z][a-z0-9]+$'),\n  first_name text,\n  last_name text,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Updating a Topic with GraphQL Mutation (GraphQL)\nDESCRIPTION: Executes a GraphQL mutation to update the title of an existing topic by specifying the topic's id and a patch object. Relies on a PostgreSQL 'app_public.topics' table as defined below and utilizes the simplify inflector plugin for consistent field naming. The result includes the updated topic properties. Prerequisites: the 'topics' table exists as shown, and the API is configured to allow updates through GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  updateTopic(input: { id: 1, patch: { title: \"My (edited) title\" } }) {\n    topic {\n      nodeId\n      id\n      title\n      body\n    }\n  }\n}\n```\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.topics (\n  id serial primary key,\n  forum_id integer NOT NULL references app_public.forums on delete cascade,\n  title text NOT NULL,\n  body text DEFAULT ''::text NOT NULL\n);\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"updateTopic\": {\n    \"topic\": {\n      \"nodeId\": \"WyJ0b3BpY3MiLDFd\",\n      \"id\": 1,\n      \"title\": \"My (edited) title\",\n      \"body\": \"500-1500 requests per second on a single server is pretty awesome.\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL statement_timeout per Connection in PostGraphile (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates a more efficient method for setting `statement_timeout` by configuring it once per database connection rather than per transaction, using the `graphile.config.mjs` file. It involves creating a custom `pg.Pool`, using the `pool.on('connect', ...)` event to execute `SET statement_timeout TO 3000` for each new client, and then providing this configured pool to PostGraphile using `makePgService` within the `pgServices` configuration array. This reduces overhead compared to setting the timeout per transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/production.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Pool } from \"pg\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** does nothing */\nfunction noop() {}\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\npool.on(\"error\", noop);\npool.on(\"connect\", (client) => {\n  client.on(\"error\", noop);\n  // highlight-next-line\n  client.query(\"SET statement_timeout TO 3000\");\n});\n\nexport default {\n  // ...\n  pgServices: [\n    makePgService({\n      pool,\n      schemas: [\"app_public\"],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Setting up Grafserv with Hono in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to initialize and integrate a Grafserv instance with the Hono web framework. It imports `grafserv` from `grafserv/hono`, `Hono` and `serve` from the Hono ecosystem, along with a project-specific schema and preset. A Hono app (`app`) and a Grafserv instance (`serv`) are created. The code then attempts to mount the Grafserv request handler onto an object named `server` using `serv.addTo(server)`. Finally, the server is started using `serve(app)`, leveraging Hono's Node.js adapter. Error handling is included for the mounting process.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/hono.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { grafserv } from \"grafserv/hono\";\nimport preset from \"./graphile.config.mjs\";\nimport schema from \"./schema.mjs\";\n\nimport { Hono } from \"hono\";\nimport { serve } from \"@hono/node-server\";\n\n// Create a Node HTTP server\nconst app = new Hono();\n\n// Create a Grafserv instance\n// the second argument is an optional websocket upgrade handler\n// see https://hono.dev/docs/helpers/websocket\nconst serv = grafserv({ schema, preset });\n\n// Mount the request handler into a new HTTP server\nserv.addTo(server).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\n// Start the server with the chosen Hono adapter - here Node.js\nserve(app);\n```\n\n----------------------------------------\n\nTITLE: Defining a Grafast Plan Resolver with makeGrafastSchema in TypeScript\nDESCRIPTION: Illustrates how to specify a Grafast plan resolver for a field ('meaningOfLife' on 'Query') using the `makeGrafastSchema` helper function. The plan resolver is provided within the `plans` configuration object, nested under the type name and field name.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-resolvers.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeGrafastSchema, constant } from \"grafast\";\n\nexport const schema = makeGrafastSchema({\n  typeDefs: /* GraphQL */ `\n    type Query {\n      meaningOfLife: Int\n    }\n  `,\n  plans: {\n    Query: {\n      meaningOfLife() {\n        return constant(42);\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Array Wrapper for Filtering SETOF Non-Scalar Computed Columns\nDESCRIPTION: Illustrates handling computed columns returning `SETOF` composite types for filtering. It defines `user_objects` returning `SETOF object`, and a wrapper `user_object_fields` that aggregates the `field` attribute from each object into a `varchar[]` array using `ARRAY_AGG`. Annotating this wrapper with `@sortable` (or more commonly `@filterable` in conjunction with plugins like `postgraphile-plugin-connection-filter`) allows filtering based on the array content in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_35\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar setof function\nCREATE OR REPLACE FUNCTION user_objects(user user) RETURNS SETOF object AS $$\nSELECT * FROM object where owner_id = user.id; -- one user, many objects\n$$ language SQL STABLE;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\nCREATE OR REPLACE FUNCTION user_object_fields(user user) RETURNS varchar[] AS $$\nSELECT ARRAY_AGG((user_objects(user)).field);\n$$ language SQL STABLE;\n\n-- don't forget the comments...\ncomment on function user_object_fields() is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL `statement_timeout` via `pg.Pool` Connection Event in JavaScript\nDESCRIPTION: Demonstrates setting the PostgreSQL `statement_timeout` on a per-connection basis by attaching an event listener to the `connect` event of a `pg.Pool` instance. This ensures every new connection used by PostGraphile has the timeout set (3000ms in this case). Requires the `pg` (node-postgres) and `postgraphile` libraries. The pool instance is then passed to PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/production.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst { Pool } = require('pg');\n\nconst pool = new Pool();\npool.on('connect', (client) => {\n  client.query('SET statement_timeout TO 3000')\n});\n\n// ...\napp.use(postgraphile(pool, \"public\", { ... }));\n// ...\n```\n\n----------------------------------------\n\nTITLE: Running and Managing Containers with Docker Compose - Shell/Bash\nDESCRIPTION: This shell snippet covers starting containers from the Docker Compose configuration, including options for running all services, only select ones, and background (daemon) mode. It illustrates how to run the entire stack together, or only the individual database or GraphQL containers. Output and log access depend on whether you run in the foreground or background mode.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n\"# Run containers for all services in docker-compose.yml\\n$ docker-compose up\\n\\n# Run containers as daemon (in background)\\n$ docker-compose up -d\\n\\n# Run only the database container as daemon\\n$ docker-compose up -d db\\n\\n# Run only the GraphQL container as daemon\\n$ docker-compose up -d graphql\\n\"\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency-Free Lambda Step in TypeScript\nDESCRIPTION: This snippet presents the TypeScript function signature for the `lambda` step when the callback requires no input from other steps. The first argument `$input` is explicitly `null` or `undefined`. It takes a callback function that accepts no arguments and returns a value or a Promise, along with the optional `isSyncAndSafe` flag for optimization under specific conditions. It returns an `ExecutableStep` representing the result of the callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction lambda<R>(\n  $input: null | undefined,\n  callback: () => R | Promise<R>,\n  isSyncAndSafe = false,\n): ExecutableStep<R>;\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing GraphQL Context with Gra*fast* `context()` in TypeScript\nDESCRIPTION: Demonstrates retrieving a value (`userId`) stored in the GraphQL context within a Gra*fast* plan resolver using the `context()` step. This step provides access to context data available during query execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst $userId = context().get(\"userId\");\n```\n\n----------------------------------------\n\nTITLE: Ensuring finalize() Calls super.finalize() in Grafast Step (TypeScript)\nDESCRIPTION: This example demonstrates the required call to super.finalize() at the end of a Step's finalize method in Grafast. Omitting this call can lead to incorrect execution preparation. Any custom pre-finalization logic should be placed before the super.finalize() call. The method expects no arguments and outputs void.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nfinalize() {\n  // ... your code here ...\n\n  super.finalize();\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting PostGraphile under a Subpath with External Proxy in Express (JavaScript)\nDESCRIPTION: Demonstrates configuring PostGraphile middleware in an Express application to run under a specific subpath (`/path/to`) while also accounting for an external proxy routing requests to `/myproxypath`. The `externalUrlBase` option is crucial for ensuring PostGraphile generates correct URLs for its assets and endpoints (like GraphiQL pointing to the correct GraphQL endpoint) in this complex setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\n// Assuming you combine both Express subpath AND an external\n// proxy which mounts your express app at `/myproxypath`, you\n// should provide options like this:\napp.use(\n  \"/path/to\",\n  postgraphile(db, schemas, {\n    externalUrlBase: \"/myproxypath/path/to\",\n    graphqlRoute: \"/graphql\",\n    graphiql: true,\n    graphiqlRoute: \"/graphiql\",\n  }),\n);\n// Then you can load GraphiQL at `/myproxypath/path/to/graphiql`\n// and it will know to connect to GraphQL at\n// `/myproxypath/path/to/graphql`\n```\n\n----------------------------------------\n\nTITLE: package.json Using Subpath Imports for graphile-build* (json)\nDESCRIPTION: This code block gives a minimal package.json devDependencies setup after refactoring imports to use subpaths. Instead of listing graphile-build and graphile-build-pg, only postgraphile and connection-filter are listed because code imports submodules via postgraphile/graphile-build, reducing risk of version conflict. No input files required; output is updated package.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"devDependencies\\\": {\\n    \\\"postgraphile\\\": \\\"^5.0.0-beta.32\\\",\\n    \\\"postgraphile-plugin-connection-filter\\\": \\\"^3.0.0-beta.5\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Plugin to Dynamically Customize Ruru HTML Meta Tags (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a GraphileConfig.Plugin that injects custom meta tags into the Ruru HTML output on a per-request basis. The ruruHTMLParts hook can access the current request to adjust metaTags or other HTML elements dynamically. Dependencies include 'graphile-config' and Ruru integration. Inputs include the info, parts, and extra (with HTTP request details); changes output HTML per user/session. Suitable for advanced customization but requires understanding of plugin registration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv/CHANGELOG.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst RuruMetaPlugin: GraphileConfig.Plugin = {\n  name: \"RuruMetaPlugin\",\n  version: \"0.0.0\",\n  grafserv: {\n    hooks: {\n      ruruHTMLParts(_info, parts, extra) {\n        // extra.request gives you access to request details, so you can customize `parts` for the user\n\n        parts.metaTags += `<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />`;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with UUID v1mc PK (SQL)\nDESCRIPTION: This SQL snippet presents an alternative method for creating the `person` table, using a UUID (version 1mc) as the primary key instead of a serial integer. It first ensures the `uuid-ossp` extension is enabled and then defines the `id` column as type `uuid` with a default value generated by `uuid_generate_v1mc()`. The rest of the table structure (`...`) is assumed to be similar to the serial ID example.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"uuid-ossp\";\n\ncreate table forum_example.person (\n  id uuid primary key default uuid_generate_v1mc(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Posts and Users with Fragments and Deep Nesting - GraphQL\nDESCRIPTION: Requesting all posts including author information (via fragment), comments, each comment's author, recent comments, and each recent comment's related post and author. The UserDetails fragment enables field reuse. This query demonstrates PostGraphile's single SQL statement compilation for arbitrarily deep trees using look-ahead capabilities and is a good reference for combining fragments and nested relationships. Outputs a multi-level data structure involving posts, users, comments, and author bios.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/performance.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPosts {\n    edges {\n      node {\n        id\n        title\n        author: userByAuthorId {\n          ...UserDetails\n        }\n        comments {\n          text\n          author: userByAuthorId {\n            ...UserDetails\n            recentComments {\n              date\n              post: postByPostId {\n                title\n                author {\n                  ...UserDetails\n                }\n              }\n              text\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfragment UserDetails on User {\n  id\n  username\n  bio: bioByUserId {\n    preamble\n    location\n    description\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Sponsorship Call-to-Action Buttons (JSX)\nDESCRIPTION: Uses the custom `SponsorButtons` React component to display interactive elements, presumably buttons or links. This component likely encapsulates the logic and presentation for directing users to platforms where they can sponsor Graphile projects (e.g., GitHub Sponsors, Open Collective).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/sponsor.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<SponsorButtons></SponsorButtons>\n```\n\n----------------------------------------\n\nTITLE: Disabling Global Object Identifier Plugin in PostGraphile (Shell)\nDESCRIPTION: This shell instruction shows how to start PostGraphile CLI with the GraphQL NodePlugin disabled using the '--skip-plugins graphile-build:NodePlugin' flag. Doing this disables the global object identifier ('nodeId') feature across the API. This may be necessary if you prefer to handle unique identifiers differently or do not wish to expose a unified global identifier. Ensure your client is able to uniquely identify cache objects via other means if you use this option.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/node-id.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npostgraphile --skip-plugins graphile-build:NodePlugin ...\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine for PostGraphile Express App Deployment (YAML)\nDESCRIPTION: Defines the GCP App Engine flexible environment configuration (`app.yaml`) for deploying PostGraphile as part of an Express application. It specifies the Node.js runtime and sets essential PostgreSQL connection details (user, host, password, database) as environment variables. Crucially, it configures the Cloud SQL instance connection string via `beta_settings` for direct Unix socket access (recommended for library usage) and enabling WebSocket support needed for PostGraphile subscriptions/live queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nruntime: nodejs\nenv: flex\n\nenv_variables:\n  PGUSER: \"your-database-user\"\n  PGHOST: \"/cloudsql/your-cloudsql-instance-connection-string\"\n  PGPASSWORD: \"your-password\"\n  PGDATABASE: \"your-database-name\"\n\nbeta_settings:\n  cloud_sql_instances: your-cloudsql-instance-connection-string\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local Scope of SET in PostgreSQL Transactions (SQL)\nDESCRIPTION: This SQL code block provides an example of using a transaction to demonstrate the local scoping of configuration parameters set with 'SET LOCAL'. The 'begin;' statement starts a transaction, and a JWT-related claim is set. After 'commit;', the claim is no longer accessible, illustrating the temporary effect of 'SET LOCAL' within transactions. Operations rely on PostgreSQL session and transaction semantics.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nbegin;\nset local jwt.claims.user_id to 2;\n\n-- Has access to `jwt.claims.user_id`\ncommit;\n\n-- Does not have access to `jwt.claims.user_id`\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for Database Service - YAML\nDESCRIPTION: Defines 'docker-compose.yml' file that orchestrates the database service with build configuration, environment, persistent storage, network definitions, and port mappings. Requires Docker Compose and correctly structured directory/files. Input: configuration YAML. Output: Multi-container Docker environment for forum database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_10\n\nLANGUAGE: yml\nCODE:\n```\nversion: \\\"3.3\\\"\\nservices:\\n  db:\\n    container_name: forum-example-db\\n    restart: always\\n    image: forum-example-db\\n    build:\\n      context: ./db\\n    volumes:\\n      - db:/var/lib/postgresql/data\\n    env_file:\\n      - ./.env\\n    networks:\\n      - network\\n    ports:\\n      - 5432:5432\\n\\nnetworks:\\n  network:\\n\\nvolumes:\\n  db:\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with Specific Role (Bash)\nDESCRIPTION: This command starts the PostGraphile server, connecting to the PostgreSQL database `mydb` on localhost using the `forum_example_postgraphile` role and its password `xyz`. The `-c` flag specifies the connection string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://forum_example_postgraphile:xyz@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for GraphQL Container in .env\nDESCRIPTION: Adds `DATABASE_URL` and `PORT` variables to the `.env` file for the GraphQL container. `DATABASE_URL` specifies the connection string (format: `postgres://<user>:<password>@db:5432/<db_name>`) for PostGraphile to connect to the PostgreSQL container ('db'), and `PORT` defines the port the PostGraphile service will listen on.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_1\n\nLANGUAGE: dotenv\nCODE:\n```\n[...]\n# GRAPHQL\n# Parameters used by graphql container\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\nPORT=5433\n```\n\n----------------------------------------\n\nTITLE: Replacing a Built-in Inflector with a Graphile Plugin (TypeScript)\nDESCRIPTION: This TypeScript code defines a Graphile plugin named `ReplaceInflectorPlugin` that overrides the default `builtin` inflector. The replacement function checks if the input text is 'Query' and returns 'RootQuery' instead, effectively renaming the root query type. For other inputs, it calls the original `previous` inflector. Type imports are included for TypeScript development.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Import types for TypeScript, no need in JS\nimport \"graphile-config\";\nimport \"graphile-build\";\nimport \"graphile-build-pg\";\n\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\n  // Unique name for your plugin:\n  name: \"ReplaceInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      builtin(\n        // The previous version of this inflector, the one you're replacing\n        previous,\n\n        // The resolved configuration\n        preset,\n\n        // Everything from the 3rd paramater onward are the arguments to this inflector\n        text,\n      ) {\n        if (name === \"Query\") return \"RootQuery\";\n        return previous(text);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Styled Container Div using JSX and CSS Modules\nDESCRIPTION: Defines a `div` element using JSX syntax within an MDX file. It applies CSS classes dynamically using the imported `styles` object from CSS Modules (`styles.mainSectionInstructionContainer`, `styles.instructionSponsor`) to style the main section header containing the sponsor instruction text. This structure helps visually organize the top part of the sponsor page.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/sponsor.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div className={styles.mainSectionInstructionContainer}>\n  <div className={styles.instructionSponsor}>\n    Sponsor Graphileâ€™s Open Source Software\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Creating and Granting Authenticated User Role in PostgreSQL (SQL)\nDESCRIPTION: This SQL snippet creates a role named `forum_example_person` intended for authenticated users (it doesn't have login privileges itself). It then grants this role to the `forum_example_postgraphile` role. This allows the PostGraphile service (connected as `forum_example_postgraphile`) to assume the `forum_example_person` role for requests from users who have successfully authenticated, typically via JWT.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_27\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_person;\ngrant forum_example_person to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Conditionally Returning Null for User.email (JavaScript)\nDESCRIPTION: Example using `makeWrapResolversPlugin` (Method 1) to wrap the `User.email` resolver for access control. It uses the `requires` property to fetch the user's ID alongside the email, then checks if the requesting user's ID (from `context.jwtClaims`) matches the target user's ID. If they don't match, it returns `null` instead of calling the original resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst { makeWrapResolversPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    email: {\n      requires: {\n        siblingColumns: [{ column: \"id\", alias: \"$user_id\" }],\n      },\n      resolve(resolver, user, args, context, _resolveInfo) {\n        if (context.jwtClaims.user_id !== user.$user_id) return null;\n        return resolver();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Table with a Foreign Key and Text Field - Graphile SQL\nDESCRIPTION: This SQL snippet creates a posts table with an integer foreign key to a users table and a body text field. This structure is used in the documentation to exemplify relationship-naming strategies in Graphile. Requires a users table; the author_id references users and is not nullable. Enables reverse relationship naming in Graphile-generated GraphQL schemas.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncreate table posts (\n  id serial primary key,\n  author_id int not null references users,\n  body text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Variables for Database and Environment - INI\nDESCRIPTION: This .ini snippet defines the database connection string and PostGraphile environment setting. It is placed in a .env file and typically loaded by environment variable management tools. Replace placeholders to match your actual database credentials.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_18\n\nLANGUAGE: ini\nCODE:\n```\nDATABASE_URL=postgres://[username]:[password]@[host]:[port]/[database]\\nGRAPHILE_ENV=development\n```\n\n----------------------------------------\n\nTITLE: Creating PostGraphile Connection Role in PostgreSQL\nDESCRIPTION: Creates a dedicated PostgreSQL role named `forum_example_postgraphile`. This role is intended for the PostGraphile service to use when connecting to the database. It is granted `login` privileges and assigned a password ('xyz' in the example).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_22\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_postgraphile login password 'xyz';\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphileConfig Preset with Plugins in JavaScript (CommonJS)\nDESCRIPTION: Defines and exports a basic GraphileConfig.Preset object in JavaScript using CommonJS syntax. Dependencies include a plugin (\\\"some-plugin\\\") which is required and attached to the \\\"plugins\\\" array. The exported object may include scope-based configuration such as \\\"someConfigOption\\\". Input: requires installed plugin dependencies. Output: an object containing plugins and scoped options, intended as the default export for \\\"graphile.config.js\\\". No strict type-checking is enforced in this environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst SomePlugin = require(\"some-plugin\");\n\nmodule.exports = {\n  plugins: [SomePlugin],\n  someScope: {\n    someConfigOption: 10,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Upgrading PostGraphile Dependencies to V5 Beta using Yarn\nDESCRIPTION: Bash command using `yarn add` to update PostGraphile V4 development dependencies to their V5 beta versions. It targets specific packages like `graphile-build`, `graphile-build-pg`, `postgraphile`, and `postgraphile-plugin-connection-filter`, installing the versions tagged with `@beta`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add --dev \\\n  graphile-build@beta \\\n  graphile-build-pg@beta \\\n  postgraphile@beta \\\n  postgraphile-plugin-connection-filter@beta\n```\n\n----------------------------------------\n\nTITLE: Replacing Schema with Stitched Schema using makeProcessSchemaPlugin in JavaScript\nDESCRIPTION: This example shows how `makeProcessSchemaPlugin` can be used to replace the default PostGraphile schema with a stitched schema. It imports `makeProcessSchemaPlugin` and defines a plugin that takes the original `schema` and passes it to a hypothetical `stitchOtherSchemasInto` function. The result of this function, presumably a new stitched schema, is returned, effectively replacing the original schema used by the PostGraphile server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-process-schema-plugin.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst { makeProcessSchemaPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeProcessSchemaPlugin((schema) => {\n  return stitchOtherSchemasInto(schema);\n});\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Type Steps with __assertStep in TypeScript\nDESCRIPTION: Shows how to enforce that a GraphQL object type (`MyObject`) is represented by specific Gra*fast* step classes using the `__assertStep` property within the `plans` configuration. This example defines an assertion function that checks if the step is one of `PgSelectSingleStep`, `PgInsertSingleStep`, or `PgUpdateSingleStep`, throwing an error otherwise. This helps ensure downstream field resolvers receive the expected step type, preventing planning errors.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\n\nconst schema = makeExtendSchemaPlugin({\n  typeDefs: gql`\n    type MyObject {\n      id: Int\n    }\n  `,\n  plans: {\n    MyObject: {\n      assertStep($step) {\n        if ($step instanceof PgSelectSingleStep) return true;\n        if ($step instanceof PgInsertSingleStep) return true;\n        if ($step instanceof PgUpdateSingleStep) return true;\n        throw new Error(\n          `Type 'User' expects a step of type PgSelectSingleStep, PgInsertSingleStep ` +\n            `or PgUpdateSingleStep; but found step of type '${$step.constructor.name}'.`,\n        );\n      },\n      a($obj: PgSelectSingleStep | PgInsertSingleStep | PgUpdateSingleStep) {\n        return $obj.get(\"id\");\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Parsed Smart Comment Example - JSON\nDESCRIPTION: This snippet provides the resultant JSON object after parsing a smart comment block with multiple tags, including arrays for repeated values and booleans for tags with no explicit value. Requires a parsing implementation that understands the PostGraphile smart comment syntax. Input is a smart comment string, output is the resulting tags object as shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"name\\\": \\\"meta\\\",\\n  \\\"isImportant\\\": true,\\n  \\\"jsonField\\\": [\\\"date timestamp\\\", \\\"name text\\\", \\\"episode enum ONE=1 TWO=2\\\"]\\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Arbitrary JavaScript Values with embed Helper for Directives - JavaScript\nDESCRIPTION: This code demonstrates how to use the embed helper from graphile-utils to inject arbitrary JavaScript values, such as metadata objects, into a GraphQL schema definition. Commonly used with directive arguments in custom schema extensions, embed allows non-string values to be passed directly into the AST generated from gql. Dependencies are graphile-utils and PostGraphile's schema extension mechanism. This enables support for complex directive parameters on fields or types and is most useful when integrating with custom plugins or directives.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst meta = {\n  /* arbitrary data */\n  name: \"fieldName\",\n  added: \"2019-04-29T16:15:00Z\",\n};\nconst typeDefs = gql`\n  extend type Query {\n    fieldName: Int @scope(meta: ${embed(fieldNameMeta)})\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Example package.json for PostGraphile Express Project - JSON\nDESCRIPTION: This JSON snippet provides a sample 'package.json' file for the project, listing project metadata and specifying dependencies on 'express' and 'postgraphile'. Input is meant as a template to be copied and customized. The output defines npm package configuration for the app.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_11\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"name\": \"postgraphile_express\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"express\": \"^4.21.2\",\n    \"postgraphile\": \"^5.0.0-beta.38\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing pgl with npx, Amber Preset, Full DB Connection, and Schema\nDESCRIPTION: This example shows how to run the beta version of `pgl` via `npx`, specifying the full path to the 'amber' preset (`-P postgraphile/preset/amber`). It connects to a PostgreSQL database using a detailed connection string including user, password, host, port, and database name (`-c postgres://user:pass@host:port/dbname`). Additionally, it targets a specific database schema named `my_schema` (`-s my_schema`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/pgl/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Or: npx pgl@beta -P postgraphile/preset/amber -c postgres://user:pass@host:port/dbname -s my_schema\n```\n\n----------------------------------------\n\nTITLE: Rendering Pricing and Action Buttons with Dynamic Classes - React (JavaScript)\nDESCRIPTION: These snippets render pricing and call-to-action buttons inside table cells, using strong, small, and a elements for markup. Class names are dynamically composed using the clsx utility (for conditional or compounded classes) and CSS modules (styles, pricingStyles). This demonstrates integration of dynamic style assignment patterns in React, formatted pricing details, and contextual notes including multiple currencies. Inputs comprise row/column configuration; outputs are complex HTML fragments inside table cells, relying on upstream class definitions and utility CSS/JS libraries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<strong>\n  <a href=\"/sponsor/\">Crowd-funded</a>\n</strong>\n<br />\n<span className={(styles.note, pricingStyles.showFull)}>\n  <span className={styles.small}>Please give back</span>\n</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<strong>\n  <span className={clsx(styles.small, pricingStyles.showFull)}>\n    <s>$100/mo</s>\n  </span>{\" \"}\n  $25<small>/mo USD +VAT</small>\n</strong>\n<br />\n<span className={clsx(styles.note, pricingStyles.showFull)}>\n  <span className={styles.small}>EUR â‚¬25/mo, GBP Â£20/mo</span>\n</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={styles.small}>From</span>{\" \"}\n<strong>\n  $100<small>/mo USD</small>\n</strong>\n<br />\n<span className={clsx(styles.note, pricingStyles.showFull)}>\n  <span className={styles.small}>GitHub Sponsors or annual invoicing</span>\n</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={styles.small}>From</span>{\" \"}\n<strong>\n  $1,500<small>/mo USD</small>\n</strong>\n<br />\n<span className={clsx(styles.note, pricingStyles.showFull)}>\n  <span className={styles.small}>GitHub Sponsors or bespoke invoicing</span>\n</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<a\n  className={clsx(\"button button--outline\", pricingStyles.outlineButton)}\n  href=\"https://store.graphile.com\"\n>\n  Buy\n</a>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<a\n  className={clsx(\"button button--primary\", pricingStyles.primaryButton)}\n  href=\"https://github.com/sponsors/benjie\"\n>\n  GitHub Sponsors\n</a>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<a\n  className={clsx(\"button button--outline\", pricingStyles.outlineButton)}\n  href=\"mailto:info@graphile.org?subject=Private%20Advisor%20tier%20question\"\n>\n  Get in contact\n</a>\n```\n\n----------------------------------------\n\nTITLE: Testing Connection Refused Error - Bash\nDESCRIPTION: Illustrates the error message received when psql fails to connect because the PostgreSQL server is not running or unreachable. Serves as diagnostic output for troubleshooting installation or connectivity issues. Input is a local postgres connection string; output is a connection error.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n$ psql \\\"postgres:///\\\"\\n\\npsql: could not connect to server: Connection refused\\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Set-Returning Search Function (SQL)\nDESCRIPTION: This SQL snippet defines a function `forum_example.search_posts` that searches post headlines and bodies for a given text string. It uses `position()` for basic substring matching and crucially returns `setof forum_example.post`, indicating it can return multiple rows. Marked `stable`, this function is suitable for implementing search functionality exposed via PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.search_posts(search text) returns setof forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where position(search in post.headline) > 0 or position(search in post.body) > 0\n$$ language sql stable;\n\ncomment on function forum_example.search_posts(text) is 'Returns posts containing a given search term.';\n```\n\n----------------------------------------\n\nTITLE: Creating UPDATE/DELETE Policies for User-Specific Rows (SQL)\nDESCRIPTION: Defines Row Level Security policies for the `forum_example.person` table, allowing users associated with the `forum_example_person` role to update or delete only their own row. Access is determined by comparing the row's `id` column with the `person_id` extracted from a JWT claim using `current_setting('jwt.claims.person_id', true)`. The `nullif` function handles potential empty strings from the setting.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_41\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy update_person on forum_example.person for update to forum_example_person\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy delete_person on forum_example.person for delete to forum_example_person\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Defining Signature for Method 1 of makeWrapPlansPlugin in TypeScript\nDESCRIPTION: Specifies the TypeScript function signature for the first method of `makeWrapPlansPlugin`. This method accepts either a `PlanWrapperRules` object or a `PlanWrapperRulesGenerator` function to define rules for wrapping specific, known field resolvers (identified by type and field name). It returns a `GraphileConfig.Plugin`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Method 1: wrap individual resolvers of known fields\nfunction makeWrapPlansPlugin(\n  rulesOrGenerator: PlanWrapperRules | PlanWrapperRulesGenerator,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Filtering Arrays from Wrapper Computed Columns in Graphile GraphQL API - GraphQL\nDESCRIPTION: This GraphQL snippet demonstrates how to filter users based on a wrapped computed column that returns an array of scalar values, made possible by the SQL wrapping pattern and @sortable comment. It queries all users filtering where their array field contains a specific value (e.g., 'foo'). The snippet presupposes the underlying SQL implementations described earlier and a Graphile API that exposes array field filtering via connection-filter plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_32\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # get all users who own an object with field == 'foo'\n  allUsers(filter: { object_fields: { contains: \"foo\" } }) {\n    nodes {\n      id\n      # ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Project Directory and Git Repository (Bash)\nDESCRIPTION: Creates a new directory for the project, changes into it, and initializes a Git repository using standard shell commands. This is the first step in the minimal CLI setup. Requires standard Unix/Linux shell commands (`mkdir`, `cd`) and Git.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir project_folder_name\ncd project_folder_name && git init\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Schema (V4) with postgraphile-core in JavaScript\nDESCRIPTION: This code demonstrates the deprecated V4 approach to generating a PostGraphile schema using `createPostGraphileSchema` from the `postgraphile-core` package. It takes the database URL, schema name (e.g., 'public'), and configuration options as arguments and returns the schema asynchronously. This method is replaced by `makeSchema` in V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\nimport { createPostGraphileSchema } from \"postgraphile-core\";\n\n// ...\n\nconst schema = await createPostGraphileSchema(DATABASE_URL, \"public\", {\n  // options\n});\n```\n\n----------------------------------------\n\nTITLE: Processing Tuples with getLast4FromStripeIfAdmin in Graphile Crystal (TypeScript)\nDESCRIPTION: This snippet defines an asynchronous function that filters tuples based on the isAdmin flag, extracts unique stripeIds, loads associated results with getLast4FromStripeIds, and maps back to results, returning null for non-admins. It demonstrates how to process the output of list() with custom batching and mapping logic. Dependencies: lodash's uniq, getLast4FromStripeIds, asynchronous/Promise handling. Inputs: Array of [isAdmin, stripeId] tuples. Outputs: An array matching the original input positions, with either last4 digits or null.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function getLast4FromStripeIfAdmin(tuples) {\n  const stripeIds = uniq(\n    tuples\n      .filter(([isAdmin, stripeId]) => isAdmin)\n      .map(([isAdmin, stripeId]) => stripeId),\n  );\n  const last4s = await getLast4FromStripeIds(stripeIds);\n\n  return tuples.map(([isAdmin, stripeId]) => {\n    if (!isAdmin) return null;\n    const index = stripeIds.indexOf(stripeId);\n    return last4s[index];\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Unique Foreign Key Relationships on a Table - Graphile SQL\nDESCRIPTION: This SQL snippet creates a table with a unique foreign key constraint, establishing a singular relationship between mascots and companies. The unique, non-nullable foreign key ensures a one-to-one mapping in the GraphQL schema. Requires the referenced table ('companies') to exist in the SQL database.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate table mascots (\n    id serial primary key,\n    company_id int unique not null references companies,\n    name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile Server via CLI (Reiteration)\nDESCRIPTION: Reiterates the command to start the PostGraphile server from the command line using the `forum_example_postgraphile` role. This command remains the same even after configuring the default anonymous role within PostGraphile, as the connection role needs broader permissions (granted from other roles).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://forum_example_postgraphile:xyz@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Defining V5 makeAddPgTableOrderByPlugin and Related Types in TypeScript\nDESCRIPTION: Shows the simplified V5 TypeScript signatures for `makeAddPgTableOrderByPlugin`, `MakeAddPgTableOrderByPluginOrders`, `OrderBySpecIdentity`, and `orderByAscDesc`. It highlights changes from V4, including the use of a `match` object (accepting `serviceName`, `schemaName`, `tableName`) and integration with the Grafast plan system via the `applyPlan` method within `extensions.grafast`. The `OrderBySpecIdentity` now also accepts Grafast `PgOrderSpec` objects or callbacks returning them.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nexport function makeAddPgTableOrderByPlugin(\n  match: {\n    serviceName?: string;\n    schemaName: string;\n    tableName: string;\n  },\n  ordersGenerator: (\n    build: GraphileBuild.Build,\n  ) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): GraphileConfig.Plugin;\n\nexport interface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    extensions: {\n      grafast: {\n        applyPlan($select: PgSelectStep): void;\n      };\n    };\n  };\n}\n\ntype OrderBySpecIdentity =\n  | string // Column name\n  | Omit<PgOrderSpec, \"direction\"> // Expression\n  | (($select: PgSelectStep) => Omit<PgOrderSpec, \"direction\">); // Callback, allows for joins/etc\n\nexport function orderByAscDesc(\n  baseName: string,\n  columnOrSqlFragment: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n```\n\n----------------------------------------\n\nTITLE: Defining makeWrapResolversPlugin Method 1 Signature (TypeScript)\nDESCRIPTION: TypeScript function signature for the first method of using `makeWrapResolversPlugin`. This method takes either a `ResolverWrapperRules` object directly or a `ResolverWrapperRulesGenerator` function (which receives `Options` and returns rules) to specify which individual resolvers to wrap.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeWrapResolversPlugin(\n  rulesOrGenerator: ResolverWrapperRules | ResolverWrapperRulesGenerator,\n): Plugin;\n```\n\n----------------------------------------\n\nTITLE: Calling a Replacement Inflector in PostGraphile (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to call a replacement inflector method ('builtin') using the new plugin infrastructure. Only input arguments from the third parameter onward are supplied by the caller. The example shows invoking the inflection.builtin method to get the inflected name for 'Query'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst text = inflection.builtin(\\\"Query\\\");\n```\n\n----------------------------------------\n\nTITLE: Migrating Grafast Plugin Hooks to Middleware in TypeScript/JavaScript\nDESCRIPTION: This diff demonstrates the required code changes when migrating a Grafast plugin from the deprecated `hooks.args` system to the new `middleware.prepareArgs`. It highlights the signature change, requiring developers to call the `next()` function and access `requestContext` (ctx) and `resolvedPreset` directly from the `args` object instead of receiving them as separate parameters. This change is part of the move towards a more powerful middleware system in `grafast`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_13\n\nLANGUAGE: diff\nCODE:\n```\n const plugin = {\n   grafast: {\n-    hooks: {\n+    middleware: {\n-      args({ args, ctx, resolvedPreset }) {\n+      prepareArgs(next, { args }) {\n+        const { requestContext: ctx, resolvedPreset } = args;\n         // ...\n+        return next();\n       }\n     }\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Creating New Execution Batch (Pseudocode)\nDESCRIPTION: Initializes a new batch object associated with a specific path identity and Crystal context. It retrieves the corresponding plan from `aether` and prepares an empty list to hold batch entries (parent objects and deferred results).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_41\n\nLANGUAGE: pseudocode\nCODE:\n```\nNewBatch(aether, pathIdentity, crystalContext):\n\n- Let {batch} be an empty object.\n- Let {batch}.{pathIdentity} be {pathIdentity}.\n- Let {batch}.{crystalContext} be {crystalContext}.\n- Let {planId} be the value for key {pathIdentity} within {aether}.{planIdByPathIdentity}.\n- Let {plan} be the plan at index {planId} within {aether}.{plans}.\n- Let {batch}.{plan} be {plan}.\n- Let {batch}.{entries} be an empty list.\n- Return {batch}.\n```\n\n----------------------------------------\n\nTITLE: Applying Smart Tags for Single Table Polymorphism - SQL\nDESCRIPTION: Assigns smart tag comments to the 'single_table_items' table for PostGraphile to interpret the table as a polymorphic interface with variants mapped from the type column. Each '@type' smart tag specifies a discriminator value, GraphQL type name, and relevant attributes for that variant. Requires prior definition of the table and type column as shown earlier. Outputs include correct type mapping in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.single_table_items is $$\n  @interface mode:single type:type\n  @type TOPIC name:SingleTableTopic attributes:title\n  @type POST name:SingleTablePost attributes:title,description,note\n  @type DIVIDER name:SingleTableDivider attributes:title,color\n  @type CHECKLIST name:SingleTableChecklist attributes:title\n  @type CHECKLIST_ITEM name:SingleTableChecklistItem attributes:description,note\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Generating a PostGraphile Schema with JavaScript\nDESCRIPTION: Demonstrates the basic usage of `createPostGraphileSchema` to generate a GraphQL schema from a database connection string. It accepts the connection string (or config object) and returns a promise that resolves with the generated `GraphQLSchema` object or rejects with an error. This schema is static and will not update automatically if the database changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```js\ncreatePostGraphileSchema(\n  process.env.DATABASE_URL || 'postgres:///'\n)\n  .then(schema => { ... })\n  .catch(error => { ... })\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a User via GraphQL Mutation (Triggers Custom Wrapper)\nDESCRIPTION: An example GraphQL mutation to create a new user with the username \"Bob\". It calls the `createUser` mutation, passing the necessary input, and specifies the user fields (`id`, `username`, `createdDate`) to be returned upon successful creation. Executing this mutation will invoke the custom resolver wrapper configured earlier, demonstrating its effect.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_25\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createUser(input: { user: { username: \"Bob\" } }) {\n    user {\n      id\n      username\n      createdDate\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Ruru via Node.js Middleware (JavaScript)\nDESCRIPTION: Integrates Ruru into a Node.js web server (like Express, implied by `app`, `req`, `res`) using middleware. The `ruruHTML` function from `ruru/server` generates the necessary HTML string to render the Ruru interface. This HTML is then sent as a response to client requests (e.g., GET '/'), configured to point to the specified GraphQL endpoint (`/graphql`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { ruruHTML } from \"ruru/server\";\n\n// ...\n\napp.get(\"/\", (req, res, next) => {\n  res.writeHead(200, { \"Content-Type\": \"text/html\" });\n  return res.end(\n    ruruHTML({\n      endpoint: \"/graphql\",\n    }),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Automating Database Setup and Subscription Test Workflow - Bash\nDESCRIPTION: Automates the full subscription test cycle: initializes the database, creates schemas/tables/functions, inserts test records, sends subscription notifications, and cancels subscriptions. Requires bash, PostgreSQL client tools (createdb, psql), and appropriate server permissions. Inputs are script execution; outputs are creation of database structure, notification events, and eventual cancellation. Limitations: idempotency is managed for creation but not for cleanup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_21\n\nLANGUAGE: Bash\nCODE:\n```\n#!/bin/bash\nset -e\ncreatedb subs || true\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\ncreate schema if not exists app_public;\ncreate table if not exists app_public.foo (\n id serial primary key,\n title text not null\n);\ncreate schema if not exists app_private;\ncreate or replace function app_private.validate_subscription(topic text)\nreturns text as \\$\\$\n select 'CANCEL_ALL_SUBSCRIPTIONS'::text;\n\\$\\$ language sql stable;\nHERE\n\nsleep 1\n\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\n do \\$\\$\n declare\n   v_foo app_public.foo;\n begin\n   insert into app_public.foo (title) values ('Howdy!') returning * into v_foo;\n   perform pg_notify(\n     'postgraphile:hello',\n     json_build_object('__node__', json_build_array('foos', v_foo.id))::text\n   );\n end;\n \\$\\$ language plpgsql;\nHERE\n\nsleep 3\n\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\n do \\$\\$\n declare\n   v_foo app_public.foo;\n begin\n   insert into app_public.foo (title) values ('Goodbye!') returning * into v_foo;\n   perform pg_notify(\n     'postgraphile:hello',\n     json_build_object('__node__', json_build_array('foos', v_foo.id))::text\n   );\n   perform pg_notify(\n     'CANCEL_ALL_SUBSCRIPTIONS',\n     json_build_object()::text\n   );\n end;\n \\$\\$ language plpgsql;\nHERE\n```\n\n----------------------------------------\n\nTITLE: Registering a GraphQL Object Type with Graphile Build V5 API in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to implement a Graphile Config plugin that registers a custom GraphQL object type during the 'init' schema hook. It leverages the new V5 API, including the 'registerObjectType' method, and highlights how to define field specs and assert execution steps. The plugin object requires the GraphileConfig types as dependencies, accepts a generated type name, and optionally enforces type safety with custom steps. Inputs include an inflector for naming, while outputs are newly registered GraphQL types available within the schema. The snippet assumes access to Graphile Build's plugin architecture and inflection utilities, and must be used during schema initialization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyPlugin: GraphileConfig.Plugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      init(_, build) {\n        const typeName = inflection.myInflector(\"MyInflectorInput\");\n\n        build.registerObjectType(\n          typeName,\n          {\n            /* add scope data here */\n          },\n          () => ({\n            // Here's the spec for the type\n            description: \"...\",\n            fields: {\n              //...\n            },\n\n            // If this type requires a particular step class, optionally\n            // specify it here:\n            //\n            //     assertStep: ObjectStep,\n            //\n            // Or if you prefer, you can make `assertStep` a callback that\n            // throws an error if the step passed is incompatible:\n            //\n            //     assertStep($step: ExecutableStep): asserts $step is ObjectStep {\n            //       if (!($step instanceof ObjectStep)) {\n            //         throw new Error(`Expected ObjectStep, instead received '${$step}'`);\n            //       }\n            //     },\n          }),\n          `Here you'd put a helpful phrase detailing why this type is being registered; useful when two types try and register with the same name`,\n        );\n\n        return _;\n      },\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Types for makePgSmartTagsPlugin in TypeScript\nDESCRIPTION: Provides the TypeScript type definitions for the `makePgSmartTagsPlugin` function and its core types (`PgSmartTagRule`, `PgSmartTagFilterFunction`, `SubscribeToPgSmartTagUpdatesCallback`). It details the structure for rules, which include the entity `kind`, a `match` (string identifier or filter function), optional `tags`, and an optional `description`. The filter function receives the entity and build object, returning a boolean. It also defines the callback mechanism for watch mode updates.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makePgSmartTagsPlugin(\n  ruleOrRules: PgSmartTagRule | PgSmartTagRule[] | null,\n  subscribeToUpdatesCallback?: SubscribeToPgSmartTagUpdatesCallback | null,\n): Plugin;\n\ninterface PgSmartTagRule<T extends PgEntity = PgEntity> {\n  kind: PgEntityKind;\n  match: string | PgSmartTagFilterFunction<T>;\n  tags?: PgSmartTagTags;\n  description?: string;\n}\n\ntype PgSmartTagFilterFunction<T> = (input: T, build: Build) => boolean;\n\ntype UpdatePgSmartTagRulesCallback = (\n  ruleOrRules: PgSmartTagRule | PgSmartTagRule[] | null,\n) => void;\n\ntype SubscribeToPgSmartTagUpdatesCallback = (\n  cb: UpdatePgSmartTagRulesCallback | null,\n) => void | Promise<void>;\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Polymorphic Resolution with polymorphicBranch in Grafast (TypeScript/GraphQL)\nDESCRIPTION: Demonstrates a full example of using `polymorphicBranch` within a Grafast schema. It sets up a mock database (`ANIMALS`), defines GraphQL types including an `Animal` interface and `Cat`, `Dog`, `Hamster` types, and implements the `Query.animal` resolver. The resolver uses `lambda` to fetch an animal by ID and `polymorphicBranch` with custom `match` functions to determine the object's type (`feline`, `canine`, `hamster`). A custom `plan` function using `access` is provided for `Hamster` to adjust the data structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/polymorphicBranch.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeGrafastSchema, polymorphicBranch, access, lambda } from \"grafast\";\n\n// Our database of animals\nconst ANIMALS = [\n  { type: \"feline\", name: \"Artie\", colour: \"ginger\" },\n  { type: \"feline\", name: \"Brontie\", colour: \"tortoise shell\" },\n  { type: \"canine\", name: \"Captain\", wagsTail: true },\n  { type: \"hamster\", data: { name: \"Hammy\", type: \"winter white dwarf\" } },\n];\n\nconst schema = makeGrafastSchema({\n  typeDefs: /* GraphQL */ `\n    interface Animal {\n      name: String!\n    }\n    type Cat implements Animal {\n      name: String!\n      colour: String!\n    }\n    type Dog implements Animal {\n      name: String!\n      wagsTail: Boolean!\n    }\n    type Hamster implements Animal {\n      name: String!\n      type: String!\n    }\n\n    type Query {\n      animal(id: Int!): Animal\n    }\n  `,\n  plans: {\n    Query: {\n      animal(_, { $id }) {\n        const $animal = lambda($id, (id) => ANIMALS[id - 1]);\n        return polymorphicBranch($animal, {\n          Cat: {\n            match: (obj) => obj.type === \"feline\",\n          },\n          Dog: {\n            match: (obj) => obj.type === \"canine\",\n          },\n          Hamster: {\n            match: (obj) => obj.type === \"hamster\",\n            // Notice the shape of \\`Hamster\\` is different, so we need to\n            // transform the object to represent a hamster. For other types\n            // this might even involve fetching details from a remote data\n            // source.\n            plan: ($obj) => access($obj, \"data\"),\n          },\n        });\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Extending the Mutation Type in Graphile Build (JavaScript)\nDESCRIPTION: This JavaScript code snippet shows how to add custom fields to the root `Mutation` type within a `graphile-build` schema plugin. It hooks into the `GraphQLObjectType` build phase using `builder.hook`, verifies if the scope (`scope.isRootMutation`) corresponds to the root Mutation object, and utilizes the `extend` function to add new mutation fields. The `Mutation` object itself is only added to the final schema if at least one hook adds fields to it.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/default-plugins.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nfunction MyPlugin(builder) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (spec, { extend }, { scope: { isRootMutation } }) => {\n      if (!isRootMutation) {\n        return spec;\n      }\n\n      return extend(spec, {\n        //... Add new mutation fields here\n      });\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying SQL Language for PostgreSQL Functions\nDESCRIPTION: Recommends specifying `LANGUAGE sql` when creating PostgreSQL functions for better performance potential through inlining, as opposed to procedural languages. This snippet shows the keyword used in function definitions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nLANGUAGE sql\n```\n\n----------------------------------------\n\nTITLE: Setting Graphile License Environment Variable in Windows PowerShell\nDESCRIPTION: This command demonstrates setting the `GRAPHILE_LICENSE` environment variable within a Windows PowerShell session, a prerequisite for using premium Graphile plugins. It uses the `$env:` prefix to modify environment variables for the current session, followed by the `postgraphile` command executed sequentially.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n```bash\n# Windows PowerShell\n$env:GRAPHILE_LICENSE=\"license_key_from_graphile_store\"; postgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up Grafserv with h3 v1 Server in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates setting up a Node.js HTTP server using the h3 v1 framework and integrating Grafserv. It imports required modules, creates an h3 app, initializes Grafserv with a schema and preset configuration, attaches Grafserv's handlers to the h3 app, and starts the server listening on a specified port (defaulting to 5678). Dependencies include 'node:http', 'h3', 'grafserv/h3/v1', and local './graphile.config' and './schema.mjs' files.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/h3.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServer } from \"node:http\";\nimport { createApp, eventHandler, toNodeListener } from \"h3\";\nimport { grafserv } from \"grafserv/h3/v1\";\nimport preset from \"./graphile.config\";\nimport schema from \"./schema.mjs\";\n\n// create a h3 app\nconst app = createApp();\n// (Add any h3 eventHandlers you want here.)\n\n// Create a Node HTTP server, mounting h3 into it\nconst server = createServer(toNodeListener(app));\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// Create a Grafserv instance\nconst serv = grafserv({ schema, preset });\n\n// Add the Grafserv instance's route handlers to the h3 app\nserv.addTo(app).catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n\n// Start the server\nserver.listen(preset.grafserv?.port ?? 5678);\n\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile/Node.js with Inspector (Bash)\nDESCRIPTION: These Bash commands show how to start Node.js applications with the built-in inspector enabled, allowing debugging via tools like Chrome DevTools. The examples cover running a globally installed PostGraphile (using `which` to find its path), a locally installed PostGraphile from `node_modules`, and a generic Node.js application (`server.js`), all using the `--inspect` flag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# For globally installed PostGraphile:\nnode --inspect `which postgraphile` -c postgres://...\n\n# or for locally installed PostGraphile:\nnode --inspect node_modules/.bin/postgraphile -c postgres://...\n\n# or, if you have your own Node.js app in `server.js`:\nnode --inspect server.js\n```\n\n----------------------------------------\n\nTITLE: Enforcing PostgreSQL Statement Timeout Globally Using pg.Pool - Node.js (TypeScript)\nDESCRIPTION: This TypeScript snippet configures a PostgreSQL connection pool to set a global statement_timeout for all DB connections using Node.js and the 'pg' package. The code demonstrates how to import Pool from 'pg', handle pool and client errors, and execute SET statement_timeout TO 3000 when a new client connects. It is included in a typical PostGraphile configuration file and requires Node.js, the pg library, and PostGraphile's makePgService. The effect is a one-time-per-connection timeout enforcement, limiting statement execution duration for all queries issued through the pool.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/production.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Pool } from \"pg\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** does nothing */\nfunction noop() {}\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\npool.on(\"error\", noop);\npool.on(\"connect\", (client) => {\n  client.on(\"error\", noop);\n  // highlight-next-line\n  client.query(\"SET statement_timeout TO 3000\");\n});\n\nexport default {\n  // ...\n  pgServices: [\n    makePgService({\n      pool,\n      schemas: [\"app_public\"],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Plugin using Yarn\nDESCRIPTION: Shows the command to install a PostGraphile server plugin (`@graphile/operation-hooks` in this example) using the Yarn package manager. This is a standard way to add Node.js dependencies to a project.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @graphile/operation-hooks\n```\n\n----------------------------------------\n\nTITLE: Populating Forum Database with Dummy Data (SQL)\nDESCRIPTION: SQL script (`01-data.sql`) intended to run after the schema creation during PostgreSQL container initialization. It connects to the `forum_example` database and inserts sample data into the `public.user` and `public.post` tables, creating three users and three posts linked to those users.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\n\n/*Create some dummy users*/\nINSERT INTO public.user (username) VALUES\n('Benjie'),\n('Singingwolfboy'),\n('Lexius');\n\n/*Create some dummy posts*/\nINSERT INTO public.post (title, body, author_id) VALUES\n('First post example', 'Lorem ipsum dolor sit amet', 1),\n('Second post example', 'Consectetur adipiscing elit', 2),\n('Third post example', 'Aenean blandit felis sodales', 3);\n```\n\n----------------------------------------\n\nTITLE: Re-initializing the Database by Resetting Docker Volume and Rebuilding - Shell/Bash\nDESCRIPTION: These commands allow a full reset and re-initialization of the database service by stopping containers, deleting the relevant Docker Volume, removing the database image, and bringing the services back up (which triggers a new build and volume creation). Use this workflow after changes to 'db/init' files. The <your_repository_name>_db placeholder must be replaced with the actual volume name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n\"# Stop running containers\\n$ docker-compose down\\n\\n# List Docker volumes\\n$ docker volume ls\\n\\n# Delete volume\\n$ docker volume rm <your_repository_name>_db\\n\\n# Delete database image to force rebuild\\n$ docker rmi db\\n\\n# Run containers (will automatically rebuild the image)\\n$ docker-compose up\\n\"\n```\n\n----------------------------------------\n\nTITLE: Applying PostGraphile @interface mode:single Smart Tags in SQL\nDESCRIPTION: Adds a comment to the `polymorphic.single_table_items` table containing PostGraphile smart tags. `@interface mode:single type:type` declares it as an interface based on the 'type' column. `@type` tags define specific GraphQL types (SingleTableTopic, SingleTablePost, etc.) for each enum value, specifying their unique attributes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.single_table_items is $$\n  @interface mode:single type:type\n  @type TOPIC name:SingleTableTopic attributes:title\n  @type POST name:SingleTablePost attributes:title,description,note\n  @type DIVIDER name:SingleTableDivider attributes:title,color\n  @type CHECKLIST name:SingleTableChecklist attributes:title\n  @type CHECKLIST_ITEM name:SingleTableChecklistItem attributes:description,note\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Database Schema and Fixtures with Yarn (Bash)\nDESCRIPTION: Executes the `pretest` script defined in `package.json` using yarn. This script typically connects to the configured PostgreSQL database (using environment variables) and runs SQL scripts to create the necessary schema and populate test data.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn pretest\n```\n\n----------------------------------------\n\nTITLE: Defining One-to-One Table Relationships in SQL\nDESCRIPTION: This SQL snippet creates two tables, `foo` and `bar`, demonstrating a one-to-one relationship. The `bar` table's primary key (`foo_id`) is also a foreign key referencing the `foo` table's primary key, ensuring that each `foo` record can be associated with at most one `bar` record.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table foo (\n  id serial primary key\n);\n\ncreate table bar (\n  foo_id int not null primary key references foo,\n  name text\n);\n```\n\n----------------------------------------\n\nTITLE: Importing EXPORTABLE Helper from Graphile Export in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to import the EXPORTABLE helper from the graphile-export package, which is required when the plugin adds EXPORTABLE callbacks to your code. Dependencies are the 'graphile-export' package and a TypeScript/JavaScript environment that supports ES module imports. 'EXPORTABLE' should be added to your imports whenever the lint rules call for it. Input is regular TypeScript code, output is the EXPORTABLE symbol available for use; no additional constraints are mentioned.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/eslint-plugin-graphile-export/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EXPORTABLE } from \"graphile-export\";\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Schema with makeSchema in TypeScript\nDESCRIPTION: Demonstrates using the `makeSchema` function (imported from `postgraphile`) with a configuration preset to generate a GraphQL schema and the resolved preset. This function replaces `createPostGraphileSchema` from V4 and is used for schema-only scenarios.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\n// highlight-next-line\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Listing Behaviors to Avoid for Clarity (Text)\nDESCRIPTION: Specifies behavior strings that should be avoided to prevent ambiguity within the Graphile system. Recommends using 'insert' instead of 'create' and specific prefixes like 'query:', 'mutation:', or 'subscription:' instead of the generic 'root:'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n- `create` - use `insert` instead\n- `root:` - use `query:`, `mutation:` or `subscription:` instead\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Locally using npm (Bash)\nDESCRIPTION: Shows the steps to navigate into a designated project directory (`~/postgraphile`) and install the `postgraphile` beta package using `npm`. This is intended for a more permanent project setup compared to using `npx` for temporary execution. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/postgraphile\nnpm install postgraphile@beta\n```\n\n----------------------------------------\n\nTITLE: Shortening AllRows Queries with an Inflector Plugin in Graphile (TypeScript)\nDESCRIPTION: This TypeScript module exports a plugin for Graphile that overrides the allRows inflector. Its purpose is to rename generated query fields like 'allUsers' to 'users', yielding simpler plural field names. Dependencies include Graphile's plugin/plugin system; register the function as a plugin with your Graphile configuration. The main parameter is table (the database table for the query), and output is a modified schema with shortened plural queries. The code preserves all existing inflectors and just customizes query field naming. This is a demonstration of the concept, not recommended for production directly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/inflector.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Simply renames the `allUsers` and `allPosts` Query fields to `users` and\n * `posts` respectively.\n *\n * Not particularly useful, just an example.\n *\n * Replaces this inflector:\n * https://github.com/graphile/graphile-engine/blob/f3fb3878692c6959e481e517375da66503428dc5/packages/graphile-build-pg/src/plugins/PgBasicsPlugin.js#L460-L464\n */\nmodule.exports = function PgShortenAllRowsInflectorPlugin(builder) {\n  builder.hook(\"inflection\", (inflector) => ({\n    // Retain the existing inflectors\n    ...inflector,\n\n    // Override the allRows inflector\n    allRows(table) {\n      return this.camelCase(\n        // Was: `all-${this.pluralize(this._singularizedTableName(table))}`\n        // Now:\n        this.pluralize(this._singularizedTableName(table)),\n      );\n    },\n  }));\n};\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with a Specific Auth User - Bash\nDESCRIPTION: This bash command initializes a PostGraphile server instance using a connection string containing the authentication user's credentials. It assumes PostGraphile is installed and accessible on the command line, and the specified user ('auth_user') has the necessary database privileges. The command takes the Postgres connection string as a parameter input, and starts the PostGraphile application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/default-role.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Instance in JavaScript\nDESCRIPTION: This snippet shows how to initialize a new PostGraphile instance using a configuration preset. It imports the required postgraphile and preset modules and exports the instance for use in other modules. Required dependencies include 'postgraphile' and a preset config file. Expected output is a reusable PostGraphile instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nexport const pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafast Context for pgSettings in Express (TypeScript)\nDESCRIPTION: Demonstrates configuring the `grafast.context` function within `graphile.config.js` for a PostGraphile setup using Express. It extracts the Express request object (`req`) from `requestContext`, accesses specific headers (`x-something`) and user information (`req.user.id`), and maps them to custom PostgreSQL settings (`myapp.headers.x_something`, `myapp.user_id`) within the returned context object's `pgSettings` property.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"graphile.config.js\"\nexport default {\n  // ...\n\n  grafast: {\n    async context(requestContext, args) {\n      // Extract request details from the requestContext:\n      // highlight-next-line\n      const req = requestContext.expressv4?.req;\n\n      return {\n        pgSettings: {\n          ...args.contextValue?.pgSettings,\n          // Expose a specific header (if present) to PostgreSQL\n          // highlight-next-line\n          \"myapp.headers.x_something\": req?.getHeader(\"x-something\"),\n          // Expose the user id from the request, if present\n          // highlight-next-line\n          \"myapp.user_id\": req?.user?.id,\n        },\n      };\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Registering a User with Password Hashing in Postgres - SQL\nDESCRIPTION: This PL/pgSQL function registers a new user by inserting their profile into `forum_example.person` and their account (with a securely hashed password) into `forum_example_private.person_account`. Required dependencies are the pgcrypto extension and the proper schema/tables as referenced in the snippet. The function accepts four text parameters (`first_name`, `last_name`, `email`, `password`) and returns the newly created person row. It uses `security definer` to execute with creator's privileges, and is marked `strict` for input validation. Inputs must be non-null; outputs include the inserted person row.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_21\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.register_person(\n  first_name text,\n  last_name text,\n  email text,\n  password text\n) returns forum_example.person as $$\ndeclare\n  person forum_example.person;\nbegin\n  insert into forum_example.person (first_name, last_name) values\n    (first_name, last_name)\n    returning * into person;\n\n  insert into forum_example_private.person_account (person_id, email, password_hash) values\n    (person.id, email, crypt(password, gen_salt('bf')));\n\n  return person;\nend;\n$$ language plpgsql strict security definer;\n\ncomment on function forum_example.register_person(text, text, text, text) is 'Registers a single user and creates an account in our forum.';\n```\n\n----------------------------------------\n\nTITLE: Making a Function Exportable Using EXPORTABLE (TypeScript)\nDESCRIPTION: This code refactors the previous getExportTime function into an exportable form using EXPORTABLE. The original scope variable (EXPORT_TIME) is provided as an explicit dependency in the EXPORTABLE call, wrapping the function in a factory that returns it. This enables Graphile Export to serialize and reproduce the correct state at export time. Input is the factory and dependencies; output is the exportable function. Limit: dependencies must be serializable.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst EXPORT_TIME = Date.now();\nexport const getExportTime = EXPORTABLE(\n  // A factory function called with the dependency values\n  (EXPORT_TIME) =>\n    function getExportTime() {\n      return EXPORT_TIME;\n    },\n  // The values of the dependencies:\n  [EXPORT_TIME],\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Relational Tables with Polymorphic Types Â· SQL\nDESCRIPTION: Defines a central table with a type discriminator and multiple subtype tables, each sharing the same primary key and using foreign keys to establish subtype relationships. The central 'items' table uses an enum column to indicate type, and each subtype table references 'items.id' and adds specific fields. This enables SQL-based polymorphism for use in complex data modeling and well-aligned with Graphile's polymorphic resource techniques.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate type item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\n-- Central table\ncreate table items (\n  id serial primary key,\n  type item_type not null default 'POST'::item_type,\n\n  -- Shared attributes:\n  parent_id int references items on delete cascade,\n  author_id int not null references people on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz\n);\n\n-- Tables for each of the subtypes\ncreate table topics (\n  id int primary key references items,\n  title text not null\n);\ncreate table posts (\n  id int primary key references items,\n  title text not null,\n  description text default '-- Enter description here --',\n  note text\n);\ncreate table dividers (\n  id int primary key references items,\n  title text,\n  color text\n);\ncreate table checklists (\n  id int primary key references items,\n  title text not null\n);\ncreate table checklist_items (\n  id int primary key references items,\n  description text not null,\n  note text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Updating Behavior String Patterns for Graphile Schema (Plaintext)\nDESCRIPTION: Illustrates the new pattern for behavior strings introduced in version 5.0.0-0.14 as part of a behavior system overhaul. The change standardizes behavior scopes by inserting `:source:` between the operation/relation type and the action (list/connection/single), requiring updates to existing behavior configurations.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_19\n\nLANGUAGE: plaintext\nCODE:\n```\n# v5.0.0-0.14: Behavior string pattern change\n\n# Old pattern format:\n# (query|singularRelation|manyRelation|queryField|typeField):(list|connection|single)\n\n# New pattern format:\n# $1:source:$2\n\n# Example:\n# 'query:list' becomes 'query:source:list'\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images with Docker Compose\nDESCRIPTION: Provides shell commands demonstrating how to build the Docker images defined in the `docker-compose.yml` file. It shows the command to build all service images (`docker-compose build`) and commands to build images for specific services individually (`docker-compose build db`, `docker-compose build graphql`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n# Build images for all services in docker-compose.yml\n$ docker-compose build\n\n# You can also build images one by one\n# For instance you can build the database image like this\n$ docker-compose build db\n\n# And build the graphql image like this\n$ docker-compose build graphql\n```\n\n----------------------------------------\n\nTITLE: Installing Grafast and GraphQL with npm - Bash\nDESCRIPTION: This snippet demonstrates installing the grafast (beta) and graphql packages using npm. Dependencies required include Node.js and npm. Running this command ensures both grafast (JavaScript/TypeScript GraphQL execution engine) and the GraphQL.js reference implementation are available in your project, prerequisites for defining and executing GraphQL schemas through grafast.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save grafast@beta graphql\n```\n\n----------------------------------------\n\nTITLE: Reinitializing the Database in Dockerized Environment - Shell Commands\nDESCRIPTION: This shell snippet outlines the process for reinitializing the PostgreSQL database by stopping containers, deleting the persistent Docker volume, removing the database image, and restarting the stack. This ensures schema and seed file changes are applied. Proper permission and cleanup procedures are needed, as deletion is irreversible and may result in data loss.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n# Stop running containers\\n$ docker-compose down\\n\\n# List Docker volumes\\n$ docker volume ls\\n\\n# Delete volume\\n$ docker volume rm <your_repository_name>_db\\n\\n# Delete database image to force rebuild\\n$ docker rmi db\\n\\n# Run containers (will automatically rebuild the image)\\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Creating Heroku Procfile for PostGraphile CLI (Bash)\nDESCRIPTION: Creates a `Procfile` in the project root using shell redirection. This file tells Heroku how to run the web process: execute the `postgraphile` CLI, connecting with the database specified by the `$RDS_URL` environment variable, binding to all interfaces (`0.0.0.0`), and using the Heroku-assigned `$PORT`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\necho 'web: postgraphile -c $RDS_URL --host 0.0.0.0 --port $PORT' >> Procfile\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query Result - JSON\nDESCRIPTION: This snippet shows the expected JSON result from a GraphQL query fetching a topic's body and its computed summary. The 'body' field contains the full body text, and 'bodySummary' contains the truncated summary as produced by the SQL computed column function. This provides an example of how computed columns are reflected in the API response.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/computed-columns.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"topic\": {\n    \"body\": \"PostGraphile is a powerful, idomatic, and elegant tool.\",\n    \"bodySummary\": \"PostGraphile is a powerful,...\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Id-to-NodeId Inflection Plugin (PostGraphile, TypeScript)\nDESCRIPTION: This TypeScript code defines a custom GraphileConfig plugin `IdToNodeIdPlugin` for PostGraphile, modifying inflection to use `nodeId` instead of the default field and altering attribute naming behavior. It requires the `graphile-config` and PostGraphile's plugin application infrastructure. The plugin customizes how global object identifiers are named and mapped in the schema, preventing attribute collisions for tables with an `id` primary key. It should be included in the PostGraphile plugin pipeline for effect.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/node-id.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst IdToNodeIdPlugin: GraphileConfig.Plugin = {\n  name: \"IdToNodeIdPlugin\",\n  version: \"1.0.0\",\n  inflection: {\n    replace: {\n      nodeIdFieldName() {\n        return \"nodeId\";\n      },\n      _attributeName(previous, options, details) {\n        const attribute = codec.attributes[attributeName];\n        const name = attribute.extensions?.tags?.name || attributeName;\n        return this.coerceToGraphQLName(name);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing PostGraphile Routes in a NestJS Controller using TypeScript\nDESCRIPTION: This snippet shows how to integrate PostGraphile route handlers within a NestJS application using a controller. It uses `@nestjs/common` decorators (`@Controller`, `@Get`, `@Post`, `@Req`, `@Res`, `@Next`) to define routes that correspond to PostGraphile's GraphiQL and GraphQL endpoints. The actual handling is delegated to `middleware.graphiqlRouteHandler` and `middleware.graphqlRouteHandler`, wrapped with `PostGraphileResponseNode` to adapt to the Express-based request/response objects used by NestJS.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { Controller, Get, Post, Req, Next, Res } from \"@nestjs/common\";\nimport { Request, Response } from \"express\";\nimport { PostGraphileResponseNode } from \"postgraphile\";\nimport { middleware } from \"./postgraphile.middleware\";\n\n@Controller(\"/\")\nexport class PostGraphileController {\n  @Get(middleware.graphiqlRoute)\n  graphiql(@Req() request: Request, @Res() response: Response, @Next() next) {\n    middleware.graphiqlRouteHandler(\n      new PostGraphileResponseNode(request, response, next),\n    );\n  }\n\n  @Post(middleware.graphqlRoute)\n  graphql(@Req() request: Request, @Res() response: Response, @Next() next) {\n    middleware.graphqlRouteHandler(\n      new PostGraphileResponseNode(request, response, next),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Removing hello-world Docker Image (Shell)\nDESCRIPTION: Lists all local Docker images using `docker image ls` and then forcefully removes the `hello-world` image using `docker rmi -f hello-world`. This cleans up the test image after verifying the Docker installation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ docker image ls\n$ docker rmi -f hello-world\n```\n\n----------------------------------------\n\nTITLE: Loading ES Module Configuration on Windows\nDESCRIPTION: Specifies the ES Module configuration filename `graphile.config.mjs`. The surrounding context describes a fix implemented to ensure compatibility with Windows by using `file://` URLs within dynamic `import()` calls when loading this configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\ngraphile.config.mjs\n```\n\n----------------------------------------\n\nTITLE: Installing Preset using npm\nDESCRIPTION: This Bash command installs the `@graphile/simplify-inflection` package using the npm package manager. The `--save` flag adds it to the project's dependencies, and `@beta` specifies the beta version.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @graphile/simplify-inflection@beta\n```\n\n----------------------------------------\n\nTITLE: Function Signature for makeAddPgTableConditionPlugin in TypeScript\nDESCRIPTION: This TypeScript code displays the function signature for `makeAddPgTableConditionPlugin`. It takes a `match` object (specifying the target table via `schemaName` and `tableName`), a `conditionFieldName` string (the name for the new condition in GraphQL), and a `fieldSpecGenerator` function. The generator function receives the `build` object and must return an input field configuration, including the GraphQL type, description, and an `applyPlan` function that defines how to modify the SQL query based on the provided condition value.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-condition-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makeAddPgTableConditionPlugin(\n  match: { serviceName?: string; schemaName: string; tableName: string },\n  conditionFieldName: string,\n  fieldSpecGenerator: (build: GraphileBuild.Build) => GraphileInputFieldConfig,\n): GraphileConfig.Plugin;\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Specific Behavior with @behavior Smart Tag\nDESCRIPTION: Illustrates using the `@behavior` smart tag with a specific negated behavior, like `@behavior -update`. This prevents only the specified behavior (in this case, generating update mutations/fields) for the associated database object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n@behavior -update\n```\n\n----------------------------------------\n\nTITLE: Querying Custom Root-Level Functions in GraphQL - GraphQL\nDESCRIPTION: Illustrates how the above PostgreSQL custom query functions are queried via GraphQL after exposure through PostGraphile. Shows both functions with and without arguments, and demonstrates retrieving row fields when a function returns a record type. Inputs are function arguments as GraphQL fields, and the output matches the function's return type as specified in the schema. Requires the PostgreSQL function to be correctly defined and exposed by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-queries.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # For a function without arguments\n  myFunction\n\n  # For a function with arguments\n  myFunction(a: 1, b: 2)\n\n  # For a function that returns a row\n  myOtherFunction(a: 1, b: 2) {\n    id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Subscription Example for Testing (GraphQL)\nDESCRIPTION: This GraphQL subscription request demonstrates how a client subscribes to forum message events by forum ID. The query expects the server to stream event and user fields in real time as messages are posted. Use this in a GraphQL IDE like Ruru or GraphiQL to connect to the subscription endpoint. Field parameters and selection sets are customizable based on extended schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription MySubscription {\n  forumMessage(forumId: 1) {\n    user\n    event\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Fastify Server with Grafserv Integration - JavaScript\nDESCRIPTION: This snippet initializes a Fastify V4 server, sets up optional middleware, integrates a Grafserv instance configured with a GraphQL schema and preset, and binds its route handlers to the Fastify app. The final block starts the server listening on a configurable port, with logging and error handling. Dependencies include Fastify, grafserv/fastify/v4, the Graphile preset, and schema modules; optional websocket support is commented out.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/fastify.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport Fastify from \\\"fastify\\\";\\n// import websocket from '@fastify/websocket'\\nimport { grafserv } from \\\"grafserv/fastify/v4\\\";\\nimport preset from \\\"./graphile.config.mjs\\\";\\nimport schema from \\\"./schema.mjs\\\";\\n\\n// Create a Fastify app\\nconst app = Fastify({\\n  logger: true,\\n});\\n// (Add any Fastify middleware you want here.)\\n// await app.register(websocket);\\n\\n// Create a Grafserv instance\\nconst serv = grafserv({ schema, preset });\\n\\n// Add the Grafserv instance's route handlers to the Fastify app\\nserv.addTo(app).catch((e) => {\\n  console.error(e);\\n  process.exit(1);\\n});\\n\\n// Start the Fastify server\\napp.listen({ port: preset.grafserv?.port ?? 5678 }, (err, address) => {\\n  if (err) throw err;\\n  console.log(`Server is now listening on ${address}`);\\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Field to Root Query via schema.hooks (JavaScript)\nDESCRIPTION: This schema plugin for Graphile Build hooks into 'GraphQLObjectType_fields' and detects when the root query type is being constructed, then adds a new 'meaningOfLife' integer field that always returns 42 using Gra*fast*'s 'constant' planner. It depends on 'grafast', and proper build/scoping configuration in the Graphile Build plugin system is required.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { constant } from \\\"grafast\\\";\n\nconst RootQueryFieldPlugin = {\n  name: \\\"RootQueryFieldPlugin\\\",\n  version: \\\"0.0.0\\\",\n  description: \\\"Adds a field to the root Query type\\\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // Only add the field to the root query type\n        if (!context.scope.isRootQuery) return fields;\n\n        // Add a field called `meaningOfLife`\n        fields.meaningOfLife = {\n          // It's an integer\n          type: build.graphql.GraphQLInt,\n\n          // When you call the field, you should always return the number '42'\n          plan() {\n            return constant(42);\n          },\n        };\n\n        return fields;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Function for Post Body Summarization (SQL)\nDESCRIPTION: Defines a stable SQL function `forum_example.post_summary` that takes a `forum_example.post` record, an optional integer `length` (defaulting to 50), and an optional text `omission` (defaulting to 'â€¦'). It returns a substring of the post's body up to the specified length, followed by the omission text, or null if the body is null. A descriptive comment is included. PostGraphile treats such functions as computed fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.post_summary(\n  post forum_example.post,\n  length int default 50,\n  omission text default 'â€¦'\n) returns text as $$\n  select case\n    when post.body is null then null\n    else substr(post.body, 0, length) || omission\n  end\n$$ language sql stable;\n\ncomment on function forum_example.post_summary(forum_example.post, int, text) is 'A truncated version of the body for summaries.';\n```\n\n----------------------------------------\n\nTITLE: Migrating @requires Logic from V4 Resolver to V5 Plan\nDESCRIPTION: Demonstrates converting a V4 `makeExtendSchemaPlugin` resolver that uses `@requires(columns: [\"price_in_us_cents\"])` to ensure data availability into a V5 plan. The V5 plan replaces the directive by explicitly fetching the column using `$product.get('price_in_us_cents')` and uses a `lambda` step from `postgraphile/grafast` to apply the `convertUsdToAud` function. Dependencies include `postgraphile/utils`, `postgraphile/grafast`, and a hypothetical `ficticious-npm-library`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n```diff title=\"V4 -> V5 conversion\"\n-const { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\n+const { makeExtendSchemaPlugin, gql } = require(\"postgraphile/utils\");\n const { convertUsdToAud } = require(\"ficticious-npm-library\");\n+const { lambda } = require('postgraphile/grafast');\n\n-const MyForeignExchangePlugin = makeExtendSchemaPlugin((build, options) => {\n+const MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n+  const { options } = build;\n   return {\n     typeDefs: gql`\n       extend type Product {\n-        priceInAuCents: Int! @requires(columns: [\"price_in_us_cents\"])\n+        priceInAuCents: Int!\n       }\n     `,\n-    resolvers: {\n+    plans: {\n       Product: {\n-        priceInAuCents: async (product) => {\n-          // Note that the columns are converted to fields, so the case changes\n-          // from `price_in_us_cents` to `priceInUsCents`\n-          const { priceInUsCents } = product;\n-          return await convertUsdToAud(priceInUsCents);\n-        },\n+        priceInAuCents($product) {\n+          const $cents = $product.get('price_in_us_cents');\n+          return lambda($cents, cents => convertUsdToAud(cents));\n+        },\n       },\n     },\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling a Default Plugin in PostGraphile Configuration (TypeScript)\nDESCRIPTION: This snippet shows how to prevent a specific default Graphile Build plugin from running by adding its name to the `disabledPlugins` array in the PostGraphile configuration (`graphile.config.mjs`). The example disables `PgCustomTypeFieldPlugin` to prevent Postgres functions from being added to the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending-raw.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nexport default {\n  // ...\n  disabledPlugins: [\"PgCustomTypeFieldPlugin\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Querying One-to-Many Relation in GraphQL\nDESCRIPTION: Demonstrates a GraphQL query against a schema generated by PostGraphile from the example one-to-many SQL schema. It fetches all posts (`allPosts`) and, for each post node, retrieves the headline, body, and associated author details (id, name, about) using the automatically generated `personByAuthorId` relation field.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/relations.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPosts {\n    nodes {\n      headline\n      body\n\n      # this relation is automatically exposed\n      personByAuthorId {\n        id\n        name\n        about\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Queueing a Job with Graphile Worker in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet demonstrates how to add a job to the Graphile Worker queue by calling the add_job function within the PostgreSQL database schema managed by Graphile Worker. The job type is specified as 'hello' and a payload is passed as a JSON object containing key-value pairs. This requires Graphile Worker installed and its schema set up in the PostgreSQL database. Inputs are the job name and payload; there is no direct output, but the job is persisted for future processing by a worker.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/background-tasks.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT graphile_worker.add_job('hello', json_build_object('name', 'Bobby Tables'));\n```\n\n----------------------------------------\n\nTITLE: Configuring Operation Timeouts in Gra*fast* (JavaScript)\nDESCRIPTION: This repeated example reinforces how to set planning and execution timeouts in the Gra*fast* `preset` object. Use the `grafast.timeouts.planning` property for maximum planning time and `grafast.timeouts.execution` for execution, both given in milliseconds. The configuration pattern is the same as elsewhere in the documentation, and helps to protect server resources from overly slow or complex queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/production-considerations.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst preset = {\n  grafast: {\n    timeouts: {\n      /** Planning timeout in ms */\n      planning: 500,\n\n      /** Execution timeout in ms */\n      execution: 30_000,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Basic Condition in GraphQL\nDESCRIPTION: Demonstrates a basic GraphQL query using the default `condition` argument provided by PostGraphile to filter `allForums` based on the `creatorId`. This shows the standard filtering mechanism before introducing custom conditions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-condition-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsCreatedByUser1 {\n  allForums(condition: { creatorId: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Docker Compose Configuration for PostGraphile Service in YAML\nDESCRIPTION: Updates the `docker-compose.yml` file to define the `graphql` service. It specifies the container name, restart policy, image name, build context (pointing to the `graphql` directory containing the Dockerfile), environment file (`.env`), dependency on the `db` service, network configuration, and port mapping (mapping host port 5433 to the container's port 5433, which corresponds to the `PORT` env var used by `server.js`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_4\n\nLANGUAGE: yml\nCODE:\n```\nversion: \"3.3\"\\nservices:\\n    db: [...]\\n\\n    graphql:\\n        container_name: forum-example-graphql\\n        restart: always\\n        image: forum-example-graphql\\n        build:\\n            context: ./graphql\\n        env_file:\\n            - ./.env\\n        depends_on:\\n            - db\\n        networks:\\n            - network\\n        ports:\\n            - 5433:5433\\n[...]\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for the access() Function\nDESCRIPTION: Provides the TypeScript type definition for the `access` function. It accepts a source `ExecutableStep<unknown>`, a `path` (which can be a single string/number or an array of strings/numbers representing the nested keys/indices), and an optional `fallback` value. It returns an `AccessStep<TData>`, which itself has `.get()` and `.at()` methods for further traversal.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/access.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nfunction access<TData>(\n  $source: ExecutableStep<unknown>,\n  path: (string | number)[] | string | number,\n  fallback?: any,\n): AccessStep<TData>;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Inflection Plugin in JavaScript\nDESCRIPTION: This JavaScript code defines a PostGraphile plugin named `FullNameToNamePlugin`. It utilizes the `inflection.replace.attribute` hook from graphile-build to rename any database attribute named `full_name` to `name` in the generated GraphQL schema. It relies on the `GraphileConfig.Plugin` type and the underlying inflection system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n/** @type {GraphileConfig.Plugin} */\nconst FullNameToNamePlugin = {\n  name: \"FullNameToNamePlugin\",\n  inflection: {\n    replace: {\n      attribute(previous, options, details) {\n        if (details.attributeName === \"full_name\") {\n          return \"name\";\n        } else {\n          return previous?.(details) ?? details.attributeName;\n        }\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Users by Organization ID with ioEquivalence in loadMany - TypeScript\nDESCRIPTION: Extends the previous plan resolver by adding 'organization_id' as ioEquivalence to loadMany, indicating input/output equivalence between user and organization IDs. This enables parallel fetching of users and organizations, optimizing GraphQL query performance. Dependencies include batch data access functions and the loadMany/loadOne APIs in Graphile Crystal.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst plans = {\n  Query: {\n    usersByOrganizationId(_, { $id }) {\n      return loadMany($id, 'organization_id', batchGetUsersByOrganizationId);\n    },\n  },\n  User: {\n    organization($user) {\n      const $orgId = $user.get(\"organization_id\");\n      return loadOne($orgId, batchGetOrganizationById);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Support Table Row with Icons and Multi-Channel Support - React (JavaScript)\nDESCRIPTION: This snippet displays support options across pricing tiers using a combination of styled spans for responsive messaging, line breaks, and multiple Icon components within a React JSX table. It highlights use of brand and solid FontAwesome icons for visual identification (GitHub, Discord, Slack, Phone), rendered inline with optional whitespace and context cues. Dependencies include a custom Icon component and pricingStyles CSS classes, as well as FontAwesome icon configuration. Inputs are fixed and outputs are variably rendered icons and text for each support channel.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={pricingStyles.showFull}>via community Discord</span>\n<span className={pricingStyles.showMobile}>Community support</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={pricingStyles.showFull}>\n  Priority support via community Discord\n</span>\n<span className={pricingStyles.showMobile}>Community support</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nWithin your own company\n<br />\n<Icon icon=\"fa-brands fa-github\" size=\"lg\" />\n&nbsp;\n<Icon icon=\"fa-brands fa-discord\" size=\"lg\" />\n&nbsp;\n<Icon icon=\"fa-brands fa-slack\" size=\"lg\" />\n&nbsp;\n<Icon icon=\"fa-solid fa-square-phone-flip\" size=\"lg\" />\n```\n\n----------------------------------------\n\nTITLE: Structuring a Batch GraphQL Query Request Payload in JSON\nDESCRIPTION: This JSON snippet illustrates the expected format for sending a batch of GraphQL queries. The request payload should be a JSON array, where each element is a standard GraphQL request object containing the query string, optional operation name, and variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"query\": \"...\",\n    \"operationName\": \"...\",\n    \"variables\": {\n      \"someVariable\": \"...\"\n    }\n  },\n  {\n    \"query\": \"...\",\n    \"operationName\": \"...\",\n    \"variables\": {\n      \"someVariable\": \"...\"\n    }\n  },\n  {\n    \"query\": \"...\",\n    \"operationName\": \"...\",\n    \"variables\": {\n      \"someVariable\": \"...\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Bulk Insert Mutation in PostgreSQL\nDESCRIPTION: This SQL snippet defines a custom mutation function `app_public.create_documents` that performs a bulk insert operation. It takes a number (`num`), type, and location, then inserts `num` records into the `app_public.document` table using `generate_series`. The `RETURNS SETOF app_public.document` clause indicates it will return multiple document records, and `RETURNING *` returns all columns of the inserted rows.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-mutations.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION app_public.create_documents(num integer, type text, location text)\nRETURNS SETOF app_public.document\nAS $$\n  INSERT INTO app_public.document (type, location)\n    SELECT create_documents.type, create_documents.location\n    FROM generate_series(1, num) i\n    RETURNING *;\n$$ LANGUAGE sql STRICT VOLATILE;\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Full Name Function (SQL)\nDESCRIPTION: This SQL code defines a function `forum_example.person_full_name` that takes a `forum_example.person` row as input and returns the concatenation of the person's first and last names. Marked as `stable`, this function is intended to be used by PostGraphile as a computed field on the `Person` type. A comment describes its purpose.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_full_name(person forum_example.person) returns text as $$\n  select person.first_name || ' ' || person.last_name\n$$ language sql stable;\n\ncomment on function forum_example.person_full_name(forum_example.person) is 'A personâ€™s full name which is a concatenation of their first and last name.';\n```\n\n----------------------------------------\n\nTITLE: Exported Pure Function After Graphile Export (TypeScript)\nDESCRIPTION: Represents the shape of code produced after exporting with Graphile Export, inlining concrete values (such as EXPORT_TIME). The resulting function is pure and no longer references external dependencies, and will always return the fixed exported value. Output is deterministic; input is irrelevant since dependencies are inlined.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getExportTime() {\n  return 1730722557867;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector in PostGraphile Plugin (TypeScript with Declaration Merging)\nDESCRIPTION: This TypeScript snippet showcases the correct structure for defining a plugin that adds a new inflector ('enhanced') with full type safety. The code snippet uses declaration merging via a global augmentation of the GraphileBuild.Inflection interface, ensuring type awareness across plugins. Required dependencies include 'graphile-config', 'graphile-build', and 'graphile-build-pg'. The plugin registers the new inflector in the inflection.add property, which returns the enhanced column name string when invoked.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\ndeclare global {\\n  namespace GraphileBuild {\\n    interface Inflection {\\n      /**\\n       * Add documentation for your inflector here.\\n       */\\n      enhanced(this: Inflection, columnName: string): string;\\n    }\\n  }\\n}\\n\\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\\n  name: \\\"MyNewInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    add: {\\n      enhanced(preset, columnName) {\\n        return columnName + \\\"Enhanced\\\";\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Schema Only with makeSchema (TypeScript)\nDESCRIPTION: This snippet shows schema-only usage by importing makeSchema from postgraphile and applying it to a loaded preset. The returned object contains the generated GraphQL schema and the fully resolved preset. No context lifecycle management is needed in V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\n// highlight-next-line\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Heroku Configuration Variables (Bash)\nDESCRIPTION: Demonstrates setting several essential environment variables for a Node.js/PostGraphile application on Heroku using `heroku config:set`. It includes setting `NODE_ENV` to production, enabling `GRAPHILE_TURBO` for performance, and providing the `DATABASE_URL` with SSL enabled, targeting a specific app (`myappname`). Requires the Heroku CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set \\\n    NODE_ENV=\"production\" \\\n    GRAPHILE_TURBO=\"1\" \\\n    DATABASE_URL=\"postgres://username:password@host:port/dbname?ssl=true\" \\\n    -a myappname\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Compose - Shell\nDESCRIPTION: This command installs Docker Compose on Linux using the system package manager. Requires root access. Input: none. Output: Docker Compose installed and available via CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt install docker-compose\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Optimized PostGraphile V4 Bundling (No Subscriptions) in JavaScript\nDESCRIPTION: This advanced Webpack configuration provides optimizations for bundling PostGraphile V4, suitable for environments like AWS Lambda, but it disables watch mode and subscriptions. It targets Node.js, uses `DefinePlugin` to set environment variables (`NODE_ENV`, `POSTGRAPHILE_ENV`, `NODE_PG_FORCE_NATIVE`, `POSTGRAPHILE_OMIT_ASSETS`), employs `NormalModuleReplacementPlugin` to replace the native `pg` module with the JS client (tricking `node-postgres`), omit PostGraphile's WebSocket functionality, and optionally omit Express views. It sets `node.__dirname` to `false` and configures `TerserPlugin` with `mangle: false` to prevent potential GraphQL naming conflicts during minification. This config depends on external placeholder files (`postgraphile-http-subscriptions.js`, `express-lib-view.js`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/bundling-webpack.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst webpack = require(\"webpack\");\nconst TerserPlugin = require(\"terser-webpack-plugin\");\n\nmodule.exports = {\n  //...\n\n  target: \"node\",\n  plugins: [\n    // Prevent loading pg-native (in a weird, backwards kind of way!)\n    new webpack.DefinePlugin({\n      // Nice light dependencies\n      \"process.env.NODE_ENV\": '\"production\"',\n      \"process.env.POSTGRAPHILE_ENV\": '\"production\"',\n\n      // Forces node-postgres to attempt to use the native module, HOWEVER we\n      // trick this below by replacing the native module with the JavaScript\n      // client using `NormalModuleReplacementPlugin`. ðŸ˜ˆ\n      \"process.env.NODE_PG_FORCE_NATIVE\": '\"1\"',\n\n      // Set this if you want the smallest bundle; it excludes GraphiQL\n      \"process.env.POSTGRAPHILE_OMIT_ASSETS\": '\"1\"',\n    }),\n\n    // Here's where we replace the native `pg` module reference with the\n    // JavaScript client. (See NODE_PG_FORCE_NATIVE above.)\n    new webpack.NormalModuleReplacementPlugin(\n      /pg\\/lib\\/native\\/index\\.js$/,\n      \"../client.js\",\n    ),\n\n    // Omit websocket functionality from postgraphile:\n    new webpack.NormalModuleReplacementPlugin(\n      /postgraphile\\/build\\/postgraphile\\/http\\/subscriptions\\.js$/,\n      `${__dirname}/src/postgraphile-http-subscriptions.js`,\n    ),\n\n    // Just in case you install express, omit the expensive view file:\n    new webpack.NormalModuleReplacementPlugin(\n      /express\\/lib\\/view\\.js$/,\n      `${__dirname}/src/express-lib-view.js`,\n    ),\n  ],\n\n  // We don't need to use __dirname any more:\n  node: {\n    __dirname: false, // just output `__dirname`\n  },\n\n  // Without this, you may get errors such as `Error: GraphQL conflict for 'e'\n  // detected! Multiple versions of graphql exist in your node_modules?`\n  // May not be necessary for newer versions of the `graphql` module.\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          mangle: false, // < This is the important part\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Heroku RDS_URL Variable with SSL (Bash)\nDESCRIPTION: Sets a custom environment variable `RDS_URL` on the specified Heroku app (`heroku_app_name`) containing the connection string for the database (e.g., AWS RDS), ensuring SSL is enabled via `?ssl=true`. Requires the Heroku CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set RDS_URL=\"postgres://user:pass@rdshost/dbname?ssl=true\" -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: Defining OmitMutationsByDefaultPlugin in TypeScript\nDESCRIPTION: This TypeScript module exports a PostGraphile plugin function named `OmitMutationsByDefaultPlugin`. The plugin hooks into the `build` phase, iterates through all selectable database tables identified during introspection, and checks for an `@omit` smart comment. If no such comment exists on a table, it automatically adds the tag `omit: \"create,update,delete\"` to the table's metadata, effectively preventing PostGraphile from generating the standard Create, Update, and Delete mutations for that table. This behavior can be overridden by adding an `@omit` comment to the table in the database, potentially specifying which mutations to omit or using `@omit :` to allow all mutations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * This plugin treats any table that doesn't have an `@omit` comment as if it\n * had `@omit create,update,delete` (thereby disabling mutations).\n *\n * Override it by adding a smart comment to the table. To restore all\n * mutations, do `COMMENT ON my_table IS E'@omit :';` (the `:` is special\n * syntax for \"nothing\").\n */\nmodule.exports = function OmitMutationsByDefaultPlugin(builder) {\n  builder.hook(\"build\", (build) => {\n    const { pgIntrospectionResultsByKind } = build;\n    pgIntrospectionResultsByKind.class\n      .filter((table) => table.isSelectable && table.namespace)\n      .forEach((table) => {\n        if (!(\"omit\" in table.tags)) {\n          table.tags.omit = \"create,update,delete\";\n        }\n      });\n    return build;\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage: Passing Untransformed Steps to Lambda in TypeScript\nDESCRIPTION: This snippet illustrates an anti-pattern where a step produced by each is passed to lambda without forcing transform application, which may result in outputs like '[object Object]' due to the values not actually being mapped as intended. The code also demonstrates filtering users by organization name and describes the consequences of neglecting applyTransforms in such cases. Prerequisites include a usersResource, sql helper, and the lambda utility.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/applyTransforms.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// â— COUNTER-EXAMPLE!\nconst $users = usersResource.find();\n$users.where(sql`${$users}.organization_name = 'Graphile'`);\nconst $usernames = each($users, ($user) => $user.get(\"username\"));\nreturn lambda(\n  // UNSAFE! $usernames has not been transformed yet, it still represents the\n  // same collection as $users.\n  $usernames,\n  (usernames) => `Hello ${usernames.join(\", \")}!`,\n  true,\n);\n```\n\n----------------------------------------\n\nTITLE: Running Grafast with Plan-based Schema Benchmark - JavaScript\nDESCRIPTION: Measures Grafast's performance by executing a query 10,000 times against a plan-based schema, utilizing its planning capabilities. Setup requires pre-defined schema and plans. Outputs the execution duration, demonstrating efficiency improvements using plan-based resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/examples/users-and-friends/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnode index.mjs grafast\n```\n\n----------------------------------------\n\nTITLE: Renaming 'source' Property to 'from' in Resource/Plan Classes\nDESCRIPTION: Illustrates the renaming of the `source` property to `from` in classes like `PgResourceConfig`, `PgResource`, and `PgSelectPlanJoin` to avoid overloading the term 'source'.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nPgResourceConfig::source -> PgResourceConfig.from\nPgResource::source -> PgResource.from\nPgSelectPlanJoin::source -> PgSelectPlanJoin.from\n```\n\n----------------------------------------\n\nTITLE: Granting Role Permissions in PostgreSQL for Google Cloud SQL using SQL\nDESCRIPTION: Provides an SQL command to grant membership in one database role (e.g., `anonymous`) to another role (e.g., `postgres`). This is necessary in Google Cloud SQL where the default `postgres` user is not a superuser and needs explicit permission to switch to other roles using `SET LOCAL role TO ...`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nGRANT anonymous TO postgres;\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Live User List Changes with GraphQL\nDESCRIPTION: This snippet illustrates a GraphQL subscription designed to emulate 'live query' behavior, providing updates whenever the result set changes. Clients subscribing to this operation will be notified in real time when users named 'Alice' are added, removed, or have their data updated (including changes to their friends). This requires backend support for live queries, as clients are unaware of the distinction; implementation details differ between GraphQL providers. Inputs include a 'condition' for filtering users; outputs are updated lists of users and their friends in response to any qualifying change.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/realtime.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allUsersList(condition: { firstName: \"Alice\" }) {\n    id\n    name\n    friendsList {\n      id\n      name\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository (Bash)\nDESCRIPTION: Changes the current directory to the specified project folder and initializes a new Git repository within it using the `cd` and `git init` commands. This is a standard first step in version-controlling a project.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd project_folder_name && git init\n```\n\n----------------------------------------\n\nTITLE: Running Project Test Suite with Yarn (Bash)\nDESCRIPTION: Executes the main test suite for the project using the `test` script defined in `package.json`. This command runs all configured tests, likely using a test runner like Jest, against the prepared test database.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn test\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying PostGraphile with Multi-Stage Dockerfile - Dockerfile\nDESCRIPTION: This Dockerfile demonstrates a multi-stage build process for deploying a Node.js server (such as one using PostGraphile), optimizing for small image size and separation of build/runtime concerns. It uses three stages: a builder stage for dependency installation and build, a cleaning stage to minimize unnecessary files, and a final runtime stage with production dependencies only. Key parameters include NODE_ENV for environment control, exposed port 5000, and environment variables for tuning PostGraphile. Dependencies: Docker, Node.js (12-alpine), and Yarn. The Dockerfile expects a server/ directory with a build script and relevant files for the build to succeed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-docker.md#_snippet_1\n\nLANGUAGE: Dockerfile\nCODE:\n```\n# Dockerfile\\n\\n# Global args, set before the first FROM, shared by all stages\\nARG NODE_ENV=\\\"production\\\"\\n\\n################################################################################\\n# Build stage 1 - `yarn build`\\n\\nFROM node:12-alpine as builder\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Cache node_modules for as long as possible\\nCOPY package.json yarn.lock /app/\\nWORKDIR /app/\\nRUN yarn install --frozen-lockfile --production=false --no-progress\\n\\n# Copy over the server source code\\nCOPY server/ /app/server/\\n\\n# Finally run the build script\\nRUN yarn run build\\n\\n################################################################################\\n# Build stage 2 - COPY the relevant things (multiple steps)\\n\\nFROM node:12-alpine as clean\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Copy over selectively just the tings we need, try and avoid the rest\\nCOPY --from=builder /app/package.json /app/yarn.lock /app/\\nCOPY --from=builder /app/server/dist/ /app/server/dist/\\n\\n################################################################################\\n# Build stage FINAL - COPY everything, once, and then do a clean `yarn install`\\n\\nFROM node:12-alpine\\n# Import our shared args\\nARG NODE_ENV\\n\\nEXPOSE 5000\\nWORKDIR /app/\\n# Copy everything from stage 2, it's already been filtered\\nCOPY --from=clean /app/ /app/\\n\\n# Install yarn ASAP because it's the slowest\\nRUN yarn install --frozen-lockfile --production=true --no-progress\\n\\nLABEL description=\\\"My PostGraphile-powered server\\\"\\n\\n# You might want to disable GRAPHILE_TURBO if you have issues\\nENV GRAPHILE_TURBO=1\\nENV NODE_ENV=$NODE_ENV\\nENTRYPOINT yarn start\n```\n\n----------------------------------------\n\nTITLE: Building Static Website Assets with Yarn (Shell)\nDESCRIPTION: Runs the `build` script via Yarn, triggering the Docusaurus build process. This generates the optimized, static HTML, CSS, and JavaScript files for the website into the `build` directory, ready for deployment.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Configuring Node.js Project Dependencies for PostGraphile Library in JSON\nDESCRIPTION: Creates a `package.json` file within the `graphql/src` directory. This file defines the Node.js application's metadata and lists its dependencies, notably `postgraphile` (the core library) and `postgraphile-plugin-connection-filter`. NPM uses this file to install the required packages.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"name\": \"postgraphile-as-library\",\\n  \"version\": \"0.0.1\",\\n  \"description\": \"PostGraphile as a library in a dockerized Node.js application.\",\\n  \"author\": \"Alexis ROLLAND\",\\n  \"license\": \"Apache-2.0\",\\n  \"main\": \"server.js\",\\n  \"keywords\": [\\n    \"nodejs\",\\n    \"postgraphile\"\\n  ],\\n  \"dependencies\": {\\n    \"postgraphile\": \"^4.5.5\",\\n    \"postgraphile-plugin-connection-filter\": \"^1.1.3\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Building Static Website with Yarn - Shell\nDESCRIPTION: This shell command builds a production-ready static version of the documentation site using Docusaurus and Yarn. The output is generated in the build directory, ready to be hosted by any static content hosting service, such as GitHub Pages or Netlify. Ensure that dependencies are installed with yarn before running this command.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn build\n```\n```\n\n----------------------------------------\n\nTITLE: Planning Column-Based Union Handling with pgUnionAll Â· TypeScript\nDESCRIPTION: Uses 'pgUnionAll' to plan resolution of a polymorphic field when multiple columns indicate candidate types. This approach matches each variant by checking the relevant foreign key and plucks the correct resource based on which column is populated. Dependencies include resource instances, Graphile's 'pgUnionAll', and appropriate context for attribute resolution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst plans = {\n  Person: {\n    favourites($person) {\n      const $favourites = personFavouritesResource.find({\n        person_id: $person.get(\"id\"),\n      });\n      return each($favourites, ($favourite) => {\n        const $list = pgUnionAll({\n          attributes: {},\n          resourceByTypeName: {\n            Person: personResource,\n            Post: postResource,\n            Comment: pommentResource,\n          },\n          members: [\n            {\n              typeName: \"Person\",\n              resource: personResource,\n              match: {\n                id: $favourite.get(\"liked_person_id\"),\n              },\n            },\n            {\n              typeName: \"Post\",\n              resource: postResource,\n              match: {\n                id: $favourite.get(\"liked_post_id\"),\n              },\n            },\n            {\n              typeName: \"Comment\",\n              resource: commentResource,\n              match: {\n                id: $favourite.get(\"liked_comment_id\"),\n              },\n            },\n          ],\n        });\n        return $list.single();\n      });\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Querying All Posts and Their Authors with GraphQL\nDESCRIPTION: Shows a GraphQL query to retrieve all posts and each post's associated author's username. Expects the GraphQL schema generated by PostGraphile. The output returns arrays of posts with their fields and nested user data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_24\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  allPosts {\n    nodes {\n      id\n      title\n      body\n      userByAuthorId {\n        username\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Bash)\nDESCRIPTION: Creates a new directory named `project_folder_name` using the `mkdir` command. This is typically the first step in setting up a new project locally before initializing version control or adding dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir project_folder_name\n```\n\n----------------------------------------\n\nTITLE: Defining Independent SQL Tables for Union-Style Interface\nDESCRIPTION: Creates two separate tables, `polymorphic.aws_applications` and `polymorphic.gcp_applications`, representing distinct types of applications with some potentially shared field names but no direct table inheritance or single discriminating column. These will be unified using `@interface mode:union`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.aws_applications (\n  id int primary key,\n  name text not null,\n  last_deployed timestamptz,\n  person_id int references polymorphic.people,\n  organization_id int references polymorphic.organizations,\n  aws_id text\n);\n\ncreate table polymorphic.gcp_applications (\n  id int primary key,\n  name text not null,\n  last_deployed timestamptz,\n  person_id int references polymorphic.people,\n  organization_id int references polymorphic.organizations,\n  gcp_id text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Grafserv Instance in Next.js with JavaScript\nDESCRIPTION: This snippet demonstrates how to initialize a shared Grafserv instance for a Next.js application. It imports the `grafserv` function, a configuration preset, and the GraphQL schema. The `grafserv` function is called with the schema and preset to create a `serv` object, which is then exported for use in specific API route handlers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/next.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// utils/grafserv.mjs\nimport { grafserv } from \"grafserv/next/v13\";\nimport preset from \"./graphile.config.mjs\";\nimport schema from \"./schema.mjs\";\n\n// Create a shared Grafserv instance\nexport const serv = grafserv({ schema, preset });\n```\n\n----------------------------------------\n\nTITLE: Implementing SanitizeHTMLTypePlugin for Graphile Build in TypeScript\nDESCRIPTION: This TypeScript code defines a Graphile Build plugin, `SanitizeHTMLTypePlugin`. It hooks into the 'init' phase to find a PostgreSQL domain type named 'html' in the 'public' schema. If found, it registers the GraphQL 'String' type for both input and output. It then defines a custom mapper (`pg2GqlMapper`) to apply a `sanitize` function (here, `toUpperCase`) when converting data between PostgreSQL and GraphQL, using `sql.fragment` and `sql.value` for safe SQL generation during input conversion.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Author: Benjie Gillam\n// License: https://benjie.mit-license.org/\n//\n// This is a documentation example, you will need to edit it to make it useful.\n// Instructions on running this plugin are at the bottom.\n\n// This function is the one that would perform sanitisation (writing actual\n// sanitisation is left as an exercise to the reader)\nfunction sanitize(html) {\n  return html.toUpperCase();\n}\n\n// Export our plugin function (it can be async if you want)\nmodule.exports = /* async */ function SanitizeHTMLTypePlugin(\n  builder\n) {\n  // Builder is an instance of SchemaBuilder:\n  //\n  //   https://www.graphile.org/graphile-build/schema-builder/\n\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Here we're hooking the init event; this event occurs after the `build`\n  // object is finalised, but before we start building our schema - it's the\n  // perfect time to hook up additional types.\n  //\n  // 'init' is an a-typical hook in that the first argument is meaningless (but\n  // you should still return it at the end of the hook).\n  //\n  // Note all hooks in graphile-build must be synchronous; any async work must be done above here.\n  builder.hook(\"init\", (_, build) => {\n    // The `build` object is an instance of Build: https://www.graphile.org/graphile-build/build-object/\n    // graphile-build-pg adds a bunch of additional helpers to this object:\n    const {\n      pgIntrospectionResultsByKind, // From PgIntrospectionPlugin\n      pgRegisterGqlTypeByTypeId, // From PgTypesPlugin\n      pgRegisterGqlInputTypeByTypeId, // From PgTypesPlugin\n      pg2GqlMapper, // From PgTypesPlugin\n      pgSql: sql, // From PgBasicsPlugin, this is equivalent to `require('pg-sql2')` but avoids multiple-module conflicts\n      graphql, // Equivalent to `require('graphql')` but avoids multiple-module conflicts\n    } = build;\n    const { GraphQLString } = graphql;\n\n    // First we find the type that we care about. In this case we've done\n    //\n    //   CREATE DOMAIN html AS text;\n    // or\n    //   CREATE DOMAIN public.html AS text;\n    //\n    // so we are looking for the 'html' type in the 'public' schema (namespace).\n    const htmlDomain = pgIntrospectionResultsByKind.type.find(\n      type =>\n        type.name === \"html\" &&\n        type.namespaceName ===\n          \"public\"\n    );\n\n    // If this type exists, then...\n    if (htmlDomain) {\n      // Register the *output* type for this type, we just want to use the `String` type\n      pgRegisterGqlTypeByTypeId(\n        htmlDomain.id,\n        () => GraphQLString\n      );\n\n      // Register the *input* type for this type, again we'll use `String`\n      pgRegisterGqlInputTypeByTypeId(\n        htmlDomain.id,\n        () => GraphQLString\n      );\n\n      // The pg2GqlMapper is responsible for translating things from PostgreSQL\n      // into GraphQL and back again.\n      pg2GqlMapper[htmlDomain.id] = {\n        // From Postgres to GraphQL: we simply take the string from postgres\n        // and sanitise it and return the resulting string to GraphQL.\n        map: value => sanitize(value),\n\n        // From GraphQL to SQL: we must construct an SQL fragment that can be\n        // interpolated into larger SQL queries (e.g. as the argument to a\n        // function or the input value for a CREATE/UPDATE mutation). Graphile\n        // uses the pg-sql2 module for this purpose, you can find the docs\n        // here:\n        //\n        //   https://github.com/graphile/pg-sql2/blob/master/README.md\n        //\n        // We're going to take the value (string) the client gave us, stick it\n        // through the sanitise function, then pass it into SQL using\n        // `sql.value` to avoid SQL injection and being sure to cast it to our\n        // HTML type. Note that if you miss the `sql.value(...)` pg-sql2 will\n        // throw an error, so you don't have to worry about accidental SQL\n        // injection - just never use `sql.raw`!\n        unmap: value =>\n          sql.fragment`(${sql.value(\n            sanitize(value)\n          )}::public.html)`,\n      };\n    }\n\n    // All hooks in graphile-build must return something; normally it's an\n    // augmented form of the thing that was passed as the first argument. We\n    // don't manipuate _ at all so we can simply return it.\n    return _;\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server with Yarn - Shell\nDESCRIPTION: This shell command launches the Docusaurus local development server via Yarn. It hosts the site locally and opens a browser window for live preview. Most source code or content changes are reflected live, offering a rapid feedback loop for website development. No special configuration is needed beyond installation.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ yarn start\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Field Function for Post Summary (SQL)\nDESCRIPTION: Creates a PostgreSQL function `post_summary` in the `forum_example` schema. It takes a `forum_example.post` row, an optional `length` (default 50), and an optional `omission` string (default 'â€¦') as input. It returns a truncated version of the post's `body` followed by the omission string, or null if the body is null. Marked `stable`, PostGraphile treats this as a computed field. A comment provides documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.post_summary(\n  post forum_example.post,\n  length int default 50,\n  omission text default 'â€¦'\n) returns text as $$\n  select case\n    when post.body is null then null\n    else substr(post.body, 0, length) || omission\n  end\n$$ language sql stable;\n\ncomment on function forum_example.post_summary(forum_example.post, int, text) is 'A truncated version of the body for summaries.';\n```\n\n----------------------------------------\n\nTITLE: Applying PostGraphile @interface mode:relational Smart Tags in SQL\nDESCRIPTION: Adds a comment to the `polymorphic.relational_items` table with PostGraphile smart tags. `@interface mode:relational type:type` defines it as an interface based on the 'type' column, joining to related tables. `@type` tags specify which table (`references:`) corresponds to each value in the 'type' column.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.relational_items is $$\n  @interface mode:relational type:type\n  @type TOPIC references:relational_topics\n  @type POST references:relational_posts\n  @type DIVIDER references:relational_dividers\n  @type CHECKLIST references:relational_checklists\n  @type CHECKLIST_ITEM references:relational_checklist_items\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Callback Function for loadMany with Attributes - TypeScript\nDESCRIPTION: Defines a reusable callback for loadMany that receives an array of user IDs and an options object containing requested attributes, invoking a business logic fetcher with this information. Enables selective data retrieval based on the accessed fields. Requires getFriendshipsByUserIds function and adherence to the specified callback signature.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst friendshipsByUserIdCallback = (ids, { attributes }) => {\n  // Your business logic would be called here; e.g. this might be the same\n  // function that your DataLoaders would call, except additional information\n  // can be passed to it:\n  return getFriendshipsByUserIds(ids, { attributes });\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin in V4 Style (JavaScript)\nDESCRIPTION: Presents the old V4 plugin structure: an exported function receives the builder, hooks the GraphQLObjectType:fields, and returns extended fields. The callback targets Query fields and injects a static 'four' field. Relies on the builder.hook API and GraphQLInt dependency. Will not work with V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// Version 4 example; will not work with V5!\n// highlight-start\nmodule.exports = (builder) => {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    // highlight-end\n    const {\n      graphql: { GraphQLInt },\n    } = build;\n    const { Self } = context;\n    if (Self.name !== \"Query\") return fields;\n    return build.extend(\n      fields,\n      {\n        four: {\n          type: GraphQLInt,\n          // highlight-start\n          resolve() {\n            return 4;\n          },\n          // highlight-end\n        },\n      },\n      \"Adding Query.four\",\n    );\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Building Static Site for Production with Yarn\nDESCRIPTION: Executes the `build` script via Yarn. This command compiles the Docusaurus project and generates the static HTML, CSS, and JavaScript files into the `build` directory, making the website ready for deployment to any static content hosting service.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Setting Table-Specific Pagination Cap with PostGraphile Smart Comment in SQL\nDESCRIPTION: This SQL statement adds a comment to the 'users' table in PostgreSQL. The comment includes a PostGraphile Pro plugin 'smart comment' (`@paginationCap 20`) which enforces a maximum limit of 20 items that can be requested from connections involving this table, overriding any default pagination cap set via `--default-pagination-cap`. This functionality is specifically provided by the PostGraphile Pro plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/production.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table users is\n  E'@paginationCap 20\\nSomeone who can log in.';\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with UUID v1mc Primary Key in PostgreSQL using SQL\nDESCRIPTION: Provides an alternative method for creating the `person` table using UUIDs (version 1, MAC address based) as primary keys instead of serial integers. It first ensures the `uuid-ossp` extension is available and then defines the `id` column with type `uuid`, setting `uuid_generate_v1mc()` as the default value generator.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"uuid-ossp\";\n\ncreate table forum_example.person (\n  id uuid primary key default uuid_generate_v1mc(),\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Applying Omit Tag via JSONPgSmartTags (JSON5)\nDESCRIPTION: This JSON5 configuration snippet demonstrates how to use `makeJSONPgSmartTagsPlugin`'s input object to apply Smart Tags. It targets all attributes named `created_at` and `updated_at` (using non-fully qualified identifiers) and applies the `omit` tag with the value `\"create,update\"`, preventing these columns from appearing in create or update mutations in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      created_at: { tags: { omit: \"create,update\" } },\n      updated_at: { tags: { omit: \"create,update\" } },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Patch Type Inflector in PostGraphile Plugin (TypeScript)\nDESCRIPTION: This TypeScript snippet provides a plugin that changes the naming pattern from '*Patch' to '*ChangeSet' for patch types by replacing the 'patchType' inflector. It shows how to apply inflector logic using the upperCamelCase helper. The snippet imports required type definitions and defines the replacement within the inflection.replace property. Outputs a new inflector string based on the input type name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\\n  // Unique name for your plugin:\\n  name: \\\"ReplaceInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    replace: {\\n      patchType(previous, preset, typeName) {\\n        return this.upperCamelCase(`${typeName}-change-set`);\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Updating ExecutableStep.execute Method Signature in TypeScript\nDESCRIPTION: Illustrates the required modification to the `execute` method signature for custom step classes inheriting from `ExecutableStep`. The signature changes from accepting individual parameters (`count`, `values`, `extra`) to a single object `ExecutionDetails` containing these properties. It also shows how to process the `newValues` array from the `ExecutionDetails` object to handle both batched (`dep.isBatch`) and non-batched dependency results.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/CHANGELOG.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n- async execute(count: number, values: any[][], extra: ExecutionExtra) {\n+ async execute({ count, values: newValues, extra }: ExecutionDetails) {\n+   const values = newValues.map((dep) =>\n+     dep.isBatch ? dep.entries : new Array(count).fill(dep.value)\n+   );\n    // REST OF YOUR FUNCTION HERE\n  }\n```\n\n----------------------------------------\n\nTITLE: Using makePgSmartTagsFromFilePlugin in TypeScript\nDESCRIPTION: This TypeScript code shows how to import and use `makePgSmartTagsFromFilePlugin` to generate a PostGraphile plugin. The plugin reads Smart Tag definitions from a specified file (e.g., `/path/to/my/tags.file.json5`) and applies them to the schema when included in the preset's `plugins` array.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { makePgSmartTagsFromFilePlugin } from \"postgraphile/utils\";\n\n// highlight-start\nconst SmartTagsPlugin = makePgSmartTagsFromFilePlugin(\n  // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\n  \"/path/to/my/tags.file.json5\",\n);\n// highlight-end\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n  plugins: [\n    // highlight-next-line\n    SmartTagsPlugin,\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images with Docker Compose Commands in Shell\nDESCRIPTION: Provides shell commands using `docker-compose build` to build the Docker images defined in the `docker-compose.yml` file. It shows how to build all service images at once or build images for specific services like `db` or `graphql` individually.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Build images for all services in docker-compose.yml\\n$ docker-compose build\\n\\n# You can also build images one by one\\n# For instance you can build the database image like this\\n$ docker-compose build db\\n\\n# And build the graphql image like this\\n$ docker-compose build graphql\n```\n\n----------------------------------------\n\nTITLE: Migrated Execute Method with Index Mapping (TypeScript)\nDESCRIPTION: This snippet provides an updated implementation of the execute function utilizing the new ExecutionDetails API. It extracts indexMap and values, and efficiently computes results by mapping indices and calling the .at() method on dependency objects. No additional dependencies are required besides the updated type definitions. The function expects ExecutionDetails as input and returns an array of computed results, enabling improved performance and compatibility with the new unary and batch model.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/ev2.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction execute({ indexMap, values }: ExecutionDetails<[number, number]>) {\\n  const [allA, allB] = values;\\n  return indexMap((i) => {\\n    const a = allA.at(i);\\n    const b = allB.at(i);\\n    return a + b;\\n  });\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Heroku Config Variables (Bash)\nDESCRIPTION: Sets multiple configuration variables for a specified Heroku application (`-a myappname`) in a single command. It configures the application environment to 'production' (`NODE_ENV`), enables Graphile optimization (`GRAPHILE_TURBO`), and sets the database connection string (`DATABASE_URL`) with SSL enabled. These variables are accessible as environment variables within the running application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set \\\n    NODE_ENV=\"production\" \\\n    GRAPHILE_TURBO=\"1\" \\\n    DATABASE_URL=\"postgres://username:password@host:port/dbname?ssl=true\" \\\n    -a myappname\n```\n\n----------------------------------------\n\nTITLE: Applying Scoped CSS Class in React JSX - JavaScript\nDESCRIPTION: This snippet demonstrates using a dynamically imported CSS class in the className attribute of a JSX <div> element. By referencing 'styles.graphileHeart', it applies the scoped styling from the imported CSS module to the containing element, ensuring style encapsulation and avoiding CSS leaks. This requires the prior import of the CSS module, as shown in a preceding snippet.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/code-of-conduct.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n<div className={styles.graphileHeart}>\n```\n\n----------------------------------------\n\nTITLE: Opting In to application/x-www-form-urlencoded Content Type in Grafserv - TypeScript\nDESCRIPTION: This snippet configures the Grafserv server to accept 'application/x-www-form-urlencoded' request content types, which is not enabled by default for CSRF protection. By extending the 'grafserv.allowedRequestContentTypes' in a GraphileConfig.Preset, it manually includes the risky content type along with defaults. Imports 'DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES' from 'grafserv'. Useful for legacy clients or explicit opt-in scenarios. Use with caution to avoid security vulnerabilities.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES } from \"grafserv\";\n\nconst preset: GraphileConfig.Preset = {\n  //...\n\n  grafserv: {\n    //...\n\n    allowedRequestContentTypes: [\n      ...DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES,\n      \"application/x-www-form-urlencoded\",\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Combining Plugins with graphile-utils in JavaScript\nDESCRIPTION: This snippet illustrates how to use the makePluginByCombiningPlugins helper from graphile-utils to create a composite plugin from multiple smaller plugins. Dependencies include Node.js and the graphile-utils package (ensure it is installed in your project). The function accepts any number of plugin instances (e.g., plugin1, plugin2) and returns a single plugin which can be exported or used in a PostGraphile server setup. Inputs are the plugins themselves; output is the combined plugin. Ensure all plugins are compatible with each other and with PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-plugin-by-combining-plugins.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { makePluginByCombiningPlugins } = require('graphile-utils');\n\nmodule.exports = makePluginByCombiningPlugins(plugin1, plugin2, ...);\n```\n\n----------------------------------------\n\nTITLE: Defining Quiz and QuizEntry Update Mutation Inputs - GraphQL - GraphQL\nDESCRIPTION: These GraphQL input types supply the required data for update mutations on Quiz and QuizEntry (and QuizEntryAnswer) entities, using either globally unique nodeId or an entity-specific ID alongside a patch for partial updates. 'clientMutationId' is included for tracking by client applications. Dependencies include existence of the referenced Patch types (QuizPatch, QuizEntryPatch, QuizEntryAnswerPatch). Expected input is a JSON object matching GraphQL argument shapes; proper IDs and patch objects must be provided. Limitations include validation of IDs and provided patch object structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"All input for the `updateQuizByNodeId` mutation.\"\"\"\ninput UpdateQuizByNodeIdInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  The globally unique `ID` which will identify a single `Quiz` to be updated.\n  \"\"\"\n  nodeId: ID!\n\n  \"\"\"\n  An object where the defined keys will be set on the `Quiz` being updated.\n  \"\"\"\n  patch: QuizPatch!\n}\n\n\"\"\"All input for the `updateQuizEntryAnswerByNodeId` mutation.\"\"\"\ninput UpdateQuizEntryAnswerByNodeIdInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  The globally unique `ID` which will identify a single `QuizEntryAnswer` to be updated.\n  \"\"\"\n  nodeId: ID!\n\n  \"\"\"\n  An object where the defined keys will be set on the `QuizEntryAnswer` being updated.\n  \"\"\"\n  patch: QuizEntryAnswerPatch!\n}\n\n\"\"\"All input for the `updateQuizEntryAnswer` mutation.\"\"\"\ninput UpdateQuizEntryAnswerInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  An object where the defined keys will be set on the `QuizEntryAnswer` being updated.\n  \"\"\"\n  patch: QuizEntryAnswerPatch!\n  id: Int!\n}\n\n\"\"\"All input for the `updateQuizEntryByNodeId` mutation.\"\"\"\ninput UpdateQuizEntryByNodeIdInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  The globally unique `ID` which will identify a single `QuizEntry` to be updated.\n  \"\"\"\n  nodeId: ID!\n\n  \"\"\"\n  An object where the defined keys will be set on the `QuizEntry` being updated.\n  \"\"\"\n  patch: QuizEntryPatch!\n}\n\n\"\"\"All input for the `updateQuizEntry` mutation.\"\"\"\ninput UpdateQuizEntryInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  An object where the defined keys will be set on the `QuizEntry` being updated.\n  \"\"\"\n  patch: QuizEntryPatch!\n  id: Int!\n}\n\n\"\"\"All input for the `updateQuiz` mutation.\"\"\"\ninput UpdateQuizInput {\n  \"\"\"\n  An arbitrary string value with no semantic meaning. Will be included in the\n  payload verbatim. May be used to track mutations by the client.\n  \"\"\"\n  clientMutationId: String\n\n  \"\"\"\n  An object where the defined keys will be set on the `Quiz` being updated.\n  \"\"\"\n  patch: QuizPatch!\n  id: Int!\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Interfaces for Grafast Execution Details in TypeScript\nDESCRIPTION: Presents simplified TypeScript type definitions for `ExecutionDetails`, `ExecutionValue`, and `GrafastResultsList`. These types define the structure of the data passed to the `execute` method and the expected format of its return value within the Grafast framework. `ExecutionValue` handles both batch and unary dependency results.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// These are simplified types\ninterface ExecutionDetails {\n  count: number;\n  values: [...ExecutionValue[]];\n  indexMap<T>(callback: (i: number) => T): ReadonlyArray<T>;\n  indexForEach(callback: (i: number) => any): void;\n  extra: ExecutionExtra;\n}\n\ntype ExecutionValue<TData> =\n  | { at(i: number): TData; isBatch: true; entries: ReadonlyArray<TData> }\n  | { at(i: number): TData; isBatch: false; value: TData };\n\ntype GrafastResultsList<T> = ReadonlyArray<PromiseOrDirect<T>>;\n```\n\n----------------------------------------\n\nTITLE: Tree Shaking (Pruning) Inactive Plans - Pseudocode\nDESCRIPTION: This algorithm identifies active plans (those referenced in pathIdentity mappings) and marks dependencies as well, removing unused plans by replacing them with null in the Aether's plans list. Helps catch logic errors and reduces memory/processing burden. Input: aether with plans and mappings. Output: pruned plan list with only referenced plans preserved. May be restricted to development modes.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_7\n\nLANGUAGE: pseudocode\nCODE:\n```\nTreeShakePlans(aether):\n\n- Let {activePlans} be an empty list.\n- For each key {pathIdentity} and value {planId} in {aether}.{planIdByPathIdentity}:\n  - Let {plan} be the plan at index {planId} within {aether}.{plans}.\n  - Call {MarkPlanActive(plan, activePlans)}.\n- For each {inactivePlan} with index {i} in {aether}.{plans} where {inactivePlan} isn't in {activePlans}:\n  - Replace the {i}th entry in {aether}.{plans} with {null}.\n\nNote: Replacing inactive plans with null is not strictly necessary, but it may help catch bugs earlier. Maybe only do\nthis in development. Maybe don't do it if it makes the TypeScript too annoying.\n```\n\n----------------------------------------\n\nTITLE: Defining a Schema Hook in Graphile V4 (TypeScript)\nDESCRIPTION: Illustrates the V4 method for registering a schema hook using the procedural `builder.hook` function. This example targets the `GraphQLObjectType:fields` hook. This snippet serves as a comparison for the V5 declarative approach.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst ExamplePlugin: Plugin = (builder) => {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    // ...\n    return fields;\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Properties with te.get in JavaScript\nDESCRIPTION: Demonstrates how to generate a JavaScript property access expression programmatically with te.get. This utility decides whether to use dot notation or bracket notation based on the provided key, which can be a string, symbol, or number. Required dependencies are not specified, but a code emitter context is assumed. Key parameter: key (string | symbol | number), expected output is a string representing a JavaScript property access expression (e.g., .foo or [\"foo\"]).\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-get.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n# `te.get(key)`\n\nReturns an expression for accessing the property `key` (which could be a string,\nsymbol or number) of the preceding expression; will return code like `.foo` or\n`[\"foo\"]` as appropriate.\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Environment Variables - INI\nDESCRIPTION: This .env file sets environment variables used by the PostgreSQL Docker container. It defines the database name (POSTGRES_DB), admin user (POSTGRES_USER), and password (POSTGRES_PASSWORD). These variables are required by the official Postgres image and loaded by Docker Compose. Ensure sensitive values are protected or use Docker Secrets in production.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n# DB\\n# Parameters used by db container\\nPOSTGRES_DB=forum_example\\nPOSTGRES_USER=postgres\\nPOSTGRES_PASSWORD=change_me\n```\n\n----------------------------------------\n\nTITLE: Running Ruru CLI with Proxying (Shell)\nDESCRIPTION: Executes the installed `ruru` command-line tool after installation via Yarn or npm. It connects to a local GraphQL endpoint (`http://localhost:5678/graphql`) and enables proxying (`-P`) to bypass CORS issues and subscriptions (`-S`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn ruru -SPe http://localhost:5678/graphql\n```\n\n----------------------------------------\n\nTITLE: Replacing Plan Methods on PgSelectStep/PgUnionAllStep (TypeScript)\nDESCRIPTION: The plan-time methods `wherePlan` and `havingPlan` on `PgUnionAllStep` (and `PgSelectStep`) have been removed. Use the runtime `apply` method with the `FieldArg` object to modify the query builder instead.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nPgUnionAllStep.wherePlan // Removed\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgUnionAllStep.havingPlan // Removed\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgSelectStep.wherePlan // Removed (implied)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgSelectStep.havingPlan // Removed (implied)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfieldArg.apply($step, qb => qb.whereBuilder()) // Replacement pattern\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfieldArg.apply($step, qb => qb.havingBuilder()) // Replacement pattern\n```\n\n----------------------------------------\n\nTITLE: Implementing V5 Context equivalent for additionalGraphQLContextFromRequest (TypeScript)\nDESCRIPTION: Illustrates the PostGraphile V5 approach for adding custom context based on the incoming HTTP request, replacing the V4 `additionalGraphQLContextFromRequest` option. It uses the `grafast.context` configuration function within the preset definition to access request details (like `req`, `res` from `ctx.node`) and return the additional context object needed by resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req, res } = ctx.node ?? {};\n      return additionalGraphQLContextFromRequest(req, res);\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Types for makeJSONPgSmartTagsPlugin in TypeScript\nDESCRIPTION: Provides the TypeScript type definitions for the `makeJSONPgSmartTagsPlugin` function signature and its associated types (`JSONPgSmartTags`, `SubscribeToJSONPgSmartTagsUpdatesCallback`). It outlines the structure of the JSON configuration object expected (version, config with kinds like class, attribute, constraint, procedure) and the optional callback mechanism for handling updates in watch mode.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makeJSONPgSmartTagsPlugin(\n  json: JSONPgSmartTags | null,\n  subscribeToJSONUpdatesCallback?: SubscribeToJSONPgSmartTagsUpdatesCallback | null,\n): Plugin;\n\ntype JSONPgSmartTags = {\n  version: 1;\n  config: {\n    [kind in PgSmartTagSupportedKinds]?: {\n      [identifier: string]: {\n        tags?: PgSmartTagTags;\n        description?: string;\n        attribute?: {\n          [attributeName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n        constraint?: {\n          [constraintName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n      };\n    };\n  };\n};\n\ntype SubscribeToJSONPgSmartTagsUpdatesCallback = (\n  cb: UpdateJSONPgSmartTagsCallback | null,\n) => void | Promise<void>;\n```\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Test Pattern within Transaction in SQL\nDESCRIPTION: Outlines the SQL pattern for testing database logic within a transaction. It involves starting a transaction (`BEGIN`), setting session-local configurations using `set_config` (e.g., role, JWT claims), running the target SQL (e.g., `my_function()`), and then rolling back (`ROLLBACK`) to ensure test isolation. The `true` flag in `set_config` is crucial for ensuring settings are local to the transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n-- start transaction\nbegin;\n\n-- set relevant transaction settings; the `, true` means \"local\" - i.e. it'll\n-- be rolled back with the transaction - do not forget to add this!\nselect\n  set_config('role', 'YOUR_GRAPHQL_ROLE_HERE', true),\n  set_config('jwt.claims.user_id', 27, true),\n  set_config...;\n\n-- run the SQL you want to test\nselect * from my_function();\n\n-- rollback the transaction\nrollback;\n```\n\n----------------------------------------\n\nTITLE: Granting and Revoking Permissions in Postgres with SQL\nDESCRIPTION: This SQL snippet sets up permissions for roles in a forum_example schema by explicitly revoking default function execution, then granting usage, select, update, delete, insert, and function execution privileges to specific roles. It ensures that both anonymous and authenticated users are only given privileges they need, following the principle of least privilege. Dependencies include an existing forum_example schema with created tables, sequences, and functions, and prerequisite roles forum_example_anonymous and forum_example_person.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_37\n\nLANGUAGE: sql\nCODE:\n```\n-- after schema creation and before function creation\\nalter default privileges revoke execute on functions from public;\\n\\ngrant usage on schema forum_example to forum_example_anonymous, forum_example_person;\\n\\ngrant select on table forum_example.person to forum_example_anonymous, forum_example_person;\\ngrant update, delete on table forum_example.person to forum_example_person;\\n\\ngrant select on table forum_example.post to forum_example_anonymous, forum_example_person;\\ngrant insert, update, delete on table forum_example.post to forum_example_person;\\ngrant usage on sequence forum_example.post_id_seq to forum_example_person;\\n\\ngrant execute on function forum_example.person_full_name(forum_example.person) to forum_example_anonymous, forum_example_person;\\ngrant execute on function forum_example.post_summary(forum_example.post, integer, text) to forum_example_anonymous, forum_example_person;\\ngrant execute on function forum_example.person_latest_post(forum_example.person) to forum_example_anonymous, forum_example_person;\\ngrant execute on function forum_example.search_posts(text) to forum_example_anonymous, forum_example_person;\\ngrant execute on function forum_example.authenticate(text, text) to forum_example_anonymous, forum_example_person;\\ngrant execute on function forum_example.current_person() to forum_example_anonymous, forum_example_person;\\n\\ngrant execute on function forum_example.register_person(text, text, text, text) to forum_example_anonymous;\n```\n\n----------------------------------------\n\nTITLE: Creating Heroku Procfile for PostGraphile CLI (Bash)\nDESCRIPTION: Creates a file named `Procfile` in the current directory and adds a line defining the 'web' process type. This instructs Heroku to run the `postgraphile` command-line interface, connecting using the `$RDS_URL` environment variable and listening on the Heroku-assigned host (`0.0.0.0`) and port (`$PORT`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\necho 'web: postgraphile -c $RDS_URL --host 0.0.0.0 --port $PORT' >> Procfile\n```\n\n----------------------------------------\n\nTITLE: Creating the Forum Post Table in PostgreSQL (SQL)\nDESCRIPTION: Defines the `forum_example.post` table to store forum posts. It includes columns like `id` (primary key), `author_id` (foreign key referencing `forum_example.person`), `headline` (text with length check), `body` (text), `topic` (using the custom `forum_example.post_topic` enum), and `created_at` (timestamp with default). Comments are added for clarity using the `COMMENT ON` command.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.post (\n  id               serial primary key,\n  author_id        integer not null references forum_example.person(id),\n  headline         text not null check (char_length(headline) < 280),\n  body             text,\n  topic            forum_example.post_topic,\n  created_at       timestamp default now()\n);\n\ncomment on table forum_example.post is 'A forum post written by a user.';\ncomment on column forum_example.post.id is 'The primary key for the post.';\ncomment on column forum_example.post.headline is 'The title written by the user.';\ncomment on column forum_example.post.author_id is 'The id of the author user.';\ncomment on column forum_example.post.topic is 'The topic this has been posted in.';\ncomment on column forum_example.post.body is 'The main body text of our post.';\ncomment on column forum_example.post.created_at is 'The time this post was created.';\n```\n\n----------------------------------------\n\nTITLE: Declaring the makeProcessSchemaPlugin Signature in TypeScript\nDESCRIPTION: Defines the TypeScript function signature for makeProcessSchemaPlugin, a PostGraphile utility that accepts a schema processing function. The 'process' parameter receives a GraphQLSchema instance and must return a (possibly modified) GraphQLSchema. The function itself returns a PostGraphile Plugin object. This establishes the interface contract and its synchronous nature, and is crucial when implementing schema manipulation or inspection logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-process-schema-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction makeProcessSchemaPlugin(\n  process: (schema: GraphQLSchema) => GraphQLSchema,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Defining the Dockerfile for the PostGraphile Node.js Application\nDESCRIPTION: Specifies the instructions to build the Docker image for the PostGraphile service in the `graphql/Dockerfile`. It uses the `node:alpine` base image, sets up the working directory, copies the `package.json` file, installs dependencies using `npm install` as the `node` user, copies the application source code (`src` directory), exposes port 8080 (though the app listens on `PORT` env var, Docker Compose handles the mapping), and sets the default command to run the application using `node server.js`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_3\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\\n\\n# Set Node.js app folder\\nRUN mkdir -p /home/node/app/node_modules\\nWORKDIR /home/node/app\\n\\n# Copy dependencies\\nCOPY ./src/package*.json .\\nRUN chown -R node:node /home/node/app\\n\\n# Install dependencies\\nUSER node\\nRUN npm install\\n\\n# Copy application files\\nCOPY --chown=node:node ./src .\\n\\nEXPOSE 8080\\nCMD [ \"node\", \"server.js\" ]\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for Plan Diagram Generation\nDESCRIPTION: This GraphQL query requests the current user's name and the names of their friends. It serves as an example input for which a Grafast plan diagram might be generated.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  currentUser {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Basic Condition in GraphQL\nDESCRIPTION: A GraphQL query demonstrating the default usage of the `condition` argument in PostGraphile to filter `allForums` based on the `creator_id`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsCreatedByUser1 {\n  allForums(condition: { creator_id: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Webpack for Node.js Bundling in JavaScript\nDESCRIPTION: This snippet demonstrates a minimal webpack configuration for bundling a Node.js application such as PostGraphile. It sets the build target to Node.js, adjusts the build context, manages __dirname references, and excludes the pg-native module from being bundled (as it cannot be inlined). Intended for scenarios such as serverless deployments, it presumes knowledge of custom webpack configuration and requires the 'webpack' and 'pg-native' dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/bundling-webpack.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  // All your other webpack options:\n  // ...\n\n  // We're targetting node:\n  target: \"node\",\n\n  // CUSTOMIZE THIS!\n  context: `${__dirname}/app`,\n\n  // Update `__dirname` references to point to the correct location, relative to\n  // `context`:\n  // https://webpack.js.org/configuration/node/#node__dirname\n  node: {\n    __dirname: true,\n  },\n\n  // We cannot bundle native modules, so leave it out:\n  externals: [\"pg-native\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Wrapping Mutation with PostgreSQL Transaction Savepoints (TypeScript)\nDESCRIPTION: TypeScript example demonstrating wrapping the `Mutation.createPost` resolver (Method 1) to integrate custom logic within the existing PostgreSQL transaction provided by PostGraphile via `context.pgClient`. It uses SQL SAVEPOINTs to allow rolling back only the custom logic and the original mutation if the custom code (`doCustomThing`) fails, without aborting the entire transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport const CreatePostPlugin = makeWrapResolversPlugin({\n  Mutation: {\n    createPost: {\n      requires: {\n        childColumns: [{ column: \"id\", alias: \"$post_id\" }],\n      },\n      async resolve(resolve: any, _source, _args, context: any, _resolveInfo) {\n        // The pgClient on context is already in a transaction configured for the user:\n        const { pgClient } = context;\n        // Create a savepoint we can roll back to\n        await pgClient.query(\"SAVEPOINT mutation_wrapper\");\n        try {\n          // Run the original resolver\n          const result = await resolve();\n          // Do the custom thing\n          await doCustomThing(result.data.$post_id);\n          // Finally return the result of our original mutation\n          return result;\n        } catch (e) {\n          // Something went wrong - rollback!\n          // NOTE: Do NOT rollback entire transaction as a transaction may be\n          // shared across multiple mutations. Rolling back to the above defined\n          // SAVEPOINT allows other mutations to succeed.\n          await pgClient.query(\"ROLLBACK TO SAVEPOINT mutation_wrapper\");\n          // Re-throw the error so the GraphQL client knows about it\n          throw e;\n        } finally {\n          await pgClient.query(\"RELEASE SAVEPOINT mutation_wrapper\");\n        }\n      },\n    },\n  },\n});\n\nasync function doCustomThing(postId: number) {\n  throw new Error(\"to be implemented\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting foreignFieldName and fieldName for Relationships via Smart Tags - JSON5\nDESCRIPTION: This JSON5 snippet documents how to apply 'foreignFieldName' and 'fieldName' smart tags to foreign key relationships in the GraphQL schema. These tags adjust how relation fields are named on local and remote types. Intended for use in a smart tags JSON5 configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_8\n\nLANGUAGE: json5\nCODE:\n```\nforeignFieldName: \"threads\",\nfieldName: \"author\"\n```\n\n----------------------------------------\n\nTITLE: Mounting PostGraphile Routes in Fastify v3 using JavaScript\nDESCRIPTION: This snippet demonstrates how to mount various PostGraphile routes onto a Fastify v3 server (`app`) using the `convertHandler` function created previously. It uses properties from the initialized `middleware` object (`middleware.graphqlRoute`, `middleware.graphqlRouteHandler`, `middleware.graphiqlRoute`, etc.) to dynamically get the correct paths and handlers for the GraphQL endpoint (POST, OPTIONS), GraphiQL (HEAD, GET), favicon (GET), and the watch mode event stream (OPTIONS, GET). Conditional mounting based on `middleware.options` is also shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\n// OPTIONS requests, for CORS/etc\napp.options(\n  middleware.graphqlRoute,\n  convertHandler(middleware.graphqlRouteHandler),\n);\n\n// This is the main middleware\napp.post(\n  middleware.graphqlRoute,\n  convertHandler(middleware.graphqlRouteHandler),\n);\n\n// GraphiQL, if you need it\nif (middleware.options.graphiql) {\n  if (middleware.graphiqlRouteHandler) {\n    app.head(\n      middleware.graphiqlRoute,\n      convertHandler(middleware.graphiqlRouteHandler),\n    );\n    app.get(\n      middleware.graphiqlRoute,\n      convertHandler(middleware.graphiqlRouteHandler),\n    );\n  }\n  // Remove this if you don't want the PostGraphile logo as your favicon!\n  if (middleware.faviconRouteHandler) {\n    app.get(\"/favicon.ico\", convertHandler(middleware.faviconRouteHandler));\n  }\n}\n\n// If you need watch mode, this is the route served by the\n// X-GraphQL-Event-Stream header; see:\n// https://github.com/graphql/graphql-over-http/issues/48\nif (middleware.options.watchPg) {\n  if (middleware.eventStreamRouteHandler) {\n    app.options(\n      middleware.eventStreamRoute,\n      convertHandler(middleware.eventStreamRouteHandler),\n    );\n    app.get(\n      middleware.eventStreamRoute,\n      convertHandler(middleware.eventStreamRouteHandler),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Subscription Result Payload Example (Empty Notification) - JSON\nDESCRIPTION: This JSON object demonstrates the payload a GraphQL client receives when a basic NOTIFY with an empty JSON message triggers a subscription. Typically, fields relatedNodeId and relatedNode will be null unless further information is sent. Used for reference in testing and confirming subscription delivery.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"listen\": {\n      \"relatedNodeId\": null,\n      \"relatedNode\": null\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Built-in PostgreSQL Type Codecs using TYPES in TypeScript\nDESCRIPTION: Imports the `TYPES` object from `@dataplan/pg` and demonstrates accessing a predefined codec for the PostgreSQL `int` type. This pattern is used to easily reference standard PostgreSQL data types within the application code.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/codecs.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { TYPES } from \"@dataplan/pg\";\n\nconst intCodec = TYPES.int;\n```\n\n----------------------------------------\n\nTITLE: Mounting Grafserv to a Node HTTP Server (TypeScript)\nDESCRIPTION: This snippet demonstrates the creation of a bare Node HTTP server with error handling, followed by mounting the Grafserv instance to it using the serv.addTo(server) API. The server is then started on a configurable port. Dependencies: node:http, a configured preset, and previously created Grafserv and PostGraphile instances.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from \"node:http\";\nconst server = createServer();\nserver.on(\"error\", (e) => console.error(e));\n\n// highlight-next-line\nserv.addTo(server);\n\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Applying PostGraphile @ref/@refVia Smart Tags (Shorthand Syntax) in SQL\nDESCRIPTION: Demonstrates a shorthand syntax for the `@refVia` smart tag used on the `polymorphic.log_entries` table. Instead of specifying the full join condition like `via:(person_id)->people(person_id)`, it uses the simpler `via:people` when the foreign key relationship is unambiguous within the table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:people\n  @refVia author via:organizations\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Pure GraphQL Resolver Using Context for Dependencies (TypeScript)\nDESCRIPTION: Illustrates rewriting a GraphQL resolver in TypeScript so all external dependencies (such as db) are accessed via the GraphQL context argument, making the function pure and natively exportable. This pattern is the preferred alternative where feasible, eliminating the need for EXPORTABLE. Inputs are pure function arguments; output is the loaded data from db.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst resolvers = {\n  User: {\n    async friends(user, args, context, resolveInfo) {\n      // highlight-start\n      // Extract the dependency from the GraphQL context\n      const { db } = context;\n      // highlight-end\n      return await db.friends.loadMany(user.id, context);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Executing a Custom Mutation in GraphQL\nDESCRIPTION: Illustrates the GraphQL mutation syntax for calling the custom PostgreSQL function `my_function` defined previously. It follows the Relay Input Object Mutations Specification, wrapping arguments (`a`, `b`) within an `input` object. The response selects the `text` field returned by the function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-mutations.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  myFunction(input: { a: 1, b: 2 }) {\n    text\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Node.js Application Dependencies in package.json\nDESCRIPTION: Creates the `package.json` file located in `graphql/src/` for the Node.js application running PostGraphile. It specifies project metadata (name, version, description, author, license, entry point) and lists runtime dependencies like `postgraphile` and `postgraphile-plugin-connection-filter`, which will be installed by npm within the Docker container.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"postgraphile-as-library\",\n  \"version\": \"0.0.1\",\n  \"description\": \"PostGraphile as a library in a dockerized Node.js application.\",\n  \"author\": \"Alexis ROLLAND\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"server.js\",\n  \"keywords\": [\"nodejs\", \"postgraphile\"],\n  \"dependencies\": {\n    \"postgraphile\": \"^4.5.5\",\n    \"postgraphile-plugin-connection-filter\": \"^1.1.3\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector in Graphile Build (JavaScript)\nDESCRIPTION: This JavaScript plugin demonstrates adding a completely new inflector named `myNewInflector`. It uses the `inflection.add` property in the plugin configuration. The new inflector function receives the resolved preset as its first argument, followed by any custom arguments defined (like `columnName`). This example appends 'Something' to the provided column name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\n  name: \"MyNewInflectorPlugin\",\n  version: \"0.0.0\",\n  inflection: {\n    add: {\n      myNewInflector(preset, columnName) {\n        return columnName + \"Something\";\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Global Default Behavior in PostGraphile Configuration (JavaScript)\nDESCRIPTION: Demonstrates setting the `defaultBehavior` property within the PostGraphile preset configuration (`graphile.config.mjs`). This example configures the schema to favor lists (`+list`) and disable connections (`-connection`) by default for all entities.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/behavior.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// graphile.config.mjs\n\nconst preset = {\n  //...\n  schema: {\n    //...\n    defaultBehavior: \"-connection +list\",\n  },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Schemas in PostgreSQL - SQL\nDESCRIPTION: Defines two PostgreSQL schemas, 'forum_example' for publicly accessible forum data and 'forum_example_private' for internal/private use. This foundational structure is essential for logically separating application data and enforcing security at the schema level. Requires PostgreSQL, with no extra dependencies. Intended to be executed in a SQL session before defining tables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema forum_example;\ncreate schema forum_example_private;\n```\n\n----------------------------------------\n\nTITLE: Adding updated_at Columns to Tables using SQL ALTER TABLE\nDESCRIPTION: Modifies the `forum_example.person` and `forum_example.post` tables by adding a new column named `updated_at` of type `timestamp`. This column is configured to default to the current timestamp (`now()`) when a new row is inserted, mirroring the behavior of a `created_at` column initially. This is a prerequisite for implementing an update trigger.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_17\n\nLANGUAGE: sql\nCODE:\n```\nalter table forum_example.person add column updated_at timestamp default now();\nalter table forum_example.post add column updated_at timestamp default now();\n```\n\n----------------------------------------\n\nTITLE: Express Middleware for GraphQL-Compatible Auth Error Handling - JavaScript\nDESCRIPTION: This snippet provides middleware for Express to catch 'UnauthorizedError' exceptions thrown by 'express-jwt' during JWT verification. It logs the error internally and sends a GraphQL-compliant JSON error response with HTTP 401 status, instead of sending a default HTML error. This ensures client applications receive structured error feedback consistent with GraphQL APIs. Must be applied after the authentication middleware. Dependencies: Express.js, 'express-jwt'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst authErrors = (err, req, res, next) => {\n  if (err.name === \"UnauthorizedError\") {\n    console.log(err); // You will still want to log the error...\n    // but we don't want to send back internal operation details\n    // like a stack trace to the client!\n    res.status(err.status).json({ errors: [{ message: err.message }] });\n    res.end();\n  }\n};\n\n// Apply error handling to the graphql endpoint\napp.use(\"/graphql\", authErrors);\n```\n\n----------------------------------------\n\nTITLE: Building and Printing a GraphQL Schema with Preset (JavaScript)\nDESCRIPTION: This snippet shows how to use a preset (such as the one defined in 'graphile.config.mjs') to build and print a GraphQL schema using Graphile Build. The workflow involves importing the preset, invoking 'buildSchema' to generate a schema, and then using GraphQL's 'printSchema' to output its structure. Dependencies: 'graphile-build', 'graphql', and a valid Graphile preset file.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { buildSchema } from \\\"graphile-build\\\";\nimport { printSchema } from \\\"graphql\\\";\nimport preset from \\\"./graphile.config.mjs\\\";\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n```\n\n----------------------------------------\n\nTITLE: Implementing V5 Context equivalent for pgSettings (TypeScript)\nDESCRIPTION: Shows the recommended PostGraphile V5 method for dynamically setting PostgreSQL session settings based on the incoming request, replacing the V4 `pgSettings` function option. This is achieved by returning a `pgSettings` key (whose value is determined potentially by the request object `req`) within the object returned by the `grafast.context` configuration function in the preset.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req } = ctx.node ?? {};\n      return {\n        pgSettings: pgSettings(req);\n      };\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions on Tables in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet exhibits granular control over table permissions by granting 'select', 'insert' (on specific columns), 'update' (on other columns), and 'delete' rights on 'my_table' to the 'app_visitor' role. It highlights recommendations such as whitelisting writeable columns and avoiding column-level 'select' grants, which affects API behaviors like 'select *'. This requires existing tables, target role, and is a key setup step for safe database access within a RBAC model.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ngrant\n  select,\n  insert (column_1, column_2),\n  update (column_2, column_3),\n  delete\non my_table to app_visitor;\n```\n\n----------------------------------------\n\nTITLE: Marking `loadOne` as Having Side Effects in TypeScript\nDESCRIPTION: Demonstrates an alternative approach for mutations requiring batching. Instead of using `sideEffect`, this snippet uses `loadOne` to perform an operation (calculating a random number based on min/max inputs) and then explicitly marks the resulting step (`$random`) as having side effects by setting its `hasSideEffects` property to `true`. This allows leveraging `loadOne`'s batching capabilities while still indicating the operation modifies state.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $random = loadOne(list([$min, $max]), (tuples) =>\n  tuples.map(([min, max]) => min + Math.floor(Math.random() * (max - min + 1))),\n);\n$random.hasSideEffects = true;\n\nreturn $random;\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Forums Ordered by Latest Post Date (Custom Order) in GraphQL\nDESCRIPTION: This GraphQL query demonstrates using the custom ordering defined by the example plugin. It fetches all forums ordered by the `LAST_POST_CREATED_AT_DESC` value, effectively sorting forums from the one with the most recent post to the one with the oldest post. It retrieves the `id` and `name` for each forum.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery ForumsOrderedByMostRecentPost {\n  allForums(orderBy: [LAST_POST_CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple PL/pgSQL Function in PostgreSQL\nDESCRIPTION: Defines the `add` function using the `plpgsql` procedural language. It accepts two integers (`a`, `b`) and returns their sum within a `BEGIN...END` block. Like the SQL version, it's marked `IMMUTABLE` and `STRICT`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\nBEGIN\n  RETURN a + b;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n```\n\n----------------------------------------\n\nTITLE: Defining a JWT Token Composite Type in PostgreSQL (SQL)\nDESCRIPTION: Shows how to create a composite PostgreSQL type to represent a JWT token with explicit fields: 'role', 'person_id', and 'exp'. This composite type enables the database to structure JWT payload data, facilitating integration between PostgreSQL authentication logic and PostGraphile's JWT service. Dependencies: a suitable schema (e.g., forum_example) and appropriate privileges to run CREATE TYPE.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_30\n\nLANGUAGE: sql\nCODE:\n```\ncreate type forum_example.jwt_token as (\n  role text,\n  person_id integer,\n  exp bigint\n);\n```\n\n----------------------------------------\n\nTITLE: Defining STABLE and IMMUTABLE SQL Functions\nDESCRIPTION: Provides examples of defining SQL functions marked as `STABLE` or `IMMUTABLE`. `STABLE` indicates the function doesn't modify data and returns consistent results within a single scan, while `IMMUTABLE` guarantees results depend solely on arguments. Also demonstrates returning a table row (`my_table`). PostGraphile typically exposes these as queries or computed columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_16\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql STABLE;\n\n-- orâ€¦\n\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql IMMUTABLE;\n\n-- or if you wanted to return a row from a tableâ€¦\n\nCREATE FUNCTION my_function(a int, b int) RETURNS my_table AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Node.js Project and Start Script for PostGraphile CLI on GCP using JSON\nDESCRIPTION: Configures a Node.js project using `package.json` for deployment to GCP. It defines project metadata, specifies the `postgraphile` dependency, sets required Node.js/npm engine versions, and includes a `start` script. The `start` script executes `postgraphile` with specific flags (`--host 0.0.0.0`, `--port 8080`, `--cors`, `--enhance-graphiql`, `--graphql /`) and the database connection string (`-c postgres://user:password@172.17.0.1:5432/str_dev`) tailored for GCP App Engine.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"myprojectname\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"postgraphile --host --port 8080 --cors --enhance-graphiql --graphql / 0.0.0.0 -c postgres://user:password@172.17.0.1:5432/str_dev\"\n  },\n  \"engines\": {\n    \"node\": \"^10.15\",\n    \"npm\": \"^6.9\"\n  },\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"postgraphile\": \"^4.4.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming a Table Column using Smart Comments in SQL\nDESCRIPTION: Adds a `COMMENT` statement to the `col1` column of the `original_table` table. The `@name` smart tag within the comment instructs PostGraphile to rename this column to `colA` in the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column original_table.col1 is E'@name colA';\n```\n\n----------------------------------------\n\nTITLE: Configuring Node.js Build/Start Scripts and Engine in package.json (JSON)\nDESCRIPTION: Shows an example fragment of a `package.json` file configuring essential settings for a Node.js application on Heroku. It defines a `build` script (e.g., for TypeScript compilation with `tsc`), a `start` script (to run the application server with `node server.js`), and specifies the required Node.js runtime version (`12.x`) using the `engines` field.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node server.js\"\n  },\n  \"engines\": {\n    \"node\": \"12.x\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL API Route with Websockets in Nuxt using TypeScript\nDESCRIPTION: This snippet demonstrates creating a GraphQL endpoint in a Nuxt project with websocket support (requires h3@^1.13.0). It exports an event handler composed of both a request handler and a websocket handler, allowing both traditional HTTP and websocket-based GraphQL connections. The implementation relies on the previously instantiated 'serv' from Grafserv, and uses 'makeWsHandler()' for websocket events. Dependencies include 'h3', a compatible version (>=1.13.0), and the shared 'serv'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/nuxt.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { eventHandler } from \\\"h3\\\";\nimport { serv } from \\\"@/server/grafserv/serv\\\";\n\nexport default eventHandler({\n  // Create and export the `/api/graphql` route handler\n  handler: (event) => serv.handleGraphQLEvent(event),\n  // Create and export the `/api/graphql` websocket handler\n  websocket: serv.makeWsHandler(),\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Inflection with a JavaScript Plugin\nDESCRIPTION: This JavaScript code defines a simple PostGraphile inflection plugin. It overrides the `getOppositeBaseName` inflector to specify that the opposite of 'distributor' should be 'distributed'. This allows for customized naming of reverse relationships (e.g., generating `distributedBeverages` on the `Company` type based on the `distributor_id` foreign key).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst plugin = {\n  name: \"MyCustomInflectionPlugin\",\n  version: \"0.0.0\",\n  inflection: {\n    replace: {\n      getOppositeBaseName(previous, options, baseName) {\n        return (\n          {\n            // These are the default opposites\n            parent: \"child\",\n            child: \"parent\",\n            author: \"authored\",\n            editor: \"edited\",\n            reviewer: \"reviewed\",\n\n            // ðŸ‘‡ Add/customise this line:\n            distributor: \"distributed\",\n          }[baseName] || previous(baseName)\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Tables and Functions Accepting nodeId Arguments (SQL)\nDESCRIPTION: This SQL code creates two tables, 'entity_a' and 'entity_b', each with a UUID primary key, and a join table 'junction' with foreign keys referencing the first two. It then defines the 'add_junction_entry' function for inserting a new junction row by extracting IDs from composite type arguments and marks its arguments as accepting nodeId. Dependencies are PostgreSQL and, optionally, PostGraphile's smart tagging for argument variants. Inputs are two records of types entity_a and entity_b; the function inserts a corresponding row into 'junction' and returns it. Smart tags facilitate GraphQL-level parameter mapping.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/node-id.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table entity_a(\n  id uuid primary key\n);\n\ncreate table entity_b(\n  id uuid primary key\n);\n\ncreate table junction(\n  a_id uuid REFERENCES entity_a(id),\n  b_id uuid REFERENCES entity_b(id),\n  primary key (a_id, b_id)\n);\n\ncreate function add_junction_entry(a entity_a, b entity_b) returns junction as $$\n  insert into junction values (a.id, b.id) returning *;\n$$ language sql volatile;\n\ncomment on function add_junction_entry(a entity_a, b entity_b) is $$\n  @arg0variant nodeId\n  @arg1variant nodeId\n$$;\n```\n\n----------------------------------------\n\nTITLE: Enabling SQL Explain Logging via DEBUG Environment Variable (Windows Console)\nDESCRIPTION: This Windows Console (cmd.exe) command uses the `set` command to assign the value `@dataplan/pg:PgExecutor:explain` to the `DEBUG` environment variable. Subsequently running PostGraphile (`postgraphile -c ...`) in the same console session will trigger the output of SQL EXPLAIN results.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_3\n\nLANGUAGE: batch\nCODE:\n```\n# Windows Console\nset DEBUG=@dataplan/pg:PgExecutor:explain & postgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Setting Grafast Optimization Flag in JavaScript\nDESCRIPTION: This code snippet demonstrates setting the `isSyncAndSafe` property to `true` on a function (`fn`). This flag indicates to the Grafast engine that the function is synchronous and safe to optimize, a pattern now automatically detected and handled by `graphile-export`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/CHANGELOG.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfn.isSyncAndSafe=true\n```\n\n----------------------------------------\n\nTITLE: Defining Heroku Web Process with Yarn Start (Procfile)\nDESCRIPTION: Defines the `web` process type in a Heroku `Procfile`. This specific configuration tells Heroku to execute the `yarn start` command (defined in `package.json`) to launch the application's web server. This approach is common when PostGraphile is used as a library within a custom Node.js application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_9\n\nLANGUAGE: procfile\nCODE:\n```\nweb: yarn start\n```\n\n----------------------------------------\n\nTITLE: Querying Data for Array Reconstitution in PostgreSQL\nDESCRIPTION: This SQL query demonstrates retrieving data from a PostgreSQL function (`random_user_array_set`) that returns sets of arrays. It uses `with ordinality` and `unnest` to flatten the structure into rows, including an `array_idx` to indicate which original sub-array each row belongs to. This flat structure requires subsequent processing (like `listTransform`) to reconstruct the intended nested array format.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/pages/plans/listTransform.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n# select array_idx, b.id, b.username\n  from random_user_array_set() with ordinality as a (arr, array_idx)\n  cross join lateral unnest(arr) as b;\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ array_idx â”‚                  id                  â”‚ username â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚         1 â”‚ b0b00000-0000-0000-0000-000000000b0b â”‚ Bob      â”‚\nâ”‚         2 â”‚ a11ce000-0000-0000-0000-0000000a11ce â”‚ Alice    â”‚\nâ”‚         2 â”‚ cec111a0-0000-0000-0000-00000cec111a â”‚ Cecilia  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n----------------------------------------\n\nTITLE: Initializing a Project Directory and Node.js Project - Bash\nDESCRIPTION: This Bash snippet creates a new directory for a PostGraphile/Express project and initializes it as a Node.js project. It requires Bash and npm tools. It creates the folder structure and a package.json via 'npm init -y'. Outputs are the filesystem changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nmkdir postgraphile_express\ncd postgraphile_express\nnpm init -y\n```\n\n----------------------------------------\n\nTITLE: Configuring Module and Resolution in TypeScript - JSON\nDESCRIPTION: This snippet shows an explicit 'tsconfig.json' setup for TypeScript, setting the 'module' and 'moduleResolution' compiler options to 'Node16'. This is an alternative to extending a preset, allowing direct control over TypeScript's module system. It requires no dependencies except for TypeScript itself. The file should be saved as 'tsconfig.json', with the settings ensuring correct ES module resolution and preventing issues with legacy CommonJS imports.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"compilerOptions\\\": {\\n    \\\"module\\\": \\\"Node16\\\",\\n    \\\"moduleResolution\\\": \\\"Node16\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting CRUD Operations via @omit Smart Comment in SQL\nDESCRIPTION: Shows how to apply an `@omit` smart comment to the existing `forum_example.book` table to exclude `create`, `update`, and `delete` mutations from the GraphQL schema generated by PostGraphile. This modifies the previous example to omit the create operation as well.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_26\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.book is E'@omit create,update,delete';\n```\n\n----------------------------------------\n\nTITLE: Getting Result from Batch (Pseudocode)\nDESCRIPTION: Adds a parent Crystal object to a batch and returns a deferred result (e.g., a promise or future). This function allows field resolution to request data from a batch and receive a placeholder that will be resolved later when the batch is executed by `ExecuteBatch`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_43\n\nLANGUAGE: pseudocode\nCODE:\n```\nGetBatchResult(batch, parentCrystalObject):\n\n- Let {deferredResult} be a new {Defer}.\n- Push the tuple `[parentCrystalObject, deferredResult]` onto {batch}.{entries}.\n- Return {deferredResult}.\n```\n\n----------------------------------------\n\nTITLE: Defining the deduplicate Method Signature for a Grafast Step Class in TypeScript\nDESCRIPTION: Shows the TypeScript signature for the optional `deduplicate` lifecycle method in a Grafast `Step` subclass. This method is called with peer steps (same class and dependencies) and should return the subset of peers that are equivalent, enabling Grafast to optimize the execution plan.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeduplicate(\n  peers: readonly Step[]\n): readonly Step[]\n```\n\n----------------------------------------\n\nTITLE: Creating a Plugin to Enforce Non-Null Relations - GraphileConfig Plugin - typescript\nDESCRIPTION: This TypeScript snippet defines a GraphileConfig plugin (NonNullRelationsPlugin) for PostGraphile that dynamically wraps certain relation fields as non-nullable GraphQL fields if all corresponding columns are not null in the schema. It inspects registry metadata and selectively adjusts the output types. Dependencies: PostGraphile infrastructure, GraphileConfig.Plugin, proper schema build context. Input: none; Output: modifies field nullability in the GraphQL API. Limitation: applies only to forward relation fields meeting the criteria.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/why-nullable.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"const NonNullRelationsPlugin: GraphileConfig.Plugin = {\\n  name: \\\"NonNullRelationsPlugin\\\",\\n  description:\\n    \\\"Makes foreign key fields non-nullable if their columns are all `not null`\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  schema: {\\n    hooks: {\\n      // Hook a field that has already been defined\\n      GraphQLObjectType_fields_field(field, build, context) {\\n        const {\\n          graphql: { GraphQLNonNull, getNullableType },\\n          input: { pgRegistry },\\n        } = build;\\n        // Extract details about why this field was defined.\\n        const { isPgSingleRelationField, pgRelationDetails } = context.scope;\\n        // See if the field was defined for a singular relation\\n        if (isPgSingleRelationField && pgRelationDetails) {\\n          // If so, extract details about the relation\\n          const { codec, relationName } = pgRelationDetails;\\n          // Look up the relation in the registry\\n          const relation = pgRegistry.pgRelations[codec.name][relationName];\\n          // Determine if every column is non-null\\n          const everyColumnIsNonNull = relation.localAttributes.every(\\n            (attrName) => codec.attributes[attrName].notNull,\\n          );\\n          if (!relation.isReferencee && everyColumnIsNonNull) {\\n            // If so, change the type of the field to be non-nullable\\n            field.type = new GraphQLNonNull(getNullableType(field.type));\\n          }\\n        }\\n        return field;\\n      },\\n    },\\n  },\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Planning an Aether Subscription - Pseudocode\nDESCRIPTION: This pseudocode details the construction and validation of a GraphQL subscription plan, including verifying the root selection structure and supporting subscription resolvers. It requires field grouping, variable value tracking, and fallback selection planning. The approach ensures subscription compliance and correctness through structured planning stages.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_25\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanAetherSubscription(aether):\n\n- Let {rootType} be the root Subscription type in {aether}.{schema}.\n- Assert {rootType} exists.\n- Let {selectionSet} be the top level Selection Set in {aether}.{operation}.\n- Let {trackedVariableValuesPlan} be {aether}.{trackedVariableValuesPlan}.\n- Let {groupedFieldSet} be the result of {GraphQLCollectFields(rootType, selectionSet, trackedVariableValuesPlan)}.\n- If {groupedFieldSet} does not have exactly one entry, throw a query error.\n- Let {fields} be the value of the first entry in {groupedFieldSet}.\n- Let {fieldName} be the name of the first entry in {fields}. Note: This value is unaffected if an alias is used.\n- Let {field} be the first entry in {fields}.\n- Let {fieldSpec} be the field named {fieldName} on {rootType}.\n- Let {subscriptionPlanResolver} be `fieldSpec.extensions.graphile.subscribePlan`.\n- If {subscriptionPlanResolver} exists:\n  - Let {trackedArguments} be {TrackedArguments(aether, rootType, field)}.\n  - Let {trackedRootValuePlan} be {aether}.{trackedRootValuePlan}.\n  - Let {subscribePlan} be the result of calling {subscriptionPlanResolver}, providing {trackedRootValuePlan},\n    {trackedArguments}, {aether}.{trackedContextPlan}.\n  - Call {PlanFieldArguments(aether, field, trackedArguments, subscribePlan)}.\n- Otherwise:\n  - Let {subscribePlan} be {aether}.{trackedRootValuePlan}.\n- Call {PlanSelectionSet(aether, \"\", subscribePlan, rootType, selectionSet)}.\n```\n\n----------------------------------------\n\nTITLE: Getting a Polymorphic Object Plan for a Type - Pseudocode\nDESCRIPTION: This snippet provides the pseudocode for obtaining a concrete plan for a specific object type from a polymorphic plan (such as an interface or union). It invokes the plan's internal `planForType` procedure to generate an executable plan for the provided type. Inputs include the aether context, the polymorphic plan, and the object type in question.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_22\n\nLANGUAGE: pseudocode\nCODE:\n```\nGetPolymorphicObjectPlanForType(aether, polymorphicPlan, objectType):\n\n- Note: {polymorphicPlan} represents an interface or union.\n- Let {planForType} be the internal function provided by {polymorphicPlan} to return a plan for a given object type.\n- Assert {planForType} is not {null}.\n- Let {objectPlan} be the result of calling {planForType}, passing {aether}, {polymorphicPlan} and {objectType}.\n- Return {objectPlan}.\n```\n\n----------------------------------------\n\nTITLE: Granting Role Permission for PostgreSQL in Cloud SQL - SQL\nDESCRIPTION: This SQL command snippet grants the 'anonymous' role to the 'postgres' user, essential for applications deployed on Google Cloud SQL where the default 'postgres' user doesn't have superuser rights as in local development. No dependencies other than appropriate database access rights. Input: anonymous role and postgres user must already exist. Output: enables SET LOCAL role switching to 'anonymous' in SQL sessions. Limitation: Only permissions are granted; roles must pre-exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nGRANT anonymous TO postgres;\n```\n\n----------------------------------------\n\nTITLE: Referencing PostgreSQL 'array_agg()' Function\nDESCRIPTION: References the PostgreSQL aggregate function 'array_agg()'. The changelog notes that a bug related to empty arrays becoming null, caused by the use of this function, has been fixed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n`array_agg()`\n```\n\n----------------------------------------\n\nTITLE: Wrapping Data with Crystal Context (Pseudocode)\nDESCRIPTION: Recursively wraps raw data according to the GraphQL return type, creating Crystal objects where appropriate. It handles null values, non-null types, and list types. For object types, it creates a new Crystal object using `NewCrystalObject`, associating it with the plan, parent object, path, and other contextual information.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_36\n\nLANGUAGE: pseudocode\nCODE:\n```\nCrystalWrap(crystalContext, plan, returnType, parentCrystalObject, pathIdentity, id, data, indexes):\n\n- If {indexes} is not set, initialize it to an empty list.\n- If {data} is {null}:\n  - Return {null}.\n- Otherwise, if {returnType} is a non-null type:\n  - Let {innerType} be the inner type of {returnType}.\n  - Return {CrystalWrap(crystalContext, plan, innerType, parentCrystalObject, pathIdentity, id, data)}.\n- Otherwise, if {returnType} is a list type:\n  - Let {innerType} be the inner type of {returnType}.\n  - Let {result} be an empty list.\n  - For each {entry} with index {index} in {data}:\n    - Let {wrappedIndexes} be a list composed of everything in {indexes} followed by {index}.\n    - Let {wrappedEntry} be {CrystalWrap(crystalContext, plan, innerType, parentCrystalObject, pathIdentity, id, entry,\n      wrappedIndexes)}.\n    - Push {wrappedEntry} onto {result}.\n  - Return {result}.\n- Otherwise:\n  - If {parentCrystalObject} is provided:\n    - Let {idByPathIdentity} be a reference to {parentCrystalObject}'s {idByPathIdentity}.\n    - Let {indexesByPathIdentity} be a reference to {parentCrystalObject}'s {indexesByPathIdentity}.\n  - Let {crystalObject} be {NewCrystalObject(plan, pathIdentity, id, indexes, data, crystalContext, idByPathIdentity,\n    indexesByPathIdentity)}.\n  - Return {crystalObject}.\n```\n\n----------------------------------------\n\nTITLE: Generic PostgreSQL Trigger Function for GraphQL Subscriptions (SQL)\nDESCRIPTION: Defines a PL/pgSQL function for use as a trigger to emit subscription notification events in response to INSERT, UPDATE, or DELETE operations. Parameters let you specify the event type, topic template, and primary key attribute for substitution. Publishes a JSON event to the specified topic via pg_notify. Requires: PostgreSQL, table with 'id' primary key field (or modification), and appropriate privileges. May require adjustment if table does not use 'id' as PK.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function tg__graphql_subscription() returns trigger\n    language plpgsql\n    as $_$\ndeclare\n  v_process_new bool = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE');\n  v_process_old bool = (TG_OP = 'UPDATE' OR TG_OP = 'DELETE');\n  v_event text = TG_ARGV[0];\n  v_topic_template text = TG_ARGV[1];\n  v_attribute text = TG_ARGV[2];\n  v_record record;\n  v_sub text;\n  v_topic text;\n  v_i int = 0;\n  v_last_topic text;\nbegin\n  for v_i in 0..1 loop\n    if (v_i = 0) and v_process_new is true then\n      v_record = new;\n    elsif (v_i = 1) and v_process_old is true then\n      v_record = old;\n    else\n      continue;\n    end if;\n     if v_attribute is not null then\n      execute 'select $1.' || quote_ident(v_attribute)\n        using v_record\n        into v_sub;\n    end if;\n    if v_sub is not null then\n      v_topic = replace(v_topic_template, '$1', v_sub);\n    else\n      v_topic = v_topic_template;\n    end if;\n    if v_topic is distinct from v_last_topic then\n      -- This if statement prevents us from triggering the same notification twice\n      v_last_topic = v_topic;\n      perform pg_notify(v_topic, json_build_object(\n        'event', v_event,\n        'subject', v_sub,\n        /* highlight-next-line */\n        'id', v_record.id\n      )::text);\n    end if;\n  end loop;\n  return v_record;\nend;\n$_$;\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile CLI with npx - Shell Script\nDESCRIPTION: Shows how to run the PostGraphile CLI with the beta version using npx, specifying the amber preset, enabling schema export, and providing a PostgreSQL connection string. Assumes availability of Node.js, npx, and a valid PostgreSQL database. Key parameters: '-P' for preset, '-e' for exporting the schema, and '-c' for the connection string. Expects users to replace the connection string as appropriate; the command auto-detects schemas or can be directed with '-s'. Output includes CLI logs and possibly exported schema files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/index.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx pgl@beta -P pgl/amber -e -c 'postgres:///mydb'\n```\n\n----------------------------------------\n\nTITLE: Renaming PostgreSQL Configuration and Service Name Identifiers\nDESCRIPTION: Details the renaming of `PgDatabaseConfiguration` to `PgServiceConfiguration` and the configuration property `databaseName` to `serviceName`. The latter clarifies it refers to the `pgServices` entry name, not the database name.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nPgDatabaseConfiguration -> PgServiceConfiguration\ndatabaseName -> serviceName\n```\n\n----------------------------------------\n\nTITLE: Executing Functions Wrapped by EXPORTABLE in JavaScript\nDESCRIPTION: Confirms that a function wrapped with `EXPORTABLE` retains its original functionality and can be executed normally, returning the expected result. It also shows that `toString()` still returns the inner function's source code.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n> add(3)\n10\n> add.toString()\n'function add(b) { return a + b; }'\n```\n\n----------------------------------------\n\nTITLE: Referencing External Values with te.ref in JavaScript\nDESCRIPTION: This snippet shows how to use te.ref() to reference an external JavaScript variable in generated function code using the te templating engine. It demonstrates the default behavior, where the identifier for the reference is randomized to prevent conflicts. Dependencies include the te template engine, assert for validation, and a Source class. Parameters include 'source' (the referenced object) and 'spec' (the string literal); the generated code uses these parameters to create a new function plan. The output is a function as a string, ensuring injected variables are referenced correctly. Limitations: Identifier names are not controlled by the user unless a name is specified.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-ref.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst source = new Source(/* ... */);\nconst spec = \"some string here\";\n\nconst plan = te.run`\\\n  const source = ${te.ref(source)};\n  return function plan($record) {\n    const $records = source.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in JavaScript/JSX\nDESCRIPTION: This snippet imports CSS styles defined in `common.module.css` using the CSS Modules pattern. The imported `styles` object allows applying class names like `styles.graphileHeart` to JSX elements for scoped styling. Requires a build system configured for CSS Modules (like in Docusaurus).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/community-chat.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Planning GraphQL Field Arguments (Pseudocode)\nDESCRIPTION: Details the `PlanFieldArguments` algorithm, which iterates through the arguments specified for a field in the schema. For each argument that has a corresponding value provided in the query (tracked via `trackedArguments`), it calls the `PlanFieldArgument` function to handle the planning for that specific argument.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_28\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanFieldArguments(aether, objectType, field, trackedArguments, fieldPlan):\n\n- Let {fieldName} be the name of {field}.\n- Let {fieldSpec} be the field named {fieldName} on {objectType}.\n- For each argument {argumentSpec} in {fieldSpec}:\n  - Let {argumentName} be the name of {argument}.\n  - Let {trackedArgumentValuePlan} be the value for {argumentName} within {trackedArguments}.\n  - If {trackedArgumentValuePlan} is defined (including {null}):\n    - Call {PlanFieldArgument(aether, objectType, field, argument, trackedArgumentValuePlan, fieldPlan)}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Updating Grafast Plugin Hook to Middleware in TypeScript\nDESCRIPTION: Illustrates the migration from the deprecated `grafast.hooks.args` to the new `grafast.middleware.prepareArgs` within a Graphile Crystal plugin, as introduced in version 0.0.1-beta.9. This change requires updating the function signature to accept `next` and extracting context (`ctx`) and `resolvedPreset` directly from the `args` object. An explicit call to `next()` is necessary to continue the middleware chain.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-config/CHANGELOG.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n```diff\\n const plugin = {\\n   grafast: {\\n-    hooks: {\\n+    middleware: {\\n-      args({ args, ctx, resolvedPreset }) {\\n+      prepareArgs(next, { args }) {\\n+        const { requestContext: ctx, resolvedPreset } = args;\\n         // ...\\n+        return next();\\n       }\\n     }\\n   }\\n }\\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Single Test File Snapshots with Jest (Shell)\nDESCRIPTION: Navigates into a specific package directory (`postgraphile/postgraphile`) and runs `jest` directly on a single test file (`__tests__/path/to/test.file.graphql`). The `UPDATE_SNAPSHOTS=1` environment variable ensures that snapshots for only this specific file are updated.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ncd postgraphile/postgraphile\nUPDATE_SNAPSHOTS=1 yarn jest __tests__/path/to/test.file.graphql\n```\n\n----------------------------------------\n\nTITLE: Initial Project Directory Structure\nDESCRIPTION: Displays the expected file and folder layout for the project after setting up the initial database configuration files (`00-database.sql`, `01-data.sql`, `Dockerfile` within `db/`) and the root-level `.env` and `docker-compose.yml` files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Creating Application Tables for Union Polymorphism - SQL\nDESCRIPTION: Creates separate tables for AWS and GCP applications, each with provider-specific identifiers but sharing common fields. Foreign keys reference people and organizations, which should exist. These tables are later unified into a GraphQL interface using smart tags and a composite type. Useful for scenarios where several implementations share some structural similarities but are normalized.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.aws_applications (\n  id int primary key,\n  name text not null,\n  last_deployed timestamptz,\n  person_id int references polymorphic.people,\n  organization_id int references polymorphic.organizations,\n  aws_id text\n);\n\ncreate table polymorphic.gcp_applications (\n  id int primary key,\n  name text not null,\n  last_deployed timestamptz,\n  person_id int references polymorphic.people,\n  organization_id int references polymorphic.organizations,\n  gcp_id text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Deploying with SSH using Yarn - Shell\nDESCRIPTION: This shell command deploys the built Docusaurus site using Yarn with SSH enabled by setting the USE_SSH environment variable to true. It is intended for users wishing to push the built content via SSH, typically to a GitHub Pages branch. Ensure that SSH keys are configured for GitHub access.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ USE_SSH=true yarn deploy\n```\n```\n\n----------------------------------------\n\nTITLE: Using te.join() to Construct an Object Literal String in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use `te.join()` to concatenate an array of tagged template expression fragments (`te`). It first maps an array of strings to `te` fragments representing key-value pairs using `te.safeKeyOrThrow` and `te.literal`. Then, `te.join()` combines these fragments with a \", \" delimiter. Finally, `te.run` executes the resulting template string to create a JavaScript object, which is verified using `assert.deepEqual`. This requires the `te` library and an `assert` function.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-join.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst keysAndValues = [\"a\", \"b\", \"c\", \"d\"].map(\n  (n, i) => te`${te.safeKeyOrThrow(n)}: ${te.literal(i)}`,\n);\nconst obj = te.run`return { ${te.join(keysAndValues, \", \")} }`;\n\nassert.deepEqual(obj, { a: 0, b: 1, c: 2, d: 3 });\n```\n\n----------------------------------------\n\nTITLE: Creating Roles in PostgreSQL - SQL\nDESCRIPTION: This suite of SQL statements illustrates the creation of three roles with varying privileges, including a superuser and roles suitable for application authentication. It outlines assigning login capability, setting encrypted passwords, and the 'noinherit' flag to control permission inheritance. The 'grant' command delegates role privileges from 'app_visitor' to 'app_authenticator'. The snippet is foundational for implementing secure, role-based access in a PostgreSQL database for applications like PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate role my_superuser with login password 'password here' superuser;\ncreate role app_authenticator with login password 'password here' noinherit;\ncreate role app_visitor;\ngrant app_visitor to app_authenticator;\n```\n\n----------------------------------------\n\nTITLE: Connecting to the New Database with psql - Bash\nDESCRIPTION: Demonstrates connecting to the newly created PostgreSQL database via psql and shows sample output representing a successful connection. This confirms that database creation and access are functional. Input is the connection command with a database URI; output is psql introductory banner and prompt.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n$ psql \\\"postgres:///mydb\\\"\\n\\npsql (9.6.*)\\nType \\\"help\\\" for help.\\n\\n=#\\n```\n```\n\n----------------------------------------\n\nTITLE: Adding @listSuffix Smart Tag to Control Collection Naming - Graphile SQL\nDESCRIPTION: This SQL snippet demonstrates how to use a smart comment tag (@listSuffix) to override the default naming of collection types in the Graphile-generated GraphQL schema on a per-entity basis. It creates a table and annotates it, which impacts how Graphile generates connection and list fields. Requires Graphile with support for smart comment tags, and access to a PostgreSQL-compatible database. The key parameter, '@listSuffix omit', changes the default connection field naming conventions.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table companies (id serial primary key);\ncomment on table companies is E'@listSuffix omit';\n```\n\n----------------------------------------\n\nTITLE: Creating a Ruru Title Customization Plugin in TypeScript\nDESCRIPTION: This TypeScript function `makeRuruTitlePlugin` demonstrates creating a GraphileConfig plugin to customize the title displayed in the Ruru GraphQL interface. It uses the `grafserv.middleware.ruruHTMLParts` hook to modify the `<title>` tag, incorporating a custom title string and the request host.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makeRuruTitlePlugin(title: string): GraphileConfig.Plugin {\n  return {\n    name: \"RuruTitlePlugin\",\n    version: \"0.0.0\",\n\n    grafserv: {\n      middleware: {\n        ruruHTMLParts(next, event) {\n          const { htmlParts, request } = event;\n          htmlParts.titleTag = `<title>${escapeHTML(\n            title + \" | \" + request.getHeader(\"host\"),\n          )}</title>`;\n          return next();\n        },\n      },\n    },\n  };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining EventStream GraphQL Endpoint in Nuxt using TypeScript\nDESCRIPTION: This snippet creates an API route for handling GraphQL event streams (such as subscriptions) in a Nuxt application. Using 'h3's event handler and Grafserv's 'handleEventStreamEvent' method, it enables streaming responses for clients connecting to the '/api/graphql/stream' endpoint. Required dependencies are 'h3' and the shared 'serv' instance from Grafserv. The input is an HTTP event, and the output is a stream of GraphQL execution results.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/nuxt.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { eventHandler } from \\\"h3\\\";\nimport { serv } from \\\"@/server/grafserv/serv\\\";\n\n// Create and export the `/api/graphql/stream` route handler\nexport default eventHandler((event) => serv.handleEventStreamEvent(event));\n```\n\n----------------------------------------\n\nTITLE: Deleting a Single Row with pgDeleteSingle in TypeScript\nDESCRIPTION: This snippet demonstrates the use of pgDeleteSingle to delete a single row from the usersResource, identified by the id parameter. The function executes a DELETE statement on the specified resource, removing the matching record. It returns an object that can be used to further access information about the deleted row. Dependencies include the usersResource and a valid id input; users should ensure that the id uniquely identifies the target row.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgDeleteSingle.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $deletedUser = pgDeleteSingle(usersResource, {\n  id: $id,\n});\n```\n\n----------------------------------------\n\nTITLE: Final Project Directory Structure\nDESCRIPTION: Displays the complete file and folder layout after adding the `graphql/Dockerfile` for the PostGraphile service to the project structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ graphql/\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Overriding a Graphile Inflector via Plugin - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to create a PostGraphile plugin to override a specific inflector (here, 'patchType'). This is achieved by assigning a new function in the 'inflection.replace' object. The custom inflector formats a type name as an UpperCamelCase string suffixed with '-change-set'. Requires PostGraphile ecosystem and knowledge of plugin registration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/inflection.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  name: \"ReplacePatchTypeInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      patchType(previous, resolvedPreset, typeName) {\n        return this.upperCamelCase(`${typeName}-change-set`);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Temporary Dockerized PostgreSQL (Bash)\nDESCRIPTION: Exports necessary environment variables (`PGUSER`, `PGHOST`, `PGPORT`) to allow development tools and tests to connect to the temporary PostgreSQL database running in Docker on port 6432.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport PGUSER=postgres\nexport PGHOST=127.0.0.1\nexport PGPORT=6432\n```\n\n----------------------------------------\n\nTITLE: Installing and Running PostGraphile with pg-simplify-inflector (Shell)\nDESCRIPTION: These shell commands demonstrate how to add the '@graphile-contrib/pg-simplify-inflector' plugin to a PostGraphile project using yarn, and then how to start PostGraphile with the plugin enabled via the '--append-plugins' flag. Requires Node.js and yarn to be installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn add postgraphile @graphile-contrib/pg-simplify-inflector\nyarn postgraphile --append-plugins @graphile-contrib/pg-simplify-inflector\n```\n\n----------------------------------------\n\nTITLE: Logging Before and After Mutations (JavaScript)\nDESCRIPTION: Example using `makeWrapResolversPlugin` (Method 2) to add logging around root mutation fields. The filter function checks `context.scope.isRootMutation` and returns the scope if true. The rule function receives the scope and returns an async wrapper that logs the field name and arguments before calling the original resolver, and logs the result afterwards.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Example: log before and after each mutation runs\nmodule.exports = makeWrapResolversPlugin(\n  (context) => {\n    if (context.scope.isRootMutation) {\n      return { scope: context.scope };\n    }\n    return null;\n  },\n  ({ scope }) =>\n    async (resolver, user, args, context, _resolveInfo) => {\n      console.log(\n        `Mutation '${scope.fieldName}' starting with arguments:`,\n        args,\n      );\n      const result = await resolver();\n      console.log(`Mutation '${scope.fieldName}' result:`, result);\n      return result;\n    },\n);\n```\n\n----------------------------------------\n\nTITLE: Deleting a Heroku Application (Bash)\nDESCRIPTION: Destroys the specified Heroku application (`myappname`) using the `heroku apps:destroy` command provided by the Heroku CLI. This action is irreversible and permanently deletes the application, its code, configuration, and associated add-ons. Requires confirmation before proceeding.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nheroku apps:destroy -a myappname\n```\n\n----------------------------------------\n\nTITLE: Smart Tagging Table with @ref and @refVia for GraphQL Unions - SQL\nDESCRIPTION: Applies '@ref' and '@refVia' smart tags to the 'log_entries' table so that the author field in GraphQL is resolved via union types. The detailed example specifies both column-based and table-based 'via' syntax. Prerequisites are the presence of referenced tables and correct configuration of the mutually exclusive keys.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:(person_id)->people(person_id)\n  @refVia author via:(organization_id)->organizations(organization_id)\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Running Docker Containers using Docker Compose Commands\nDESCRIPTION: Provides example shell commands using `docker-compose up` to create and start the containers defined in the `docker-compose.yml` file. It demonstrates running all services in the foreground, running in detached (background) mode using the `-d` flag, and starting specific services like `db` or `graphql` individually in detached mode. It also notes that a Docker Volume for database persistence is automatically created on the first run.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n# Run containers for all services in docker-compose.yml\n$ docker-compose up\n\n# Run containers as daemon (in background)\n$ docker-compose up -d\n\n# Run only the database container as daemon\n$ docker-compose up -d db\n\n# Run only the GraphQL container as daemon\n$ docker-compose up -d graphql\n```\n\n----------------------------------------\n\nTITLE: Adding a New Graphile Config Scope in TypeScript\nDESCRIPTION: This TypeScript code shows how to define a completely new configuration scope (`sendgrid`) within the `GraphileConfig.Preset` interface using declaration merging. It also defines the structure of the options for this new scope (`SendgridOptions`) with an `apiKey` property.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare global {\n  namespace GraphileConfig {\n    interface Preset {\n      sendgrid?: SendgridOptions;\n    }\n\n    interface SendgridOptions {\n      apiKey?: string;\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Marking a Plan and Its Dependencies as Active - Pseudocode\nDESCRIPTION: This recursive function adds a plan and all of its dependent plans (via dependencies and children lists) to an active plan set for tree-shaking purposes. Inputs: plan object and a list of activePlans tracked across recursion. Output: augmented activePlans list. Assumes plans have dependencies and children arrays.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_8\n\nLANGUAGE: pseudocode\nCODE:\n```\nMarkPlanActive(plan, activePlans):\n\n- If {plan} is within {activePlans}:\n  - Return.\n- Add {plan} to {activePlans}.\n- For each {dependencyPlan} in {plan}.{dependencies}:\n  - Call {MarkPlanActive(dependencyPlan, activePlans)}.\n- For each {childPlan} in {plan}.{children}:\n  - Call {MarkPlanActive(dependencyPlan, activePlans)}.\n```\n\n----------------------------------------\n\nTITLE: Wrapping Mutation Plans for Logging using makeWrapPlansPlugin (Method 2) in TypeScript\nDESCRIPTION: Demonstrates using Method 2 of `makeWrapPlansPlugin` to add logging around mutations. The `filter` function identifies fields where `context.scope.isRootMutation` is true, returning the `scope`. The `rule` function uses this `scope` to create a wrapper. This wrapper employs `sideEffect` from `postgraphile/grafast` twice: once to log the field name and arguments before calling the original plan (`plan()`), and once to log the field name and result after the plan completes. Dependencies include `makeWrapPlansPlugin` and `sideEffect`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\nimport { sideEffect } from \"postgraphile/grafast\";\n\n// Example: log before and after each mutation runs\nexport default makeWrapPlansPlugin(\n  (context) => {\n    if (context.scope.isRootMutation) {\n      return { scope: context.scope };\n    }\n    return null;\n  },\n  ({ scope }) =>\n    (plan, _, fieldArgs) => {\n      sideEffect(fieldArgs.getRaw(), (args) => {\n        console.log(\n          `Mutation '${scope.fieldName}' starting with arguments:`,\n          args,\n        );\n      });\n\n      const $result = plan();\n\n      sideEffect($result, (result) => {\n        console.log(`Mutation '${scope.fieldName}' result:`, result);\n      });\n\n      return $result;\n    },\n);\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.5\nDESCRIPTION: This snippet indicates an update to project dependencies, highlighting version '0.0.1-0.5' of the 'grafast' package, as recorded in the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.5\n```\n\n----------------------------------------\n\nTITLE: Showing Implicit Side Effect Dependencies in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet demonstrates how an implicit dependency on a side-effect step is visualized. A dotted line ending in a circle connects the side-effect step ('SideEffect18') to a subsequent step ('LoadOne19'), indicating that 'LoadOne19' implicitly depends on the side effect having occurred.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    Access17{{\"Access[17âˆˆ3]<br />á¸15.friend_idá³\"}}:::plan\n    SideEffect18[[\"SideEffect[18âˆˆ3]\"]]:::sideeffectplan\n    LoadOne19{{\"LoadOne[19âˆˆ3]\"}}:::plan\n    Access17 --> SideEffect18\n    Access17 --> LoadOne19\n    SideEffect18 -.-o LoadOne19\n    class Access17 bucket3\n    class SideEffect18 bucket3\n    class LoadOne19 bucket3\n\n```\n\n----------------------------------------\n\nTITLE: Planning an Aether Query - Pseudocode\nDESCRIPTION: This pseudocode entry describes how to plan execution for a GraphQL query by retrieving the root query type, asserting its existence, and invoking selection set planning. It establishes the root plan context using the tracked value and recurses into the query's selection set. Prerequisites are a properly structured aether with schema and operation data.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_23\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanAetherQuery(aether):\n\n- Let {rootType} be the root Query type in {aether}.{schema}.\n- Assert {rootType} exists.\n- Let {selectionSet} be the top level Selection Set in {aether}.{operation}.\n- Let {trackedRootValuePlan} be {aether}.{trackedRootValuePlan}.\n- Call {PlanSelectionSet(aether, \"\", trackedRootValuePlan, rootType, selectionSet)}.\n```\n\n----------------------------------------\n\nTITLE: Specifying Anonymous Table Return Types for PostgreSQL Functions\nDESCRIPTION: Example SQL fragment illustrating the `returns table(...)` syntax for defining an anonymous table structure as the return type for a PostgreSQL function. While functional, this method is generally discouraged in the Graphile context compared to using named composite types (`returns setof named_type`) because named types offer better schema management and clarity.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nreturns table(...)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function toString() in JavaScript\nDESCRIPTION: Shows the basic usage of the `.toString()` method on a simple JavaScript function without closures to retrieve its source code representation.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n> (function add(a, b) { return a + b }).toString()\n'function add(a, b) { return a + b }'\n```\n\n----------------------------------------\n\nTITLE: Conditionally Masking Field Data using makeWrapPlansPlugin (JavaScript)\nDESCRIPTION: Shows how `makeWrapPlansPlugin` can wrap a field plan (`User.email`) in PostGraphile V5 to conditionally return data. It retrieves the current user's ID from the context (`$myUserId`) and the target user's ID from the parent step (`$theirUserId = $user.get(\"id\")`). It then executes the original plan to get the email (`$email`). Finally, it uses a `lambda` step to compare the IDs and returns the actual email only if they match, returning `null` otherwise to mask the email for other users. Assumes the 'email' field is nullable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst plugin = makeWrapPlansPlugin({\n  User: {\n    email(plan, $user, args, info) {\n      // Get 'userId' from the GraphQL context\n      const $myUserId = context().get(\"userId\");\n\n      // Get the user's ID\n      const $theirUserId = $user.get(\"id\");\n\n      // Get the email via the original plan\n      const $email = plan();\n\n      // Now return a new plan that only returns the email if the IDs match\n      return lambda(\n        [$myUserId, $theirUserId, $email],\n        ([myUserId, theirUserId, email]) => {\n          if (myUserId === theirUserId) {\n            return email;\n          } else {\n            return null; // TODO: ensure the 'email' field is nullable!\n          }\n        },\n      );\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining makeWrapResolversPlugin Overloads (TypeScript)\nDESCRIPTION: TypeScript definitions illustrating the two overloaded signatures for `makeWrapResolversPlugin`. Method 1 accepts a rules object or generator for wrapping specific fields. Method 2 accepts a filter function and a rule generator for wrapping fields matching the filter. It also includes related interface definitions for `ResolverWrapperRules` and `ResolverWrapperRulesGenerator`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Method 1: wrap individual resolvers of known fields\nfunction makeWrapResolversPlugin(\n  rulesOrGenerator: ResolverWrapperRules | ResolverWrapperRulesGenerator,\n): Plugin;\n\n// Method 2: wrap all resolvers that match a filter function\nfunction makeWrapResolversPlugin<T>(\n  filter: (\n    context: Context,\n    build: Build,\n    field: GraphQLFieldConfig,\n    options: Options,\n  ) => T,\n  rule: (match: T) => ResolverWrapperRule | ResolverWrapperFn,\n);\n\n/****************************************/\n\ninterface ResolverWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: ResolverWrapperRule | ResolverWrapperFn;\n  };\n}\ntype ResolverWrapperRulesGenerator = (options: Options) => ResolverWrapperRules;\n```\n\n----------------------------------------\n\nTITLE: Defining PostGraphile Start Script in package.json (JSON)\nDESCRIPTION: Configures the `package.json` file for a PostGraphile project intended for GCP deployment. It defines the project name, version, specifies Node.js/npm engine versions, lists `postgraphile` as a dependency, and sets the `start` script. The `start` script executes the `postgraphile` CLI with arguments tailored for GCP App Engine: `--host 0.0.0.0` and `--port 8080` for proper binding, `--cors` for handling cross-origin requests, `--enhance-graphiql`, `--graphql /` to set the endpoint root, and the database connection string pointing to the Cloud SQL instance via its internal IP (`172.17.0.1` is often used with the TCP mapping from `app.yaml`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"myprojectname\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"postgraphile --host --port 8080 --cors --enhance-graphiql --graphql / 0.0.0.0 -c postgres://user:password@172.17.0.1:5432/str_dev\"\n  },\n  \"engines\": {\n    \"node\": \"^10.15\",\n    \"npm\": \"^6.9\"\n  },\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"postgraphile\": \"^4.4.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing pgl with npx, Amber Preset, and Local DB Connection\nDESCRIPTION: This command demonstrates running the beta version of the `pgl` tool using `npx`. It applies the 'amber' preset (`-P pgl/amber`) and connects to a local PostgreSQL database named `my_db` using a simple connection string (`-c postgres:///my_db`). `pgl` simplifies running `postgraphile` by handling peer dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/pgl/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx pgl@beta -P pgl/amber -c postgres:///my_db\n```\n\n----------------------------------------\n\nTITLE: Integrating a CORS Plugin with PostGraphile Middleware - JavaScript\nDESCRIPTION: This snippet demonstrates how to integrate the custom CORS plugin produced by `makeAllowedOriginTweak` into the PostGraphile middleware setup. It constructs a `pluginHook` array with the CORS plugin configured for a specific origin and then initializes PostGraphile middleware with this hook. Required dependencies include PostGraphile and access to the `postgraphile` and `makePluginHook` functions. Key parameters are the allowed origin string, database URL, and schema name. Inputs are setup parameters for PostGraphile, and output is the fully configured middleware. Limitation: Assumes a compatible PostGraphile environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst pluginHook = makePluginHook([\n  makeAllowedOriginTweak(\"https://graphql.rocks\"),\n]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Ruru Explain Feature in PostGraphile Configuration (JavaScript)\nDESCRIPTION: This JavaScript configuration snippet, intended for `graphile.config.mjs`, enables the 'Explain' feature in Ruru. Setting `grafast.explain` to `true` allows developers to view the Gra*fast* operation plan and the underlying SQL queries directly within the Ruru interface. A warning advises disabling this feature in production environments to prevent exposing internal schema details.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  // ...\n  grafast: {\n    explain: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining QuizEntry Mutation Inputs and Patches - GraphQL - GraphQL\nDESCRIPTION: These GraphQL input and patch types define the data shape for mutations targeting QuizEntry entities. 'QuizEntryInput' collects all data needed for creation or upsert mutations, while 'QuizEntryPatch' supports partial updates where only selected fields are supplied. Dependencies include Int, and correct relations to userId and quizId. Creation requires userId and quizId, but updates may set any fields as needed. Limitations follow the schema's definition and constraints around required and nullable fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"An input for mutations affecting `QuizEntry`\"\"\"\ninput QuizEntryInput {\n  id: Int\n  userId: Int!\n  quizId: Int!\n}\n\n\"\"\"\nRepresents an update to a `QuizEntry`. Fields that are set will be updated.\n\"\"\"\ninput QuizEntryPatch {\n  id: Int\n  userId: Int\n  quizId: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Select Policies for RLS in Postgres (SQL)\nDESCRIPTION: These SQL snippets create RLS policies allowing all roles to select (view) any row in the \\\"person\\\" and \\\"post\\\" tables. The policies use \\\"using (true)\\\" to permit selection without checks, restoring read access to all rows for all roles. These should be defined after RLS is enabled to grant explicit permission for SELECT operations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_38\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy select_person on forum_example.person for select\n  using (true);\n\ncreate policy select_post on forum_example.post for select\n  using (true);\n```\n\n----------------------------------------\n\nTITLE: Querying GraphQL API for Posts and Authors - GraphQL\nDESCRIPTION: Provides a sample GraphQL query to fetch all posts and nested author information using the 'allPosts' field. The query returns post IDs, titles, bodies, and the username of the author associated via 'userByAuthorId'. This structure assumes the schema generated or exposed by PostGraphile includes these types and relationships.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_22\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  allPosts {\n    nodes {\n      id\n      title\n      body\n      userByAuthorId {\n        username\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing the Patch Type Inflector to Emit ChangeSet (TypeScript)\nDESCRIPTION: This TypeScript code defines a PostGraphile plugin that overrides the inflector for patch types, returning a new name ending in 'ChangeSet' instead of 'Patch'. It uses the upperCamelCase method from the inflector instance to format the new type name. Dependencies are the same as for other plugins, including 'graphile-config', 'graphile-build', and 'graphile-build-pg'. The key parameter is 'typeName', which is combined into a camel-cased string. Output is a string with the new naming pattern. The plugin should be registered in PostGraphile's configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\\n  // Unique name for your plugin:\\n  name: \\\"ReplaceInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    replace: {\\n      patchType(previous, preset, typeName) {\\n        return this.upperCamelCase(\\`${typeName}-change-set\\`);\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL `statement_timeout` via `pgSettings` in JavaScript\nDESCRIPTION: Illustrates setting the PostgreSQL `statement_timeout` configuration parameter on a per-transaction basis using the `pgSettings` option when initializing PostGraphile as a library. This example sets the timeout to 3000 milliseconds (3 seconds) to help prevent excessively long-running queries. Requires the `postgraphile` library.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/production.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\napp.use(\n  postgraphile(process.env.DATABASE_URL, \"public\", {\n    // ...\n    pgSettings: {\n      statement_timeout: \"3000\",\n    },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Ordering Clauses with pgSelect orderBy in TypeScript\nDESCRIPTION: Provides an example of adding multiple sorting criteria to a `pgSelect` step (`$users`). The first `orderBy` call sorts by the length of the 'username' attribute (using a callback to generate the SQL `length()` expression) in ascending order with nulls last. The second `orderBy` call adds a secondary sort by the 'id' attribute in ascending order. Multiple calls append to the ordering list. Requires `usersResource`, `sql`, and `TYPES`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// Get a pgSelect:\nconst $users = usersResource.find();\n\n// Sort by username length\n$users.orderBy({\n  attribute: \"username\",\n  callback(usernameExpression, codec) {\n    return [sql`length(${usernameExpression})`, TYPES.int];\n  },\n  direction: \"ASC\",\n  nulls: \"LAST\",\n});\n\n// Sort within that by user id\n$users.orderBy({ attribute: \"id\", direction: \"ASC\" });\n\n// Result is something like:\n// `SELECT ... FROM users ORDER BY length(username) ASC NULLS LAST, id ASC`\n```\n\n----------------------------------------\n\nTITLE: Executing an Update Mutation by ID in PostGraphile (GraphQL)\nDESCRIPTION: Shows an example GraphQL `updateUserById` mutation to modify an existing record in the `users` table, identified by its primary key (`id`). It uses a `userPatch` object within the `input` to specify the fields to update (in this case, `about`) and requests details (`id`, `name`, `username`, `about`, `createdAt`) of the updated user in the response.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/crud-mutations.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n# Update Bilbo using the user.id primary key\nmutation {\n  updateUserById(\n    input: { id: 1, userPatch: { about: \"An adventurous hobbit\" } }\n  ) {\n    user {\n      id\n      name\n      username\n      about\n      createdAt\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Inflector Graphile V5 TypeScript\nDESCRIPTION: Defines a new inflector `allRowsConnection` within a Graphile V5 plugin. It first declares the inflector's type signature globally within the `GraphileBuild.Inflection` namespace. Then, it implements the inflector logic inside the `inflection.add` object of the plugin definition. The implementation receives an `options` object (passed by the system) and the resource defined in the type declaration, using `this.connectionField` and other inflection helpers to generate the name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Declare the type\ndeclare global {\n  namespace GraphileBuild {\n    interface Inflection {\n      /** Field name for a Connection field returning all rows from the resource. */\n      allRowsConnection(this: Inflection, resource: PgResource): string;\n    }\n  }\n}\n\n// Implement the inflector\nexport const PgAllRowsPlugin: GraphileConfig.Plugin = {\n  name: \"PgAllRowsPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    add: {\n      allRowsConnection(\n        options, // Additional argument, automatically passed by the system\n        resource, // This is the argument you defined in the types above\n      ) {\n        return this.connectionField(\n          this.camelCase(\n            `all-${this.pluralize(this._singularizedResourceName(resource))}`,\n          ),\n        );\n      },\n      // ...\n    },\n  },\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.2\nDESCRIPTION: This snippet records an update to project dependencies, specifically mentioning version '0.0.1-0.2' of the 'grafast' package within the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.2\n```\n\n----------------------------------------\n\nTITLE: Configuring Express Server with PostGraphile for Testability (JavaScript)\nDESCRIPTION: This snippet demonstrates setting up an Express server using the `postgraphile` middleware. It highlights extracting PostGraphile options into a dedicated function (`postgraphileOptions`) which can be exported and imported into test files, facilitating integration testing. The server uses environment variables for the database URL and listens on a specified port.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\nfunction postgraphileOptions() {\n  return {\n    dynamicJson: true,\n  };\n}\nexports.postgraphileOptions = postgraphileOptions;\n\napp.use(\n  postgraphile(\n    process.env.DATABASE_URL || \"postgres:///\",\n    [\"app_public\"],\n    postgraphileOptions(),\n  ),\n);\n\napp.listen(process.env.PORT || 3000);\n```\n\n----------------------------------------\n\nTITLE: Defining a JWT Composite Type in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet creates a composite type for JWT tokens in the 'forum_example' schema, specifying claims for 'role', 'person_id', and 'exp'. This enables PostGraphile to map selected PostgreSQL query results directly into JWTs for issuance to clients. Dependencies include a prior database schema and correct configuration with pgJwtTypes in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_32\n\nLANGUAGE: sql\nCODE:\n```\ncreate type forum_example.jwt_token as (\\n  role text,\\n  person_id integer,\\n  exp bigint\\n);\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring PostgreSQL Roles (SQL)\nDESCRIPTION: Demonstrates creating various PostgreSQL roles using the `CREATE ROLE` statement. It shows setting attributes like `login` (allowing the role to log in), `password`, `superuser` status, and `noinherit`. The `noinherit` attribute prevents a role from automatically inheriting permissions from granted roles, requiring an explicit `SET ROLE` command to use those privileges. It also includes granting one role (`app_visitor`) membership in another (`app_authenticator`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/required-knowledge.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate role my_superuser with login password 'password here' superuser;\ncreate role app_authenticator with login password 'password here' noinherit;\ncreate role app_visitor;\ngrant app_visitor to app_authenticator;\n```\n\n----------------------------------------\n\nTITLE: Setting Heroku Database URL with SSL (Bash)\nDESCRIPTION: Sets the `DATABASE_URL` configuration variable on Heroku for connecting to a PostgreSQL database (like AWS RDS), ensuring the connection uses SSL by appending `?ssl=true`. Replace the placeholder URL components with actual database credentials, host, and database name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set DATABASE_URL=\"postgres://...rdshost.../db_name?ssl=true\"\n```\n\n----------------------------------------\n\nTITLE: Using listOfCodec with Query Placeholders in TypeScript\nDESCRIPTION: Demonstrates creating an array codec using `listOfCodec(TYPES.uuid)` and using it with `$orderItems.placeholder`. This technique allows a dynamically generated list of IDs (`$orderIds`) to be correctly typed and embedded within a SQL query using the `ANY` operator for efficient filtering. Assumes setup involving resources (`orders`, `order_items`), context, and helper functions like `applyTransforms` and `each`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/codecs.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst $orders = orders.find({\n  customer_id: context().get(\"customerId\"),\n});\n\nconst $orderIds = applyTransforms(each($orders, ($order) => $order.get(\"id\")));\n\nconst $orderItems = registry.pgResources.order_items.find();\n\n$orderItems.where(\n  sql`${$orderItems}.order_id = ANY (${$orderItems.placeholder(\n    $orderIds,\n    listOfCodec(TYPES.uuid),\n  )})`,\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Viewer Query Field Using PostgreSQL Function - SQL\nDESCRIPTION: Defines a stable SQL function â€˜viewer()â€™ that returns the currently logged-in user as a row of type â€˜usersâ€™. It relies on the auxiliary â€˜current_user_id()â€™ function to extract user identity (commonly from a JWT or PostGraphile pgSettings). Designed to extend the schema, this function enables secure, session-aware access to user data in PostGraphile-backed APIs. Prerequisites: a â€˜usersâ€™ table and the â€˜current_user_id()â€™ utility; output is a single user row or null.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate function viewer()\nreturns users\nas $$\n  select *\n  from users\n  where id = current_user_id();\n  /*\n   * current_user_id() is a function\n   * that returns the logged in user's\n   * id, e.g. by extracting from the JWT\n   * or indicated via pgSettings.\n   */\n$$ language sql stable set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Handling JWT Authentication Errors in Express (JavaScript)\nDESCRIPTION: Implements an Express error handling middleware (`authErrors`) specifically for errors thrown by `express-jwt` (identified by `err.name === 'UnauthorizedError'`). Instead of the default HTML error, it logs the error server-side and sends a JSON response conforming to the GraphQL error specification, containing only the error message, with the appropriate HTTP status code (e.g., 401). This middleware should be applied to the relevant endpoint (e.g., `/graphql`) after the JWT middleware.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst authErrors = (err, req, res, next) => {\n  if (err.name === \"UnauthorizedError\") {\n    console.log(err); // You will still want to log the error...\n    // but we don't want to send back internal operation details\n    // like a stack trace to the client!\n    res.status(err.status).json({ errors: [{ message: err.message }] });\n    res.end();\n  }\n};\n\n// Apply error handling to the graphql endpoint\napp.use(\"/graphql\", authErrors);\n```\n\n----------------------------------------\n\nTITLE: Creating New Crystal Object (Pseudocode)\nDESCRIPTION: Constructs a new Crystal object, which encapsulates data along with execution context information like the plan, path identity, IDs, indexes, and the Crystal context. It initializes and copies path-based ID and index maps, ensuring contextual information is propagated correctly.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_37\n\nLANGUAGE: pseudocode\nCODE:\n```\nNewCrystalObject(plan, pathIdentity, id, indexes, data, crystalContext, idByPathIdentity, indexesByPathIdentity):\n\n- If {idByPathIdentity} is not set, initialize it to a map containing value {crystalContext}.{rootId} for key `\"\"`.\n- If {indexesByPathIdentity} is not set, initialize it to a map containing an empty list value for key `\"\"`.\n- Let {crystalObject} be an empty object.\n- Let {crystalObject}.{id} be {id}.\n- Let {crystalObject}.{crystalContext} be a reference to {crystalContext}.\n- Let {crystalObject}.{idByPathIdentity} be an independent copy of {idByPathIdentity}.\n- Let {crystalObject}.{indexesByPathIdentity} be an independent copy of {indexesByPathIdentity}.\n- Let {crystalObject}.{data} be {data}.\n- Set {id} as the value for key {pathIdentity} within {crystalObject}.{idByPathIdentity}.\n- Set {indexes} as the value for key {pathIdentity} within {crystalObject}.{indexesByPathIdentity}.\n- Return {crystalObject}.\n```\n\n----------------------------------------\n\nTITLE: Setting JWT Claims in PostgreSQL Session Namespace - SQL\nDESCRIPTION: This SQL snippet details how to serialize individual JWT claims (both standard and custom) as session-local PostgreSQL variables under the 'jwt.claims' namespace. Each claim from the JWT is set with its own variable, facilitating claim-based access checks and functions within PostgreSQL. Every claim, including 'role', is set this way and is available within the session or transaction block.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nset local jwt.claims.$claim_name to $claim_value;\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Export Metadata from EXPORTABLE Wrapped Functions in JavaScript\nDESCRIPTION: Demonstrates how `graphile-export` can retrieve the necessary information for exporting the function. It accesses the special `$exporter$factory` and `$exporter$args` properties added by `EXPORTABLE` to get the factory function's source and the values of its dependencies (like `a=7`).\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n> add.$exporter$factory.toString()\n'(a) => function add(b) { return a + b; }'\n> add.$exporter$args\n[ 7 ]\n```\n\n----------------------------------------\n\nTITLE: Getting Value Plan ID (Pseudocode)\nDESCRIPTION: Retrieves or generates a unique ID for a given object within the context of a specific value plan. It uses a map (`valueIdByObjectByPlanId` within `aether`) to cache IDs per plan and object. If an ID doesn't exist, it generates a new one, populates the value plan for that ID using `PopulateValuePlan`, caches it, and returns the new ID.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_34\n\nLANGUAGE: pseudocode\nCODE:\n```\nGetValuePlanId(aether, crystalContext, valuePlan, object):\n\n- Assert: {valuePlan} is a {__ValuePlan}.\n- Let {valueIdByObject} be the map for {valuePlan}.{id} within the map {aether}.{valueIdByObjectByPlanId} (creating the\n  entry if necessary).\n- Let {valueId} be the value for {object} within the map {valueIdByObject} (note: object might be {null} or {undefined}\n  for root resolvers only).\n- If {valueId} is set:\n  - Return {valueId}.\n- Otherwise:\n  - Let {valueId} be a new unique id.\n  - Call {PopulateValuePlan(crystalContext, valuePlan, valueId, object)}. (Note: this populates the {__ValuePlan} for\n    this specific parent.)\n  - Set {valueId} as the value for {object} in {valueIdByObject}.\n  - Return {valueId}.\n```\n\n----------------------------------------\n\nTITLE: Example JWT Access Token Payload (JSON)\nDESCRIPTION: Illustrates the structure and common claims within a decoded JWT Access Token payload after successful verification. Key claims include issuer (`iss`), subject (`sub`), audience (`aud`), issued at time (`iat`), expiration time (`exp`), authorized party (`azp`), and scopes/permissions (`scope`). This example shows a token with only the `read:schema` scope.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"iss\": \"https://YOUR_DOMAIN/\",\n  \"sub\": \"CLIENT_ID@clients\",\n  \"aud\": \"YOUR_API_IDENTIFIER\",\n  \"iat\": 1555808706,\n  \"exp\": 1555895106,\n  \"azp\": \"CLIENT_ID\",\n  \"scope\": \"read:schema\", // scopes a.k.a. permissions\n  \"gty\": \"client-credentials\"\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Behavior During Schema Build (Old Approach) in TypeScript\nDESCRIPTION: This snippet demonstrates the previous method for determining behavior within a GraphQL schema hook (specifically `GraphQLObjectType_fields_field`). It involves establishing a default behavior based on conditions, explicitly fetching user-specified behavior using `getBehavior` by merging extensions from multiple sources (like `relation.remoteResource.codec.extensions`, `relation.remoteResource.extensions`, `relation.extensions`), and finally checking if the resulting behavior string matches a target behavior using `build.behavior.matches` with the calculated default. This approach could lead to inconsistencies as different plugins might calculate defaults differently and required careful management of extension sources.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n\n  // Establish a default behavior, e.g. you might give it different default behavior\n  // depending on if the remote table is in the same schema or not\n  const defaultBehavior = someCondition(relation) ? \"behavior_if_true\" : \"behavior_if_false\";\n\n  // Now establish the user-specified behavior for the entity, inheriting from all the\n  // relevant places.\n  const behavior = getBehavior([\n    relation.remoteResource.codec.extensions,\n    relation.remoteResource.extensions,\n    relation.extensions\n  ]);\n\n  // Finally check this behavior string against `behavior_to_test`, being sure to apply\n  // the \"schema-time smart defaulting\" that we established in `defaultBehavior` above.\n  if (build.behavior.matches(behavior, \"behavior_to_test\", defaultBehavior)) {\n    doTheThing();\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a pgSelect Step using Resource find Method in TypeScript\nDESCRIPTION: Demonstrates obtaining a `pgSelect` instance representing all messages from forum with `forum_id` equal to 1. This is achieved using the `.find()` method on the `messages` resource within the `registry.pgResources` collection. Requires `registry`, `pgResources`, and the `constant` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// `pgSelect()` step representing all the messages in forum 1:\nconst $pgSelect = registry.pgResources.messages.find({ forum_id: constant(1) });\n```\n\n----------------------------------------\n\nTITLE: GraphQL Subscription Result Payload Example (With Node Data) - JSON\nDESCRIPTION: This JSON subscription result shows the structure for a payload that includes relatedNodeId and attached node data (id, title, etc.). It reflects what the module delivers to the GraphQL client when a NOTIFY message with a node reference is received. Use as guidance or test output when configuring node-based events.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"listen\": {\n      \"relatedNodeId\": \"WyJmb29zIiwzMl0=\",\n      \"relatedNode\": {\n        \"nodeId\": \"WyJmb29zIiwzMl0=\",\n        \"id\": 32,\n        \"title\": \"Howdy!\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Plugin hooks.args to Middleware prepareArgs in Graphile with Diff (TypeScript)\nDESCRIPTION: This code snippet demonstrates migrating a plugin configuration from the deprecated 'hooks.args' format to the new 'middleware.prepareArgs' function when using Graphile with TypeScript. The migration involves changing the nesting structure and renaming methods according to updated API conventions. It also shows the extraction of 'requestContext' and 'resolvedPreset' from the 'args' object, and the requirement to call the 'next()' function within the middleware. Inputs include a plugin object; outputs are the correctly structured plugin for Graphile's new middleware system. The snippet should be placed in the plugin definition file, requires TypeScript, and assumes a compatible version of 'graphile-config'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n const plugin = {\n   grafast: {\n-    hooks: {\n+    middleware: {\n-      args({ args, ctx, resolvedPreset }) {\n+      prepareArgs(next, { args }) {\n+        const { requestContext: ctx, resolvedPreset } = args;\n         // ...\n+        return next();\n       }\n     }\n   }\n }\n```\n```\n\n----------------------------------------\n\nTITLE: Building Multi-Stage Docker Image for PostGraphile Server - Dockerfile\nDESCRIPTION: This multi-stage Dockerfile example demonstrates how to efficiently build and package a custom PostGraphile-based Node.js server. It breaks the build into three phases: a build phase for dependency installation and code compilation, a clean phase for copying only necessary files, and a final stage for optimized runtime setup and dependency installation. It uses Docker ARGs for environment control, exposes port 5000, sets environment variables, and uses yarn as the package manager. To use, Docker must be installed and configured, and this Dockerfile should be customized per project structure. Input files include Node.js source and build artifacts; output is a minimal production-ready Docker container.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-docker.md#_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\n# Dockerfile\\n\\n# Global args, set before the first FROM, shared by all stages\\nARG NODE_ENV=\\\"production\\\"\\n\\n################################################################################\\n# Build stage 1 - `yarn build`\\n\\nFROM node:12-alpine as builder\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Cache node_modules for as long as possible\\nCOPY package.json yarn.lock /app/\\nWORKDIR /app/\\nRUN yarn install --frozen-lockfile --production=false --no-progress\\n\\n# Copy over the server source code\\nCOPY server/ /app/server/\\n\\n# Finally run the build script\\nRUN yarn run build\\n\\n################################################################################\\n# Build stage 2 - COPY the relevant things (multiple steps)\\n\\nFROM node:12-alpine as clean\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Copy over selectively just the tings we need, try and avoid the rest\\nCOPY --from=builder /app/package.json /app/yarn.lock /app/\\nCOPY --from=builder /app/server/dist/ /app/server/dist/\\n\\n################################################################################\\n# Build stage FINAL - COPY everything, once, and then do a clean `yarn install`\\n\\nFROM node:12-alpine\\n# Import our shared args\\nARG NODE_ENV\\n\\nEXPOSE 5000\\nWORKDIR /app/\\n# Copy everything from stage 2, it's already been filtered\\nCOPY --from=clean /app/ /app/\\n\\n# Install yarn ASAP because it's the slowest\\nRUN yarn install --frozen-lockfile --production=true --no-progress\\n\\nLABEL description=\\\"My PostGraphile-powered server\\\"\\n\\n# You might want to disable GRAPHILE_TURBO if you have issues\\nENV GRAPHILE_TURBO=1\\nENV NODE_ENV=$NODE_ENV\\nENTRYPOINT yarn start\n```\n\n----------------------------------------\n\nTITLE: Renaming a Type and Function using SQL Smart Comments\nDESCRIPTION: Creates a custom SQL type `flibble` and a function `getFlamble` returning a set of this type. It then uses SQL `COMMENT` statements with the `@name` smart tag to rename the type to `flamble` and the function's corresponding GraphQL query field to `allFlambles` in the PostGraphile schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate type flibble as (f text);\n\ncreate function getFlamble() returns SETOF flibble as $$\n    select (body)::flibble from post\n$$ language sql;\n\ncomment on type flibble is E'@name flamble';\ncomment on function getFlamble() is E'@name allFlambles';\n```\n\n----------------------------------------\n\nTITLE: Replacing Inflector Graphile V5 TypeScript\nDESCRIPTION: Demonstrates how to replace an existing inflector (`allRowsConnection`) in a Graphile V5 plugin using the `inflection.replace` hook. The replacement function receives the previous implementation (`prev`), system-provided `options`, and the original arguments (`resource`). It shows conditional logic to either provide a custom name or call the previous inflector. The `ignoreReplaceIfNotExists` array ensures no warning is issued if the inflector doesn't exist and guarantees `prev` is non-null.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport const PgAllThePeoplePlugin: GraphileConfig.Plugin = {\n  name: \"PgAllThePeoplePlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      allRowsConnection(prev, options, resource) {\n        return resource.name === \"people\" ? `allThePeople` : prev!(resource);\n      },\n      ignoreReplaceIfNotExists: [\"allRowsConnection\"],\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in React - JavaScript\nDESCRIPTION: This snippet demonstrates how to import a CSS module via ES6 import syntax in a React component. The imported 'styles' object allows the application of scoped CSS class names defined in '@site/src/css/common.module.css' to JSX elements for consistent styling throughout the component. Prerequisites include a React environment with CSS module support through the build system (e.g., using Webpack or compatible loaders).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/code-of-conduct.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Planning and Execution Timeouts in Grafast with TypeScript\nDESCRIPTION: This TypeScript configuration snippet demonstrates how to set planning and execution timeouts for Grafast by configuring a 'preset' object. It should be provided as the second argument to the 'grafast()' or 'execute()' function within your application's Graphile integration. The 'grafast.timeouts.planning' option determines the timeout (in milliseconds) for planning, and 'grafast.timeouts.execution' sets the timeout for execution, allowing fine-grained control over query responsiveness. Ensure that your project uses compatible versions of Grafast, and that 'preset' is correctly merged with your existing configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst preset = {\n  grafast: {\n    timeouts: {\n      /** Planning timeout in ms */\n      planning: 500,\n\n      /** Execution timeout in ms */\n      execution: 30_000,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Composite Type Example (SQL)\nDESCRIPTION: This SQL snippet demonstrates creating a custom composite type `my_schema.my_type` in PostgreSQL. It serves as an example type containing two integer fields, `foo` and `bar`, illustrating how structured data types can be defined in the database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate type my_schema.my_type as (\n  foo integer,\n  bar integer\n);\n```\n\n----------------------------------------\n\nTITLE: Patching Pagila Database Enum Values using SQL\nDESCRIPTION: These SQL commands modify the `mpaa_rating` enum type within the Pagila database. They rename the values 'PG-13' to 'PG13' and 'NC-17' to 'NC17' to resolve naming incompatibilities required for the Graphile Crystal examples. These commands should be run after the database has been populated.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/src/examples/README.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nalter type mpaa_rating rename value 'PG-13' TO 'PG13';\nalter type mpaa_rating rename value 'NC-17' TO 'NC17';\n```\n\n----------------------------------------\n\nTITLE: Setting Mutation Field Values via Plan Wrapping in PostGraphile V5 (JavaScript)\nDESCRIPTION: Demonstrates how to use makeWrapPlansPlugin to inject custom values into mutation inputs by directly manipulating the field's plan before execution. This approach enables dynamic field population (e.g., building a 'name' from 'firstName' and 'lastName') without exposing the underlying columns in the schema. Dependencies include PostGraphile V5, access to lambda, and a Graphile plan execution context; inputs depend on mutation arguments and outputs affect plan behavior but maintain result shape.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-wrap-resolvers-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nmakeWrapPlansPlugin({\n  Mutation: {\n    // This same pattern works for 'update' mutations too\n    createPost(plan, $source, { $firstName, $lastName }) {\n      // Call the original plan\n      const $planResult = plan();\n\n      // Get a reference to the `PgInsertSingleStep`.\n      // Remember: it's a step, it has not executed yet, so we can still\n      // augment what it will do.\n      const $insert = $planResult.get(\"result\");\n\n      // We have a legacy 'name' field that needs populating; build it from\n      // each tuple of firstName/lastName fields:\n      const $name = lambda(\n        [$firstName, $lastName],\n        ([firstName, lastName]) => `${firstName} ${lastName}`,\n        // Our callback is synchronous and won't throw\n        true,\n      );\n\n      // Now set this as the value of 'name' in the PgInsertSingleStep:\n      $insert.set(\"name\", $name);\n\n      // Our result is the same as before (otherwise dependent plans may fail)\n      return $planResult;\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Limitations of Functions for DML Operations\nDESCRIPTION: Illustrates that database functions, unlike tables, cannot be directly targeted by `INSERT`, `UPDATE`, or `DELETE` statements. Separate functions must be created to perform such modifications on the underlying data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nINSERT\n```\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE\n```\n\nLANGUAGE: sql\nCODE:\n```\nDELETE\n```\n\n----------------------------------------\n\nTITLE: Importing Built-in Scalar Codecs in PostGraphile/TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import predefined scalar type codecs, such as `int`, `bool`, and `text`, from the `TYPES` object exported by the `postgraphile/@dataplan/pg` package. These codecs represent basic PostgreSQL data types and are fundamental components within the PostGraphile registry system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/registry.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\nconst { int, bool, text /* ... */ } = TYPES;\n```\n\n----------------------------------------\n\nTITLE: Deprecated: 'PgAdaptorOptions' Type Name (TypeScript)\nDESCRIPTION: Highlights the deprecated type name `PgAdaptorOptions` previously used for PostgreSQL adaptor settings in TypeScript. As of version 5.0.0-beta.26, this name has been changed to `PgAdaptorSettings` and requires a global find and replace.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nPgAdaptorOptions\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in a React Component - JavaScript\nDESCRIPTION: This code snippet demonstrates how to import CSS module styles into a React component using the ES module import syntax. The 'styles' object provides scoped class names defined in '@site/src/css/common.module.css', enabling modular and conflict-free styling within React components. There are no required parameters, but the corresponding CSS module file must exist; the main output is the 'styles' object for use in JSX className assignments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/community-chat.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Using a Live Query Subscription in PostGraphile (GraphQL)\nDESCRIPTION: This snippet illustrates a live query subscription operation using GraphQL in PostGraphile. It subscribes to a reactive list of users named 'Alice', including their friends and attributes. Required dependencies include an experimental server implementation supporting live queries. The condition parameter restricts results to users with the first name 'Alice', while nested selections retrieve friend data. Whenever the result set would differ due to changes in matching users or their friends, updated results are sent, which can impact performance if queries are large.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/realtime.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allUsersList(condition: { firstName: \"Alice\" }) {\n    id\n    name\n    friendsList {\n      id\n      name\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Inefficient RLS Policy Function Accepting Row Data (SQL)\nDESCRIPTION: Shows an inefficient pattern for Row-Level Security (RLS). It defines a function `current_user_is_member_of` that takes a `target_organization_id` and checks if the current user is a member. A `CREATE POLICY` statement then uses this function in its `USING` clause, passing the `members.organization_id` column value from each row being evaluated. This is marked as 'BAD' because the function might be called repeatedly, potentially once for every row, leading to significant performance degradation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user_is_member_of(target_organization_id int) returns boolean as $$\n  select exists(\n    select 1\n    from members\n    where organization_id = target_organization_id\n    and user_id = current_user_id()\n  );\n$$ language sql stable security definer;\n\ncreate policy select_members\n  for select on members\n  using (\n    /* highlight-next-line */\n    current_user_is_member_of(members.organization_id)\n  );\n```\n\n----------------------------------------\n\nTITLE: Ignoring the .env File with Git - Bash\nDESCRIPTION: This bash snippet appends the .env filename to .gitignore, ensuring sensitive information such as database credentials isn't committed to source control. Should be run from the root of the project after creating the .env file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\necho .env >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column using JSON5 Smart Tags File\nDESCRIPTION: Configures PostGraphile via `postgraphile.tags.json5` to mark the `my_column` attribute (database column) as deprecated in the GraphQL schema, providing a reason. This uses the `@deprecated` smart tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_3\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      my_column: {\n        tags: {\n          deprecated: \"Use myOtherColumn instead.\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Jest to use the GraphQL Schema Serializer in package.json\nDESCRIPTION: Updates the `jest` configuration section within `package.json` to include `jest-serializer-graphql-schema` in the `snapshotSerializers` array. This instructs Jest to utilize this custom serializer when generating and comparing snapshots specifically for GraphQLSchema objects.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"jest\": {\n  \"snapshotSerializers\": [\"jest-serializer-graphql-schema\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SQL Explain Logging via DEBUG Environment Variable (PowerShell)\nDESCRIPTION: This Windows PowerShell command sets the `DEBUG` environment variable to `@dataplan/pg:PgExecutor:explain` using the `$env:` syntax. Running PostGraphile (`postgraphile -c ...`) afterwards in the same PowerShell session will cause it to log SQL EXPLAIN details.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n# Windows PowerShell\n$env:DEBUG='@dataplan/pg:PgExecutor:explain'; postgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Extending the Default Preset with graphile-build (JavaScript)\nDESCRIPTION: This code demonstrates how to create a new Graphile Build preset by extending the default preset. The preset is defined as an exportable JavaScript object, which can then be fed into Graphile Build's schema building mechanisms. Requires the 'graphile-build' module; ensure it is installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defaultPreset } from \\\"graphile-build\\\";\n\nexport default {\n  extends: [defaultPreset],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile to Use a Composite JWT Token Structure (Bash)\nDESCRIPTION: Demonstrates starting PostGraphile via CLI with the '--jwt-token-identifier' flag to enable JWT token encoding based on a user-defined composite type. Necessary dependencies include a PostGraphile CLI installation and a predefined composite type in the connected PostgreSQL schema. The key parameter is the fully-qualified type name. Input is the bash command; output is that PostGraphile will expect and issue JWT tokens representing the specified type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_31\n\nLANGUAGE: Bash\nCODE:\n```\npostgraphile --jwt-token-identifier forum_example.jwt_token\n```\n\n----------------------------------------\n\nTITLE: Migrating ExecutableStep.execute Signature in TypeScript\nDESCRIPTION: This snippet demonstrates the migration required when updating the signature of the 'execute' method in custom step classes extending 'ExecutableStep'. The previous signature receives parameters directly; the new signature uses a destructured object that allows handling new batching logic for dependencies. Users must update their implementations accordingly, ensuring any code relying on 'count', 'values', and 'extra' adapts to the new destructured model. The example assumes TypeScript and the presence of types 'ExecutionExtra' and 'ExecutionDetails'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- async execute(count: number, values: any[][], extra: ExecutionExtra) {\n+ async execute({ count, values: newValues, extra }: ExecutionDetails) {\n+   const values = newValues.map((dep) =>\n+     dep.isBatch ? dep.entries : new Array(count).fill(dep.value)\n+   );\n    // REST OF YOUR FUNCTION HERE\n  }\n```\n\n----------------------------------------\n\nTITLE: Building a PostgreSQL Image with Initialization Scripts - Dockerfile\nDESCRIPTION: This Dockerfile uses the official Postgres 11.0-alpine image as a base and copies initialization SQL scripts from the './init/' directory on the host into the container's '/docker-entrypoint-initdb.d/' directory. When the container starts for the first time, PostgreSQL will automatically execute all scripts in that directory. Inputs: the directory and SQL scripts. Outputs: a custom PostgreSQL image with schema/data initialization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_9\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM postgres:11.0-alpine\\nCOPY ./init/ /docker-entrypoint-initdb.d/\n```\n\n----------------------------------------\n\nTITLE: Joining SQL INNER JOIN Clauses with sql.join() - JavaScript\nDESCRIPTION: This snippet demonstrates combining multiple SQL INNER JOIN statements using sql.join() to build a dynamic FROM/JOIN clause for complex queries. It depends on sql-template-tag for safe templating. The code takes an array of join fragments and a space delimiter to concatenate them into a valid SQL clause. Inputs are join fragments; the output is a FROM/JOIN clause for a SELECT statement.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-join.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst arrayOfSqlInnerJoins = [\n  sql`inner join bar on (bar.foo_id = foo.id)`,\n  sql`inner join baz on (baz.bar_id = bar.id)`,\n];\nsql`select * from foo ${sql.join(arrayOfSqlInnerJoins, \" \")}`;\n// select * from foo inner join bar on (bar.foo_id = foo.id) inner join baz on (baz.bar_id = bar.id)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Asynchronous Steps in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet illustrates the representation of an asynchronous step in a Grafast plan diagram. These steps, often involving communication with external resources, are shown with a double border on the left and right. The example shows a 'LoadOne' step.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    LoadOne18[[\"LoadOne[18âˆˆ3]<br />á¸userByIdá³\"]]:::plan\n    class LoadOne18 bucket2\n\n```\n\n----------------------------------------\n\nTITLE: Setting a Manual Reference Name with te.ref in JavaScript\nDESCRIPTION: This snippet demonstrates how to explicitly set the identifier name when referencing an external JavaScript variable in generated function code using the te templating engine. By passing a second parameter to te.ref, the identifier is manually set to the provided name ('source'), making the function easier to debug. The snippet requires the te template engine, assert, and the Source class. Key parameters are the external object (source), the string (spec), and the manual name for the identifier. The output is a function string referencing 'source' directly. Constraints: The user must ensure custom names do not clash with other identifiers.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-ref.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst source = new Source(/* ... */);\nconst spec = \"some string here\";\n\nconst plan = te.run`\\\n  return function plan($record) {\n    const $records = ${te.ref(source, \"source\")}.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Deleting a Topic with GraphQL Mutation (GraphQL)\nDESCRIPTION: Submits a GraphQL mutation to delete a topic by id, returning the 'deletedTopicNodeId' as confirmation. The mutation expects an input containing the target topic's id and assumes backend support for deletions via GraphQL. The response includes the encoded node ID of the removed topic. It is critical that the schema and permissions allow deletion operations for proper function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/mutations.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  deleteTopic(input: { id: 1 }) {\n    deletedTopicNodeId\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"deleteTopic\": {\n    \"deletedTopicNodeId\": \"WyJ0b3BpY3MiLDFd\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.12\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.12' of the 'grafast' package as noted in the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.12\n```\n\n----------------------------------------\n\nTITLE: Refactoring Plan Resolver with FieldArgs Destructuring (JavaScript/Diff)\nDESCRIPTION: This diff showcases a refactoring pattern within a Gra*fast* plan resolver (`updateUser`) for a Mutation. It demonstrates replacing multiple calls to `fieldArgs.getRaw()` with direct destructuring of steps (like `$id`, `$username`, `$bio`) from the `FieldArgs` object (represented as the second argument), resulting in more concise and readable resolver code. This change was introduced in pull request #358.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n const plans = {\n   Mutation: {\n-    updateUser(_, fieldArgs) {\n-      const $id = fieldArgs.getRaw(['input', 'id']);\n-      const $username = fieldArgs.getRaw(['input', 'patch', 'username']);\n-      const $bio = fieldArgs.getRaw(['input', 'patch', 'bio']);\n+    updateUser(_, { $input: { $id, $patch: { $username, $bio } } }) {\n       return pgUpdateSingle(\n         usersResource,\n         { id: $id },\n         { username: $username, bio: $bio }\n       );\n     }\n```\n```\n\n----------------------------------------\n\nTITLE: Simplifying Multi-Key Foreign Keys in Field Names - Graphile SQL & Diff\nDESCRIPTION: This pair of snippets demonstrates the impact of pluralization and key reduction in naming reverse relationships for tables with composite foreign keys. The SQL shows the foreign key declaration, and the diff reveals the resulting shorter, more expressive field name in the generated GraphQL schema. Requires a relational schema in PostgreSQL and enables auto-naming logic based on foreign key structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n  foreign key (organization_id, team_id, goal_uuid) references goals\n```\n\n----------------------------------------\n\nTITLE: Avoiding Procedural Constructs in SQL Functions\nDESCRIPTION: Highlights `IF` and `LOOP` as examples of procedural programming constructs that should generally be avoided in PostgreSQL functions used with PostGraphile. Preferring declarative SQL constructs is recommended for better performance and compatibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nIF\n```\n\nLANGUAGE: sql\nCODE:\n```\nLOOP\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL-Compliant Error Response (JSON)\nDESCRIPTION: Shows an example JSON response returned by the custom `authErrors` middleware when an authentication error occurs, such as a missing authorization token. The response follows the GraphQL error specification format, containing an `errors` array with objects detailing the error message.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwk-verification.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"errors\": [\n    {\n      \"message\": \"No authorization token was found\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Composite Type Mapping (GraphQL)\nDESCRIPTION: This GraphQL snippet shows the corresponding GraphQL object type `MyType` that PostGraphile generates from the SQL composite type `my_schema.my_type`. The fields `foo` and `bar` from the composite type are mapped directly to fields in the GraphQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\ntype MyType {\n  foo: Int\n  bar: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Computed Column with Arguments in PostgreSQL (SQL)\nDESCRIPTION: Illustrates creating a PostgreSQL computed column function that takes extra arguments beyond the table type, resulting in a GraphQL field with arguments. Requires 'my_schema.users' table. The first argument is the user row; the second ('greeting') is exposed to GraphQL clients. The function concatenates the greeting with the user's name. Output is personalized greeting text. Limitation: all arguments must have SQL-compatible types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\n-- Creates `User.greet(greeting: String)` string field\ncreate function my_schema.users_greet(\n  u my_schema.users,  --- required table type parameter, unexposed\n  greeting text       --- additional parameter, will be exposed\n) returns text as $$\n  select greeting || ', ' || u.first_name || ' ' || u.last_name || '!';\n$$ language sql stable strict;\n```\n\n----------------------------------------\n\nTITLE: Wrapping Non-Scalar Computed Columns for Sorting in Graphile - SQL\nDESCRIPTION: This set of SQL snippets shows how to enable sorting on non-scalar computed columns by wrapping them with scalar-returning functions. The approach is to create a computed column that returns a composite type, wrap it with another function returning the desired scalar (or an array), and then apply the @sortable comment. Dependencies include underlying composite types and properly defined functions in the database. Inputs are standard PostgreSQL CREATE FUNCTION and COMMENT commands. This pattern is essential for scenarios where direct sorting or filtering on composite results is not supported.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_31\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar function\ncreate or replace function user_object(user user) returns object as $$\nselect * from object where id = user.object_id;\n$$ language sql stable;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\ncreate or replace function user_object_field(user user) returns varchar as $$\nselect (user_object(user)).field;\n$$ language sql stable;\n\n-- don't forget the comments...\ncomment on function user_object_field() is E'@sortable';\n```\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar setof function\ncreate or replace function user_objects(user user) returns setof object as $$\nselect * from object where owner_id = user.id; -- one user, many objects\n$$ language sql stable;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\ncreate or replace function user_object_fields(user user) returns varchar[] as $$\nselect array_agg((user_objects(user)).field);\n$$ language sql stable;\n\n-- don't forget the comments...\ncomment on function user_object_fields() is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin Behavior (String, JS)\nDESCRIPTION: This JavaScript code defines a simple PostGraphile plugin named `FavourListsPlugin`. It uses the `schema.globalBehavior` property set to a string `\"-connection +list\"` to prepend this behavior to the global default behaviors. This approach modifies the schema generation to favor lists over connections globally, intended for use within presets.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst FavourListsPlugin = {\n  name: \"FavourListsPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    globalBehavior: \"-connection +list\",\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile V5 Beta via npx\nDESCRIPTION: This command demonstrates the quickest way to try PostGraphile V5 using `npx`, which downloads and runs the `pgl` command-line tool from the `@beta` tag without needing a permanent installation. It uses the `pgl/amber` preset (`-P`), enables relay specification support (`-e`), connects to a specified PostgreSQL database (`-c`), and targets a specific schema (`-s`). Users need to replace `postgres:///my_db` and `public` with their actual database connection string and schema name(s).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/news/2023-08-03-beta-release.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx pgl@beta -P pgl/amber -e -c postgres:///my_db -s public\n```\n\n----------------------------------------\n\nTITLE: Authenticated Relay Network Layer with JWT - JavaScript\nDESCRIPTION: Defines a 'fetchQuery' function for Relay that transmits JWTs within the 'Authorization' header for GraphQL queries, and constructs a network environment using this transport. Dependencies: Relay, fetch API. Expects JWT token from 'getJWTToken()', sends GraphQL operations and variables, receives JSON responses.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfunction fetchQuery( operation, variables, cacheConfig, uploadables) {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n      authorization: token ? `Bearer ${token}` : \"\",\n    },\n    body: JSON.stringify({\n      query: operation.text, // GraphQL text from input\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  });\n}\n\nconst environment = new Environment({\n  network: Network.create(fetchQuery),\n  store: new Store(new RecordSource()),\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying Node.js Installation and Version using Bash\nDESCRIPTION: Verifies the Node.js installation and checks the installed version using the `-v` flag, which is a shorthand for `--version`. This command should be run after installation to confirm success and check if the version meets requirements (e.g., 16.20.0 or higher for PostGraphile). Requires Node.js to be in the PATH.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Defining the Root Query Type in PostGraphile-Generated GraphQL Schema - GraphQL\nDESCRIPTION: This GraphQL schema snippet shows the root 'Query' type that PostGraphile generates based on detected table and column structures. It provides connections for retrieving lists of users with pagination and filtering, single-record queries by unique keys, and global node lookup, aligning with Relay-compatibility patterns. Dependencies include a properly introspected PostgreSQL schema and the PostGraphile engine; expected inputs are arguments to queries, such as filtering conditions, ordering, cursors for pagination, and key-based queries. Limitations are defined by the underlying database schema and any RBAC permissions enforced at introspection time.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/tables.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query implements Node {\n  allUsers(\n    first: Int\n    last: Int\n    offset: Int\n    before: Cursor\n    after: Cursor\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n    condition: UserCondition\n  ): UsersConnection\n\n  userById(id: Int!): User\n\n  userByUsername(username: String!): User\n\n  user(nodeId: ID!): User\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL for Logical Decoding (wal2json)\nDESCRIPTION: Specifies PostgreSQL `postgresql.conf` settings (`wal_level`, `max_wal_senders`, `max_replication_slots`) required for the `@graphile/subscriptions-lds` plugin, enabling logical decoding for live queries. These settings control write-ahead log level and replication connections.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nwal_level = logical\nmax_wal_senders = 10\nmax_replication_slots = 10\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile JWT Type Specification in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to configure PostGraphile using `graphile.config.mjs`. It specifies the PostgreSQL composite type (`jwt_token`) that PostGraphile should recognize for generating JWTs via the `preset.gather.pgJwtTypes` setting. The value should be a schema-qualified type name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  gather: {\n    pgJwtTypes: \"jwt_token\",\n  },\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Installing diffutils on macOS with Homebrew (Shell)\nDESCRIPTION: Uses the Homebrew package manager on macOS to install the `diffutils` package. This provides an updated version of the `diff` command, which is required for reliable snapshot testing within the project.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nbrew install diffutils\n```\n\n----------------------------------------\n\nTITLE: Creating Test Tables for One-to-One Relations with PostgreSQL\nDESCRIPTION: Demonstrates how to create two related tables using SQL, establishing a one-to-one relationship by having a primary key reference. Requires a running PostgreSQL server and appropriate privileges. The 'foo' table is a simple primary key table, and 'bar' creates a primary key and foreign key to 'foo'. Intended for clarifying backward relation support changes in PostGraphile v4; no input records are included, and constraints enforce referential integrity.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v3-migration.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table foo (\n  id serial primary key\n);\n\ncreate table bar (\n  foo_id int not null primary key references foo,\n  name text\n);\n```\n\n----------------------------------------\n\nTITLE: Renaming Entities using PostGraphile Tags File (JSON5)\nDESCRIPTION: Uses the `postgraphile.tags.json5` file to apply the `@name` smart tag. It renames the database class (table) `post` to `message` and the procedure (function) `search_posts` to `returnPostsMatching` in the resulting GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      post: {\n        tags: {\n          name: \"message\",\n        },\n      },\n    },\n    procedure: {\n      search_posts: {\n        tags: {\n          name: \"returnPostsMatching\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Role for PostGraphile Access - SQL\nDESCRIPTION: This SQL command creates a new Postgres role `forum_example_postgraphile` with login capability and the specified password, intended for use as the main connection identity for PostGraphile. It requires appropriate superuser or CREATEROLE privileges in the database. Parameters such as password should be set securely. After creation, this role can be used by PostGraphile to access the database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_22\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_postgraphile login password 'xyz';\n```\n\n----------------------------------------\n\nTITLE: Defining Update Triggers for Timestamp Management - PostgreSQL - SQL\nDESCRIPTION: This set of SQL statements implements a trigger function and two BEFORE UPDATE triggers to automatically update the 'updated_at' timestamp on rows when they are modified. The function is defined in the 'forum_example_private' schema and is referenced in triggers applied to 'forum_example.person' and 'forum_example.post'. Required dependencies include the tables involved and PL/pgSQL support. The function must be created before the triggers, and the triggers ensure the 'updated_at' field reflects the latest update for each row.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_18\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function forum_example_private.set_updated_at() returns trigger as $$\nbegin\n  new.updated_at := current_timestamp;\n  return new;\nend;\n$$ language plpgsql;\n\ncreate trigger person_updated_at before update\n  on forum_example.person\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n\ncreate trigger post_updated_at before update\n  on forum_example.post\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enums Programmatically with makeExtendSchemaPlugin (JavaScript)\nDESCRIPTION: Shows how to use PostGraphile's `makeExtendSchemaPlugin` utility to define a GraphQL enum `AnimalType` using GraphQL Schema Definition Language (SDL) within `typeDefs`. It also extends the `Pet` type to include a `type` field of this enum type and defines resolver `plans` to map database values (e.g., 'cat') to GraphQL enum values (e.g., CAT). Note the `Pet.type` plan requires further implementation logic. Dependencies include `postgraphile/grafast` and `postgraphile/utils`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/enums.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { constant } from \"postgraphile/grafast\";\nimport { gql, makeExtendSchemaPlugin } from \"postgraphile/utils\";\n\nconst myPlugin = makeExtendSchemaPlugin(() => ({\n  typeDefs: gql`\n    enum AnimalType {\n      \"\"\"\n      A feline animal\n      \"\"\"\n      CAT\n\n      \"\"\"\n      A canine animal\n      \"\"\"\n      DOG\n\n      \"\"\"\n      An aquatic animal\n      \"\"\"\n      FISH\n    }\n\n    extend type Pet {\n      type: AnimalType!\n    }\n  `,\n  plans: {\n    AnimalType: {\n      CAT: \"cat\",\n      DOG: \"dog\",\n      FISH: \"fish\",\n    },\n    Pet: {\n      type() {\n        /* TODO: add logic here */\n        return constant(\"cat\");\n      },\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for PostgreSQL Service (YAML)\nDESCRIPTION: Defines a multi-container Docker application using Docker Compose format version 3.3. It sets up a single service named `db` for the PostgreSQL database. Key configurations include setting a container name, ensuring it always restarts, specifying the image to use (built from the context `./db`), mounting a named volume `db` for persistent data storage at `/var/lib/postgresql/data`, loading environment variables from the `.env` file, connecting it to a custom network named `network`, and mapping host port 5432 to container port 5432. The network and volume are also explicitly defined.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_10\n\nLANGUAGE: yml\nCODE:\n```\nversion: \"3.3\"\nservices:\n  db:\n    container_name: forum-example-db\n    restart: always\n    image: forum-example-db\n    build:\n      context: ./db\n    volumes:\n      - db:/var/lib/postgresql/data\n    env_file:\n      - ./.env\n    networks:\n      - network\n    ports:\n      - 5432:5432\n\nnetworks:\n  network:\n\nvolumes:\n  db:\n```\n\n----------------------------------------\n\nTITLE: Creating a Table and Omitting Update/Delete via Smart Comments - SQL\nDESCRIPTION: This SQL snippet creates a table named 'forum_example.book' and attaches a smart comment that omits update and delete operations from GraphQL. Useful for limiting mutations exposed by the API. Requires PostgreSQL and PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.book (\n  col1 int\n);\n\ncomment on table forum_example.book is E'@omit update,delete';\n```\n\n----------------------------------------\n\nTITLE: Querying User Accounts in Authentication Logic (PL/pgSQL)\nDESCRIPTION: Performs a parameterized SQL SELECT within PL/pgSQL to retrieve an account record based on the provided email address input. Demonstrates how to fetch user data for the purpose of validating credentials during login. Requires the 'forum_example_private.person_account' table and must be run inside a PL/pgSQL context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_33\n\nLANGUAGE: plpgsql\nCODE:\n```\nselect a.* into account\nfrom forum_example_private.person_account as a\nwhere a.email = $1;\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with Random Type and Resolvers using Graphile Utils (JavaScript)\nDESCRIPTION: This code snippet creates a schema plugin that adds a new Random type and extends the Query type with a 'random' field. The Random type exposes a float property and a number(min, max) resolver returning a random integer in the provided range. Implemented using makeExtendSchemaPlugin and gql from graphile-utils, the resolvers are specified explicitly. Dependencies: graphile-utils; Node.js. Parameters: min (minimum) and max (maximum) for number generator. Input: GraphQL queries. Output: Random float or integer. Limitation: Only suitable when resolving simple random values without external state.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nmakeExtendSchemaPlugin((build) => ({\n  typeDefs: gql`\n    type Random {\n      float: Float!\n      number(min: Int!, max: Int!): Int!\n    }\n    extend type Query {\n      random: Random\n    }\n  `,\n  resolvers: {\n    Query: {\n      random() {\n        return {};\n      },\n    },\n    Random: {\n      float() {\n        return Math.random();\n      },\n      number(_parent, { min, max }) {\n        return min + Math.floor(Math.random() * (max - min + 1));\n      },\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Recommended PostGraphile Options for Production in JavaScript\nDESCRIPTION: This snippet provides a recommended set of PostGraphile options (`postgraphileOptions`) optimized for a production environment. It enables essential features like subscriptions and automatic retry on initialization failure (`retryOnInitFail`). It disables development-centric features like GraphiQL (`graphiql: false`) and the default query logging (`disableQueryLog: true`) for performance reasons. It keeps useful features like `dynamicJson`, batching, and includes the `pg-simplify-inflector` plugin. Error details are limited (`extendedErrors: ['errcode']`) for security.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nconst postgraphileOptions = {\n  subscriptions: true,\n  retryOnInitFail: true,\n  dynamicJson: true,\n  setofFunctionsContainNulls: false,\n  ignoreRBAC: false,\n  extendedErrors: [\"errcode\"],\n  appendPlugins: [require(\"@graphile-contrib/pg-simplify-inflector\")],\n  graphiql: false,\n  enableQueryBatching: true,\n  disableQueryLog: true, // our default logging has performance issues, but do make sure you have a logging system in place!\n  legacyRelations: \"omit\",\n  pgSettings(req) {\n    /* TODO */\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Graphile V5 TypeScript\nDESCRIPTION: Shows the V5 declarative style for defining the equivalent schema hook as the V4 example. Hooks are now defined within the `schema.hooks` object in the plugin configuration. Hook names use underscores instead of colons (e.g., `GraphQLObjectType_fields`). The function signature and purpose remain similar, receiving fields, build, and context, and returning fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst ExamplePlugin: GraphileConfig.Plugin = {\n  name: \"ExamplePlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        //...\n        return fields;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using te.ref for Variable Referencing with Automatic Naming\nDESCRIPTION: Shows how `te.ref` passes a value by reference into the generated function's scope. An identifier is automatically generated. The example aliases this generated identifier (`source`) within the generated code for better readability and debugging.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst source = new Source(/* ... */);\nconst spec = \"some string here\";\n\nconst plan = te.run`\\\n  const source = ${te.ref(source)};\n  return function plan($record) {\n    const $records = source.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Joining SQL Identifiers in SELECT Query using sql.join() - JavaScript\nDESCRIPTION: This snippet demonstrates how to use sql.join() to combine an array of SQL identifiers (such as column names) into a single SELECT statement, with the identifiers safely quoted. It requires the sql-template-tag library, and the key parameters are the list of field names and the delimiter (a comma and space). The input is an array of strings representing column names, and the output is a dynamic SQL fragment with correctly quoted identifiers for inclusion in a SELECT statement.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-join.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst arrayOfSqlFields = [\"a\", \"b\", \"c\", \"d\"].map((n) => sql.identifier(n));\nsql`select ${sql.join(arrayOfSqlFields, \", \")}`; // -> select \"a\", \"b\", \"c\", \"d\"\n```\n\n----------------------------------------\n\nTITLE: Installing wal2json using Git and Make (Bash)\nDESCRIPTION: Clones the `wal2json` repository from GitHub, changes into the directory, and then compiles and installs it using `make`. This requires `git`, `make`, and `pg_config` (pointing to the correct PostgreSQL installation) to be available in the system's PATH. `wal2json` is a required dependency for `@graphile/lds`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/eulerto/wal2json.git\ncd wal2json\nUSE_PGXS=1 make\nUSE_PGXS=1 make install\n```\n\n----------------------------------------\n\nTITLE: Increased Specificity in Graphile Behavior Checks (Plaintext)\nDESCRIPTION: Highlights the introduction of more specific behavior checks in version 5.0.0-0.14. The system now evaluates finer-grained behaviors (e.g., `source:update`, `constraint:source:update`, `attribute:update`) before considering broader ones (e.g., `update`), allowing for more precise schema customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_20\n\nLANGUAGE: plaintext\nCODE:\n```\n# v5.0.0-0.14: Enhanced behavior specificity\n\n# System now checks for more specific behaviors first, e.g.:\n# - source:update\n# - constraint:source:update\n# - attribute:update\n\n# Before falling back to broader behaviors like:\n# - update\n```\n\n----------------------------------------\n\nTITLE: Listing Graphile Configuration Options using Bash\nDESCRIPTION: Introduces the 'graphile config options' command as part of the new 'graphile' command-line tool (pull request #176). This command lists available configuration options within the Graphile system, helping users discover available settings and understand configuration possibilities.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile/CHANGELOG.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngraphile config options\n```\n\n----------------------------------------\n\nTITLE: Applying Where Clause Graphile V4 TypeScript\nDESCRIPTION: Example of adding a WHERE condition in a Graphile V4 plugin hook using the `QueryBuilder`. It accesses the parent query builder to get its table alias and uses that alias within an `sql.fragment` to construct the WHERE clause, checking for a non-null `archived_at` column on the parent.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// V4\nconst parentAlias = queryBuilder.parentQueryBuilder.getTableAlias();\nqueryBuilder.where(sql.fragment`${parentAlias}.archived_at is not null`);\n```\n\n----------------------------------------\n\nTITLE: Enabling Live Queries via PostGraphile CLI (Shell)\nDESCRIPTION: Demonstrates how to enable live queries when running PostGraphile from the command line. It uses the `--live` flag, provides a necessary `--owner-connection` string with elevated privileges for replication, and appends the `@graphile/subscriptions-lds` plugin using `--append-plugins`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npostgraphile \\\n  --connection postgres://postgraphile_user:postgraphile_pass@host/db \\\n  --live \\\n  --owner-connection postgres://db_owner:db_owner_pass@host/db \\\n  --append-plugins @graphile/subscriptions-lds \\\n  ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Heroku Web Process via Procfile (Procfile)\nDESCRIPTION: Defines the 'web' process type in a Heroku `Procfile`. This line tells Heroku's dyno manager to execute the `yarn start` command to launch the primary web service for the application. The `yarn start` script should be defined in the project's `package.json`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_9\n\nLANGUAGE: procfile\nCODE:\n```\nweb: yarn start\n```\n\n----------------------------------------\n\nTITLE: Installing @grafserv/persisted package using Shell\nDESCRIPTION: This snippet demonstrates how to install the `@grafserv/persisted` package, specifically the beta version, into a project using either Yarn or npm package managers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @grafserv/persisted@beta\n# or: npm install --save @grafserv/persisted@beta\n```\n\n----------------------------------------\n\nTITLE: Writing a PostGraphile Integration Test Case (JavaScript)\nDESCRIPTION: This snippet illustrates how to write an integration test for a PostGraphile endpoint using the previously defined test helpers. It utilizes `beforeAll` and `afterAll` hooks for setup and teardown. The test case executes a GraphQL query using `runGraphQLQuery`, providing the query string, variables, mock request data (like user authentication), and an asynchronous checker function to perform assertions on the GraphQL response and potentially query the database within the test's transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/testing-jest.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst { setup, teardown, runGraphQLQuery } = require(\"../test_helper\");\n\nbeforeAll(setup);\nafterAll(teardown);\n\ntest(\"GraphQL query nodeId\", async () => {\n  await runGraphQLQuery(\n    // GraphQL query goes here:\n    `{ __typename }`,\n\n    // GraphQL variables go here:\n    {},\n\n    // Any additional properties you want `req` to have (e.g. if you're using\n    // `pgSettings`) go here:\n    {\n      // Assuming you're using Passport.js / pgSettings, you could pretend\n      // to be logged in by setting `req.user` to `{id: 17}`:\n      user: { id: 17 },\n    },\n\n    // This function runs all your test assertions:\n    async (json, { pgClient }) => {\n      expect(json.errors).toBeFalsy();\n      expect(json.data.__typename).toEqual(\"Query\");\n\n      // If you need to, you can query the DB within the context of this\n      // function - e.g. to check that your mutation made the changes you'd\n      // expect.\n      const { rows } = await pgClient.query(\n        `SELECT * FROM app_public.users WHERE id = $1`,\n        [17],\n      );\n      if (rows.length !== 1) {\n        throw new Error(\"User not found!\");\n      }\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Providing a Sample JWT Payload/Claims - JSON\nDESCRIPTION: Illustrates the typical structure of a decoded JWT payload as provided by Auth0, with fields including 'iss' (issuer), 'sub' (subject), 'aud' (audience), issue/expiry timestamps, and a representative 'scope' value (e.g., permissions). This sample clarifies which claims are expected and how application permissions might be carried in user tokens. No code dependencies. JSON structure to be adapted as necessary for application domain.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"iss\": \"https://YOUR_DOMAIN/\",\n  \"sub\": \"CLIENT_ID@clients\",\n  \"aud\": \"YOUR_API_IDENTIFIER\",\n  \"iat\": 1555808706,\n  \"exp\": 1555895106,\n  \"azp\": \"CLIENT_ID\",\n  \"scope\": \"read:schema\", // scopes a.k.a. permissions\n  \"gty\": \"client-credentials\"\n}\n```\n\n----------------------------------------\n\nTITLE: Matching a Set of Constraints - Pseudocode\nDESCRIPTION: This function checks whether an object satisfies a sequence of constraints by evaluating each through another constraint-matching function. It is generic and can be used for variable, context, or rootValue constraints. Inputs: constraints array and the object; Output: true if all constraints match, false otherwise. Assumes a MatchesConstraint() helper for individual constraint evaluation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\nMatchesConstraints(constraints, object):\n\n- For each {constraint} in {constraints}:\n  - If not {MatchesConstraint(constraint, object)}:\n    - Return {false}.\n- Return {true}.\n```\n\n----------------------------------------\n\nTITLE: Referencing 'pgServices' Configuration Object (JavaScript)\nDESCRIPTION: Refers to the `pgServices` object, typically used in Graphile configuration to define settings for PostgreSQL data sources. The breaking change discussed in version 5.0.0-beta.26 involves how the `adaptor` property within this configuration is specified.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\npgServices\n```\n\n----------------------------------------\n\nTITLE: Accessing pgSubscriber from GraphQL Execution Context (TypeScript)\nDESCRIPTION: This TypeScript code snippet shows how to retrieve the `pgSubscriber` object from the GraphQL execution context within a resolver. The `pgSubscriber` enables pubsub capabilities via PostgreSQL's LISTEN/NOTIFY and is accessible in resolvers if supported by the configured PostGraphile adapter. No additional dependencies are required, and this is typically used inside a resolver or plan definition to set up subscription listening.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst $pgSubscriber = context().get(\"pgSubscriber\");\n```\n\n----------------------------------------\n\nTITLE: Quickstart: Building and Printing a Schema with Presets - Graphile Engine - JavaScript\nDESCRIPTION: This snippet demonstrates quickstarting a project by importing buildSchema and defaultPreset from 'graphile-build', as well as printSchema from 'graphql'. It sets up a custom preset array (extending from defaultPreset), asynchronously builds the schema with buildSchema(preset), and prints the resulting schema using printSchema. Inputs include preset configuration. Outputs are printed SDL. Dependencies: graphile-build and graphql, with an async runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { buildSchema, defaultPreset } from \"graphile-build\";\nimport { printSchema } from \"graphql\";\n\nconst preset = {\n  extends: [\n    defaultPreset,\n    // Add more presets here!\n  ],\n};\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n```\n\n----------------------------------------\n\nTITLE: Defining Graphile Export ESLint Rules in JavaScript/JSON\nDESCRIPTION: This code block illustrates how to declare specific rule overrides for the graphile-export plugin within an ESLint rules object. Each rule such as 'exhaustive-deps', 'export-methods', 'export-instances', 'export-subclasses', and 'no-nested' is enabled (set to level 2, which means 'error'). This configuration is typically included within the 'rules' section of an ESLint configuration file. Input is an object with rule levels, output is ESLint enforcing these rules when linting source code. As this is partial code, ensure correct placement within the complete ESLint config.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/eslint-plugin-graphile-export/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n      rules: {\n        \"graphile-export/exhaustive-deps\": 2,\n        \"graphile-export/export-methods\": 2,\n        \"graphile-export/export-instances\": 2,\n        \"graphile-export/export-subclasses\": 2,\n        \"graphile-export/no-nested\": 2,\n      },\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict TypeScript Settings for V5 Plugins\nDESCRIPTION: Example `tsconfig.json` settings required for PostGraphile V5 plugin development after initial migration. It emphasizes enabling `strict` mode and `noImplicitAny` to leverage V5's strong typing system for better autocompletion, documentation, and type safety.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true,\n    \"noImplicitAny\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Tables and Columns with COMMENT in PostgreSQL - SQL\nDESCRIPTION: Shows how to richly document a table ('forum_example.person') and its columns using SQL COMMENT statements. Proper documentation enables tools like PostGraphile and GraphiQL to provide in-context help and domain-specific details directly from the database. There are no dependencies other than PostgreSQL; use immediately after table creation to maintain up-to-date data definitions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.person is 'A user of the forum.';\ncomment on column forum_example.person.id is 'The primary unique identifier for the person.';\ncomment on column forum_example.person.first_name is 'The personâ€™s first name.';\ncomment on column forum_example.person.last_name is 'The personâ€™s last name.';\ncomment on column forum_example.person.about is 'A short description about the user, written by the user.';\ncomment on column forum_example.person.created_at is 'The time this person was created.';\n```\n\n----------------------------------------\n\nTITLE: Comparing Lambda with LoadOne (Multiple Dependencies) in TypeScript\nDESCRIPTION: This snippet demonstrates using `loadOne` for the addition task involving multiple dependencies (`$a`, `$b`), contrasting it with the `lambda` example. `loadOne` accepts an array of steps and its callback receives an array (`allAsAndBs`) where each element is a pair `[a, b]` corresponding to the resolved values for one execution. The `map` function is used to calculate the sum for each pair, enabling batch processing. This is typically more efficient than `lambda` for operations that could benefit from batching.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $aPlusB = loadOne([$a, $b], (allAsAndBs) =>\n  allAsAndBs.map(([a, b]) => a + b),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Grafast Step Class and Factory Function in TypeScript\nDESCRIPTION: This snippet demonstrates creating a custom Grafast step class `GetRandomNumberStep` extending `Step`. Its `execute` method always returns an array filled with the number 4, referencing XKCD 221. A factory function `getRandomNumber` is provided for convenient instantiation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/** XKCD-221 step class @ref https://xkcd.com/221/ */\nclass GetRandomNumberStep extends Step {\n  execute({ count }) {\n    return new Array(count).fill(4); // chosen by fair dice roll.\n                                     // guaranteed to be random.\n  }\n}\n\nfunction getRandomNumber() {\n  return new GetRandomNumberStep();\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming ExecutableStep to Step in Grafast (TypeScript)\nDESCRIPTION: As part of removing `ModifierStep` and `BaseStep`, the core `ExecutableStep` class in Grafast has been renamed to `Step` for simplicity. The old name `ExecutableStep` is now deprecated.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nExecutableStep\n```\n\nLANGUAGE: typescript\nCODE:\n```\nStep\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for PostgreSQL Image - Dockerfile\nDESCRIPTION: Defines a two-line Dockerfile for building a PostgreSQL 11.0-alpine-based image, copying SQL initialization scripts into '/docker-entrypoint-initdb.d/'. Depends on folder structure with './init' containing SQL files. Used by Docker and Docker Compose for initializing database containers. Input: base image, SQL files. Output: Docker image ready for init script execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_9\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM postgres:11.0-alpine\\nCOPY ./init/ /docker-entrypoint-initdb.d/\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with Authentication User - Bash\nDESCRIPTION: This bash command demonstrates how to launch the PostGraphile server using a specific authenticated PostgreSQL user via connection string. Dependencies: PostGraphile CLI installed, valid PostgreSQL server/database, existing 'auth_user' role. Parameters: Connection string (user, host, database). Input: CLI arguments. Output: PostGraphile server started with specified credentials.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/default-role.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Updating Environment Variables for PostGraphile Connection\nDESCRIPTION: Adds the `DATABASE_URL` variable to the `.env` file. This variable provides the connection string for PostGraphile to connect to the PostgreSQL database container, specifying the user, password, host (service name 'db'), port, and database name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_12\n\nLANGUAGE: dotenv\nCODE:\n```\n[...]\n# GRAPHQL\n# Parameters used by graphql container\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\n```\n\n----------------------------------------\n\nTITLE: Renaming 'pgConfigs' to 'pgServices' in TypeScript/JavaScript\nDESCRIPTION: Illustrates the renaming of configuration-related identifiers. `pgConfigs` is renamed to `pgServices`, `makePgConfig` to `makePgService`, and `MakePgConfigOptions` to `MakePgServiceOptions`. This primarily affects configuration files like `graphile.config.ts`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\npgConfigs -> pgServices\nmakePgConfig -> makePgService\nMakePgConfigOptions -> MakePgServiceOptions\n\n// Affects files like:\ngraphile.config.ts\n```\n\n----------------------------------------\n\nTITLE: Defining the pgPolymorphic Function Signature in TypeScript\nDESCRIPTION: Defines the TypeScript function signature for `pgPolymorphic` within commented-out documentation. This function accepts an item step (`$item`), a specifier step (`$typeSpecifier`), and a `PgPolymorphicTypeMap` to handle various polymorphism patterns by dynamically choosing the correct plan based on the specifier's runtime value.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport function pgPolymorphic(\n  $item: PgSelectSingleStep | PgClassExpressionStep\n  $typeSpecifier: ExecutableStep,\n  possibleTypes: PgPolymorphicTypeMap\n): PgPolymorphicStep\n```\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Plugin in PostGraphile Configuration (TypeScript)\nDESCRIPTION: This snippet demonstrates how to integrate a custom plugin, like the previously defined `AddHttpBinPlugin`, into the PostGraphile configuration using a `graphile.config.mjs` file. The custom plugin is imported and added to the `plugins` array within the exported configuration object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending-raw.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport AddHttpBinPlugin from \"./add-http-bin-plugin.js\";\n\nexport default {\n  // ...\n  plugins: [AddHttpBinPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring connection() with edgeDataPlan Option - TypeScript\nDESCRIPTION: This TypeScript snippet provides an example of how to use the updated connection() function. It accepts a configuration object that includes edgeDataPlan, enabling the association of additional edge data with connection edges. The example demonstrates both the configuration of the connection and the retrieval of additional edge data from the plans object. Inputs include $list, $item, and $otherThing; outputs are enriched edge objects. Required dependencies are the underlying connection() utility and integration with Graphile Crystal's execution framework.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\\nreturn connection($list, {\\n  edgeDataPlan($item) {\\n    return object({ item: $item, otherThing: $otherThing });\\n  },\\n});\\n\\n// ...\\n\\nconst plans = {\\n  FooEdge: {\\n    otherThing($edge) {\\n      return $edge.data().get(\\\"otherThing\\\");\\n    },\\n  },\\n};\\n```\n```\n\n----------------------------------------\n\nTITLE: Replacing BaseGraphQLContext with Grafast.Context\nDESCRIPTION: Indicates a global replacement throughout the codebase where `BaseGraphQLContext` has been replaced with `Grafast.Context`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nReplace BaseGraphQLContext with Grafast.Context throughout.\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Docker Image (Dockerfile)\nDESCRIPTION: Defines the build instructions for a custom PostgreSQL Docker image. It starts from the official `postgres:11.0-alpine` base image (a specific version of PostgreSQL on a minimal Linux distribution). It then copies the contents of the local `./init/` directory (containing the .sql initialization scripts) into the `/docker-entrypoint-initdb.d/` directory within the container. Scripts in this directory are automatically executed by the entrypoint script of the official Postgres image upon first container start.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_9\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM postgres:11.0-alpine\nCOPY ./init/ /docker-entrypoint-initdb.d/\n```\n\n----------------------------------------\n\nTITLE: Defining an Importable Singleton with $$export (TypeScript)\nDESCRIPTION: This snippet demonstrates how to mark an object (db) as importable using the non-standard $$export property in TypeScript. By attaching the $$export property, Graphile Export can replace inline serialization with an import statement that sources db from the specified module and export name. Input is the object to be imported, and the $$export configuration; output is a value replaceable with a module import.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport const db = new DatabaseConnection();\n\n// highlight-start\n// Detail from where this value can be imported so that our exported schema\n// can import it at runtime.\ndb.$$export = { moduleName: \"./runtime/db\", exportName: \"db\" };\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Changing Input Object Field APIs in Grafast (TypeScript)\nDESCRIPTION: Input object fields no longer support plan-time methods `applyPlan` and `inputPlan`. Instead, they now have runtime equivalents `apply()` (called by `applyStep()`) and `baked()`. `FieldArgs` is no longer available in these runtime contexts; the actual value is passed directly.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napplyPlan // Removed from input object fields\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninputPlan // Removed from input object fields\n```\n\nLANGUAGE: typescript\nCODE:\n```\napply() // Runtime equivalent, called by applyStep()\n```\n\nLANGUAGE: typescript\nCODE:\n```\nbaked() // Runtime equivalent\n```\n\nLANGUAGE: typescript\nCODE:\n```\napplyStep()\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArgs // No longer passed to input field apply/baked\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Composite Type Example (SQL)\nDESCRIPTION: Creates an example PostgreSQL composite type named `my_schema.my_type`. This type acts like a structured object with named fields `foo` and `bar`, both of integer type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate type my_schema.my_type as (\n  foo integer,\n  bar integer\n);\n```\n\n----------------------------------------\n\nTITLE: Resolving Node ID to Specification using PostGraphile V5 (JavaScript)\nDESCRIPTION: This example illustrates how to handle Node IDs in PostGraphile V5 mutations. It retrieves the appropriate Node ID handler using `build.getNodeIdHandler`, then uses `specFromNodeId` to convert the provided Node ID into a specification object. This specification can then be used with data-fetching steps like `pgUpdateSingle` to identify the correct database record. This replaces the V4 `build.getTypeAndIdentifiersFromNodeId` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst typeName = \"User\";\nconst handler = build.getNodeIdHandler(typeName);\n\nconst plans = {\n  Mutation: {\n    updateUser(parent, fieldArgs) {\n      const spec = specFromNodeId(handler, fieldArgs.$id);\n      const plan = object({ result: pgUpdateSingle(userSource, spec) });\n      fieldArgs.apply(plan);\n      return plan;\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Finding 'source' Terms for Renaming using RegExp\nDESCRIPTION: Provides a regular expression to locate instances of 'source' related terms (e.g., ':source\\b' or '\\bsource:') that require updating to ':resource:' or 'resource:' as part of a large API renaming initiative announced in pull request #271. This helps users update their configurations and code to align with the stabilized API.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile/CHANGELOG.md#_snippet_0\n\nLANGUAGE: regexp\nCODE:\n```\n/:source\\b|\\bsource:[a-z$]/\n```\n\n----------------------------------------\n\nTITLE: Querying Polymorphic Data with Inline Fragments in GraphQL\nDESCRIPTION: Shows a GraphQL query requesting a polymorphic field ('bestAnimal') defined as an interface, using inline fragments to retrieve additional fields for concrete types ('Cat', 'Dog'). Inputs are the fields and fragment structures, and outputs are objects of various concrete types with merged fields. Demonstrates how to extract type-specific information while querying against interface-based results.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/polymorphism.mdx#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  bestAnimal {\n    name\n    ... on Cat {\n      numberOfLives\n    }\n    ... on Dog {\n      wagsTail\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disambiguating SQL Function Arguments Using Function Name\nDESCRIPTION: Demonstrates creating a stable SQL function `get_user` that retrieves a user by ID. It disambiguates the function argument `id` from the table column `users.id` by referencing the argument using the qualified function name: `get_user.id`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\n```sql {2}\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = get_user.id;\n$$ language sql stable;\n```\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema with Plugins - Graphile Engine - JavaScript\nDESCRIPTION: This snippet demonstrates how to build a GraphQL schema by providing a list of plugins to the buildSchema function in Graphile Engine. It relies on the buildSchema API, which expects an array of plugins as parameter and returns a fully constructed schema object. The primary input is pluginsâ€”an array of plugin definitions, and it outputs a schema suitable for further GraphQL operations. There are no specific limitations, but required dependencies include Graphile Engine with buildSchema available.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nbuildSchema(plugins);\n```\n\n----------------------------------------\n\nTITLE: Creating Foreign Key Indexes in PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates the creation of two tables ('users' and 'things') and explicitly creates an index on a foreign key column ('user_id'). The index ensures that reverse lookups (e.g., finding all things for a user) remain efficient and appear correctly in the GraphQL schema. Requires PostgreSQL with sufficient privileges to create tables and indexes; tables must not already exist, and the referenced table must be created first.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/best-practices.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table users (id serial primary key);\ncreate table things (id serial primary key, user_id int not null references users);\n/* highlight-next-line */\ncreate index on things (user_id);\n```\n\n----------------------------------------\n\nTITLE: Querying a Parameterized Computed Column in GraphQL - GraphQL\nDESCRIPTION: Demonstrates a GraphQL query that supplies a parameter to the 'greet' computed column, illustrating how PostGraphile exposes function parameters as field arguments. This pattern enables dynamic, user-driven values to be passed to computed columns at query time, and is contingent on corresponding function signatures in PostgreSQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  userById(id: â€¦) {\n    greet(greeting: \"Greetings and salutations\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Granting RDS Replication Privileges in PostgreSQL\nDESCRIPTION: This SQL command grants the `rds_replication` role to the specified database owner (`DB_OWNER`) on an Amazon RDS PostgreSQL instance. This is a necessary step for enabling PostGraphile Live Queries, as it allows the database owner role to manage logical replication slots required by the feature. Execute this command as a superuser after setting `rds.logical_replication` to 1.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/live-queries.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ngrant rds_replication to DB_OWNER;\n```\n\n----------------------------------------\n\nTITLE: Enforcing and Describing Enums Using Tables and Smart Tags in PostgreSQL - SQL\nDESCRIPTION: Implements enums via a dedicated 'animal_type' table and enforces their use with a foreign key constraint on 'pets'. The '@enum' smart tag on the table makes PostGraphile treat it as an enum table for GraphQL. The table includes a 'description' column to document each enum value, and example inserts provide initial data. The 'pets' table references the enum values by foreign key, ensuring referential integrity. Dependencies include running PostgreSQL and PostGraphile with smart comment/tag parsing enabled.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/enums.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table animal_type (\n  type text primary key,\n  description text\n);\ncomment on table animal_type is E'@enum';\ninsert into animal_type (type, description) values\n  ('CAT', 'A feline animal'),\n  ('DOG', 'A canine animal'),\n  ('FISH', 'An aquatic animal');\n\ncreate table pets (\n  id serial primary key,\n  type text not null references animal_type,\n  name text not null\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Forum Ordering by Latest Post Date using makeAddPgTableOrderByPlugin\nDESCRIPTION: This JavaScript code defines a PostGraphile plugin using `makeAddPgTableOrderByPlugin`. It targets the `app_public.forums` table and adds `LAST_POST_CREATED_AT_ASC` and `LAST_POST_CREATED_AT_DESC` orderings. The sorting logic uses a subquery (`sql.fragment`) to find the creation date of the latest post associated with each forum. The `orderByAscDesc` helper simplifies creating both ascending and descending options.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n/* TODO: test this plugin works! */\nmodule.exports = makeAddPgTableOrderByPlugin(\n  \"app_public\",\n  \"forums\",\n  ({ pgSql: sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"lastPostInForum\"));\n    return orderByAscDesc(\n      \"LAST_POST_CREATED_AT\",\n      ({ queryBuilder }) => sql.fragment`(\n        select ${sqlIdentifier}.created_at\n        from app_public.posts as ${sqlIdentifier}\n        where ${sqlIdentifier}.forum_id = ${queryBuilder.getTableAlias()}.id\n        order by ${sqlIdentifier}.created_at desc\n        limit 1\n      )`,\n    );\n  },\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Module Resolution for PostGraphile\nDESCRIPTION: This JSON snippet shows the required TypeScript configuration setting (`moduleResolution`) needed when using PostGraphile with TypeScript v5.0.0 or later. Setting it to `\"node16\"` or `\"nodenext\"` enables support for the `exports` property in `package.json`, which PostGraphile relies on. This configuration should be added to your `tsconfig.json` file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/requirements.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n```\n    \"moduleResolution\": \"node16\", // Or \"nodenext\"\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Very Deeply Nested Data with GraphQL\nDESCRIPTION: A very heavy, deeply nested GraphQL query retrieving albums for an artist, their tracks with genres, and related artist data including their other albums, tracks, media types, and genres. This query benchmarks PostGraphile's capability (approx. 550 requests/second) to handle complex, multi-level relationship fetching while maintaining low latency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/performance.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery prisma_deeplyNested {\n  allAlbumsList(condition: { artistId: 127 }) {\n    albumId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n    artistByArtistId {\n      albumsByArtistIdList {\n        tracksByAlbumIdList {\n          mediaTypeByMediaTypeId {\n            name\n          }\n          genreByGenreId {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running the graphile-lds Server (Bash)\nDESCRIPTION: Example command to start the `@graphile/lds` server using `npx`. It requires the `LD_DATABASE_URL` environment variable to be set with the connection string for the database that will be used for logical decoding. Other optional environment variables like `LD_TABLE_PATTERN`, `LD_PORT`, `LD_HOST`, `LD_SLOT_NAME`, `LD_MAX_CLIENTS`, and `LD_WAIT` can also be set to configure the server's behavior.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nLD_DATABASE_URL=\"postgres:///my_db\" npx graphile-lds\n```\n\n----------------------------------------\n\nTITLE: Defining te.tempVar() Function Signature\nDESCRIPTION: Signature of the experimental `te.tempVar` function. It accepts an optional `symbol` parameter (defaulting to a new Symbol) to create or retrieve a temporary variable. This variable can then be utilized within expressions or statements managed by the template engine (`te`).\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-temp-var.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nte.tempVar(symbol = Symbol())\n```\n\n----------------------------------------\n\nTITLE: Defining a STABLE PostgreSQL Function\nDESCRIPTION: Defines a function explicitly marked as `STABLE`. This indicates the function does not modify the database and returns consistent results for the same arguments within a single table scan, although results might change between statements (e.g., if it queries tables). `STABLE` functions are often exposed as queries or computed columns by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Switching Between PostGraphile Schemas on a Single Endpoint using Express Middleware (TypeScript)\nDESCRIPTION: This TypeScript code illustrates how to serve multiple PostGraphile schemas from a single endpoint using Express. It creates separate PostGraphile instances ('admin', 'user') and mounts them into distinct Express handlers. A custom middleware function inspects the incoming request (e.g., `req.user.isAdmin`) to dynamically route the request to the appropriate handler, effectively switching between the admin and user GraphQL schemas. Websockets and subscriptions are explicitly disabled in this configuration as switching logic might complicate their handling.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/multiple-schemas.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// TODO: this is untested!\nimport { createServer } from \"node:http\";\nimport express from \"express\";\nimport postgraphile from \"postgraphile\";\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\nimport userPreset from \"./graphile.config.mjs\";\n\n// Create an express app\nconst app = express();\n// (Add any Express middleware you want here.)\n\n// Create a Node HTTP server, mounting Express into it\nconst server = createServer(app);\nserver.on(\"error\", (e) => {\n  console.error(e);\n});\n\n// A preset shared between our services which disables websockets and\n// subscriptions since they are not supported\nconst commonPreset = {\n  extends: [userPreset],\n  grafserv: { websockets: false },\n  disablePlugins: [\"SubscriptionPlugin\"],\n};\n\n// The services we wish to switch between\nconst services = {\n  admin: {\n    handler: express(),\n    pgl: postgraphile({\n      extends: [commonPreset],\n      pgServices: [makePgService({ connectionString: \"postgres:///admin\" })],\n    }),\n  },\n  user: {\n    handler: express(),\n    pgl: postgraphile({\n      extends: [commonPreset],\n      pgServices: [makePgService({ connectionString: \"postgres:///user\" })],\n    }),\n  },\n};\n\n// Mount the PostGraphile instances into the handlers\nfor (const { handler, pgl } of Object.values(services)) {\n  const serv = pgl.createServ(grafserv);\n  serv.addTo(handler);\n}\n\n// Add a custom middleware to switch between these handlers\napp.use((req, res, next) => {\n  const isAdmin = req.user?.isAdmin;\n  if (isAdmin) {\n    services.admin.handler(req, res, next);\n  } else {\n    services.user.handler(req, res, next);\n  }\n});\n\n// Start the Express server\nserver.listen(userPreset.grafserv?.port ?? 5678);\n```\n```\n\n----------------------------------------\n\nTITLE: Sending JWT with Apollo Client WebSocket Link in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates configuring Apollo Client's `WebSocketLink` (from `@apollo/client/link/ws`) to send a JWT for GraphQL subscriptions or other operations over WebSockets. The JWT (retrieved via `getJWTToken()`) is included in the `connectionParams` object, specifically within the `authorization` property as a Bearer token, when the WebSocket connection is established.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/security.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\n// get the authentication token from wherever you store it\nconst token = getJWTToken();\n\nconst wsLink = new WebSocketLink({\n  uri: \"ws://localhost:3000/graphql\",\n  options: {\n    reconnect: true,\n    connectionParams: token\n      ? {\n          authorization: `Bearer ${token}`,\n        }\n      : {},\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating connection() Step Arguments in Graphile Crystal (TypeScript)\nDESCRIPTION: This snippet illustrates the API change for the connection() step, switching from multiple positional arguments to a configuration object. It provides a concrete example in TypeScript for specifying edgeDataPlan in the connection, enabling users to attach extra data to connection edges. The update aims to improve usability and flexibility of GraphQL connections. Expected input is a list and a configuration object; outputs are appropriately configured connection plans.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n-return connection($list, nodePlan, cursorPlan);\\n+return connection($list, { nodePlan, cursorPlan });\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Schema Behavior in PostGraphile (JS)\nDESCRIPTION: This JavaScript code snippet shows how to configure the global default behavior for a PostGraphile schema within the `graphile.config.mjs` file. It sets the `defaultBehavior` property within the `schema` object to `\"-connection +list\"`, which instructs PostGraphile to prefer generating GraphQL list fields instead of connection fields by default across the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// graphile.config.mjs\n\nconst preset = {\n  //...\n  schema: {\n    //...\n    defaultBehavior: \"-connection +list\",\n  },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Implementing Express Error Handling Middleware for JWT Authentication - JavaScript\nDESCRIPTION: Implements error handling middleware in Express to catch errors thrown by the JWT authentication middleware. Checks for 'UnauthorizedError' and responds with a 401 status and a GraphQL-style JSON error object. This prevents leaking sensitive server error details to the client and keeps error responses consistent with GraphQL API conventions. Should be mounted on the desired endpoint (e.g., '/graphql') after authentication middleware.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst authErrors = (err, req, res, next) => {\n  if (err.name === \"UnauthorizedError\") {\n    console.log(err); // You will still want to log the error...\n    // but we don't want to send back internal operation details\n    // like a stack trace to the client!\n    res.status(err.status).json({ errors: [{ message: err.message }] });\n    res.end();\n  }\n};\n\n// Apply error handling to the graphql endpoint\napp.use(\"/graphql\", authErrors);\n```\n\n----------------------------------------\n\nTITLE: Querying Lists of Polymorphic Data using GraphQL Interface and Fragments\nDESCRIPTION: Demonstrates a GraphQL query fetching a list of the interface type ('randomAnimals: [Animal]'), using inline fragments to select fields of concrete types within the list. Inputs are the fields and fragment specifications; outputs are lists whose items may be of any type implementing the specified interface. This pattern is used for queries against lists of polymorphic types in Gra*fast*.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/polymorphism.mdx#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  randomAnimals {\n    name\n    ... on Cat {\n      numberOfLives\n    }\n    ... on Dog {\n      wagsTail\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Database Schema - SQL\nDESCRIPTION: Initializes the PostgreSQL schema, creating 'user' and 'post' tables with appropriate fields and foreign key relationship. Contains table comments for documentation. Expected input: runs in a PostgreSQL database connection. Output: database schema for forum example.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\\n\\n/*Create user table in public schema*/\\nCREATE TABLE public.user (\\n    id SERIAL PRIMARY KEY,\\n    username TEXT,\\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP\\n);\\n\\nCOMMENT ON TABLE public.user IS\\n'Forum users.';\\n\\n/*Create post table in public schema*/\\nCREATE TABLE public.post (\\n    id SERIAL PRIMARY KEY,\\n    title TEXT,\\n    body TEXT,\\n    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n    author_id INTEGER NOT NULL REFERENCES public.user(id)\\n);\\n\\nCOMMENT ON TABLE public.post IS\\n'Forum posts written by a user.';\n```\n\n----------------------------------------\n\nTITLE: Using the Middleware System in TypeScript\nDESCRIPTION: Demonstrates the end-to-end usage of the custom middleware system in `src/main.ts`. It resolves a configuration file (`graphile.config.js`) using `resolvePreset`, obtains the configured middleware instance via `getMiddleware`, and then invokes the `someAction` middleware using `middleware.run`. The `run` method accepts the action name, an event object (`{ someParameter: 42 }`), and the core function to execute. An example implementation of the underlying `someAction` function, which the middleware wraps, is also provided.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/library-authors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"src/main.ts\"\n// Get the user's Graphile Config from somewhere, e.g.\nimport config from \"./graphile.config.js\";\n\n// Resolve the above config, recursively applying all the presets it extends from\nconst resolvedPreset = resolvePreset(config);\n\n// Get the middleware for this preset\nconst middleware = getMiddleware(resolvedPreset);\n\n// Then in the relevant place in your code, call the middleware around the\n// relevant functionality\nconst result = await middleware.run(\n  \"someAction\",\n  { someParameter: 42 }, // < `event` object\n  async (event) => {\n    // Note: `event` will be the same object as above, but its contents may\n    // have been modified by middlewares.\n    const { someParameter } = event;\n\n    // Call the underlying method to perform the action.\n    return await someAction(someParameter);\n  },\n);\n// The value of `result` should match the return value of `someAction(...)`\n// (unless a middleware tweaked or replaced it, of course!)\n\n// This is the thing that your middleware wraps. It can do anything, it's just\n// an arbitrary JavaScript function.\nfunction someAction(someParameter: number): PromiseOrDirect<SomeActionResult> {\n  // Do something here...\n  if (Math.random() < 0.5) {\n    return someParameter;\n  } else {\n    return sleep(200).then(() => someParameter);\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile Beta CLI via npx\nDESCRIPTION: This command executes the beta version of the PostGraphile CLI (`pgl@beta`) using `npx` without needing a global installation. It connects to a PostgreSQL database specified by the connection string '-c 'postgres:///mydb''. The '-P pgl/amber' flag likely applies a preset, and '-e' might enable specific extensions or features. The surrounding text notes that '-s' can be used to specify database schemas if they are not 'public'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/index.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx pgl@beta -P pgl/amber -e -c 'postgres:///mydb'\n```\n\n----------------------------------------\n\nTITLE: Integrating Grafserv with Node.js HTTP Server in TypeScript\nDESCRIPTION: Demonstrates creating a standard Node.js HTTP server using `node:http` and attaching the Grafserv instance (`serv`) to it using `serv.addTo(server)`. The server then listens on a specified port (defaulting to 5678 if not specified in the preset).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from \"node:http\";\nconst server = createServer();\nserver.on(\"error\", (e) => console.error(e));\n\n// highlight-next-line\nserv.addTo(server);\n\nserver.listen(preset.grafserv?.port ?? 5678);\n```\n\n----------------------------------------\n\nTITLE: Extending Build Interface Graphile V5 TypeScript\nDESCRIPTION: Demonstrates how to extend the `GraphileBuild.Build` interface in TypeScript using declaration merging to add a custom property (`flibble`). It requires importing `graphile-build` and `graphile-config`. The accompanying plugin (`FlibblePlugin`) then implements the `build` hook within `schema.hooks` to assign a value to the new `build.flibble` property at runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Ensure that the types are imported for TypeScript\nimport \"graphile-build\";\nimport \"graphile-config\";\n\n// Extend the global GraphileBuild.Build type to add our 'flibble' attribute:\ndeclare global {\n  namespace GraphileBuild {\n    interface Build {\n      flibble: bool;\n    }\n  }\n}\n\n// And here's the plugin that actually adds the attribute at runtime:\nexport const FlibblePlugin: GraphileConfig.Plugin = {\n  name: \"FlibblePlugin\",\n  version: \"0.0.0\",\n  schema: {\n    hooks: {\n      build(build) {\n        build.flibble = true;\n        return build;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Bulk Insert Mutation for Quiz Entries - SQL\nDESCRIPTION: Provides SQL code for creating input types and a custom mutation function to enable bulk creation of quiz entries and their answers. Defines a composite type â€˜quiz_entry_inputâ€™ for input, and the â€˜add_quiz_entryâ€™ function that receives a quiz id and an array of quiz entry input records, inserting both a quiz entry and its answers. Returns the new â€˜quiz_entryâ€™ record. Requires tables quiz_entry, quiz_entry_answer, definitions for current_user_id(), and the new input type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n/**\n * Occasionally you'll want to create a bunch of rows in different tables in a\n * single mutation. Here's an example of how to do that.\n *\n * Pretend we're registering quiz entries, and we want to store each answer in\n * its own table as we want to be able to operate on the answers independently\n * later.\n *\n * This means we want:\n *\n *  1. A mutation that takes input data for inserting one quiz entry and\n *  multiple answers.\n *  2. A function that inserts a new quiz entry, inserts an answer for each\n *  answer provided in the input data, and connects each answer to the created\n *  quiz entry.\n *  3. Finally, we want the function to return the inserted quiz entry itself.\n */\n\n/**\n * This type is used for input in the mutation\n */\ncreate type quiz_entry_input as (\n  question text,\n  answer int\n);\n\n/**\n * Here's the function that gets turned into a \"custom mutation\"\n */\ncreate function add_quiz_entry(\n  quiz_id int,\n  answers quiz_entry_input[]\n)\nreturns quiz_entry\nas $$\n  declare\n    q quiz_entry;\n    a quiz_entry_answer;\n  begin\n    insert into quiz_entry(user_id, quiz_id)\n      values(current_user_id(), quiz_id)\n      returning * into q;\n\n    foreach a in array answers loop\n      insert into quiz_entry_answer(quiz_entry_id, question, answer)\n        values (quiz_id, a.question, a.answer);\n    end loop;\n\n    return q;\n  end;\n$$ language plpgsql volatile strict set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @notNull Constraint via SQL Comment (SQL)\nDESCRIPTION: This SQL statement demonstrates attaching a virtual @notNull constraint directly using a comment on a column, instructing PostGraphile to treat the column as non-nullable in the GraphQL schema. This does not affect the actual nullability in PostgreSQL itself but alters schema inference.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_27\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_view.my_column is E'@notNull`;\n```\n\n----------------------------------------\n\nTITLE: Executing a Simple SQL Query in psql - SQL\nDESCRIPTION: Demonstrates running a basic SQL arithmetic query in the psql prompt. No dependencies other than a running PostgreSQL database. The query adds 1 + 1 and outputs the result, verifying that SQL execution works. Shows expected tabular output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n=# select 1 + 1 as two;\n two\n-----\n   2\n(1 row)\n\n=#\n```\n\n----------------------------------------\n\nTITLE: Retrieving Step Dependencies via Index in Grafast (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to retrieve previously registered dependencies from a custom step instance using the `getDep` method in TypeScript. The method accepts the positional index of the dependency (assigned when adding dependencies) and returns the corresponding step. Access to dependencies is intended before or during the optimize phase and ensures that custom logic within step classes can operate on their upstream inputs. No external dependencies are required beyond the Grafast Step API.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $a = this.getDep(0);\nconst $b = this.getDep(1);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Plugin Package Metadata in JSON\nDESCRIPTION: Defines the `package.json` for a custom PostGraphile plugin named `custom-plugin`. It specifies metadata like name, version, description, entry point (`index.js`), author, license, and includes `graphile-utils` and `postgraphile` as dependencies required for creating and interacting with PostGraphile's schema modification utilities.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"custom-plugin\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Custom plugin example for PostGraphile.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Alexis ROLLAND\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"graphile-utils\": \"^4.5.6\",\n    \"postgraphile\": \"^4.5.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating GraphQL API Route Handler in Next.js with JavaScript\nDESCRIPTION: This snippet shows how to create the `/api/graphql` endpoint handler using the shared Grafserv instance. It imports the `serv` object from `utils/grafserv.mjs` and calls its `createGraphQLHandler()` method. The returned handler function is then exported as the default export, making it the handler for the Next.js API route defined by this file's location (`pages/api/graphql.mjs`).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/next.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// pages/api/graphql.mjs\nimport { serv } from \"../../utils/grafserv.mjs\";\n\n// Create and export the `/graphql` route handler\nconst handler = serv.createGraphQLHandler();\nexport default handler;\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function to Get Current User from JWT\nDESCRIPTION: This SQL snippet defines a function `forum_example.current_person` that returns the `forum_example.person` row corresponding to the user identified by the 'person_id' claim within a JWT. It utilizes the `current_setting` function to access JWT claims (expected to be set by PostGraphile) and converts the claim value to an integer. The function is marked as `stable`, indicating it doesn't modify the database and returns the same results for the same arguments within a single transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_35\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.current_person() returns forum_example.person as $$\n  select *\n  from forum_example.person\n  where id = nullif(current_setting('jwt.claims.person_id', true), '')::integer\n$$ language sql stable;\n\ncomment on function forum_example.current_person() is 'Gets the person who was identified by our JWT.';\n```\n\n----------------------------------------\n\nTITLE: Declaring makeAddPgTableOrderByPlugin V5 Signatures and Structures - TypeScript\nDESCRIPTION: These updated TypeScript interfaces and function signatures reflect the new (V5) contract for adding custom OrderBy logic to Graphile-managed tables. The API now packages table identification into a 'match' object and order spec callbacks operate within the Gra*fast* planning system, using step representations of values rather than runtime lookahead. Additional properties (like applyPlan) support extension and integration with advanced Graphile machinery. Types reference GraphileConfig, SQL expressions, and potentially PG-specific order spec and codec constructs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function makeAddPgTableOrderByPlugin(\n  match: {\n    serviceName?: string;\n    schemaName: string;\n    tableName: string;\n  },\n  ordersGenerator: (\n    build: GraphileBuild.Build,\n  ) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): GraphileConfig.Plugin;\n\nexport interface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    extensions: {\n      grafast: {\n        applyPlan($select: PgSelectStep): void;\n      };\n    };\n  };\n}\n\ntype OrderBySpecIdentity =\n  | string // Column name\n  | Omit<PgOrderSpec, \"direction\"> // Expression\n  | (($select: PgSelectStep) => Omit<PgOrderSpec, \"direction\">); // Callback, allows for joins/etc\n\nexport function orderByAscDesc(\n  baseName: string,\n  columnOrSqlFragment: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n```\n\n----------------------------------------\n\nTITLE: Adding Foreign Key Virtual Constraint via Comment - SQL\nDESCRIPTION: Shows how to apply a virtual foreign key constraint to a materialized view via SQL comment for PostGraphile. The E-prefixed comment includes one or more '@foreignKey' tags, each defining a relationship. Allows for single or multiple constraints by separating them with newlines. This modifies only metadata exposure, no DB-level FK enforcement.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_19\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)';\n\n-- or if you want multiple foreignKeys\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)\\n@foreignKey (key_3, key_4) references some_other_table (key_3, key_4)';\n```\n\n----------------------------------------\n\nTITLE: Visualizing Item Steps in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet shows the representation of an '__ItemStep' in a Grafast plan diagram. These steps represent individual entries in lists or streams and are depicted as trapezoids. They do not execute themselves but are managed by Grafast.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    __Item15[/\"__Item[15âˆˆ3]<br />á¸11á³\"\\\\]:::itemplan\n    class __Item15 bucket3\n\n```\n\n----------------------------------------\n\nTITLE: Updating Docker Compose for GraphQL Service\nDESCRIPTION: Updates the `docker-compose.yml` file under the `services` section to add the `graphql` service definition. It specifies the container name, restart policy, image build context (`./graphql`), environment file (`.env`), dependency on the `db` service, network attachment, port mapping (host 5433 to container 5433), and the command to start PostGraphile using the `DATABASE_URL` variable, specifying the connection, port, schema, and appending the connection filter plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_14\n\nLANGUAGE: yml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db: [...]\n\n    graphql:\n        container_name: forum-example-graphql\n        restart: always\n        image: forum-example-graphql\n        build:\n            context: ./graphql\n        env_file:\n            - ./.env\n        depends_on:\n            - db\n        networks:\n            - network\n        ports:\n            - 5433:5433\n        command: [\"--connection\", \"${DATABASE_URL}\", \"--port\", \"5433\", \"--schema\", \"public\", \"--append-plugins\", \"postgraphile-plugin-connection-filter\"]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Stable PostgreSQL Function Example (SQL)\nDESCRIPTION: Demonstrates a basic PostgreSQL function named `add` written in SQL. It accepts two integer arguments (`a` and `b`), returns their sum as an integer, and is marked `stable` to indicate it does not modify data, making it suitable for queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\n select a + b\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Querying Views via GraphQL in PostGraphile (GraphQL)\nDESCRIPTION: These snippets provide examples of querying PostgreSQL views through the PostGraphile-generated GraphQL schema. The first query fetches a list of comedies, showing how a filtered view can be queried as a top-level connection. The second example contrasts the nested structure of querying underlying tables with a flattened view, demonstrating how the API is simplified for client consumption. Requires a running PostGraphile server with the SQL views present in the database schema. Inputs are GraphQL queries, outputs are type-safe results according to the view shape. Limitations depend on the schema and smart tags used to map views.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/views.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  comedies(first: 20) {\n    name\n    releaseYear\n  }\n}\n```\n\nLANGUAGE: graphql\nCODE:\n```\nquery Before {\n  person {\n    id\n    address {\n      country\n      street\n    }\n  }\n}\n\nquery After {\n  personView {\n    id\n    country\n    street\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a STABLE PostgreSQL Function Returning a Table Row\nDESCRIPTION: Demonstrates defining a `STABLE` function that returns a composite type corresponding to a row in `my_table`. This pattern is common for custom queries or computed columns in PostGraphile that need to return structured data based on table definitions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS my_table AS $$ â€¦ $$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Introducing Runtime SQL Value Handling (TypeScript)\nDESCRIPTION: The function `sqlValueWithCodec(value, codec)` is introduced for runtime use where `$step.placeholder($value, codec)` was previously used in plan-time. The `placeholder` method has been removed from contexts that now operate at runtime, such as modifier classes.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nsqlValueWithCodec(value, codec) // New runtime function\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$step.placeholder($value, codec) // Plan-time usage\n```\n\nLANGUAGE: typescript\nCODE:\n```\nplaceholder // Removed from runtime contexts (Modifiers)\n```\n\n----------------------------------------\n\nTITLE: Adding User to Docker Group on Linux (Shell)\nDESCRIPTION: Adds the specified user (replace `<username>` with the actual username) to the `docker` system group using the `usermod` command. This grants the user permission to run Docker commands without needing `sudo`. A system restart or logging out and back in is required for this group membership change to take effect.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo usermod -a -G docker <username>\n```\n\n----------------------------------------\n\nTITLE: Customizing Smart Tags for Multiple Columns Across Tables (JSON5)\nDESCRIPTION: This configuration snippet shows how to use a JSON5 config to apply smart tags to specific attributes (columns) regardless of the table. The snippet omits create/update operations on any 'created_at' or 'updated_at' columns. It demonstrates the powerful pattern matching by identifier and serves as an example of partial qualification in smart tags configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      created_at: { tags: { omit: \"create,update\" } },\n      updated_at: { tags: { omit: \"create,update\" } },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding JavaScript Values in Schema with embed Helper (JavaScript)\nDESCRIPTION: Illustrates the usage of the `embed` helper (mentioned as potentially removed in PostGraphile V5) within a `gql` template literal. This example, commented out in the source documentation, shows embedding a plain JavaScript object (`meta`) into the schema definition, specifically passing it as an argument to the custom `@scope` directive on the `fieldName` field. Note: This functionality might be deprecated or unavailable.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst meta = {\n  // arbitrary data\n  name: \"fieldName\",\n  added: \"2019-04-29T16:15:00Z\",\n};\nconst typeDefs = gql`\n  extend type Query {\n    fieldName: Int @scope(meta: ${embed(fieldNameMeta)})\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Renaming ModifierStep Classes to Runtime Modifiers (TypeScript)\nDESCRIPTION: Several `ModifierStep` classes have been renamed by dropping the `Step` suffix. These classes now represent runtime operations invoked via the new `applyInput()` step, rather than plan-time steps. They handle runtime values directly, and the `placeholder` method is removed. Deprecated forms are removed.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nModifierStep â‡’ Modifier\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgBooleanFilterStep â‡’ PgBooleanFilter\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgClassFilterStep â‡’ PgClassFilter\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgConditionCapableParentStep â‡’ PgConditionCapableParent\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgConditionLikeStep â‡’ PgConditionLike\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgConditionStepMode â‡’ PgConditionMode\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgConditionStep â‡’ PgCondition\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgManyFilterStep â‡’ PgManyFilter\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgOrFilterStep â‡’ PgOrFilter\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgTempTableStep â‡’ PgTempTable\n```\n\nLANGUAGE: typescript\nCODE:\n```\nSetterCapableStep â‡’ SetterCapable\n```\n\nLANGUAGE: typescript\nCODE:\n```\nSetterStep â‡’ Setter\n```\n\nLANGUAGE: typescript\nCODE:\n```\napplyInput() // New step invoking runtime modifiers\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Operation with hookArgs and Manual Validation in TypeScript\nDESCRIPTION: This snippet demonstrates custom execution of a GraphQL query by parsing and validating the GraphQL document manually, building execution args using hookArgs, and finally invoking execute from grafast. Useful for scenarios where string-based input is not sufficient or more control is needed. Dependencies include postgraphile, grafast, and associated GraphQL functions. Returns errors if validation fails, otherwise the execution result.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport { parse, validate } from \"postgraphile/graphql\";\nimport { execute, hookArgs } from \"postgraphile/grafast\";\nimport preset from \"./graphile.config.js\";\n\n// Build a `pgl` instance, with helpers and schema based on our preset.\nconst pgl = postgraphile(preset);\n\n/**\n * Given a request context `requestContext`, GraphQL query text `source` and\n * optionally variable values and operation name, execute the given GraphQL\n * operation against our schema and return the result.\n */\nexport async function executeQuery(\n  requestContext: Partial<Grafast.RequestContext>,\n  source: string,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n) {\n  // We might get a newer schema in \"watch\" mode\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n\n  // Parse the GraphQL query text:\n  const document = parse(source);\n\n  // Validate the GraphQL document against the schema:\n  const errors = validate(schema, document);\n  if (errors.length > 0) {\n    return { errors };\n  }\n\n  // Prepare the execution arguments:\n  const args = await hookArgs({\n    schema,\n    document,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n\n  // Execute the request using Grafast:\n  return await execute(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Steps via toString Method in Grafast (TypeScript)\nDESCRIPTION: This snippet shows how to invoke the `toString` method of a step instance for pretty-printing its details in TypeScript. It's mainly used for debugging or visualization within the query planning lifecycle. The method outputs a string representation of the step, helping developers understand the structure during development or analysis. Requires that the referenced step variable ($a) is a valid Step instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nconsole.log(\"$a = \" + $a.toString());\n```\n\n----------------------------------------\n\nTITLE: Cleaning up Docker Images - Shell\nDESCRIPTION: These commands list available Docker images and forcibly remove the 'hello-world' image. Useful for cleaning up after installation tests. Outputs the image list and removes the specified image.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ docker image ls\\n$ docker rmi -f hello-world\n```\n\n----------------------------------------\n\nTITLE: Defining an EXPORTABLE Function (TypeScript - Before ESLint Fix)\nDESCRIPTION: This TypeScript snippet exemplifies the usage of the EXPORTABLE wrapper on a function definition. It wraps an anonymous function intended to be exported but does not yet declare its dependency array. The main parameter is the value to export (here, a function named 'add'). The snippet demonstrates initial usage before running ESLint autofix, and is vital for illustrating how the plugin detects and modifies exportable code constructs.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/eslint.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst add = EXPORTABLE(\n  () =>\n    function add(b) {\n      return a + b;\n    },\n);\n```\n\n----------------------------------------\n\nTITLE: Retrieving JWT Claim Values in PostgreSQL - SQL\nDESCRIPTION: These queries exemplify how to extract previously set JWT claim values during a session in PostgreSQL. 'current_setting' is a function that returns the value of a session setting, and 'SHOW' is a command-line operation to display configuration variables. They both require that the claim variable (e.g., 'jwt.claims.user_id') was set earlier in the session. An error will occur if the variable was not set and no default was given.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/jwt-guide.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nselect current_setting('jwt.claims.user_id');\n-- Orâ€¦\nshow jwt.claims.user_id;\n```\n\n----------------------------------------\n\nTITLE: Accessing Database Resources in PostGraphile Build Input (TypeScript)\nDESCRIPTION: Shows how to retrieve references to database resources (e.g., `organizations`, `users`, `channels`) registered by `@dataplan/pg` from the `build.input.pgRegistry.pgResources` object within a PostGraphile plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst { organizations, users, channels } = build.input.pgRegistry.pgResources;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Tables and Relations with Row Level Security - PostgreSQL - sql\nDESCRIPTION: This SQL snippet creates two tables: person and post, enforcing a simple foreign key constraint connecting posts to authors. Following that, two RLS policies are established: one to restrict access to personal records to their owners, another to allow universal access to all posts. Purpose: illustrates how database-level visibility can affect GraphQL field nullability. Dependencies: PostgreSQL with RLS enabled. Inputs: none; Outputs: modified schema and policy. Limitation: example only, not a full deployment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/why-nullable.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n\"create table person (\\n  id serial primary key,\\n  username citext not null\\n);\\n\\ncreate table post (\\n  id serial primary key,\\n  author_id int not null references person on delete cascade,\\n  body text not null\\n);\\n\"\n```\n\nLANGUAGE: sql\nCODE:\n```\n\"-- Users can only see their own 'Person'\\ncreate policy select_self on person for select using (id = current_user_id());\\n-- Users can see all Posts\\ncreate policy select_all on post for select using (true);\"\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin in V5 Style (JavaScript)\nDESCRIPTION: This snippet exhibits a modern, V5-compatible plugin as an exported object, using declarative schema and hooks. It adds a 'four' field to the Query type with a plan-based resolver using grafast's constant plan utility. Requires the grafast package and uses the build.extend API. More discoverable and debuggable than the V4 function style.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-start\nconst { constant } = require(\"grafast\");\nmodule.exports = {\n  name: \"AddQueryFourFieldPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // highlight-end\n        const {\n          graphql: { GraphQLInt },\n        } = build;\n        const { Self } = context;\n        if (Self.name !== \"Query\") return fields;\n        return build.extend(\n          fields,\n          {\n            four: {\n              type: GraphQLInt,\n              // highlight-start\n              plan() {\n                return constant(4);\n              },\n              // highlight-end\n            },\n          },\n          \"Adding Query.four\",\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Object Type with newWithHooks - Graphile Engine - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates using Graphile Engine's newWithHooks API to instantiate a GraphQLObjectType called 'MyType', supporting plugin-based extension and hook-based modifications of the type or its fields. Inputs are the constructor (GraphQLObjectType) and a configuration object, mirroring the reference implementation but with Graphile's extensibility hooks applied. Requires Graphile Engine and the 'graphql' library.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyType =\n/* highlight-next-line */\n  newWithHooks(GraphQLObjectType, {\n    name: 'MyType',\n    fields: {\n      // ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Detailed Error Debugging for SQL in PostGraphile - Bash\nDESCRIPTION: Provides commands to set up environment variables for even more detailed debugging, including both SQL statements and execution errors. It covers variations for Bash, Windows Console, and PowerShell environments. Setting these DEBUG values logs SQL interactions and any errors associated. Useful for tracking down database-level issues with GraphQL resolvers. Suitable for development; not for production.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Bash (Linux, macOS, etc)\nexport DEBUG=\\\"postgraphile:postgres,postgraphile:postgres:error\\\"\npostgraphile -c postgres://...\n  # or:\nexport DEBUG=\\\"postgraphile:postgres*\\\"\npostgraphile -c postgres://...\n\n# Windows Console\nset DEBUG=postgraphile:postgres,postgraphile:postgres:error & postgraphile -c postgres://...\n  #or\nset DEBUG=postgraphile:postgres* & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:DEBUG = \\\"postgraphile:postgres,postgraphile:postgres:error\\\"; postgraphile -c postgres://...\n  #or\n$env:DEBUG = \\\"postgraphile:postgres*\\\"; postgraphile -c postgres://...\n\n```\n\n----------------------------------------\n\nTITLE: Querying a SETOF Function as a GraphQL Connection\nDESCRIPTION: Provides an example GraphQL query illustrating how a PostgreSQL `SETOF` function, exposed via PostGraphile, can be queried. It demonstrates passing function arguments (`a`, `b`) along with standard GraphQL connection arguments (`first`) for pagination, and requesting page information and node data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_18\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  myFunction(a: 1, b: 2, first: 2) {\n    pageInfo {\n      hasNextPage\n      hasPrevPage\n    }\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Granting an Anonymous Role - SQL\nDESCRIPTION: These SQL commands create a new Postgres role `forum_example_anonymous` (without login privilege) and grant it to `forum_example_postgraphile`, so that PostGraphile can switch to this role for unauthenticated users. The administrator must have CREATEROLE rights. No passwords are involved for the anonymous role. This setup helps separate privileges for anonymous vs. authenticated access.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_24\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_anonymous;\ngrant forum_example_anonymous to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Custom Mutation Using Composite Type Arguments (SQL)\nDESCRIPTION: This pair of SQL code snippets creates a table and a mutation function using a composite type as argument, serving as an example for PostGraphile custom mutations. The mutation inserts a new row and returns the inserted object, suitable for cases where client-provided IDs are accepted. Prerequisites: extension or function for UUID generation if gen_random_uuid() is used.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_23\n\nLANGUAGE: sql\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example(input example) returns example as $$\n  insert into example (id, name) values (input.id, input.name) returning *;\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin Using the V5 Declarative API (typescript)\nDESCRIPTION: This TypeScript code illustrates the V5 declarative approach for defining a PostGraphile plugin as a structured object rather than a builder function. The plugin exposes inflection additions and schema hooks for build, init, and GraphQLObjectType_fields. It leverages the GraphileConfig.Plugin type, requiring 'postgraphile' as a dependency. Inputs and outputs mimic the V4 version but are organized declaratively, simplifying maintenance and enhancing type safety. Suitable only with PostGraphile V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {} from \\\"postgraphile\\\";\\n\\nexport const MyPlugin: GraphileConfig.Plugin = {\\n  name: \\\"MyPlugin\\\",\\n\\n  inflection: {\\n    add: {\\n      myInflector(stuff) {\\n        return stuff + \\\"Stuff\\\";\\n      },\\n    },\\n  },\\n\\n  schema: {\\n    hooks: {\\n      build(build) {\\n        return build.extend(\\n          build,\\n          { myStuff: () => [\\\"my\\\", \\\"stuff\\\"] },\\n          \\\"Adding myStuff to build\\\",\\n        );\\n      },\\n\\n      init(_, build) {\\n        doSomethingWith(build.myStuff());\\n        return _;\\n      },\\n\\n      GraphQLObjectType_fields(fields, build, context) {\\n        return build.extend(\\n          fields,\\n          { myField: { type: build.graphql.GraphQLString } },\\n          \\\"Adding fields from MyPlugin\\\",\\n        );\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Behaviors in a Graphile Crystal Plugin (TypeScript)\nDESCRIPTION: This TypeScript code defines a Graphile Crystal plugin named 'MyPlugin'. It demonstrates how to register default behaviors (e.g., 'myCodecBehavior' for all pgCodecs) and conditional behaviors (e.g., 'myResourceBehavior' for unique pgResources) via the `entityBehaviors` property. It also shows how to use a hook (`GraphQLObjectType_fields_field`) to check if a specific behavior applies to an entity (pgFieldCodec) using `build.behavior.pgCodecMatches` before potentially modifying the GraphQL schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/behavior.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst MyPlugin = {\n  name: \"MyPlugin\",\n  version: \"0.0.0\",\n\n  schema: {\n    // Register default behaviors (optional)\n    entityBehaviors: {\n      // Apply 'myCodecBehavior' by default to _all_ codecs\n      pgCodec: \"myCodecBehavior\",\n\n      // Apply 'myResourceBehavior' to resources with truthy `isUnique` (overrides defaults)\n      pgResource(behavior, resource) {\n        if (resource.isUnique) {\n          return [behavior, \"myResourceBehavior\"];\n        } else {\n          return behavior;\n        }\n      },\n    },\n\n    // Do something with behaviors (optional)\n    hooks: {\n      GraphQLObjectType_fields_field(field, build, context) {\n        const codec = context.scope.pgFieldCodec;\n        if (\n          !codec ||\n          !build.behavior.pgCodecMatches(codec, \"myCodecBehavior\")\n        ) {\n          return field;\n        }\n\n        // Behavior matches! Do stuff here...\n\n        return field;\n      },\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Executing a GraphQL Mutation to Trigger a Subscription\nDESCRIPTION: This GraphQL code defines a mutation operation named `MyMutation`. It calls the `updateUserById` mutation, providing an `id` and a `userPatch` with updated data (e.g., changing the name to 'foo'). Executing this mutation is intended to trigger the database changes and subsequently the `currentUserUpdated` subscription defined in other examples.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nmutation MyMutation {\n  updateUserById(input: { userPatch: { name: \"foo\" }, id: 27 }) {\n    clientMutationId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Explicitly VOLATILE SQL Function\nDESCRIPTION: Illustrates how to explicitly define a PostgreSQL function as `VOLATILE`. This classification signifies the function can modify database state or has side effects, preventing certain query optimizations and typically mapping to GraphQL mutations in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_function(a int, b int) returns int as $$\n  â€¦\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Using Placeholder in pgCondition with placeholder - Graphile (JavaScript)\nDESCRIPTION: Shows the use of the placeholder method for injecting placeholders in a pgCondition, similar to the mechanism in pgSelect. The parameters are $step (the step reference) and codec (type information). This is primarily used for advanced dynamic query compilation scenarios, allowing for safe parameterization of conditions in Graphile's execution plan.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.placeholder($step, codec)\n```\n\n----------------------------------------\n\nTITLE: Creating and Granting an Authenticated User Role - SQL\nDESCRIPTION: These SQL commands establish `forum_example_person` as a role for authenticated forum users and grant it to the `forum_example_postgraphile` role, enabling PostGraphile to switch to this identity when a JWT-authenticated user is detected. Dependencies include adequate privileges to create and modify roles. This setup helps delineate access between logged-in and anonymous users.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_26\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_person;\ngrant forum_example_person to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Type and Interface for Union Polymorphism - SQL\nDESCRIPTION: Defines a composite SQL type listing the shared fields and annotates it as an interface using PostGraphile smart tags. Subsequently, applies '@implements' smart tags to tables to indicate conformance to the interface. Requires all involved tables and fields to exist. The effect is that these tables implement a common GraphQL interface in the generated schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n-- Declare a composite type to detail the common fields\ncreate type polymorphic.applications as (\n  id int,\n  name text,\n  last_deployed timestamptz\n);\n\n-- Mark this composite type as an interface named Application\ncomment on type polymorphic.applications is $$\n  @interface mode:union\n  @name Application\n  $$;\n\n-- Have our tables implement this interface\ncomment on table polymorphic.aws_applications is $$\n  @implements Application\n  $$;\ncomment on table polymorphic.gcp_applications is $$\n  @implements Application\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Topic with GraphQL Mutation (GraphQL)\nDESCRIPTION: Performs a GraphQL mutation to create a new topic within a forum, leveraging the @graphile-contrib/pg-simplify-inflector plugin for simplified field names. The input requires a nested 'topic' object specifying forumId (integer), title (string), and body (string), and the mutation returns the full details of the created topic node. Dependencies include a properly configured GraphQL server with the plugin enabled and a PostgreSQL backend matching the expected schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/mutations.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createTopic(\n    input: {\n      topic: {\n        forumId: 2\n        title: \"My question relates to mutations...\"\n        body: \"How do you write them?\"\n      }\n    }\n  ) {\n    topic {\n      nodeId\n      id\n      forumId\n      title\n      body\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"createTopic\": {\n    \"topic\": {\n      \"nodeId\": \"WyJ0b3BpY3MiLDVd\",\n      \"id\": 5,\n      \"forumId\": 2,\n      \"title\": \"My question relates to mutations...\",\n      \"body\": \"How do you write them?\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple PostgreSQL Mutation Function (PostgreSQL, SQL)\nDESCRIPTION: Defines a PostgreSQL function that accepts two integer parameters and returns text, implementing a volatile, SQL-based custom mutation suitable for PostGraphile. No dependencies beyond an operational PostgreSQL environment are required. Arguments 'a' and 'b' represent input parameters, and the function's output is a single text value. This provides a basic template for exposing custom logic via GraphQL through PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-mutations.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS text AS $$ â€¦ $$ LANGUAGE sql VOLATILE;\n```\n\n----------------------------------------\n\nTITLE: Defining PlanWrapperFn Signature for makeWrapPlansPlugin in TypeScript\nDESCRIPTION: Defines the `PlanWrapperFn` type alias used within `makeWrapPlansPlugin`. This function signature represents the core wrapper logic. It accepts the original plan resolver function (`plan` of type `SmartFieldPlanResolver`) as the first argument, followed by the standard plan resolver arguments: `$source` (parent step), `fieldArgs`, and `info`. The wrapper function can then choose when and how to call the original `plan` function, potentially modifying arguments or the result step.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntype PlanWrapperFn = (\n  plan: SmartFieldPlanResolver,\n  $source: ExecutableStep,\n  fieldArgs: FieldArgs,\n  info: FieldInfo,\n) => any;\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Plugin Hook for PostGraphile Middleware\nDESCRIPTION: This JavaScript snippet illustrates how to enable PostGraphile server plugins when using it as middleware. It utilizes the `makePluginHook` function from the `postgraphile` library, passing an array of imported plugin objects (like `OperationHooks`, `PgPubsub`, `GraphilePro`). The resulting `pluginHook` function is then included in the options passed to the `postgraphile()` middleware factory.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n// Only include as many plugins as you need. An empty array is also valid.\nconst pluginHook = makePluginHook([OperationHooks, PgPubsub, GraphilePro]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n\napp.use(postGraphileMiddleware);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Explicitly Non-Nullable Types in GraphQL Schema - GraphQL\nDESCRIPTION: This code snippet demonstrates the definition of a GraphQL schema with all fields set as non-nullable using the exclamation mark syntax. The schema includes Numbers and Letters types, both with non-nullable fields, and a Query type aggregating them. It highlights error propagation when downstream resolvers fail, elucidating why marking all fields as non-nullable can be problematic. No external dependencies are required, but this schema's strict nullability can cause unexpected failures to cascade.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/why-nullable.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n# This is a bad practice GraphQL schema to demonstrate a point.\n\ntype Numbers {\n  one: Int!\n  two: Int!\n  three: Int!\n}\n\ntype Letters {\n  a: String!\n  b: String!\n  c: String!\n}\n\ntype Query {\n  numbers: Numbers!\n  letters: Letters!\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping User.email Plan for Data Masking using makeWrapPlansPlugin (Method 1) in TypeScript\nDESCRIPTION: Illustrates using Method 1 of `makeWrapPlansPlugin` to mask the value of the `User.email` field. It executes the original plan using `plan()` to get the email value, then uses a `lambda` step to apply a regular expression replacement, masking parts of the email address before returning it. Dependencies include `makeWrapPlansPlugin` and `lambda`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\nimport { lambda } from \"postgraphile/grafast\";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan) {\n      const $email = plan();\n      return lambda($email, (email) =>\n        // someone@sub.example.com -> so***@su***.com\n        email.replace(\n          /^(.{1,2})[^@]*@(.{,2})[^.]*\\.([A-z]{2,})$/,\n          \"$1***@$2***.$3\",\n        ),\n      );\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Simplified Entity Behavior Matching in Graphile Plugins - TypeScript\nDESCRIPTION: This TypeScript code illustrates the new, simplified hook pattern for checking behavior on a relation entity in a Graphile plugin context. The snippet improves clarity and maintainability by relying on the centralized build.behavior.pgCodecRelationMatches method, removing the need for manual extension aggregation or custom smart defaults. Dependencies are limited to build.behavior's utility APIs and the context scope containing the relation. The input is a field context with an associated relation, and the output triggers the relevant logic if the specified behavior matches. This approach reduces complexity, risk of inconsistency, and eases debugging for plugin authors.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n  // Do the thing if the relation has the given behavior. Simples.\n  if (build.behavior.pgCodecRelationMatches(relation, \"behavior_to_test\")) {\n    doTheThing();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Plugin Combination from Helper Function to Preset Object (diff)\nDESCRIPTION: This diff illustrates the shift from using the deprecated `makePluginByCombiningPlugins` function to the preferred method of defining a preset object. The `-` line shows the old approach, while the `+` line demonstrates creating a `preset` constant containing an object with a `plugins` array holding the individual plugins (Plugin1, Plugin2, Plugin3).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-plugin-by-combining-plugins.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-const plugin = makePluginByCombiningPlugins(Plugin1, Plugin2, Plugin3);\n+const preset = { plugins: [Plugin1, Plugin2, Plugin3] };\n```\n\n----------------------------------------\n\nTITLE: Assigning PostgreSQL Role and JWT Role Claim from JWT (SQL)\nDESCRIPTION: Shows how PostGraphile sets both the database role and the corresponding JWT role claim based on the 'role' property in the JWT payload. This impacts subsequent database permissions and enforces correct access control. This snippet is for environments where role-based access is enforced, requiring a properly defined role in Postgres. The input is a validated role string, outputting session-level changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_30\n\nLANGUAGE: SQL\nCODE:\n```\nset local role to 'forum_example_person'\nset local jwt.claims.role to 'forum_example_person'\n```\n\n----------------------------------------\n\nTITLE: Simplifying Dependencies using V5 Subpaths in package.json\nDESCRIPTION: Demonstrates how to simplify `package.json` dependencies in PostGraphile V5 by using subpath imports (e.g., `postgraphile/graphile-build` instead of `graphile-build`). This reduces the need to list individual Graphile packages, minimizing potential version conflicts, requiring only the main `postgraphile` package and specific plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"devDependencies\": {\n    \"postgraphile\": \"^5.0.0-beta.32\",\n    \"postgraphile-plugin-connection-filter\": \"^3.0.0-beta.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: SQL: Applying Smart Comments to Fake Constraints via the Pipe Separator - SQL\nDESCRIPTION: This snippet provides an example of attaching smart tags to a fake constraint when newlines cannot be used, by employing the pipe '|' character to separate tags. Input: COMMENT ON MATERIALIZED VIEW with a smart tag assignment targeting a fake constraint. Output: PostGraphile will assign naming customizations based on smart tags provided after the '|'. Limitation: intended for constraints where newlines are not allowed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncomment on materialized view my_materialized_view is\\n  E'@foreignKey (post_id) references posts (id)|@fieldName yourNameHere';\n```\n\n----------------------------------------\n\nTITLE: Efficiently Archiving Forums using Bulk Update (SQL)\nDESCRIPTION: Presents a more efficient version of the `archive_forums` function using `LANGUAGE sql`. Instead of looping, it performs two bulk `UPDATE` operations, one for the `forums` table and one for the `posts` table, using the `ANY` operator to match against the input `forum_ids` array. This significantly reduces the number of executed queries compared to the looping approach. The function takes an integer array `forum_ids` and returns `void`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate function archive_forums(forum_ids int[]) returns void as $$\n  update forums set is_archived = true where id = ANY(forum_ids);\n  update posts set is_archived = true where forum_id = ANY(forum_ids);\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Running Ruru GraphiQL Client via CLI\nDESCRIPTION: Shows the command to run the Ruru GraphiQL interface using `npx` against a running GraphQL endpoint. The `-PSe` flags are likely specific options for Ruru, and the URL points to the GraphQL server endpoint (e.g., `http://localhost:5678/graphql`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nnpx ruru@beta -PSe http://localhost:5678/graphql\n```\n\n----------------------------------------\n\nTITLE: Verifying Functionality and toString() of EXPORTABLE Wrapped Function\nDESCRIPTION: Confirms that a function wrapped with `EXPORTABLE` still executes correctly (returning 10) and its standard `.toString()` method returns the original inner function's source code, preserving its basic behavior.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n> add(3)\n10\n> add.toString()\n'function add(b) { return a + b; }'\n```\n\n----------------------------------------\n\nTITLE: Executing a TE Fragment with te.run() in JavaScript\nDESCRIPTION: This snippet demonstrates how to use the `te.run()` function (or its alias `eval`) from the @graphile/crystal library. It defines a simple TE fragment that performs addition and then uses `te.run()` to evaluate it, storing the result (3) in the `result` variable. An assertion confirms the expected outcome.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-run.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst fragment = te`return 1 + 2`;\nconst result = te.run(fragment);\n\nassert.equal(result, 3);\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.13\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.13' of the 'grafast' package within a changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.13\n```\n\n----------------------------------------\n\nTITLE: Wrapping Non-Scalar Computed Columns for Sorting/Filtering (SQL)\nDESCRIPTION: This trio of SQL snippets demonstrates wrapping a non-scalar computed column with a new computed column that returns a scalar type to enable sorting and filtering. The pattern involves writing a composite-output function, a wrapper function returning a scalar from the composite, and annotating the wrapper as @sortable for Graphile. Dependencies: an existing composite type, function, and proper SQL syntax.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_19\n\nLANGUAGE: sql\nCODE:\n```\n-- non scalar function\nCREATE OR REPLACE FUNCTION user_object(user user) RETURNS object AS $$\nSELECT * FROM object where id = user.object_id;\n$$ language SQL STABLE;\n\n-- wrapper. Note the () for notation. Failing to use them will throw an error\nCREATE OR REPLACE FUNCTION user_object_field(user user) RETURNS varchar AS $$\nSELECT (user_object(user)).field;\n$$ language SQL STABLE;\n\n-- don't forget the comments...\ncomment on function user_object_field() is E'@sortable';\n```\n\n----------------------------------------\n\nTITLE: Migrating Hooks to Middleware in Graphile Plugins - Markdown Diff Example\nDESCRIPTION: This Markdown code snippet demonstrates the migration path for updating Graphile plugin hooks to the new middleware-based API, as described in the patch notes. It illustrates, side-by-side, the old hooks-based configuration and the new middleware approach, with particular attention to the prepareArgs method signature. This guidance is intended for developers updating their plugins for compatibility with new versions of the Graphile libraries; no code execution is expected and the snippet is meant for technical documentation purposes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n```diff\n const plugin = {\n   grafast: {\n-    hooks: {\n+    middleware: {\n-      args({ args, ctx, resolvedPreset }) {\n+      prepareArgs(next, { args }) {\n+        const { requestContext: ctx, resolvedPreset } = args;\n         // ...\n+        return next();\n       }\n     }\n   }\n }\n```\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Login Roles and Users - SQL\nDESCRIPTION: These SQL snippets illustrate how to create a role with login permissions ('admin') in PostgreSQL. Both statements achieve the same result, as in PostgreSQL 'user' is an alias for 'role' with LOGIN. Dependencies: PostgreSQL. Parameters: Role/user name ('admin'), login option. Input: SQL statements. Output: Role/user created in database with LOGIN property. Should be run with sufficient database permissions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/default-role.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate role admin login;\ncreate user admin;\n```\n\n----------------------------------------\n\nTITLE: Dropping the Logical Replication Slot (SQL)\nDESCRIPTION: SQL command to manually drop the logical replication slot created by `@graphile/lds`. This is essential cleanup to perform when the LDS server is no longer needed, to prevent the database disk from filling up with Write-Ahead Log (WAL) data. The default slot name used by `@graphile/lds` is 'postgraphile', but this should be replaced if a different `LD_SLOT_NAME` was configured.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nSELECT pg_drop_replication_slot('postgraphile'); -- or whatever slot name you were using.\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column Using Smart Comment - SQL\nDESCRIPTION: This SQL snippet applies the @deprecated smart tag to a database column, marking it as deprecated in GraphQL. Use with PostgreSQL and PostGraphile. The comment is attached to 'my_schema.my_table.my_column', with a deprecation message provided.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\n  E'@deprecated Use myOtherColumn instead.';\n```\n\n----------------------------------------\n\nTITLE: Renaming Types and Configuration Options in Grafast/Graphile (TypeScript)\nDESCRIPTION: Documents breaking changes involving the renaming of core types and configuration options in Grafast and Graphile Config as part of versions 5.0.0-0.14 and 5.0.0-0.8. This includes context types, request context types, database adaptor options, helper functions, and schema options. Developers need to update their code to use the new names.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// v5.0.0-0.14: Type renames\nGraphileBuild.GraphileResolverContext // renamed to Grafast.Context\nGraphileConfig.GraphQLRequestContext  // renamed to Grafast.RequestContext\nGrafast.PgDatabaseAdaptorOptions      // renamed to GraphileConfig.PgDatabaseAdaptorOptions\nmakeNodePostgresWithPgClient          // renamed to makePgAdaptorWithPgClient\n\n// v5.0.0-0.8: Schema options rename\nGraphileBuild.GraphileBuildSchemaOptions // renamed to GraphileBuild.SchemaOptions\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Query Execution in GraphQL - GraphQL\nDESCRIPTION: This snippet is an example of a GraphQL query selecting all fields from the Numbers and Letters objects. It serves to illustrate how the schema handles errors and nullability depending on prior type definitions, and is meant for use with a compatible GraphQL server. No dependencies are required but actual results may depend on resolver implementations and the non-nullability settings explained earlier.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/why-nullable.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  numbers {\n    one\n    two\n    three\n  }\n  letters {\n    a\n    b\n    c\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Sorting Options to Functions via GraphQL Query (GraphQL)\nDESCRIPTION: These GraphQL query examples demonstrate how to leverage functions annotated with @sortable in the schema. Provided functions support the 'orderBy' parameter, allowing clients to sort by specific columns or computed function output when querying sets or parent tables. Expected output is a sorted connection or list per GraphQL schema conventions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(orderBy: [ID_ASC]) { ... }\n  user(nodeId: ...) {\n    foo(orderBy: [ID_ASC]) { ... }\n  }\n\n  # If the function return a scalar\n  allUsers(orderBy: [FOO_ASC]) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Resolver Wrapper Rules Interfaces (TypeScript)\nDESCRIPTION: TypeScript interfaces defining the structure for specifying resolver wrapping rules used in Method 1. `ResolverWrapperRules` is a nested map from type name to field name to the wrapper rule or function. `ResolverWrapperRulesGenerator` is a function type that accepts `Options` and returns `ResolverWrapperRules`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ResolverWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: ResolverWrapperRule | ResolverWrapperFn;\n  };\n}\ntype ResolverWrapperRulesGenerator = (options: Options) => ResolverWrapperRules;\n```\n\n----------------------------------------\n\nTITLE: Defining Docker Image for PostGraphile Node.js Application\nDESCRIPTION: Specifies the instructions in `graphql/Dockerfile` to build the Docker image for the Node.js application running PostGraphile. It starts from a `node:alpine` base image, sets up the working directory `/home/node/app`, copies `package.json` and `package-lock.json`, installs dependencies using `npm install` as the `node` user, copies the application source code from `./src`, sets ownership to `node:node`, exposes port 8080 (though the app listens on `PORT=5433` as configured in `.env` and `docker-compose.yml`), and defines the default command to start the server as `node server.js`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_4\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Set Node.js app folder\nRUN mkdir -p /home/node/app/node_modules\nWORKDIR /home/node/app\n\n# Copy dependencies\nCOPY ./src/package*.json .\nRUN chown -R node:node /home/node/app\n\n# Install dependencies\nUSER node\nRUN npm install\n\n# Copy application files\nCOPY --chown=node:node ./src .\n\nEXPOSE 8080\nCMD [ \"node\", \"server.js\" ]\n```\n\n----------------------------------------\n\nTITLE: Building Custom PostGraphile Docker Images Using Multi-Stage Build (Dockerfile)\nDESCRIPTION: This Dockerfile demonstrates a multi-stage build process for deploying a custom PostGraphile-powered server. It utilizes Node.js Alpine images for lightweight builds, leverages build and clean stages to optimize dependencies, and sets up application exposure and environment variables for final execution. Key stages perform dependency installation, building of source code, copying of build output, and final installation of only production dependencies. Required dependencies include Node.js, Yarn, and Docker, with ports, environment variables, and entrypoints defined for optimal container usage. The expected input is source code in server/ and standard Node.js project files, producing a secure and optimized Docker image ready to run with 'yarn start'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-docker.md#_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\n# Dockerfile\\n\\n# Global args, set before the first FROM, shared by all stages\\nARG NODE_ENV=\\\"production\\\"\\n\\n################################################################################\\n# Build stage 1 - `yarn build`\\n\\nFROM node:12-alpine as builder\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Cache node_modules for as long as possible\\nCOPY package.json yarn.lock /app/\\nWORKDIR /app/\\nRUN yarn install --frozen-lockfile --production=false --no-progress\\n\\n# Copy over the server source code\\nCOPY server/ /app/server/\\n\\n# Finally run the build script\\nRUN yarn run build\\n\\n################################################################################\\n# Build stage 2 - COPY the relevant things (multiple steps)\\n\\nFROM node:12-alpine as clean\\n# Import our shared args\\nARG NODE_ENV\\n\\n# Copy over selectively just the tings we need, try and avoid the rest\\nCOPY --from=builder /app/package.json /app/yarn.lock /app/\\nCOPY --from=builder /app/server/dist/ /app/server/dist/\\n\\n################################################################################\\n# Build stage FINAL - COPY everything, once, and then do a clean `yarn install`\\n\\nFROM node:12-alpine\\n# Import our shared args\\nARG NODE_ENV\\n\\nEXPOSE 5000\\nWORKDIR /app/\\n# Copy everything from stage 2, it's already been filtered\\nCOPY --from=clean /app/ /app/\\n\\n# Install yarn ASAP because it's the slowest\\nRUN yarn install --frozen-lockfile --production=true --no-progress\\n\\nLABEL description=\\\"My PostGraphile-powered server\\\"\\n\\n# You might want to disable GRAPHILE_TURBO if you have issues\\nENV GRAPHILE_TURBO=1\\nENV NODE_ENV=$NODE_ENV\\nENTRYPOINT yarn start\n```\n\n----------------------------------------\n\nTITLE: Creating Grafserv Instance in TypeScript\nDESCRIPTION: Shows how to create a Grafserv instance (`serv`) by calling the `pgl.createServ()` method on the PostGraphile instance, passing the imported Grafserv adapter. This `serv` instance handles the HTTP request/response lifecycle for the chosen server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst serv = pgl.createServ(grafserv);\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.8\nDESCRIPTION: This snippet notes an update in the project's dependencies, highlighting version '0.0.1-0.8' of the 'grafast' package as part of the changelog entry.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.8\n```\n\n----------------------------------------\n\nTITLE: Declaring and Adding a New Inflector in TypeScript (with Declaration Merging)\nDESCRIPTION: This snippet shows how to both declare a new inflector method ('enhanced') using TypeScript's declaration merging, and implement a plugin that adds it. The declaration extends the global GraphileBuild.Inflection interface to make the new method available in type definitions. The plugin is then defined with the enhanced inflector logic, similar to the JavaScript example but type-safe. It should be used in projects requiring the inflector to have TypeScript types. Key inputs are the configuration preset and 'columnName'; output is the enhanced string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\ndeclare global {\\n  namespace GraphileBuild {\\n    interface Inflection {\\n      /**\\n       * Add documentation for your inflector here.\\n       */\\n      enhanced(this: Inflection, columnName: string): string;\\n    }\\n  }\\n}\\n\\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\\n  name: \\\"MyNewInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    add: {\\n      enhanced(preset, columnName) {\\n        return columnName + \\\"Enhanced\\\";\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Resolving Data with Look-Ahead Metadata using JavaScript\nDESCRIPTION: This snippet demonstrates how to utilize the look-ahead metadata within a field's resolver function. Inside the 'myConnection' field resolver (defined using `fieldWithHooks`), `parseResolveInfo` is called to get the parsed query information. Then, `getDataFromParsedResolveInfoFragment` is used, passing the parsed info and the expected return type (`MyConnection`), to retrieve the aggregated metadata (including argument-based data like `{ limit: [3] }`). This `resolveData` object can then be used to optimize the actual data fetching logic (e.g., applying limits, selecting specific columns).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/look-ahead.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst Query = newWithHooks(GraphQLObjectType, {\n  name: \"Query\",\n  fields: ({ fieldWithHooks }) => ({\n    myConnection: fieldWithHooks(\n      \"myConnection\",\n      ({ addArgDataGenerator, getDataFromParsedResolveInfoFragment }) => {\n        addArgDataGenerator(function connectionFirst({ first }) {\n          if (first) {\n            /* highlight-next-line */\n            return { limit: [first] };\n          }\n        });\n        return {\n          type: MyConnection\n          args: {\n            first: {\n              type: GraphQLInt,\n            },\n          },\n          resolve(data, args, context, resolveInfo) {\n            const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n            /* highlight-start */\n            const resolveData = getDataFromParsedResolveInfoFragment(\n              parsedResolveInfoFragment,\n              MyConnection\n            );\n            /* highlight-end */\n\n            // For example, if this is called with (limit: 3)\n            // then we'd have:\n            //\n            // resolveData = {\n            /* highlight-start */\n            //   limit: [\n            //     3\n            //   ]\n            /* highlight-end */\n            // }\n\n            // TODO: generate and return connection\n          },\n        };\n      }\n    ),\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a bad-behaved setof Function in PostgreSQL\nDESCRIPTION: Defines a PostgreSQL PL/pgSQL function returning a setof 'person' with an intentionally mixed result, including NULL between rows. Requires an existing 'c.person' table and PL/pgSQL support. This example is used to explain why PostGraphile v4 treats connections from setof functions as nullable, highlighting migration impact. Inputs are queries or invocations of the function; output is an array possibly containing NULL and 'person' records.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v3-migration.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate function c.badly_behaved_function() returns setof c.person as $$\nbegin\n  return query select * from c.person order by id asc limit 1;\n  return next null;\n  return query select * from c.person order by id desc limit 1;\nend;\n$$ language plpgsql stable;\n```\n\n----------------------------------------\n\nTITLE: Defining STABLE and IMMUTABLE SQL Functions\nDESCRIPTION: Provides examples of defining PostgreSQL functions as `STABLE` or `IMMUTABLE`. These functions guarantee not to modify the database, enabling optimizations. `STABLE` functions can depend on database lookups or parameters (results consistent within a scan), while `IMMUTABLE` functions depend only on arguments (results always the same for same inputs). They often correspond to custom queries or computed columns in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_16\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_function(a int, b int) returns int as $$\n  â€¦\n$$ language sql stable;\n\n-- orâ€¦\n\ncreate function my_function(a int, b int) returns int as $$\n  â€¦\n$$ language sql immutable;\n\n-- or if you wanted to return a row from a tableâ€¦\n\ncreate function my_function(a int, b int) returns my_table as $$\n  â€¦\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Exporting PostGraphile Schema using graphile-export in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates initializing PostGraphile, retrieving the schema, and exporting it to an executable '.mjs' file using the `exportSchema` function from `graphile-export`. It requires the PostGraphile schema object and configuration (from `./graphile.config.js`), potentially including external modules like 'jsonwebtoken'. The output is a JavaScript module file containing the self-contained schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/exporting-schema.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { exportSchema } from \"graphile-export\";\nimport { postgraphile } from \"postgraphile\";\nimport config from \"./graphile.config.js\";\nimport * as jsonwebtoken from \"jsonwebtoken\";\n\nconst pgl = postgraphile(config);\nasync function main() {\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n  const exportFileLocation = `${__dirname}/exported-schema.mjs`;\n  await exportSchema(schema, exportFileLocation, {\n    mode: \"graphql-js\",\n    // or:\n    // mode: \"typeDefs\",\n    modules: {\n      jsonwebtoken: jsonwebtoken,\n    },\n  });\n}\n\nmain()\n  .finally(() => pgl.release())\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  });\n```\n\n----------------------------------------\n\nTITLE: Declaring PostGraphile Scripts and Dependencies for Node.js Deployment - JSON\nDESCRIPTION: This JSON snippet for package.json defines the project metadata, specifies postgraphile as a dependency, and sets up the start script for launching PostGraphile with required host and port options for Google App Engine. Dependencies: Postgraphile (4.x), Node.js 10.15+, npm 6.9+. The 'start' script specifically binds to all interfaces and port 8080 (required for GCP), enables CORS and enhanced GraphiQL, and connects to the PostgreSQL backend via TCP. Inputs: user- and environment-specific DB credentials, outputs: ready-for-deployment Node.js package file. Constraints: configure all credential placeholders before use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-gcp.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"myprojectname\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"postgraphile --host --port 8080 --cors --enhance-graphiql --graphql / 0.0.0.0 -c postgres://user:password@172.17.0.1:5432/str_dev\"\n  },\n  \"engines\": {\n    \"node\": \"^10.15\",\n    \"npm\": \"^6.9\"\n  },\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"postgraphile\": \"^4.4.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Argument Variant for Mutation Input (SQL)\nDESCRIPTION: This SQL snippet shows how to annotate a mutation function argument with @arg0variant patch, instructing PostGraphile to use the 'patch' GraphQL input type variant for parameter 0 in the schema. This is typically done to omit required columns (like id) from the client mutation input, matching update conventions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_24\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function new_example_with_auto_id(input example) is\n  E'@arg0variant patch';\n```\n\n----------------------------------------\n\nTITLE: Building a PostGraphile Node.js Application Image - Dockerfile\nDESCRIPTION: This Dockerfile defines a multi-stage build for a Node.js application serving PostGraphile as a library. It uses the node:alpine base image, sets up the app directory, copies package.json files, changes ownership for a non-root user (node), installs dependencies, and copies application files. The image exposes port 8080 and specifies the default command to run server.js. It expects application source to exist in ./src and is used in Docker Compose for orchestration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_3\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\\nLABEL description=\\\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\\\"\\n\\n# Set Node.js app folder\\nRUN mkdir -p /home/node/app/node_modules\\nWORKDIR /home/node/app\\n\\n# Copy dependencies\\nCOPY ./src/package*.json .\\nRUN chown -R node:node /home/node/app\\n\\n# Install dependencies\\nUSER node\\nRUN npm install\\n\\n# Copy application files\\nCOPY --chown=node:node ./src .\\n\\nEXPOSE 8080\\nCMD [ \\\"node\\\", \\\"server.js\\\" ]\n```\n\n----------------------------------------\n\nTITLE: Configuring Grafast Plan Explanation in TypeScript/JavaScript\nDESCRIPTION: This TypeScript/JavaScript code snippet demonstrates how to configure a Grafast server to expose execution plan diagrams. By setting the 'grafast.explain' option in the configuration file (e.g., 'graphile.config.mjs') to include 'plan', the server will make plan data available, often via GraphQL extensions.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport default {\n  grafast: {\n    explain: [\"plan\"],\n    // Setting explain: true will expose all explain types\n    // explain: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector with a Graphile Plugin (JavaScript)\nDESCRIPTION: This JavaScript code defines a Graphile plugin named `MyNewInflectorPlugin` that introduces a new inflector called `myNewInflector`. The function takes the resolved configuration `preset` (automatically supplied by the build system) and a `columnName` as input, returning a modified string by appending 'Something'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\n  name: \"MyNewInflectorPlugin\",\n  version: \"0.0.0\",\n  inflection: {\n    add: {\n      myNewInflector(preset, columnName) {\n        return columnName + \"Something\";\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating additionalGraphQLContextFromRequest to V5 Configuration with grafast.context - TypeScript\nDESCRIPTION: This TypeScript code demonstrates replacing the additionalGraphQLContextFromRequest configuration from V4 with the modern grafast.context option in PostGraphile V5. The function extracts request and response objects from the context and calls the classic V4 handler, returning the resulting context for GraphQL execution. This approach requires users to define or reuse their additionalGraphQLContextFromRequest logic and structure context as expected by their application. It assumes integration with the grafast context API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req, res } = ctx.node ?? {};\n      return additionalGraphQLContextFromRequest(req, res);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Expected Output from Successful PostgreSQL Configuration Check\nDESCRIPTION: Displays the notification message shown by PostgreSQL when the configuration verification SQL script executes successfully, indicating that the database settings are correct for using `@graphile/lds`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nNOTICE:  00000: Everything seems to be in order.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Closure Limitation with Function toString() in JavaScript\nDESCRIPTION: Demonstrates that `toString()` on a function using a variable (`a`) from its parent scope does not capture the value of that variable, highlighting the difficulty in exporting functions with closures.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n> const a = 7;\nundefined\n> function add(b) { return a + b };\nundefined\n> add(3)\n10\n> add.toString()\n'function add(b) { return a + b }'\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.0\nDESCRIPTION: This snippet marks the initial dependency version recorded in the changelog, specifically version '0.0.1-0.0' of the 'grafast' package, associated with the initial release.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.0\n```\n\n----------------------------------------\n\nTITLE: Installing eslint-plugin-graphile-export via Yarn\nDESCRIPTION: Provides the shell command to install the `eslint-plugin-graphile-export` package using the Yarn package manager. This plugin helps automate the process of wrapping code with `EXPORTABLE`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nyarn add eslint-plugin-graphile-export@beta\n```\n\n----------------------------------------\n\nTITLE: Embedding Mermaid Sequence Diagram in Documentation - JSX (React/Markdown)\nDESCRIPTION: This snippet demonstrates how to embed a Mermaid sequence diagram within a documentation page using a React/JSX-styled component. The imported Mermaid component from the '@theme/Mermaid' module allows the user to display rendered diagrams by passing a Mermaid syntax chart as the 'chart' prop. Requires a React-based documentation system (such as Docusaurus) preconfigured with the '@theme/Mermaid' component. The main parameter, 'chart', should be a properly formatted Mermaid sequence diagram string. The component renders the corresponding visualization inline within the Markdown content. Inputs are the Mermaid diagram string; output is the rendered SVG/diagram artifact.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/servers/index.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Mermaid from \"@theme/Mermaid\";\n\n<Mermaid\n  chart={`\\\nsequenceDiagram\n  participant Server as Server Framework\n  participant Adaptor as Grafserv Adaptor\n  participant Grafserv as Grafserv Core\n  Server->>Adaptor: Framework request object\n  Adaptor->>Grafserv: Normalized request digest<br/>(method, path, headers, etc)\n  opt For POST requests\n    Grafserv--)Adaptor: Get request body\n    Adaptor--)Server: Fetch body\n    Server--)Adaptor: Framework specific body<br/>(Buffer, JSON, text, etc)\n    Adaptor--)Grafserv: Normalized body\n  end\n  Grafserv-)Grafserv: Compute GraphQL Result\n  Grafserv->>Adaptor: Grafserv response<br/>(JSON, text, stream, etc)\n  Adaptor->>Server: Framework response\n`}\n/>\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Computed Fields (GraphQL)\nDESCRIPTION: This GraphQL snippet shows how PostGraphile exposes SQL functions like `person_full_name` and `person_latest_post` as computed fields (`fullName`, `latestPost`) on the corresponding GraphQL type (`Person`). This requires the SQL functions to meet specific criteria, such as taking the table row as the first argument and being marked `stable`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\ntype Person {\n  id: Int!\n  firstName: String!\n  lastName: String\n  ...\n  fullName: String\n  latestPost: Post\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Signature for applyTransforms Function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript type signature for the applyTransforms function, indicating it takes an ExecutableStep and returns another ExecutableStep with applied transforms. It clarifies required parameter types and intended functional interface for users and implementers needing to utilize or type-check applyTransforms in custom workflows or integrations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/applyTransforms.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction applyTransforms($step: ExecutableStep): ExecutableStep;\n```\n\n----------------------------------------\n\nTITLE: Referencing V4 Preset Inflector Override '_joinAttributeNames'\nDESCRIPTION: Identifies the '_joinAttributeNames' inflector function within the PostGraphile V4 preset. This override is mentioned in the context of maintaining V4 compatibility amidst inflection changes introduced in V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n`_joinAttributeNames`\n```\n\n----------------------------------------\n\nTITLE: Defining Grafserv Persisted Operations Options using TypeScript\nDESCRIPTION: This TypeScript snippet defines the configuration options added by the `@grafserv/persisted` plugin. It includes options for extracting the operation hash from the payload (`hashFromPayload`), specifying the source of persisted operations (`persistedOperationsDirectory`, `persistedOperations`, `persistedOperationsGetter`), and conditionally allowing non-persisted operations (`allowUnpersistedOperation`). Detailed comments explain the purpose and usage of each option.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * This function will be passed a GraphQL request object (normally\n * `{query: string, variables?: any, operationName?: string, extensions?: any}`,\n * but in the case of persisted operations it likely won't have a `query`\n * property), and must extract the hash to use to identify the persisted\n * operation. For Apollo Client, this might be something like:\n * `request?.extensions?.persistedQuery?.sha256Hash`; for Relay something\n * like: `request?.documentId`.\n */\nhashFromPayload?(request: ParsedGraphQLBody): string | undefined;\n\n/**\n * We can read persisted operations from a folder (they must be named\n * `<hash>.graphql`). When used in this way, the first request for a hash\n * will read the file, and then the result will be cached such that the\n * **filesystem read** will only impact the first use of that hash. We\n * periodically scan the folder for new files, requests for hashes that\n * were not present in our last scan of the folder will be rejected to\n * mitigate denial of service attacks asking for non-existent hashes.\n */\npersistedOperationsDirectory?: string;\n\n/**\n * An optional string-string key-value object defining the persisted\n * operations, where the keys are the hashes, and the values are the\n * operation document strings to use.\n */\npersistedOperations?: { [hash: string]: string };\n\n/**\n * If your known persisted operations may change over time, or you'd rather\n * load them on demand, you may supply this function. Note this function is\n * **performance critical** so you should use caching to improve\n * performance of any follow-up requests for the same hash.\n */\npersistedOperationsGetter?: PersistedOperationGetter;\n\n/**\n * There are situations where you may want to allow arbitrary operations\n * (for example using GraphiQL in development, or allowing an admin to\n * make arbitrary requests in production) whilst enforcing Persisted\n * Operations for the application and non-admin users. This function\n * allows you to determine under which circumstances persisted operations\n * may be bypassed.\n *\n * IMPORTANT: this function must not throw!\n *\n * @example\n *\n * ```\n * app.use(postgraphile(DATABASE_URL, SCHEMAS, {\n *   allowUnpersistedOperation(event) {\n *     return process.env.NODE_ENV === \"development\" && event.request?.getHeader('referer')?.endsWith(\"/graphiql\");\n *   }\n * });\n * ```\n */\nallowUnpersistedOperation?:\n  | boolean\n  | ((event: ProcessGraphQLRequestBodyEvent) => boolean);\n```\n\n----------------------------------------\n\nTITLE: Enabling pgcrypto Extension in PostgreSQL (SQL)\nDESCRIPTION: This SQL command ensures the `pgcrypto` extension is available in the current PostgreSQL database. It's a prerequisite for using cryptographic functions like password hashing (`crypt`, `gen_salt`) required by the user registration function.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_20\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n```\n\n----------------------------------------\n\nTITLE: Using te.substring for Safe String Embedding in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use `te.substring` to safely embed an untrusted string, containing various special characters and potential injection code (`'`, `\"`, `` ` ``, `\\`, `${...}`), into a double-quoted string literal. The `te.run` function likely processes the template literal, and `te.substring(untrusted, '\"')` ensures the `untrusted` variable is properly escaped for inclusion within double quotes. It requires a `te` object with `run` and `substring` methods and the standard `assert` module. An assertion verifies that the original content of `untrusted` is correctly escaped and included in the output string, preventing the execution of the embedded code.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-substring.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// Some untrusted user input, could have anything in it\nconst untrusted = \"'\\\"` \\\\'\\\\\"\\\\` ${process.exit(1)}\";\n\n// Safely insert the untrusted input into a string\nconst code = te.run`return \"abc${te.substring(untrusted, '\"')}123\";`;\n\nassert.strictEqual(code, \"abc'\\\"` \\\\'\\\\\"\\\\` ${process.exit(1)}123\");\n```\n\n----------------------------------------\n\nTITLE: Creating an Authentication Function for JWT Generation (PL/pgSQL)\nDESCRIPTION: Implements a secure PostgreSQL function (in PL/pgSQL) to authenticate users based on email and password, returning a JWT composite type if authentication succeeds. The function fetches the user from a private schema, compares password hashes using pgcryptoâ€™s 'crypt' function, and generates a token that includes the userâ€™s role, ID, and expiration as a Unix epoch. It is marked STRICT and SECURITY DEFINER to ensure security. Dependencies: access to 'forum_example_private.person_account', Postgres 'pgcrypto' extension, the previously defined JWT composite type, and suitable privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_32\n\nLANGUAGE: plpgsql\nCODE:\n```\ncreate function forum_example.authenticate(\n  email text,\n  password text\n) returns forum_example.jwt_token as $$\ndeclare\n  account forum_example_private.person_account;\nbegin\n  select a.* into account\n  from forum_example_private.person_account as a\n  where a.email = $1;\n\n  if account.password_hash = crypt(password, account.password_hash) then\n    return ('forum_example_person', account.person_id, extract(epoch from (now() + interval '2 days')))::forum_example.jwt_token;\n  else\n    return null;\n  end if;\nend;\n$$ language plpgsql strict security definer;\n\ncomment on function forum_example.authenticate(text, text) is 'Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 2 days.';\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Query Functions with PostgreSQL in SQL\nDESCRIPTION: These example SQL snippets demonstrate how to define PostgreSQL functions that are recognized by PostGraphile as custom root-level GraphQL queries. Each function illustrates different return types: a scalar (int) and a table row type. Functions must comply with PostGraphile requirements (e.g., be STABLE/IMMUTABLE, not return VOID, reside in introspected schemas). Arguments (named for clarity) are used as GraphQL field arguments. Both definitions require execution in a PostgreSQL environment, utilizing the SQL language with appropriate stability markings. No dependencies beyond PostgreSQL and a compatible schema are necessary.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/custom-queries.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function my_function(a int, b int) returns int as $$ â€¦ $$ language sql immutable;\ncreate function my_other_function(a int, b int) returns my_table as $$ â€¦ $$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Importing Grafserv Adaptors for Web Server Integration (TypeScript)\nDESCRIPTION: This snippet showcases importing the appropriate Grafserv adaptor for your chosen JavaScript web server (Node HTTP, Express, Koa, Fastify, etc). Only one import should be selected based on the server framework in use. Ensure you have the grafserv package and the relevant adaptor installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { grafserv } from \"grafserv/node\";\n// OR: import { grafserv } from \"grafserv/express/v4\";\n// OR: import { grafserv } from \"grafserv/koa/v2\";\n// OR: import { grafserv } from \"grafserv/fastify/v4\";\n// etc\n```\n\n----------------------------------------\n\nTITLE: Re-initializing PostgreSQL Database in Docker\nDESCRIPTION: Outlines the sequence of shell commands required to completely reset and re-initialize the PostgreSQL database when schema changes are made (e.g., modifying files in `/db/init`). This process involves stopping the running containers (`docker-compose down`), listing Docker volumes (`docker volume ls`), removing the specific volume associated with the database (`docker volume rm <your_repository_name>_db`), removing the existing database Docker image (`docker rmi db`) to ensure it's rebuilt with the new initialization scripts, and finally restarting the services (`docker-compose up`), which triggers the image rebuild and database initialization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n# Stop running containers\n$ docker-compose down\n\n# List Docker volumes\n$ docker volume ls\n\n# Delete volume\n$ docker volume rm <your_repository_name>_db\n\n# Delete database image to force rebuild\n$ docker rmi db\n\n# Run containers (will automatically rebuild the image)\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Running Locally Installed PostGraphile with npx (Bash)\nDESCRIPTION: Executes the locally installed `postgraphile` command using `npx`. This command assumes `postgraphile` has been installed in the project's `node_modules` directory (e.g., via `npm install`). It applies the 'amber' preset (`-P postgraphile/presets/amber`), enables explain mode (`-e`), and specifies the database connection string (`-c postgres:///mydb`). The `-e` flag is recommended only for development environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-cli.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx postgraphile -P postgraphile/presets/amber -e -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Type Based Union Relationships Â· SQL\nDESCRIPTION: Demonstrates the creation of a PostgreSQL composite type to represent a union between several tables by storing multiple nullable foreign keys as distinct attributes, with the expectation that only one will be non-null. Useful when returning unions from functions or supporting polymorphic columns, this pattern highlights a denormalized way to indicate which record is being referenced.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncreate table people (...);\ncreate table posts (...);\ncreate table comments (...);\n\ncreate type entity as (\n  person_id int,\n  post_id int,\n  comment_id int\n);\n\n```\n\n----------------------------------------\n\nTITLE: Referencing V4 Preset Inflector Override 'attribute'\nDESCRIPTION: Identifies the 'attribute' inflector function within the PostGraphile V4 preset. This override is needed to revert changes where the 'id' to 'rowId' logic was moved from this inflector to '_attributeName' in V5, ensuring V4 behavior is preserved.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n`attribute`\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Function Arguments in PostGraphile (Library)\nDESCRIPTION: This JavaScript snippet shows how to configure the PostGraphile library middleware to treat all function arguments as non-null (required) unless they have a default value. This is achieved by setting the `pgStrictFunctions` option within `graphileBuildOptions` to `true`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/custom-mutations.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.use(\n  postgraphile(connectionString, schemaName, {\n    graphileBuildOptions: {\n      pgStrictFunctions: true,\n    },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Providing Edge Data Plans in connection() Configuration (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use the new connection() configuration object to define edgeDataPlan, associating rich edge data within GraphQL connections. It further shows how to reference edge data in resolver plan objects, using the EdgeStep's data() and get() methods. Users must supply the appropriate $item and $otherThing variables, and the output will allow resolvers to access custom edge metadata.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nreturn connection($list, {\\n  edgeDataPlan($item) {\\n    return object({ item: $item, otherThing: $otherThing });\\n  },\\n});\\n\\n// ...\\n\\nconst plans = {\\n  FooEdge: {\\n    otherThing($edge) {\\n      return $edge.data().get(\"otherThing\");\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Manipulating Request Body with a Server Plugin in TypeScript\nDESCRIPTION: This TypeScript snippet showcases a Graphile server plugin named `QueryByNamePlugin` designed to modify the GraphQL request body. It intercepts the request using the `processGraphQLRequestBody` middleware hook within the `grafserv` scope. The plugin attempts to find a GraphQL document in a predefined `documents` map using the `id` property from the request body and populates the `body.query` field accordingly. It depends on `GraphileConfig` and `SafeError` from the `grafast` library. Note: This is intended as an API demonstration; `@grafserv/persisted` is recommended for actual persisted queries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { SafeError } from \"grafast\";\n\nconst documents = Object.assign(Object.create(null), {\n  QueryName: `query QueryName { __typename }`,\n  WhoAmI: `query WhoAmI { currentUser { name } }`,\n  CreatePost: `mutation CreatePost($input: CreatePostInput!) { createPost(input: $input) { post { id title } } }`,\n});\n\nexport const QueryByNamePlugin: GraphileConfig.Plugin = {\n  name: \"QueryByNamePlugin\",\n  description: \"Only specify the query name and the query will be populated\",\n  version,\n\n  grafserv: {\n    middleware: {\n      processGraphQLRequestBody(next, event) {\n        const { body } = event;\n        const document = documents[body.id];\n        if (!document) {\n          throw new SafeError(\n            `QueryByNamePlugin couldn't find query '${body.id}'`,\n            { statusCode: 400 },\n          );\n        } else {\n          body.query = document;\n        }\n        return next();\n      },\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Masking Email Addresses by Pattern in Field Resolver (TypeScript)\nDESCRIPTION: This plugin modifies the User.email field by passing the resolved value through a masking regular expression, hiding part of the email without omitting it. Dependencies include makeWrapPlansPlugin and lambda from PostGraphile. The code expects email string input and outputs a masked string matching a specified pattern. It acts as a privacy-preservation mechanism for user data in the API response.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\\nimport { lambda } from \"postgraphile/grafast\";\\n\\nexport default makeWrapPlansPlugin({\\n  User: {\\n    email(plan) {\\n      const $email = plan();\\n      return lambda($email, (email) =>\\n        // someone@sub.example.com -> so***@su***.com\\n        email.replace(\\n          /^(.{1,2})[^@]*@(.{,2})[^.]*\\.([A-z]{2,})$/,\n          \"$1***@$2***.$3\",\\n        ),\\n      );\\n    },\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Login-capable Roles and Users in PostgreSQL - SQL\nDESCRIPTION: This snippet shows two equivalent ways to create a PostgreSQL role with LOGIN capability, making it a user. These commands are used when you wish to create a user for database authentication. Inputs are the desired username. Outputs are new login-enabled roles who can connect to the database. Requires PostgreSQL superuser or user-creation privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/default-role.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate role admin login;\ncreate user admin;\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @foreignKey Constraints via SQL Comment (SQL)\nDESCRIPTION: These SQL comment examples attach one or more virtual @foreignKey constraints on a materialized view, enabling Graphile to infer relationships in the GraphQL schema. The syntax mirrors regular PostgreSQL foreign key definitions, but is only for schema inference. Multiple constraints are separated by newlines in the comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_31\n\nLANGUAGE: sql\nCODE:\n```\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)';\n\n-- or if you want multiple foreignKeys\ncomment on materialized view my_materialized_view is E'@foreignKey (key_1, key_2) references other_table (key_1, key_2)\\n@foreignKey (key_3, key_4) references some_other_table (key_3, key_4)';\n```\n\n----------------------------------------\n\nTITLE: Adding GraphQL Service Definition to docker-compose.yml\nDESCRIPTION: Updates the `docker-compose.yml` file to define the `graphql` service alongside the existing `db` service. It configures the `graphql` service with a specific container name (`forum-example-graphql`), sets it to always restart, specifies the image name (`forum-example-graphql`), provides the build context (`./graphql`), links the environment variables file (`.env`), establishes a dependency on the `db` service, connects it to the `network`, and maps the host port 5433 to the container port 5433 (matching the `PORT` variable).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.3\"\nservices:\n    db: [...]\n\n    graphql:\n        container_name: forum-example-graphql\n        restart: always\n        image: forum-example-graphql\n        build:\n            context: ./graphql\n        env_file:\n            - ./.env\n        depends_on:\n            - db\n        networks:\n            - network\n        ports:\n            - 5433:5433\n[...]\n```\n\n----------------------------------------\n\nTITLE: Setting Session Variables from JWT Example Claims (SQL)\nDESCRIPTION: These SQL commands demonstrate how the claims from a JWT payload are mapped to PostgreSQL session settings. It shows 'SET LOCAL ROLE' for the user role, then assigns each individual claim to the dedicated 'jwt.claims' namespace using 'SET LOCAL'. The snippet clarifies the one-to-one correspondence between JWT claims and variables visible within a transaction, which presumes claim values are strings or literals.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nset local role user;\nset local jwt.claims.sub to 'postgraphql';\nset local jwt.claims.role to 'user';\nset local jwt.claims.user_id to 2;\n```\n\n----------------------------------------\n\nTITLE: Snapshot Testing a Sorted GraphQL Schema with Jest and TypeScript\nDESCRIPTION: Demonstrates how to ensure snapshot stability regardless of schema definition order. This Jest test fetches and builds the GraphQL schema, then uses `lexicographicSortSchema` from the `graphql` library to sort the schema elements alphabetically before generating the snapshot with `toMatchSnapshot()`. This prevents test failures caused solely by reordering of types or fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lexicographicSortSchema } from \"graphql\";\n\ntest(\"Pokemon GraphQL API has a consistent schema\", async () => {\n  const schema = await getSchema(\"https://graphql-pokemon.now.sh\");\n  expect(lexicographicSortSchema(schema)).toMatchSnapshot();\n});\n```\n\n----------------------------------------\n\nTITLE: Building PostGraphile Docker Image with Custom Plugin Installation\nDESCRIPTION: Defines the Docker build process for the PostGraphile service. It starts from a Node.js Alpine image, installs `postgraphile` and the connection filter plugin globally, copies the `custom-plugin` code, packages it using `npm pack`, installs the resulting `.tgz` file globally, removes the temporary plugin source, exposes port 5000, and sets the entry point to start the `postgraphile` server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_21\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Install PostGraphile and PostGraphile connection filter plugin\nRUN npm install -g postgraphile\nRUN npm install -g postgraphile-plugin-connection-filter\n\n# Install custom plugin\nCOPY ./custom-plugin /tmp/custom-plugin\nRUN cd /tmp/custom-plugin && npm pack\nRUN npm install -g /tmp/custom-plugin/custom-plugin-0.0.1.tgz\nRUN rm -rf /tmp/custom-plugin\n\nEXPOSE 5000\nENTRYPOINT [\"postgraphile\", \"-n\", \"0.0.0.0\"]\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Current Person from JWT Claims in PostgreSQL (SQL)\nDESCRIPTION: Defines a SQL function to return the user row identified by the JWT's 'person_id' claim, using 'current_setting' and casting its output. Requires the 'forum_example.person' table and the JWT to contain a 'person_id'. Input is implicit (the current session JWT claim); output is the corresponding user row. Handles conversion (string to integer) and null-safety in claim extraction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_36\n\nLANGUAGE: SQL\nCODE:\n```\ncreate function forum_example.current_person() returns forum_example.person as $$\n  select *\n  from forum_example.person\n  where id = nullif(current_setting('jwt.claims.person_id', true), '')::integer\n$$ language sql stable;\n\ncomment on function forum_example.current_person() is 'Gets the person who was identified by our JWT.';\n```\n\n----------------------------------------\n\nTITLE: Updating PostgreSQL Adaptor Configuration with Direct Import (JavaScript)\nDESCRIPTION: Demonstrates the required update for configuring the PostgreSQL adaptor introduced in version 5.0.0-beta.26. Instead of a string path, the adaptor module must be imported directly using `await import()`. This change improves bundlability by removing dynamic imports.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nadaptor: await import(\"@dataplan/pg/adaptors/pg\")\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Heroku Config Variables (Bash)\nDESCRIPTION: Demonstrates setting multiple environment variables (`NODE_ENV`, `GRAPHILE_TURBO`, `DATABASE_URL`) simultaneously on a Heroku application (`myappname`) using a single `heroku config:set` command with backslash line continuation. This configures the application for production, enables Graphile Turbo mode for potential performance improvements, and provides the database connection string with SSL required.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set \\\n    NODE_ENV=\"production\" \\\n    GRAPHILE_TURBO=\"1\" \\\n    DATABASE_URL=\"postgres://username:password@host:port/dbname?ssl=true\" \\\n    -a myappname\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruru HTML Parts with a Plugin in TypeScript\nDESCRIPTION: This snippet illustrates creating a GraphileConfig Plugin to dynamically customize Ruru's HTML output. The plugin, `RuruMetaPlugin`, hooks into the `grafserv.hooks.ruruHTMLParts` lifecycle event. Within the hook, it modifies the `parts.metaTags` by appending a viewport meta tag. The comment highlights that `extra.request` details can be used for per-request customization.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst RuruMetaPlugin: GraphileConfig.Plugin = {\n  name: \"RuruMetaPlugin\",\n  version: \"0.0.0\",\n  grafserv: {\n    hooks: {\n      ruruHTMLParts(_info, parts, extra) {\n        // extra.request gives you access to request details, so you can customize `parts` for the user\n\n        parts.metaTags += `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />`;\n      },\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruru Title with a Server Plugin in TypeScript\nDESCRIPTION: This TypeScript snippet defines a function `makeRuruTitlePlugin` that generates a Graphile server plugin. The plugin customizes the HTML title tag displayed in the Ruru interface by intercepting the `ruruHTMLParts` middleware event within the `grafserv` scope. It requires the `GraphileConfig` type and an `escapeHTML` utility function (assumed to be available), taking a desired `title` string as input.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction makeRuruTitlePlugin(title: string): GraphileConfig.Plugin {\n  return {\n    name: \"RuruTitlePlugin\",\n    version: \"0.0.0\",\n\n    grafserv: {\n      middleware: {\n        ruruHTMLParts(next, event) {\n          const { htmlParts, request } = event;\n          htmlParts.titleTag = `<title>${escapeHTML(\n            title + \" | \" + request.getHeader(\"host\"),\n          )}</title>`;\n          return next();\n        },\n      },\n    },\n  };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Controlling Graphile Plugin Load Order with `before` and `after` in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to explicitly control the loading order of Graphile Config plugins using the `before` and `after` properties. `PluginA` loads after `PluginC`, `PluginB` loads before `PluginA`, and `PluginC` loads after `PluginB`. This results in a guaranteed loading order of `[PluginB, PluginC, PluginA]`, overriding the default preset resolution order.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=graphile.config.ts\nimport type {} from \"graphile-config\";\n\nconst PluginA: GraphileConfig.Plugin = { name: \"PluginA\", after: [\"PluginC\"] };\nconst PluginB: GraphileConfig.Plugin = { name: \"PluginB\", before: [\"PluginA\"] };\nconst PluginC: GraphileConfig.Plugin = { name: \"PluginC\", after: [\"PluginB\"] };\n\nconst Preset1: GraphileConfig.Preset = {\n  plugins: [PluginA],\n};\n\nconst Preset2: GraphileConfig.Preset = {\n  extends: [Preset1],\n  plugins: [PluginB, PluginC],\n};\n\n// Resulting order: PluginB, PluginC, PluginA\n```\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with makeExtendSchemaPlugin using SDL\nDESCRIPTION: Demonstrates using GraphQL Schema Definition Language (SDL) within the `makeExtendSchemaPlugin` factory to add new fields, like `random: Int`, to existing types such as `Query`. This approach requires providing corresponding Grafast plans or GraphQL resolvers for execution logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nextend type Query { random: Int }\n```\n\n----------------------------------------\n\nTITLE: Extending TypeScript Configuration for Modern Node.js - JSON\nDESCRIPTION: This snippet demonstrates how to extend a root tsconfig.json file using the '@tsconfig/node20' preset, aligning TypeScript's module resolution and settings with Node.js v20 defaults. No additional dependencies are required aside from the '@tsconfig/node20' package. The file should be named 'tsconfig.json', and this configuration helps ensure that TypeScript properly resolves modern Node.js-style modules, preventing import errors such as 'Cannot find module'.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"extends\\\": \\\"@tsconfig/node20\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the EXPORTABLE Helper from graphile-export (TypeScript)\nDESCRIPTION: This snippet shows how to import the EXPORTABLE function from the graphile-export/helpers package in a TypeScript codebase. This utility is required to wrap values that have scope dependencies and need to be exported using Graphile Export. The import is the prerequisite for all related EXPORTABLE usage patterns.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EXPORTABLE } from \"graphile-export/helpers\";\n```\n\n----------------------------------------\n\nTITLE: Creating a Function to Get Latest Post (SQL)\nDESCRIPTION: This SQL code creates a function `forum_example.person_latest_post` that retrieves the most recent forum post for a given person. It accepts a `forum_example.person` row, queries the `post` table filtering by `author_id` and ordering by `created_at`, and returns the latest `forum_example.post` row. It's marked `stable` and includes a comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.person_latest_post(person forum_example.person) returns forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where post.author_id = person.id\n  order by created_at desc\n  limit 1\n$$ language sql stable;\n\ncomment on function forum_example.person_latest_post(forum_example.person) is 'Getâ€™s the latest post written by the person.';\n```\n\n----------------------------------------\n\nTITLE: Equivalent SQL for Nested Channel Lookup (SQL)\nDESCRIPTION: This SQL query represents how Grafast and @dataplan/pg optimize nested queries into a single statement, joining channels and users by organization_id using a subselect. This equivalence ensures performance and single-round-trip database access. Inputs are the parameterized userId. Outputs are the matching channels rows. Any referenced columns/tables must exist in the database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_14\n\nLANGUAGE: SQL\nCODE:\n```\nselect ...\nfrom channels\nwhere organization_id = (\n  select users.organization_id\n  from users\n  where users.id = $1\n);\n```\n\n----------------------------------------\n\nTITLE: Referencing V4 Preset Inflector Override '_attributeName'\nDESCRIPTION: Identifies the '_attributeName' inflector function within the PostGraphile V4 preset. This function is highlighted as one of the overrides necessary to maintain V4 naming behavior, specifically undoing the V5 change that moved 'id' to 'rowId' logic into this inflector.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n`_attributeName`\n```\n\n----------------------------------------\n\nTITLE: Opting In to application/x-www-form-urlencoded Content Type in Grafserv (TypeScript)\nDESCRIPTION: This TypeScript snippet configures Grafserv to allow requests with 'application/x-www-form-urlencoded' content type by updating the allowedRequestContentTypes array. It imports DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES from 'grafserv' and includes the form content type in a GraphileConfig.Preset. Dependencies are 'grafserv' and 'graphile-config'; configuration expected in graphile.config.ts. Inputs include extended preset and allowed content types; outputs a less restrictive content-type policy, suitable for legacy support. Limitation: increases CSRF risk if not protected.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv/CHANGELOG.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES } from \"grafserv\";\n\nconst preset: GraphileConfig.Preset = {\n  //...\n\n  grafserv: {\n    //...\n\n    allowedRequestContentTypes: [\n      ...DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES,\n      \"application/x-www-form-urlencoded\",\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Custom 'containsPostsByUserId' Condition in GraphQL\nDESCRIPTION: Illustrates how to use the custom `containsPostsByUserId` condition (created by a plugin like the one in Example 2) in a GraphQL query to filter the `allForums` collection. It demonstrates querying forums containing posts by user with ID 1.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-condition-plugin.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsContainingPostsByUser1 {\n  allForums(condition: { containsPostsByUserId: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing Runtime Query Builder Augmentation (TypeScript)\nDESCRIPTION: Runtime query builders are introduced for `PgSelectStep` and `PgUnionAllStep`. Corresponding `apply()` methods (`PgSelectStep.apply()` and `PgUnionAllStep.apply()`) allow registering callbacks to augment the query builder at runtime, e.g., for handling orderBy logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nPgSelectStep\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgUnionAllStep\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgSelectStep.apply()\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgUnionAllStep.apply()\n```\n\n----------------------------------------\n\nTITLE: Reading HTTP Headers in PostgreSQL Function - SQL\nDESCRIPTION: This SQL function demonstrates how to create a custom PostgreSQL function for accessing a session variable set via PostGraphile's `pgSettings` feature. The function `get_x_something` retrieves the `http.headers.x-something` value using the `current_setting` built-in. Preconditions include the session variable being set by the application middleware, and it returns the value as text or NULL if unset. This is useful for extending PostgreSQL access to web-layer request data, with the constraint that the session variable is only available per transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate function get_x_something() returns text as $$\n  select current_setting('http.headers.x-something', true)::text;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client Caching Using Custom ID Fields (TypeScript)\nDESCRIPTION: This TypeScript snippet configures Apollo Client with a custom data identity function for caching purposes, prioritizing the 'id' or 'nodeId' field as the cache key. It imports required Apollo Client libraries and sets the 'dataIdFromObject' property of InMemoryCache to extract either '.id' or '.nodeId' from each object. Inputs are GraphQL response objects, output is a cache key string or null. Dependencies are 'apollo-client', 'apollo-link-http', and 'apollo-cache-inmemory'. Suitable for ensuring normalized caching when the server schema uses a configurable unique identifier.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/node-id.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport ApolloClient from \"apollo-client\";\nimport { HttpLink } from \"apollo-link-http\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\n\nconst cache = new InMemoryCache({\n  // highlight-next-line\n  dataIdFromObject: (object) => object.id || null,\n  // Or if you renamed 'id' to 'nodeId' then:\n  //   dataIdFromObject: (object) => object.nodeId || null,\n});\n\nexport const client = new ApolloClient({\n  link: new HttpLink(),\n  cache,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Primary Key via Smart Tag in JSON5 - JSON5\nDESCRIPTION: Demonstrates setting a primary key on a view using the 'primaryKey' tag in 'postgraphile.tags.json5'. The configuration assigns a single column (id) or multiple columns as the composite primary key for 'my_view'. This influences GraphQL schema generation in PostGraphile by enforcing uniqueness and non-null constraints at the API level. Inputs: column names, Output: constraint tags for view.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_15\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_view: {\n        tags: {\n          primaryKey: \"id\",\n          // or:\n          //   primaryKey: \"type,identifier\"\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Annotations with SQL Comments in PostgreSQL\nDESCRIPTION: This SQL snippet demonstrates how to use the COMMENT ON TABLE syntax in PostgreSQL to add both a smart tag annotation (@name) and descriptive documentation for a table. The smart tag modifies the name used by PostGraphile in the generated GraphQL schema, while the accompanying documentation string is used for field/type descriptions visible in tools like GraphiQL. Requires PostgreSQL and a table named 'users'. The expected input is the table to annotate and the content of the comment; output is meta-information stored in the PostgreSQL system catalogs for use by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/customization-overview.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TABLE users IS $$\n@name people\nRepresents the people that can log in to our application.\n$$;\n```\n\n----------------------------------------\n\nTITLE: Declaring makeAddPgTableConditionPlugin V4 Signature in TypeScript\nDESCRIPTION: This TypeScript snippet declares the V4 signature for the makeAddPgTableConditionPlugin function, a core utility used for creating condition plugins in PostGraphile. It specifies argument types for schema and table names, condition field configuration, and the SQL condition generator. The signature returns a Plugin type and requires TypeScript context for types such as Build, QueryBuilder, PgSQL, SQL, and Plugin, assumed to be imported or globally available.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// V4 signature\\nfunction makeAddPgTableConditionPlugin(\\n  schemaName: string,\\n  tableName: string,\\n  conditionFieldName: string,\\n  fieldSpecGenerator: (build: Build) => GraphQLInputFieldConfig,\\n  conditionGenerator: (\\n    value: unknown,\\n    helpers: { queryBuilder: QueryBuilder; sql: PgSQL; sqlTableAlias: SQL },\\n    build: Build,\\n  ) => SQL,\\n): Plugin;\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema for Person Favourite Union Entity Â· GraphQL\nDESCRIPTION: Illustrates a GraphQL schema snippet that defines a union type for a person's favorite entity, allowing it to be a Person, Post, or Comment, and an enclosing type for storing favorites. This schema underpins the associated SQL and resource planning by describing the model's GraphQL contract.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_12\n\nLANGUAGE: graphql\nCODE:\n```\nunion PersonFavouriteEntity = Person | Post | Comment\ntype PersonFavourite {\n  id: ID!\n  person: Person!\n  entity: PersonFavouriteEntity!\n}\ntype Person {\n  # ...\n  favourites: [PersonFavourite!]!\n}\ntype Query {\n  person: Person\n}\n\n```\n\n----------------------------------------\n\nTITLE: Annotating a Function with Smart Comments - SQL\nDESCRIPTION: This example shows a COMMENT ON FUNCTION statement that applies smart tags and descriptive text to a stored procedure, customizing its representation in PostGraphile's schema. Needed are an existing function and known argument types. Tags can alter GraphQL naming and documentation, with strings separated by escaped newlines.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function my_function(arg_type_1, arg_type_2) is\\n  E'@name my_new_function_name\\\\nDocumentation here.';\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Columns - SQL\nDESCRIPTION: This example illustrates smart tagging of a table column via a COMMENT statement, customizing its name and omitting create/update operations in PostGraphile. The escape string syntax allows for newline separation of tags. Input: COMMENT ON COLUMN. Output: column schema behavior is affected in the generated GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\\n  E'@name my_new_column\\\\n@omit create,update\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Module in React Component (JavaScript)\nDESCRIPTION: Imports a CSS module file into a React component so that scoped CSS classes can be applied by referencing the returned 'styles' object. This allows for CSS class names to be used as properties (e.g., styles.graphileHeart) within JSX for style encapsulation. Requires a supported React environment and an appropriate bundler (such as Webpack) configured for CSS modules. Input is a module path string; output is a JavaScript object mapping CSS class names; works with .module.css files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/community-chat.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.10\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.10' of the 'grafast' package, as recorded in the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.10\n```\n\n----------------------------------------\n\nTITLE: Updating package.json for TypeScript and PostGraphile Development (json)\nDESCRIPTION: This package.json fragment configures output/main entry points, files to publish (dist), and scripts for compiling and live watching TypeScript during development and prepack. It also ensures the correct devDependencies for TypeScript and Node 18 tsconfig preset are installed. Inputs include src directory files; outputs are in dist. The watch script uses tsc --watch for live compilation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  // ...\\n  \\\"main\\\": \\\"dist/index.js\\\",\\n  \\\"types\\\": \\\"dist/index.d.ts\\\",\\n  \\\"files\\\": [\\\"dist\\\"],\\n  \\\"scripts\\\": {\\n    // ...\\n    \\\"watch\\\": \\\"tsc --watch\\\",\\n    \\\"prepack\\\": \\\"tsc\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    // ...\\n    \\\"@tsconfig/node18\\\": \\\"^18.2.4\\\",\\n    \\\"typescript\\\": \\\"^5.7.2\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Table and Function Using Patch Variant (SQL)\nDESCRIPTION: This SQL example creates a table and a function that inserts a new row with an auto-generated id, returning the table type. It demonstrates the use of 'patch' argument variant annotation discussed in adjacent text. Dependencies: UUID generator must be available (e.g., pgcrypto extension).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_25\n\nLANGUAGE: sql\nCODE:\n```\ncreate table example(\n  id uuid primary key,\n  name text not null\n);\n\ncreate function new_example_with_auto_id(input example) returns example as $$\n  insert into example (id, name) values (gen_random_uuid(), input.name) returning *;\n$$ language sql volatile;\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic SQL Function (Default VOLATILE)\nDESCRIPTION: Illustrates the basic syntax for creating a SQL function without explicitly specifying volatility. PostgreSQL defaults to `VOLATILE` in this case, assuming the function might modify data or have side effects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql;\n```\n```\n\n----------------------------------------\n\nTITLE: Loading Custom Graphile Plugins in `graphile.config.mjs` (JavaScript)\nDESCRIPTION: Demonstrates how to load a custom Graphile plugin (e.g., `MyPlugin` imported from './myPlugin.mjs') into a PostGraphile project using the `graphile.config.mjs` configuration file. The custom plugin is included in the `plugins` array within the default exported configuration object, enabling its functionality during schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/extending.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport MyPlugin from \"./myPlugin.mjs\";\n\nexport default {\n  // ...\n  plugins: [MyPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Granting PostgreSQL Roles - SQL\nDESCRIPTION: This SQL snippet grants the permissions of one role ('editor') to another ('admin'). The 'admin' role inherits all privileges from 'editor', and can optionally switch to the 'editor' role for the session. Dependencies: PostgreSQL installation. Parameters: Role names ('editor', 'admin'). Input: SQL command. Output: Roles updated in database with new hierarchy. No constraints beyond valid roles existing.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/default-role.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ngrant editor to admin;\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruru HTML Parts via Preset in TypeScript\nDESCRIPTION: This snippet demonstrates how to customize the HTML generated by Ruru server using a GraphileConfig Preset. It imports `defaultHTMLParts` and defines a preset object that modifies the `ruru.htmlParts` configuration, specifically setting a custom `titleTag` and appending a viewport meta tag to the default `metaTags`. This configuration is typically placed in a `graphile.config.ts` file.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { defaultHTMLParts } from \"ruru/server\";\n\nconst preset: GraphileConfig.Preset = {\n  //...\n  ruru: {\n    htmlParts: {\n      titleTag: \"<title>GraphiQL with Grafast support - Ruru!</title>\",\n      metaTags:\n        defaultHTMLParts.metaTags +\n        `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />`,\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Final Project Directory Structure with GraphQL Components\nDESCRIPTION: Displays the complete project directory structure after adding the `graphql` folder. This folder contains the Node.js application source files (`src/package.json`, `src/server.js`) and the `Dockerfile` specific to the GraphQL service, alongside the previously existing database components and configuration files.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ graphql/\n|  â”œâ”€ src/\n|  |  â”œâ”€ package.json\n|  |  â””â”€ server.js\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.15\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.15' of the 'grafast' package. This is typically found in changelogs or dependency management files.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.15\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema and Queries using Graphile-Utils with JavaScript\nDESCRIPTION: This snippet illustrates how to import 'gql' under two variable names to split schema definitions from query documents, helping avoid IntelliSense conflicts when working with custom schema extensions in Graphile projects. Dependencies are 'graphile-utils' and 'postgraphile'. The function defines new types using 'gqlExtend' and queries with 'gql'. Inputs are GraphQL type definitions and resolvers; the output is an extended PostGraphile plugin. Limitations arise from improper import usage or schema conflicts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// get gql as two different variables\nimport { makeExtendSchemaPlugin, gql, gql as gqlExtend } from \"graphile-utils\";\nimport { Build } from \"postgraphile\";\n\nexport const MyPlugin = makeExtendSchemaPlugin((build: Build) => {\n  const { graphql } = build;\n  return {\n    // use the \"gqlExtend\" template string here to extend your GraphQL API:\n    typeDefs: gqlExtend`\n      extend type Query {\n        myExtension: [String!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        myExtension: async (query, args, context, resolveInfo) => {\n          // use the normal \"gql\" template string to define your query inline:\n          const inlineDocument = gql`\n            query Query {\n              __typename\n              movies(first: 3) {\n                nodes {\n                  id\n                  title\n                }\n              }\n            }\n          `;\n\n          // continue with your code\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom OrderBy Plugin for Membership Name (V5, Graphile) - TypeScript\nDESCRIPTION: This V5 code snippet modernizes the membership name OrderBy plugin, updating structure and argument signature. The code now expects a build destructuring for 'sql', and the order spec callback accesses the Gra*fast* step object for generating fragments, with an explicit codec return. The result is a more composable and type-safe definition of custom ordering involving related table lookups. Dependencies remain on Graphile, its V5 API, and provided Table/schema names. All parameters are analogous to the V4 version.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"app_public\", tableName: \"organization_memberships\" },\n  ({ sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order spec callback:\n      ($organizationMemberships) => {\n        const fragment = sql.fragment`(\n          select ${sqlIdentifier}.name\n          from app_public.users as ${sqlIdentifier}\n          where ${sqlIdentifier}.id = ${$organizationMemberships.alias}.user_id\n          limit 1\n        )`;\n        return {\n          fragment,\n          codec: TYPES.text,\n        };\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client for Query Batching in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to configure Apollo Client to use query batching. It utilizes the `BatchHttpLink` from `apollo-link-batch-http` to send multiple GraphQL queries in a single HTTP request to a PostGraphile endpoint configured with `--enable-query-batching`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient } from \"apollo-client\";\nimport { BatchHttpLink } from \"apollo-link-batch-http\";\n\nconst link = new BatchHttpLink({ uri: \"/graphql\" });\n\nconst client = new ApolloClient({\n  link,\n  // other options like cache\n});\n```\n\n----------------------------------------\n\nTITLE: Registering GraphQL Object Type via Graphile Engine (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use the build object's registerObjectType method to define and register a custom GraphQL object type within the Graphile Engine. Dependencies include the build object (injected by Graphile) and the graphql library accessible via the build context; the constant function is also expected to be available in scope. Parameters include a type name ('MyType'), a scope object ({ isMyType: true }), a specification generator returning an object with a 'meaningOfLife' field (typed as GraphQLInt and resolves to 42), and a string describing the origin. The method enables plugins or users to introduce new hooked types with custom field plans.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build/build-object.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nbuild.registerObjectType(\n  \"MyType\",\n  { isMyType: true },\n  () => {\n    return {\n      fields: {\n        meaningOfLife: {\n          type: graphql.GraphQLInt,\n          plan() {\n            return constant(42);\n          },\n        },\n      },\n    };\n  },\n  \"MyType from MyPlugin\",\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Minimal PostGraphile V4 Bundling in JavaScript\nDESCRIPTION: This minimal Webpack configuration snippet provides basic settings for bundling a PostGraphile V4 application. It targets Node.js, requires setting the `context` to the application directory, configures `node.__dirname` to `true` for correct path resolution within the bundle relative to the original context, and uses the `externals` option to prevent bundling the native `pg-native` module, which is incompatible with Webpack bundling.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/bundling-webpack.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  // All your other webpack options:\n  // ...\n\n  // We're targetting node:\n  target: \"node\",\n\n  // CUSTOMIZE THIS!\n  context: `${__dirname}/app`,\n\n  // Update `__dirname` references to point to the correct location, relative to\n  // `context`:\n  // https://webpack.js.org/configuration/node/#node__dirname\n  node: {\n    __dirname: true,\n  },\n\n  // We cannot bundle native modules, so leave it out:\n  externals: [\"pg-native\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Inline Plugin Tweak to Modify GraphiQL Branding\nDESCRIPTION: This JavaScript snippet demonstrates how to apply an inline server plugin tweak when using PostGraphile as middleware. A plugin object (`graphiqlBrandingTweak`) is defined directly in the server setup code to hook into `postgraphile:graphiql:html`. It modifies the GraphiQL HTML output via string replacement to change the branding. This inline plugin is then passed to `makePluginHook` to integrate it into the PostGraphile middleware options.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n/**\n * This plugin override changes the branding piece of graphiql.\n * /\nconst graphiqlBrandingTweak = {\n  [\"postgraphile:graphiql:html\"](html) {\n    console.log(\"Applying GraphiQL Branding Tweak...\");\n    return html.replace(\n      \"</head>\",\n      '<style type=\"text/css\">div.topBar > div.title > div { visibility: hidden; display: none !important; } div.topBar > div.title::after { content: \"GraphiQL for MyCompany\" }</style></head>',\n    );\n  },\n};\nconst pluginHook = makePluginHook([graphiqlBrandingTweak]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Queries with `withPostGraphileContext` in JavaScript\nDESCRIPTION: Provides an example function `performQuery` for executing GraphQL queries against a generated PostGraphile schema. It uses `withPostGraphileContext` to wrap the execution, providing a properly configured context object containing a dedicated PostgreSQL client connection with appropriate transaction and role settings based on the provided options (like `pgPool`, `jwtToken`, `jwtSecret`, `pgDefaultRole`). The standard `graphql` function from the `graphql` library is used within the callback to perform the actual query execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst { Pool } = require('pg');\nconst { graphql } = require('graphql');\nconst { withPostGraphileContext } = require('postgraphile');\n\nconst myPgPool = new Pool({ ... });\n\nexport async function performQuery(\n  schema,\n  query,\n  variables,\n  jwtToken,\n  operationName\n) {\n  return await withPostGraphileContext(\n    {\n      pgPool: myPgPool,\n      jwtToken: jwtToken,\n      jwtSecret: \"...\",\n      pgDefaultRole: \"...\"\n    },\n    async context => {\n      // Execute your GraphQL query in this function with the provided\n      // `context` object, which should NOT be used outside of this\n      // function.\n      return await graphql(\n        schema, // The schema from `createPostGraphileSchema`\n        query,\n        null,\n        { ...context }, // You can add more to context if you like\n        variables,\n        operationName\n      );\n    }\n  );\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example SQL Context: json_build_object\nDESCRIPTION: Illustrates an example SQL function, json_build_object, where sql.literal might be appropriately used for its key arguments. The keys, if passed via sql.literal and deemed safe and simple by the library, could be inlined directly into the resulting SQL statement.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-literal.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\njson_build_object(key, val, key, val, ...)\n```\n\n----------------------------------------\n\nTITLE: Limiting Polymorphic Query Results using 'only' Argument in GraphQL\nDESCRIPTION: Example GraphQL query demonstrating the experimental 'only' argument added in version 5.0.0-beta.17. This argument allows limiting the types returned by polymorphic plans like `pgUnionAll()`, enhancing query precision. It requires a schema with relevant polymorphic types (e.g., `Application` with subtypes `GcpApplication`, `AwsApplication`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nallApplications(only: [GcpApplication, AwsApplication])\n```\n\n----------------------------------------\n\nTITLE: Defining Independent SQL Tables for GraphQL Union Membership\nDESCRIPTION: Creates two distinct tables, `polymorphic.people` and `polymorphic.organizations`, with no inherent schema relationship, intended to be grouped into a GraphQL union type using the `@unionMember` smart tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.people (\n  person_id serial primary key,\n  username text not null unique\n);\n\ncreate table polymorphic.organizations (\n  organization_id serial primary key,\n  name text not null unique\n);\n\n```\n\n----------------------------------------\n\nTITLE: Example Code Before graphile-export ESLint Autofix (TypeScript)\nDESCRIPTION: A TypeScript code snippet showing how a developer might initially wrap a function with `EXPORTABLE` before running the ESLint autofix. It only includes the factory function.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = EXPORTABLE(\n  () =>\n    function add(b) {\n      return a + b;\n    },\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Set-Returning Function for Searching Posts (SQL)\nDESCRIPTION: Creates a PostgreSQL function `search_posts` in the `forum_example` schema. It accepts a `search` text argument and returns a set of matching `forum_example.post` rows (`returns setof forum_example.post`). The matching condition checks if the search term exists within the post's `headline` or `body` using `position`. Marked `stable`, PostGraphile exposes this as a root query field returning a connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.search_posts(search text) returns setof forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where position(search in post.headline) > 0 or position(search in post.body) > 0\n$$ language sql stable;\n\ncomment on function forum_example.search_posts(text) is 'Returns posts containing a given search term.';\n```\n\n----------------------------------------\n\nTITLE: Inefficient SQL RLS Policy Check via Per-Row Function Call\nDESCRIPTION: Demonstrates an inefficient approach to RLS in PostgreSQL where a function (`current_user_is_member_of_organization`) is called for each row to check membership. This is discouraged due to potential performance issues, especially on large tables, as it prevents index optimization. The policy applies this function to the `posts` table using the `organization_id` column.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n-- Inefficient function, do not use!\ncreate function current_user_is_member_of_organization(org_id int)\nreturns bool as $$\n  select exists(\n    select 1\n    from organization_members om\n    where om.organization_id = current_user_is_member_of_organization.org_id\n    and om.user_id = current_user_id()\n  );\n$$ language sql stable;\n\n-- Poorly performing RLS policy that passes row data to a function, do not use!\ncreate policy select_my_organizations\n  for select on posts\n  using (current_user_is_member_of_organization(organization_id));\n```\n\n----------------------------------------\n\nTITLE: Importing Grafserv Adapters for Various Node.js Servers (JavaScript)\nDESCRIPTION: This code snippet lists how to import the appropriate Grafserv function based on your chosen Node.js web server framework. It presents four choices: Express, Node HTTP, Koa, and Fastify. The developer must ensure the correct subpath is imported to match their runtime server, and that the 'postgraphile' NPM package is available.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-library.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { grafserv } from \"postgraphile/grafserv/express/v4\";\n// OR: import { grafserv } from \"postgraphile/grafserv/node\";\n// OR: import { grafserv } from \"postgraphile/grafserv/koa/v2\";\n// OR: import { grafserv } from \"postgraphile/grafserv/fastify/v4\";\n```\n\n----------------------------------------\n\nTITLE: Serialized JWT Claims Applied in PostgreSQL - SQL\nDESCRIPTION: This SQL example shows how the claims from a given JWT payload are translated into PostgreSQL session commands. Each claim is set using the 'set local' directive, making them available only within the current transaction or session scope. String values are properly quoted, and numerical values are set without quotes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwt-guide.mdx#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nset local role user;\nset local jwt.claims.sub to 'postgraphql';\nset local jwt.claims.role to 'user';\nset local jwt.claims.user_id to 2;\n\n```\n\n----------------------------------------\n\nTITLE: Defining SQL Table Referencing Union Member Tables\nDESCRIPTION: Creates the `polymorphic.log_entries` table with foreign keys referencing `polymorphic.people` and `polymorphic.organizations`. A check constraint ensures that each log entry is associated with either a person or an organization, but not both. This table structure allows referencing the `PersonOrOrganization` union.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncreate table polymorphic.log_entries (\n  id serial primary key,\n  person_id int references polymorphic.people on delete cascade,\n  organization_id int references polymorphic.organizations on delete cascade,\n  text text not null,\n  constraint owned_by_person_or_organization check ((person_id is null) <> (organization_id is null))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function with Default (VOLATILE) Volatility\nDESCRIPTION: Demonstrates that creating a PostgreSQL function without explicitly specifying `VOLATILE`, `STABLE`, or `IMMUTABLE` results in a `VOLATILE` function by default. `VOLATILE` functions are assumed to have side effects or produce results that can change even within a single query. PostGraphile typically exposes certain `VOLATILE` functions as GraphQL mutations.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Enum Type (SQL)\nDESCRIPTION: This SQL snippet defines a custom enumeration type named `forum_example.post_topic` in PostgreSQL. It restricts the possible values for columns of this type to 'discussion', 'inspiration', 'help', or 'showcase', intended for categorizing forum posts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate type forum_example.post_topic as enum (\n  'discussion',\n  'inspiration',\n  'help',\n  'showcase'\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client for Pregenerated Persisted Queries using TypeScript\nDESCRIPTION: This TypeScript snippet shows how to configure Apollo Client to use persisted queries with pregenerated hashes. It imports `createPersistedQueryLink` from `apollo-link-persisted-queries` and a helper function `usePregeneratedHashes` along with the generated hashes from `client.json`. It then creates a persisted query link configured to use these pregenerated hashes and integrates it into the Apollo Client link chain.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createPersistedQueryLink } from \"apollo-link-persisted-queries\";\nimport { usePregeneratedHashes as withPregeneratedHashes } from \"graphql-codegen-persisted-query-ids/lib/apollo\";\nimport { hashes } from \"./path/to/client.json\";\n\nconst persistedLink = createPersistedQueryLink({\n  useGETForHashedQueries: false,\n  generateHash: withPregeneratedHashes(hashes),\n  disable: () => false,\n});\n\n// ...\n\nconst client = new ApolloClient({\n  link: ApolloLink.from([persistedLink, httpLink]),\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Computed Column for User's Primary Email - SQL\nDESCRIPTION: Implements a stable SQL function â€˜users_primaryEmail(u users)â€™, returning the current user's verified primary email if the supplied user input matches the logged-in user. The function cross-checks â€˜idâ€™ and email verification status, returning a single text result or null for non-matching cases. Relies on â€˜usersâ€™ and â€˜user_emailsâ€™ tables and â€˜current_user_id()â€™; input: user row (â€˜uâ€™), output: email or null.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n/*\n * Returns the primary email of the\n * current user; for all other users\n * this function will return null.\n */\ncreate function \"users_primaryEmail\"(u users)\nreturns text\nas $$\n  select email\n  from user_emails\n  where user_id = current_user_id()\n  and user_id = u.id\n  and is_verified is true\n  order by id asc\n  limit 1;\n$$ language sql stable set search_path from current;\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Using npm - Bash\nDESCRIPTION: Provides the CLI command to install PostGraphile (beta version) as a local dependency using npm. Requires Node.js and npm to be installed. Ensures that the package is only added to the local project, not globally, as per recommendation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save postgraphile@beta\n```\n\n----------------------------------------\n\nTITLE: Enhancing Schema using makeProcessSchemaPlugin in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `makeProcessSchemaPlugin` to enhance the generated GraphQL schema. It imports the function from `graphile-utils` and exports a plugin instance. The plugin takes a function that receives the `schema` object and is expected to return a modified schema, in this case by calling `addThirdPartyEnhancementsToSchema`. This is useful for integrating third-party tools or applying custom logic after schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-process-schema-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst { makeProcessSchemaPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeProcessSchemaPlugin((schema) => {\n  return addThirdPartyEnhancementsToSchema(schema);\n});\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Function Arguments Using Numeric Placeholders in SQL\nDESCRIPTION: Shows an alternative method to resolve argument/column name conflicts in PostgreSQL SQL functions. It uses positional numeric arguments (`$1`, `$2`, etc.) to refer to function parameters, clearly distinguishing them from table columns like `users.id`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = $1;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Generic GraphQL Subscription SQL Trigger Function (SQL)\nDESCRIPTION: This snippet defines a generic PostgreSQL PL/pgSQL trigger function, `tg__graphql_subscription`, which automates topic/payload construction and notification logic for subscription events. The function emits NOTIFY with a topic and event metadata any time a table row is inserted, updated, or deleted, and can dynamically substitute values in the topic string. Assumes primary key exists as 'id'. The function is meant to be attached to triggers for relevant tables. Requires PL/pgSQL and permission to create functions and triggers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/subscriptions.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION tg__graphql_subscription() RETURNS trigger\n    LANGUAGE plpgsql\n    AS $_$\ndeclare\n  v_process_new bool = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE');\n  v_process_old bool = (TG_OP = 'UPDATE' OR TG_OP = 'DELETE');\n  v_event text = TG_ARGV[0];\n  v_topic_template text = TG_ARGV[1];\n  v_attribute text = TG_ARGV[2];\n  v_record record;\n  v_sub text;\n  v_topic text;\n  v_i int = 0;\n  v_last_topic text;\nbegin\n  for v_i in 0..1 loop\n    if (v_i = 0) and v_process_new is true then\n      v_record = new;\n    elsif (v_i = 1) and v_process_old is true then\n      v_record = old;\n    else\n      continue;\n    end if;\n     if v_attribute is not null then\n      execute 'select $1.' || quote_ident(v_attribute)\n        using v_record\n        into v_sub;\n    end if;\n    if v_sub is not null then\n      v_topic = replace(v_topic_template, '$1', v_sub);\n    else\n      v_topic = v_topic_template;\n    end if;\n    if v_topic is distinct from v_last_topic then\n      -- This if statement prevents us from triggering the same notification twice\n      v_last_topic = v_topic;\n      perform pg_notify(v_topic, json_build_object(\n        'event', v_event,\n        'subject', v_sub,\n        /* highlight-next-line */\n        'id', v_record.id\n      )::text);\n    end if;\n  end loop;\n  return v_record;\nend;\n$_$;\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Plugin Build and Installation Pipeline - Dockerfile\nDESCRIPTION: Provides a Dockerfile to build a Node.js image for serving PostGraphile with a custom resolver plugin. It globally installs 'postgraphile' and its connection filter plugin, copies and packs the custom plugin for global installation, exposes port 5000, and sets the entrypoint to launch PostGraphile. The Docker build process expects the './custom-plugin' directory structure as shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_19\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Install PostGraphile and PostGraphile connection filter plugin\nRUN npm install -g postgraphile\nRUN npm install -g postgraphile-plugin-connection-filter\n\n# Install custom plugin\nCOPY ./custom-plugin /tmp/custom-plugin\nRUN cd /tmp/custom-plugin && npm pack\nRUN npm install -g /tmp/custom-plugin/custom-plugin-0.0.1.tgz\nRUN rm -rf /tmp/custom-plugin\n\nEXPOSE 5000\nENTRYPOINT [\"postgraphile\", \"-n\", \"0.0.0.0\"]\n```\n\n----------------------------------------\n\nTITLE: Conditionally Registering Numeric Types as Float by Precision and Scale - TypeScript\nDESCRIPTION: Registers PostgreSQL NUMERIC/DECIMAL columns as GraphQLFloat in the schema only if they fall below specified precision and scale limits (defaults: <=12 precision, <=2 scale), while leaving higher-precision fields as BigFloat. Intended as a safer, more selective alternative to global float coercion and uses PostGraphile's builder.hook and pgRegisterGqlTypeByTypeId API. Accepts optional configuration to customize precision and scale caps. Precision and scale modifiers are extracted from the PostgreSQL type modifier using bit operations as referenced. Requires PostGraphile, and expects to be module.imported in TypeScript/JavaScript projects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\\n * This plugin will have PostGraphile use `GraphQLFloat` instead of `BigFloat`\\n * for DECIMAL / NUMERIC values that have a precision and scale under the given\\n * limits (currently 12 and 2 respectively).\\n *\\n * It's generally a bad idea to use floating point numbers to represent\\n * arbitrary precision numbers such as NUMERIC because loss of precision can\\n * occur; however some systems are okay with this compromise.\\n */\\nmodule.exports = function PgSmallNumericToFloatPlugin(\\n  builder,\\n  { pgNumericToFloatPrecisionCap = 12, pgNumericToFloatScaleCap = 2 },\\n) {\\n  builder.hook(\\\"build\\\", (build) => {\\n    // Register a type handler for NUMERIC / DECIMAL (oid = 1700)\\n    build.pgRegisterGqlTypeByTypeId(\\\"1700\\\", (_set, modifier) => {\\n      if (modifier && typeof modifier === \\\"number\\\" && modifier > 0) {\\n        // Ref: https://stackoverflow.com/a/3351120/141284\\n        const precision = ((modifier - 4) >> 16) & 65535;\\n        const scale = (modifier - 4) & 65535;\\n        if (\\n          precision <= pgNumericToFloatPrecisionCap &&\\n          scale <= pgNumericToFloatScaleCap\\n        ) {\\n          // This number is no more precise than our cap, so we're declaring\\n          // that we can handle it as a float:\\n          return build.graphql.GraphQLFloat;\\n        }\\n      }\\n      // If all else fails, let PostGraphile do it's default handling - i.e.\\n      // BigFloat\\n      return null;\\n    });\\n\\n    // We didn't modify _init, but we still must return it.\\n    return build;\\n  });\\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Column Data from a `PgSelectSingleStep` in Gra*fast* (TypeScript)\nDESCRIPTION: Shows how to retrieve the value of a specific column (`organization_id`) from a `PgSelectSingleStep` (`$user`) using its `get()` method. This is a common pattern for accessing data from a row fetched via `resource.get()`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst $organizationId = $user.get(\"organization_id\");\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Plugin in PostGraphile Preset (TypeScript)\nDESCRIPTION: This configuration snippet imports a locally defined AddHttpBinPlugin and incorporates it as a plugin in the PostGraphile preset. This approach is required to extend the PostGraphile schema with custom plugins defined elsewhere in the project. It should be used in a graphile.config.mjs or equivalent configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending-raw.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport AddHttpBinPlugin from \"./add-http-bin-plugin.js\";\n\nexport default {\n  // ...\n  plugins: [AddHttpBinPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Views with PostGraphile (SQL)\nDESCRIPTION: This SQL snippet demonstrates how to create a table of films, then a view that filters only those with the 'Comedy' type. The 'comedies' view enables simplified querying for specific business logic. No special libraries are required, but this structure is intended for consumption by PostGraphile in a PostgreSQL database. Inputs are tables and view definitions; the output is a new view named 'comedies' constructed from the filtered table records. Ensure that the 'app_public' schema exists and that the PostGraphile process is connected.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/views.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table app_public.films (\n  id serial primary key,\n  name text,\n  release_year int,\n  kind text\n);\n\ncreate view comedies as\n    select *\n    from app_public.films\n    where kind = 'Comedy';\n```\n\n----------------------------------------\n\nTITLE: Minimal PostGraphile Configuration File (graphile.config.mjs) using JavaScript\nDESCRIPTION: Provides a minimal example of a `graphile.config.mjs` file using ES Module syntax. It imports the `PostGraphileAmberPreset` and exports a configuration object that extends this preset. Using this file allows running `npx postgraphile` without the `-P` flag. Requires the `postgraphile` package.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nexport default { extends: [PostGraphileAmberPreset] };\n```\n\n----------------------------------------\n\nTITLE: Using makePgSmartTagsFromFilePlugin with a JSON5 File (TypeScript)\nDESCRIPTION: This example shows how to import the makePgSmartTagsFromFilePlugin plugin generator, instantiate it by passing a file path to a smart tags configuration JSON5 file, and integrate it into a PostGraphile preset. The snippet demonstrates using the plugin alongside the PostGraphileAmberPreset for advanced or multi-file smart tags merging. Dependencies: 'postgraphile/utils', a valid smart tags JSON5 file at the specified path, and optionally a preset such as PostGraphileAmberPreset.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { makePgSmartTagsFromFilePlugin } from \"postgraphile/utils\";\n\n// highlight-start\nconst SmartTagsPlugin = makePgSmartTagsFromFilePlugin(\n  // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\n  \"/path/to/my/tags.file.json5\",\n);\n// highlight-end\n\nconst preset: GraphileConfig.Preset = {\n  extends: [PostGraphileAmberPreset],\n  plugins: [\n    // highlight-next-line\n    SmartTagsPlugin,\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating API Usage for connection() Utility - Diff\nDESCRIPTION: This diff snippet demonstrates the new usage of the connection() function, which now takes a configuration object as its second argument (instead of positional arguments). Developers updating to the new API should replace positional arguments with an object containing nodePlan and cursorPlan. This is a breaking change and affects any implementations using the previous argument structure. The change does not specify additional dependencies beyond what the original code required.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n```diff\\n-return connection($list, nodePlan, cursorPlan);\\n+return connection($list, { nodePlan, cursorPlan });\\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Foreign Key Virtual Constraint in JSON5 - JSON5\nDESCRIPTION: Defines a virtual foreign key relationship on a materialized view using JSON5 configuration. The 'foreignKey' tag provides the referencing and referenced columns for 'my_materialized_view'. This informs PostGraphile to treat the view as having those relationships, which aids in GraphQL schema linking but does not enforce constraints in the database. Inputs: referencing columns, target table, and columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_17\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Roles in PostgreSQL - SQL\nDESCRIPTION: Demonstrates how to grant an existing role (editor) to another role (admin) in PostgreSQL, allowing the admin role to inherit all the permissions and capabilities of the editor role. Requires PostgreSQL with both roles already created. Takes two role names as parameters: the role to grant and the role to receive. Grants all privileges of the source role to the target role.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/default-role.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ngrant editor to admin;\n\n```\n\n----------------------------------------\n\nTITLE: Embedding Ruru using HTML Bundle (HTML/JavaScript)\nDESCRIPTION: Integrates the Ruru interface into an HTML page using pre-built JavaScript and CSS bundles loaded from a CDN (unpkg.com). It initializes Ruru by creating a React element targeting the specified GraphQL endpoint (`/graphql`) and rendering it into a designated DOM container (`#ruru-root`). Optional Prettier integration for query formatting is also shown.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!-- optionally import Prettier for query formatting -->\n<script src=\"https://unpkg.com/prettier@1.13.0/standalone.js\"></script>\n<script src=\"https://unpkg.com/prettier@1.13.0/parser-graphql.js\"></script>\n<!-- Required below here -->\n<div id=\"ruru-root\"></div>\n<link href=\"https://unpkg.com/graphiql/graphiql.min.css\" rel=\"stylesheet\" />\n<script crossorigin src=\"https://unpkg.com/ruru/bundle/ruru.min.js\"></script>\n<script>\n  const { React, createRoot, Ruru } = RuruBundle;\n  const tree = React.createElement(Ruru, {\n    endpoint: \"/graphql\",\n  });\n  const container = document.getElementById(\"ruru-root\");\n  const root = createRoot(container);\n  root.render(tree);\n</script>\n```\n\n----------------------------------------\n\nTITLE: Using Multiple-Dependency Lambda Step Example in TypeScript\nDESCRIPTION: This example illustrates using the `lambda` step with multiple dependencies (`$a`, `$b`) by passing an array of these steps as the first argument. The callback function receives an array `[a, b]` containing the resolved values of `$a` and `$b` respectively, and returns their sum. The `isSyncAndSafe` flag is set to `true`, signifying that the addition operation is synchronous and safe.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Passing an array of steps gives you the values as an array:\nconst $aPlusB = lambda([$a, $b], ([a, b]) => a + b, true);\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing an Executor from PgExecutors Registry (TypeScript)\nDESCRIPTION: This snippet shows how to retrieve the default executor from the pgExecutors registry attached to the build.input object in a PostGraphile plugin. The executor is required for advanced or custom SQL query operations, such as withPgClient, and determines which database connection context is used. The executor must correspond to a configured PostgreSQL service.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst executor = build.input.pgRegistry.pgExecutors.main;\n```\n\n----------------------------------------\n\nTITLE: Live Query Subscription for User and Friends Updates in PostGraphile (GraphQL)\nDESCRIPTION: Illustrates the use of a GraphQL subscription (live query) to receive updates whenever the result set for users named \\\"Alice\\\" changes, including friend relationships. This example is experimental and depicts how PostGraphile's live queries can reactively push updates for any changes affecting the queried data. Requires PostGraphile with experimental live queries enabled and client support for the subscription operation. The query filters users by \\`firstName: \\\"Alice\\\"\\`, retrieving their id, name, and nested friends list; output is a full result set of affected users and their friends. Limitations include potentially high load for large queries, as the full results are recalculated and resent on any change.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/realtime.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allUsersList(condition: { firstName: \"Alice\" }) {\n    id\n    name\n    friendsList {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Argument-Based Data Generators using JavaScript\nDESCRIPTION: This snippet illustrates how to associate metadata based on the arguments passed to a field. Using `fieldWithHooks` for the 'connection' field, the `addArgDataGenerator` function is called. This generator function checks if the `first` argument is provided and, if so, returns an object `{ limit: [first] }`. This metadata can later be retrieved in the resolver to optimize the data fetching based on the provided arguments, such as applying a limit to a database query.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/look-ahead.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst MyObject = newWithHooks(GraphQLObjectType, {\n  name: \"MyObject\",\n  fields: ({ fieldWithHooks }) => {\n    return {\n      connection: fieldWithHooks(\"connection\", ({ addArgDataGenerator }) => {\n        addArgDataGenerator(function connectionFirst({ first }) {\n          /* highlight-start */\n          if (first) {\n            return { limit: [first] };\n          }\n        });\n        return {\n          type: ConnectionType,\n          /* highlight-end */\n          args: {\n            first: {\n              type: GraphQLInt,\n            },\n          },\n        };\n      }),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying Without SSH using GitHub Username with Yarn - Shell\nDESCRIPTION: This shell command deploys the built website by specifying the GitHub username via the GIT_USER environment variable and running Yarn's deploy script. It is a convenient alternative to SSH-based deployment and is suitable for users leveraging GitHub Pages for static hosting. Replace <Your GitHub username> with your actual GitHub handle before executing.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column using PostGraphile Tags File (JSON5)\nDESCRIPTION: Configures the `@deprecated` smart tag for a database attribute (column) named `my_column` within the `postgraphile.tags.json5` file. This adds a deprecation notice ('Use myOtherColumn instead.') to the corresponding field in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_3\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    attribute: {\n      my_column: {\n        tags: {\n          deprecated: \"Use myOtherColumn instead.\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing get() for Object Steps in Grafast (TypeScript)\nDESCRIPTION: This snippet illustrates how to implement the get() method on a Step subclass representing an object in Grafast. The method takes a string key and accesses the corresponding attribute using the access utility. It guarantees object-like step interaction per Grafast conventions. Key parameter: key (string). Output: step accessing the given attribute.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { access } from \"grafast\";\n\nclass MyObjectStep extends Step {\n  // ...\n\n  get(key) {\n    // Your step may implement a more optimized solution here.\n    return access(this, key);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Parsing PostgreSQL Introspection Results using pg-introspection and pg\nDESCRIPTION: This JavaScript code demonstrates how to use the `pg-introspection` library in conjunction with the `pg` Node.js module to retrieve and parse PostgreSQL database introspection data. It initializes a `pg` connection pool, generates the introspection SQL query using `makeIntrospectionQuery`, executes the query, and then parses the raw JSON result using `parseIntrospectionResults` to get a strongly-typed representation of the database schema. Finally, it logs the database name and the DBA's role name. Dependencies include `pg-introspection` and `pg` modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-introspection/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {\n  makeIntrospectionQuery,\n  parseIntrospectionResults,\n} from \"pg-introspection\";\nimport { Pool } from \"pg\";\n\nconst pool = new Pool({\n  connectionString: \"postgres://localhost:5432/my_database\",\n});\n\nasync function main() {\n  const sql = makeIntrospectionQuery();\n  const { rows } = await pool.query(sql);\n  // NOTE: The original example had a typo `row[0]`, corrected to `rows[0]`\n  const introspection = parseIntrospectionResults(rows[0].introspection);\n\n  console.log(\n    `The ${introspection.database.datname} DBA is ${\n      introspection.database.getDba()?.rolname ?? \"-\"\n    }`,\n  );\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining Tables in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet demonstrates creating a 'users' table with several fields, including an auto-increment 'id' using the 'serial' data type, a 'username' column enforced to match a specific regular expression, and timestamp fields with default current timestamp values. It requires a PostgreSQL environment with support for 'citext', regular expressions, and 'timestamptz' data types. Inputs are the column definitions; outputs are the resulting relational table structure created in the database. The code showcases constraints like 'primary key', 'unique', and 'check', and is suitable for initializing core user data storage.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/required-knowledge.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table users (\n  id serial primary key,\n  username citext not null unique check(username ~ '^[a-z][a-z0-9]+$'),\n  first_name text,\n  last_name text,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Route Plural Reference Using @ref and @refVia in PostGraphile (SQL)\nDESCRIPTION: This SQL snippet showcases how to define a plural reference with multiple route strings in PostGraphile by combining @ref and multiple @refVia smart tags in a table comment. The @ref tag establishes the reference name (here: 'relatedPeople') and type (to:Person), while each @refVia specifies an alternative route (e.g., 'via:book_authors;people' and 'via:book_editors;people'). Dependencies: join tables (book_authors, book_editors) with correct foreign key relations pointing to 'people'; PostGraphile. The resulting GraphQL schema exposes a field 'relatedPeople' aggregating entities from both routes. Plural is default; no singular specified.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/refs.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table books is $$\n  @ref relatedPeople to:Person\n  @refVia relatedPeople via:book_authors;people\n  @refVia relatedPeople via:book_editors;people\n  $$;\n```\n\n----------------------------------------\n\nTITLE: Extending Schema with @pgQuery for Object Type using graphile-utils in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to extend a PostGraphile schema using `makeExtendSchemaPlugin` from `graphile-utils`. It adds a `pets` field (returning a `PetsConnection`) to the `User` type. The `@pgQuery` directive is configured with a `source` (an SQL fragment representing the `app_public.pets` table) and a `withQueryBuilder` function to define the relationship between the user and their pets using SQL fragments and query builder aliases. This pattern allows fetching related records directly via SQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nconst { makeExtendSchemaPlugin, gql, embed } = require(\"graphile-utils\");\n\nmodule.exports = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type User {\n        pets: PetsConnection @pgQuery(\n          source: ${embed(sql.fragment`app_public.pets`)}\n          withQueryBuilder: ${embed((queryBuilder, args) => {\n            queryBuilder.where(\n              sql.fragment`${queryBuilder.getTableAlias()}.user_id = ${queryBuilder.parentQueryBuilder.getTableAlias()}.id`,\n            );\n          })}\n        )\n      }\n    `,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Resolver using makeWrapResolversPlugin (JavaScript)\nDESCRIPTION: This snippet showcases wrapping an existing resolver using `makeWrapResolversPlugin` (available in PostGraphile v4.1+). It targets the `email` field on the `User` type, calls the original resolver (`resolve`), and then modifies the result by converting it to lowercase before returning. Requires `graphile-utils`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    async email(resolve, source, args, context, resolveInfo) {\n      const result = await resolve();\n      return result.toLowerCase();\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server with Yarn (Shell)\nDESCRIPTION: Executes the `start` script defined in `package.json` (typically running `docusaurus start`). This command starts a local web server, opens the website in a default browser, and enables hot reloading for most code changes, facilitating development.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile Server Using CLI Bash Command\nDESCRIPTION: This Bash snippet provides the full CLI command for starting a PostGraphile server connected to the forum_example schema, specifying the connection string, schema, default role, JWT secret, and JWT token identifier. Dependencies include an initialized Postgres database with the schema and the PostGraphile CLI installed. The command expects environment values for database access and JWT configuration for authentication.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\\n  --connection postgres://forum_example_postgraphile:xyz@localhost \\\\n  --schema forum_example \\\\n  --default-role forum_example_anonymous \\\\n  --jwt-secret keyboard_kitten \\\\n  --jwt-token-identifier forum_example.jwt_token\n```\n\n----------------------------------------\n\nTITLE: Using makePgSmartTagsFromFilePlugin in PostGraphile with TypeScript\nDESCRIPTION: Demonstrates how to instantiate the `makePgSmartTagsFromFilePlugin` by providing the path to a smart tags configuration file (e.g., `tags.file.json5`). The resulting plugin (`SmartTagsPlugin`) is then added to the `appendPlugins` array in the PostGraphile middleware options.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst SmartTagsPlugin = makePgSmartTagsFromFilePlugin(\n  // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\n  \"/path/to/my/tags.file.json5\",\n);\n\n// ...\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, \"app_public\", {\n    //...\n    appendPlugins: [SmartTagsPlugin],\n  }),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a SETOF Function for GraphQL Connections in SQL\nDESCRIPTION: Shows how to create a PostgreSQL function that returns a set of rows using `RETURNS SETOF <type>`. This type of function is commonly used with PostGraphile to expose data as a paginated GraphQL connection, suitable for large result sets.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_17\n\nLANGUAGE: sql\nCODE:\n```\n-- Assuming we already have a table named `person`â€¦\ncreate function my_function(a int, b int) returns setof person as $$\n  â€¦\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Defining Update and Delete Row Level Policies for Users in Postgres SQL\nDESCRIPTION: This SQL snippet establishes RLS update and delete policies so that users with the forum_example_person role can only modify or remove their own person record, tied by id and JWT claims. The policies use current_setting to extract the person's ID from JWT claims and compare it to the row id. This constrains updates and deletions to self-owned records; prerequisite is that RLS is enabled and JWT claims are configured accordingly in the environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_40\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy update_person on forum_example.person for update to forum_example_person\\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\\n\\ncreate policy delete_person on forum_example.person for delete to forum_example_person\\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Querying a Set-Returning Function as a Connection (GraphQL)\nDESCRIPTION: Example GraphQL query demonstrating how to interact with the `searchPosts` root field generated by PostGraphile from the `forum_example.search_posts` set-returning SQL function. It shows passing a `search` argument and using connection arguments like `first: 5` for pagination to retrieve the first 5 matching posts, including their cursor and node data (headline, body).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  searchPosts(search: \"Hello, world!\", first: 5) {\n    edges {\n      cursor\n      node {\n        headline\n        body\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom PostGraphile Inflection Plugin (JavaScript)\nDESCRIPTION: This snippet provides a basic structure for a PostGraphile plugin that overrides a specific inflector ('patchType'). The plugin exports an object with required fields ('name', 'version') and defines a new implementation for the specified inflector under 'inflection.replace'. It expects the existence of PostGraphile's plugin system and replaces the inflector logic to return a customized type name. Dependencies include PostGraphile; key parameters are the previous inflector, resolved preset, and type name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/inflection.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default {\n  name: \"ReplacePatchTypeInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      patchType(previous, resolvedPreset, typeName) {\n        return this.upperCamelCase(`\\${typeName}-change-set\\`);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Plan to Use Custom add Step Instead of Lambda - TypeScript Diff\nDESCRIPTION: Shows the difference in plan code when switching from the lambda step to a custom add step for the addTwoNumbers field. The custom add step enhances maintainability and enables stronger optimization opportunities. This diff assumes the add helper is available in the current scope.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n const plans = {\n   Query: {\n     addTwoNumbers(_, args) {\n       const $a = args.get(\"a\");\n       const $b = args.get(\"b\");\n-      return lambda([$a, $b], ([a, b]) => a + b);\n+      return add($a, $b);\n     },\n   },\n };\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom PostGraphile Server Plugin in JavaScript\nDESCRIPTION: Provides a template structure for creating a custom PostGraphile server plugin. The plugin is an object exporting hook methods (like `cli:greeting`). Each hook receives the subject being modified and a context object, and should return the modified subject. The example demonstrates adding a custom message to the CLI greeting.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyPlugin = {\n  [\"cli:greeting\"](messages, { chalk }) {\n    return [...messages, `Hello ${chalk.blue(\"world\")}!`];\n  },\n};\n\nmodule.exports = MyPlugin;\n// or, for ES6 modules:\n// export default MyPlugin;\n```\n\n----------------------------------------\n\nTITLE: SQL: Adding Smart Comments to Views - SQL\nDESCRIPTION: This SQL snippet applies smart tags to a view using the same escape string constant method. It demonstrates renaming a view and specifying omitted operations. Dependencies: PostgreSQL. Input is a COMMENT targeting a view; output is a PostGraphile schema with customized names and permissions for that view.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-comments.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncomment on view my_schema.mv_view is\\n  E'@name my_new_view_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Disabling application/x-www-form-urlencoded with V4 Preset in Grafserv - TypeScript\nDESCRIPTION: This example demonstrates how to explicitly disable 'application/x-www-form-urlencoded' content type for a server using the V4 preset in Grafserv, thereby increasing security against CSRF. By setting 'grafserv.allowedRequestContentTypes' to DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES, support for the form-encoded requests is omitted. Requires importing from 'grafserv' and extending an appropriate preset. Intended for use cases requiring strict compliance with the GraphQL-over-HTTP specification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES } from \"grafserv\";\n\nconst preset: GraphileConfig.Preset = {\n  //... extends V4 preset ...\n\n  grafserv: {\n    //...\n\n    allowedRequestContentTypes: DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Customizing Field Nullability via a PostGraphile Plugin - JavaScript\nDESCRIPTION: This JavaScript snippet defines a PostGraphile plugin that forces all forward relation fields to be non-nullable in the generated GraphQL schema. It checks each field's context for being a forward relation and verifies that all key attributes are not-null, then wraps the type in GraphQLNonNull. Requires PostGraphile and the GraphQL.js library as dependencies and is intended as a custom extension loaded into the PostGraphile build process.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/why-nullable.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = function NonNullRelationsPlugin(builder) {\n  builder.hook(\"GraphQLObjectType:fields:field\", (field, build, context) => {\n    if (\n      !context.scope.isPgForwardRelationField ||\n      !context.scope.pgFieldIntrospection?.keyAttributes?.every(\n        (attr) => attr.isNotNull,\n      )\n    ) {\n      return field;\n    }\n    return {\n      ...field,\n      type: new build.graphql.GraphQLNonNull(field.type),\n    };\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Singular Ref with @ref in SQL\nDESCRIPTION: Demonstrates adding a singular ref named 'author' to the 'posts' table using a SQL comment and the `@ref` smart tag. The `via:(author_id)->people(id)` specifies that the local 'author_id' column relates to the 'id' column of the 'people' table. The `singular` keyword marks it as a one-to-one or many-to-one relationship.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/refs.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table posts is $$\n  @ref author via:(author_id)->people(id) singular\n  $$;`\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Query with `hookArgs` and Manual Steps in TypeScript\nDESCRIPTION: Demonstrates a more manual approach to GraphQL execution in TypeScript. It involves getting the schema, parsing the query source, validating the document, preparing execution arguments using `hookArgs()` (which builds the GraphQL context), and finally executing the request with `execute()`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport { parse, validate } from \"postgraphile/graphql\";\nimport { execute, hookArgs } from \"postgraphile/grafast\";\nimport preset from \"./graphile.config.js\";\n\n// Build a `pgl` instance, with helpers and schema based on our preset.\nconst pgl = postgraphile(preset);\n\n/**\n * Given a request context `requestContext`, GraphQL query text `source` and\n * optionally variable values and operation name, execute the given GraphQL\n * operation against our schema and return the result.\n */\nexport async function executeQuery(\n  requestContext: Partial<Grafast.RequestContext>,\n  source: string,\n  variableValues?: Record<string, unknown> | null,\n  operationName?: string,\n) {\n  // We might get a newer schema in \"watch\" mode\n  const { schema, resolvedPreset } = await pgl.getSchemaResult();\n\n  // Parse the GraphQL query text:\n  const document = parse(source);\n\n  // Validate the GraphQL document against the schema:\n  const errors = validate(schema, document);\n  if (errors.length > 0) {\n    return { errors };\n  }\n\n  // Prepare the execution arguments:\n  const args = await hookArgs({\n    schema,\n    document,\n    variableValues,\n    operationName,\n    resolvedPreset,\n    requestContext,\n  });\n\n  // Execute the request using Grafast:\n  return await execute(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Entities using Smart Comments in SQL\nDESCRIPTION: Demonstrates using SQL `COMMENT` statements with the `@name` smart tag to rename database objects in the PostGraphile schema. The `post` table is renamed to `message`, and the `search_posts` function is renamed to `returnPostsMatching`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table post is\n  E'@name message';\ncomment on function search_posts(text) is\n  E'@name returnPostsMatching';\n```\n\n----------------------------------------\n\nTITLE: Creating a PetsCount Condition Plugin in JavaScript (V4, graphile-utils)\nDESCRIPTION: This JavaScript snippet demonstrates the use of makeAddPgTableConditionPlugin from graphile-utils to implement a GraphQL input field ('petCountAtLeast') that filters users based on a minimum pet count. It specifies the SQL fragment to count pets associated with a user and its expected integration within the Graphile V4 framework. Dependencies include graphile-utils, the GraphQL implementation from the PostGraphile build object, and the relevant database schema (graphile_utils).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \\\"graphile-utils\\\";\\n\\nconst PetsCountPlugin = makeAddPgTableConditionPlugin(\\n  \\\"graphile_utils\\\",\\n  \\\"users\\\",\\n  \\\"petCountAtLeast\\\",\\n  (build) => ({\\n    description: \\\"Filters users to those that have at least this many pets\\\",\\n    type: build.graphql.GraphQLInt,\\n  }),\\n  (value, helpers, build) => {\\n    const { sqlTableAlias, sql } = helpers;\\n    return sql.fragment`(select count(*) from graphile_utils.pets where pets.user_id = ${sqlTableAlias}.id) >= ${sql.value(\\n      value,\\n    )}`;\\n  },\\n);\n```\n\n----------------------------------------\n\nTITLE: Updating .env for Database Connection\nDESCRIPTION: Shows how to update the `.env` file to include the `DATABASE_URL` environment variable. This variable provides the connection string PostGraphile uses to connect to the PostgreSQL database service (`db`) defined in Docker Compose. The format is `postgres://user:password@service_name:port/db_name`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n[...]\n# GRAPHQL\n# Parameters used by graphql container\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\n```\n\n----------------------------------------\n\nTITLE: Configuring @simpleCollections for Tables, Constraints, and Functions - SQL\nDESCRIPTION: These SQL code snippets apply the @simpleCollections smart comment to a table, a foreign key constraint, and a custom query function to configure collection exposure in the GraphQL schema generated by PostGraphile. The @simpleCollections both setting enables both Relay connections and simple lists for the annotated entity. Required dependencies include a PostgreSQL database and PostGraphile with smart comments interpretation enabled. Users supply standard SQL COMMENT ON commands; these modify how types and relationships are exposed in the GraphQL API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_26\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table email is\n  E'@simpleCollections both';\n```\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint email_user_id_fkey on email is\n  E'@simpleCollections both';\n```\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function search_people(query text) is\n  E'@simpleCollections both';\n```\n\n----------------------------------------\n\nTITLE: Orchestrating Services with Docker Compose - YAML\nDESCRIPTION: This docker-compose.yml defines a networked set of services centering on the 'forum-example-db' PostgreSQL database. It builds the image from the ./db context, mounts a named Docker volume for data persistence, uses environment variables from .env, exposes port 5432, connects to a custom network, and sets a restart policy. Inputs: local Dockerfile, .env file, init scripts. Outputs: repeatable service orchestration for local development. Must be run from the root of the repository.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_10\n\nLANGUAGE: yml\nCODE:\n```\nversion: \\\"3.3\\\"\\nservices:\\n  db:\\n    container_name: forum-example-db\\n    restart: always\\n    image: forum-example-db\\n    build:\\n      context: ./db\\n    volumes:\\n      - db:/var/lib/postgresql/data\\n    env_file:\\n      - ./.env\\n    networks:\\n      - network\\n    ports:\\n      - 5432:5432\\n\\nnetworks:\\n  network:\\n\\nvolumes:\\n  db:\n```\n\n----------------------------------------\n\nTITLE: Writing a PostGraphile Integration Test using Test Helpers in JavaScript\nDESCRIPTION: This JavaScript snippet illustrates how to write an integration test for a PostGraphile endpoint using the helper functions defined in `test_helper.ts`. It utilizes `beforeAll` and `afterAll` hooks (common in test frameworks like Jest) to call the `setup` and `teardown` functions from the helper module. The `test` function calls `runGraphQLQuery`, providing the GraphQL query string, variables, mock request options (e.g., simulating a logged-in user via `req.user`), and a `checker` callback function for performing assertions on the GraphQL response (`json`) and querying the database (`pgClient`) within the test transaction. It depends on the test helper module and a compatible test runner.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/testing-jest.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst { setup, teardown, runGraphQLQuery } = require(\"../test_helper\");\n\nbeforeAll(setup);\nafterAll(teardown);\n\ntest(\"GraphQL query nodeId\", async () => {\n  await runGraphQLQuery(\n    // GraphQL query goes here:\n    `{ __typename }`,\n\n    // GraphQL variables go here:\n    {},\n\n    // Any additional properties you want `req` to have (e.g. if you're using\n    // `pgSettings`) go here:\n    {\n      // Assuming you're using Passport.js / pgSettings, you could pretend\n      // to be logged in by setting `req.user` to `{id: 17}`:\n      user: { id: 17 },\n    },\n\n    // This function runs all your test assertions:\n    async (json, { pgClient }) => {\n      expect(json.errors).toBeFalsy();\n      expect(json.data.__typename).toEqual(\"Query\");\n\n      // If you need to, you can query the DB within the context of this\n      // function - e.g. to check that your mutation made the changes you'd\n      // expect.\n      const { rows } = await pgClient.query(\n        `SELECT * FROM app_public.users WHERE id = $1`,\n        [17],\n      );\n      if (rows.length !== 1) {\n        throw new Error(\"User not found!\");\n      }\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Plugin Hook to Middleware in Graphile Plugins - Diff\nDESCRIPTION: This code snippet, written in unified diff syntax, illustrates how to migrate a Graphile plugin definition from using the deprecated hooks.args API to the new middleware.prepareArgs structure. It uses a side-by-side diff to highlight changes in the configuration, including parameter destructuring and the requirement to call next(). It is intended to help developers update their plugins to be compatible with recent Graphile core and middleware improvements. No runtime dependencies are needed to interpret this diff snippet; it provides upgrade context only.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv/CHANGELOG.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n const plugin = {\n   grafast: {\n-    hooks: {\n+    middleware: {\n-      args({ args, ctx, resolvedPreset }) {\n+      prepareArgs(next, { args }) {\n+        const { requestContext: ctx, resolvedPreset } = args;\n           // ...\n+        return next();\n         }\n       }\n     }\n   }\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Unique Constraint via Smart Comment - SQL\nDESCRIPTION: Applies one or more unique constraints to a view through SQL comments using the '@unique' smart tag. Each constraint can target one or more columns, separated by newlines for multiple constraints. Prerequisite: view and columns must exist. This ensures uniqueness at the GraphQL layer in PostGraphile, but not in PostgreSQL itself.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_21\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on view my_view is E'@unique id\\n@unique org,slug';\n```\n\n----------------------------------------\n\nTITLE: Generated Minimal GraphQL Schema Without Node Interface - GraphQL SDL\nDESCRIPTION: This GraphQL schema definition illustrates the output when the NodePlugin is omitted during schema construction. The schema contains only the root Query type with a single field, demonstrating a highly simplified API surface suitable where Relay Node specification is unnecessary. The code is the SDL output, typically used as a reference or for documentation. No external dependencies are required to interpret the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/omitting-plugins.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n# The root query type which gives access points into the data universe.\ntype Query {\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n}\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile V5 via CLI\nDESCRIPTION: This example shows how to launch PostGraphile V5 from the command line using either `postgraphile` or its alias `pgl`. It specifies the 'amber' preset (`-P`), the database connection string (`-c`), the PostgreSQL schema to introspect (`-s`), and enables the explain feature (`-e`) for query analysis in tools like Ruru. This command relies on default settings for port and host unless overridden or specified in a `graphile.config.js` file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -P postgraphile/presets/amber -c postgres:///my_db_name -s public -e\n# or: pgl -P pgl/amber -c postgres:///my_db_name -s public -e\n```\n\n----------------------------------------\n\nTITLE: Annotating a Type with Smart Comments - SQL\nDESCRIPTION: This command sets smart tags and human-readable documentation on a user-defined PostgreSQL type using COMMENT ON TYPE. It is useful for customizing type names and comments exposed via PostGraphile's schema. Dependency is an existing type in the schema. Smart tags like @name can rename the GraphQL representation; the trailing text serves as documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncomment on type my_schema.my_type is\\n  E'@name my_new_type_name\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Replacing Generic 'record' Return Type in PostgreSQL Functions\nDESCRIPTION: Illustrates the `record` keyword in the context of the suggested solution. To make a function compatible with PostGraphile, its return type should be changed from the generic `record` to a specific, named composite type defined previously.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-restrictions.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nrecord\n```\n\n----------------------------------------\n\nTITLE: Applying Virtual @unique Constraints via SQL Comment\nDESCRIPTION: This snippet applies the '@unique' smart tag to a view using SQL comments to simulate unique constraints, with support for multiple constraints via newline separation. PostGraphile interprets these for GraphQL schema generation as primary keys or unique fields. Requires the view and columns to exist; uniqueness must be manually ensured in the data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_21\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on view my_view is E'@unique id\\n@unique org,slug';\n\n```\n\n----------------------------------------\n\nTITLE: Omitting Update/Delete Operations via @omit Smart Comment in SQL\nDESCRIPTION: Demonstrates creating a table `forum_example.book` and applying an `@omit` smart comment to exclude `update` and `delete` mutations from the GraphQL schema generated by PostGraphile. This comment is added directly to the table definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_25\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.book (\n  col1 int\n);\n\ncomment on table forum_example.book is E'@omit update,delete';\n```\n\n----------------------------------------\n\nTITLE: Querying Albums, Tracks and Genres - PostGraphile - GraphQL\nDESCRIPTION: This GraphQL query demonstrates a moderately complex data retrieval scenario, accessing nested relationships from albums to tracks and then to genres for a specific artistId. It fetches information for all albums by a particular artist, including nested track and genre fields. The query is used as an intermediate benchmark to test PostGraphileâ€™s handling of nested data structures. Inputs: a filtering condition specifying the artistId; outputs: albums with tracks and corresponding genre names. Dependency: PostGraphile mapping of PostgreSQL relationships. Limitation: assumes schema contains linked album, track, and genre tables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/performance.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nquery albums_tracks_genre_some {\n  allAlbumsList(condition: { artistId: 127 }) {\n    artistId\n    title\n    tracksByAlbumIdList {\n      trackId\n      name\n      genreByGenreId {\n        name\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot Testing a Remote GraphQL Schema with Jest and TypeScript\nDESCRIPTION: Demonstrates a Jest test using TypeScript that fetches a GraphQL schema from a remote URL (Pokemon API) via an introspection query. It uses `node-fetch` to make the request, `graphql` library functions (`getIntrospectionQuery`, `buildClientSchema`) to process the response, and then `expect(schema).toMatchSnapshot()` to compare the resulting `GraphQLSchema` object against a stored snapshot using the configured serializer.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport fetch from \"node-fetch\";\nimport {\n  getIntrospectionQuery,\n  IntrospectionQuery,\n  buildClientSchema,\n} from \"graphql\";\n\nconst getSchema = async (url: string) => {\n  const response = await fetch(url, {\n    method: \"POST\",\n    body: JSON.stringify({ query: getIntrospectionQuery() }),\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n  const result = await (response.json() as Promise<{\n    data: IntrospectionQuery;\n  }>);\n  return buildClientSchema(result.data);\n};\n\ntest(\"Pokemon GraphQL API has a consistent schema\", async () => {\n  const schema = await getSchema(\"https://graphql-pokemon.now.sh\");\n  expect(schema).toMatchSnapshot();\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Applying Transforms Before Lambda with applyTransforms in TypeScript\nDESCRIPTION: This example demonstrates the correct approach: using applyTransforms on the each-mapped step before passing it to lambda, ensuring that usernames is a resolved list of strings rather than a step proxy. It highlights how to safely compose functional steps where full resolution of input data is required by the downstream function, with dependencies similar to the previous example.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/applyTransforms.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $users = usersResource.find();\n$users.where(sql`${$users}.organization_name = 'Graphile'`);\nconst $untransformed = each($users, ($user) => $user.get(\"username\"));\n\n// Force the `listItem` transforms to be applied, so `lambda` can depend on the\n// transformed values.\nconst $usernames = applyTransforms($untransformed);\n\nreturn lambda(\n  $usernames,\n  (usernames) => `Hello ${usernames.join(\", \")}!`,\n  true,\n);\n```\n\n----------------------------------------\n\nTITLE: Controlling Middleware Execution Order in Graphile Config using `before`, `after`, `provides` (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates how to control the execution order of middleware for the same action (`bar`) across different plugins (`MyPlugin`, `OtherPlugin`). `MyPlugin` uses a plugin-level `before` constraint and a middleware-level `after` constraint for `bar`. `OtherPlugin` provides `featureB` for its `bar` middleware. These constraints ensure `OtherPlugin`'s `bar` middleware runs before `MyPlugin`'s `bar` middleware. The expected console output demonstrating this order is included as a comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/middleware.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const MyPlugin: GraphileConfig.Plugin = {\n  name: \"MyPlugin\",\n  // Plugins can have default order constraints at the plugin level and can\n  // override them at the middleware level.\n  // This states that by default, middleware in MyPlugin will be executed\n  // before any other plugins' middleware that provides 'featureA'.\n  before: [\"featureA\"],\n  libraryName: {\n    middleware: {\n      foo(next) {\n        // ... do something\n        return next();\n      },\n\n      bar: {\n        after: [\"featureB\"],\n        async callback(next) {\n          // Executed after middleware that provides 'featureB'\n          console.log(\"MyPlugin\");\n          try {\n            return await next();\n          } finally {\n            console.log(\"/MyPlugin\");\n          }\n        },\n      },\n    },\n  },\n};\n\nexport const OtherPlugin: GraphileConfig.Plugin = {\n  name: \"OtherPlugin\",\n  libraryName: {\n    middleware: {\n      bar: {\n        provides: [\"featureB\"],\n        async callback(next) {\n          console.log(\"OtherPlugin\");\n          try {\n            return await next();\n          } finally {\n            console.log(\"/OtherPlugin\");\n          }\n        },\n      },\n    },\n  },\n};\n\n/* Result of executing the `bar` action:\n\nOtherPlugin\nMyPlugin\n/MyPlugin\n/OtherPlugin\n\n*/\n```\n```\n\n----------------------------------------\n\nTITLE: Renaming Fields using @name Smart Tag\nDESCRIPTION: Demonstrates the `@name` smart tag, which can be used to rename a GraphQL field derived from a database object without altering the original database object's name. This is an alternative to database renaming or using inflection plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n@name\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using LRU Caching with @graphile/lru in JavaScript\nDESCRIPTION: This snippet demonstrates initializing an LRU cache using the @graphile/lru package in a Node.js environment. The code shows how to construct the cache, specify required and optional configuration options (such as maxLength and a dispose callback), and perform basic cache operations including set, get, and reset. Dependencies include the @graphile/lru package; the maxLength parameter is mandatory and must be an integer of at least 2, while the dispose callback is optional and provides hooks for when items are removed. Inputs are arbitrary key-value pairs, and outputs are stored and retrieved items; the example also includes a disposal log. The snippet assumes ES Module syntax and may require a Node.js environment that supports import statements.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lru/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport LRU from \"@graphile/lru\";\n\n// Construct an LRU cache\nconst lru = new LRU({\n  // Maximum number of items to store (required)\n  maxLength: 500, // Must be an integer at least 2\n\n  // Optional callback to handle when a value is removed (both when LRU becomes\n  // full and when LRU is reset)\n  dispose(key, value) {\n    console.log(`Disposing of key '${key}' with value '${inspect(value)}'`);\n  },\n});\n\nconst ANY_KEY_HERE = { foo: \"bar\" };\nconst ANY_VALUE_HERE = { randomNumber: () => 4 };\n// Store a value\nlru.set(ANY_KEY_HERE, ANY_VALUE_HERE);\n\n// Retrieve a value\nconst value = lru.get(ANY_KEY_HERE);\n\n// Clear the cache\nlru.reset();\n```\n\n----------------------------------------\n\nTITLE: Verifying PostgreSQL Connection - Bash\nDESCRIPTION: Demonstrates verifying a local PostgreSQL server connection using the psql CLI. The outputs show what happens when the default database does not exist and when the server is unreachable. Requires the PostgreSQL client to be installed. Output and errors indicate server and database status.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///\"\n\npsql: FATAL:  database \"username\" does not exist\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///\"\n\npsql: could not connect to server: Connection refused\n```\n\n----------------------------------------\n\nTITLE: Enabling Various PostGraphile Debug Logs via DEBUG Environment Variable (Bash/Shell)\nDESCRIPTION: These shell commands show how to enable multiple debug logs simultaneously in PostGraphile by setting the `DEBUG` environment variable. Using comma-separated namespaces like `graphile-build:warn,@dataplan/pg:*` provides detailed insights into schema building warnings and SQL execution, aiding in comprehensive debugging across different parts of the system. Examples are provided for Bash, Windows Console, and PowerShell.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/debugging.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# Bash (Linux, macOS, etc)\nexport DEBUG=\"graphile-build:warn,@dataplan/pg:*\"\npostgraphile -c postgres://...\n\n# Windows Console\nset DEBUG=graphile-build:warn,@dataplan/pg:* & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:DEBUG = \"graphile-build:warn,@dataplan/pg:*\"; postgraphile -c postgres://...\n```\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with Different Connection Strings - Bash\nDESCRIPTION: Presents multiple examples of launching the PostGraphile server with connection strings for local, SSL-secured, and remote databases. Key parameters include -c to specify the database URI; outputs are automatically served GraphQL endpoints accessible on localhost. Useful for adapting connection settings to different environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n# Connect to the `mydb` database within the local PostgreSQL server\\n$ postgraphile -c \\\"postgres:///mydb\\\"\\n\\n# Connect to a database that requires SSL/TLS\\n$ postgraphile -c \\\"postgres://securehost:5432/db?ssl=true\\\"\\n\\n# Connect to the `somedb` database within the PostgreSQL at somehost port 2345\\n$ postgraphile -c \\\"postgres://somehost:2345/somedb\\\"\\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing GraphQL Enum Name for Enum Table via Smart Comment (SQL)\nDESCRIPTION: Demonstrates applying a PostgreSQL `COMMENT ON TABLE` statement with the PostGraphile `@enum` and `@enumName` smart comments to an enum table (`animal_type`). This explicitly sets the name of the resulting GraphQL enum generated from this table to `TypeOfAnimal`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/enums.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table animal_type is E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Computed Column Function in PostgreSQL\nDESCRIPTION: Defines a PostgreSQL SQL function `person_full_name` that takes a `person` table row as input and returns the concatenated `given_name` and `family_name`. This function, adhering to PostGraphile naming conventions and marked `STABLE`, creates a `fullName` computed column field in the corresponding GraphQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/computed-columns.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION person_full_name(person person) RETURNS text AS $$\n  SELECT person.given_name || ' ' || person.family_name\n$$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Minimal Webpack Configuration for PostGraphile (V4 Context) in JavaScript\nDESCRIPTION: This JavaScript snippet shows a minimal Webpack configuration for bundling PostGraphile, primarily addressing `__dirname` resolution and excluding the native `pg-native` module. It targets Node.js, requires setting the `context` option, enables `node.__dirname`, and lists `pg-native` in `externals`. Note that this configuration originates from V4 documentation and might need adjustments for V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/bundling-webpack.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  // All your other webpack options:\n  // ...\n\n  // We're targetting node:\n  target: \"node\",\n\n  // CUSTOMIZE THIS!\n  context: `${__dirname}/app`,\n\n  // Update `__dirname` references to point to the correct location, relative to\n  // `context`:\n  // https://webpack.js.org/configuration/node/#node__dirname\n  node: {\n    __dirname: true,\n  },\n\n  // We cannot bundle native modules, so leave it out:\n  externals: [\"pg-native\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Explicitly Defining a VOLATILE SQL Function\nDESCRIPTION: Shows how to explicitly declare a SQL function as `VOLATILE`. This classification signifies that the function might modify data or have side effects, preventing certain optimizations and potentially allowing PostGraphile to expose it as a mutation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ â€¦ $$ LANGUAGE sql VOLATILE;\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting a GraphQL Schema to TypeScript Module using PostGraphile Plugin\nDESCRIPTION: Demonstrates how to use makeProcessSchemaPlugin to export a PostGraphile-generated GraphQL schema as a TypeScript module file. The snippet imports required helpers from 'postgraphile/utils' and 'graphile-export', defines ExportSchemaPlugin that writes the schema in SDL format to a file, and returns the schema unaltered. Key parameters are the schema object and file path, and dependencies include 'postgraphile/utils' and 'graphile-export'. This code is synchronous in registration, but the file export occurs asynchronously, and any errors are logged to the console.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-process-schema-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeProcessSchemaPlugin } from \"postgraphile/utils\";\nimport { exportSchema } from \"graphile-export\";\n\nconst ExportSchemaPlugin = makeProcessSchemaPlugin((schema) => {\n  exportSchema(schema, `${process.cwd()}/exported-schema.mjs`, {\n    mode: \"typeDefs\",\n  }).catch((e) => {\n    console.error(e);\n  });\n  return schema;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Table with Specific Foreign Key Naming Convention (SQL)\nDESCRIPTION: This SQL snippet defines a `posts` table with a foreign key `author_id` referencing a `users` table. Naming the foreign key with an `_id` suffix (like `author_id`) allows the `@graphile/simplify-inflection` preset to infer a more specific relationship name ('author') rather than the default based on the referenced table ('user').\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE posts (\n  id serial primary key,\n  author_id int not null references users,\n  ...\n);\n```\n\n----------------------------------------\n\nTITLE: Hooking GraphQL Object Type Construction for Logging - JavaScript\nDESCRIPTION: This example demonstrates the use of SchemaBuilder's hook method by registering a plugin that logs the creation of every GraphQLObjectType. The GraphQLObjectTypeLogNamePlugin function attaches a hook, and logs each type's name as it\\'s constructed. Depends on builder exposed by the Graphile build pipeline. No direct input arguments except for the builder; outputs log messages to the console when new object types are created.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/schema-builder.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nfunction GraphQLObjectTypeLogNamePlugin(builder) {\n  builder.hook(\"GraphQLObjectType\", (spec) => {\n    console.log(\n      \"A new GraphQLObjectType is being constructed with name: \",\n      spec.name,\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with orderBy Enabled by @sortable in GraphQL\nDESCRIPTION: Illustrates how functions annotated with `@sortable` in SQL can be queried in GraphQL. It shows using the `orderBy` argument on fields derived from `SETOF` functions (like `foo`) and using computed column functions returning scalars as sorting criteria (`FOO_ASC`) within the `orderBy` argument of the parent type's query (`allUsers`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_31\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(orderBy: [ID_ASC]) { ... }\n  user(nodeId: ...) {\n    foo(orderBy: [ID_ASC]) { ... }\n  }\n\n  # If the function return a scalar\n  allUsers(orderBy: [FOO_ASC]) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT in PostGraphile - TypeScript\nDESCRIPTION: This TypeScript configuration file sets up PostGraphile with JWT support by extending necessary presets and defining relevant options. The 'pgJwtTypes' setting enables JWT serialization from a specific composite type, and the 'pgJwtSecret' is required to sign tokens. The configuration also demonstrates how to alter Postgres settings for the request context, allowing JWTs to influence session parameters. Requires the 'postgraphile' NPM package and valid schema/type definitions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \\\"postgraphile/presets/amber\\\";\\n// highlight-next-line\\nimport { PgLazyJWTPreset } from \\\"postgraphile/presets/lazy-jwt\\\";\\n\\nexport default {\\n  extends: [\\n    PostGraphileAmberPreset,\\n    // highlight-next-line\\n    PgLazyJWTPreset,\\n  ],\\n  gather: {\\n    // highlight-next-line\\n    pgJwtTypes: \\\"forum_example.jwt_token\\\",\\n  },\\n  schema: {\\n    // highlight-next-line\\n    pgJwtSecret: \\\"keyboard_kitten\\\", // REPLACE THIS!\\n  },\\n  grafast: {\\n    context(requestContext, args) {\\n      return {\\n        pgSettings: {\\n          role: \\\"forum_example_anonymous\\\",\\n          // highlight-start\\n          // JWT may override the role:\\n          ...args.contextValue?.pgSettings,\\n          // highlight-end\\n        },\\n      };\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Extending Hook Scope Graphile V5 TypeScript\nDESCRIPTION: Illustrates extending a specific hook's scope type using TypeScript declaration merging. This example adds an optional property `isRootNodeField` to the `ScopeObjectFieldsField` interface, which corresponds to the scope object passed to the `GraphQLObjectType_fields_field` hook. This allows plugins to safely add and access custom data within specific hook contexts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n  namespace GraphileBuild {\n    interface ScopeObjectFieldsField {\n      isRootNodeField?: boolean;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile Server with Connection String (Bash)\nDESCRIPTION: This command demonstrates starting the PostGraphile server. It specifies the connection string to connect as the `forum_example_postgraphile` user with password `xyz` to the `mydb` database. PostGraphile will likely load configuration, including the default role setting, from a configuration file like `graphile.config.mjs` if present in the project.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://forum_example_postgraphile:xyz@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile Plugin Behavior (Function, JS)\nDESCRIPTION: This JavaScript code snippet demonstrates an alternative way to define the `FavourListsPlugin`. Instead of a static string, `schema.globalBehavior` is a function. This function receives the `currentBehavior` string and returns an array `[\"-connection +list\", currentBehavior]`. This ensures the plugin's behavior (`\"-connection +list\"`) is prepended, allowing user-defined `defaultBehavior` in the main configuration to override the plugin's settings, thus maintaining flexibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst FavourListsPlugin = {\n  name: \"FavourListsPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    globalBehavior(currentBehavior, resolvedPreset) {\n      return [\"-connection +list\", currentBehavior];\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Adding `updated_at` Column to Tables in PostgreSQL\nDESCRIPTION: Alters the `forum_example.person` and `forum_example.post` tables using the `ALTER TABLE` command to add an `updated_at` timestamp column. This column defaults to the current timestamp (`now()`) upon row creation, similar to a `created_at` column, and is intended to be updated later by a trigger on row updates.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_17\n\nLANGUAGE: sql\nCODE:\n```\nalter table forum_example.person add column updated_at timestamp default now();\nalter table forum_example.post add column updated_at timestamp default now();\n```\n\n----------------------------------------\n\nTITLE: Altering Tables to Add Timestamp Columns - PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates how to add an 'updated_at' timestamp column with a default value of 'now()' to two existing tables in the 'forum_example' schema. This operation requires the target tables ('forum_example.person' and 'forum_example.post') and the correct permissions to alter table structures. The 'updated_at' column will record the last modified time for each row, similar to the existing 'created_at' timestamp. The queries must be executed by a user with ALTER TABLE privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_17\n\nLANGUAGE: SQL\nCODE:\n```\nalter table forum_example.person add column updated_at timestamp default now();\nalter table forum_example.post add column updated_at timestamp default now();\n```\n\n----------------------------------------\n\nTITLE: Querying a Table for a Unique Row using Resource.get (TypeScript)\nDESCRIPTION: This snippet retrieves a single row from a Grafast resource by unique constraint, using the users resource's get method. The key parameter is an object representing a unique column (here 'id'), typically resolved from the context or parent step. The output is a PgSelectSingleStep instance, suitable for field resolvers expecting 1:1 relations or lookups.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $user = users.get({ id: $userId });\n//    ^ PgSelectSingleStep - represents a single row\n```\n\n----------------------------------------\n\nTITLE: Running a Custom Search Query via GraphQL - GraphQL\nDESCRIPTION: Shows a GraphQL query that invokes the 'searchPosts' custom query, passing a search string and limiting results using the 'first' argument for pagination. Results return pageInfo, totalCount, and nodes with post headlines and bodies. Requires the corresponding 'search_posts' PostgreSQL function and proper PostGraphile schema setup. Inputs are 'search' and pagination arguments; the output is a connection with matching posts. May not perform efficiently on large datasets if not indexed or internally limited.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/custom-queries.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  searchPosts(search: \"Hello world\", first: 5) {\n    pageInfo {\n      hasNextPage\n    }\n    totalCount\n    nodes {\n      headline\n      body\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @primaryKey via SQL Comment - Single and Composite Keys\nDESCRIPTION: This SQL snippet adds a '@primaryKey' smart tag to a view, indicating which column(s) constitute the primary key for use in GraphQL. For single-column, use '@primaryKey id'; for composite, list comma-separated columns. PostGraphile uses this to assign the entity's unique identifier field. Prerequisite: the referenced view or table must exist. No checking of actual database uniqueness is enforced by this tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_16\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on view my_view is E'@primaryKey id';\n-- or\ncomment on view my_view is E'@primaryKey type,identifier';\n\n```\n\n----------------------------------------\n\nTITLE: Checking Entity Behavior in Schema Hook (Old Method) - TypeScript\nDESCRIPTION: Demonstrates the previous approach for checking the behavior of a PostgreSQL relation within a `GraphQLObjectType_fields_field` hook. It required manually defining default behavior, fetching user-specified behavior using `getBehavior` from various extension sources, and then checking the combined behavior using `build.behavior.matches`. This method was considered complex and potentially inconsistent across plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n\n  // Establish a default behavior, e.g. you might give it different default behavior\n  // depending on if the remote table is in the same schema or not\n  const defaultBehavior = someCondition(relation) ? \"behavior_if_true\" : \"behavior_if_false\";\n\n  // Now establish the user-specified behavior for the entity, inheriting from all the\n  // relevant places.\n  const behavior = getBehavior([\n    relation.remoteResource.codec.extensions,\n    relation.remoteResource.extensions,\n    relation.extensions\n  ]);\n\n  // Finally check this behavior string against `behavior_to_test`, being sure to apply\n  // the \"schema-time smart defaulting\" that we established in `defaultBehavior` above.\n  if (build.behavior.matches(behavior, \"behavior_to_test\", defaultBehavior)) {\n    doTheThing();\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Envelop with useGrafast Plugin in TypeScript\nDESCRIPTION: Demonstrates how to initialize the Envelop plugin system to work with a Grafast schema. It includes essential plugins like `useSchema` to provide the schema, `useParserCache` and `useValidationCache` for performance optimization (critical for Grafast), `useExtendContext` for context setup, and `useGrafast` which replaces the standard graphql-js executor with Grafast's execution engine. Requires `@envelop/core`, `grafast/envelop`, and a defined `schema`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/servers.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { envelop, useExtendContext, useSchema } from \"@envelop/core\";\nimport { useGrafast, useMoreDetailedErrors } from \"grafast/envelop\";\nimport { schema } from \"./schema\";\n\nconst getEnveloped = envelop({\n  plugins: [\n    // Use our executable schema\n    useSchema(schema),\n\n    // Caching the parser results is critical for Grafast, otherwise it\n    // must re-plan every GraphQL request!\n    useParserCache(),\n    // And we might as well cache validation whilst we're at it:\n    useValidationCache(),\n\n    // Pass your GraphQL context here:\n    useExtendContext(() => ({\n      /* ... */\n    })),\n\n    // This replaces graphql-js' `execute` with Grafast's own\n    useGrafast(),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding PostGraphile Inflection with a Custom Plugin (JavaScript)\nDESCRIPTION: This JavaScript snippet shows an example PostGraphile plugin created using `makeAddInflectorsPlugin`. The plugin overrides the `patchType` inflector to modify how certain type names are generated in the GraphQL schema. Specifically, it appends '-change-set' to the UpperCamelCase version of the original type name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/inflection.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = makeAddInflectorsPlugin(\n  {\n    patchType(typeName: string) {\n      return this.upperCamelCase(`${typeName}-change-set`);\n    },\n  },\n  true,\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Root Query with External Data using makeExtendSchemaPlugin (PostGraphile, TypeScript)\nDESCRIPTION: This snippet defines a plugin using PostGraphile's makeExtendSchemaPlugin utility to add a new root Query field (httpBinHeaders) that fetches JSON data from https://httpbin.org/headers. It requires the postgraphile/utils module and node-fetch as dependencies. The type definition for the new field is declared with gql, and the resolver is an asynchronous function returning the remote JSON response. The exported default can be integrated directly into a PostGraphile plugin list. All code is written in TypeScript.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending-raw.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\nimport fetch from \"node-fetch\";\n\nexport default makeExtendSchemaPlugin({\n  typeDefs: gql`\n    extend type Query {\n      httpBinHeaders: JSON\n    }\n  `,\n  resolvers: {\n    Query: {\n      async httpBinHeaders() {\n        const response = await fetch(\"https://httpbin.org/headers\");\n        return response.json();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Custom Step Execution Methods in Graphile Crystal (TypeScript)\nDESCRIPTION: This snippet demonstrates the updated signature for the async execute method in custom ExecutableStep classes. It changes the function parameters from positional (count, values, extra) to a single destructured object (ExecutionDetails) and explains how to process dependencies with batching logic. The update allows for more extensible and maintainable step execution while ensuring backward compatibility until the old signature is deprecated. Inputs include the new ExecutionDetails object, and the expected output is the result of the step's execution logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- async execute(count: number, values: any[][], extra: ExecutionExtra) {\\n+ async execute({ count, values: newValues, extra }: ExecutionDetails) {\\n+   const values = newValues.map((dep) =>\\n+     dep.isBatch ? dep.entries : new Array(count).fill(dep.value)\\n+   );\\n    // REST OF YOUR FUNCTION HERE\\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Quiz Mutation Inputs and Patches - GraphQL - GraphQL\nDESCRIPTION: These GraphQL input and patch types specify the data required for mutations on Quiz entities. 'QuizInput' is used for creating or replacing quiz records, accepting various attributes including name, updatedAt, and precision fields of type BigFloat. 'QuizPatch' allows for partial updates to only the supplied fields. Dependencies include custom scalar types like Datetime and BigFloat. Expected inputs are structured per GraphQL object notation, and creation requires the name field. Limitations: adherence to type requirements and providing necessary fields on creation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"An input for mutations affecting `Quiz`\"\"\"\ninput QuizInput {\n  id: Int\n  name: String!\n  updatedAt: Datetime\n  precision12Scale2: BigFloat\n  precision200Scale100: BigFloat\n}\n\n\"\"\"Represents an update to a `Quiz`. Fields that are set will be updated.\"\"\"\ninput QuizPatch {\n  id: Int\n  name: String\n  updatedAt: Datetime\n  precision12Scale2: BigFloat\n  precision200Scale100: BigFloat\n}\n```\n\n----------------------------------------\n\nTITLE: Defining makeWrapPlansPlugin Signatures and Rule Interfaces in TypeScript\nDESCRIPTION: This snippet outlines the type-level API surface for makeWrapPlansPlugin. It details two overloads for wrapping field resolvers: one using direct rules/generators and the other using filter/rule function pairs. The associated interfaces specify the required structure for rules and wrapper functions, dictating how users provide custom logic when wrapping resolvers. Dependencies include GraphileConfig, GraphileBuild, and Grafast-related types. This type definition supports extension and validation of resolver customization logic across the API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Method 1: wrap individual resolvers of known fields\\nfunction makeWrapPlansPlugin(\\n  rulesOrGenerator: PlanWrapperRules | PlanWrapperRulesGenerator,\\n): GraphileConfig.Plugin;\\n\\ninterface PlanWrapperRules {\\n  [typeName: string]: {\\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\\n  };\\n}\\n\\ninterface PlanWrapperRule {\\n  plan?: PlanWrapperFn;\\n}\\n\\ntype PlanWrapperFn = (\\n  plan: SmartFieldPlanResolver,\\n  $source: ExecutableStep,\\n  fieldArgs: FieldArgs,\\n  info: FieldInfo,\\n) => any;\\n\\ntype PlanWrapperRulesGenerator = (\\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\\n) => PlanWrapperRules;\\n\\n/****************************************/\\n\\n// Method 2: wrap all resolvers that match a filter function\\nfunction makeWrapPlansPlugin<T>(\\n  filter: (\\n    context: GraphileBuild.ContextObjectFieldsField,\\n    build: GraphileBuild.Build,\\n    field: GrafastFieldConfig,\\n  ) => T | null,\\n  rule: (match: T) => PlanWrapperRule | PlanWrapperFn,\\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Configuring Recommended PostGraphile Options for Development in JavaScript\nDESCRIPTION: This snippet provides a recommended set of PostGraphile options (`postgraphileOptions`) suitable for a development environment. It enables features like real-time updates (`subscriptions`, `watchPg`), enhanced JSON support (`dynamicJson`), detailed error reporting (`showErrorStack`, `extendedErrors`), schema exportation (`exportGqlSchemaPath`), the GraphiQL interface (`graphiql`, `enhanceGraphiql`), query explain (`allowExplain`), and query batching (`enableQueryBatching`). It also includes the `pg-simplify-inflector` plugin and uses modern relation naming (`legacyRelations: 'omit'`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nconst postgraphileOptions = {\n  subscriptions: true,\n  watchPg: true,\n  dynamicJson: true,\n  setofFunctionsContainNulls: false,\n  ignoreRBAC: false,\n  showErrorStack: \"json\",\n  extendedErrors: [\"hint\", \"detail\", \"errcode\"],\n  appendPlugins: [require(\"@graphile-contrib/pg-simplify-inflector\")],\n  exportGqlSchemaPath: \"schema.graphql\",\n  graphiql: true,\n  enhanceGraphiql: true,\n  allowExplain(req) {\n    // TODO: customise condition!\n    return true;\n  },\n  enableQueryBatching: true,\n  legacyRelations: \"omit\",\n  pgSettings(req) {\n    /* TODO */\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Single Row SQL Function for Current User (SQL)\nDESCRIPTION: This SQL snippet defines the function 'current_user', returning a single row from 'app_public.users' based on the current user's ID. The function is marked stable and utilizes a custom user ID lookup. It populates the 'currentUser' field in GraphQL, requiring that 'current_user_id()' exists and returning the entire user row matching the current session or context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncreate function current_user()\nreturns app_public.users\nlanguage sql stable\nas $$\n  select users.*\n  from app_public.users\n  where id = current_user_id();\n$$;\n```\n\n----------------------------------------\n\nTITLE: Replacing an Inflector in a Graphile V5 Plugin (TypeScript)\nDESCRIPTION: Demonstrates how to replace an existing inflector (`allRowsConnection`) in a Graphile V5 plugin. The example conditionally provides a custom name for the 'people' resource, falling back to the previous implementation (`prev`) for others. It also uses `ignoreReplaceIfNotExists` to prevent warnings if the inflector being replaced doesn't exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport const PgAllThePeoplePlugin: GraphileConfig.Plugin = {\n  name: \"PgAllThePeoplePlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    replace: {\n      allRowsConnection(prev, options, resource) {\n        return resource.name === \"people\" ? `allThePeople` : prev!(resource);\n      },\n      ignoreReplaceIfNotExists: [\"allRowsConnection\"],\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Smart Tags on Virtual Constraints via JSON5 (with @fieldName example)\nDESCRIPTION: This JSON5 snippet demonstrates attaching an additional smart tag (@fieldName) to a virtual foreign key by appending '|@fieldName field_1' to the foreign key definition. PostGraphile parses this metadata for GraphQL schema customization (e.g., renaming relationship fields). Dependencies are PostGraphile and JSON5 smart tags. Inputs are a class/view name and key specification with custom field naming.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_22\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)|@fieldName field_1\",\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Preset in Graphile Config File (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to integrate the `PgSimplifyInflectionPreset` into a Graphile configuration file (e.g., `graphile.config.mjs`). It demonstrates adding the preset to the `extends` array and includes comments showing how to optionally configure specific behaviors like omitting list suffixes (`pgOmitListSuffix`), simplifying patch field names (`pgSimplifyPatch`), simplifying root collection names (`pgSimplifyAllRows`), and modifying primary key field names (`pgShortPk`).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// graphile.config.mjs or similar\n\nimport { PgSimplifyInflectionPreset } from \"@graphile/simplify-inflection\";\n\nexport default {\n  extends: [\n    // ... (PostGraphileAmber, etc)\n    PgSimplifyInflectionPreset,\n  ],\n\n  schema: {\n    // ...\n    /*\n     * Uncomment if you want simple collections to lose the 'List' suffix\n     * (and connections to gain a 'Connection' suffix).\n     */\n    //pgOmitListSuffix: true,\n    /*\n     * Uncomment if you want 'userPatch' instead of 'patch' in update\n     * mutations.\n     */\n    //pgSimplifyPatch: false,\n    /*\n     * Uncomment if you want 'allUsers' instead of 'users' at root level.\n     */\n    //pgSimplifyAllRows: false,\n    /*\n     * Uncomment if you want primary key queries and mutations to have\n     * `ById` (or similar) suffix; and the `nodeId` queries/mutations\n     * to lose their `ByNodeId` suffix.\n     */\n    // pgShortPk: false,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming Foreign Key Field with SQL Smart Comment\nDESCRIPTION: This SQL snippet demonstrates how to use a PostGraphile smart comment on a foreign key constraint (`beverages_distributor_id_fkey`) to override the default generated field name. It renames the field derived from `distributor_id` on the `Company` type to `distributedBeverages` instead of the default `beveragesByDistributorId`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint \"beverages_distributor_id_fkey\" on \"beverages\" is\n  E'@foreignFieldName distributedBeverages';\n```\n\n----------------------------------------\n\nTITLE: Adding Configuration Option Graphile V5 TypeScript\nDESCRIPTION: Shows how to define a custom configuration option (`pgArchivedDefault`) for a Graphile V5 plugin. It uses TypeScript declaration merging to add the option to the `GraphileBuild.SchemaOptions` interface. Including a JSDoc comment provides documentation that can be picked up by tools like `graphile config options`. Plugins would typically access this option via `build.options` within their hooks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n  namespace GraphileBuild {\n    interface SchemaOptions {\n      /**\n       * The default option to use for the 'includeArchived' argument. Defaults to\n       * 'INHERIT' where feasible and 'NO' otherwise.\n       */\n      pgArchivedDefault?: \"INHERIT\" | \"NO\" | \"YES\" | \"EXCLUSIVELY\";\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting an Object Step Type Programmatically in TypeScript\nDESCRIPTION: Shows how to enforce that a GraphQL object type ('MyObject') must be represented by a specific Grafast step type (`ObjectStep`) when building the schema programmatically. This is done using the `extensions.grafast.assertStep` property on the `GraphQLObjectType` config. Both direct class assignment and a custom assertion function are shown as options. A sample field plan resolver demonstrates accessing methods on the asserted step type.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-resolvers.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { GraphQLObjectType } from \"graphql\";\nimport { ObjectStep } from \"grafast\";\n\nconst MyObject = new GraphQLObjectType({\n  name: \"MyObject\",\n  extensions: {\n    grafast: {\n      assertStep: ObjectStep,\n      /* Or:\n        assertStep($step) {\n          if ($step instanceof ObjectStep) return;\n          throw new Error(`Type 'MyObject' expects a step of type ObjectStep; instead received a step of type '${$step.constructor.name}'`);\n        }\n       */\n    },\n  },\n  fields: {\n    a: {\n      extensions: {\n        grafast: {\n          plan($obj: ObjectStep) {\n            return $obj.get(\"a\");\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating PostGraphile Dockerfile\nDESCRIPTION: Defines a Docker image for the PostGraphile service based on the official `node:alpine` image. It installs `postgraphile` and the `postgraphile-plugin-connection-filter` plugin globally using npm. It exposes port 5000 (though the compose file maps a different port later) and sets the entry point to run `postgraphile` listening on all network interfaces (`0.0.0.0`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_13\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Install PostGraphile and PostGraphile connection filter plugin\nRUN npm install -g postgraphile\nRUN npm install -g postgraphile-plugin-connection-filter\n\nEXPOSE 5000\nENTRYPOINT [\"postgraphile\", \"-n\", \"0.0.0.0\"]\n```\n\n----------------------------------------\n\nTITLE: Example Usage of makeChangeNullabilityPlugin (TypeScript)\nDESCRIPTION: Demonstrates how to use `makeChangeNullabilityPlugin` to create a PostGraphile plugin. This specific example configures the `nodes` field within the `UsersConnection` type to be a non-nullable list (`[]!`) containing non-nullable items (`!`), resulting in the `\"[!]!\"` specification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-change-nullability-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeChangeNullabilityPlugin } from \"postgraphile/utils\";\n\nconst MyNullabilityPlugin = makeChangeNullabilityPlugin({\n  UsersConnection: {\n    nodes: \"[!]!\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Forum, Topic, and Post Data with GraphQL\nDESCRIPTION: This GraphQL query retrieves a specific forum identified by its 'slug' ('cat-life'). It fetches the forum's name, the first topic (ordered by CREATED_AT_ASC), including its ID, title, body summary, and author details. Within the topic, it fetches the first post (ordered by ID_DESC), including its ID, body, and author details.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/relations.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forumBySlug(slug: \"cat-life\") {\n    name\n    topics(first: 1, orderBy: [CREATED_AT_ASC]) {\n      nodes {\n        id\n        title\n        bodySummary\n        author {\n          id\n          username\n        }\n        posts(first: 1, orderBy: [ID_DESC]) {\n          nodes {\n            id\n            author {\n              id\n              username\n            }\n            body\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining pgSettings in Grafast Context Callback with TypeScript\nDESCRIPTION: Illustrates how to add a 'pgSettings' property to the Grafast context in 'graphile.config.mjs' using TypeScript. This allows merging settings from prior context with custom ones like PostgreSQL's 'statement_timeout'. The snippet demonstrates the use of JavaScript object spread to preserve existing settings while adding new ones. It assumes the common Graphile integration with PostgreSQL, and requires that 'pgSettings' keys follow naming rules for compatibility with Postgres and custom extensions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default {\n  // ...\n\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-start\n        pgSettings: {\n          // If any pgSettings were already set, mix them in\n          ...args.contextValue?.pgSettings,\n          // Add our own settings\n          statement_timeout: \"10000\",\n        },\n        // highlight-end\n      };\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for Heroku Build and Runtime (JSON)\nDESCRIPTION: Shows relevant sections of a `package.json` file for Heroku deployment. The `scripts` section defines a `build` command (e.g., for TypeScript compilation with `tsc`) and a `start` command (to run the server, e.g., `node server.js`). The `engines` section specifies the required Node.js version for the Heroku runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node server.js\",\n  },\n  \"engines\": {\n    \"node\": \"12.x\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @primaryKey Constraint via Tag File (JSON5)\nDESCRIPTION: This JSON5 snippet configures a primaryKey tag on a view via PostGraphileâ€™s tag file, marking specified column(s) as the primary key for GraphQL schema purposes. The tag is applied at the 'class' (table/view) level, and supports single or multiple columns as a comma-separated string. This affects generated client queries and identity resolution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_28\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  my_view: {\n    tags: {\n      primaryKey: \"id\"\n      // or:\n      //   primaryKey: \"type,identifier\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Execute Method Using Array Syntax (TypeScript)\nDESCRIPTION: This snippet represents the previous style of implementating an execute function that operates on array-based values. The function receives a count and a tuple of two number arrays, then iterates to combine values from both arrays into a results array. There are no third-party dependencies or special requirements. Inputs are a count and an array of number tuples; output is an array of numbers. The code assumes positional array access for all dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/ev2.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction execute(count: number, values: ReadonlyArray<[number, number]>) {\\n  const [allA, allB] = values;\\n  const results: number[] = [];\\n  for (let i = 0; i < count; i++) {\\n    const a = allA[i];\\n    const b = allB[i];\\n    results.push(a + b);\\n  }\\n  return results;\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating pgCondition Child in NOT Mode with notPlan - Graphile (JavaScript)\nDESCRIPTION: Uses the notPlan method to generate a child pgCondition that groups conditions with AND and applies a logical NOT to them. This approach is valuable for excluding results that match a particular set of conditions. It works on an existing pgCondition instance, chainable for advanced filter construction. There are no required parameters, and the output is a child pgCondition in NOT mode.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.notPlan()\n```\n\n----------------------------------------\n\nTITLE: Annotating a Table with Smart Comments - SQL\nDESCRIPTION: This snippet shows how to use the COMMENT ON TABLE command with an E-escaped comment string to set smart tags and documentation on a PostgreSQL table. The tags may rename the GraphQL table type and control exposure of certain mutations. Use requires an existing schema and table, with no other dependencies beyond PostgreSQL; output is schema annotation for PostGraphile to read. The syntax structure is applicable to tables, with key-value and list tags possible.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table my_schema.my_table is\\n  E'@name my_new_table_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via .postgraphilerc.js\nDESCRIPTION: This JavaScript snippet demonstrates configuring PostGraphile plugins using a `.postgraphilerc.js` file. The file exports an object with an `options` property, which includes a `plugins` array listing the names of the plugins to be enabled (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`). This method is used when running PostGraphile via the CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nmodule.exports = {\n  options: {\n    plugins: [\n      \"@graphile/operation-hooks\",\n      \"@graphile/pg-pubsub\",\n      \"@graphile/pro\",\n    ],\n    connection: \"postgres:///my_db\",\n    schema: [\"app_public\"],\n    // ...\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Verifying PostgreSQL Configuration for Logical Decoding (SQL)\nDESCRIPTION: A PL/pgSQL script to check if the current PostgreSQL instance is correctly configured for logical replication. It verifies `wal_level`, `max_replication_slots`, and `max_wal_senders` settings and performs a test creation and deletion of a logical replication slot using `wal2json`. If successful, it raises a notice indicating readiness.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nDO $$\nBEGIN\n  if current_setting('wal_level') is distinct from 'logical' then\n    raise exception 'wal_level must be set to ''logical'', your database has it set to ''%''. Please edit your `%` file and restart PostgreSQL.', current_setting('wal_level'), current_setting('config_file');\n  end if;\n  if (current_setting('max_replication_slots')::int >= 1) is not true then\n    raise exception 'Your max_replication_slots setting is too low, it must be greater than 1. Please edit your `%` file and restart PostgreSQL.', current_setting('config_file');\n  end if;\n  if (current_setting('max_wal_senders')::int >= 1) is not true then\n    raise exception 'Your max_wal_senders setting is too low, it must be greater than 1. Please edit your `%` file and restart PostgreSQL.', current_setting('config_file');\n  end if;\n  perform pg_create_logical_replication_slot('compatibility_test', 'wal2json');\n  perform pg_drop_replication_slot('compatibility_test');\n  raise notice 'Everything seems to be in order.';\nend;\n$$ LANGUAGE plpgsql;\n```\n\n----------------------------------------\n\nTITLE: Creating Framework-Specific Handler Adaptors in JavaScript\nDESCRIPTION: This snippet illustrates how to create a `convertHandler` function that adapts PostGraphile's generic route handlers to a specific server framework's request/response format. It shows examples for Fastify v3 using `PostGraphileResponseFastify3`, Express/Node using `PostGraphileResponseNode` (including error handling with `.catch(next)`), and Koa using `PostGraphileResponseKoa`. This abstraction allows PostGraphile handlers to be used across different frameworks.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { PostGraphileResponseFastify3 } from \"postgraphile\";\n\n// Converts a PostGraphile handler to a Fastify v3 handler\nconst convertHandler = (handler) => (request, reply) =>\n  handler(new PostGraphileResponseFastify3(request, reply));\n\n/* Other frameworks:\n\n// Converts a PostGraphile handler to an Express handler\nconst convertHandler = handler => (req, res, next) =>\n  handler(new PostGraphileResponseNode(req, res, next)).catch(next);\n\n// Converts a PostGraphile handler to a Koa handler\nconst convertHandler = handler => (ctx, next) =>\n  handler(new PostGraphileResponseKoa(ctx, next));\n*/\n```\n\n----------------------------------------\n\nTITLE: Splitting Generated Persisted Operations into Files using JavaScript\nDESCRIPTION: This JavaScript script (`addToPersistedOperations.js`) reads a `server.json` file (presumably generated by `graphql-code-generator`) containing a map of operation hashes to GraphQL query strings. It then iterates through this map and writes each query string to a separate `.graphql` file named after its hash within a specified directory (`.persisted_operations`), preparing them for use with the `persistedOperationsDirectory` option in Grafserv.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// addToPersistedOperations.js\nconst map = require(\"./server.json\");\nconst { promises: fsp } = require(\"fs\");\n\nasync function main() {\n  await Promise.all(\n    Object.entries(map).map(([hash, query]) =>\n      fsp.writeFile(\n        `${__dirname}/.persisted_operations/${hash}.graphql`,\n        query,\n      ),\n    ),\n  );\n}\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing Inflectors in PostGraphile Plugin (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a plugin that replaces the built-in inflector to return \"RootQuery\" instead of \"Query\" for the root query type. It demonstrates the use of the inflection.replace property and how to delegate to the previous inflector when appropriate. Dependencies include the 'graphile-config', 'graphile-build', and 'graphile-build-pg' type definitions. The replacement function receives the previous inflector, preset, and inflector-specific parameters. Outputs the replacement string, and falls back to the previous inflector for other cases.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import types for TypeScript, no need in JS\\nimport \\\"graphile-config\\\";\\nimport \\\"graphile-build\\\";\\nimport \\\"graphile-build-pg\\\";\\n\\nexport const ReplaceInflectorPlugin: GraphileConfig.Plugin = {\\n  // Unique name for your plugin:\\n  name: \\\"ReplaceInflectorPlugin\\\",\\n  version: \\\"0.0.0\\\",\\n\\n  inflection: {\\n    replace: {\\n      builtin(\\n        // The previous version of this inflector, the one you're replacing\\n        previous,\\n\\n        // The resolved configuration\\n        preset,\\n\\n        // Everything from the 3rd paramater onward are the arguments to this inflector\\n        text,\\n      ) {\\n        if (name === \\\"Query\\\") return \\\"RootQuery\\\";\\n        return previous(text);\\n      },\\n    },\\n  },\\n};\n```\n\n----------------------------------------\n\nTITLE: Querying List of Forums About Cats via GraphQL (GraphQL)\nDESCRIPTION: This GraphQL query retrieves a list of forums filtered by the 'cat' keyword. The query returns a 'forumsAboutCats' field containing an array ('nodes') of objects with 'nodeId', 'id', 'name', and 'slug'. It demonstrates Graphile's handling of set-returning functions as connection fields, with @graphile-contrib/pg-simplify-inflector affecting the field names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forumsAboutCats {\n    nodes {\n      nodeId\n      id\n      name\n      slug\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JWT Composite Type in PostgreSQL - SQL\nDESCRIPTION: Defines a PostgreSQL composite type 'jwt_token' within the 'my_public_schema' schema, specifying the expected columns to be packaged into the JWT. Prerequisite: an existing PostgreSQL schema. This type is designed to represent claims and metadata for token generation, with fields for role, expiry, user identity, admin privilege, and username. No parameters are required; the type is intended for use as a return type in PG functions producing JWTs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type my_public_schema.jwt_token as (\n  role text,\n  exp integer,\n  person_id integer,\n  is_admin boolean,\n  username varchar\n);\n```\n\n----------------------------------------\n\nTITLE: Asserting an Object Step Type with makeGrafastSchema in TypeScript\nDESCRIPTION: Demonstrates how to assert a required step type (`ObjectStep`) for an object type ('MyObject') when using `makeGrafastSchema`. The assertion is specified using the `__assertStep` property within the `plans.MyObject` configuration, avoiding potential naming conflicts with fields. Both direct class assignment and a custom assertion function are presented.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-resolvers.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeGrafastSchema, ObjectStep } from \"grafast\";\n\nconst schema = makeGrafastSchema({\n  typeDefs: /* GraphQL */ `\n    type MyObject {\n      a: Int\n    }\n  `,\n  plans: {\n    MyObject: {\n      __assertStep: ObjectStep,\n      /* Or:\n        __assertStep($step) {\n          if ($step instanceof ObjectStep) return;\n          throw new Error(`Type 'MyObject' expects a step of type ObjectStep; instead received a step of type '${$step.constructor.name}'`);\n        }\n       */\n      a($obj: ObjectStep) {\n        return $obj.get(\"a\");\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for makePgSmartTagsPlugin\nDESCRIPTION: This TypeScript code defines the function signature for `makePgSmartTagsPlugin`. It takes initial rules (`PgSmartTagRule` or an array), an optional update subscription callback for watch mode, and optional plugin details, returning a `GraphileConfig.Plugin`. The associated types define the structure for rules (including `kind`, `match`, `tags`, `description`), filter functions, and the update mechanism.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nfunction makePgSmartTagsPlugin(\n  initialRules: ThunkOrDirect<\n    PromiseOrDirect<PgSmartTagRule | PgSmartTagRule[] | null>\n  >,\n  subscribeToUpdatesCallback?: SubscribeToPgSmartTagUpdatesCallback | null,\n  details?: { name?: string; description?: string; version?: string },\n): GraphileConfig.Plugin;\n\ninterface PgSmartTagRule<\n  TKind extends PgSmartTagSupportedKinds = PgSmartTagSupportedKinds,\n> {\n  serviceName?: string;\n  kind: TKind;\n  match: string | PgSmartTagFilterFunction<PgEntityByKind[TKind]>;\n  tags?: PgSmartTagTags;\n  description?: string;\n}\n\ntype PgSmartTagFilterFunction<TEntity extends PgEntity> = (\n  input: TEntity,\n) => boolean;\n\ntype UpdatePgSmartTagRulesCallback = (\n  ruleOrRules: PgSmartTagRule | PgSmartTagRule[] | null,\n) => void;\n\ntype SubscribeToPgSmartTagUpdatesCallback = (\n  cb: UpdatePgSmartTagRulesCallback | null,\n) => PromiseOrDirect<void>;\n```\n\n----------------------------------------\n\nTITLE: Customizing GraphQL Enum Name via PostgreSQL Smart Comment (SQL)\nDESCRIPTION: Demonstrates using a PostgreSQL `COMMENT ON TYPE` statement with the PostGraphile `@enumName` smart comment to explicitly set the name of the generated GraphQL enum type corresponding to `animal_type` to `TypeOfAnimal`, overriding the default name derived by PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/enums.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TYPE animal_type IS E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Schema Directly with makeSchema in JavaScript\nDESCRIPTION: Shows how to use makeSchema to build a GraphQL schema and resolved preset directly, bypassing some overhead. This is useful for quick schema extraction when watch mode and dynamic updates are not required. Dependencies include 'postgraphile' and a preset. Inputs are the preset configuration and the output is an object with 'schema' and 'resolvedPreset'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-schema.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Optimizing Webpack Configuration for Advanced PostGraphile Bundling in JavaScript\nDESCRIPTION: This advanced webpack configuration optimizes PostGraphile bundling by leveraging several plugins and environment replacements. It defines environment variables to tune PostGraphile and forcibly switches node-postgres to use a JavaScript client, replacing native and expensive modules where feasible. The configuration also disables __dirname emulation, applies Terser for optimized output, and demonstrates modular replacement strategies for further size and speed gains. Dependencies include 'webpack', 'terser-webpack-plugin', and the custom modules referenced via NormalModuleReplacementPlugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/bundling-webpack.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst webpack = require(\"webpack\");\nconst TerserPlugin = require(\"terser-webpack-plugin\");\n\nmodule.exports = {\n  //...\n\n  target: \"node\",\n  plugins: [\n    // Prevent loading pg-native (in a weird, backwards kind of way!)\n    new webpack.DefinePlugin({\n      // Nice light dependencies\n      \"process.env.NODE_ENV\": '\"production\"',\n      \"process.env.POSTGRAPHILE_ENV\": '\"production\"',\n\n      // Forces node-postgres to attempt to use the native module, HOWEVER we\n      // trick this below by replacing the native module with the JavaScript\n      // client using `NormalModuleReplacementPlugin`. ðŸ˜ˆ\n      \"process.env.NODE_PG_FORCE_NATIVE\": '\"1\"',\n\n      // Set this if you want the smallest bundle; it excludes GraphiQL\n      \"process.env.POSTGRAPHILE_OMIT_ASSETS\": '\"1\"',\n    }),\n\n    // Here's where we replace the native `pg` module reference with the\n    // JavaScript client. (See NODE_PG_FORCE_NATIVE above.)\n    new webpack.NormalModuleReplacementPlugin(\n      /pg\\/lib\\/native\\/index\\.js$/,\n      \"../client.js\",\n    ),\n\n    // Omit websocket functionality from postgraphile:\n    new webpack.NormalModuleReplacementPlugin(\n      /postgraphile\\/build\\/postgraphile\\/http\\/subscriptions\\.js$/,\n      `${__dirname}/src/postgraphile-http-subscriptions.js`,\n    ),\n\n    // Just in case you install express, omit the expensive view file:\n    new webpack.NormalModuleReplacementPlugin(\n      /express\\/lib\\/view\\.js$/,\n      `${__dirname}/src/express-lib-view.js`,\n    ),\n  ],\n\n  // We don't need to use __dirname any more:\n  node: {\n    __dirname: false, // just output `__dirname`\n  },\n\n  // Without this, you may get errors such as `Error: GraphQL conflict for 'e'\n  // detected! Multiple versions of graphql exist in your node_modules?`\n  // May not be necessary for newer versions of the `graphql` module.\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          mangle: false, // < This is the important part\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Renaming a PostgreSQL Table in GraphQL Schema using Smart Comments (SQL)\nDESCRIPTION: This SQL snippet demonstrates how to use a PostGraphile smart comment to override the default GraphQL type name generated for a PostgreSQL table. The `COMMENT ON TABLE` command applies a `@name` tag to the `post` table, instructing PostGraphile to name the corresponding GraphQL type 'message' instead of the default inferred name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/inflection.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TABLE post IS E'@name message';\n```\n\n----------------------------------------\n\nTITLE: Configuring Connection and List Behavior in PostGraphile Preset (JavaScript)\nDESCRIPTION: This snippet shows how to set the default schema behavior in PostGraphile configuration to disable connections and enable simple lists by adjusting the 'defaultBehavior' property. It belongs in a preset configuration file named 'graphile.config.mjs'. You can adjust behavior flags to '+connection', '+list', or '-connection' as needed. The only dependency is PostGraphile configured to read this preset file. No inputs or outputs in this snippet, but changing it will affect schema generation. Be cautious: toggling settings here changes the shape of your GraphQL API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/connections.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst preset = {\n  schema: {\n    defaultBehavior: \"-connection +list\",\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Removing Deprecated Grafast Schema Properties (TypeScript)\nDESCRIPTION: Several properties previously used in Grafast schemas for planning have been removed as functionality shifts towards runtime. An error will be thrown if these properties are encountered in a schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentInputPlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentApplyPlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentPlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentSubscribePlan\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninputPlan // on fields\n```\n\nLANGUAGE: typescript\nCODE:\n```\napplyPlan // on input fields\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Graphile Engine Plugin in JavaScript\nDESCRIPTION: Illustrates how to integrate a custom plugin (`NoopPlugin`, defined elsewhere) into the schema building process. It adds the custom plugin function to the array containing the spread `defaultPlugins` before passing the combined array to `buildSchema`. The resulting schema is then printed.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugins.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst { buildSchema, defaultPlugins } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nbuildSchema([...defaultPlugins, NoopPlugin]).then((schema) => {\n  console.log(printSchema(schema));\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Schema (SQL)\nDESCRIPTION: Demonstrates the SQL command to create a new schema named `app_public` in PostgreSQL. This schema is recommended as part of a pattern for organizing database objects in PostGraphile applications, specifically for tables and functions intended to be exposed via the GraphQL API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/namespaces.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE SCHEMA app_public;\n```\n\n----------------------------------------\n\nTITLE: Defining Individual Fields with Hooks and Data Generators using JavaScript\nDESCRIPTION: This snippet shows an alternative way to define fields and associate data generators using the `fieldWithHooks` helper for each field within a `GraphQLObjectType`. For each field ('id', 'caps', 'random'), `fieldWithHooks` is called with the field name and a callback function. Inside the callback, `addDataGenerator` is used to define the metadata, including a `map` function for transforming data based on the alias. This approach allows for encapsulating the field definition and its associated look-ahead metadata together.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/look-ahead.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst MyObject = newWithHooks(GraphQLObjectType, {\n  name: \"MyObject\",\n  fields: ({ fieldWithHooks }) => {\n    return {\n      /* highlight-start */\n      id: fieldWithHooks(\"id\", ({ addDataGenerator }) => {\n        addDataGenerator(({ alias }) => {\n          return {\n            map: (obj) => ({ [alias]: obj.ID }),\n          };\n        });\n        return {\n          type: new GraphQLNonNull(GraphQLString),\n          resolve: resolveAlias,\n        };\n      }),\n      /* highlight-end */\n      caps: fieldWithHooks(\"caps\", ({ addDataGenerator }) => {\n        addDataGenerator(({ alias }) => {\n          return {\n            map: (obj) => ({ [alias]: obj.CAPS }),\n          };\n        });\n        return {\n          type: new GraphQLNonNull(GraphQLString),\n          resolve: resolveAlias,\n        };\n      }),\n      random: fieldWithHooks(\"random\", ({ addDataGenerator }) => {\n        addDataGenerator(({ alias }) => {\n          return {\n            map: () => ({ [alias]: Math.floor(Math.random() * 10000) }),\n          };\n        });\n        return {\n          type: new GraphQLNonNull(GraphQLInt),\n          resolve: resolveAlias,\n        };\n      }),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Name and Result Field Name via SQL Smart Comment - SQL\nDESCRIPTION: This SQL snippet attaches two smart tags (@resultFieldName and @name) via a comment on a function, altering its mutation field and the name of its payload property in GraphQL. The tags are separated by a newline in the comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function authenticate(text, text) is\n  E'@resultFieldName token\\n@name login';\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Table for Polymorphic Data in SQL\nDESCRIPTION: SQL script to create an 'animals' table illustrating a single-table inheritance pattern. The table uses a 'type' column to distinguish between different kinds of animals (e.g., Cat, Dog, Fish) and includes both common fields and type-specific nullable fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSingleTablePolymorphic.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table animals (\n  id serial primary key,\n  type text not null,\n  name text not null,\n  date_of_birth date not null,\n  number_of_lives boolean,\n  wags_tail boolean,\n  freshwater boolean\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Instance in JavaScript\nDESCRIPTION: Creates and exports a PostGraphile instance (`pgl`) using the `postgraphile` library function and a configuration preset. This instance is the entry point for accessing schema and execution functionalities.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { postgraphile } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nexport const pgl = postgraphile(preset);\n```\n\n----------------------------------------\n\nTITLE: Extending GraphileConfig Plugin Interface for Middleware in TypeScript\nDESCRIPTION: Located in `src/index.ts`, this snippet uses TypeScript declaration merging to extend the global `GraphileConfig.Plugin` interface. It adds an optional `libraryName.middleware` property (where `libraryName` should be replaced with the actual library name), allowing plugins to provide implementations for the middleware methods defined in `MyMiddleware` using the `MiddlewareHandlers` type from `graphile-config`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/library-authors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"src/index.ts\"\nimport type { MiddlewareHandlers } from \"graphile-config\";\n\n// Extend Plugin with support for registering handlers for the middleware activities:\ndeclare global {\n  namespace GraphileConfig {\n    interface Plugin {\n      libraryName?: {\n        middleware?: MiddlewareHandlers<MyMiddleware>;\n      };\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Object Type from Composite Type (GraphQL)\nDESCRIPTION: Shows the GraphQL object type `MyType` that PostGraphile automatically generates from the `my_schema.my_type` PostgreSQL composite type. The fields `foo` and `bar` are mapped to GraphQL `Int` types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\ntype MyType {\n  foo: Int\n  bar: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Using Ruru as a React Component (JavaScript/JSX)\nDESCRIPTION: Demonstrates how to use Ruru as a React component within a JavaScript application, likely using a module bundler. It requires importing the `Ruru` component from `ruru-components` and necessary CSS files (`graphiql.css`, `@graphiql/plugin-explorer/dist/style.css`, `ruru-components/ruru.css`). The component is then rendered using JSX, passing the GraphQL API URL via the `endpoint` prop.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport { Ruru } from \"ruru-components\";\nimport \"graphiql/graphiql.css\";\nimport \"@graphiql/plugin-explorer/dist/style.css\";\nimport \"ruru-components/ruru.css\";\n\nReact.render(<Ruru endpoint=\"/graphql\" />);\n```\n\n----------------------------------------\n\nTITLE: Example SQL Schema for One-to-Many Relation\nDESCRIPTION: Sets up a database schema with two tables, `c.person` and `a.post`, demonstrating a one-to-many relationship where one person can author multiple posts. The `a.post` table includes a foreign key `author_id` referencing `c.person(id)` defined using the `references` keyword. An index on `a.post(author_id)` is created to optimize relation lookups in PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/relations.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate schema a;\ncreate schema c;\n\ncreate table c.person (\n  id serial primary key,\n  name varchar not null,\n  about text,\n  email varchar not null unique,\n  created_at timestamp default current_timestamp\n);\n\ncreate table a.post (\n  id serial primary key,\n  headline text not null,\n  body text,\n  -- `references` ðŸ‘‡  sets up the foreign key relation\n  author_id int4 references c.person(id)\n);\ncreate index on a.post (author_id);\n```\n\n----------------------------------------\n\nTITLE: Importing Grafserv Adapters in TypeScript\nDESCRIPTION: Illustrates importing the necessary `grafserv` adapter based on the chosen Node.js web server framework (e.g., Node HTTP, Express, Koa, Fastify). This adapter acts as a bridge between PostGraphile V5 and the specific web server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { grafserv } from \"grafserv/node\";\n// OR: import { grafserv } from \"grafserv/express/v4\";\n// OR: import { grafserv } from \"grafserv/koa/v2\";\n// OR: import { grafserv } from \"grafserv/fastify/v4\";\n// etc\n```\n\n----------------------------------------\n\nTITLE: Illustrating Variable Conflict in PL/pgSQL Upsert Function\nDESCRIPTION: Presents a PL/pgSQL function designed for an upsert operation (`INSERT...ON CONFLICT`). It highlights a common ambiguity issue where `ON CONFLICT (id)` fails because PL/pgSQL cannot determine whether `id` refers to the function argument or the table column.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncreate function upsert_value(id int, value text) returns void as $$\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    /* highlight-next-line */\n    on conflict (id) -- This will error\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n\n----------------------------------------\n\nTITLE: Implementing items() for Collection Steps in Grafast (TypeScript)\nDESCRIPTION: This snippet presents an implementation of the items() method for Step subclasses representing collections in Grafast. The method is parameterless and uses the access utility to retrieve the items collection, optionally tracking the call for fetch optimization. No input arguments; output is a step for the collection items.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { access } from \"grafast\";\n\nclass MyCollectionStep extends Step /* implements ConnectionCapableStep */ {\n  // ...\n\n  items() {\n    // Update this to access the correct property needed for the items in your\n    // collection; you may also choose to track that this was requested and\n    // thus ensure that fetches only go ahead when necessary.\n    return access(this, \"items\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Behaviors to Omit Update/Delete Mutations on Unique Constraints (Conceptual)\nDESCRIPTION: Introduced in version 5.0.0-0.9, this feature allows developers to apply behavior strings directly to unique constraints. This enables the selective omission of the corresponding update or delete mutations that would normally be generated based on that constraint.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_23\n\nLANGUAGE: plaintext\nCODE:\n```\n# v5.0.0-0.9: Feature enablement via behaviors\n# Context: Omitting update/delete mutations.\n# Method: Apply behaviors on unique constraints.\n# (No specific behavior string provided in the source text)\n```\n\n----------------------------------------\n\nTITLE: Creating a Trigger Function and Triggers to Update Timestamps in PostgreSQL\nDESCRIPTION: Defines a PL/pgSQL function `forum_example_private.set_updated_at` which returns type `trigger` and sets the `updated_at` field of the row being updated (`new`) to the `current_timestamp`. Subsequently, it creates two triggers, `person_updated_at` and `post_updated_at`, using `CREATE TRIGGER`. These triggers are configured to execute the `set_updated_at` function `BEFORE UPDATE` operations `FOR EACH ROW` on the `forum_example.person` and `forum_example.post` tables, respectively.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_18\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example_private.set_updated_at() returns trigger as $$\nbegin\n  new.updated_at := current_timestamp;\n  return new;\nend;\n$$ language plpgsql;\n\ncreate trigger person_updated_at before update\n  on forum_example.person\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n\ncreate trigger post_updated_at before update\n  on forum_example.post\n  for each row\n  execute procedure forum_example_private.set_updated_at();\n```\n\n----------------------------------------\n\nTITLE: Querying a Simple Track List - GraphQL\nDESCRIPTION: Executes a basic GraphQL query to retrieve the first 20 tracks, including their IDs and names, using PostGraphile's generated API. This query demonstrates high-throughput, with the documented benchmark reaching 3250 requests per second. No parameters are required except the field arguments; responses are expected as lists of trackId and name values. The snippet is suitable for scenarios where only shallow data fetches are needed with low server load.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/performance.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery tracks_media_first_20 {\n  allTracksList(first: 20) {\n    trackId\n    name\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a New Inflector in Graphile Build (TypeScript)\nDESCRIPTION: This TypeScript plugin shows how to add a new inflector, `enhanced`, while ensuring type safety. It utilizes TypeScript's declaration merging (`declare global`) to extend the `GraphileBuild.Inflection` interface, making the new inflector and its signature known throughout the project. The implementation within `inflection.add` defines the inflector's logic, which receives the preset and custom arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Import types for TypeScript, no need in JS\nimport \"graphile-config\";\nimport \"graphile-build\";\nimport \"graphile-build-pg\";\n\ndeclare global {\n  namespace GraphileBuild {\n    interface Inflection {\n      /**\n       * Add documentation for your inflector here.\n       */\n      enhanced(this: Inflection, columnName: string): string;\n    }\n  }\n}\n\nexport const MyNewInflectorPlugin: GraphileConfig.Plugin = {\n  name: \"MyNewInflectorPlugin\",\n  version: \"0.0.0\",\n\n  inflection: {\n    add: {\n      enhanced(preset, columnName) {\n        return columnName + \"Enhanced\";\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using pgSelect Alias for WHERE Clause Conditions in TypeScript\nDESCRIPTION: Illustrates obtaining the SQL alias for the table represented by a `pgSelect` step (`$users`) using `$users.alias`. This alias (`tbl`) is then used within an SQL fragment tagged template literal (`sql`) to construct a `WHERE` condition, which is applied to the `$users` step via the `.where()` method. Requires a `usersResource` instance and the `sql` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst $users = usersResource.find();\nconst tbl = $users.alias;\n$users.where(sql`${tbl}.username = 'Benjie'`);\n```\n\n----------------------------------------\n\nTITLE: Disabling Built-In Plugins via Configuration (PostGraphile, TypeScript)\nDESCRIPTION: This snippet demonstrates how to disable specific built-in PostGraphile plugins, such as PgCustomTypeFieldPlugin, by adding their names to a disabledPlugins array in the configuration export. This prevents automatic addition of features (such as exposing Postgres functions) to the generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/extending-raw.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default {\n  // ...\n  disabledPlugins: [\"PgCustomTypeFieldPlugin\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Querying a PostGraphile Set-Returning Function as a Connection (GraphQL)\nDESCRIPTION: This GraphQL query demonstrates how to interact with a PostGraphile-exposed set-returning function (`search_posts`). It uses connection arguments like `search` and `first` for filtering and pagination, retrieving edges containing cursors and post nodes with selected fields (`headline`, `body`). This illustrates how PostGraphile treats SQL set-returning functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  searchPosts(search: \"Hello, world!\", first: 5) {\n    edges {\n      cursor\n      node {\n        headline\n        body\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying a Custom Connection from PostgreSQL in GraphQL - GraphQL\nDESCRIPTION: Illustrates how to query the custom SETOF function 'myFunction' (exposed by PostGraphile) as a GraphQL connection. It shows requesting paginated data with arguments (a, b, first), and retrieving pageInfo (pagination status), edges (cursors and nodes), and node fields (id). The snippet assumes that PostGraphile maps 'my_function' to 'myFunction' in the GraphQL schema. Input: query with arguments a, b, and pagination parameter first; Output: paginated connection of person nodes. Dependencies: A PostGraphile-powered GraphQL API with the function registered.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_15\n\nLANGUAGE: graphql\nCODE:\n```\n{\\n  myFunction(a: 1, b: 2, first: 2) {\\n    pageInfo {\\n      hasNextPage\\n      hasPrevPage\\n    }\\n    edges {\\n      cursor\\n      node {\\n        id\\n      }\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing PostgreSQL Type Codecs in PostGraphile (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the built-in PostgreSQL data type codecs from the PostGraphile \"@dataplan/pg\" library using TypeScript. Key codecs like \"int\", \"bool\", and \"text\" are extracted from the \"TYPES\" export, enabling custom type handling or plugin development. This requires the \"postgraphile\" and \"@dataplan/pg\" packages, and is intended for users extending schema generation or writing PostGraphile plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/registry.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TYPES } from \"postgraphile/@dataplan/pg\";\n\nconst { int, bool, text /* ... */ } = TYPES;\n```\n\n----------------------------------------\n\nTITLE: Omitting Table from Mutations via SQL Smart Comment - SQL\nDESCRIPTION: This SQL snippet adds an @omit smart comment to a table, instructing PostGraphile to exclude 'create', 'update', and 'delete' operations for that table in the generated GraphQL API. The COMMENT ON TABLE syntax is used.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table table_name is E'@omit create,update,delete';\n```\n\n----------------------------------------\n\nTITLE: Defining an Entity Type Map for pgPolymorphic in TypeScript\nDESCRIPTION: This snippet constructs an entity type map required by `pgPolymorphic`. For each possible target type ('Person', 'Post', 'Comment'), it defines a `match` function to check if the specifier data corresponds to that type (by checking for non-null values at specific indices) and a `plan` function that takes the specifier *step* and returns a plan to retrieve the actual record using the appropriate resource (e.g., `personResource`, `postResource`) and the ID from the specifier. It assumes the existence of `personResource`, `postResource`, and `commentResource`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgPolymorphic.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst personFavouriteEntityTypeMap = {\n  Person: {\n    match: (specifier) => specifier[0] != null,\n    plan: ($specifier) => personResource.get({ person_id: $specifier.at(0) }),\n  },\n  Post: {\n    match: (specifier) => specifier[1] != null,\n    plan: ($specifier) => postResource.get({ post_id: $specifier.at(1) }),\n  },\n  Comment: {\n    match: (specifier) => specifier[2] != null,\n    plan: ($specifier) => commentResource.get({ comment_id: $specifier.at(2) }),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins in Middleware using JavaScript\nDESCRIPTION: Demonstrates how to enable plugins when using PostGraphile as middleware (e.g., within an Express or Koa application). It uses `makePluginHook` to create a `pluginHook` function from an array of imported plugin objects, which is then passed in the PostGraphile options.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n// Only include as many plugins as you need. An empty array is also valid.\nconst pluginHook = makePluginHook([OperationHooks, PgPubsub, GraphilePro]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n\napp.use(postGraphileMiddleware);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a GraphQL Service to a Multi-container Docker Compose Environment - YAML\nDESCRIPTION: This snippet updates the services section of a Docker Compose file to declare a new graphql service that uses a locally built image, depends on the db service, and maps port 5433. It loads environment variables from the .env file and connects to the configured Docker network. This YAML configuration creates dependency management between database and application layers and binds the correct runtime environment for PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \\\"3.3\\\"\\nservices:\\n    db: [...]\\n\\n    graphql:\\n        container_name: forum-example-graphql\\n        restart: always\\n        image: forum-example-graphql\\n        build:\\n            context: ./graphql\\n        env_file:\\n            - ./.env\\n        depends_on:\\n            - db\\n        networks:\\n            - network\\n        ports:\\n            - 5433:5433\\n[...]\n```\n\n----------------------------------------\n\nTITLE: Renaming a Column using SQL Smart Comment\nDESCRIPTION: Uses a SQL `COMMENT` statement with the `@name` smart tag to rename the `col1` column of the `original_table` to `colA` within the PostGraphile generated GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column original_table.col1 is E'@name colA';\n```\n\n----------------------------------------\n\nTITLE: Using sql.compile() to Prepare a Query for Execution in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `sql.compile` function. It takes a query object, typically generated using `sql` tagged template literals (represented by `sql`...`), and compiles it into an object containing the `text` (the SQL string with placeholders like $1, $2) and `values` (an array of parameters to substitute). The commented-out line illustrates how these components (`text` and `values`) could then be passed to a PostgreSQL client library (`pg`) to execute the query against a database.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-complie.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst query = sql`...`;\nconst { text, values } = sql.compile(query);\n\n// const { rows } = await pg.query(text, values);\n```\n\n----------------------------------------\n\nTITLE: Transforming a Schema with Additional Plugins - Graphile Engine - JavaScript\nDESCRIPTION: This example extends schema transformation by demonstrating how to supply buildSchema with an array of plugins, including an extra DeprecateFromCommentPlugin. Expected dependencies are the Graphile Engine library and the specific plugin modules supplied. The input is an array of plugins (the original used in schema creation, plus transformation plugins), and it outputs an enhanced schema where certain fields are now programmatically deprecated. No special configuration is needed beyond the plugin imports.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nbuildSchema([...plugins, DeprecateFromCommentPlugin]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Column via PostgreSQL Function - SQL\nDESCRIPTION: Defines a PostgreSQL function named 'person_full_name' for the 'person' table, which returns a concatenated full name as text. This function demonstrates how to create a computed column for a table in the same schema. Dependencies include an existing 'person' table with 'given_name' and 'family_name' columns, and adherence to Graphile function restrictions. The main input is a single 'person' record, and the output is the person's full name as a string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/computed-columns.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION person_full_name(person person) RETURNS text AS $$\n  SELECT person.given_name || ' ' || person.family_name\n$$ LANGUAGE sql STABLE;\n```\n\n----------------------------------------\n\nTITLE: Ruru CLI Usage Help Output (Plaintext)\nDESCRIPTION: Displays the command-line help information for the `ruru` tool, detailing available options, their descriptions, and default values. Key options include setting the GraphQL endpoint (`-e`), server port (`-p`), enabling proxying (`-P`), and handling subscriptions (`-S`, `-s`). This output is typically generated by running `ruru --help`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nruru\n\nRun a Ruru server\n\nOptions:\n      --help                   Show help                                                                      [boolean]\n      --version                Show version number                                                            [boolean]\n  -e, --endpoint               endpoint for query and mutation operations\n                                                                    [string] [default: \"http://localhost:5678/graphql\"]\n  -p, --port                   port number to run the server on                                [number] [default: 1337]\n  -P, --proxy                  Proxy requests to work around CORS issues                                      [boolean]\n  -S, --subscriptions          enable subscriptions, converting --endpoint to a ws:// URL    [boolean] [default: false]\n  -s, --subscription-endpoint  endpoint for subscription operations (overrides -S)                             [string]\n```\n\n----------------------------------------\n\nTITLE: Defining a PostGraphile V5 Plugin (JavaScript)\nDESCRIPTION: Demonstrates the declarative structure of a PostGraphile V5 plugin (`V5AddQueryFourFieldPlugin.js`). V5 plugins are objects with `name`, `version`, and `schema.hooks` properties. Hooks are defined within the `hooks` object (e.g., `GraphQLObjectType_fields`), and field logic uses Gra*fast* `plan` functions instead of `resolve` functions. Requires `grafast`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-start\nconst { constant } = require(\"grafast\");\nmodule.exports = {\n  name: \"AddQueryFourFieldPlugin\",\n  version: \"0.0.0\",\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // highlight-end\n        const {\n          graphql: { GraphQLInt },\n        } = build;\n        const { Self } = context;\n        if (Self.name !== \"Query\") return fields;\n        return build.extend(\n          fields,\n          {\n            four: {\n              type: GraphQLInt,\n              // highlight-start\n              plan() {\n                return constant(4);\n              },\n              // highlight-end\n            },\n          },\n          \"Adding Query.four\",\n        );\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Relational Tables with Foreign Key References in PostgreSQL - SQL\nDESCRIPTION: This SQL snippet defines two tables, 'animals' and 'dogs', where 'dogs' references 'animals' via the 'animal_id' column as a primary key. The purpose is to give an example database schema to illustrate how primary key references between tables affect field inflection in Graphile. It assumes a PostgreSQL-compatible environment where serial types and foreign key constraints are valid, requiring that the referenced 'animals' table exists prior to referencing it in 'dogs'. Inputs: runs as a database migration, outputs: two tables with enforced referential integrity. Limitations: demonstration sample only, omits indexes and triggers beyond PK/FK.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table animals (\n  id serial primary key,\n  name text\n);\n\ncreate table dogs (\n  animal_id int primary key references animals,\n  wags_tail bool\n);\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Precision-Limited Numeric to Float Conversion - Diff\nDESCRIPTION: Shows the changes to the GraphQL schema caused by the PgSmallNumericToFloatPlugin, in which only Numeric fields with precision and scale under the caps are converted to Float. Used for documentation, demonstrating partial changes matching the plugin rules. Intended for visual verification.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\\n+++ Modified GraphQL Schema\\n@@ -1863,7 +1863,7 @@\\n   id: Int!\\n   name: String!\\n   updatedAt: Datetime!\\n-  precision12Scale2: BigFloat\\n+  precision12Scale2: Float\\n   precision200Scale100: BigFloat\\n\\n   \\\"\\\"\\\"Reads and enables pagination through a set of `QuizEntry`.\\\"\\\"\\\"\\n@@ -1910,7 +1910,7 @@\\n   updatedAt: Datetime\\n\\n   \\\"\\\"\\\"Checks for equality with the objectâ€™s `precision12Scale2` field.\\\"\\\"\\\"\\n-  precision12Scale2: BigFloat\\n+  precision12Scale2: Float\\n\\n   \\\"\\\"\\\"Checks for equality with the objectâ€™s `precision200Scale100` field.\\\"\\\"\\\"\\n   precision200Scale100: BigFloat\\n@@ -2129,7 +2129,7 @@\\n   id: Int\\n   name: String!\\n   updatedAt: Datetime\\n-  precision12Scale2: BigFloat\\n+  precision12Scale2: Float\\n   precision200Scale100: BigFloat\\n }\\n\\n@@ -2138,7 +2138,7 @@\\n   id: Int\\n   name: String\\n   updatedAt: Datetime\\n-  precision12Scale2: BigFloat\\n+  precision12Scale2: Float\\n   precision200Scale100: BigFloat\\n }\n```\n\n----------------------------------------\n\nTITLE: Enabling pgcrypto Extension in PostgreSQL\nDESCRIPTION: Adds the `pgcrypto` extension to the current PostgreSQL database if it's not already present. This extension provides cryptographic functions, notably for password hashing (`crypt`, `gen_salt`), which are required for the user registration process.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_20\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n```\n\n----------------------------------------\n\nTITLE: Converting pgSelect to Single Record Plan with single() in TypeScript\nDESCRIPTION: Shows an alternative way to obtain a plan for a single record. Instead of using `usersResource.get()`, it uses `usersResource.find()` to get a `pgSelect` step and then calls the `.single()` method on it. This converts the potentially multi-row plan into a plan expected to resolve to only one record. Requires `usersResource` and the `constant` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// Instead of:\n//     const $user = usersResource.get({ id: constant(1) });\n// you could do:\nconst $user = usersResource.find({ id: constant(1) }).single();\n```\n\n----------------------------------------\n\nTITLE: Using Unary Step in loadMany for Friendships - TypeScript\nDESCRIPTION: Demonstrates the use of a unary step (e.g., dbClient from context) in loadMany, separating per-request context (dbClient) from user ID batching, facilitating easier backend dependency injection. Inputs are user ID and database client; output is friendship records fetched with the provided client.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadMany.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $userId = $user.get(\"id\");\nconst $dbClient = context().get(\"dbClient\");\nconst $friendships = loadMany($userId, $dbClient, getFriendshipsByUserIds);\n```\n\n----------------------------------------\n\nTITLE: Defining Extended Error Output in PostGraphile Library - JavaScript\nDESCRIPTION: This configuration shows how to specify extended error details in the PostGraphile library integration within JavaScript code. It sets the extendedErrors property to log detailed error fields, enhancing error reporting during development or troubleshooting. Requires PostGraphile as a library. The extendedErrors array accepts options like severity, code, detail, hint, etc. Adjust the values as needed for your environment; do not use such verbose errors in production.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/debugging.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nextendedErrors: [\\'severity\\', \\'code\\', \\'detail\\', \\'hint\\', \\'position\\', \\'internalPosition\\', \\'internalQuery\\', \\'where\\', \\'schema\\', \\'table\\', \\'column\\', \\'dataType\\', \\'constraint\\', \\'file\\', \\'line\\', \\'routine\\']\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Simple Collections on Database Objects (SQL)\nDESCRIPTION: These SQL code snippets demonstrate annotating tables, constraints, and functions with @simpleCollections both to control the GraphQL schema's exposure of simple (array-like) collections. This setting determines whether queries return Relay connections, plain lists, or both. The comments must be added to tables, constraints, or functions to instruct Graphile's schema generation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_22\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table email is\n  E'@simpleCollections both';\n```\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint email_user_id_fkey on email is\n  E'@simpleCollections both';\n```\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function search_people(query text) is\n  E'@simpleCollections both';\n```\n\n----------------------------------------\n\nTITLE: Extending the Query Type in Graphile Build (JavaScript)\nDESCRIPTION: This JavaScript code snippet demonstrates how to add custom fields to the root `Query` type in a `graphile-build` schema using a plugin. It uses `builder.hook` to intercept the `GraphQLObjectType` build process, checks if the current object scope (`scope.isRootQuery`) is the root Query object, and if so, uses the `extend` utility to add new fields to the Query type's specification.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/default-plugins.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nfunction MyPlugin(builder) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (spec, { extend }, { scope: { isRootQuery } }) => {\n      if (!isRootQuery) {\n        return spec;\n      }\n\n      return extend(spec, {\n        //... Add new query fields here\n      });\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Effect of Preset Composition Order in GraphileConfig (TypeScript)\nDESCRIPTION: Explains how composition order affects option resolution when presets in GraphileConfig extend the same ancestral preset. Constructs a minimal inheritance tree using in-memory JavaScript objects, showing methodical merges via object spreads. Inputs: base preset object, child presets each modifying options, and a preset that composes them; outputs: the composed preset object illustrating override precedence. This serves as an example for understanding preset merging semantics and potential pitfalls.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst Preset0 = { myScope: { option1: false, option2: false } };\nconst Preset1 = { extends: [Preset0], myScope: { option1: true } };\nconst Preset2 = { extends: [Preset0], myScope: { option2: true } };\nconst APreset = { extends: [Preset1, Preset2] };\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Resolving the presets operates depth first:\nconst Preset0 = { myScope: { option1: false, option2: false } };\nconst Preset1 = { myScope: { ...Preset0.myScope, option1: true } };\nconst Preset2 = { myScope: { ...Preset0.myScope, option2: true } };\nconst APreset = { myScope: { ...Preset1.myScope, ...Preset2.myScope } };\n// Thus:\nconst APreset = { myScope: { option1: false, option2: true } };\n```\n\n----------------------------------------\n\nTITLE: Renaming a Table Column Using SQL Smart Comments - SQL\nDESCRIPTION: This SQL snippet adds a smart comment to a specific table column to rename it in the PostGraphile-generated GraphQL schema. Requires PostgreSQL and PostGraphile. The COMMENT ON COLUMN syntax attaches the @name smart tag to 'col1', so it appears as 'colA' in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column original_table.col1 is E'@name colA';\n```\n\n----------------------------------------\n\nTITLE: Extracting an Executor from a Resource (TypeScript)\nDESCRIPTION: This example retrieves the executor directly from a resource (channels), useful when working with multiple databases or when the exact resource's connection context is needed. It is functionally equivalent to accessing pgExecutors.main in a single-db setup, but provides flexibility for multi-source Graphile projects.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst executor = channels.executor;\n```\n\n----------------------------------------\n\nTITLE: Defining Nullability Specification Strings (NullabilitySpecString) in TypeScript\nDESCRIPTION: This TypeScript code defines the `NullabilitySpecString` type alias. It enumerates the valid string formats that mimic GraphQL SDL syntax to specify the nullability of fields, including variations for lists and nested lists (e.g., `!`, `[]`, `[!]!`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-change-nullability-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nexport type NullabilitySpecString =\n  | \"\" // nullable\n  | \"!\" // non-nullable\n  | \"[]\" // nullable list of nullables\n  | \"[]!\" // non-nullable list of nullables\n  | \"[!\" // nullable list of non-nullables\n  | \"[!]!\"\n  | \"[[]]\"\n  | \"[[]]!\"\n  | \"[[]!]\"\n  | \"[[]!]!\"\n  | \"[[!]]\"\n  | \"[[!]]!\"\n  | \"[[!]!]\"\n  | \"[[!]!]!\";\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Set-Returning Function for Post Search (SQL)\nDESCRIPTION: Creates a stable SQL function `forum_example.search_posts` that accepts a `search` text parameter. It returns a set of `forum_example.post` records (`returns setof forum_example.post`) where the search term appears in either the post's `headline` or `body`, checked using the `position()` function. A comment describes its search functionality. PostGraphile maps set-returning functions to GraphQL connections.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\ncreate function forum_example.search_posts(search text) returns setof forum_example.post as $$\n  select post.*\n  from forum_example.post as post\n  where position(search in post.headline) > 0 or position(search in post.body) > 0\n$$ language sql stable;\n\ncomment on function forum_example.search_posts(text) is 'Returns posts containing a given search term.';\n```\n\n----------------------------------------\n\nTITLE: Defining InputNonNullPlan for Handling Non-Null Inputs (Pseudocode)\nDESCRIPTION: Specifies the `InputNonNullPlan` function. The current (and intended) implementation simply returns the `innerPlan`, relying entirely on GraphQL schema validation to enforce non-null constraints. An older, deprecated implementation (`OldInputNonNullPlan`) that performed explicit runtime null checks and error handling is also provided for reference but should not be used.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_15\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputNonNullPlan(aether, innerPlan):\n\n- Return {innerPlan}.\n\nNote: We rely on GraphQL to validate the inputs fully; this does mean that we rely on the\n[default values fix](https://github.com/graphql/graphql-spec/pull/793), but this is a concern of the schema designer -\nso long as the defaults are fully specified the client cannot cause issues here.\n```\n\nLANGUAGE: pseudocode\nCODE:\n```\nOldInputNonNullPlan(aether, innerPlan):\n\n- Let {plan} be {NewPlan(aether)}.\n- Add {innerPlan} to {plan}.{dependencies}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that:\n  - Let {results} be an empty list.\n  - For each input crystal object {crystalObject}:\n    - Let {innerValue} be the value associated with {innerPlan} within {crystalObject}.\n    - If {innerValue} is {null} or does not exist:\n      - Add a non-null error to {results}.\n    - Otherwise:\n      - Add {innerValue} to {results}.\n  - Return {results}.\n- Augment {plan} such that:\n  - Calls to `plan.eval()`:\n    - Let {innerValue} be the result of calling `innerPlan.eval()`.\n    - If {innerValue} is {null} or does not exist:\n      - Throw a non-null error.\n    - Otherwise:\n      - Return {innerValue}.\n- Return {plan}.\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Code Generator Using YAML\nDESCRIPTION: A YAML configuration file for graphql-code-generator specifying how to generate TypeScript types for a PostGraphile-generated schema. It sets up the schema input path, output location for generated types, included plugins, and custom scalar mappings. Required dependencies are the listed npm packages. This file should be named 'codegen.yml' and reside at the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\noverwrite: true\nschema: \"./src/generated/schema.graphql\"\ngenerates:\n  # Creates the TypeScript types from the schema and any .graphql file\n  src/generated/types.ts:\n    documents: \"src/**/*.graphql\"\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-urql\n    config:\n      withHOC: false\n      withComponent: false\n      withMutationFn: false\nconfig:\n  scalars:\n    DateTime: \"string\"\n    JSON: \"{ [key: string]: any }\"\n```\n\n----------------------------------------\n\nTITLE: Building a PostGraphile Docker Container with a Custom Plugin in Dockerfile\nDESCRIPTION: Defines a Dockerfile for creating a Node.js-based GraphQL server environment with PostGraphile and a custom plugin. Installs PostGraphile globally, adds the connection filter plugin, builds and installs the custom plugin from local sources, exposes port 5000, and launches PostGraphile. Ensure the custom plugin directory structure matches and required dependencies are included.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_21\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM node:alpine\nLABEL description=\"Instant high-performance GraphQL API for your PostgreSQL database https://github.com/graphile/postgraphile\"\n\n# Install PostGraphile and PostGraphile connection filter plugin\nRUN npm install -g postgraphile\nRUN npm install -g postgraphile-plugin-connection-filter\n\n# Install custom plugin\nCOPY ./custom-plugin /tmp/custom-plugin\nRUN cd /tmp/custom-plugin && npm pack\nRUN npm install -g /tmp/custom-plugin/custom-plugin-0.0.1.tgz\nRUN rm -rf /tmp/custom-plugin\n\nEXPOSE 5000\nENTRYPOINT [\"postgraphile\", \"-n\", \"0.0.0.0\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Name Suffix Logic using V5 JavaScript Lambda Plan\nDESCRIPTION: Presents a more performant alternative to the SQL-based plan for the `nameWithSuffix` field, implementing the logic purely in JavaScript within a V5 plan. This plan uses `$user.get(\"name\")` to retrieve the user's name and a `lambda` step to concatenate it with the `suffix` argument (`([name, suffix]) => `${name} ${suffix}`). This avoids a database round trip for the concatenation operation. Dependencies include `postgraphile/grafast`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-extend-schema-plugin.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n+    plans: {\n+      User: {\n+        nameWithSuffix($user, { $suffix }) {\n+          return lambda(\n+            [$user.get(\"name\"), $suffix],\n+            ([name, suffix]) => `${name} ${suffix}`,\n+          );\n+        },\n+      },\n+    },\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Null Return Enforcement for SETOF Functions - PostGraphile Schema Config - typescript\nDESCRIPTION: This TypeScript configuration snippet for PostGraphile sets the pgForbidSetofFunctionsToReturnNull flag to true, instructing PostGraphile to disallow returned null rows from PostgreSQL SETOF functions within the GraphQL schema. Intended to strengthen contract between SQL functions and GraphQL outputs. Dependencies: PostGraphile, configuration loaded at runtime. Input: none; Output: alters schema generation behavior. Limitation: setting is disabled by default for compatibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/why-nullable.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"export default {\\n  // ...\\n  schema: {\\n    pgForbidSetofFunctionsToReturnNull: true,\\n  },\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Configuring pgV4UseTableNameForNodeIdentifier in PostGraphile V5 Preset - JavaScript\nDESCRIPTION: This JavaScript snippet configures the pgV4UseTableNameForNodeIdentifier option within the schema section of a PostGraphile V5 preset to disable V4's table-name-based node identifier fallback. This setting replaces the V4 plugin PgNodeAliasPostGraphile, which no longer exists in V5, and should be used to maintain compatible behavior with earlier schema designs. There are no additional dependencies beyond the main PostGraphile config library; expected input is the schema config, output is a preset object ready for export or extension.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst preset = {\n  // ...\n  schema: {\n    // ...\n    pgV4UseTableNameForNodeIdentifier: false,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Adding a Root Query Field using makeExtendSchemaPlugin (JavaScript)\nDESCRIPTION: This snippet demonstrates how to add a custom root query field named `httpBinHeaders` using the `makeExtendSchemaPlugin` utility from `graphile-utils`. The resolver for this field uses `node-fetch` to call an external API (`https://httpbin.org/headers`) and returns the JSON response. This is presented as the easiest method for schema extension.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// add-http-bin-plugin.js\nconst { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = makeExtendSchemaPlugin({\n  typeDefs: gql`\n    extend type Query {\n      httpBinHeaders: JSON\n    }\n  `,\n  resolvers: {\n    Query: {\n      async httpBinHeaders() {\n        const response = await fetch(\"https://httpbin.org/headers\");\n        return response.json();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Getting the Current PostgreSQL User - SQL\nDESCRIPTION: This PostgreSQL function returns the current database user using the `current_user` built-in identifier. It's typically used in conjunction with dynamic session role changes or auditing. Preconditions are that the session's role may have been changed, for example by PostGraphile settings. The function is stable, reads no tables, and outputs the current user's name as a string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION get_current_user() RETURNS TEXT AS $$\n  SELECT current_user;\n$$ LANGUAGE SQL STABLE;\n```\n\n----------------------------------------\n\nTITLE: Creating a Graphile Plugin to Add a Custom Field using Hooks in JavaScript\nDESCRIPTION: Defines a Graphile Engine plugin (`MyRandomFieldPlugin`) that demonstrates using hooks. It registers a hook for the `GraphQLObjectType:fields` phase, which is called for every GraphQL object type being built. The hook callback uses the `extend` utility from the `Build` object to add a new `random` field (returning `GraphQLInt`) to the type's fields. This field accepts an optional `sides` argument and resolves to a random integer, using default values provided via the plugin options.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugins.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// No imports required!\n\nmodule.exports = function MyRandomFieldPlugin(\n  builder,\n  { myDefaultMin = 1, myDefaultMax = 100 },\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields, // input object\n      { extend, graphql: { GraphQLInt } }, // Build\n      context, // Context\n    ) => {\n      return extend(fields, {\n        random: {\n          type: GraphQLInt,\n          args: {\n            sides: {\n              type: GraphQLInt,\n            },\n          },\n          resolve(_, { sides = myDefaultMax }) {\n            return (\n              Math.floor(Math.random() * (sides - myDefaultMin + 1)) +\n              myDefaultMin\n            );\n          },\n        },\n      });\n    },\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile in Watch Mode - Bash\nDESCRIPTION: Runs PostGraphile with the --watch flag to enable hot schema reloading when database schemas change. Intended for development environments to boost productivity through live updates. Input is the PostGraphile command with watch flag; endpoints are recreated live.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n$ postgraphile -c \\\"postgres:///mydb\\\" --watch\\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating Constraint-Based Enums with Functions via Domains (SQL)\nDESCRIPTION: Illustrates using a unique constraint (`transportation_mean` on `my_enums`) marked with `@enum` as an enum source. It shows how to create a PostgreSQL domain linked to this constraint-based enum for use in function arguments/return types, ensuring proper GraphQL typing. Two linking methods are shown: naming convention (`[table]_[constraint]_enum_domain`) or a smart comment (`@enum [table]_[constraint]`). Requires the `my_enums` table and the specified unique constraint.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate table my_enums (\n  transportation text not null constraint transportation_mean unique\n);\n\ncomment on constraint transportation_mean on my_enums is E'@enum';\ninsert into my_enums\n  (transportation) values\n  ('CAR'),\n  ('BIKE'),\n  ('SUBWAY');\n\n-- Either follow the convention of [enum_table_name]_[constraint_name]_enum_domain:\ncreate domain my_enums_transportation_mean_enum_domain as text;\n\n-- Or use any name for the domain and add a smart comment referencing the enum\n-- via `[enum_table_name]_[constraint_name]`:\ncreate domain transportation as text;\ncomment on domain transportation is E'@enum my_enums_transportation_mean';\n\n-- Then you can create functions that take this domain as the type of their\n-- arguments or return value like in the previous example.\n```\n\n----------------------------------------\n\nTITLE: Extending TypeScript Node 22 Configuration - JSON\nDESCRIPTION: This JSON snippet customizes the default TypeScript configuration for Node.js 22 by extending @tsconfig/node22 and setting project-specific options. Features include root/output directories and automatic import extension rewriting for interoperability between TypeScript and JavaScript files. Used as tsconfig.json in the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"extends\\\": \\\"@tsconfig/node22/tsconfig.json\\\",\\n  \\\"compilerOptions\\\": {\\n    \\\"erasableSyntaxOnly\\\": true,\\n    \\\"rewriteRelativeImportExtensions\\\": true,\\n    \\\"rootDir\\\": \\\"./src\\\",\\n    \\\"outDir\\\": \\\"./dist\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Polymorphic Enum Type and Single Table - SQL\nDESCRIPTION: Defines an enum 'item_type' enumerating all allowed polymorphic variants and creates a single table 'single_table_items' with common fields and type differentiation. Dependencies include prior existence of the 'polymorphic' schema. Inputs are handled via table column defaults and constraints. This schema enables PostGraphile to generate a polymorphic GraphQL interface given suitable smart tags. The table enforces a primary key and foreign keys for structural integrity.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate type polymorphic.item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\ncreate table polymorphic.single_table_items (\n  id serial primary key,\n\n  -- Rails-style polymorphic column\n  type polymorphic.item_type not null default 'POST'::polymorphic.item_type,\n\n  -- Shared attributes:\n  parent_id int references polymorphic.single_table_items on delete cascade,\n  root_topic_id int constraint single_table_items_root_topic_fkey references polymorphic.single_table_items on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz,\n\n  -- Attributes that may be used by one or more item subtypes.\n  title text,\n  description text,\n  note text,\n  color text\n);\n\n```\n\n----------------------------------------\n\nTITLE: Querying Forum Nodes - GraphQL\nDESCRIPTION: This snippet demonstrates how to query all forum nodes, retrieving metadata and details such as nodeId, id, slug, name, and description for each forum. It requires a GraphQL endpoint generated by PostGraphile with the @graphile-contrib/pg-simplify-inflector plugin enabled. The query expects to return a connection object with a nodes array of forum objects containing the selected fields.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/basic.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forums {\n    nodes {\n      nodeId\n      id\n      slug\n      name\n      description\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Custom Condition in GraphQL\nDESCRIPTION: A GraphQL query showing how to use the custom `containsPostsByUserId` condition (created by the plugin in Example 2) to filter the `allForums` collection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsContainingPostsByUser1 {\n  allForums(condition: { containsPostsByUserId: 1 }) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Persistent Dockerized PostgreSQL (Bash)\nDESCRIPTION: Exports environment variables (`PGHOST`, `PGPORT`) for connecting to the persistent PostgreSQL Docker container via its Unix socket located in the mounted volume. This resets any previous host/port settings for TCP connections.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport PGHOST=/var/run/postgresql/\nexport PGPORT=5432\n```\n\n----------------------------------------\n\nTITLE: Updating a Single Row with pgUpdateSingle in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `pgUpdateSingle` to update a single row in a specified resource (`usersResource`). It identifies the row using a spec (e.g., `{ id: $id }`) and sets specified attributes (e.g., `{ username: $username }`). This function returns a step representing the updated user record, typically obtained via `UPDATE ... RETURNING ...`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgUpdateSingle.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $updatedUser = pgUpdateSingle(\n  usersResource,\n\n  // Find record by:\n  { id: $id },\n\n  // Update these attributes:\n  { username: $username },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining the PlanWrapperFn Type Signature (TypeScript)\nDESCRIPTION: This snippet defines the PlanWrapperFn type, which specifies the required arguments for functions passed as field plan wrappers to makeWrapPlansPlugin. It details the order and purpose of each argument, supporting users in authoring custom wrapper functions that can pass control to the underlying plan or alter its parameters. Required context and argument types are SmartFieldPlanResolver, ExecutableStep, FieldArgs, and FieldInfo.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\ntype PlanWrapperFn = (\\n  plan: SmartFieldPlanResolver,\\n  $source: ExecutableStep,\\n  fieldArgs: FieldArgs,\\n  info: FieldInfo,\\n) => any;\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Tables and a Joining View for Flattening\nDESCRIPTION: This SQL snippet sets up two related tables, `person` and `address`, within the `app_public` schema. It then creates a view named `person_view` that performs an INNER JOIN between these tables on `person.id` and `address.person_id`. The view exposes selected columns (`id`, `country`, `street`) from both tables in a single, flattened structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/views.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_public.person (\n  id serial PRIMARY KEY\n);\n\nCREATE TABLE app_public.address (\n  person_id int PRIMARY KEY REFERENCES app_public.person,\n  country text,\n  street text,\n);\n\nCREATE VIEW person_view AS\n  SELECT person.id, address.country, address.street\n  FROM app_public.person person\n  INNER JOIN app_public.address\n  ON person.id = address.person_id;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function using LANGUAGE plpgsql (SQL)\nDESCRIPTION: Shows the same `add` function as the previous SQL example, but implemented using `LANGUAGE plpgsql`, PostgreSQL's procedural language. It uses a `BEGIN...END;` block and a `RETURN` statement to return the sum of the two integer arguments `a` and `b`. Like the SQL version, it is marked `immutable` and `strict`. PL/pgSQL is needed for more complex logic involving variables, control structures, or triggers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(a int, b int) returns int as $$\nbegin\n  return a + b;\nend;\n$$ language plpgsql immutable strict;\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Query with grafast in Schema-Only Mode (TypeScript)\nDESCRIPTION: Shows how to execute a GraphQL query using the `grafast` function in schema-only mode. It requires passing the generated `schema`, the `resolvedPreset` from `makeSchema`, and a `requestContext` object (can be empty for simple cases) as arguments along with the query source. This approach automatically handles context setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { grafast } from \"grafast\";\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n\nconst args = {\n  schema,\n  // highlight-next-line\n  resolvedPreset,\n  // highlight-next-line\n  requestContext: {},\n  source: /* GraphQL */ `\n    query MyQuery {\n      __typename\n    }\n  `,\n};\nconst result = await grafast(args);\nconsole.dir(result);\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table with Serial PK (SQL)\nDESCRIPTION: This SQL snippet defines the `person` table within the `forum_example` schema. It includes an auto-incrementing integer primary key (`id`), required `first_name` and optional `last_name` columns with length checks, an `about` text field, and a `created_at` timestamp that defaults to the row insertion time. This table structure is intended to store user information for the forum.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncreate table forum_example.person (\n  id               serial primary key,\n  first_name       text not null check (char_length(first_name) < 80),\n  last_name        text check (char_length(last_name) < 80),\n  about            text,\n  created_at       timestamp default now()\n);\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruru HTML Parts via Per-Request Plugin - TypeScript\nDESCRIPTION: This code shows how to create a GraphileConfig plugin that customizes the Ruru HTML meta tags on a per-request basis, ideal for dynamic user-targeted UI. The 'grafserv.hooks.ruruHTMLParts' hook mutates the 'parts' object, appending a 'viewport' meta tag using request-specific logic. Dependencies include 'graphile-config' and a compatible Grafserv/Ruru setup. The plugin registers with a name and version, and relies on the 'extra.request' argument for context. Outputs are reflected in the dynamic HTML served per request. Intended to be added to a Graphile preset or loaded at runtime.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst RuruMetaPlugin: GraphileConfig.Plugin = {\n  name: \"RuruMetaPlugin\",\n  version: \"0.0.0\",\n  grafserv: {\n    hooks: {\n      ruruHTMLParts(_info, parts, extra) {\n        // extra.request gives you access to request details, so you can customize `parts` for the user\n\n        parts.metaTags += `<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />`;\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Addition Function in PostgreSQL (PL/pgSQL)\nDESCRIPTION: Creates a basic PostgreSQL function `add` using the procedural language `LANGUAGE plpgsql`. It accepts two integer arguments (`a` and `b`), uses a `BEGIN...END` block, and returns their sum using the `RETURN` statement. It is also marked `IMMUTABLE` and `STRICT`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\nBEGIN\n  RETURN a + b;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n```\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile V4 Plugin Structure in TypeScript\nDESCRIPTION: A TypeScript example of a custom PostGraphile V4 plugin. It exports a function that takes the `builder` object and uses `builder.hook()` calls to modify inflection, extend the build object, perform actions during initialization (`init`), and add fields to GraphQL object types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { Plugin } from \"graphile-build\";\n\nexport const MyPlugin: Plugin = (builder) => {\n  builder.hook(\"inflection\", (inflection, build) => {\n    return build.extend(inflection, {\n      myInflector(stuff) {\n        return stuff + \"Stuff\";\n      },\n    });\n  });\n\n  builder.hook(\"build\", (build) => {\n    return build.extend(\n      build,\n      { myStuff: () => [\"my\", \"stuff\"] },\n      \"Adding myStuff to build\",\n    );\n  });\n\n  builder.hook(\"init\", (_, build) => {\n    doSomethingWith(build.myStuff());\n    return _;\n  });\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    return build.extend(\n      fields,\n      { myField: { type: build.graphql.GraphQLString } },\n      \"Adding fields from MyPlugin\",\n    );\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Field Argument Using apply Method - Grafast (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the correct modern usage for applyPlan in Grafast: directly invoking fieldArg.apply($target). This approach uses the applyInput helper internally and requires that $target implement the apply method. No return value should be produced. Key parameters include $target (the object/operation being altered) and fieldArg (the argument being applied). No imports are required if context supplies these parameters.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/aap.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction applyPlan($parent, $field, fieldArg, info) {\n  // [...]\n  fieldArg.apply($target);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating pgCondition Child in OR Mode with orPlan - Graphile (JavaScript)\nDESCRIPTION: Demonstrates the use of the orPlan method to instantiate a child pgCondition with logical 'OR' combination of conditions. Requires access to a pgCondition instance, and returns a new pgCondition in OR mode for grouping filter criteria. This is typically used when building dynamic SQL conditions where multiple alternative filters may apply. No parameters are required, and the method is designed for advanced query composition within Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.orPlan()\n```\n\n----------------------------------------\n\nTITLE: Setting Heroku Config for RDS Database URL with SSL (Bash)\nDESCRIPTION: Sets the `DATABASE_URL` environment variable on Heroku for an AWS RDS PostgreSQL database using the Heroku CLI. It includes the `?ssl=true` parameter to enforce an SSL connection, which is necessary when RDS has `force_ssl` enabled. Requires the Heroku CLI to be installed and logged in.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set DATABASE_URL=\"postgres://...rdshost.../db_name?ssl=true\"\n```\n\n----------------------------------------\n\nTITLE: Extending Graphile Hook Scopes in V5 (TypeScript)\nDESCRIPTION: Demonstrates how to add custom properties to the scope objects passed to specific Graphile V5 hooks. This is achieved using TypeScript declaration merging to augment the relevant `GraphileBuild.Scope*` interface, ensuring properties are optional.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n  namespace GraphileBuild {\n    interface ScopeObjectFieldsField {\n      isRootNodeField?: boolean;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Schema Directly with `makeSchema` in JavaScript\nDESCRIPTION: Shows an alternative method to generate the GraphQL schema and resolved preset using the `makeSchema` function directly with a configuration preset. This approach has minimal overhead but does not support PostGraphile's watch mode.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/usage-schema.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { makeSchema } from \"postgraphile\";\nimport preset from \"./graphile.config.js\";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n```\n\n----------------------------------------\n\nTITLE: Sorting GraphQL ObjectType Fields Alphabetically with Graphile Plugin (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a GraphileConfig.Plugin named \\\"SortFieldsAlphabetically\\\", which sorts the fields of each GraphQLObjectType alphabetically. The plugin implements the schema.hooks.GraphQLObjectType_fields method, safely rearranging the input fields object using locale-sensitive string comparison. The plugin must be added last (or use the after config option), as it reorders fields post-creation, and has no side effects besides field ordering. Dependencies include the GraphileConfig types and an understanding of plugin registration order.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/versioning-policy.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Make sure this is the last plugin to be added, and if necessary add\n// `after: [...]` to it containing a list of the names of all the plugins that\n// add fields.\nconst SortFieldsAlphabetically: GraphileConfig.Plugin = {\n  name: \"SortFieldsAlphabetically\",\n  version: \"0.0.0\",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields) {\n        const entries = Object.entries(fields);\n        entries.sort(([a], [z]) => a.localeCompare(z, \"en-US\"));\n        return Object.fromEntries(entries);\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Docker Environment Variables for PostgreSQL - Bash Env File\nDESCRIPTION: Specifies environment variables for Docker PostgreSQL container, including database name, username, and password. Saved as a .env file at repository root and loaded via Docker Compose's env_file. Key parameters: POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD. Output: .env config file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n# DB\\n# Parameters used by db container\\nPOSTGRES_DB=forum_example\\nPOSTGRES_USER=postgres\\nPOSTGRES_PASSWORD=change_me\n```\n\n----------------------------------------\n\nTITLE: Importing makePgSmartTagsPlugin in TypeScript\nDESCRIPTION: This TypeScript snippet shows the necessary import statement to use the `makePgSmartTagsPlugin` function from `postgraphile/utils`. This function is a lower-level utility for creating Smart Tag plugins based on custom rules and matching functions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { makePgSmartTagsPlugin } from \"postgraphile/utils\";\n```\n\n----------------------------------------\n\nTITLE: Installing the @graphile/pg-pubsub Package Using Yarn (Shell)\nDESCRIPTION: This snippet shows the installation of the new @graphile/pg-pubsub package using yarn. This package provides open-source support for GraphQL subscriptions in PostGraphile and must be included in the application's dependencies before activating related features.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/pg-pubsub-migration.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @graphile/pg-pubsub\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Tags File with makePgSmartTagsFromFilePlugin - PostGraphile in JavaScript\nDESCRIPTION: This snippet illustrates how to load a smart tags file from a custom path using the 'makePgSmartTagsFromFilePlugin' from the PostGraphile plugins. The path to the tags file (e.g., JSON or JSONC) is provided as an argument, and the plugin is then appended within the PostGraphile options. This approach is useful if you wish to select a specific file or file extension for tags configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags-file.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst postGraphileOptions = {\\n  appendPlugins: [\\n    require(\\\"postgraphile/plugins\\\").makePgSmartTagsFromFilePlugin(\\n      // JSON and JSONC are also JSON5 compatible, so you can use these extensions if you prefer:\\n      \\\"/path/to/my/tags.file.json\\\",\\n    ),\\n  ],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Calling a Newly Added Inflector in PostGraphile (JavaScript)\nDESCRIPTION: This short JavaScript snippet shows how to call a newly added inflector ('enhanced') after it has been registered via a plugin. Demonstrates that, according to PostGraphile conventions, only arguments from the second parameter onward are supplied by calling code. Outputs the enhanced version of the column name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-inflectors-plugin.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst text = inflection.enhanced(\\\"avatarUrl\\\");\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Compose on Linux (Shell)\nDESCRIPTION: Installs Docker Compose using the `apt` package manager on Debian-based Linux systems. Docker Compose is a tool for defining and running multi-container Docker applications, typically using a YAML configuration file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt install docker-compose\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for User and Friends\nDESCRIPTION: An example GraphQL query requesting the current user's name and the names of their friends. This query is used to illustrate how Grafast builds an operation plan based on the defined schema and plan resolvers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.mdx#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\n{\n  currentUser {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple JOIN Clauses with sql.join in pg-sql2 JavaScript\nDESCRIPTION: Shows how `sql.join` in `pg-sql2` can be used to dynamically append multiple SQL `JOIN` clauses (stored as an array of `sql` fragments) to a base query, using a space as the separator.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst arrayOfSqlInnerJoins = [\n  sql`inner join bar on (bar.foo_id = foo.id)`,\n  sql`inner join baz on (baz.bar_id = bar.id)`,\n];\nsql`select * from foo ${sql.join(arrayOfSqlInnerJoins, \" \")}`;\n// select * from foo inner join bar on (bar.foo_id = foo.id) inner join baz on (baz.bar_id = bar.id)\n```\n\n----------------------------------------\n\nTITLE: Creating Types, Functions, and Applying Multiple Smart Comments - SQL\nDESCRIPTION: This SQL code block demonstrates creation of a custom composite type ('flibble'), a table-returning function ('getFlamble'), and application of several smart comments: renaming types, enforcing not-null constraints, and renaming the function for GraphQL. Dependencies are PostgreSQL and PostGraphile. Key inputs include the custom type and function definition, with smart comments affecting their GraphQL names and nullability.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate type flibble as (f text);\n\ncreate function getFlamble() returns SETOF flibble as $$\n    select (body)::flibble from post\n$$ language sql;\n\ncomment on type flibble is E'@name flamble';\ncomment on column flibble.f is E'@notNull';\ncomment on function getFlamble() is E'@name allFlambles';\n```\n\n----------------------------------------\n\nTITLE: Disabling PgNodeAliasPostGraphile Plugin via CLI\nDESCRIPTION: This command-line instruction demonstrates how to start PostGraphile while skipping the `PgNodeAliasPostGraphile` plugin. Disabling this plugin is necessary when dealing with non-unique table names across different PostgreSQL schemas to prevent issues with non-globally unique Node IDs, ensuring GraphQL type names are used in identifiers instead of potentially conflicting table names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/reserved-keywords.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile --skip-plugins graphile-build-pg:PgNodeAliasPostGraphile\n```\n\n----------------------------------------\n\nTITLE: Defining `sideEffect` with a Single Dependency in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for `sideEffect` when it accepts a single input step. The function takes an `ExecutableStep<T>` as the first argument (`$input`) and a callback function as the second. The callback receives the resolved value of the input step (type `T`) and returns a result (type `R`) or a Promise resolving to `R`. The `sideEffect` function itself returns a new `ExecutableStep<R>` representing the result of the callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction sideEffect<T, R>(\n  $input: ExecutableStep<T>,\n  callback: (input: T) => R | Promise<R>,\n): ExecutableStep<R>;\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Forums Ordered Descending by Creation Date in GraphQL\nDESCRIPTION: This GraphQL query retrieves all forums, specifically ordering them by the `CREATED_AT_DESC` enum value provided by default PostGraphile setup. It fetches the `id` and `name` for each forum node. This exemplifies the standard ordering mechanism that `makeAddPgTableOrderByPlugin` can enhance.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery ForumsNewestToOldest {\n  allForums(orderBy: [CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Inserting Sample Data into Forum Tables - SQL\nDESCRIPTION: This SQL file inserts initial dummy data for testing and development into the forum database. It creates some users and posts for the 'user' and 'post' tables. Inputs: a schema structured as above. Outputs: sample rows in each table. Should only be run once per clean database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\\n\\n/*Create some dummy users*/\\ninsert into public.user (username) values\\n('Benjie'),\\n('Singingwolfboy'),\\n('Lexius');\\n\\n/*Create some dummy posts*/\\ninsert into public.post (title, body, author_id) values\\n('First post example', 'Lorem ipsum dolor sit amet', 1),\\n('Second post example', 'Consectetur adipiscing elit', 2),\\n('Third post example', 'Aenean blandit felis sodales', 3);\n```\n\n----------------------------------------\n\nTITLE: Wrapping Mutation Fields for Validation (JavaScript)\nDESCRIPTION: Demonstrates using `makeWrapResolversPlugin` (Method 1) with a helper function `validateUserData` to apply validation logic before multiple mutation resolvers (`createUser`, `updateUser`, etc.) are executed. The helper creates a resolver wrapper that performs validation based on input arguments before calling the original resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst validateUserData = (propName) => {\n  return async (resolve, source, args, context, resolveInfo) => {\n    const user = args.input[propName];\n\n    await isValidUserData(user); // throws error if invalid\n\n    return resolve();\n  };\n};\n\nmodule.exports = makeWrapResolversPlugin({\n  Mutation: {\n    createUser: validateUserData(\"user\"),\n    updateUser: validateUserData(\"userPatch\"),\n    updateUserById: validateUserData(\"userPatch\"),\n    updateUserByEmail: validateUserData(\"userPatch\"),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Procfile for PostGraphile CLI Deployment (Bash)\nDESCRIPTION: Creates a file named `Procfile` in the project root using the `echo` command and shell redirection (`>>`). The Procfile defines a `web` process type for Heroku, instructing it to run the PostGraphile CLI (`postgraphile`) using the connection string from the `$RDS_URL` environment variable and binding to the host (`0.0.0.0`) and port (`$PORT`) provided by Heroku.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\necho 'web: postgraphile -c $RDS_URL --host 0.0.0.0 --port $PORT' >> Procfile\n```\n\n----------------------------------------\n\nTITLE: Querying All Posts and Authors with GraphQL\nDESCRIPTION: An example GraphQL query demonstrating how to fetch a list of all posts. It requests the `id`, `title`, and `body` for each post node, and also traverses the relationship to fetch the `username` of the author via `userByAuthorId`. This showcases a typical read operation against the PostGraphile API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_24\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  allPosts {\n    nodes {\n      id\n      title\n      body\n      userByAuthorId {\n        username\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating a View with Smart Comments - SQL\nDESCRIPTION: This example demonstrates the usage of E-escaped smart comments applied to a PostgreSQL view with the COMMENT ON VIEW command. Tags can rename the view and restrict certain operations in the schema generated by PostGraphile. Requires a pre-existing view named 'mv_view' in the relevant schema; outputs only affect introspection and have no runtime effect in standard SQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\ncomment on view my_schema.mv_view is\\n  E'@name my_new_view_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Illustrating PL/pgSQL Argument/Column Conflict in ON CONFLICT\nDESCRIPTION: Defines a volatile PL/pgSQL function `upsert_value` to insert or update data. It highlights a common issue where the `ON CONFLICT (id)` clause is ambiguous because PL/pgSQL cannot determine if `id` refers to the table column or the function argument, potentially leading to an error.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\n```sql\ncreate function upsert_value(id int, value text) returns void as $$\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    /* highlight-next-line */\n    on conflict (id) -- This will error\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Compiler for Node.js 18 Projects (json)\nDESCRIPTION: This TypeScript configuration file (tsconfig.json) extends the Node 18 preset and sets various compiler options needed for migrating a PostGraphile V4 plugin. It enables JavaScript file support, sets source and output directories, and configures output of declarations and source maps. Developers can optionally disable 'noImplicitAny' to ease migration from loose types. Ensure @tsconfig/node18 and typescript are installed as devDependencies. Inputs are *.*ts and *.js files in ./src. Outputs are .js and .d.ts in ./dist. Excludes node_modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"extends\\\": \\\"@tsconfig/node18/tsconfig.json\\\",\\n  \\\"compilerOptions\\\": {\\n    // You may want to enable this flag in V4 since V4 types were extremely\\n    // loose (since it was originally written in Flow, not TypeScript):\\n    //\\n    // \\\"noImplicitAny\\\": false,\\n\\n    // If your tests are written in JS you'll need this for subpath importing\\n    // to work:\\n    \\\"allowJs\\\": true,\\n\\n    \\\"rootDir\\\": \\\"./src\\\",\\n    \\\"outDir\\\": \\\"./dist\\\",\\n    \\\"declarationDir\\\": \\\"dist\\\",\\n    \\\"declaration\\\": true,\\n    \\\"sourceMap\\\": true\\n  },\\n  \\\"exclude\\\": [\\\"node_modules\\\"]\\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Middleware Handlers in TypeScript\nDESCRIPTION: Defines the `getMiddleware` function in `src/getMiddleware.ts`, which takes a resolved Graphile Config preset (`GraphileConfig.ResolvedPreset`). It creates a new `Middleware` instance typed with `MyMiddleware` (from `src/interfaces.ts`). It then iterates through the plugins in the preset using `orderedApply` from `graphile-config`, extracting and registering any defined `libraryName.middleware` handlers onto the `Middleware` instance.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/library-authors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"src/getMiddleware.ts\"\nimport { Middleware, orderedApply, resolvePreset } from \"graphile-config\";\n\nexport function getMiddleware(resolvedPreset: GraphileConfig.ResolvedPreset) {\n  // Create your middleware instance. The generic describes the events supported\n  const middleware = new Middleware<MyMiddleware>();\n  // Now apply the relevant middlewares registered by each plugin (if any) to the\n  // Middleware instance\n  orderedApply(\n    resolvedPreset.plugins,\n    (plugin) => plugin.libraryName?.middleware,\n    (name, fn, _plugin) => {\n      middleware.register(name, fn as any);\n    },\n  );\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Schema Structures with Required and Nullable Types - GraphQL - graphql\nDESCRIPTION: This GraphQL schema demonstrates best/worst practices for nullable and non-nullable fields within types. It defines two types, Numbers and Letters, both with required fields, and a Query type returning non-nullable instances. The example serves to illustrate how nulls propagate and why defaults matter in schema design. Dependencies: none, works standalone in any GraphQL environment. Inputs: none; Outputs: defines schema; Limitation: meant only for demonstration, not production use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/why-nullable.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n\"# This is a bad practice GraphQL schema to demonstrate a point.\\n\\ntype Numbers {\\n  one: Int!\\n  two: Int!\\n  three: Int!\\n}\\n\\ntype Letters {\\n  a: String!\\n  b: String!\\n  c: String!\\n}\\n\\ntype Query {\\n  numbers: Numbers!\\n  letters: Letters!\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining QuizEntryAnswer Mutation Inputs and Patches - GraphQL - GraphQL\nDESCRIPTION: These GraphQL input types define the structure necessary for creating, updating, and partially updating a QuizEntryAnswer entity. 'QuizEntryAnswerInput' specifies all fields needed for mutation calls, while 'QuizEntryAnswerPatch' enables partial updates by allowing nullable fields. Dependencies include the existence of types such as Int and String. Required parameters (like quizEntryId and question) ensure key data is always provided for creation, while updates allow selective field modification. Expected input is a JSON object conforming to these shapes. Limitations: types must match schema expectations and required fields must be present for creation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"An input for mutations affecting `QuizEntryAnswer`\"\"\"\ninput QuizEntryAnswerInput {\n  id: Int\n  quizEntryId: Int!\n  question: String!\n  answer: Int\n}\n\n\"\"\"\nRepresents an update to a `QuizEntryAnswer`. Fields that are set will be updated.\n\"\"\"\ninput QuizEntryAnswerPatch {\n  id: Int\n  quizEntryId: Int\n  question: String\n  answer: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Create, Update, Delete Mutations on Table via SQL Smart Comment - SQL\nDESCRIPTION: This SQL snippet applies an @omit smart tag to a table, instructing PostGraphile to exclude create, update, and delete operations. Useful when you want the API to expose only read operations. The table is identified as 'forum_example.book'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table forum_example.book is E'@omit create,update,delete';\n```\n\n----------------------------------------\n\nTITLE: Marking a Field Deprecated Using Directives - GraphQL - GraphQL\nDESCRIPTION: This GraphQL schema code illustrates the use of the @deprecated directive to deprecate the 'firstName' field in the Person type, expressing explicitly via directive syntax the deprecation reason. Expected input is the schema SDL, and output includes GraphQL tooling relaying the deprecation reason to consumers. There are no prerequisites except use in a compliant environment. Main limitation is only applicable for static deprecation messaging.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/index.md#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Person {\n  # The person's first name\n  /* highlight-start */\n  firstName: String @deprecated(\n    reason: \"Use 'name' instead\")\n  /* highlight-end */\n\n  #...\n```\n\n----------------------------------------\n\nTITLE: Resolving PL/pgSQL Upsert Naming Conflict with #variable_conflict\nDESCRIPTION: Provides a solution to the ambiguity shown in the previous `upsert_value` example. By adding the comment directive `#variable_conflict use_column` at the beginning of the function body, it instructs PL/pgSQL to prefer the table column (`my_table.id`) within the `on conflict (id)` clause, resolving the conflict. The function remains `volatile`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncreate function upsert_value(id int, value text) returns void as $$\n#variable_conflict use_column\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    on conflict (id)\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n\n----------------------------------------\n\nTITLE: Executing a GraphQL Subscription Query\nDESCRIPTION: This GraphQL code defines a subscription operation named `MySubscription`. It subscribes to the `currentUserUpdated` field, expecting to receive updates containing the associated `user` object and the `event` string whenever the relevant trigger occurs on the server.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription MySubscription {\n  currentUserUpdated {\n    user\n    event\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint Plugin for Graphile Export (JavaScript)\nDESCRIPTION: This code sample shows how to configure .eslintrc.js to enable and extend the eslint-plugin-graphile-export plugin for JavaScript/TypeScript projects. The configuration enables the plugin by adding 'graphile-export' to the plugins list and 'plugin:graphile-export/recommended' to the extends list, allowing ESLint to automatically check and autofix exportable patterns. Parameters such as 'plugins' and 'extends' must be provided as arrays within the module.exports object, and the configuration should be merged with any existing ESLint settings.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/eslint.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  //...\n  plugins: [\n    //...\n    // highlight-next-line\n    \"graphile-export\",\n    //...\n  ],\n  extends: [\n    //...\n    // highlight-next-line\n    \"plugin:graphile-export/recommended\",\n    //...\n  ],\n  //...\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing PostGraphile Amber Preset in JavaScript\nDESCRIPTION: This snippet demonstrates a minimal PostGraphile configuration in a `graphile.config.mjs` file. It imports the `PostGraphileAmberPreset` and exports a preset object that extends it. This serves as the basic starting point for a PostGraphile setup using ES Modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"graphile.config.mjs\"\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [PostGraphileAmberPreset],\n};\n\nexport default preset;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Variables for PostGraphile Container in INI\nDESCRIPTION: Updates the `.env` file to include `DATABASE_URL` and `PORT` environment variables. `DATABASE_URL` specifies the connection string for the PostgreSQL database container (using the service name 'db'), and `PORT` defines the port on which the PostGraphile Node.js application will listen.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[...]\\n# GRAPHQL\\n# Parameters used by graphql container\\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\\nPORT=5433\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Type with Computed Fields (GraphQL)\nDESCRIPTION: Illustrates how PostGraphile extends the generated `Person` GraphQL type with computed fields based on specific PostgreSQL functions. The `person_full_name` function becomes the `fullName` field (returning `String`), and the `person_latest_post` function becomes the `latestPost` field (returning a `Post` object).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\ntype Person {\n  id: Int!\n  firstName: String!\n  lastName: String\n  ...\n  fullName: String\n  latestPost: Post\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Member Name OrderBy Plugin (V4) in TypeScript\nDESCRIPTION: Shows a V4 example of creating an `OrderByMemberNamePlugin` for the `organization_memberships` table in the `app_public` schema. It uses `makeAddPgTableOrderByPlugin` and `orderByAscDesc`. The `ordersGenerator` callback defines a SQL fragment that selects the `name` from the related `users` table based on the `user_id` from the `organization_memberships` table alias, enabling ordering by member name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst OrderByMemberNamePlugin = makeAddPgTableOrderByPlugin(\n  \"app_public\",\n  \"organization_memberships\",\n  ({ pgSql: sql }) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"member\"));\n    return orderByAscDesc(\n      \"MEMBER_NAME\",\n      // Order fragment callback:\n      ({ queryBuilder }) => {\n        return sql.fragment`(\n          select ${sqlIdentifier}.name\n          from app_public.users as ${sqlIdentifier}\n          where ${sqlIdentifier}.id = ${queryBuilder.getTableAlias()}.user_id\n          limit 1\n        )`;\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using access() to Retrieve Nested Data in TypeScript\nDESCRIPTION: Demonstrates how to use the `access` function to retrieve a simple property ('id' from `$user`) and a deeply nested property ('id' within a nested 'user' object inside the 'patches' array at index 0 from `$args.get(\"input\")`). This function bypasses standard `.get()`/`.at()` methods, which should be used with caution as noted in the surrounding text warnings.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/access.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst $userId = access($user, \"id\");\nconst $firstPatchUserId = access($args.get(\"input\"), [\n  \"patches\",\n  0,\n  \"user\",\n  \"id\",\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom PostGraphile Subscription Plugin in JavaScript\nDESCRIPTION: This JavaScript code defines a PostGraphile plugin using `makeExtendSchemaPlugin` from `graphile-utils`. It extends the GraphQL schema to add a `currentUserUpdated` subscription field to the `Subscription` type. The `@pgSubscription` directive from `@graphile/pg-pubsub` is used to dynamically determine the PostgreSQL LISTEN topic based on the user's JWT claims. A resolver is provided for the `UserSubscriptionPayload` type to fetch user data based on the event received from the subscription.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// MySubscriptionPlugin.js\nconst { makeExtendSchemaPlugin, gql, embed } = require(\"graphile-utils\");\n// or: import { makeExtendSchemaPlugin, gql, embed } from 'graphile-utils';\n\nconst currentUserTopicFromContext = async (_args, context, _resolveInfo) => {\n  if (context.jwtClaims.user_id) {\n    return `graphql:user:${context.jwtClaims.user_id}`;\n  } else {\n    throw new Error(\"You're not logged in\");\n  }\n};\n\nmodule.exports = makeExtendSchemaPlugin(({ pgSql: sql }) => ({\n  typeDefs: gql`\n    type UserSubscriptionPayload {\n      # This is populated by our resolver below\n      user: User\n\n      # This is returned directly from the PostgreSQL subscription payload (JSON object)\n      event: String\n    }\n\n    extend type Subscription {\n      \"\"\"\n      Triggered when the current user's data changes:\n\n      - direct modifications to the user\n      - when their organization membership changes\n      \"\"\"\n      currentUserUpdated: UserSubscriptionPayload @pgSubscription(topic: ${embed(\n        currentUserTopicFromContext,\n      )})\n    }\n  `,\n\n  resolvers: {\n    UserSubscriptionPayload: {\n      // This method finds the user from the database based on the event\n      // published by PostgreSQL.\n      //\n      // In a future release, we hope to enable you to replace this entire\n      // method with a small schema directive above, should you so desire. It's\n      // mostly boilerplate.\n      async user(\n        event,\n        _args,\n        _context,\n        { graphile: { selectGraphQLResultFromTable } },\n      ) {\n        const rows = await selectGraphQLResultFromTable(\n          sql.fragment`app_public.users`,\n          (tableAlias, sqlBuilder) => {\n            sqlBuilder.where(\n              sql.fragment`${tableAlias}.id = ${sql.value(event.subject)}`,\n            );\n          },\n        );\n        return rows[0];\n      },\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Remapping Object Keys with remapKeys in TypeScript\nDESCRIPTION: Demonstrates how to use the remapKeys function to create a new object with specified properties from an original object, renamed according to the provided mapping. This snippet depends on the remapKeys function being available in scope. Inputs include the original object and a mapping object; output is a new object with keys as specified by the mapping. The approach is particularly useful when optimizing or transforming data structures.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/remapKeys.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $mapped = remapKeys(\n  $original,\n\n  // Take the `first_name` and `id` properties of the original object, and\n  // return a new object where these are stored into the `name` and `row_id`\n  // properties respectively.\n  {\n    name: \"first_name\",\n    row_id: \"id\",\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Granting Role Permissions in Google Cloud SQL (SQL)\nDESCRIPTION: Provides the SQL command necessary to grant membership of one role (e.g., `anonymous`) to another role (e.g., `postgres`) within a PostgreSQL database hosted on Google Cloud SQL. This is required because the default `postgres` user in Cloud SQL is not a superuser and needs explicit permission to switch to other roles using `SET ROLE`, a common pattern used by PostGraphile for authentication and authorization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-gcp.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nGRANT anonymous TO postgres;\n```\n\n----------------------------------------\n\nTITLE: Wrapping User.email Plan to Convert to Lower Case using makeWrapPlansPlugin (Method 1) in TypeScript\nDESCRIPTION: Demonstrates using Method 1 of `makeWrapPlansPlugin` to wrap the plan for the `User.email` field. It retrieves the original email plan result by calling `plan()` and then applies `toLowerCase()` using a `lambda` step from `postgraphile/grafast`. This creates a plugin that ensures user emails are always returned in lower case.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\nimport { lambda } from \"postgraphile/grafast\";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan) {\n      const $email = plan();\n      return lambda($email, (email) => email.toLowerCase());\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Running Docker Containers for GraphQL and PostgreSQL Services - Shell Commands\nDESCRIPTION: This shell script demonstrates various docker-compose up commands to start containers either for all or specific services (db, graphql), and also how to run them in daemon mode. These commands orchestrate service lifecycles as defined by Docker Compose, providing flexible options for background or foreground container execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n# Run containers for all services in docker-compose.yml\\n$ docker-compose up\\n\\n# Run containers as daemon (in background)\\n$ docker-compose up -d\\n\\n# Run only the database container as daemon\\n$ docker-compose up -d db\\n\\n# Run only the GraphQL container as daemon\\n$ docker-compose up -d graphql\n```\n\n----------------------------------------\n\nTITLE: Implementing at() for List Steps in Grafast (TypeScript)\nDESCRIPTION: This snippet shows how to implement the at() method for a custom Step subclass representing a list in Grafast. The method receives an integer index and delegates access via the access utility, which abstracts step indexing. It ensures conformity with Grafast expectations for list-like behavior. Inputs: index (integer). Output: step accessing the respective index.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { access } from \"grafast\";\n\nclass MyListStep extends Step {\n  // ...\n\n  at(index) {\n    // Your step may implement a more optimized solution here.\n    return access(this, index);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with a Default Role - Bash\nDESCRIPTION: This bash snippet demonstrates how to launch PostGraphile specifying both the database authentication user and a default role to use for unauthenticated requests or when no explicit role is set. Requires PostGraphile CLI and database access; '--default-role' flag is set to designate the fall-back role for connections. Inputs are the Postgres connection string and the default role's name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/default-role.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb --default-role default_role\n```\n\n----------------------------------------\n\nTITLE: Visualizing PostGraphile V5 Module Dependencies with Mermaid\nDESCRIPTION: This Mermaid diagram illustrates the relationships and dependencies between various packages within the PostGraphile V5 ecosystem. It uses a top-down graph (`graph TD`) to show how core components like `postgraphile`, `grafserv`, `grafast`, `graphile-build`, and `graphile-config` interact with each other, configuration files, presets, and specialized modules like `@dataplan/pg` and `pg-introspection`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/index.mdx#_snippet_20\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD;\n  postgraphile-->grafserv;\n  grafserv-->ruru;\n  ruru-->ruru-components;\n  postgraphile-->graphile-build;\n  postgraphile-->graphile-config;\n  graphile-config-->CONFIG[\"graphile.config.js\"];\n  CONFIG-->AMBER[\"postgraphile/presets/amber\"];\n  AMBER-->graphile-build;\n  AMBER-->graphile-build-pg;\n  CONFIG-->graphile-utils;\n  CONFIG-->dataplan__pg_adaptors_pg[\"@dataplan/pg/adaptors/pg\"];\n  grafserv-->grafast;\n  graphile-build-->grafast;\n  graphile-build-pg-->grafast;\n  dataplan__pg-->grafast;\n  dataplan__json-->grafast;\n  %% graphile;\n  %% graphile-export;\n  %% eslint-plugin-graphile-export;\n  graphile-build-pg-->dataplan__pg[\"@dataplan/pg\"];\n  graphile-build-pg-->dataplan__json[\"@dataplan/json\"];\n  graphile-build-pg-->pg-introspection;\n  graphile-build-pg-->pg-sql2;\n```\n\n----------------------------------------\n\nTITLE: Manual Application Using applyInput - Grafast (TypeScript)\nDESCRIPTION: This TypeScript snippet provides an equivalent lower-level implementation for applying a field argument in Grafast. It extracts the argument type and value from info and fieldArg, respectively, and invokes applyInput to create a callback, which is then passed to $target.apply. Dependencies include the applyInput utility and valid construction of info, fieldArg, and $targetâ€”the function must not return a value. Input variables are handled at runtime to avoid branching at plan-time.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/aap.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction applyPlan($parent, $field, fieldArg, info) {\n  // [...]\n  // fieldArg.apply($target) is roughly equivalent to:\n  const argType = info.arg.type;\n  const $value = fieldArg.getRaw();\n  const $callback = applyInput(argType, $value);\n  $target.apply($callback);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Smart Comments to Columns with Escaped Newlines - SQL\nDESCRIPTION: This snippet demonstrates how to set a multi-line smart comment on a PostgreSQL column using E-escaped (\n) newlines. It uses the COMMENT ON statement and an E-prefixed string constant to inject smart tags and description. Prerequisites are an existing schema, table, and column, and the code is to be run within a PostgreSQL SQL environment. Key parameters include the schema, table, and column name, while expected output is that the comment becomes available for PostGraphile introspection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\\n  E'@name meta\\\\n@isImportant\\\\n@jsonField date timestamp\\\\n@jsonField name text\\\\n@jsonField episode enum ONE=1 TWO=2\\\\nThis field has a load of arbitrary tags.';\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via .postgraphilerc.js in JavaScript\nDESCRIPTION: Example configuration within a `.postgraphilerc.js` file demonstrating how to enable PostGraphile plugins. Plugins are listed in an array assigned to the `options.plugins` property.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nmodule.exports = {\n  options: {\n    plugins: [\n      \"@graphile/operation-hooks\",\n      \"@graphile/pg-pubsub\",\n      \"@graphile/pro\",\n    ],\n    connection: \"postgres:///my_db\",\n    schema: [\"app_public\"],\n    // ...\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Introspection Query - GraphQL\nDESCRIPTION: This GraphQL snippet shows an introspection query which can be run against the configured GraphQL endpoint for schema metadata. It queries for the root query type and details on all available fields and their descriptions. No dependencies except a running GraphQL server on http://localhost:5050 are required. Output is the introspection data according to the schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_25\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\\n  __schema {\\n    queryType {\\n      name\\n      fields {\\n        name\\n        description\\n      }\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Simple Track Data with GraphQL\nDESCRIPTION: A simple GraphQL query retrieving the first 20 tracks with their IDs and names. This query is used as a baseline benchmark, demonstrating PostGraphile handling approximately 3250 requests per second under specific test conditions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/performance.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery tracks_media_first_20 {\n  allTracksList(first: 20) {\n    trackId\n    name\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Condition to WHERE Clause with where - Graphile (JavaScript)\nDESCRIPTION: Utilizes the where method of pgCondition to append a condition to the set of WHERE clauses. This method cannot be used when pgCondition is in 'having' mode. The parameter condition represents the predicate to be included in the SQL WHERE list. Designed for advanced dynamic query building scenarios within Graphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.where(condition)\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Sponsor Page in MDX\nDESCRIPTION: Imports necessary React components like `Sponsor`, `Sponsors`, `SponsorButtons` from the local project structure (`@site/src/components`) and `Link` from `@docusaurus/Link`. It also imports CSS Modules (`styles`) for styling. These imports are dependencies required for rendering the sponsor page content and functionality within a Docusaurus MDX file.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/sponsor.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Sponsor from \"@site/src/components/Sponsor\";\nimport Sponsors from \"@site/src/components/Sponsors\";\nimport SponsorButtons from \"@site/src/components/SponsorButtons\";\nimport Link from \"@docusaurus/Link\";\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with a Specific Database Role - Bash\nDESCRIPTION: This Bash command launches the PostGraphile server using a connection string that specifies the previously created database role and password (`forum_example_postgraphile:xyz`). PostGraphile and Node.js must be installed. The environment must allow local TCP connections to Postgres on the default port. No other arguments are needed, though the database ('mydb') must exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://forum_example_postgraphile:xyz@localhost/mydb\n```\n\n----------------------------------------\n\nTITLE: Retrieving Updated Attributes with pgUpdateSingle.get in TypeScript\nDESCRIPTION: Shows how to use the `.get(attr)` method on the step returned by `pgUpdateSingle` (e.g., `$updatedUser`) to retrieve the value of a specific attribute from the row *after* it has been updated. This functionality relies on the underlying `UPDATE ... RETURNING ...` SQL syntax. The example retrieves the 'updated_at' attribute.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgUpdateSingle.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst $updatedAt = $updatedUser.get(\"updated_at\");\n```\n\n----------------------------------------\n\nTITLE: Using Single-Dependency Lambda Step Example in TypeScript\nDESCRIPTION: This example demonstrates using the `lambda` step function to create a new step (`$oneBased`) from an existing step (`$zeroBased`). The callback function takes the resolved value (`zeroBased`) and returns `zeroBased + 1`. The `isSyncAndSafe` flag is set to `true`, indicating the callback is synchronous, does not throw errors, and has no side effects, allowing for optimization. This is suitable for trivial synchronous calculations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/lambda.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Takes a step representing a zero-based index, and converts it to a one-based\n// index by adding one to it.\nconst $oneBased = lambda($zeroBased, (zeroBased) => zeroBased + 1, true);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Fields with Early Hooks using `fieldWithHooks` in Graphile Crystal (JavaScript)\nDESCRIPTION: This example demonstrates utilizing the `fieldWithHooks` function available in the context of a `GraphQLInputObjectType:fields` hook in Graphile Crystal. It defines an `id` field, calling `addDataGenerator` within the field's definition callback provided to `fieldWithHooks` to attach data generation logic early. The `extend` utility is used to add this newly defined field to the input object type's fields. Requires `GraphQLNonNull` and `GraphQLString` for type definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/context-object.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nbuilder.hook(\"GraphQLInputObjectType:fields\",\n  (\n    fields,\n    { extend, resolveAlias },\n    /* highlight-next-line */\n    { fieldWithHooks }\n  ) => {\n    // TODO: if (...) return fields;\n    return extend(fields, {\n      /* highlight-start */\n      id: fieldWithHooks(\"id\", ({ addDataGenerator }) => {\n        addDataGenerator(({ alias }) => {\n          return {\n            map: obj => ({ [alias]: obj.ID }),\n          };\n        });\n        return {\n          type: new GraphQLNonNull(GraphQLString),\n          resolve: resolveAlias,\n        };\n      }),\n      /* highlight-end */\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Re-initializing the Database Volume and Image\nDESCRIPTION: Outlines the shell commands required to completely reset the PostgreSQL database when schema changes in `/db/init` need to be applied. This involves stopping running containers (`docker-compose down`), listing Docker volumes (`docker volume ls`), removing the specific database volume (`docker volume rm <your_repository_name>_db`), removing the cached database Docker image (`docker rmi db`) to force a rebuild, and finally starting the containers again (`docker-compose up`), which rebuilds the image and re-runs the initialization scripts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n# Stop running containers\n$ docker-compose down\n\n# List Docker volumes\n$ docker volume ls\n\n# Delete volume\n$ docker volume rm <your_repository_name>_db\n\n# Delete database image to force rebuild\n$ docker rmi db\n\n# Run containers (will automatically rebuild the image)\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Safely Setting Dynamic Object Keys with te.lit() in JavaScript\nDESCRIPTION: This snippet demonstrates using `te.lit()` within a `te.run` template literal to safely set properties on a JavaScript object created with `Object.create(null)`. It highlights how `te.lit()` can embed potentially unsafe keys like `\"__proto__\"` securely into the generated code. The example depends on the `@graphile/crystal` library (specifically `te` which provides `run` and `lit`) and uses the standard `assert` module for verification.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-lit.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// This is a perfectly reasonable key\nconst key1 = \"one\";\n\n// Note this key would be unsafe to set on an object created via `{}`, but is\n// fine for `Object.create(null)`\nconst key2 = \"__proto__\";\n\nconst obj = te.run`\\\n  const obj = Object.create(null);\n  obj[${te.lit(key1)}] = 1;\n  obj[${te.lit(key2)}] = { str: true };\n  return obj;\n`;\n\nassert.equal(typeof obj, \"object\");\nassert.equal(obj.one, 1);\nassert.deepEqual(obj.__proto__, { str: true });\n```\n\n----------------------------------------\n\nTITLE: Mounting Express Middleware with Subpath Proxy - JavaScript\nDESCRIPTION: This snippet shows how to mount PostGraphile middleware under a subpath in Express, including configuration for external URL base when using a proxy. The example provides the correct use of Express's 'app.use' for path mounting and demonstrates configuring route options for use with a proxy prefix. Dependencies: Express.js, postgraphile package, database connections and schema, and proper proxy configuration if used. Inputs are the mount path, DB connection, schema(s), and postgraphile options. Outputs are correctly routed GraphQL and GraphiQL interfaces; ensure routes and proxies match your deployment environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Assuming you combine both Express subpath AND an external\n// proxy which mounts your express app at `/myproxypath`, you\n// should provide options like this:\napp.use(\n  \"/path/to\",\n  postgraphile(db, schemas, {\n    externalUrlBase: \"/myproxypath/path/to\",\n    graphqlRoute: \"/graphql\",\n    graphiql: true,\n    graphiqlRoute: \"/graphiql\",\n  }),\n);\n// Then you can load GraphiQL at `/myproxypath/path/to/graphiql`\n// and it will know to connect to GraphQL at\n// `/myproxypath/path/to/graphql`\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Table for Products - SQL\nDESCRIPTION: This SQL snippet creates a product table with UUID primary key, text name, and integer price_in_us_cents columns. Used as the backing PostgreSQL schema for a Product GraphQL type in PostGraphile. Input is a raw SQL statement to be executed on a PostgreSQL database. No application-specific dependencies, but intended for use with PostGraphile's introspection and code generation features.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table product (\n  id uuid primary key,\n  name text not null,\n  price_in_us_cents integer not null\n);\n```\n\n----------------------------------------\n\nTITLE: Resolving PL/pgSQL ON CONFLICT Ambiguity with #variable_conflict\nDESCRIPTION: Provides a solution to the PL/pgSQL `ON CONFLICT` ambiguity using the `#variable_conflict use_column` directive. This tells PostgreSQL to prioritize the table column named `id` within the `ON CONFLICT (id)` clause, resolving the conflict between the column and the function argument.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\n```sql {2}\ncreate function upsert_value(id int, value text) returns void as $$\n#variable_conflict use_column\nbegin\n  insert into my_table (id, value)\n    values(id, value)\n    on conflict (id)\n    do update set value = excluded.value;\nend;\n$$ language plpgsql volatile;\n```\n```\n\n----------------------------------------\n\nTITLE: Printing Active Configuration with Graphile CLI\nDESCRIPTION: Executes the `graphile config print` command via the command line. This command displays the final, resolved configuration settings that PostGraphile is currently using, taking into account the configuration file, loaded presets, and default values, as illustrated in the accompanying screenshot.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/v5-new-feature-summary.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngraphile config print\n```\n\n----------------------------------------\n\nTITLE: Importing makeJSONPgSmartTagsPlugin with TypeScript\nDESCRIPTION: Shows how to import the `makeJSONPgSmartTagsPlugin` function from the `graphile-utils` package using TypeScript's `require`. This function allows defining smart tags configuration directly as a JavaScript object instead of reading from a file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst { makeJSONPgSmartTagsPlugin } = require(\"graphile-utils\");\n```\n```\n\n----------------------------------------\n\nTITLE: Populating PostgreSQL with Dummy Data - SQL\nDESCRIPTION: Inserts example rows into 'user' and 'post' tables within the forum_example database. Useful for initial development and demonstration. Requires schema as defined above. Input: SQL commands; Output: test data populated into database.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\n\\connect forum_example;\\n\\n/*Create some dummy users*/\\nINSERT INTO public.user (username) VALUES\\n('Benjie'),\\n('Singingwolfboy'),\\n('Lexius');\\n\\n/*Create some dummy posts*/\\nINSERT INTO public.post (title, body, author_id) VALUES\\n('First post example', 'Lorem ipsum dolor sit amet', 1),\\n('Second post example', 'Consectetur adipiscing elit', 2),\\n('Third post example', 'Aenean blandit felis sodales', 3);\n```\n\n----------------------------------------\n\nTITLE: Annotating a Materialized View with Smart Comments - SQL\nDESCRIPTION: This snippet illustrates using smart comments to annotate a PostgreSQL materialized view via COMMENT ON MATERIALIZED VIEW. The smart tags enable customization for PostGraphile, such as renaming and configuration. Prerequisite is an existing materialized view; no further dependencies. Output is annotation only, visible to documentation systems or PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncomment on materialized view my_schema.mv_view is\\n  E'@name my_new_view_name\\\\n@omit update,delete\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Defining PlanWrapperRules and PlanWrapperRulesGenerator Interfaces for makeWrapPlansPlugin (Method 1) in TypeScript\nDESCRIPTION: Defines the TypeScript interfaces `PlanWrapperRules` and `PlanWrapperRulesGenerator` used by Method 1 of `makeWrapPlansPlugin`. `PlanWrapperRules` is a nested map where keys are GraphQL type names and field names, and values are either a `PlanWrapperRule` object or a `PlanWrapperFn` directly. `PlanWrapperRulesGenerator` is a function accepting the `build` object and returning `PlanWrapperRules`, useful for accessing build-time information.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PlanWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\n  };\n}\n\ntype PlanWrapperRulesGenerator = (\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\n) => PlanWrapperRules;\n```\n\n----------------------------------------\n\nTITLE: Building a Basic GraphQL Schema with graphile-build (JavaScript)\nDESCRIPTION: Demonstrates building a GraphQL schema using the `buildSchema` function from `graphile-build` with its `defaultPlugins`. It requires `graphile-build` and `graphql` (specifically `printSchema` from `graphql/utilities`). The resulting schema object is then asynchronously retrieved and printed to the console using `printSchema`. An alternative `async/await` syntax is noted in a comment.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/getting-started.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst { buildSchema, defaultPlugins } = require(\"graphile-build\");\nconst { printSchema } = require(\"graphql/utilities\");\n\nbuildSchema(defaultPlugins).then((schema) => {\n  console.log(printSchema(schema));\n});\n// ES2017: const schema = await buildSchema(defaultPlugins);\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo GraphQL IntelliSense in JavaScript Projects\nDESCRIPTION: This snippet provides the recommended structure for the apollo.config.js file, which informs the Apollo extension in VSCode about which files to include or exclude for GraphQL IntelliSense. Dependencies include Node.js and the Apollo GraphQL tooling. Key parameters are 'localSchemaFile' (the generated GraphQL schema), 'excludes' (to prevent conflicting sources), and 'includes' (the files where GraphQL should be detected). Input should be a correct schema file and project source layout; output is optimized IntelliSense support within your IDE.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-schema.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  client: {\n    excludes: [\n      \"**/node_modules\",\n      \"**/__tests__\",\n      \"**/generated/**/*.{ts,tsx,js,jsx,graphql,gql}\",\n    ],\n    includes: [\"src/**/*.{ts,tsx,js,jsx,graphql,gql}\"],\n    service: {\n      name: \"client\",\n      localSchemaFile: \"./src/generated/schema.graphql\",\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Explaining the SQL Structure Generated by pgUnionAll\nDESCRIPTION: This SQL snippet illustrates the complex query structure generated by `pgUnionAll` to efficiently handle `UNION ALL` operations with custom conditions, ordering, and pagination. It features nested selects: an inner select fetches and orders data from individual tables with limits, a middle select prepares data for the union, the `UNION ALL` combines results, and an outer select applies final ordering, limit/offset, and casts fields to their correct types. The use of `row_number()` ensures stable ordering.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgUnionAll.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- OUTER SELECT\nselect\n  __union__.\"0\"::text,\n  __union__.\"1\"::text\nfrom (\n    -- MIDDLE SELECT\n    select\n      __first_table__.\"0\",\n      __first_table__.\"1\",\n      __first_table__.\"2\",\n      \"n\"\n    from (\n      -- INNER SELECT\n      select\n        __first_table__.\"column1\" as \"0\",\n        __first_table__.\"id\" as \"1\",\n        'FirstTable' as \"2\",\n        row_number() over (partition by 1) as \"n\"\n      from first_table as __first_table__\n      where ...\n      order by __first_table__.\"column1\"\n      limit ...\n    )\n  -- Any number of additional \"middle selects\" from different tables\n  -- via 'union all'\n  union all\n    select\n  ...\n  order by\n    \"0\" desc,\n    \"n\" asc,\n    \"2\" asc\n  limit ...\n  offset ...\n) __union__\n```\n\n----------------------------------------\n\nTITLE: Combining Plugins to Make User Email Conditionally Nullable in JavaScript\nDESCRIPTION: This JavaScript code demonstrates combining `makeChangeNullabilityPlugin` and `makeWrapResolversPlugin` from `graphile-utils`. First, it makes the `User.email` field nullable. Then, it wraps the `email` resolver to return the email value only if the requesting user's ID (from JWT claims) matches the user record's ID; otherwise, it returns null. This setup effectively restricts access to a user's email to the user themselves.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-change-nullability-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst {\n  makeChangeNullabilityPlugin,\n  makeWrapResolversPlugin,\n  makePluginByCombiningPlugins,\n} = require(\"graphile-utils\");\n\nmodule.exports = makePluginByCombiningPlugins(\n  // 1: make User.email nullable:\n  makeChangeNullabilityPlugin({\n    User: {\n      email: true,\n    },\n  }),\n\n  // 2: return null unless the user id matches the current logged in user_id\n  makeWrapResolversPlugin({\n    User: {\n      email: {\n        requires: {\n          siblingColumns: [{ column: \"id\", alias: \"$user_id\" }],\n        },\n        resolve(resolver, user, args, context, _resolveInfo) {\n          if (context.jwtClaims.user_id !== user.$user_id) return null;\n          return resolver();\n        },\n      },\n    },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile Console Warning for Missing Ref Relation\nDESCRIPTION: Displays a sample warning message output by PostGraphile when it encounters a `@ref` definition that lacks a corresponding underlying foreign key relationship or `@foreignKey` smart tag. This indicates that the specified 'via' path could not be resolved.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/refs.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nWhen processing ref for resource 'posts', could not find matching relation for\nvia:'(author_id)->users'\n```\n\n----------------------------------------\n\nTITLE: Querying Single Scalar Field via GraphQL (GraphQL)\nDESCRIPTION: This GraphQL snippet queries the single scalar field 'randomNumber', which is mapped from a custom SQL function in the schema. It demonstrates reading a numeric value directly from the API, serving as a basic query example for custom scalar fields. The query requires the @graphile-contrib/pg-simplify-inflector plugin for field naming and expects the schema to expose a field called 'randomNumber'.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-queries.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  randomNumber\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Root Query Field using Raw Plugin API Hook (JavaScript)\nDESCRIPTION: This snippet shows how to add the `httpBinHeaders` root query field using the low-level Graphile Engine plugin API. It hooks into `GraphQLObjectType:fields`, checks if the current scope is the root query (`isRootQuery`), retrieves the existing `JSON` type using `getTypeByName`, and defines the field with its resolver. The resolver conditionally returns JSON or text based on the `pgExtendedTypes` option (controlled by PostGraphile's `--dynamic-json`). Requires `node-fetch`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// add-http-bin-plugin-raw.js\nconst fetch = require(\"node-fetch\");\n\nfunction AddHttpBinPlugin(builder, { pgExtendedTypes }) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields, // Input object - the fields for this GraphQLObjectType\n      { extend, getTypeByName }, // Build object - handy utils\n      { scope: { isRootQuery } }, // Context object - used for filtering\n    ) => {\n      if (!isRootQuery) {\n        // This isn't the object we want to modify:\n        // return the input object unmodified\n        return fields;\n      }\n\n      // We don't want to introduce a new JSON type as that will clash,\n      // so let's find the JSON type that other fields use:\n      const JSONType = getTypeByName(\"JSON\");\n\n      return extend(fields, {\n        httpBinHeaders: {\n          type: JSONType,\n          async resolve() {\n            const response = await fetch(\"https://httpbin.org/headers\");\n            if (pgExtendedTypes) {\n              // This setting is enabled through postgraphile's\n              // `--dynamic-json` option, if enabled return JSON:\n              return response.json();\n            } else {\n              // If Dynamic JSON is not enabled, we want a JSON string instead\n              return response.text();\n            }\n          },\n        },\n      });\n    },\n  );\n}\n\nmodule.exports = AddHttpBinPlugin;\n```\n\n----------------------------------------\n\nTITLE: Building JSON Objects in SQL with sql.join() - JavaScript\nDESCRIPTION: This code constructs a Postgres JSON object using json_build_object, mapping JavaScript objects to SQL identifiers and values. It uses sql.join() to dynamically build the key-value pairs, handling proper quoting and escaping. Dependencies include the sql-template-tag library. Key parameters include the alias (as the JSON key) and the sqlFragment (as the value). The output SQL creates a JSON object with the given aliases as keys and corresponding columns as values.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-join.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fragments = [\n  { alias: \"name\", sqlFragment: sql.identifier(\"user\", \"name\") },\n  { alias: \"age\", sqlFragment: sql.identifier(\"user\", \"age\") },\n];\nsql`\n  json_build_object(\n    ${sql.join(\n      fragments.map(\n        ({ sqlFragment, alias }) => sql`${sql.literal(alias)}, ${sqlFragment}`,\n      ),\n      \",\\n\",\n    )}\n  )`;\n```\n\n----------------------------------------\n\nTITLE: Applying Filtering to Functions via GraphQL Query (GraphQL)\nDESCRIPTION: These GraphQL queries show how users utilize 'condition' fields with filterable functions annotated in PostgreSQL. The syntax allows filtering either by direct field values from function result sets or by computed scalar returns, improving client-side flexibility. Result is a filtered set or list in response.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_18\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  # If the function returns a set of table rows\n  foo(condition: {firstName: \"Alice\"}) { ... }\n\n  # If the function return a scalar\n  allUsers(condition: {foo: \"FOO_VALUE\"}) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the PgPolymorphicTypeMap Interface in TypeScript\nDESCRIPTION: Describes the TypeScript interface `PgPolymorphicTypeMap`, used by the `pgPolymorphic` function, within commented-out documentation. It maps GraphQL type names to objects containing a `match` function (to determine if a specifier matches the type at runtime) and a `plan` function (to generate the appropriate plan step for the matched type), facilitating dynamic type resolution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface PgPolymorphicTypeMap {\n  [typeName: string]: {\n    match(specifier: any): boolean;\n    plan(\n      $specifier: ExecutableStep,\n      $item: PgSelectSingleStep | PgClassExpressionStep,\n    ): ExecutableStep;\n  };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom OrderBy Plugin (V4) in TypeScript\nDESCRIPTION: Provides a V4 example using `makeAddPgTableOrderByPlugin` and `orderByAscDesc` to create a custom order-by plugin (`OrderByAveragePetIdPlugin`) for the `users` table in the `graphile_utils` schema. It defines an order (`PET_ID_AVERAGE`) based on the average `id` of related pets, calculated using a SQL fragment generated within the `ordersGenerator` callback function. Nulls handling is specified using `nulls: \"last-iff-ascending\"`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst OrderByAveragePetIdPlugin = makeAddPgTableOrderByPlugin(\n  \"graphile_utils\",\n  \"users\",\n  (build) => {\n    const { pgSql: sql } = build;\n    const sqlIdentifier = sql.identifier(Symbol(\"pet\"));\n\n    const customOrderBy = orderByAscDesc(\n      \"PET_ID_AVERAGE\", // this is a ridiculous and unrealistic column but it will serve for testing purposes\n      (helpers) => {\n        const { queryBuilder } = helpers;\n\n        const orderByFrag = sql.fragment`(\n          select avg(${sqlIdentifier}.id)\n          from graphile_utils.pets as ${sqlIdentifier}\n          where ${sqlIdentifier}.user_id = ${queryBuilder.getTableAlias()}.id\n        )`;\n\n        return orderByFrag;\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n\n    return customOrderBy;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Annotating Functions as Filterable in PostGraphile (SQL)\nDESCRIPTION: These SQL code snippets illustrate the use of the @filterable smart comment, making functions accept a 'condition' argument for filtering in the Graphile/GraphQL schema. This enables client-side queries to filter results by attributes or function return values. Functions must be SETOF a table-like type or scalar-returning computed columns. Prerequisite: PostgreSQL function in scope.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_17\n\nLANGUAGE: sql\nCODE:\n```\ncomment on function foo() is E'@filterable';\ncomment on function users_foo(users) is E'@filterable';\n```\n\n----------------------------------------\n\nTITLE: Performing PostgreSQL Introspection with pg-introspection in JavaScript\nDESCRIPTION: This snippet demonstrates the recommended approach for extracting and using strongly-typed PostgreSQL metadata using the pg-introspection library together with the 'pg' module. It performs an introspection SQL query, parses the returned JSON metadata, and accesses key information such as the database name and DBA role. Dependencies required are 'pg-introspection' and 'pg', and it expects a valid PostgreSQL connection string. Input is the database connection; output is printed metadata. All function usage is asynchronous and must be awaited.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-introspection/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  makeIntrospectionQuery,\n  parseIntrospectionResults,\n} from \"pg-introspection\";\nimport { Pool } from \"pg\";\n\nconst pool = new Pool({\n  connectionString: \"postgres://localhost:5432/my_database\",\n});\n\nasync function main() {\n  const sql = makeIntrospectionQuery();\n  const { rows } = await pool.query(sql);\n  const introspection = parseIntrospectionResults(rows[0].introspection);\n\n  console.log(\n    `The ${introspection.database.datname} DBA is ${\n      introspection.database.getDba()?.rolname ?? \"-\"\n    }`,\n  );\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Running Temporary PostgreSQL Instance with Docker (Bash)\nDESCRIPTION: Starts a temporary PostgreSQL 17 container using Docker, exposing it on port 6432. It uses 'trust' authentication for easy local development access and enables logical replication (`wal_level=logical`). The container runs in the foreground and is removed on exit (Ctrl-C).\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Run a temporary postgres instance on port 6432\ndocker run --rm -it -e POSTGRES_HOST_AUTH_METHOD=trust -p 6432:5432 postgres:17 -c wal_level=logical\n```\n\n----------------------------------------\n\nTITLE: Creating Authenticated User Role in PostgreSQL\nDESCRIPTION: Creates a PostgreSQL role named `forum_example_person` intended for authenticated users. Like the anonymous role, it does not have direct login privileges but is granted to the `forum_example_postgraphile` role. This allows PostGraphile to switch the session's role to `forum_example_person` when a valid JWT indicates an authenticated user.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_27\n\nLANGUAGE: sql\nCODE:\n```\ncreate role forum_example_person;\ngrant forum_example_person to forum_example_postgraphile;\n```\n\n----------------------------------------\n\nTITLE: Updating Data with Sanitized HTML Input using GraphQL Mutation\nDESCRIPTION: This GraphQL mutation shows how to update a record in the 'a' table using the `SanitizeHTMLTypePlugin`. The `updateAById` mutation takes an `id` and an `aPatch` containing new values for `t` and `h`. The input value for `h` will be processed by the `sanitize` function (via `unmap`) before being saved to the database. The mutation returns the updated record, where the `h` field is again processed by `sanitize` (via `map`) for output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_11\n\nLANGUAGE: graphql\nCODE:\n```\n  mutation {\n    updateAById(\n      input: {\n        id: 1\n        aPatch: {\n          t: \"tttt_TTTT_tttt\"\n          h: \"hhhh_HHHH_hhhh\"\n        }\n      }\n    ) {\n      a {\n        id\n        t\n        h\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring Resolver Wrapper Rule and Requirement Interfaces (TypeScript)\nDESCRIPTION: This snippet defines TypeScript interfaces to describe the structure of rule objects used for advanced resolver wrapper configuration in Graphile. The ResolverWrapperRequirements interface lists optional childColumns and siblingColumns arrays, each containing columns with assigned aliases, which can inform the wrapper about required data fields. The ResolverWrapperRule interface references these requirements and mandates the resolve method (the actual wrapper), allowing for extension with additional properties (e.g., subscribe). These interfaces enable strict typing for more complex resolver orchestration. Requires standard TypeScript support.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface ResolverWrapperRequirements {\n  childColumns?: Array<{ column: string; alias: string }>;\n  siblingColumns?: Array<{ column: string; alias: string }>;\n}\ninterface ResolverWrapperRule {\n  requires?: ResolverWrapperRequirements;\n  resolve?: ResolverWrapperFn;\n  // subscribe?: ResolverWrapperFn;\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping User.email to Lowercase Result (JavaScript)\nDESCRIPTION: Example using `makeWrapResolversPlugin` (Method 1) to wrap the `User.email` field resolver. It calls the original resolver (`resolve()`) and then transforms the result to lowercase before returning it. This demonstrates augmenting the return value.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    async email(resolve, source, args, context, resolveInfo) {\n      const result = await resolve();\n      return result.toLowerCase();\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Virtual Unique Constraints Using Smart Tags - PostGraphile - JSON\nDESCRIPTION: Shows the declaration of virtual unique constraints for database classes (tops, views, etc.) using PostGraphile's JSON smart tag configuration. This snippet works within a PostGraphile smart tag JSON config file and specifies unique column sets with either single or multiple columns, provided as strings or arrays. The purpose is to hint at column uniqueness where SQL constraints cannot be enforced, so data integrity is user's responsibility.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_33\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  my_view: {\n    tags: {\n      unique: [\n        \"id\",\n        \"org_id,slug\"\n      ]\n      // or:\n      //   unique: \"id\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom pgSettings in PostgreSQL Function (SQL)\nDESCRIPTION: Defines a PostgreSQL SQL function `get_x_something()` that retrieves the value of a custom setting previously set via `pgSettings`. It uses the `current_setting('setting_name', true)` function to access the setting (`myapp.headers.x_something`) and `nullif` to return `NULL` if the setting is an empty string. The function is marked `stable`, indicating it doesn't modify the database and returns the same results for the same arguments within a single transaction.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\n```sql\ncreate function get_x_something() returns text as $$\n  /* highlight-next-line */\n  select nullif(current_setting('myapp.headers.x_something', true), '')::text;\n$$ language sql stable;\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Mapping of SQL Enum to GraphQL Enum (GraphQL)\nDESCRIPTION: This GraphQL snippet demonstrates how PostGraphile translates the `forum_example.post_topic` SQL enum type into a GraphQL enum named `PostTopic`. The string values from the SQL enum are converted to uppercase enum values in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nenum PostTopic {\n  DISCUSSION\n  INSPIRATION\n  HELP\n  SHOWCASE\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images with Docker Compose\nDESCRIPTION: Provides shell commands using `docker-compose build` to build the Docker images for the services defined in the `docker-compose.yml` file. It demonstrates building all images at once or building images for specific services (`db`, `graphql`) individually.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n# Build images for all services in docker-compose.yml\n$ docker-compose build\n\n# You can also build images one by one\n# For instance you can build the database image like this\n$ docker-compose build db\n\n# And build the graphql image like this\n$ docker-compose build graphql\n```\n\n----------------------------------------\n\nTITLE: Declaring Virtual @foreignKey Constraints via Tag File (JSON5)\nDESCRIPTION: These JSON5 examples show how to add virtual foreign key constraints to a materialized view (or other objects) in a tag file for Graphile. The 'foreignKey' tag supports both single and multiple relationships, mapped as string or array of strings, mirroring PostgreSQL's references syntax for connection inferences in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_30\n\nLANGUAGE: json5\nCODE:\n```\nclass: {\n  my_materialized_view: {\n    tags: {\n      foreignKey: \"(key_1, key_2) references other_table (key_1, key_2)\"\n    }\n  }\n}\n\n// or if you want multiple foreignKeys\nclass: {\n  my_materialized_view: {\n    tags: {\n      foreignKey: [\n        \"(key_1, key_2) references other_table (key_1, key_2)\",\n        \"(key_3, key_4) references some_other_table (key_3, key_4)\"\n      ]\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Renaming a Table Using SQL Smart Comments - SQL\nDESCRIPTION: This SQL snippet demonstrates how to create a table and apply a smart comment to rename its GraphQL representation using the @name tag. Requires a PostgreSQL database and PostGraphile for schema introspection. The 'col1' column is defined as an integer, and a smart tag is set via COMMENT ON TABLE to rename 'original_table' to 'renamed_table' in the resulting GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table original_table (\n  col1 int\n);\n\ncomment on table original_table is E'@name renamed_table';\n```\n\n----------------------------------------\n\nTITLE: Updating Test Snapshots with Yarn (Shell)\nDESCRIPTION: Runs the project's test suite via `yarn test` with the `UPDATE_SNAPSHOTS` environment variable set to `1`. This instructs the test runner (likely Jest) to overwrite existing snapshot files with the new output generated during the test run.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nUPDATE_SNAPSHOTS=1 yarn test\n```\n\n----------------------------------------\n\nTITLE: Adding Condition to HAVING Clause with having - Graphile (JavaScript)\nDESCRIPTION: Demonstrates the use of the having method to append a condition to the HAVING clause, limited to when pgCondition is in 'having' mode. The input condition is a SQL expression intended for aggregation-based filtering. This method enables dynamic construction of HAVING conditions for advanced GraphQL query extensions.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgCondition.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n$pgCondition.having(condition)\n```\n\n----------------------------------------\n\nTITLE: Using the `constant` Helper in TypeScript\nDESCRIPTION: This snippet demonstrates two ways to use the `constant` helper in TypeScript within a Graphile Crystal context. The first line creates a step `$one` that will always resolve to the number 1 using the `constant()` function. The second line creates a step `$str` that will always resolve to the string \"My string here\" using the `constant` template literal tag.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/constant.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $one = constant(1);\nconst $str = constant`My string here`;\n```\n```\n\n----------------------------------------\n\nTITLE: Annotating a View with Smart Tags via SQL Comments - PostGraphile - SQL\nDESCRIPTION: Illustrates how to attach smart tags to a view using a SQL COMMENT statement, enabling PostGraphile to recognize virtual unique constraints on that view. The example requires an existing view and applies string annotations that PostGraphile reads. The tag uses the '@unique' directive with multiple constraints separated by newlines.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_34\n\nLANGUAGE: sql\nCODE:\n```\ncomment on view my_view is E'@unique id\\n@unique org,slug';\n```\n\n----------------------------------------\n\nTITLE: Describing Naming Convention Inflection Steps\nDESCRIPTION: Illustrates the sequence of case transformations (camelCase, upperCamelCase, constantCase) applied during the inflection process for naming fields, types, or enum values in PostGraphile, highlighting how intermediate results could be re-used, potentially leading to unexpected outcomes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`camelCase`/`upperCamelCase`/`constantCase`\n```\n\nLANGUAGE: markdown\nCODE:\n```\nstring ðŸ‘‰ camel-case ðŸ‘‰ concatenate ðŸ‘‰ camel-case ðŸ‘‰ concatenate ðŸ‘‰ constant-case\n```\n\n----------------------------------------\n\nTITLE: Example JWT Claims Object (JSON)\nDESCRIPTION: This JSON snippet provides an example JWT payload with the claims 'sub', 'role', and 'user_id'. It serves to illustrate how the claims are represented before being serialized and set as PostgreSQL session variables. This format mirrors the standard JWT claims structure and is intended for documentation scenarios or test fixtures.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwt-guide.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sub\": \"postgraphql\",\n  \"role\": \"user\",\n  \"user_id\": 2\n}\n```\n\n----------------------------------------\n\nTITLE: Running Ruru Instantly via NPX (Shell)\nDESCRIPTION: Executes the `ruru` CLI tool without permanent installation using `npx`. This command connects to a specified GraphQL endpoint (https://countries.trevorblades.com/graphql), enabling immediate API exploration. Flags `-S` (enable subscriptions) and `-P` (proxy GraphQL requests) are included as examples, though not strictly required for this specific endpoint.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/ruru/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx ruru@beta -SPe https://countries.trevorblades.com/graphql\n```\n\n----------------------------------------\n\nTITLE: Implementing PetsCountPlugin with makeAddPgTableConditionPlugin in Graphile V4 (JavaScript)\nDESCRIPTION: Provides a Graphile V4 JavaScript example of using `makeAddPgTableConditionPlugin` to create a `PetsCountPlugin`. This plugin adds a `petCountAtLeast` condition to the `users` table, filtering users based on their pet count. The condition generator receives the runtime `value` and uses SQL helpers to construct a filtering SQL fragment directly incorporating the value.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { makeAddPgTableConditionPlugin } from \"graphile-utils\";\n\nconst PetsCountPlugin = makeAddPgTableConditionPlugin(\n  \"graphile_utils\",\n  \"users\",\n  \"petCountAtLeast\",\n  (build) => ({\n    description: \"Filters users to those that have at least this many pets\",\n    type: build.graphql.GraphQLInt,\n  }),\n  (value, helpers, build) => {\n    const { sqlTableAlias, sql } = helpers;\n    return sql.fragment`(select count(*) from graphile_utils.pets where pets.user_id = ${sqlTableAlias}.id) >= ${sql.value(\n      value,\n    )}`;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: TypeScript Implementation of EXPORTABLE Utility Function\nDESCRIPTION: Reproduces the EXPORTABLE utility function implementation as seen in the graphile-export/helpers package. The function takes a factory, argument array, and optional name, returning the constructed function/object and attaching special metadata if it is exportable. This underpinning logic is what makes EXPORTABLE work for TypeScript projects. Inputs: factory, args, nameHint; output: value to export.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport function EXPORTABLE<T, TScope extends any[]>(\n  factory: (...args: TScope) => T,\n  args: [...TScope],\n  nameHint?: string,\n): T {\n  const fn: T = factory(...args);\n  if (\n    ((typeof fn === \"object\" && fn !== null) || typeof fn === \"function\") &&\n    !(\"$exporter$factory\" in fn)\n  ) {\n    Object.defineProperties(fn, {\n      $exporter$args: { value: args },\n      $exporter$factory: { value: factory },\n      $exporter$name: { writable: true, value: nameHint },\n    });\n  }\n  return fn;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with Viewer Field (GraphQL Diff)\nDESCRIPTION: Shows the schema-level diff used to indicate the addition of the 'viewer' field of type 'User' to the generated GraphQL schema. This diff is produced by running PostGraphile after registering the above SQL function. The only dependency is for the SQL function 'viewer' to be defined; no code execution is required. The output provides an 'Intuitive' root-level field for authenticated users.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -1795,6 +1795,7 @@\n\n   \"\"\"Chosen by fair dice roll. Guaranteed to be random. XKCD#221\"\"\"\n   randomNumber: Int\n+  viewer: User\n\n   \"\"\"Reads a single `Forum` using its globally unique `ID`.\"\"\"\n   forumByNodeId(\n\n```\n\n----------------------------------------\n\nTITLE: Executing Closure-Dependent Function in New Environment Fails\nDESCRIPTION: Shows the runtime `ReferenceError` that occurs when attempting to execute a function definition (obtained via `.toString()`) in a new environment where the closed-over variable `a` is not defined. This highlights the problem Graphile Export aims to solve.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n> function add(b) { return a + b }\nundefined\n> add(3)\nUncaught ReferenceError: a is not defined\n    at add (REPL1:1:19)\n```\n\n----------------------------------------\n\nTITLE: Adding PostGraphile Dependency (Bash)\nDESCRIPTION: Adds the `postgraphile` package as a project dependency using the Yarn package manager. This command downloads and installs PostGraphile and adds it to the project's `package.json` and `yarn.lock` files. Requires Yarn to be installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add postgraphile\n```\n\n----------------------------------------\n\nTITLE: Defining PlanWrapperRules and Generator Types for Plan Resolver Wrapping (TypeScript)\nDESCRIPTION: This code snippet provides type and interface definitions for creating mapping rules or rule generators for makeWrapPlansPlugin. It sets out the structure for customizing which type and field pairs get wrapped and how, supporting both static and dynamically-generated rule objects. These types and interfaces are essential for users building complex wrapper plugins that need to reference build-time configuration or registry items.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ninterface PlanWrapperRules {\\n  [typeName: string]: {\\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\\n  };\\n}\\n\\ntype PlanWrapperRulesGenerator = (\\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\\n) => PlanWrapperRules;\n```\n\n----------------------------------------\n\nTITLE: Running Persistent PostgreSQL Instance with Docker (Bash)\nDESCRIPTION: Starts a PostgreSQL container using Docker that persists data by mounting a host volume (`/var/run/postgresql/`) and runs in the background (`-d`). It uses host networking for potentially simpler connections and sets up 'trust' authentication.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v /var/run/postgresql/:/var/run/postgresql/ --network host -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_HOST_AUTH_METHOD=trust -e POSTGRES_INITDB_ARGS='--auth-host=trust' -d postgres\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Functions with PLV8 (JavaScript)\nDESCRIPTION: Demonstrates how to define PostgreSQL functions using JavaScript via the `plv8` extension. The first example defines the `add` function, similar to previous examples. The second example, `plv8_test`, takes arrays of keys and values, constructs a JavaScript object, and returns its JSON string representation. Both functions are marked `IMMUTABLE` and `STRICT`. Requires the `plv8` extension to be installed in PostgreSQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- This does look the exact same as the PL/pgSQL exampleâ€¦\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  return a + b;\n$$ LANGUAGE plv8 IMMUTABLE STRICT;\n\n-- Hereâ€™s a better example from the plv8 repoâ€¦\nCREATE FUNCTION plv8_test(keys text[], vals text[]) RETURNS text AS $$\n  var object = {}\n  for (var i = 0; i < keys.length; i++) {\n    object[keys[i]] = vals[i]\n  }\n  return JSON.stringify(object)\n$$ LANGUAGE plv8 IMMUTABLE STRICT;\n```\n\n----------------------------------------\n\nTITLE: Implementing Traditional GraphQL Resolvers (TypeScript)\nDESCRIPTION: Provides an example implementation of standard GraphQL resolvers in TypeScript using `graphql-js`. It shows asynchronous functions that fetch data using `DataLoader` instances (`userLoader`, `friendshipsByUserIdLoader`) stored in the `context` to address the N+1 problem. It resolves `currentUser`, `User.name`, and `User.friends`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst resolvers = {\n  Query: {\n    async currentUser(_, args, context) {\n      return context.userLoader.load(context.currentUserId);\n    },\n  },\n  User: {\n    name(user) {\n      return user.full_name;\n    },\n    async friends(user, args, context) {\n      const friendships = await context.friendshipsByUserIdLoader.load(user.id);\n      const friends = await Promise.all(\n        friendships.map((friendship) =>\n          context.userLoader.load(friendship.friend_id),\n        ),\n      );\n      return friends;\n    },\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Resolving Naming Conflicts using Numeric Arguments in PostgreSQL Functions\nDESCRIPTION: Defines a `get_user` function that retrieves a user record based on an `id`. It demonstrates resolving a potential naming conflict between the function argument `id` and the table column `users.id` by referencing the argument using the numeric placeholder `$1`. The function is marked `stable` as its result depends on database lookups but doesn't modify data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = $1;\n$$ language sql stable;\n```\n\n----------------------------------------\n\nTITLE: Starting PostGraphile with a Default Role - Bash\nDESCRIPTION: This Bash command runs PostGraphile with a specified default role (`forum_example_anonymous`) so that unauthenticated requests are automatically made under this role's permissions. It requires the roles already to exist in the database and that PostGraphile is installed. The options control the database connection and the default security context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile \\\n  --connection postgres://forum_example_postgraphile:xyz@localhost/mydb \\\n  --default-role forum_example_anonymous\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images using Docker Compose Commands\nDESCRIPTION: Provides example shell commands using `docker-compose build` to build the Docker images defined in the `docker-compose.yml` file. It shows how to build images for all services simultaneously or target individual services like `db` or `graphql` specifically.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n# Build images for all services in docker-compose.yml\n$ docker-compose build\n\n# You can also build images one by one\n# For instance you can build the database image like this\n$ docker-compose build db\n\n# And build the graphql image like this\n$ docker-compose build graphql\n```\n\n----------------------------------------\n\nTITLE: Enabling PostGraphile Plugins via CLI Flag\nDESCRIPTION: Illustrates how to enable multiple PostGraphile server plugins using the `--plugins` command-line flag. This flag must be the first argument passed to the `postgraphile` command. Plugins are specified as a comma-separated list.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile --plugins \\\n  @graphile/operation-hooks,@graphile/pg-pubsub,@graphile/pro \\\n  -c postgres:///my_db\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Foreign Keys in JSON5 - JSON5\nDESCRIPTION: Demonstrates attaching multiple virtual foreign keys to a materialized view via the 'foreignKey' array in JSON5 configuration. Each entry specifies a source-target mapping for foreign keys. Prerequisite: referenced table(s) and columns exist. Used by PostGraphile for schema relationships but not enforced in PostgreSQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_18\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: [\n            \"(key_1, key_2) references other_table (key_1, key_2)\",\n            \"(key_3, key_4) references some_other_table (key_3, key_4)\",\n          ],\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying to Heroku via Git Push (CLI Setup) (Bash)\nDESCRIPTION: Pushes the local `master` branch to the 'heroku' remote repository. This action triggers the build and deployment process on the associated Heroku application. This command is used within the minimal CLI setup example.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit push heroku master\n```\n\n----------------------------------------\n\nTITLE: Base64 JSON Node ID Codec Implementation - JavaScript\nDESCRIPTION: This snippet provides functions for encoding and decoding node identifiers by JSON serializing to a UTF-8 string and base64 encoding/decoding. The 'base64JSONEncode' and 'base64JSONDecode' functions set an 'isSyncAndSafe' property for optimization. The resulting 'base64JSONCodec' object can be used as a codec in handler specifications. Requires the Node.js Buffer API and is usable wherever intermediate entity specs can be safely stringified and parsed.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/node.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction base64JSONEncode(value: any): string | null {\n  return Buffer.from(JSON.stringify(value), \"utf8\").toString(\"base64\");\n}\nbase64JSONEncode.isSyncAndSafe = true; // Optimization\n\nfunction base64JSONDecode(value: string): any {\n  return JSON.parse(Buffer.from(value, \"base64\").toString(\"utf8\"));\n}\nbase64JSONDecode.isSyncAndSafe = true; // Optimization\n\nconst base64JSONCodec = {\n  name: \"base64JSON\",\n  encode: base64JSONEncode,\n  decode: base64JSONDecode,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Functions using JavaScript (PL/v8) in PostgreSQL (SQL)\nDESCRIPTION: Illustrates how to define PostgreSQL functions using JavaScript via the `plv8` extension. The first example shows the simple `add` function, functionally identical to the SQL and PL/pgSQL versions but using JavaScript syntax within the `$$` block and specifying `LANGUAGE plv8`. The second, more complex example `plv8_test`, takes arrays of keys and values, constructs a JavaScript object from them, and returns the object serialized as a JSON string using `JSON.stringify()`. Both functions require the `plv8` extension to be installed in the database and are marked `immutable` and `strict`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\n-- This does look the exact same as the PL/pgSQL exampleâ€¦\ncreate function add(a int, b int) returns int as $$\n  return a + b;\n$$ language plv8 immutable strict;\n\n-- Hereâ€™s a better example from the plv8 repoâ€¦\ncreate function plv8_test(keys text[], vals text[]) returns text as $$\n  var object = {}\n  for (var i = 0; i < keys.length; i++) {\n    object[keys[i]] = vals[i]\n  }\n  return JSON.stringify(object)\n$$ language plv8 immutable strict;\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile and Plugins using ES Modules in JavaScript\nDESCRIPTION: Shows how to import the `postgraphile` library, `makePluginHook` utility, and specific PostGraphile plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) using JavaScript ES2015 Module (ESM) `import` syntax.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nimport { postgraphile, makePluginHook } from \"postgraphile\";\nimport OperationHooks from \"@graphile/operation-hooks\";\nimport PgPubsub from \"@graphile/pg-pubsub\";\nimport GraphilePro from \"@graphile/pro\";\n```\n```\n\n----------------------------------------\n\nTITLE: Using indexMap in Grafast execute Method with No Dependencies in TypeScript\nDESCRIPTION: Provides an example of using the `indexMap` helper function within a Grafast step's `execute` method, specifically for steps without dependencies. It generates a result list of the correct length (`count`) by applying a function to each index.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nreturn indexMap((i) => 42);\n```\n\n----------------------------------------\n\nTITLE: Example Exported Code by Graphile Export\nDESCRIPTION: Shows an example of the resulting JavaScript code that Graphile Export would generate for the `EXPORTABLE` wrapped function. It correctly includes the definition of the dependency (`const a = 7;`) before the function definition, ensuring the function works when executed in a new environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst a = 7;\nfunction add(b) {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a User with a GraphQL Mutation\nDESCRIPTION: Defines a GraphQL mutation for creating a new user by providing a username. Expects a PostGraphile-generated GraphQL schema with a createUser mutation. Returns the new user's id, username, and creation date.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_25\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  createUser(input: {user: {username: \"Bob\"}}) {\n    user {\n      id\n      username\n      createdDate\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Composite Type (SQL)\nDESCRIPTION: Creates a PostgreSQL composite type named `my_type` in the `my_schema` schema. This type acts like a structure or object, containing two integer fields: `foo` and `bar`. PostGraphile translates such composite types into GraphQL object types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncreate type my_schema.my_type as (\n  foo integer,\n  bar integer\n);\n```\n\n----------------------------------------\n\nTITLE: Building Static Website Content with Yarn (Shell)\nDESCRIPTION: Executes the `build` script defined in `package.json` (typically running `docusaurus build`). This command compiles the Docusaurus project and generates static HTML, CSS, and JavaScript files into the `build` directory, making the website ready for deployment to any static hosting service.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Plugin Metadata with package.json in Node.js\nDESCRIPTION: Specifies the Node.js package configuration for the custom PostGraphile plugin. Lists package metadata, scripts, author, license, and declares dependencies on graphile-utils and postgraphile. The file is required for Node.js package management and must reside in the custom-plugin directory.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"custom-plugin\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Custom plugin example for PostGraphile.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Alexis ROLLAND\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"graphile-utils\": \"^4.5.6\",\n    \"postgraphile\": \"^4.5.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RDS Database URL for Heroku App (Bash)\nDESCRIPTION: Sets the `RDS_URL` configuration variable for a specific Heroku application (`-a heroku_app_name`). This variable stores the connection string for an AWS RDS PostgreSQL database, including user credentials, host, database name, and enabling SSL. Replace placeholders with actual values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set RDS_URL=\"postgres://user:pass@rdshost/dbname?ssl=true\" -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: Illustrating a Bucket Node in Mermaid for Grafast Plans\nDESCRIPTION: This Mermaid diagram snippet demonstrates the visual structure of a 'Bucket' or 'Layer Plan' node within a Grafast plan diagram. It shows the bucket number, the reason for its creation (e.g., 'nullableBoundary'), its dependencies ('Deps'), the root step ('ROOT'), and the execution order of steps within it.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\n%%\n%%{init: {'themeVariables': { 'fontSize': '12px'}}}%%\nflowchart TD\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    Bucket1(\"Bucket 1 (nullableBoundary)<br />Deps: 8<br /><br />ROOT LoadOneá¸userByIdá³[8]<br />1: <br />á³: Access[10]<br />2: Load[11]\"):::bucket\n    classDef bucket1 stroke:#00bfff\n    class Bucket1,Access10,Load11 bucket1\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruru HTML Parts with Graphile Config - TypeScript\nDESCRIPTION: This code snippet demonstrates how to customize the HTML 'meta' and 'title' tags that the Ruru server renders, by extending the 'ruru.htmlParts' property within a GraphileConfig.Preset object. It imports the defaultHTMLParts utility and composes custom HTML strings, suitable for organizations wishing to influence the served GraphiQL UI. Requires the 'ruru/server' and 'graphile-config' modules. Key parameters include 'titleTag' and 'metaTags', allowing for precise HTML content injection. The preset is expected to be exported or used in a config file for Ruru CLI or server initialization.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defaultHTMLParts } from \"ruru/server\";\n\nconst preset: GraphileConfig.Preset = {\n  //...\n  ruru: {\n    htmlParts: {\n      titleTag: \"<title>GraphiQL with Grafast support - Ruru!</title>\",\n      metaTags:\n        defaultHTMLParts.metaTags +\n        `<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />`,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example V4 Plugin Dependencies in package.json\nDESCRIPTION: Shows typical PostGraphile V4 related `devDependencies` in a `package.json` file before upgrading to V5. This includes packages like `graphile-build`, `graphile-build-pg`, `postgraphile`, and potentially other V4 plugins.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"devDependencies\": {\n    \"graphile-build\": \"^4.12.0-alpha.0\",\n    \"graphile-build-pg\": \"^4.12.0-alpha.0\",\n    \"postgraphile\": \"^4.12.0-alpha.0\",\n    \"postgraphile-plugin-connection-filter\": \"^2.2.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via HTTPS using Yarn\nDESCRIPTION: Deploys the built website using Yarn, specifying the GitHub username via the `GIT_USER` environment variable. This method is typically used for HTTPS-based deployment (e.g., to GitHub Pages) where authentication might involve a username and password or a personal access token.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Applying PostGraphile @unionMember Smart Tags in SQL\nDESCRIPTION: Adds comments to the `polymorphic.people` and `polymorphic.organizations` tables, applying the `@unionMember PersonOrOrganization` smart tag to each. This instructs PostGraphile to include both corresponding GraphQL types as members of the `PersonOrOrganization` union type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/polymorphism.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.people is $$\n  @unionMember PersonOrOrganization\n  $$;\ncomment on table polymorphic.organizations is $$\n  @unionMember PersonOrOrganization\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Deploying Application to Heroku via Git Push (Bash)\nDESCRIPTION: Pushes the `master` branch of the local Git repository to the `heroku` remote repository. This action triggers Heroku's build and deployment process based on the project's configuration. This instance of the command is part of the more detailed library setup guide.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit push heroku master\n```\n\n----------------------------------------\n\nTITLE: Defining a `product` table in PostgreSQL\nDESCRIPTION: SQL statement to create a `product` table in the database. This table includes columns for `id` (UUID primary key), `name` (text), and `price_in_us_cents` (integer), which PostGraphile will use to generate a corresponding GraphQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-extend-schema-plugin.md#_snippet_16\n\nLANGUAGE: sql\nCODE:\n```\ncreate table product (\n  id uuid primary key,\n  name text not null,\n  price_in_us_cents integer not null\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Auth0 Authentication Dependencies - Bash\nDESCRIPTION: This snippet shows how to install Express.js along with the necessary Auth0 middleware packages for JWT validation and JWKS key retrieval using Yarn or npm. The dependencies include 'express', 'express-jwt', and 'jwks-rsa', which are required for implementing authentication and authorization with JWTs in an Express application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/jwk-verification.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add express express-jwt jwks-rsa\n# Or:\nnpm install --save express express-jwt jwks-rsa\n```\n\n----------------------------------------\n\nTITLE: Querying Table-Like Data with selectGraphQLResultFromTable - PostGraphile - JavaScript\nDESCRIPTION: This JavaScript async resolver queries a row from a PostgreSQL function returning a user record by leveraging resolveInfo.graphile.selectGraphQLResultFromTable. It uses sql.fragment to build a table-like subquery from the match_user() function and extracts the first row from the result array. Dependencies include PostGraphile's query look-ahead and the pg-sql2 sql object, and all input parameters come from standard GraphQL resolver arguments. Outputs a User object or undefined; all code must run within a properly configured PostGraphile resolver context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-extend-schema-plugin.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// type Query { matchingUser(searchText: String!): User }\nconst matchingUserResolver = async (parent, args, context, resolveInfo) => {\n  const [row] = await resolveInfo.graphile.selectGraphQLResultFromTable(\n    sql.fragment`(select * from match_user(${sql.value(args.searchText)}))`,\n    () => {}, // no-op\n  );\n  return row;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a pgSelectSingle from a pgSelect Row in TypeScript\nDESCRIPTION: Demonstrates creating a `pgSelectSingle` step instance (`$row`) from a specific row within an existing `pgSelect` collection (`$pgSelect`). It uses the `first()` step helper to target the first row of the `$pgSelect` result set and passes this target row step to the `$pgSelect.row()` method. Requires an existing `$pgSelect` instance and the `first` step helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst $row = $pgSelect.row(first($pgSelect));\n```\n\n----------------------------------------\n\nTITLE: Visualizing Unbatched Synchronous Steps in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet illustrates an unbatched synchronous step, typically used for trivial operations like property access. These steps don't benefit from batching and are represented with hexagonal borders, allowing the system to execute them inline with their dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    Access17{{\"Access[17âˆˆ3]<br />á¸15.friend_idá³\"}}:::plan\n    class Access17 bucket3\n\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin for Graphile Export (Shell)\nDESCRIPTION: This snippet demonstrates the shell command required to install the eslint-plugin-graphile-export plugin using yarn. The package must be added as a development dependency before configuring ESLint or using its features. This step is a prerequisite for configuring the ESLint rules in project files.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/eslint.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn add eslint-plugin-graphile-export@beta\n```\n\n----------------------------------------\n\nTITLE: Converting a Query to a Live Subscription (GraphQL)\nDESCRIPTION: Illustrates how to make a GraphQL query 'live' within PostGraphile by changing the operation type from `query` to `subscription`. The structure of the requested fields remains the same, but the operation now subscribes to changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Beta Plugin via Yarn\nDESCRIPTION: This command installs a beta version of the 'postgraphile-plugin-connection-filter' Node.js module using the Yarn package manager. The '@beta' tag specifies the desired release channel, necessary because the software is currently in beta.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/index.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn add postgraphile-plugin-connection-filter@beta\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema Extension for addQuizEntry Mutation - Diff\nDESCRIPTION: Shows a comprehensive diff illustrating schema changes after defining the â€˜add_quiz_entryâ€™ custom mutation in SQL. Demonstrates the addition of new input, payload, and edge types, as well as the â€˜addQuizEntryâ€™ mutation field. Details data structures necessary for performing and receiving results via the custom bulk insertion mutation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -1,3 +1,41 @@\n+\"\"\"All input for the `addQuizEntry` mutation.\"\"\"\n+input AddQuizEntryInput {\n+  \"\"\"\n+  An arbitrary string value with no semantic meaning. Will be included in the\n+  payload verbatim. May be used to track mutations by the client.\n+  \"\"\"\n+  clientMutationId: String\n+  quizId: Int!\n+  answers: [QuizEntryInputRecordInput]!\n+}\n+\n+\"\"\"The output of our `addQuizEntry` mutation.\"\"\"\n+type AddQuizEntryPayload {\n+  \"\"\"\n+  The exact same `clientMutationId` that was provided in the mutation input,\n+  unchanged and unused. May be used by a client to track mutations.\n+  \"\"\"\n+  clientMutationId: String\n+  quizEntry: QuizEntry\n+\n+  \"\"\"\n+  Our root query field type. Allows us to run any query from our mutation payload.\n+  \"\"\"\n+  query: Query\n+\n+  \"\"\"Reads a single `User` that is related to this `QuizEntry`.\"\"\"\n+  user: User\n+\n+  \"\"\"Reads a single `Quiz` that is related to this `QuizEntry`.\"\"\"\n+  quiz: Quiz\n+\n+  \"\"\"An edge for our `QuizEntry`. May be used by Relay 1.\"\"\"\n+  quizEntryEdge(\n+    \"\"\"The method to use when ordering `QuizEntry`.\"\"\"\n+    orderBy: [QuizEntriesOrderBy!] = [PRIMARY_KEY_ASC]\n+  ): QuizEntriesEdge\n+}\n+\n \"\"\"\n A floating point number that requires more precision than IEEE 754 binary 64\n \"\"\"\n@@ -1472,6 +1510,12 @@\n     \"\"\"\n     input: DeleteUserByUsernameInput!\n   ): DeleteUserPayload\n+  addQuizEntry(\n+    \"\"\"\n+    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objectâ€™s fields.\n+    \"\"\"\n+    input: AddQuizEntryInput!\n+  ): AddQuizEntryPayload\n\n   \"\"\"\n   If you've forgotten your password, give us one of your email addresses and we'\n@@ -2115,6 +2159,12 @@\n   quizId: Int!\n }\n\n+\"\"\"An input for mutations affecting `QuizEntryInputRecord`\"\"\"\n+input QuizEntryInputRecordInput {\n+  question: String\n+  answer: Int\n+}\n+\n \"\"\"\n Represents an update to a `QuizEntry`. Fields that are set will be updated.\n \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostGraphile Server Using PostgreSQL Role - Bash\nDESCRIPTION: This command line example demonstrates how to connect to a PostGraphile server using the specified PostgreSQL user role (auth_user). It assumes PostGraphile is installed globally via npm/yarn and that the indicated database and user exist. Passes a connection string formatted as postgres://user@host/database to the -c option. Used to launch PostGraphile with the provided database role context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/default-role.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Grafserv Instance - JavaScript\nDESCRIPTION: This snippet demonstrates how to create a Grafserv server instance by invoking the 'grafserv' factory function with a schema and a configuration preset. Dependencies include the 'grafserv' package, with 'schema' representing the GraphQL schema and 'preset' an object specifying server configuration. The function returns a server instance, which can be integrated with various Node.js server frameworks. Inputs are the schema and preset; output is the Grafserv instance. Make sure both dependencies are properly imported.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafserv/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst serv = grafserv({ schema, preset });\n```\n\n----------------------------------------\n\nTITLE: Bypassing Authorization Checks with pgSelect setTrusted() in TypeScript\nDESCRIPTION: Illustrates using `$posts.setTrusted()` within a Gra*fast plan resolver for the `Forum.posts` field. This method signals that default authorization checks defined on the `postsResource` should be skipped for this specific query (`$posts`). This is typically done when access is implicitly guaranteed by the context (e.g., if the user can already access the parent `$forum`, they are assumed to have access to its posts). Requires `postsResource` and assumes a Gra*fast plan structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/pgSelect.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nconst plans = {\n  Forum: {\n    posts($forum) {\n      const $posts = postsResource.find({ forum_id: $forum.get(\"id\") });\n\n      // If we can see the forum, then we can see all the posts inside the\n      // forum, so don't bother adding the access conditions:\n      $posts.setTrusted();\n\n      return $posts;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Adding the pgcrypto Extension in Postgres - SQL\nDESCRIPTION: This statement installs the `pgcrypto` extension in the database if it is not already present, providing cryptographic functions such as `crypt` and `gen_salt` that are required for password hashing. No parameters are needed. Dependencies include a working Postgres database with sufficient privileges to manage extensions. The command is safe to run multiple times due to the `if not exists` clause.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_20\n\nLANGUAGE: sql\nCODE:\n```\ncreate extension if not exists \"pgcrypto\";\n```\n\n----------------------------------------\n\nTITLE: Setting Heroku Config for Custom RDS URL (Bash)\nDESCRIPTION: Sets a custom environment variable named `RDS_URL` on the specified Heroku app (`heroku_app_name`) to the connection string for an AWS RDS database. The connection string includes credentials, host, database name, and the `?ssl=true` parameter for SSL connection. This variable is used by the PostGraphile CLI in the Procfile example.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nheroku config:set RDS_URL=\"postgres://user:pass@rdshost/dbname?ssl=true\" -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum via graphile-utils Plugin (JavaScript)\nDESCRIPTION: Uses `makeExtendSchemaPlugin` from `graphile-utils` to define a GraphQL enum `AnimalType` directly using GraphQL Schema Definition Language (SDL). It also extends the existing `Pet` type to use this custom enum for its `type` field and provides basic resolvers. This approach defines the enum within the GraphQL layer, independent of the database schema. Requires the `graphile-utils` dependency.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { gql, makeExtendSchemaPlugin } from \"graphile-utils\";\n\nconst myPlugin = makeExtendSchemaPlugin(() => ({\n  typeDefs: gql`\n    enum AnimalType {\n      \"\"\"\n      A feline animal\n      \"\"\"\n      CAT\n\n      \"\"\"\n      A canine animal\n      \"\"\"\n      DOG\n\n      \"\"\"\n      An aquatic animal\n      \"\"\"\n      FISH\n    }\n\n    extend type Pet {\n      type: AnimalType!\n    }\n  `,\n  resolvers: {\n    AnimalType: {\n      CAT: \"cat\",\n      DOG: \"dog\",\n      FISH: \"fish\",\n    },\n    Pet: {\n      type() {\n        /* TODO: add logic here */\n        return \"cat\";\n      },\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Replacing an Inflector using Inflectors Generator in TypeScript/JavaScript\nDESCRIPTION: Demonstrates how to replace an existing inflector (`enumName`) using an inflector generator function passed to `makeAddInflectorsPlugin` with the `replace` flag set to true. It shows how to safely call the original inflector by dereferencing it and using `.call(this, ...)` to preserve the `this` context and avoid infinite recursion. This example replaces dots with underscores in enum names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-inflectors-plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { makeAddInflectorsPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeAddInflectorsPlugin((inflectors) => {\n  // Here 'enumName' is dereferenced to 'oldEnumName' from the existing\n  // inflectors.\n  const { enumName: oldEnumName } = inflectors;\n\n  return {\n    enumName(value: string) {\n      // By the time we get here, `inflectors.enumName` refers to this very\n      // method, so we must call `oldEnumName` rather than\n      // `inflectors.enumName` otherwise we will get a \"Maximum call stack size\n      // exceeded\" error.\n\n      // Further, we must ensure that the value of `this` is passed through\n      // otherwise the old inflector cannot reference other inflectors.\n\n      return oldEnumName.call(this, value.replace(/\\./g, \"_\"));\n    },\n  };\n}, true);\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Enum Mapping (GraphQL)\nDESCRIPTION: This GraphQL snippet shows how PostGraphile automatically converts the previously defined PostgreSQL `post_topic` enum type into a GraphQL enum named `PostTopic`. Each SQL enum value is mapped to an uppercase GraphQL enum value.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nenum PostTopic {\n  DISCUSSION\n  INSPIRATION\n  HELP\n  SHOWCASE\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing httpRequest in Grafast RequestContext (TypeScript)\nDESCRIPTION: Notes the removal of `Grafast.RequestContext.httpRequest` in version 5.0.0-0.14. Developers should now access Node.js request/response objects via `Grafast.RequestContext.node.req/res` when appropriate, as implemented by server adaptors.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// v5.0.0-0.14: Request context property change\n// Removed: \n// Grafast.RequestContext.httpRequest\n\n// Use instead (where applicable):\n// Grafast.RequestContext.node.req\n// Grafast.RequestContext.node.res\n```\n\n----------------------------------------\n\nTITLE: Unsupported 'record' Return Type in PostgreSQL Functions for PostGraphile\nDESCRIPTION: Identifies `record` as an unsupported return type for PostgreSQL functions when used with PostGraphile if no further type information is provided. PostGraphile cannot infer the columns contained within the generic `record` to generate a corresponding GraphQL type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-restrictions.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nrecord\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.14\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.14' of the 'grafast' package. This is part of a changelog entry.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.14\n```\n\n----------------------------------------\n\nTITLE: Removing Docker Images - Shell\nDESCRIPTION: Lists available Docker images with 'docker image ls' and forcibly removes the 'hello-world' image using 'docker rmi -f'. Requires Docker to be installed. Useful for cleanup after installation tests.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ docker image ls\\n$ docker rmi -f hello-world\n```\n\n----------------------------------------\n\nTITLE: Illustrating PostGraphile Mapping of SQL Composite Type to GraphQL Object Type (GraphQL)\nDESCRIPTION: This GraphQL snippet shows how PostGraphile converts the `my_schema.my_type` SQL composite type into a GraphQL object type named `MyType`. The fields `foo` and `bar` are mapped to GraphQL `Int` types.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\ntype MyType {\n  foo: Int\n  bar: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing GraphQL Enum Name via Smart Comment (SQL)\nDESCRIPTION: Demonstrates how to use the `@enumName` smart comment on a PostgreSQL `TYPE` to specify a custom name (`TypeOfAnimal`) for the corresponding GraphQL enum generated by PostGraphile. Requires the enum `animal_type` to exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/enums.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCOMMENT ON TYPE animal_type IS E'@enum\\n@enumName TypeOfAnimal';\n```\n\n----------------------------------------\n\nTITLE: Unsafe Dynamic GraphQL Query Construction (JavaScript)\nDESCRIPTION: Shows a discouraged pattern of building GraphQL queries by concatenating variables directly into the query string. This approach risks injection attacks and performance issues, and is considered bad practice for both Gra*fast* and the general GraphQL ecosystem. The function takes a user ID, composes a query string with it directly interpolated, and executes it. There are no external dependencies beyond a generic `runGraphQLQuery`; the main concern is the unescaped `userId` within the query.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/production-considerations.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction getUserDetails(userId) {\n  // DON'T DO THIS\n  const source = `\n    query UserDetails {\n      userById(id: ${userId}) { # <<< STRING CONCATENATION IS BAD!\n        username\n        avatarUrl\n      }\n    }\n  `;\n  return runGraphQLQuery(source);\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Auto-Apply Behavior for Field Arguments (TypeScript)\nDESCRIPTION: `autoApplyAfterParentPlan` and `autoApplyAfterParentSubscribePlan` are removed. Instead, if an argument has `applyPlan` or `applySubscribePlan` respectively, it will be called automatically at runtime unless it was explicitly called during the field plan resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentPlan // Removed\n```\n\nLANGUAGE: typescript\nCODE:\n```\napplyPlan // Auto-applied if defined and not called in resolver\n```\n\nLANGUAGE: typescript\nCODE:\n```\nautoApplyAfterParentSubscribePlan // Removed\n```\n\nLANGUAGE: typescript\nCODE:\n```\napplySubscribePlan // Auto-applied if defined and not called in resolver\n```\n\n----------------------------------------\n\nTITLE: Defining a No-op Plugin for Graphile Build (JavaScript)\nDESCRIPTION: This example defines a minimal Graphile Build plugin that specifies only a name, version, and description and does not implement any functional scopes. Such a no-op plugin serves as a placeholder or example and can be included in presets without affecting schema generation. No dependencies beyond a Graphile Build environment are required.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-5/plugins.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst NoopPlugin = {\n  name: \\\"NoopPlugin\\\",\n  version: \\\"0.0.0\\\",\n  description: \\\"Does nothing\\\",\n};\n```\n\n----------------------------------------\n\nTITLE: Checking Entity Behavior (New Approach) in TypeScript\nDESCRIPTION: This snippet illustrates the overhauled behavior system within a GraphQL schema hook (`GraphQLObjectType_fields_field`). Instead of complex calculations within the hook, entities now have a single, pre-established behavior. Plugins can check this behavior directly using helper methods provided by `build.behavior`, such as `pgCodecRelationMatches`. This example shows checking if a `relation` entity matches the `\"behavior_to_test\"`. This approach simplifies plugin development, enhances consistency, and improves debuggability.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n  // Do the thing if the relation has the given behavior. Simples.\n  if (build.behavior.pgCodecRelationMatches(relation, \"behavior_to_test\")) {\n    doTheThing();\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Environment Variables for Dockerized PostGraphile - INI Configuration\nDESCRIPTION: This snippet configures environment variables in a .env file for the GraphQL container, specifically the PostgreSQL connection string (DATABASE_URL) and the port (PORT) for PostGraphile. The DATABASE_URL parameter specifies the connection information for PostgreSQL, adhering to standard URI formatting. These values are consumed by both Docker Compose and the Node.js application, enabling proper connectivity and service addressability.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-as-a-library-in-docker.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n# GRAPHQL\\n# Parameters used by graphql container\\nDATABASE_URL=postgres://postgres:change_me@db:5432/forum_example\\nPORT=5433\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Resolver Property with EXPORTABLE (TypeScript)\nDESCRIPTION: Showcases using EXPORTABLE to wrap the previously converted friends resolver property to make it exportable. The async arrow function is passed to EXPORTABLE, initially without explicit dependencies. This step is typically followed by auto-fixing via a linter to enumerate dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfriends: EXPORTABLE(() => async (user, args, context, resolveInfo) => {\n  return await db.friends.loadMany(user.id, context);\n}),\n```\n\n----------------------------------------\n\nTITLE: Listing Schema Inflectors with Graphile CLI\nDESCRIPTION: Executes the `graphile inflection list` command via the command line. This command lists all the inflectors active in the current configuration, detailing their purpose, arguments, and rough TypeScript definitions, aiding in understanding and customizing schema naming conventions. The accompanying screenshots show examples of the command's output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/v5-new-feature-summary.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngraphile inflection list\n```\n\n----------------------------------------\n\nTITLE: Function Signature and Type Declarations for makePgSmartTagsPlugin (TypeScript)\nDESCRIPTION: Defines the signature, parameters, and types for the makePgSmartTagsPlugin function, including how to describe rules via kind and match parameters, as well as subscription methods for live plugin updates. This documentation is crucial for developers defining highly customized smart tags behavior through code rather than static config files. All types depend on various entities provided by 'postgraphile/utils' and related typings.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nfunction makePgSmartTagsPlugin(\n  initialRules: ThunkOrDirect<\n    PromiseOrDirect<PgSmartTagRule | PgSmartTagRule[] | null>\n  >,\n  subscribeToUpdatesCallback?: SubscribeToPgSmartTagUpdatesCallback | null,\n  details?: { name?: string; description?: string; version?: string },\n): GraphileConfig.Plugin;\n\ninterface PgSmartTagRule<\n  TKind extends PgSmartTagSupportedKinds = PgSmartTagSupportedKinds,\n> {\n  serviceName?: string;\n  kind: TKind;\n  match: string | PgSmartTagFilterFunction<PgEntityByKind[TKind]>;\n  tags?: PgSmartTagTags;\n  description?: string;\n}\n\ntype PgSmartTagFilterFunction<TEntity extends PgEntity> = (\n  input: TEntity,\n) => boolean;\n\ntype UpdatePgSmartTagRulesCallback = (\n  ruleOrRules: PgSmartTagRule | PgSmartTagRule[] | null,\n) => void;\n\ntype SubscribeToPgSmartTagUpdatesCallback = (\n  cb: UpdatePgSmartTagRulesCallback | null,\n) => PromiseOrDirect<void>;\n```\n\n----------------------------------------\n\nTITLE: Applying Inline Server Plugin Tweak via Middleware in JavaScript\nDESCRIPTION: Shows how to define a small, inline server plugin directly within the server setup code when using PostGraphile as middleware. This example defines a plugin (`graphiqlBrandingTweak`) that modifies the GraphiQL HTML output using the `postgraphile:graphiql:html` hook to change the branding text. The inline plugin is then passed to `makePluginHook`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * This plugin override changes the branding piece of graphiql.\n */\nconst graphiqlBrandingTweak = {\n  [\"postgraphile:graphiql:html\"](html) {\n    console.log(\"Applying GraphiQL Branding Tweak...\");\n    return html.replace(\n      \"</head>\",\n      '<style type=\"text/css\">div.topBar > div.title > div { visibility: hidden; display: none !important; } div.topBar > div.title::after { content: \"GraphiQL for MyCompany\" }</style></head>',\n    );\n  },\n};\nconst pluginHook = makePluginHook([graphiqlBrandingTweak]);\n\nconst postGraphileMiddleware = postgraphile(databaseUrl, \"app_public\", {\n  pluginHook,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Calling a Newly Added Inflector (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to call a custom inflector (`enhanced`) that has been added via a plugin. The Graphile Build system ensures the `preset` argument is passed implicitly to the inflector's implementation. The calling code only supplies the arguments defined after the `preset` parameter (in this case, the string 'avatarUrl').\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-inflectors-plugin.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst text = inflection.enhanced(\"avatarUrl\");\n```\n\n----------------------------------------\n\nTITLE: Composing PostGraphile with Custom Middleware in Express (JavaScript)\nDESCRIPTION: Illustrates how to apply custom middleware (e.g., for authentication or authorization) specifically to the GraphQL endpoint (`/graphql`) before the main PostGraphile middleware handles the request. This allows for pre-processing or access control on GraphQL requests. The example shows mounting `authMiddleware` on `/graphql` and then mounting `postgraphile`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\n// Example middleware, does nothing\nfunction authMiddleware(req, res, next) {\n  //...\n  next();\n}\n// Mount middleware on the GraphQL endpoint\napp.use(\"/graphql\", authMiddleware);\n// Mount PostGraphile after this middleware\napp.use(postgraphile(connectionString, schema, options));\n```\n\n----------------------------------------\n\nTITLE: Updating NodeIdHandler Interface (TypeScript)\nDESCRIPTION: The `NodeIdHandler` interface now requires a `getIdentifiers` method. This method runs at runtime and is responsible for extracting identifiers from a decoded Node ID string, affecting GraphQL Global Object Identification (`Node`/`id`) implementation.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nNodeIdHandler\n```\n\nLANGUAGE: typescript\nCODE:\n```\ngetIdentifiers // New required runtime method\n```\n\nLANGUAGE: typescript\nCODE:\n```\nNode\n```\n\nLANGUAGE: typescript\nCODE:\n```\nid\n```\n\n----------------------------------------\n\nTITLE: Replacing 'source' with 'resource' in Behavior Strings\nDESCRIPTION: Indicates a global renaming convention change where behavior strings previously using ':source:' should now use ':resource:'. Developers should update these strings in their configurations.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n*:source:* behaviors are now *:resource:* behaviors\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository in Project Directory (Bash)\nDESCRIPTION: Changes the current directory to `project_folder_name` and then initializes a new Git repository within that directory using `git init`. This prepares the project for version control and subsequent deployment via Git.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd project_folder_name && git init\n```\n\n----------------------------------------\n\nTITLE: Testing Docker Installation - Shell\nDESCRIPTION: This command runs the 'hello-world' container to verify Docker is working. It pulls the image if not already present and prints a success message. Inputs: none. Outputs: a verification message from Docker.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker run hello-world\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Enum Type for Post Topics (GraphQL)\nDESCRIPTION: Illustrates the GraphQL `PostTopic` enum type automatically generated by PostGraphile from the corresponding PostgreSQL `forum_example.post_topic` enum type. The values are converted to uppercase.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nenum PostTopic {\n  DISCUSSION\n  INSPIRATION\n  HELP\n  SHOWCASE\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Schema Snapshot Generated by Jest\nDESCRIPTION: Shows the snapshot file content generated by Jest for the Pokemon GraphQL API schema, utilizing the `jest-serializer-graphql-schema`. This output provides a serialized, human-readable representation of the GraphQL schema's structure (types, fields, descriptions, etc.), which is used for comparison in subsequent test runs.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Pokemon GraphQL API has a consistent schema 1`] = `\n\"\"\"Represents a PokÃ©mon's attack types\"\"\"\ntype Attack {\n  \"\"\"The name of this PokÃ©mon attack\"\"\"\n  name: String\n\n  \"\"\"The type of this PokÃ©mon attack\"\"\"\n  type: String\n\n  \"\"\"The damage of this PokÃ©mon attack\"\"\"\n  damage: Int\n}\n\n\"\"\"Represents a PokÃ©mon\"\"\"\ntype Pokemon {\n  \"\"\"The ID of an object\"\"\"\n  id: ID!\n\n  \"\"\"The identifier of this PokÃ©mon\"\"\"\n  number: String\n\n  \"\"\"The name of this PokÃ©mon\"\"\"\n  name: String\n\n  \"\"\"The minimum and maximum weight of this PokÃ©mon\"\"\"\n  weight: PokemonDimension\n\n  \"\"\"The minimum and maximum weight of this PokÃ©mon\"\"\"\n  height: PokemonDimension\n\n  \"\"\"The classification of this PokÃ©mon\"\"\"\n  classification: String\n\n  \"\"\"The type(s) of this PokÃ©mon\"\"\"\n  types: [String]\n\n  \"\"\"The type(s) of PokÃ©mons that this PokÃ©mon is resistant to\"\"\"\n  resistant: [String]\n\n  \"\"\"The attacks of this PokÃ©mon\"\"\"\n  attacks: PokemonAttack\n\n  \"\"\"The type(s) of PokÃ©mons that this PokÃ©mon weak to\"\"\"\n  weaknesses: [String]\n  fleeRate: Float\n\n  \"\"\"The maximum CP of this PokÃ©mon\"\"\"\n  maxCP: Int\n\n  \"\"\"The evolutions of this PokÃ©mon\"\"\"\n  evolutions: [Pokemon]\n\n  \"\"\"The evolution requirements of this PokÃ©mon\"\"\"\n  evolutionRequirements: PokemonEvolutionRequirement\n\n  \"\"\"The maximum HP of this PokÃ©mon\"\"\"\n  maxHP: Int\n  image: String\n}\n\n\"\"\"Represents a PokÃ©mon's attack types\"\"\"\ntype PokemonAttack {\n  \"\"\"The fast attacks of this PokÃ©mon\"\"\"\n  fast: [Attack]\n\n  \"\"\"The special attacks of this PokÃ©mon\"\"\"\n  special: [Attack]\n}\n\n\"\"\"Represents a PokÃ©mon's dimensions\"\"\"\ntype PokemonDimension {\n  \"\"\"The minimum value of this dimension\"\"\"\n  minimum: String\n\n  \"\"\"The maximum value of this dimension\"\"\"\n  maximum: String\n}\n\n\"\"\"Represents a PokÃ©mon's requirement to evolve\"\"\"\ntype PokemonEvolutionRequirement {\n  \"\"\"The amount of candy to evolve\"\"\"\n  amount: Int\n\n  \"\"\"The name of the candy to evolve\"\"\"\n  name: String\n}\n\n\"\"\"Query any PokÃ©mon by number or name\"\"\"\ntype Query {\n  query: Query\n  pokemons(first: Int!): [Pokemon]\n  pokemon(id: String, name: String): Pokemon\n}\n\n`;\n```\n\n----------------------------------------\n\nTITLE: Constructing json_build_object Arguments with sql.join in pg-sql2 JavaScript\nDESCRIPTION: Provides an example of using `sql.join` in `pg-sql2` to dynamically generate the arguments for PostgreSQL's `json_build_object` function. It combines `sql.literal` for keys (assuming trusted input) and other `sql` fragments for values, separated by commas.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst fragments = [\n  { alias: \"name\", sqlFragment: sql.identifier(\"user\", \"name\") },\n  { alias: \"age\", sqlFragment: sql.identifier(\"user\", \"age\") },\n];\nsql`\n  json_build_object(\n    ${sql.join(\n      fragments.map(\n        ({ sqlFragment, alias }) => sql`${sql.literal(alias)}, ${sqlFragment}`,\n      ),\n      \",\\n\",\n    )}\n  )`;\n```\n\n----------------------------------------\n\nTITLE: Defining the 'condition' Function for Boolean Logic Operations in TypeScript\nDESCRIPTION: Defines several overloads for the 'condition' function, enabling unary or binary logical checks on ExecutableStep objects in a TypeScript-based step processing environment. The function can be called with operations such as 'null', 'not null', 'exists', 'not exists', '===', and '!==', requiring one or two ExecutableStep arguments as appropriate. Each signature returns an ExecutableStep<boolean>, allowing the result to be used within further step computations; no implementation is provided, only signatures and intended usage, and the context presumes that ExecutableStep is already defined elsewhere in the project.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/condition.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// value === null?\nfunction condition(\n  operation: \"null\",\n  $value: ExecutableStep,\n): ExecutableStep<boolean>;\n\n// value !== null?\nfunction condition(\n  operation: \"not null\",\n  $value: ExecutableStep,\n): ExecutableStep<boolean>;\n\n// value != null\nfunction condition(\n  operation: \"exists\",\n  $value: ExecutableStep,\n): ExecutableStep<boolean>;\n\n// value == null\nfunction condition(\n  operation: \"not exists\",\n  $value: ExecutableStep,\n): ExecutableStep<boolean>;\n\n// a === b\nfunction condition(\n  operation: \"===\",\n  $a: ExecutableStep,\n  $b: ExecutableStep,\n): ExecutableStep<boolean>;\n\n// a !== b\nfunction condition(\n  operation: \"!==\",\n  $a: ExecutableStep,\n  $b: ExecutableStep,\n): ExecutableStep<boolean>;\n```\n\n----------------------------------------\n\nTITLE: Replacing `makePluginByCombiningPlugins` with a Preset Object (Diff/JavaScript/TypeScript)\nDESCRIPTION: This diff snippet illustrates the code modification required to migrate from the deprecated `makePluginByCombiningPlugins` helper function to the modern approach of defining a preset object. The preset object contains a `plugins` array listing the plugins (`Plugin1`, `Plugin2`, `Plugin3`) to be combined, achieving the same result as the old helper. This change reflects the preferred pattern for plugin composition in newer versions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-plugin-by-combining-plugins.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-const plugin = makePluginByCombiningPlugins(Plugin1, Plugin2, Plugin3);\n+const preset = { plugins: [Plugin1, Plugin2, Plugin3] };\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL for Logical Replication (postgresql.conf)\nDESCRIPTION: Shows the required settings within the `postgresql.conf` file to enable logical decoding. `wal_level` must be set to `logical`, and `max_wal_senders` and `max_replication_slots` must be set to at least 1. PostgreSQL needs to be restarted after changing these settings.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/lds/README.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nwal_level = logical\nmax_wal_senders = 10\nmax_replication_slots = 10\n```\n\n----------------------------------------\n\nTITLE: Ensuring .env File is Ignored by Git - Bash\nDESCRIPTION: This snippet ensures your .env file (containing sensitive credentials) is not checked into git source control by appending '.env' to a '.gitignore' file. Requires git support. No input other than working directory; output is a mutation to .gitignore.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\necho .env >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Resolving Field Aliases with resolveAlias and getAliasFromResolveInfo - JavaScript\nDESCRIPTION: This JavaScript snippet shows a resolver function that leverages getAliasFromResolveInfo to extract the alias by which a field was requested in a GraphQL query. The example presumes integration in a field resolver, where the alias is used to dynamically select the correct property from the data object. It depends on the graphql-parse-resolve-info package's API. Its key parameters are: the data object, arguments (unused), context (unused), and resolveInfo; it returns the aliased field value from the data source.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/build-object.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nresolveAlias(data, _args, _context, resolveInfo) {\n  const alias = getAliasFromResolveInfo(resolveInfo);\n  return data[alias];\n}\n```\n\n----------------------------------------\n\nTITLE: Running Prepack and Test Scripts Using Yarn (bash)\nDESCRIPTION: This snippet demonstrates how to execute preliminary packaging and test scripts for a Node.js project using Yarn, typically to build and validate the project after making changes or before submitting a pull request. It should be run in the project root directory after following contributing setup steps. Input: none. Output: prepack and test script results to console. Dependencies: Node.js, Yarn. Limitation: Assumes presence of yarn scripts prepack and test configured in package.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn prepack\nyarn test\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote (Bash)\nDESCRIPTION: Associates the local Git repository with a remote Heroku application named `heroku_app_name` using the `heroku git:remote` command. This allows pushing code directly to Heroku for deployment. Requires the Heroku CLI and an existing Heroku app with the specified name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nheroku git:remote -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: Launching Node with TypeScript ESM Loader for GraphileConfig\nDESCRIPTION: Configures the Node.js environment to support loading TypeScript ESM modules using the experimental --loader flag with ts-node/esm. Required when using TypeScript files with \\\"export default\\\" in an ESM context to avoid module loading errors. This shell command sets the NODE_OPTIONS environment variable so that subsequent node executions make use of the ts-node loader. Inputs: shell environment; outputs: correctly configured TypeScript module loading behavior for the current process. Limitation: Experimental API; requires compatible versions of Node and ts-node.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/preset.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport NODE_OPTIONS=\"$NODE_OPTIONS --loader ts-node/esm\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-Exportable Function with External Dependency (TypeScript)\nDESCRIPTION: This snippet demonstrates a basic function getExportTime that depends on an external constant EXPORT_TIME from its JavaScript scope. As written, the function cannot be exported safely since its output depends on the surrounding module state, which may not transfer correctly across module boundaries when exporting a GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// A dependency provided via the JS scope\nconst EXPORT_TIME = Date.now();\n\nexport function getExportTime() {\n  return EXPORT_TIME;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Heroku Web Process using Yarn Start (Procfile)\nDESCRIPTION: A `Procfile` entry specifying that the 'web' dyno on Heroku should execute the command `yarn start`. This command should be defined in the `scripts` section of the project's `package.json` file and typically starts the Node.js application.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_9\n\nLANGUAGE: Procfile\nCODE:\n```\nweb: yarn start\n```\n\n----------------------------------------\n\nTITLE: Safely Embedding Literals and Setting Object Keys with te.lit\nDESCRIPTION: Illustrates using `te.lit` to embed primitive values directly into the generated code or pass them by reference. This example specifically shows how `te.lit` can be used to safely set object keys, even potentially problematic ones like `__proto__`, by using bracket notation on an object created with `Object.create(null)`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\n// This is a perfectly reasonable key\nconst key1 = \"one\";\n\n// Note this key would be unsafe to set on an object created via `{}`, but is\n// fine for `Object.create(null)`\nconst key2 = \"__proto__\";\n\nconst obj = te.run`\\\n  const obj = Object.create(null);\n  obj[${te.lit(key1)}] = 1;\n  obj[${te.lit(key2)}] = { str: true };\n  return obj;\n`;\n\nassert.equal(typeof obj, \"object\");\nassert.equal(obj.one, 1);\nassert.deepEqual(obj.__proto__, { str: true });\n```\n\n----------------------------------------\n\nTITLE: Querying Forums with Custom Cross-table Ordering (GraphQL)\nDESCRIPTION: Illustrates the use of a custom orderBy enum value (LAST_POST_CREATED_AT_DESC) in a GraphQL query to order forums by the timestamp of their most recent post, made possible by a plugin extending ForumOrderBy. Requires that the described TypeScript plugin is installed and applied. Returns forums in descending order of their latest posts, showing id and name fields for each.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsOrderedByMostRecentPost {\n  allForums(orderBy: [LAST_POST_CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the EXPORTABLE Helper Function in JavaScript\nDESCRIPTION: Provides the plain JavaScript source code for the `EXPORTABLE` helper function, equivalent to the TypeScript version. It takes a factory, arguments, and an optional name hint, runs the factory, and attaches export metadata properties (`$exporter$factory`, `$exporter$args`, `$exporter$name`) to the result.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nexport function EXPORTABLE(factory, args, nameHint) {\n  const fn = factory(...args);\n  if (\n    ((typeof fn === \"object\" && fn !== null) || typeof fn === \"function\") &&\n    !(\"$exporter$factory\" in fn)\n  ) {\n    Object.defineProperties(fn, {\n      $exporter$args: { value: args },\n      $exporter$factory: { value: factory },\n      $exporter$name: { writable: true, value: nameHint },\n    });\n  }\n  return fn;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading PostGraphile Plugins via CLI (Bash)\nDESCRIPTION: Demonstrates how to load PostGraphile schema plugins using the `--append-plugins` command-line option. Examples show loading a plugin from a local JavaScript file and loading a plugin installed via npm. Requires PostGraphile CLI and a PostgreSQL database connection string (`-c`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# For a local file:\npostgraphile \\\n  --append-plugins `pwd`/add-http-bin-plugin.js \\\n  -c postgres:///mydb\n\n# Or, for an npm plugin:\npostgraphile \\\n  --append-plugins postgraphile-plugin-connection-filter \\\n  -c postgres:///mydb\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom CORS Plugin for PostGraphile - JavaScript\nDESCRIPTION: This snippet defines a factory function `makeAllowedOriginTweak` that returns a plugin object tailored for PostGraphile. The plugin injects CORS headers into HTTP responses, allowing only requests from a specified origin and whitelisting necessary methods and headers. The function can be used as a plugin within the PostGraphile pluginHook. There are no external dependencies beyond a PostGraphile context, and the key parameter is `origin`, which specifies the allowed source. Input is an origin string, and output is a plugin object for PostGraphile server integration. Limitation: The approach is suitable when custom middleware is not an option.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\n/**\n * This server plugin injects CORS headers to allow requests only from a specific origin.\n * /\n\nfunction makeAllowedOriginTweak(origin) {\n  return {\n    [\"postgraphile:http:handler\"](req, { res }) {\n      res.setHeader(\"Access-Control-Allow-Origin\", origin);\n      res.setHeader(\"Access-Control-Allow-Methods\", \"HEAD, GET, POST\");\n      res.setHeader(\n        \"Access-Control-Allow-Headers\",\n        [\n          \"Origin\",\n          \"X-Requested-With\",\n          // Used by `express-graphql` to determine whether to expose the GraphiQL\n          // interface (`text/html`) or not.\n          \"Accept\",\n          // Used by PostGraphile for auth purposes.\n          \"Authorization\",\n          // Used by GraphQL Playground and other Apollo-enabled servers\n          \"X-Apollo-Tracing\",\n          // The `Content-*` headers are used when making requests with a body,\n          // like in a POST request.\n          \"Content-Type\",\n          \"Content-Length\",\n          // For our 'Explain' feature\n          \"X-PostGraphile-Explain\",\n        ].join(\", \"),\n      );\n      res.setHeader(\n        \"Access-Control-Expose-Headers\",\n        [\"X-GraphQL-Event-Stream\"].join(\", \"),\n      );\n      return req;\n    },\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Restricting to Default Allowed Content Types in Grafserv V4 Preset (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to restrict Grafserv to only the default allowed content types within a V4 preset. By setting allowedRequestContentTypes to DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES, it disables 'application/x-www-form-urlencoded' unless explicitly needed. Dependencies are 'grafserv' and 'graphile-config', and the configuration goes in graphile.config.ts. Inputs are extended V4 preset and allowed content types; outputs a safer, more compliant HTTP policy. Should be used if form-encoded content is not required.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES } from \"grafserv\";\n\nconst preset: GraphileConfig.Preset = {\n  //... extends V4 preset ...\n\n  grafserv: {\n    //...\n\n    allowedRequestContentTypes: DEFAULT_ALLOWED_REQUEST_CONTENT_TYPES,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example .postgraphilerc.js Configuration for PostGraphile\nDESCRIPTION: Provides a sample JavaScript configuration file (`.postgraphilerc.js`) for PostGraphile. It demonstrates how to export an options object containing settings like database connection string, schema names (as an array), JWT secret, default role, JWT token identifier, and watch mode activation. This method allows centralizing configuration instead of using only command-line arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nmodule.exports = {\n  options: {\n    connection: \"postgres://api_user:api_password@localhost/api_development\",\n    schema: [\"myApp\", \"myAppPrivate\"],\n    jwtSecret: \"myJwtSecret\",\n    defaultRole: \"myapp_anonymous\",\n    jwtTokenIdentifier: \"myApp.jwt_token\",\n    watch: true,\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Connecting with psql to a Specific Database - Bash\nDESCRIPTION: Shows how to connect with psql to the \"mydb\" PostgreSQL database, displaying the prompt received on connection. Requires prior creation of the database and that PostgreSQL is running locally. Success is indicated by the database version and prompt output.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///mydb\"\npsql (14.*)\nType \"help\" for help.\n\n=#\n```\n\n----------------------------------------\n\nTITLE: Defining OrderByAscDescOptions and NullsSortMethod Types in TypeScript\nDESCRIPTION: Defines the TypeScript interface `OrderByAscDescOptions` and the type alias `NullsSortMethod`. These are used to configure how null values are sorted within an order-by clause. The `unique` option can also be specified. These types remain consistent between V4 and V5.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nexport interface OrderByAscDescOptions {\n  unique?: boolean;\n  nulls?: NullsSortMethod;\n}\n\nexport type NullsSortMethod =\n  | \"first\"\n  | \"last\"\n  | \"first-iff-ascending\"\n  | \"last-iff-ascending\"\n  | undefined;\n```\n\n----------------------------------------\n\nTITLE: Calling a Replacement Inflector Method (TypeScript)\nDESCRIPTION: This short TypeScript snippet demonstrates how calling code can invoke a replacement inflector method. The calling code supplies only the arguments specific to the inflector (e.g., 'Query'); the system handles contextual parameters. This assumes the replacement plugin is already configured in PostGraphile. It expects 'inflection' to be available in the context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-inflectors-plugin.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst text = inflection.builtin(\\\"Query\\\");\n```\n\n----------------------------------------\n\nTITLE: Optimized Webpack Configuration for PostGraphile Lambda Deployment (V4 Context) in JavaScript\nDESCRIPTION: This JavaScript code presents an optimized Webpack configuration for PostGraphile, derived from a V4 Lambda example, focusing on reducing bundle size. It targets Node.js and utilizes `DefinePlugin` and `NormalModuleReplacementPlugin` to replace native modules (`pg-native`), omit subscription functionality, and exclude parts of Express. It requires external stub files (`src/postgraphile-http-subscriptions.js`, `src/express-lib-view.js`) and disables mangling in Terser to avoid potential GraphQL conflicts. Note this configuration is from V4 documentation and has limitations like lack of watch mode and subscription support.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/bundling-webpack.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst webpack = require(\"webpack\");\nconst TerserPlugin = require(\"terser-webpack-plugin\");\n\nmodule.exports = {\n  //...\n\n  target: \"node\",\n  plugins: [\n    // Prevent loading pg-native (in a weird, backwards kind of way!)\n    new webpack.DefinePlugin({\n      // Nice light dependencies\n      \"process.env.NODE_ENV\": '\"production\"',\n      \"process.env.POSTGRAPHILE_ENV\": '\"production\"',\n\n      // Forces node-postgres to attempt to use the native module, HOWEVER we\n      // trick this below by replacing the native module with the JavaScript\n      // client using `NormalModuleReplacementPlugin`. ðŸ˜ˆ\n      \"process.env.NODE_PG_FORCE_NATIVE\": '\"1\"',\n\n      // Set this if you want the smallest bundle; it excludes GraphiQL\n      \"process.env.POSTGRAPHILE_OMIT_ASSETS\": '\"1\"',\n    }),\n\n    // Here's where we replace the native `pg` module reference with the\n    // JavaScript client. (See NODE_PG_FORCE_NATIVE above.)\n    new webpack.NormalModuleReplacementPlugin(\n      /pg\\/lib\\/native\\/index\\.js$/,\n      \"../client.js\",\n    ),\n\n    // Omit websocket functionality from postgraphile:\n    new webpack.NormalModuleReplacementPlugin(\n      /postgraphile\\/build\\/postgraphile\\/http\\/subscriptions\\.js$/,\n      `${__dirname}/src/postgraphile-http-subscriptions.js`,\n    ),\n\n    // Just in case you install express, omit the expensive view file:\n    new webpack.NormalModuleReplacementPlugin(\n      /express\\/lib\\/view\\.js$/,\n      `${__dirname}/src/express-lib-view.js`,\n    ),\n  ],\n\n  // We don't need to use __dirname any more:\n  node: {\n    __dirname: false, // just output `__dirname`\n  },\n\n  // Without this, you may get errors such as `Error: GraphQL conflict for 'e'\n  // detected! Multiple versions of graphql exist in your node_modules?`\n  // May not be necessary for newer versions of the `graphql` module.\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          mangle: false, // < This is the important part\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Running PostGraphile with Default Role - Bash\nDESCRIPTION: This bash command runs PostGraphile with a specified connection string and also assigns a '--default-role', setting the default database role used by PostGraphile for anonymous or role-less requests. Dependencies: PostGraphile CLI, existing roles in PostgreSQL. Parameters: Connection string, '--default-role' flag. Input: CLI command/flags. Output: GraphQL API started with 'default_role' as the fallback PostgreSQL role for unauthenticated connections.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/default-role.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npostgraphile -c postgres://auth_user@localhost/mydb --default-role default_role\n```\n\n----------------------------------------\n\nTITLE: Using EXPORTABLE Wrapper for Function Export in JavaScript\nDESCRIPTION: Introduces the `EXPORTABLE` function from `graphile-export`. It shows how to wrap a function definition, explicitly passing the closed-over variable `a` as a dependency, making the function exportable.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n> const { EXPORTABLE } = require(\"graphile-export\")\nundefined\n> const a = 7;\nundefined\n> const add = EXPORTABLE((a) => function add(b) { return a + b; }, [a]);\nundefined\n```\n\n----------------------------------------\n\nTITLE: Removing the @graphile/supporter Package Using Yarn (Shell)\nDESCRIPTION: This snippet demonstrates uninstalling the deprecated @graphile/supporter Node.js package from the project using yarn. This step is necessary to avoid module conflicts and to cleanly transition to the new @graphile/pg-pubsub package. The command removes the dependency from both node_modules and package.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/pg-pubsub-migration.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn remove @graphile/supporter\n```\n\n----------------------------------------\n\nTITLE: Selecting a Computed Column Directly in SQL (SQL)\nDESCRIPTION: Shows two ways to select the computed column in raw SQL: as a pseudo-column or an explicit function call. Requires the function 'person_full_name' and a table 'person'. Expects an 'id' parameter and returns the id and computed full name. Demonstrates PostgreSQL's special support for treating function calls as virtual columns.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/computed-columns.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nselect\n  person.id,\n  person.person_full_name as full_name\n  -- or, equivalently:\n  -- person_full_name(person) as full_name\nfrom person\nwhere id = $1;\n```\n\n----------------------------------------\n\nTITLE: Rebuilding and Running the Dockerized GraphQL API - shell\nDESCRIPTION: Lists shell commands to shut down existing Docker containers, rebuild the updated GraphQL container, and bring all services back up. Intended to be run from a terminal at the project root. Prerequisites include a valid docker-compose.yml file and Docker installed; these commands orchestrate the rebuild and redeployment process after code changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n# Shut down containers\n$ docker-compose down\n\n# Rebuild the GraphQL container\n$ docker-compose build graphql\n\n# Rerun containers\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Installing Express and PostGraphile Dependencies - Bash\nDESCRIPTION: This Bash command installs 'express' and the beta version of 'postgraphile' as dependencies in the Node.js project. Requires npm and a valid package.json. Output is a populated node_modules directory and package.json entries.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install --save express postgraphile@beta\n```\n\n----------------------------------------\n\nTITLE: Importing makeJSONPgSmartTagsPlugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the makeJSONPgSmartTagsPlugin generator from PostGraphile utilities, enabling in-code definition of smart tags rather than loading from an external source. Useful for situations where smart tags configuration is dynamic or provided by application logic. Requires 'postgraphile/utils'; intended for use in TypeScript or modern JavaScript codebases.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeJSONPgSmartTagsPlugin } from \"postgraphile/utils\";\n```\n\n----------------------------------------\n\nTITLE: Annotating a Column with Smart Comments that Omit Create/Update - SQL\nDESCRIPTION: This snippet documents how to use smart tags to rename a column and specify omission from certain operations, with a trailing description. Use COMMENT ON COLUMN with E-escaped newlines; prerequisites are an existing schema, table, and column. The output is used for schema customization in PostGraphile, and \\\\n is required for multi-line input.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is\\n  E'@name my_new_column\\\\n@omit create,update\\\\nThis is the documentation.';\n```\n\n----------------------------------------\n\nTITLE: Connecting to Custom PostgreSQL Databases - Bash\nDESCRIPTION: Shows various ways to connect to different PostgreSQL databases using psql, including connecting to a local database by name and a remote database with full credentials and host. Useful for demonstrating how to adapt connection URIs based on deployment or authentication needs. Input is several variants of the psql command; output is connection behavior (not shown).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n$ psql postgres:///testdb # Connects to the `testdb` database on your local machine\\n$ psql \\\"postgres://user:password@somehost:2345/somedb\\\"  # Connects to the `somedb` database at `postgres://somehost:2345` using login with `user` and `password`\\n```\n```\n\n----------------------------------------\n\nTITLE: Renaming Patch Types with an Inflector Plugin in Graphile (TypeScript)\nDESCRIPTION: This TypeScript module exports a plugin for Graphile that overrides the patchType inflector. Its purpose is to rename generated input types from '*Patch' to '*PatchSet', e.g., 'UserPatch' becomes 'UserPatchSet'. Dependencies include Graphile's plugin API and its inflector system; it should be registered as a plugin with your Graphile server setup. The key parameter is typeName, representing the base type being patched. The output is a modified schema where input patch types have 'PatchSet' instead of 'Patch' in their names. This is a simple demonstration intended for instructional purposes, not production use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/inflector.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Simply renames the `UserPatch` and `PostPatch` type names to be called\n * `UserPatchSet` and `PostPatchSet` instead.\n *\n * Not particularly useful, just an example. ('PatchSet' chosen to minimise\n * diff to make example clearer.)\n *\n * Replaces this inflector:\n * https://github.com/graphile/graphile-engine/blob/f3fb3878692c6959e481e517375da66503428dc5/packages/graphile-build-pg/src/plugins/PgBasicsPlugin.js#L309-L311\n */\nmodule.exports = function PgRenamePatchToPatchSetPlugin(builder) {\n  builder.hook(\"inflection\", (inflector) => ({\n    // Retain the existing inflectors\n    ...inflector,\n\n    // Override the patchType inflector\n    patchType(typeName) {\n      // return this.upperCamelCase(`${typeName}-patch`);\n      return this.upperCamelCase(`${typeName}-patch-set`);\n    },\n  }));\n};\n```\n\n----------------------------------------\n\nTITLE: Re-initializing the PostgreSQL Database in Docker with Shell Commands\nDESCRIPTION: Outlines the shell commands required to completely reset and re-initialize the PostgreSQL database when schema changes are made in the `db/init` scripts. This involves stopping containers (`docker-compose down`), finding and removing the associated Docker volume (`docker volume rm`), removing the database Docker image (`docker rmi db`) to force a rebuild, and finally restarting the services (`docker-compose up`), which rebuilds the database image and re-runs the initialization scripts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n# Stop running containers\\n$ docker-compose down\\n\\n# List Docker volumes\\n$ docker volume ls\\n\\n# Delete volume\\n$ docker volume rm <your_repository_name>_db\\n\\n# Delete database image to force rebuild\\n$ docker rmi db\\n\\n# Run containers (will automatically rebuild the image)\\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Variables in te.tagged Templates - JavaScript\nDESCRIPTION: Demonstrates the use of te.tmp() to store the result of a potentially expensive expression in a temporary variable, which is then referenced within a tagged template to prevent repeated computation. Requires the 'te' library/module and an understanding of tagged template literals in JavaScript. The function takes the object or expression to cache, and a callback that receives the temporary variable for use in a template; this ensures the original expression is only evaluated once. Inputs include a target object and a callback; output is the evaluated result using the temporary variable. This pattern is most useful in cases where the referenced object is expensive to compute or access.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-tmp.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nte.tmp(obj, tmp => te`(${tmp}.foo === 3 ? ${tmp}.bar : ${tmp}.baz)`)\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Virtual @foreignKey Constraints via JSON5\nDESCRIPTION: This snippet demonstrates how to specify multiple virtual foreign keys on a materialized view using an array value for the 'foreignKey' smart tag in JSON5. Each string in the array describes a foreign key constraint in PostgreSQL syntax. Requires PostGraphile and JSON5 parser. The input is a structured tags configuration for the relevant view. Results in multiple relationships for GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_18\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_materialized_view: {\n        tags: {\n          foreignKey: [\n            \"(key_1, key_2) references other_table (key_1, key_2)\",\n            \"(key_3, key_4) references some_other_table (key_3, key_4)\",\n          ],\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine (Flex) for PostGraphile CLI Deployment using YAML\nDESCRIPTION: Defines the Google App Engine Flexible environment configuration for a PostGraphile service deployed via the CLI. It sets up Cloud SQL instance connection via `beta_settings`, specifies Node.js runtime, service name, scaling parameters, disables health checks, and configures file skipping for deployment. The `cloud_sql_instances` setting maps the Cloud SQL Unix socket to a TCP port (5432 in this example) for connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nbeta_settings:\n  cloud_sql_instances: webstr-dev-######:us-central1:webstr-dev=tcp:5432\n\n# [START runtime]\nruntime: nodejs\nenv: flex\nthreadsafe: yes\nservice: wgraphile\n\nmanual_scaling:\n  instances: 1\nresources:\n  cpu: .5\n  memory_gb: .5\n  disk_size_gb: 10\n\nhealth_check:\n  enable_health_check: False\n\n# [END runtime]\n\nhandlers:\n  - url: /(.*)\n    static_files: ./\\1\n    upload: ./(.*)\n\n#  settings to keep gcloud from uploading files not required for deployment\nskip_files:\n  - ^node_modules$\n  - ^README\\..*\n  - ^package-lock.json\n  - \\.gitignore\n  - \\.es*\n  - ^\\.git$\n  - ^errors\\.log\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Properties with Optional Chaining using te.optionalGet in JavaScript\nDESCRIPTION: Explains how to generate property access expressions with optional chaining using te.optionalGet. This function chooses between ?.foo and ?.[\"foo\"] syntax depending on the key, which can be a string, symbol, or number. No explicit external dependencies are mentioned; context assumes code transformation or generation. Key parameter: key (string | symbol | number), and the output is a JavaScript string representing an optional-chained property access.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-get.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n# `te.optionalGet(key)`\n\nAs with `te.get` except using optional chaining - the expression will be `?.foo`\nor `?.[\"foo\"]` as appropriate.\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom OrderBy Plugin (V5) in TypeScript\nDESCRIPTION: Demonstrates the V5 equivalent of creating the `OrderByAveragePetIdPlugin` using the updated `makeAddPgTableOrderByPlugin` signature with a `match` object. The `ordersGenerator` callback now receives the `$select` step (representing the `users` table selection) and uses its alias. The `orderByAscDesc` callback returns an object containing the SQL `fragment` for the average pet ID calculation and the corresponding `codec` (e.g., `TYPES.int`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst OrderByAveragePetIdPlugin = makeAddPgTableOrderByPlugin(\n  { schemaName: \"graphile_utils\", tableName: \"users\" },\n  (build) => {\n    const { sql } = build;\n    const sqlIdentifier = sql.identifier(Symbol(\"pet\"));\n\n    const customOrderBy = orderByAscDesc(\n      \"PET_ID_AVERAGE\", // this is a ridiculous and unrealistic column but it will serve for testing purposes\n      ($select) => {\n        const orderByFrag = sql`(\n            select avg(${sqlIdentifier}.id)\n            from graphile_utils.pets as ${sqlIdentifier}\n            where ${sqlIdentifier}.user_id = ${$select.alias}.id\n          )`;\n\n        return { fragment: orderByFrag, codec: TYPES.int };\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n\n    return customOrderBy;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruru HTML Parts in Graphile Preset (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to customize Ruruâ€™s HTML rendering by configuring htmlParts in a GraphileConfig.Preset. It imports defaultHTMLParts from 'ruru/server' and overrides the title and meta tags to enhance the GraphiQL interface. Requires 'ruru' and 'graphile-config' dependencies, and the configuration is expected to be placed in graphile.config.ts. Inputs are preset and ruru.htmlParts; outputs are modified HTML for Ruruâ€™s served assets. Limitations include requiring proper preset structure and that customizations be static per process.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defaultHTMLParts } from \"ruru/server\";\n\nconst preset: GraphileConfig.Preset = {\n  //...\n  ruru: {\n    htmlParts: {\n      titleTag: \"<title>GraphiQL with Grafast support - Ruru!</title>\",\n      metaTags:\n        defaultHTMLParts.metaTags +\n        `<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />`,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Indicating a Column Has a Default via Smart Tag - SQL\nDESCRIPTION: This SQL snippet uses the @hasDefault smart tag to inform PostGraphile that a column has a default, enabling nullability in 'create' mutations. Best applied to columns whose default is not implemented as a traditional database default. Attach via COMMENT ON COLUMN syntax.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncomment on column my_schema.my_table.my_column is E'@hasDefault';\n```\n\n----------------------------------------\n\nTITLE: Creating Non-login Roles and Users in PostgreSQL - SQL\nDESCRIPTION: This snippet demonstrates two methods for creating PostgreSQL roles without LOGIN capability. Such roles are generally used for grouping permissions or for assignment to other roles, rather than database authentication. Inputs are role names; output is non-login-capable role creation. Requires PostgreSQL superuser or role-creation privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/default-role.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate role editor;\ncreate user editor nologin;\n```\n\n----------------------------------------\n\nTITLE: Dynamically Generating a Function with tamedevil in JavaScript\nDESCRIPTION: Demonstrates using 'tamedevil' (`te`) to dynamically generate a JavaScript function string. It utilizes `te.ref` to include an external variable (`source`) by reference within the generated function's scope and `te.lit` to embed a string (`spec`) as a literal. The generated code is then executed using `te.run`, and the resulting function's string representation is verified using `assert`. Requires the 'tamedevil' library and an assumed 'Source' class.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/importing.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// Here's a string we want to embed into the function:\nconst spec = \"some string here\";\n\n// And here's a complex variable we want to use within the function's scope:\nconst source = new Source(/* ... */);\n\nconst toEval = te`\\\n  const source = ${te.ref(source)};\n  return function plan($record) {\n    const $records = source.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nconst plan = te.run(toEval);\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Importing makeRegistryBuilder for @dataplan/pg in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the `makeRegistryBuilder` function from the `@dataplan/pg` library. This function serves as the entry point for constructing a registry configuration using a type-safe builder pattern, enabling the definition of codecs, resources, and relations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/registry/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { makeRegistryBuilder } from \"@dataplan/pg\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Table Pagination Cap via PostgreSQL Smart Comments - SQL\nDESCRIPTION: This snippet demonstrates how to use a PostgreSQL comment to set a default pagination cap for a specific table. The '@paginationCap' smart comment, processed by PostGraphile (Pro), restricts how many records can be fetched in a single GraphQL connection query. This relies on the Pro or Sponsor version of PostGraphile with smart comments enabled. The SQL command is applied to the 'users' table and specifies a cap of 20 records, along with a human-readable comment description. Inputs required: database superuser or ALTER privilege, and a table name. No output is expected beyond an updated table comment. Limitations include requiring the Pro or Sponsor plugin and no enforcement outside of compatible tools.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/production.mdx#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on table users is\n  E'@paginationCap 20\\nSomeone who can log in.';\n```\n\n----------------------------------------\n\nTITLE: Creating a Fastify v3 Server Instance in JavaScript\nDESCRIPTION: This snippet shows the basic setup for creating a Fastify server instance using the `Fastify` factory function imported from the `fastify` library. This instance (`app`) will be used later to mount the PostGraphile route handlers.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-library.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport Fastify from \"fastify\";\n\nconst app = Fastify({});\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Initial Project Files (Bash)\nDESCRIPTION: Stages all current changes in the project directory using `git add .` and then creates an initial commit with the message \"Initial commit\" using `git commit -m`. This saves the initial state of the project in the Git history.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-heroku.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit add . && git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Building a GraphQL Schema Instance with SchemaBuilder - JavaScript\nDESCRIPTION: This snippet illustrates the internal buildSchema method of SchemaBuilder, which synchronously generates or retrieves a cached GraphQLSchema. It first constructs a fresh build context and then calls newWithHooks to produce the schema, including any relevant hooks or customizations. Requires Graphile\\'s SchemaBuilder and a valid GraphQLSchema import. Returns a fully constructed GraphQLSchema object.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/schema-builder.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nclass SchemaBuilder {\n  // ...\n  buildSchema() {\n    const build = this.createBuild();\n    return build.newWithHooks(GraphQLSchema, {}, { isSchema: true });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Column Using JSON5 Smart Tags - JSON5\nDESCRIPTION: This JSON5 snippet shows how to deprecate a column in the GraphQL schema by adding a 'deprecated' smart tag. Intended for use in PostGraphile's smart tags JSON5 file. The attribute 'my_column' receives deprecation text, which will display as a GraphQL deprecation warning.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags.md#_snippet_3\n\nLANGUAGE: json5\nCODE:\n```\nattribute: {\n  my_column: {\n    tags: {\n      deprecated: \"Use myOtherColumn instead.\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Plugins and Building a GraphQL Schema using graphile-build-pg (JavaScript)\nDESCRIPTION: This snippet shows how to manually assemble Graphile plugins using imports from graphile-build and graphile-build-pg in JavaScript, and use them to generate a custom GraphQL schema builder. The getSchema function allows specification of PostgreSQL connection info, schemas, and additional plugins, enabling extensions or customizations. Inputs include pgConfig (PostgreSQL connection string), pgSchemas (array of PostgreSQL schemas to introspect), and additionalPlugins (custom plugin array). Output is a builder object suitable for constructing a GraphQL schema. Dependencies: 'graphile-build', 'graphile-build-pg', Node.js environment, and a running PostgreSQL database. Requires that pgConfig resolves to a valid database URL and that referenced schemas exist.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/graphile-build-pg_versioned_docs/version-4/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defaultPlugins, getBuilder } from \"graphile-build\";\nimport { defaultPlugins as pgDefaultPlugins } from \"graphile-build-pg\";\n\nasync function getSchema(\n  pgConfig = process.env.DATABASE_URL,\n  pgSchemas = [\"public\"],\n  additionalPlugins = [],\n) {\n  return getBuilder(\n    [...defaultPlugins, ...pgDefaultPlugins, ...additionalPlugins],\n    {\n      pgConfig,\n      pgSchemas,\n      pgExtendedTypes: true,\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Helper Function to Instantiate AddStep - TypeScript\nDESCRIPTION: Defines a helper function add which creates instances of the AddStep class. This pattern simplifies schema plan code and future-proofs step instantiation. Using a wrapper function allows for more maintainable and readable plans. Required dependency is the AddStep class defined previously.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nfunction add($a, $b) {\n  return new AddStep($a, $b);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Subscription Authorization Logic - PostgreSQL Function (PL/pgSQL)\nDESCRIPTION: This PL/pgSQL snippet is a template for a validate_subscription function that returns a static UUID string to always approve subscriptions, unless business logic denies access (in which case an exception is raised). Replace the logic and UUID as required. Invoke via --subscription-authorization-function or the relevant server option. Ensures subscriptions are conditionally granted and allows optional future handling for subscription revocation.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_16\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION app_hidden.validate_subscription(topic text)\nRETURNS TEXT AS $$\nBEGIN\n  IF ... THEN\n    RETURN '4A2D27CD-7E67-4585-9AD8-50AF17D98E0B'::text;\n  ELSE\n    RAISE EXCEPTION 'Subscription denied' USING errcode = '.....';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;\n```\n\n----------------------------------------\n\nTITLE: Installing Tamedevil via Yarn or NPM - Shell\nDESCRIPTION: Shows command-line instructions for installing the tamedevil module from the beta channel using both yarn and npm package managers. This snippet requires a Node.js and a compatible package management environment. It does not require any code inputs, and issues no outputs besides installing the package for later project use. No additional dependencies are necessary beyond having yarn or npm installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn add tamedevil@beta\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save tamedevil@beta\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP App Engine (Flex) for PostGraphile Library Deployment using YAML\nDESCRIPTION: Defines the Google App Engine Flexible environment configuration for an Express application using the PostGraphile library. It specifies the Node.js runtime, sets environment variables (`PGUSER`, `PGHOST`, `PGPASSWORD`, `PGDATABASE`) for database connection using the Cloud SQL proxy socket path, and configures the Cloud SQL instance connection via `beta_settings`. This setup requires the flexible environment for potential websocket support.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-gcp.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nruntime: nodejs\nenv: flex\n\nenv_variables:\n  PGUSER: \"your-database-user\"\n  PGHOST: \"/cloudsql/your-cloudsql-instance-connection-string\"\n  PGPASSWORD: \"your-password\"\n  PGDATABASE: \"your-database-name\"\n\nbeta_settings:\n  cloud_sql_instances: your-cloudsql-instance-connection-string\n```\n\n----------------------------------------\n\nTITLE: Example PostGraphile Naming Conflict Error\nDESCRIPTION: Provides a concrete example of a naming conflict error message generated by PostGraphile. It highlights a clash between an attribute field ('task' on 'Subtask') and a singular relation field ('taskByMyTask' on 'Subtask') trying to use the same key 'task'. This illustrates the type of error discussed in the document.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/errors/nc.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nError: A naming conflict has occurred - two entities have tried to define the same key 'task'.\n  The first entity was:\n    Adding 'task' attribute field to GraphQL type 'Subtask' (representing PgCodec 'subtask')\n  The second entity was:\n    Adding field to GraphQL type 'Subtask' for singular relation 'taskByMyTask'\n  Details: https://err.red/pnc\n```\n\n----------------------------------------\n\nTITLE: Defining FinalizePlan for Plan Finalization (Pseudocode)\nDESCRIPTION: Describes the `FinalizePlan` function which marks a given plan as finalized. It calls an internal `finalize` function provided by the plan and sets the plan's `finalized` property to true.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_10\n\nLANGUAGE: pseudocode\nCODE:\n```\nFinalizePlan(aether, plan):\n\n- Let {finalize} be the internal function provided by {plan} for finalizing the plan.\n- Calling {finalize}.\n- Let {plan}.{finalized} be {true}.\n```\n\n----------------------------------------\n\nTITLE: Rebuilding and Restarting Docker Containers via Shell Commands\nDESCRIPTION: Provides shell commands using `docker-compose` to manage the application stack after code changes. `docker-compose down` stops existing containers, `docker-compose build graphql` rebuilds the specific `graphql` service image to include the newly added custom plugin, and `docker-compose up` restarts the application with the updated configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n# Shut down containers\n$ docker-compose down\n\n# Rebuild the GraphQL container\n$ docker-compose build graphql\n\n# Rerun containers\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Defining Types and Signature for makeAddInflectorsPlugin in TypeScript\nDESCRIPTION: Provides the TypeScript interface definitions for `Inflectors` and `InflectorsGenerator`, along with the function signature for `makeAddInflectorsPlugin`. This outlines the expected structure for inflector objects and generator functions used with the plugin factory.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-inflectors-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Inflectors {\n  [str: string]: (...args: Array<any>) => string;\n}\n\ntype InflectorsGenerator = (\n  inflection: Inflectors,\n  build: Build,\n  options: Options,\n) => Inflectors;\n\nfunction makeAddInflectorsPlugin(\n  additionalInflectorsOrGenerator: Inflectors | InflectorsGenerator,\n  replace = false,\n): Plugin;\n```\n\n----------------------------------------\n\nTITLE: Defining makeAddPgTableConditionPlugin Signature in Graphile V4 (TypeScript)\nDESCRIPTION: Shows the simplified TypeScript signature for `makeAddPgTableConditionPlugin` in Graphile V4. It takes schema/table names, a field spec generator, and a condition generator function that receives runtime values and SQL helpers to produce an SQL fragment.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// V4 signature\nfunction makeAddPgTableConditionPlugin(\n  schemaName: string,\n  tableName: string,\n  conditionFieldName: string,\n  fieldSpecGenerator: (build: Build) => GraphQLInputFieldConfig,\n  conditionGenerator: (\n    value: unknown,\n    helpers: { queryBuilder: QueryBuilder; sql: PgSQL; sqlTableAlias: SQL },\n    build: Build,\n  ) => SQL,\n): Plugin;\n```\n\n----------------------------------------\n\nTITLE: Printing Graphile Configuration using Bash\nDESCRIPTION: Introduces the 'graphile config print' command as part of the new 'graphile' command-line tool (pull request #176). This command allows users to view their resolved Graphile configuration, incorporating presets and plugins, which is useful for debugging and verification.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile/CHANGELOG.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngraphile config print\n```\n\n----------------------------------------\n\nTITLE: Setting Graphile License Environment Variable on Heroku\nDESCRIPTION: This command illustrates how to configure the `GRAPHILE_LICENSE` environment variable for a Heroku application using the Heroku CLI. This is necessary for enabling premium Graphile plugins within the Heroku environment. The `heroku config:set` command updates the application's configuration variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# Heroku\nheroku config:set GRAPHILE_LICENSE=\"license_key_from_graphile_store\" -a my_heroku_app\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Schema Change for Adding Viewer Field - Diff\nDESCRIPTION: Shows the resulting GraphQL schema diff after adding the â€˜viewerâ€™ SQL function. Highlights the insertion of a â€˜viewer: Userâ€™ root-level field. Useful for visualizing how database-level additions appear at the GraphQL API level.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/function-gallery.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -1795,6 +1795,7 @@\n\n   \"\"\"Chosen by fair dice roll. Guaranteed to be random. XKCD#221\"\"\"\n   randomNumber: Int\n+  viewer: User\n\n   \"\"\"Reads a single `Forum` using its globally unique `ID`.\"\"\"\n   forumByNodeId(\n\n```\n\n----------------------------------------\n\nTITLE: HTTP Authorization Header Example for JWT Transfer - Shell\nDESCRIPTION: Demonstrates the correct format for transmitting JWT tokens to the API server using the 'Authorization' HTTP header with the 'Bearer' scheme. No dependencies needed. Replace 'JWT_TOKEN_HERE' with a real token. Applied for API requests to securely authenticate via JWT.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nAuthorization: Bearer JWT_TOKEN_HERE\n```\n\n----------------------------------------\n\nTITLE: Specifying Node ID Variant for Function Arguments using Annotation\nDESCRIPTION: Introduces the `@arg0variant nodeId` annotation, used within the `postgraphile/presets/relay` preset. This annotation allows functions to specify that an argument (indexed starting from 0) should accept a Relay Node ID, particularly when the argument's type is a table type.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_10\n\nLANGUAGE: annotation\nCODE:\n```\n@arg0variant nodeId\n```\n\n----------------------------------------\n\nTITLE: Selecting User Account by Email (PL/pgSQL)\nDESCRIPTION: Selects user data from the 'person_account' table given an email parameter, assigning it to a local PL/pgSQL variable for further authentication logic. Requires that the email argument be provided and that the target table/row exists. The input is the email address ('$1'); the output is assignment of the database row to the local 'account' variable or null if not found.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_34\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\nselect a.* into account\nfrom forum_example_private.person_account as a\nwhere a.email = $1;\n```\n\n----------------------------------------\n\nTITLE: Wrapping Specifications with Hooks in Graphile Engine (JavaScript)\nDESCRIPTION: Demonstrates the usage and effect of the newWithHooks function versus applying multiple hooks manually when instantiating a GraphQLObjectType within the Graphile engine. The first snippet initializes a GraphQL type via the newWithHooks utility, while the second elaborates on the effective order of hook application through composition. Assumes dependencies on GraphQL's GraphQLObjectType, and that the plugins/registering logic is in place. The expected input is a spec object for the type, and the output is an instance of GraphQLObjectType, potentially augmented by a sequence of hooks.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/hooks.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst MyType = newWithHooks(GraphQLObjectType, spec);\n\n```\n\nLANGUAGE: js\nCODE:\n```\nconst MyType = new GraphQLObjectType(hook3(hook2(hook1(spec))));\n\n```\n\n----------------------------------------\n\nTITLE: Creating Non-Login Roles in PostgreSQL - SQL\nDESCRIPTION: Presents two equivalent SQL statements for creating a role (editor) without login privileges in PostgreSQL. Either form (with 'create role' or 'create user' and 'nologin') yields a non-authenticatable role intended for permission assignment only. Change 'editor' to another name to use. Output is a non-login role typically used for grouping privileges.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/default-role.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate role editor;\ncreate user editor nologin;\n\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile and Plugins using CommonJS in JavaScript\nDESCRIPTION: Shows how to import the `postgraphile` library, `makePluginHook` utility, and specific PostGraphile plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) using Node.js CommonJS `require` syntax.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/plugins.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst { postgraphile, makePluginHook } = require(\"postgraphile\");\nconst { default: OperationHooks } = require(\"@graphile/operation-hooks\");\nconst { default: PgPubsub } = require(\"@graphile/pg-pubsub\");\nconst { default: GraphilePro } = require(\"@graphile/pro\");\n```\n```\n\n----------------------------------------\n\nTITLE: Importing tamedevil (te) using CommonJS in JavaScript\nDESCRIPTION: Imports the 'te' tagged template literal function from the 'tamedevil' library using the CommonJS 'require' syntax. This method is typically used in Node.js environments that do not use ES Modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/importing.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst { te } = require(\"tamedevil\");\n```\n\n----------------------------------------\n\nTITLE: Defining makeAddPgTableConditionPlugin Signature in Graphile V5 (TypeScript)\nDESCRIPTION: Displays the updated TypeScript signature for `makeAddPgTableConditionPlugin` in Graphile V5. Key changes include a `match` object for identifying the target table and an optional `conditionGenerator` that now operates on `FieldArgs` (representing plan steps) rather than concrete values, using `$condition.placeholder` for input. Alternatively, an `applyPlan` can be used within the `fieldSpecGenerator`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-condition-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// V5 signature\nfunction makeAddPgTableConditionPlugin(\n  match: { serviceName?: string; schemaName: string; tableName: string },\n  conditionFieldName: string,\n  fieldSpecGenerator: (build: GraphileBuild.Build) => GraphileInputFieldConfig,\n\n  // OPTIONAL:\n  conditionGenerator?: (\n    value: FieldArgs,\n    helpers: {\n      $condition: PgConditionStep<PgSelectStep>;\n      sql: typeof sql;\n      sqlTableAlias: SQL;\n      build: GraphileBuild.Build;\n    },\n  ) => SQL | null | undefined,\n): GraphileConfig.Plugin;\n```\n\n----------------------------------------\n\nTITLE: Plain JavaScript Implementation of EXPORTABLE Utility Function\nDESCRIPTION: A JavaScript (non-TypeScript) version of the EXPORTABLE utility. The function signature is simplified to use generic parameters, but the logic (factory+args+optional name, exports metadata as special properties on the function/object) is identical to the TypeScript version. Inputs: factory, args, nameHint; output: export-ready function.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nexport function EXPORTABLE(factory, args, nameHint) {\n  const fn = factory(...args);\n  if (\n    ((typeof fn === \"object\" && fn !== null) || typeof fn === \"function\") &&\n    !(\"$exporter$factory\" in fn)\n  ) {\n    Object.defineProperties(fn, {\n      $exporter$args: { value: args },\n      $exporter$factory: { value: factory },\n      $exporter$name: { writable: true, value: nameHint },\n    });\n  }\n  return fn;\n}\n```\n\n----------------------------------------\n\nTITLE: Example psql Error: Connection Refused using Bash\nDESCRIPTION: Shows an example error message from `psql` indicating it could not connect to the PostgreSQL server because the connection was refused. This typically means the PostgreSQL server process is not running, not listening on the expected interface/port, or a firewall is blocking the connection.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ psql \"postgres:///\"\n\npsql: could not connect to server: Connection refused\n```\n\n----------------------------------------\n\nTITLE: Smart Tagging Table with Shorthand @refVia - SQL\nDESCRIPTION: Demonstrates a simplified smart tag usage for the 'log_entries' table using table shorthand 'via:' syntax for PostGraphile. Reduces complexity when only one foreign key exists per table. Requirements are as above; this is a more concise alternative to the previous approach.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/polymorphism.md#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table polymorphic.log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:people\n  @refVia author via:organizations\n  $$;\n\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Requirement\nDESCRIPTION: Specifies that TypeScript version 5 is now a required dependency for the project.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nTypeScript v5 is now required\n```\n\n----------------------------------------\n\nTITLE: Updating package.json for TypeScript Compilation\nDESCRIPTION: Example `package.json` snippet demonstrating necessary updates after converting a plugin to TypeScript. It specifies the compiled output (`main`, `types`), includes the output directory in `files`, adds `watch` and `prepack` scripts for compilation, and lists required `devDependencies` like `typescript` and `@tsconfig/node18`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    // ...\n    \"watch\": \"tsc --watch\",\n    \"prepack\": \"tsc\"\n  },\n  \"devDependencies\": {\n    // ...\n    \"@tsconfig/node18\": \"^18.2.4\",\n    \"typescript\": \"^5.7.2\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Graphile Plugin Generator to Remove Specific GraphQL Fields in JavaScript\nDESCRIPTION: This JavaScript code defines a factory function `removeFieldPluginGenerator` that produces Graphile build plugins. Each generated plugin hooks into the `GraphQLObjectType:fields` phase of the schema build process. It checks if the current object type matches the specified `objectName` and, if so, removes the field specified by `fieldName` using `lodash/omit`. The example demonstrates creating a plugin to remove the 'bar' field from the 'Foo' type. Requires the 'lodash' library.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/extending-raw.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst omit = require(\"lodash/omit\");\n\nfunction removeFieldPluginGenerator(objectName, fieldName) {\n  const fn = function (builder) {\n    builder.hook(\"GraphQLObjectType:fields\", (fields, _, { Self }) => {\n      if (Self.name !== objectName) return fields;\n      return omit(fields, [fieldName]);\n    });\n  };\n  // For debugging:\n  fn.displayName = `RemoveFieldPlugin:${objectName}.${fieldName}`;\n  return fn;\n}\n\nconst RemoveFooDotBarPlugin = removeFieldPluginGenerator(\"Foo\", \"bar\");\n\nmodule.exports = RemoveFooDotBarPlugin;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function with Unnamed Arguments\nDESCRIPTION: Defines the `add` function using unnamed positional arguments (`int, int`). Inside the function body, arguments are referenced using numeric placeholders like `$1` and `$2`. This function is marked `IMMUTABLE` and `STRICT`. PostGraphile will auto-generate names like `arg1`, `arg2` for unnamed arguments in the GraphQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION add(int, int) RETURNS int AS $$\n  SELECT $1 + $2;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n\n----------------------------------------\n\nTITLE: Registering TagsFilePlugin for Smart Tags - PostGraphile in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to load the default 'postgraphile.tags.json5' tags file in PostGraphile library mode by appending the built-in TagsFilePlugin to the 'appendPlugins' option. It shows the necessary import via require and setting up the middleware with the plugin, enabling auto-loading and watching of the tags file. The key parameters include DATABASE_URL and SCHEMAS; the 'TagsFilePlugin' is provided directly.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-tags-file.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.use(\\n  postgraphile(DATABASE_URL, SCHEMAS, {\\n    // ...\\n    appendPlugins: [\\n      // Automatically loads and watches the 'postgraphile.tags.json5' file:\\n      require(\\\"postgraphile/plugins\\\").TagsFilePlugin,\\n    ],\\n  }),\\n);\\n\n```\n\n----------------------------------------\n\nTITLE: Triggering a Subscription Update using pg_notify - SQL (Basic Payload)\nDESCRIPTION: This SQL statement sends a NOTIFY message to the topic 'postgraphile:hello' with an empty JSON object as payload, triggering the listen subscription for that topic. This requires a running PostgreSQL server and makes use of the built-in pg_notify function. Subscribers listening on this topic using the PostGraphile GraphQL API will receive the event.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nselect pg_notify(\n  'postgraphile:hello',\n  '{}'\n);\n```\n\n----------------------------------------\n\nTITLE: Updating `connection()` Step Signature in TypeScript/diff\nDESCRIPTION: This diff snippet highlights a breaking change introduced in PR #1978 for the `connection()` step. It shows that the previous signature accepting multiple arguments after the initial list (`$list, nodePlan, cursorPlan`) has been replaced. The new signature requires a configuration object as the second argument, containing properties like `nodePlan` and `cursorPlan`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n-return connection($list, nodePlan, cursorPlan);\n+return connection($list, { nodePlan, cursorPlan });\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring npm Scripts and Package Metadata - Diff (JSON)\nDESCRIPTION: This diff-style JSON snippet describes modifications to package.json to enable environment-specific scripts, module type, and dependency versions. Notable scripts are 'start' for running source with Node type stripping, 'build' for TypeScript compilation, and 'prod' for production server execution. Ensures all relevant dependencies are declared; requires npm and proper Node.js/TypeScript setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_24\n\nLANGUAGE: diff\nCODE:\n```\n {\n   \\\"name\\\": \\\"simple_node_project\\\",\\n   \\\"version\\\": \\\"1.0.0\\\",\\n+  \\\"private\\\": true,\\n+  \\\"type\\\": \\\"module\\\",\\n   \\\"scripts\\\": {\\n+    \\\"start\\\": \\\"node --env-file=./.env src/server.ts\\\",\\n+    \\\"build\\\": \\\"tsc\\\",\\n+    \\\"prod\\\": \\\"node dist/server.js\\\"\\n   },\\n   \\\"dependencies\\\": {\\n     \\\"@graphile/simplify-inflection\\\": \\\"^8.0.0-beta.6\\\",\\n     \\\"express\\\": \\\"^4.21.2\\\",\\n     \\\"postgraphile\\\": \\\"^5.0.0-beta.38\\\"\\n   },\\n   \\\"devDependencies\\\": {\\n     \\\"@tsconfig/node22\\\": \\\"^22.0.0\\\",\\n     \\\"@types/express\\\": \\\"^5.0.0\\\",\\n     \\\"@types/node\\\": \\\"^20.11.24\\\",\\n     \\\"typescript\\\": \\\"^5.7.3\\\"\\n   }\\n }\n```\n\n----------------------------------------\n\nTITLE: Populating the Pagila Database using psql\nDESCRIPTION: This command uses the PostgreSQL `psql` command-line utility to connect to the 'pagila' database and execute SQL scripts. The `-f` option specifies the schema (`pagila-schema.sql`) and data (`pagila-data.sql`) files to load. The `-Xv ON_ERROR_STOP=1` flags ensure the process stops if any errors occur during script execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/src/examples/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npsql pagila -Xv ON_ERROR_STOP=1 -f pagila-schema.sql -f pagila-data.sql\n```\n\n----------------------------------------\n\nTITLE: Renaming pgIntrospection Helper Functions for Service Retrieval\nDESCRIPTION: Shows the renaming of helper functions within `helpers.pgIntrospection`: `getDatabase` becomes `getService` and `getExecutorForDatabase` becomes `getExecutorForService`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nhelpers.pgIntrospection.getDatabase -> helpers.pgIntrospection.getService\nhelpers.pgIntrospection.getExecutorForDatabase -> helpers.pgIntrospection.getExecutorForService\n```\n\n----------------------------------------\n\nTITLE: Creating a New Heroku Application (Bash)\nDESCRIPTION: Uses the Heroku CLI `create` command to provision a new application on Heroku with the specified name (`myappname`). Requires the Heroku CLI to be installed and logged in.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nheroku create myappname\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile via npm - Bash\nDESCRIPTION: Installs PostGraphile globally using npm, making the CLI accessible anywhere on the system as the 'postgraphile' command. Requires Node.js and npm to be installed prior to running this command. This is the foundational step to enable further PostGraphile CLI usage.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/usage-cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g postgraphile\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL with withPgClient in TypeScript\nDESCRIPTION: This TypeScript code demonstrates using the `withPgClient` function to execute a raw SQL query. It retrieves a PostgreSQL client via an executor obtained from a registry, defines a constant step `$twenty`, runs a `SELECT 22` statement using the client provided in the callback, processes the result, and combines it with data passed via the `$data` parameter (`$twenty`). Requires `@dataplan/pg`, `grafast`, and a pre-configured PostgreSQL executor. The client object's specific type depends on the adapter but guarantees a `query` method.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/withPgClient.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { withPgClient } from \"@dataplan/pg\";\nimport { constant } from \"grafast\";\nimport { registry } from \"./myRegistry\";\n\n// Grab executor from the registry\nconst executor = pgRegistry.pgExecutors.main;\n\nfunction meaningOfLifePlan() {\n  // Arbitrary data for our callback to use\n  const $twenty = constant(20);\n\n  // 20 + 22 = 42\n  const $meaningOfLife = withPgClient(\n    executor,\n    $twenty,\n    async (client, twenty) => {\n      // The client that you receive will be dependent on the adaptor you're\n      // using, but must have a `query` method:\n      const {\n        rows: [{ num }],\n      } = await client.query({ text: `select 22 as num` });\n\n      return twenty + parseInt(num, 10);\n    },\n  );\n\n  return $meaningOfLife;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple SQL Function in PostgreSQL\nDESCRIPTION: Defines a basic PostgreSQL function named `add` that takes two integer arguments (`a`, `b`) and returns their sum. It uses the `sql` language, is marked `IMMUTABLE` (meaning its result depends only on its arguments and it doesn't query data or have side effects), and `STRICT` (meaning it returns NULL if any argument is NULL).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/functions.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE FUNCTION add(a int, b int) RETURNS int AS $$\n  select a + b;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Value Interpolation in pg-sql2 JavaScript\nDESCRIPTION: This snippet highlights an incorrect usage pattern in `pg-sql2`. Directly embedding non-`sql` values like the integer `1` within an `sql` tagged template literal is disallowed and will throw an error, enforcing the library's safety mechanism against SQL injection. Values must be wrapped using `sql.value()` or `sql.literal()`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/pg-sql2/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nsql`select ${1}`;\n```\n\n----------------------------------------\n\nTITLE: Example Standard GraphQL Query (GraphQL)\nDESCRIPTION: A basic GraphQL query to fetch the names of all people. This example serves as a baseline to demonstrate the conversion to a live query subscription.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL Function with Unnamed Arguments (SQL)\nDESCRIPTION: Defines a PostgreSQL function `add` using `LANGUAGE sql` with unnamed (positional) integer arguments. The arguments are accessed within the function body using positional references `$1` and `$2`. While functional in PostgreSQL, this style is discouraged when using PostGraphile, as it requires PostGraphile to auto-generate argument names like `arg1`, `arg2`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\n```sql\nCREATE FUNCTION add(int, int) RETURNS int AS $$\n  SELECT $1 + $2;\n$$ LANGUAGE sql IMMUTABLE STRICT;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for V4 Plugin Migration\nDESCRIPTION: Example `tsconfig.json` configuration for converting a PostGraphile V4 plugin project to TypeScript. It extends `@tsconfig/node18`, sets output directories, enables declaration generation, and optionally disables `noImplicitAny` initially to ease the V4 migration due to looser V4 types. It also includes `allowJs` for JavaScript tests.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": \"@tsconfig/node18/tsconfig.json\",\n  \"compilerOptions\": {\n    // You may want to enable this flag in V4 since V4 types were extremely\n    // loose (since it was originally written in Flow, not TypeScript):\n    //\n    // \"noImplicitAny\": false,\n\n    // If your tests are written in JS you'll need this for subpath importing\n    // to work:\n    \"allowJs\": true,\n\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"declarationDir\": \"dist\",\n    \"declaration\": true,\n    \"sourceMap\": true\n  },\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Building/Watching Project with Yarn\nDESCRIPTION: Installs project dependencies using yarn and then either compiles the TypeScript source code once or starts a watch process to recompile on file changes. This is the initial step for setting up the development environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn\nyarn watch # or 'yarn build'\n```\n\n----------------------------------------\n\nTITLE: Defining `sideEffect` with No Dependencies in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for `sideEffect` when the callback requires no input data. In this case, `null` or `undefined` is passed as the first argument instead of a step. The callback function takes no arguments and returns a result (type `R`) or a Promise resolving to `R`. The `sideEffect` function returns an `ExecutableStep<R>`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/sideEffect.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction sideEffect<R>(\n  $input: null | undefined,\n  callback: () => R | Promise<R>,\n): ExecutableStep<R>;\n```\n```\n\n----------------------------------------\n\nTITLE: Sample JWT Claims Payload - JSON\nDESCRIPTION: Provides an illustrative example of a typical JWT payload used by PostGraphile, with fields for audience ('aud'), PostgreSQL role, and user ID. This is not executable code, but demonstrates the expected shape of the claims used to map token data to SQL session variables.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/security.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"aud\": \"postgraphile\",\n  \"role\": \"app_user\",\n  \"user_id\": 27\n}\n```\n\n----------------------------------------\n\nTITLE: Adding AddQuizEntry Custom Mutation to GraphQL Schema (GraphQL Diff)\nDESCRIPTION: Includes an extensive diff showing the GraphQL schema changes from registering the 'add_quiz_entry' function as a mutation. The mutation input, output payload, and input record type for answers are displayed. The schema additions allow clients to invoke the mutation providing quiz id and list of answers, then querying the resulting quiz entry and related nodes. Must be run after the corresponding SQL function and types are defined.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/function-gallery.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\n+++ Modified GraphQL Schema\n@@ -1,3 +1,41 @@\n+\"\"\"All input for the `addQuizEntry` mutation.\"\"\"\n+input AddQuizEntryInput {\n+  \"\"\"\n+  An arbitrary string value with no semantic meaning. Will be included in the\n+  payload verbatim. May be used to track mutations by the client.\n+  \"\"\"\n+  clientMutationId: String\n+  quizId: Int!\n+  answers: [QuizEntryInputRecordInput]!\n+}\n+\n+\"\"\"The output of our `addQuizEntry` mutation.\"\"\"\n+type AddQuizEntryPayload {\n+  \"\"\"\n+  The exact same `clientMutationId` that was provided in the mutation input,\n+  unchanged and unused. May be used by a client to track mutations.\n+  \"\"\"\n+  clientMutationId: String\n+  quizEntry: QuizEntry\n+\n+  \"\"\"\n+  Our root query field type. Allows us to run any query from our mutation payload.\n+  \"\"\"\n+  query: Query\n+\n+  \"\"\"Reads a single `User` that is related to this `QuizEntry`.\"\"\"\n+  user: User\n+\n+  \"\"\"Reads a single `Quiz` that is related to this `QuizEntry`.\"\"\"\n+  quiz: Quiz\n+\n+  \"\"\"An edge for our `QuizEntry`. May be used by Relay 1.\"\"\"\n+  quizEntryEdge(\n+    \"\"\"The method to use when ordering `QuizEntry`.\"\"\"\n+    orderBy: [QuizEntriesOrderBy!] = [PRIMARY_KEY_ASC]\n+  ): QuizEntriesEdge\n+}\n+\n \"\"\"\n A floating point number that requires more precision than IEEE 754 binary 64\n \"\"\"\n@@ -1472,6 +1510,12 @@\n     \"\"\"\n     input: DeleteUserByUsernameInput!\n   ): DeleteUserPayload\n+  addQuizEntry(\n+    \"\"\"\n+    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objectâ€™s fields.\n+    \"\"\"\n+    input: AddQuizEntryInput!\n+  ): AddQuizEntryPayload\n\n   \"\"\"\n   If you've forgotten your password, give us one of your email addresses and we'\n@@ -2115,6 +2159,12 @@\n   quizId: Int!\n }\n\n+\"\"\"An input for mutations affecting `QuizEntryInputRecord`\"\"\"\n+input QuizEntryInputRecordInput {\n+  question: String\n+  answer: Int\n+}\n+\n \"\"\"\n Represents an update to a `QuizEntry`. Fields that are set will be updated.\n \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Forum Nodes JSON Response Example - JSON\nDESCRIPTION: This JSON object shows a representative response for the forum nodes GraphQL query, providing four forums with their respective nodeId, id, slug, name, and description fields. The JSON structure follows the typical GraphQL response pattern, mapping the requested fields. No dependencies are required beyond a standard JSON parser; data will match the schema generated by PostGraphile with pg-simplify-inflector.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/basic.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forums\": {\n    \"nodes\": [\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDFd\",\n        \"id\": 1,\n        \"slug\": \"testimonials\",\n        \"name\": \"Testimonials\",\n        \"description\": \"How do you rate PostGraphile?\"\n      },\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDJd\",\n        \"id\": 2,\n        \"slug\": \"feedback\",\n        \"name\": \"Feedback\",\n        \"description\": \"How are you finding PostGraphile?\"\n      },\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDNd\",\n        \"id\": 3,\n        \"slug\": \"cat-life\",\n        \"name\": \"Cat Life\",\n        \"description\": \"A forum all about cats and how fluffy they are and how they completely ignore their owners unless there is food. Or yarn.\"\n      },\n      {\n        \"nodeId\": \"WyJmb3J1bXMiLDRd\",\n        \"id\": 4,\n        \"slug\": \"cat-help\",\n        \"name\": \"Cat Help\",\n        \"description\": \"A forum to seek advice if your cat is becoming troublesome.\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple DEBUG Namespaces (PowerShell)\nDESCRIPTION: This Windows PowerShell command sets the `DEBUG` environment variable using `$env:` syntax to enable multiple comma-separated debug namespaces (`graphile-build:warn,@dataplan/pg:*`). This allows capturing debug output from various parts of the PostGraphile system when it's subsequently executed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\n# Windows PowerShell\n$env:DEBUG = \"graphile-build:warn,@dataplan/pg:*\"; postgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Defining the deduplicatedWith Method Signature for a Grafast Step Class in TypeScript\nDESCRIPTION: Shows the TypeScript signature for the optional `deduplicatedWith` lifecycle method in a Grafast `Step` subclass. This method is called on a step instance that is about to be removed during deduplication, providing it with the replacement step instance so it can transfer any necessary state or configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeduplicatedWith(\n  replacement: Step\n): void\n```\n\n----------------------------------------\n\nTITLE: Sample GraphQL-Compatible JWT Error Response - JSON\nDESCRIPTION: Shows the expected JSON format for error responses when a JWT authorization check fails on the GraphQL endpoint. The error object is returned with an 'errors' array containing a single message property. Useful to illustrate expected client-side error handling. No dependencies, simple JSON structure.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"errors\": [\n    {\n      \"message\": \"No authorization token was found\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @graphile/subscriptions-lds Plugin (Shell)\nDESCRIPTION: Shell command using Yarn to install the `@graphile/subscriptions-lds` package, which is the official PostGraphile plugin for enabling live queries using PostgreSQL's logical decoding feature.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @graphile/subscriptions-lds\n```\n\n----------------------------------------\n\nTITLE: Applying CSS Module Class Dynamically in JSX\nDESCRIPTION: This JSX snippet renders a paragraph element (`<p>`) and applies a CSS class named `showFull` dynamically using the `pricingStyles` object. This object is expected to be imported from a CSS module file (`./pricing.module.css`). This technique demonstrates scoped styling common in frameworks like React, where CSS Modules prevent global class name collisions. It depends on the `pricingStyles` object being correctly imported beforehand.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<p className={pricingStyles.showFull}>\n  For businesses which are not capable of engaging in the sponsorship model,\n  there is an option to purchase the license by itself. However, this does not\n  come with any other benefit such as priority support or discounted consultancy\n  rates.\n</p>\n```\n\n----------------------------------------\n\nTITLE: Safely Setting Object Properties with Untrusted Keys in JavaScript\nDESCRIPTION: Demonstrates the discouraged use of `te.safeKeyOrThrow` within an object literal versus the recommended, safer approach using `Object.create(null)` and bracket notation with `te.lit(untrustedKey)` to prevent prototype pollution when dealing with untrusted keys. The first snippet shows a potentially vulnerable pattern, while the second illustrates the secure pattern using a null-prototype object.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-safe-key-or-throw.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = { ${te.safeKeyOrThrow(untrustedKey)}: value }\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = Object.create(null);\n${obj}[${te.lit(untrustedKey)}] = value;\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of the Setter Modifier (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the basic usage pattern for the `setter` modifier. It initializes an empty object (`object`) and then calls the `setter` function, passing the object as an argument. The return value of the `setter` function is then returned. The exact behavior depends on the implementation of `setter`. Note the TODO comment indicating incomplete documentation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/setter.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst object = {};\nreturn setter(object);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Grafast Plan Resolver Programmatically in TypeScript\nDESCRIPTION: Demonstrates how to attach a Grafast plan resolver to a field ('meaningOfLife') when defining a GraphQL schema programmatically using `graphql-js`. The plan resolver is defined within the `extensions.grafast.plan` property of the field configuration and uses the `constant` step from Grafast to return a fixed value.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-resolvers.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { GraphQLSchema, GraphQLObjectType, GraphQLInt } from \"graphql\";\nimport { constant } from \"grafast\";\n\nconst Query = new GraphQLObjectType({\n  name: \"Query\",\n  fields: {\n    meaningOfLife: {\n      type: GraphQLInt,\n      extensions: {\n        grafast: {\n          plan() {\n            return constant(42);\n          },\n        },\n      },\n    },\n  },\n});\n\nexport const schema = new GraphQLSchema({\n  query: Query,\n});\n```\n\n----------------------------------------\n\nTITLE: Calling the sql.literal Function (Conceptual)\nDESCRIPTION: Represents the sql.literal function call which takes a value 'val'. Unlike sql.value, this function may inline simple, trusted, non-sensitive values directly into the SQL query rather than using placeholders. It is critical to only use trusted inputs and avoid user-provided data.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/pg-sql2/api/sql-literal.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nsql.literal(val)\n```\n\n----------------------------------------\n\nTITLE: Transforming a Resolver Function into an Exportable Property (TypeScript)\nDESCRIPTION: This snippet demonstrates the pattern of converting an async friend resolver method into a property whose value is an async arrow function. The property-based approach is necessary for proper wrapping with EXPORTABLE in the next pattern. No change to logic, only to definition style; dependency on db remains.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfriends: async (user, args, context, resolveInfo) => {\n  return await db.friends.loadMany(user.id, context);\n},\n```\n\n----------------------------------------\n\nTITLE: Using te.ref for Variable Referencing with Explicit Naming\nDESCRIPTION: Demonstrates using the optional second argument (`name`) of `te.ref` to force a specific identifier name (`source`) for the referenced value within the generated code. When using explicit naming, the developer is responsible for avoiding naming conflicts.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nconst source = new Source(/* ... */);\nconst spec = \"some string here\";\n\nconst plan = te.run`\\\n  return function plan($record) {\n    const $records = ${te.ref(source, \"source\")}.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Illustrative Type Definition for PolymorphicTypeMatchers (TypeScript)\nDESCRIPTION: Defines the illustrative structure of the `matchers` object parameter accepted by `polymorphicBranch`. This object maps type names (strings) to matcher objects containing optional `match` functions (to check if an object matches the type) and `plan` functions (to return a step appropriate for that type). If `match` is omitted, it defaults to checking `obj.__typename`; if `plan` is omitted, it defaults to returning the input step.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/polymorphicBranch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This type is for illustrative purposes only; the actual type is slightly\n// more complex\ntype PolymorphicTypeMatchers = {\n  [typeName: string]: {\n    match?(obj: any): boolean;\n    plan?($obj: ExecutableStep): ExecutableStep;\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Defining makeWrapResolversPlugin Method 2 Signature (TypeScript)\nDESCRIPTION: TypeScript function signature for the second method of using `makeWrapResolversPlugin`. This method accepts a `filter` function to determine which fields to wrap and a `rule` function that generates the wrapper rule or function based on the filter's output. The filter receives context, build, field, and options.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeWrapResolversPlugin<T>(\n  filter: (\n    context: Context,\n    build: Build,\n    field: GraphQLFieldConfig,\n    options: Options,\n  ) => T | null,\n  rule: (match: T) => ResolverWrapperRule | ResolverWrapperFn,\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic No-op Graphile Engine Plugin in JavaScript\nDESCRIPTION: Presents the simplest form of a Graphile Engine plugin: a function that accepts the `builder` instance as its first argument. This example logs a message to the console but performs no actions on the schema builder or registers any hooks, serving as a basic structural template for a plugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/plugins.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nfunction NoopPlugin(builder) {\n  console.log(\"I don't do anything\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Linting and Auto-Fixing with Yarn (Shell)\nDESCRIPTION: Executes the `lint:fix` script defined in `package.json`. This command runs configured linters (like ESLint or Prettier) to check the codebase for style inconsistencies or potential errors and attempts to automatically fix them. It's recommended to run this before creating a pull request.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn lint:fix\n```\n\n----------------------------------------\n\nTITLE: Defining the Optional finalize() Method in Grafast Step (TypeScript)\nDESCRIPTION: This snippet declares the optional finalize method for a Step in Grafast, which performs one-time preparation before execution. The method takes no arguments and returns void. Finalization logic may include precompilation, function optimization, or any single-execution preparatory activity required by a step, ensuring readiness for efficient execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nfinalize(): void\n```\n\n----------------------------------------\n\nTITLE: Returning Target in applyPlan - Grafast Migration Error (TypeScript)\nDESCRIPTION: This TypeScript snippet shows a deprecated pattern in Grafast, where applyPlan erroneously returns a value (typically $target). Previously, this was valid during early beta, but now returning a value from applyPlan is disallowed. The main parameter involved is $target, representing the operation or object being mutated by applyPlan. No external dependencies are required. Developers should remove the return statement to resolve the error.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/aap.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code that produces the error:\nfunction applyPlan($parent, $field, fieldArg, info) {\n  // [...]\n  return $target;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating makeWrapPlansPlugin Callback Signature (Conceptual)\nDESCRIPTION: Describes a breaking change in the `makeWrapPlansPlugin` callback. The callback function now receives the `build` object as its parameter instead of the `options` object. Options can be accessed via `build.options`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nmakeWrapPlansPlugin callback is now passed `build` rather than `options` - use `build.options` to get the options object.\n```\n\n----------------------------------------\n\nTITLE: Querying One-to-One Relationships (v3 Connection Style) in GraphQL\nDESCRIPTION: This GraphQL query shows how one-to-one relationships were typically queried in PostGraphile v3. Even though the relationship is one-to-one, it required using the standard connection pattern (`edges`/`node`) to access the related `bar` object's `name` field from a `foo` object.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/v4-new-features.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  fooById(id: 1) {\n    # Due to this being one-to-one, at most one row would ever be returned,\n    # however we didn't account for this and returned a connection anyway\n    barsByFooId {\n      edges {\n        node {\n          name\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Graphile Config Middleware with `middleware.run` in TypeScript\nDESCRIPTION: This TypeScript snippet shows how a library invokes the middleware chain for a specific action using `middleware.run()`. It passes the action name (`\"someAction\"`), an event object containing context (`{ someParameter: 42 }`), and the underlying action function to be executed after all relevant middleware have called `next()`. The result of the final action or a middleware replacement is returned.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-config/plugin/middleware.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst actionResult = await middleware.run(\n  // The \"action name\"\n  \"someAction\",\n\n  // The `event` object\n  { someParameter: 42 },\n\n  // The \"underlying action\"; this function is what will be retried if the\n  // MySomeActionRetryPlugin is included in a preset.\n  async (event) => {\n    // Extract the (possibly modified) values from the event\n    const { someParameter } = event;\n\n    // Do something:\n    return doTheThing(someParameter);\n  },\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Function Signature of makeAddPgTableConditionPlugin in TypeScript\nDESCRIPTION: The TypeScript function signature for `makeAddPgTableConditionPlugin`. It details the required parameters: `schemaName`, `tableName`, `conditionFieldName`, `conditionFieldSpecGenerator`, and `conditionGenerator`, along with their types and the function's return type (`Plugin`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-condition-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport default function makeAddPgTableConditionPlugin(\n  schemaName: string,\n  tableName: string,\n  conditionFieldName: string,\n  conditionFieldSpecGenerator: (build: Build) => GraphQLInputFieldConfig,\n  conditionGenerator: (\n    value: unknown,\n    helpers: {\n      queryBuilder: QueryBuilder;\n      sql: typeof pgsql2 /* the 'pg-sql2' module */;\n      sqlTableAlias: SQL;\n    },\n    build: Build,\n  ) => SQL | null | void,\n): Plugin;\n```\n\n----------------------------------------\n\nTITLE: Installing PostGraphile Beta using npm in Bash\nDESCRIPTION: Changes the current directory to `~/postgraphile` (a user-defined project directory) and installs the beta version of the `postgraphile` package using npm. This command downloads and saves PostGraphile as a project dependency, enabling local execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/postgraphile\nnpm install postgraphile@beta\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Input Object Default Value Injection - Diff\nDESCRIPTION: Shows the GraphQL schema diff reflecting application of SetInputObjectDefaultValue plugin, where certain 'name' fields now have a default value. Used to illustrate plugin effects on input object types, especially mandatory string fields converted to accept a default. Intended for documentation, not actual code execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/types.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n--- Original GraphQL Schema\\n+++ Modified GraphQL Schema\\n@@ -968,7 +968,7 @@\\n   slug: String!\\n\\n   \\\"\\\"\\\"The name of the `Forum` (indicates its subject matter).\\\"\\\"\\\"\\n-  name: String!\\n+  name: String = \\\"Bobby Tables\\\"\\n\\n   \\\"\\\"\\\"A brief description of the `Forum` including it's purpose.\\\"\\\"\\\"\\n   description: String\\n@@ -2127,7 +2127,7 @@\\n \\\"\\\"\\\"An input for mutations affecting `Quiz`\\\"\\\"\\\"\\n input QuizInput {\\n   id: Int\\n-  name: String!\\n+  name: String = \\\"Bobby Tables\\\"\\n   updatedAt: Datetime\\n   precision12Scale2: BigFloat\\n   precision200Scale100: BigFloat\\n@@ -3343,7 +3343,7 @@\\n   username: String!\\n\\n   \\\"\\\"\\\"Public-facing name (or pseudonym) of the user.\\\"\\\"\\\"\\n-  name: String\\n+  name: String = \\\"Bobby Tables\\\"\\n\\n   \\\"\\\"\\\"Optional avatar URL.\\\"\\\"\\\"\\n   avatarUrl: String\n```\n\n----------------------------------------\n\nTITLE: Importing makePgSmartTagsFromFilePlugin with TypeScript\nDESCRIPTION: Shows how to import the `makePgSmartTagsFromFilePlugin` function from the `postgraphile/plugins` package using TypeScript's `require`. This function is the highest-level helper, designed to load smart tag configurations from a JSON5 file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst { makePgSmartTagsFromFilePlugin } = require(\"postgraphile/plugins\");\n```\n```\n\n----------------------------------------\n\nTITLE: Running a Simple SQL Query in psql - Shell\nDESCRIPTION: Shows how to execute a basic SQL query from within the psql shell to verify query execution and database connectivity. Useful for confirming database health or testing psql functionality. Input is a SQL arithmetic select statement; output is the expected result and prompt.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n```\n=# select 1 + 1 as two;\n two\n-----\n   2\n(1 row)\n\n=#\n```\n```\n\n----------------------------------------\n\nTITLE: Example of an Empty JSONPgSmartTags Configuration (JSON5)\nDESCRIPTION: Provides a barebones JSON5 structure for the JSONPgSmartTags object as required by makeJSONPgSmartTagsPlugin or file-driven plugin imports. This example demonstrates how to set up the minimum valid configuration for the plugin, with empty objects for each supported kind ('class', 'attribute', 'constraint', 'procedure'). Intended for use as a template or starting point for smart tags definition.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_4\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {},\n    attribute: {},\n    constraint: {},\n    procedure: {},\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Deprecated @omit Tag via JSON5 - Table Mutation Actions\nDESCRIPTION: This snippet demonstrates marking a table 'table_name' in JSON5 config with an 'omit' smart tag to disable GraphQL mutations (create, update, delete) for that table in PostGraphile using the legacy @omit API (deprecated in favor of @behavior -*). This approach is useful for tailoring the exposed GraphQL API without altering underlying database schema or permissions. Input keys are operation names as a comma-separated string.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_23\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      table_name: {\n        tags: {\n          omit: \"create,update,delete\",\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sample Output for addTwoNumbers Query - JSON\nDESCRIPTION: Shows the expected JSON result when running the addTwoNumbers query with the input values a: 40 and b: 2. The result demonstrates that the execution plan correctly computes the sum. No dependencies are needed; this is output only.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/getting-started/index.mdx#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"addTwoNumbers\": 42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Code After graphile-export ESLint Autofix (TypeScript)\nDESCRIPTION: The same TypeScript snippet after applying `eslint --fix`. The `eslint-plugin-graphile-export` plugin has automatically identified the dependency `a`, added it as a parameter to the factory function, and included its value `a` in the dependency array argument to `EXPORTABLE`.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = EXPORTABLE(\n  (\n    // The dependencies:\n    a,\n  ) =>\n    function add(b) {\n      return a + b;\n    },\n  [\n    // The dependency values\n    a,\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Object Fields with Data Generators using JavaScript\nDESCRIPTION: This snippet demonstrates defining fields for a GraphQLObjectType (`MyObject`) using the `newWithHooks` helper. It utilizes the `addDataGeneratorForField` function provided within the `fields` function callback to associate data generators with specific fields ('id', 'caps', 'random'). These generators define a `map` function to transform the resolved object based on the field's alias, enabling look-ahead optimizations. The fields themselves use a placeholder `resolveAlias` resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/look-ahead.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst MyObject = newWithHooks(GraphQLObjectType, {\n  name: \"MyObject\",\n  fields: ({ addDataGeneratorForField }) => {\n    addDataGeneratorForField(\"id\", ({ alias }) => {\n      return {\n        /* highlight-start */\n        map: (obj) => ({ [alias]: obj.ID }),\n      };\n    });\n    addDataGeneratorForField(\"caps\", ({ alias }) => {\n      return {\n        /* highlight-end */\n        map: (obj) => ({ [alias]: obj.CAPS }),\n      };\n    });\n    addDataGeneratorForField(\"random\", ({ alias }) => {\n      return {\n        map: () => ({ [alias]: Math.floor(Math.random() * 10000) }),\n      };\n    });\n    return {\n      id: {\n        type: new GraphQLNonNull(GraphQLString),\n        /* highlight-start */\n        resolve: resolveAlias,\n      },\n      caps: {\n        type: new GraphQLNonNull(GraphQLString),\n        /* highlight-end */\n        resolve: resolveAlias,\n      },\n      random: {\n        type: new GraphQLNonNull(GraphQLInt),\n        resolve: resolveAlias,\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using te.compile() to Build and Inspect TE Fragments in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the usage of the `te.compile(fragment)` function. It defines a TE template literal fragment with embedded references using `te.ref()`. It then calls `te.compile()` with this fragment and uses `assert.deepEqual` to verify that the returned object contains the expected compiled string (with placeholders like `_$$_ref_1`) and a `refs` object mapping these placeholders to their original values (1 and 2). This is useful for understanding the compilation process without executing the code.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/api/te-compile.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst fragment = te`return ${te.ref(1)} + ${te.ref(2)}`;\nconst result = te.compile(fragment);\n\nassert.deepEqual(result, {\n  string: `return _$$_ref_1 + _$$_ref_2`,\n  refs: { _$$_ref_1: 1, _$$_ref_2: 2 },\n});\n```\n\n----------------------------------------\n\nTITLE: Planning Column-Based Union Handling with pgPolymorphic Â· TypeScript\nDESCRIPTION: Alternative TypeScript plan that uses 'pgPolymorphic' with a tuple of candidate IDs instead of 'pgUnionAll' for column-based union resolution. It constructs a list of foreign keys to detect which member of the union to fetch for each favourite. Helper functions like 'list' and resource definitions are prerequisites.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst personFavouriteEntityTypeMap = {\n  Person: {\n    match: (specifier) => specifier[0] != null,\n    plan: ($specifier) => personResource.get({ person_id: $specifier.at(0) }),\n  },\n  Post: {\n    match: (specifier) => specifier[1] != null,\n    plan: ($specifier) => postResource.get({ post_id: $specifier.at(1) }),\n  },\n  Comment: {\n    match: (specifier) => specifier[2] != null,\n    plan: ($specifier) => commentResource.get({ comment_id: $specifier.at(2) }),\n  },\n};\n\nconst plans = {\n  Person: {\n    favourites($person) {\n      const $favourites = personFavouritesResource.find({\n        person_id: $person.get(\"id\"),\n      });\n      return each($favourites, ($favourite) => {\n        const $specifier = list([\n          $favourite.get(\"liked_person_id\"),\n          $favourite.get(\"liked_post_id\"),\n          $favourite.get(\"liked_comment_id\"),\n        ]);\n        return pgPolymorphic(\n          $favourite,\n          $specifier,\n          personFavouriteEntityTypeMap,\n        );\n      });\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using IO Equivalence with List Steps in loadOne (TypeScript)\nDESCRIPTION: This TypeScript snippet shows loadOne usage for batch fetching organization member records, where the input is a list of tuples (organizationId, userId). The ioEquivalence array argument enables direct reference to input steps from output fields. The callback receives an array of 2-tuples, and the data fetch ensures order and direct equivalence. Dependencies include list() combinator, ioEquivalence argument, and a proper batch fetch callback.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/loadOne.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $member = loadOne(\n  list([$organizationId, $userId]),\n  [\"organization_id\", \"user_id\"],\n  batchGetMemberByOrganizationIdAndUserId,\n);\n\n// - batchGetMemberByOrganizationIdAndUserId will be called with a list of\n//   2-tuples, the first value in each tuple being the organizationId and the\n//   second the userId.\n// - Due to the io equivalence (2nd argument):\n//   - `$member.get(\"organization_id\")` will return `$organizationId` directly\n//   - `$member.get(\"user_id\")` will return `$userId` directly\n```\n\n----------------------------------------\n\nTITLE: Running GraphQL.js Tests using Mocha (Shell)\nDESCRIPTION: This shell command executes the Mocha test runner to run all TypeScript test files (`*-test.ts`) located within the `vendor/graphql-js/` directory and its subdirectories. It uses `yarn` to invoke `mocha`. This command is used to verify Grafast's compatibility with the GraphQL.js specification by running adapted tests from the `graphql-js` project. Requires `yarn` and `mocha` to be installed, along with the test files present in the specified path.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/vendor/graphql-js/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn mocha 'vendor/graphql-js/**/*-test.ts'\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Database - Bash\nDESCRIPTION: Uses the createdb CLI tool to create a new PostgreSQL database named 'mydb'. This assumes that PostgreSQL is installed and the user has the necessary permissions. No parameters aside from the database name are demonstrated; output is not shown, as it typically runs silently on success.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/quick-start-guide.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ createdb mydb\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Usage of te Tagged Template Literal\nDESCRIPTION: Illustrates an incorrect use of the `te` tagged template literal. Embedding a raw value (like the number `1`) directly into the template literal without using a `te` helper function (like `te.lit` or `te.ref`) will result in an error. This enforcement prevents accidental code injection.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nte`return 2 + ${1}`; // WILL THROW AN ERROR\n```\n\n----------------------------------------\n\nTITLE: Planning a GraphQL Selection Set (Pseudocode)\nDESCRIPTION: Describes the `PlanSelectionSet` algorithm which processes a GraphQL selection set for a given object type. It groups fields, resolves plans for each field (using custom resolvers if available), handles polymorphism for interfaces and unions, manages stream directives, and recursively calls itself for nested object types.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_26\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanSelectionSet(aether, path, parentPlan, objectType, selectionSet, isSequential):\n\n- If {isSequential} is not provided, initialize it to {false}.\n- Assert: {objectType} is an object type.\n- Let {trackedVariableValuesPlan} be {aether}.{trackedVariableValuesPlan}.\n- Let {groupedFieldSet} be the result of {GraphQLCollectFields(objectType, selectionSet, trackedVariableValuesPlan)}\n  with modified algorithm to factor `groupId`/`maxGroupId` in (based on fragments with `@defer`, `@stream`, etc).\n- For each {groupedFieldSet} as {responseKey} and {fields}:\n  - Let {pathIdentity} be `path + \">\" + objectType.name + \".\" + responseKey`.\n  - Let {field} be the first entry in {fields}.\n  - Let {fieldName} be the name of {field}. Note: This value is unaffected if an alias is used.\n  - Let {fieldType} be the return type defined for the field {fieldName} of {objectType}.\n  - If {field} provides the directive `@stream`:\n    - Assert {fieldType} is a List type.\n    - Let {oldGroupId} be {aether}.{groupId}.\n    - Increment {aether}.{maxGroupId}.\n    - Let {aether}.{groupId} be {aether}.{maxGroupId}.\n  - Let {planResolver} be `field.extensions.graphile.plan`.\n  - If {planResolver} is not {null}:\n    - Let {trackedArguments} be {TrackedArguments(aether, objectType, field)}.\n    - Let {plan} be the result of calling {planResolver}, providing {parentPlan}, {trackedArguments},\n      {aether}.{trackedContextPlan}.\n    - Call {PlanFieldArguments(aether, objectType, field, trackedArguments, plan)}.\n  - Otherwise:\n    - Let {plan} be {__ValuePlan(aether)}. (Note: this is populated in {GetValuePlanId}.)\n  - Set {plan}.{id} as the value for {pathIdentity} in {aether}.{planIdByPathIdentity}.\n  - Let {unwrappedFieldType} be the named type of {fieldType}.\n  - (Note: when implementing types, we should see the list depth of fieldType and assert that the data to be returned\n    has the same depth if we can.)\n  - If {unwrappedFieldType} is an Object, Interface or Union type:\n    - Let {subSelectionSet} be the result of calling {graphqlMergeSelectionSets(fields)}.\n    - If {unwrappedFieldType} is an object type:\n      - Call {PlanSelectionSet(aether, pathIdentity, plan, unwrappedFieldType, subSelectionSet, false)}.\n    - Otherwise, if {unwrappedFieldType} is a union type:\n      - Assert {plan} is a polymorphic plan.\n      - Let {possibleObjectTypes} be all the object types that can be accessed in {subSelectionSet} that are compatible\n        with {unwrappedFieldType}.\n      - For each {possibleObjectType} in {possibleObjectTypes}:\n        - Let {subPlan} be {GetPolymorphicObjectPlanForType(aether, plan, possibleObjectType)}.\n        - Call {PlanSelectionSet(aether, pathIdentity, subPlan, possibleObjectType, subSelectionSet, false)}.\n    - Otherwise:\n      - Assert {unwrappedFieldType} is an interface type.\n      - Assert {plan} is a polymorphic plan.\n      - If any non-introspection field in {subSelectionSet} is selected on the interface type itself, or any of the\n        interfaces it implements:\n        - Let {possibleObjectTypes} be all the object types that implement the {unwrappedFieldType} interface.\n        - For each {possibleObjectType} in {possibleObjectTypes}:\n          - Let {subPlan} be {GetPolymorphicObjectPlanForType(aether, plan, possibleObjectType)}.\n          - Call {PlanSelectionSet(aether, pathIdentity, subPlan, possibleObjectType, subSelectionSet, false)}.\n      - Otherwise:\n        - Note: this is the same approach as for union types.\n        - Let {possibleObjectTypes} be all the object types that can be accessed in {subSelectionSet} that are\n          compatible with {unwrappedFieldType}.\n        - For each {possibleObjectType} in {possibleObjectTypes}:\n          - Let {subPlan} be {GetPolymorphicObjectPlanForType(aether, plan, possibleObjectType)}.\n          - Call {PlanSelectionSet(aether, pathIdentity, subPlan, possibleObjectType, subSelectionSet, false)}.\n  - Let {aether}.{groupId} be {oldGroupId}.\n- Return.\n\n**TODO**: what happens if a interface/union field does NOT have a plan? In this case the plan is a {__ValuePlan} which\nis not a polymorphic plan so the assertions will fail.\n```\n\n----------------------------------------\n\nTITLE: Importing PostGraphile Plugins using ES Modules (Middleware)\nDESCRIPTION: This JavaScript code shows how to import the `postgraphile` library and server plugins (`@graphile/operation-hooks`, `@graphile/pg-pubsub`, `@graphile/pro`) using ES Modules (ESM) `import` syntax. This is the modern standard for JavaScript modules and is used when integrating PostGraphile as middleware in Node.js applications configured to use ESM.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/plugins.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nimport { postgraphile, makePluginHook } from \"postgraphile\";\nimport OperationHooks from \"@graphile/operation-hooks\";\nimport PgPubsub from \"@graphile/pg-pubsub\";\nimport GraphilePro from \"@graphile/pro\";\n```\n```\n\n----------------------------------------\n\nTITLE: Denoting Unary Steps in Mermaid for Grafast Plan Diagrams\nDESCRIPTION: This Mermaid diagram snippet shows how a 'unary step' is marked in a Grafast plan diagram. Unary steps are guaranteed to produce only one value per request. They are denoted by a 'âžŠ' symbol within the step node, which can be important for optimizations and dependent steps.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    Access17{{\"Access[16âˆˆ0] âžŠ<br />á¸2.pgSettingsá³\"}}:::plan\n\n```\n\n----------------------------------------\n\nTITLE: Resolving Last Entry with Utility Function (TypeScript)\nDESCRIPTION: Demonstrates how to use the 'last' utility function to retrieve the final entry in a provided list within a TypeScript codebase. This requires the 'last' function to be available in the scope, likely as an import from the project utilities. The function accepts a list as its parameter and returns the last element or undefined if the list is empty. Intended for cases where only the final result of a computation or data query is relevant.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/last.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $lastItem = last($list);\n```\n\n----------------------------------------\n\nTITLE: Defining a Value Plan - Pseudocode\nDESCRIPTION: This pseudocode defines how to create a special value plan intended for use within the plan population and resolution algorithms. This kind of plan throws an error if executed directly, as its primary usage is internal management of resolved values, not for user interaction. The ValuePlan structure is initialized and returned for further use.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_21\n\nLANGUAGE: pseudocode\nCODE:\n```\n__ValuePlan(aether):\n\n- Let {plan} be {NewPlan(aether)}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that throws an internal\n  consistency error.\n- Return {plan}.\n```\n\n----------------------------------------\n\nTITLE: Updating Module Paths and Function Signatures for @dataplan/pg (TypeScript)\nDESCRIPTION: Details breaking changes in version 5.0.0-0.14 affecting the `@dataplan/pg` package. The node-postgres adaptor path changed due to npm package naming, the `makePgConfigs` function was renamed to `makePgConfig`, moved to be exported by adaptors, and its signature updated to accept a single object parameter, requiring adjustments in import statements and function calls.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// v5.0.0-0.14: Module path change\n// Old path: @dataplan/pg/adaptors/node-postgres\n// New path: @dataplan/pg/adaptors/pg\n\n// v5.0.0-0.14: Function rename, export location, and signature change\n// Old export: makePgConfigs from '@dataplan/pg'\n// New export: makePgConfig from '@dataplan/pg/adaptors/pg' (or other adaptor)\n\n// Old signature: makePgConfigs(connectionString, schemas, superuserConnectionString)\n// New signature: makePgConfig({connectionString, schemas, superuserConnectionString})\n```\n\n----------------------------------------\n\nTITLE: Defining __TrackedObjectPlan for Runtime Value Tracking (Pseudocode)\nDESCRIPTION: Defines the `__TrackedObjectPlan` function which creates a plan representing an object whose values are provided at runtime via a `__ValuePlan`. It uses original values (passed during Aether creation) to narrow scope via `eval*` methods. The plan allows accessing nested properties (`get`), evaluating the object (`eval`), checking equality (`evalIs`), property existence (`evalHas`), array elements (`at`), and array length (`evalLength`). It tracks the access path and associated constraints.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_11\n\nLANGUAGE: pseudocode\nCODE:\n```\n__TrackedObjectPlan(aether, valuePlan, value, constraints, path):\n\n- If {path} is not provided, initialize it to an empty list.\n- Let {plan} be {NewPlan(aether)}.\n- Add {valuePlan} to {plan}'s {dependencies}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that returns the value\n  from {valuePlan}.\n- Augment {plan} such that:\n  - Calls to `plan.get(attr)`:\n    - Let {newPath} be a copy of {path} with {attr} appended.\n    - Let {subValue} be `value[attr]`.\n    - Let {subValuePlan} be {valuePlan}.{get(attr)}.\n    - Return {__TrackedObjectPlan(aether, subValuePlan, subValue, constraints, newPath)}.\n  - Calls to `plan.eval()`:\n    - Add `{type: 'value', path: path, value: value}` to {constraints}.\n    - Return {value}.\n  - Calls to `plan.evalIs(expectedValue)`:\n    - Let {pass} be `value === expectedValue`.\n    - Add `{type: 'equal', path: path, expectedValue: expectedValue, pass: pass}` to {constraints}.\n    - Return {pass}.\n  - Calls to `plan.evalHas(attr)`:\n    - Let {newPath} be a copy of {path} with {attr} appended.\n    - Let {exists} be whether the property `value[attr]` exists ({null} exists, {undefined} does not).\n    - Add `{type: 'exists', path: newPath, exists: exists}` to {constraints}.\n    - Return {exists}.\n  - TODO: split array stuff into separate thing?\n  - Calls to `plan.at(idx)`:\n    - Let {newPath} be a copy of {path} with {idx} appended.\n    - Let {subValue} be `value[idx]`.\n    - Let {subValuePlan} be {valuePlan}.{at(idx)}.\n    - Return {__TrackedObjectPlan(aether, subValuePlan, subValue, constraints, newPath)}.\n  - Calls to `plan.evalLength()`:\n    - Assert: {value} is an array.\n    - Let {length} be the length of the array {value}.\n    - Add `{type: 'length', path: path, expectedLength: length}` to {constraints}.\n    - Return {length}.\n  - (In future, maybe `plan.evalContains(childValue)` e.g. for JWT scopes?)\n- Return {plan}.\n\nNote: A {__TrackedObjectPlan()} is like {ValuePlan()} but with extra `eval` methods that allow branching the plan\nformation during planning. No other plans allow this kind of plan-time branching because planning is synchronous, and\n{__TrackedObjectPlan()} is the only type that represents these synchronous pieces of data.\n```\n\n----------------------------------------\n\nTITLE: Replacing Execute Import with Grafast Execute in JavaScript\nDESCRIPTION: Shows how to update the import of the 'execute' function from GraphQL.js to the Grafast engine. This pattern switches the source of the 'execute' function to Grafast, ensuring that existing execution code benefits from Grafast's optimizations. This snippet requires that 'grafast' be a dependency of the project and that the surrounding code is compatible with Grafast's constraints for execution. No other changes are needed beyond this import statement, making for a drop-in replacement in JavaScript projects.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/README.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-import { execute } from \"graphql\";\n+import { execute } from \"grafast\";\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for orderByAscDesc Helper Function\nDESCRIPTION: This TypeScript code defines the function signature for the `orderByAscDesc` helper. It takes a `baseName` (for the enum values), a `columnOrSqlFragment` (the expression to order by), and an optional `uniqueOrOptions` argument (boolean or `OrderByAscDescOptions` object) to specify uniqueness and null sorting behavior. It simplifies creating corresponding `_ASC` and `_DESC` enum values.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport function orderByAscDesc(\n  baseName: string,\n  columnOrSqlFragment: string | SQL,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote via SSH URL (Bash)\nDESCRIPTION: Adds a Git remote named 'heroku' pointing to the specified Heroku application's repository (`myappname`) using the SSH protocol (`git@heroku.com:...`). This method requires the user's SSH public key to be added to their Heroku account settings. Requires Git.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add heroku git@heroku.com:myappname.git\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Implicitly VOLATILE SQL Function\nDESCRIPTION: Shows the standard syntax for creating a PostgreSQL function using the `sql` language. Without an explicit volatility keyword, the function defaults to `VOLATILE`, indicating it might have side effects or modify data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\ncreate function my_function(a int, b int) returns int as $$\n  â€¦\n$$ language sql;\n```\n\n----------------------------------------\n\nTITLE: Creating a New Aether Execution Context - Pseudocode\nDESCRIPTION: This algorithm initializes a new Aether object for a given GraphQL execution, populating its fields with schema, document, operation info, planning constructs, and plan tracking lists. Depending on the detected operation type (query, mutation, subscription), it delegates to specialized planners, then performs optimization, tree shaking, and finalization. Inputs: schema, document, operation name, variable values, context, root value. Output: a fully constructed and initialized Aether object for use in planning and execution stages.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\nNewAether(schema, document, operationName, variableValues, context, rootValue):\n\n- Let {aether} be an empty object.\n- Let {aether}.{schema} be {schema}.\n- Let {aether}.{document} be {document}.\n- Let {aether}.{operationName} be {operationName}.\n- Let {aether}.{operation} be the result of {graphqlGetOperation(document, operationName)}.\n\n- Let {aether}.{maxGroupId} be {0}.\n- Let {aether}.{groupId} be {aether}.{maxGroupId}.\n- Let {aether}.{plans} be an empty list.\n- Let {aether}.{batchByPathIdentity} be an empty map.\n- Let {aether}.{planIdByPathIdentity} be an empty map.\n- Let {aether}.{valueIdByObjectByPlanId} be an empty map.\n\n- Let {variableValuesConstraints} be an empty list.\n- Let {variableValuesPlan} be {__ValuePlan(aether)}.\n- Let {aether}.{variableValuesConstraints} be {variableValuesConstraints}.\n- Let {aether}.{variableValuesPlan} be {variableValuesPlan}.\n- (TODO: this should use a more intelligent tracked object plan since the variables are strongly typed (unlike\n  context/rootValue).)\n- Let {aether}.{trackedVariableValuesPlan} be {__TrackedObjectPlan(aether, variableValuesPlan, variableValues,\n  variableValuesConstraints)}.\n\n- Let {contextConstraints} be an empty list.\n- Let {contextPlan} be {__ValuePlan(aether)}.\n- Let {aether}.{contextConstraints} be {contextConstraints}.\n- Let {aether}.{contextPlan} be {contextPlan}.\n- Let {aether}.{trackedContextPlan} be {__TrackedObjectPlan(aether, contextPlan, context, contextConstraints)}.\n\n- Let {rootValueConstraints} be an empty list.\n- Let {rootValuePlan} be {__ValuePlan(aether)}.\n- Let {aether}.{rootValueConstraints} be {rootValueConstraints}.\n- Let {aether}.{rootValuePlan} be {rootValuePlan}.\n- Let {aether}.{trackedRootValuePlan} be {__TrackedObjectPlan(aether, rootValuePlan, rootValue,\n  rootValueConstraints)}.\n\n* If {aether}.{operation} is a query operation:\n  - Let {aether}.{operationType} be {\"query\"}.\n  - Call {PlanAetherQuery(aether)}.\n* Otherwise, if {aether}.{operation} is a mutation operation:\n  - Let {aether}.{operationType} be {\"mutation\"}.\n  - Call {PlanAetherMutation(aether)}.\n* Otherwise, if {aether}.{operation} is a subscription operation:\n  - Let {aether}.{operationType} be {\"subscription\"}.\n  - Call {PlanAetherSubscription(aether)}.\n* Otherwise:\n  - Raise unknown operation type error.\n* Call {OptimizePlans(aether)}.\n* Call {TreeShakePlans(aether)}.\n* Call {FinalizePlans(aether)}.\n* Return {aether}.\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Unnamed Arguments (SQL)\nDESCRIPTION: Demonstrates creating a PostgreSQL function `add` using unnamed (positional) arguments, specified only by their types (`int, int`). Inside the function body, these arguments must be referenced using positional parameters like `$1`, `$2`. While valid SQL, this practice is discouraged when using PostGraphile, as PostGraphile will auto-generate argument names like `arg1`, `arg2` for the GraphQL schema, which is less descriptive than using explicit names. The function calculates the sum and is `immutable` and `strict`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/functions.md#_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\ncreate function add(int, int) returns int as $$\n  select $1 + $2;\n$$ language sql immutable strict;\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server with Yarn\nDESCRIPTION: Executes the `start` script defined in `package.json` using Yarn. This typically starts the Docusaurus local development server, opens a browser window, and enables live reloading for easy development and testing of website changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Conceptual API for Partitioning Lists in Crystal (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates the desired high-level API for partitioning a list plan (`$select`) into a nested structure. It uses a hypothetical `partitionByIndex` function, taking the list plan and a callback that extracts a key (`array_idx`) from each row plan (`$row`) to determine the grouping. This API exemplifies the kind of transformation enabled by the underlying `listTransform` mechanism.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/pages/plans/listTransform.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nreturn partitionByIndex($select, ($row) => $row.select(sql`array_idx`));\n```\n\n----------------------------------------\n\nTITLE: Visualizing Side-Effect Steps in Mermaid for Grafast\nDESCRIPTION: This Mermaid diagram snippet displays a side-effect step, such as one causing a database mutation. These steps have a significant impact on the plan and are visually distinguished by a slightly reddish background.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/plan-diagrams.mdx#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {'themeVariables': { 'fontSize': '16px'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n    classDef bucket0 stroke:#696969\n    classDef bucket2 stroke:#7f007f\n    SideEffect18[[\"SideEffect[18âˆˆ3]\"]]:::sideeffectplan\n\n```\n\n----------------------------------------\n\nTITLE: Importing tamedevil Tagged Template Literal in CommonJS\nDESCRIPTION: Imports the `te` tagged template literal function from the 'tamedevil' library using CommonJS `require` syntax. This is typically used in Node.js environments that do not use ES Modules.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst { te } = require(\"tamedevil\");\n```\n\n----------------------------------------\n\nTITLE: Building Input Object Plans - Pseudocode\nDESCRIPTION: This snippet outlines how to construct a plan for a GraphQL input object, recursing into field plans and supporting both static and variable values. Field plans are generated for each input field based on the type and value, and dependencies are collected. The plan object exposes means to get field-level plans and can evaluate the overall object or null. It requires field definitions and input values as prerequisites.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_18\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputObjectPlan(aether, inputObjectType, inputValues):\n\n- Let {plan} be {NewPlan(aether)}.\n- Let {inputFieldDefinitions} be the input fields defined by {inputObjectType}.\n- Let {inputFieldPlans} be an empty map.\n- For each {inputFieldDefinition} in {inputFieldDefinitions}:\n  - Let {inputFieldName} be the name of {inputFieldDefinition}.\n  - Let {inputFieldType} be the expected type of {inputFieldDefinition}.\n  - Let {defaultValue} be an AST representation of the default value for {inputFieldDefinition}.\n  - Let {inputFieldValue} be the value in {inputValues} for key {inputFieldName}.\n  - Let {inputFieldPlan} be {InputPlan(aether, inputFieldType, inputFieldValue, defaultValue)}.\n  - Set {inputFieldPlan} as the value for key {inputFieldName} in {inputFieldPlans}.\n  - Add {inputFieldPlan} to {plan}.{dependencies}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that:\n  - Let {results} be an empty list.\n  - For each input crystal object {crystalObject}:\n    - If {inputValues} is the {null} literal:\n      - Add {null} to {results}.\n    - Otherwise:\n      - Let {values} be an empty map.\n      - For each key {inputFieldName} and value {inputFieldPlan} in {inputFieldPlans}:\n        - Let {value} be the value associated with {inputFieldPlan} within {crystalObject}.\n        - Set {value} as the value for key {inputFieldName} in {values}.\n      - Add {values} to {results}.\n  - Return {results}.\n- Augment {plan} such that:\n  - Calls to `plan.get(inputFieldName)`:\n    - Let {inputFieldPlan} be the value for key {inputFieldName} in {inputFieldPlans}.\n    - Return {inputFieldPlan}.\n  - Calls to `plan.eval()`:\n    - If {inputValues} is the {null} literal:\n      - Return {null}.\n    - Let {values} be an empty map.\n    - For each key {inputFieldName} and value {inputFieldPlan} in {inputFieldPlans}:\n      - Let {value} be `inputFieldPlan.eval()`.\n      - Set {value} as the value for key {inputFieldName} in {values}.\n    - Return {values}.\n- Return {plan}.\n```\n\n----------------------------------------\n\nTITLE: Defining Custom OrderBy Plugin for Average Value (V4, Graphile) - TypeScript\nDESCRIPTION: This code defines a V4-compatible example of a Graphile OrderBy plugin, adding a custom 'average pet id' ordering to a 'users' table. It demonstrates use of SQL fragments for subselects and custom null-sorting, and illustrates passing a callback to generate the ordering fragment dynamically. Requires Graphile utilities, the makeAddPgTableOrderByPlugin and orderByAscDesc helpers, and access to a build object exposing pgSql. Inputs are table and schema names, a generator function, and any null ordering preferences.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst OrderByAveragePetIdPlugin = makeAddPgTableOrderByPlugin(\n  \"graphile_utils\",\n  \"users\",\n  (build) => {\n    const { pgSql: sql } = build;\n    const sqlIdentifier = sql.identifier(Symbol(\"pet\"));\n\n    const customOrderBy = orderByAscDesc(\n      \"PET_ID_AVERAGE\", // this is a ridiculous and unrealistic column but it will serve for testing purposes\n      (helpers) => {\n        const { queryBuilder } = helpers;\n\n        const orderByFrag = sql.fragment`(\n          select avg(${sqlIdentifier}.id)\n          from graphile_utils.pets as ${sqlIdentifier}\n          where ${sqlIdentifier}.user_id = ${queryBuilder.getTableAlias()}.id\n        )`;\n\n        return orderByFrag;\n      },\n      { nulls: \"last-iff-ascending\" },\n    );\n\n    return customOrderBy;\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for makeJSONPgSmartTagsPlugin\nDESCRIPTION: This TypeScript code defines the function signature for `makeJSONPgSmartTagsPlugin`. It accepts a configuration object (`JSONPgSmartTags`) or a thunk returning one, an optional callback for watch mode updates, and optional plugin details. It returns a `GraphileConfig.Plugin`. The associated types `JSONPgSmartTags` and `SubscribeToJSONPgSmartTagsUpdatesCallback` define the structure of the configuration and the update subscription mechanism.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-pg-smart-tags-plugin.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nfunction makeJSONPgSmartTagsPlugin(\n  jsonOrThunk: ThunkOrDirect<PromiseOrDirect<JSONPgSmartTags | null>>,\n  subscribeToJSONUpdatesCallback?: SubscribeToJSONPgSmartTagsUpdatesCallback | null,\n  details?: { name?: string; description?: string; version?: string },\n): GraphileConfig.Plugin;\n\ntype JSONPgSmartTags = {\n  version: 1;\n  config: {\n    [kind in PgSmartTagSupportedKinds]?: {\n      [identifier: string]: {\n        tags?: PgSmartTagTags;\n        description?: string;\n        attribute?: {\n          [attributeName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n        constraint?: {\n          [constraintName: string]: {\n            tags?: PgSmartTagTags;\n            description?: string;\n          };\n        };\n      };\n    };\n  };\n};\n\ntype SubscribeToJSONPgSmartTagsUpdatesCallback = (\n  cb: UpdateJSONPgSmartTagsCallback | null,\n) => void | Promise<void>;\n```\n\n----------------------------------------\n\nTITLE: Defining InputPlan for Handling Various Input Types (Pseudocode)\nDESCRIPTION: Describes the `InputPlan` function, which acts as a dispatcher for creating the appropriate input plan based on the input type and value. It handles GraphQL Variables by deferring to `InputVariablePlan`, applies default values if the input value is missing (and not a variable), and delegates to specific plan constructors (`InputNonNullPlan`, `InputListPlan`, `InputStaticLeafPlan`, `InputObjectPlan`) based on the input type (non-null, list, leaf, input object).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_12\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputPlan(aether, inputType, inputValue, defaultValue):\n\n- If {inputValue} is a {Variable}:\n  - Let {variableName} be the name of {inputValue}.\n  - Let {variableType} be the expected input type for variable {variableName} in {aether}.{operation}.\n  - Return {InputVariablePlan(aether, variableName, variableType, inputType, defaultValue)}.\n- (Note: past here, we know whether {defaultValue} will be used or not because we know {inputValue} is not a variable.)\n- If {inputValue} does not exist:\n  - Let {inputValue} be an AST representation of {defaultValue}.\n- If {inputType} is a non-null type:\n  - Let {innerType} be the inner type of {inputType}.\n  - Let {valuePlan} be {InputPlan(aether, innerType, inputValue)}.\n  - Return {InputNonNullPlan(aether, valuePlan)}.\n- Otherwise, if {inputType} is a List type:\n  - Let {innerType} be the inner type of {inputType}.\n  - Return {InputListPlan(aether, innerType, inputValue)}.\n- Otherwise, if {inputType} is a leaf type:\n  - Return {InputStaticLeafPlan(aether, inputType, inputValue)}\n- Otherwise, if {inputType} is an input object type:\n  - Return {InputObjectPlan(aether, inputType, inputValue)}.\n- Otherwise:\n  - Raise an unsupported input type error.\n```\n\n----------------------------------------\n\nTITLE: Planning GraphQL Input Object Fields (Pseudocode)\nDESCRIPTION: Outlines the `PlanInputFields` algorithm. It iterates through the fields defined in an input object type. For each field that exists in the tracked input value (`trackedValuePlan`), it retrieves the field's value and calls `PlanInputField` to process it.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_31\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanInputFields(aether, inputObjectType, trackedValuePlan, parentPlan):\n\n- For each input field {inputField} in {inputObjectType}:\n  - Let {fieldName} be the name of {inputField}.\n  - If {trackedValuePlan} {evalHas} {fieldName}:\n    - Let {trackedFieldValue} be {trackedValuePlan}.{get(fieldName)}.\n    - Call {PlanInputField(aether, inputField, trackedFieldValue, parentPlan)}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Matching Individual Constraint - Pseudocode\nDESCRIPTION: This function describes how to check if a specific constraint is satisfied by a value, with two basic types: 'value' (strict equality) and 'equal' (conditional, with a pass/fail flag). It is extensible to other constraint types as required. Inputs: a constraint object and its associated value. Outputs true/false depending on constraint logic. Note: Actual navigation within complex values (by path) is marked as TODO, so current logic only supports shallow values.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\nMatchesConstraint(constraint, value):\n\n- TODO: update this to match new constraints logic (constraint contains a path to navigate through the value).\n\n- If {constraint}.{type} is {'value'}:\n  - Return {true} if {value} is equal to {constraint}.{value}, otherwise {false}.\n- If {constraint}.{type} is {'equal'}:\n  - Return {constraint}.{pass} if {value} is {constraint}.{value}, otherwise not {constraint}.{pass}.\n- Raise unknown constraint error.\n```\n\n----------------------------------------\n\nTITLE: Defining the execute Method Signature for a Grafast Step Class in TypeScript\nDESCRIPTION: Shows the required TypeScript signature for the `execute` method in a Grafast `Step` subclass. This method receives `ExecutionDetails` and must return a `GrafastResultsList` containing the results for each item in the execution batch, potentially asynchronously.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexecute(details: ExecutionDetails): PromiseOrDirect<GrafastResultsList>\n```\n\n----------------------------------------\n\nTITLE: Enabling Autofix for Foreign Key Uniqueness in graphile-build-pg (JSON)\nDESCRIPTION: Configuration object snippet enabling the `pgFakeConstraintsAutofixForeignKeyUniqueness` option within the `gather` settings. When set to `true`, this option automatically creates unique constraints for foreign keys tagged with `@foreignKey`, aiding in migration from previous versions (V4).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n`{ gather: { pgFakeConstraintsAutofixForeignKeyUniqueness: true } }`\n```\n\n----------------------------------------\n\nTITLE: Explaining Scope Fragment Matching Algorithm (Pseudocode)\nDESCRIPTION: This pseudocode defines the `ScopeMatches(fragment, filter)` algorithm, which determines if a given behavior scope fragment matches a filter string. Both the fragment and filter are colon-separated strings. The algorithm compares corresponding phrases, handling wildcards (`*`) and negation (fragments starting with `-`). It returns true if the fragment matches the filter criteria, and false otherwise.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\nScopeMatches(fragment, filter):\n\n- Let `filterPhrases` be `filter` split on `:`.\n- Let `fragmentPhrases` be the scope of `fragment` split on `:`.\n- If `fragmentPhrases` has more parts than `filterPhrases`, return false.\n- Let `positive` be false if `fragment` starts with `-`, otherwise true.\n- Make `fragmentPhrases` have the same length as `filterPhrases` by prepending\n  the requisite number of `*` phrases to it.\n- For each corresponding `filterPhrase` and `fragmentPhrase` in `filterPhrases`\n  and `fragmentPhrases`:\n  - If `filterPhrase` is `*`, `fragmentPhrase` is not `*`, and `positive` is\n    false; return false.\n  - If neither `filterPhrase` nor `fragmentPhrase` is `*` and they are not\n    equal, return false.\n- Return true.\n```\n\n----------------------------------------\n\nTITLE: Establishing Aether Context - Pseudocode\nDESCRIPTION: This algorithm establishes or retrieves an 'Aether' (execution context) from a global cache for a GraphQL operation based on the schema, document, operation name, variables, context, and root value. If a compatible Aether exists, it reuses it; otherwise, it creates and stores a new one. Dependencies include a global cache variable, and helper functions for compatibility checking and Aether creation. Inputs: schema, document, operation name, variable values, context, root value. Output: matching or newly created Aether object. Assumes supporting cache and plan generation infrastructure.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nEstablishAether(schema, document, operationName, variableValues, context, rootValue):\n\n- Let {possibleAethers} be all the Aethers in _globalCache_.\n- For each {possibleAether} in {possibleAethers}:\n  - If {IsAetherCompatible(possibleAether, schema, document, operationName, variableValues, context, rootValue)}:\n    - Return {possibleAether}.\n- Let {aether} be the result of calling {NewAether(schema, document, operationName, variableValues, context,\n  rootValue)}.\n- Store {aether} into _globalCache_ (temporarily).\n- Return {aether}.\n```\n\n----------------------------------------\n\nTITLE: Populating Value Plan Data (Pseudocode)\nDESCRIPTION: Stores the actual object/value associated with a specific ID within a given value plan in the Crystal context. This links the abstract plan execution with concrete data.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_39\n\nLANGUAGE: pseudocode\nCODE:\n```\nPopulateValuePlan(crystalContext, valuePlan, valueId, object):\n\n- Set {object} as the value for entry {valueId} for entry {valuePlan} in {crystalContext}.{resultByIdByPlan}.\n```\n\n----------------------------------------\n\nTITLE: Installing jest-serializer-simple using Yarn\nDESCRIPTION: This command installs the `jest-serializer-simple` package, specifically the beta version, using the Yarn package manager. This is the first step required to use the serializer in a project.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-simple/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add jest-serializer-simple@beta\n```\n\n----------------------------------------\n\nTITLE: Removing InputPlan from Field Arguments (TypeScript)\nDESCRIPTION: Field arguments no longer support `inputPlan`. Use the `bakedInput()` function if similar plan-time input processing is required.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninputPlan // Removed from field arguments\n```\n\nLANGUAGE: typescript\nCODE:\n```\nbakedInput() // Alternative for processing inputs\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Forgot Password Mutation\nDESCRIPTION: Shows the expected JSON data structure returned by the GraphQL server after successfully executing the 'forgotPassword' mutation. The response object contains the 'forgotPassword' key, which maps to another object containing the 'success' field with a boolean value (true in this example), confirming the operation's completion.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/custom-mutations.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forgotPassword\": {\n    \"success\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Behavior System Error Handling and Scope Adjustments (Plaintext)\nDESCRIPTION: Describes changes in error handling and scope naming within the behavior system in version 5.0.0-0.14. A more helpful error message is provided when the `-insert` behavior prevents functions with input arguments. Additionally, using the 'create' scope now throws an error, enforcing the use of 'insert', 'update', or 'delete' scopes.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_21\n\nLANGUAGE: plaintext\nCODE:\n```\n# v5.0.0-0.14: Behavior system adjustments\n\n# More helpful error when '-insert' behavior conflicts with function arguments.\n\n# Error thrown if 'create' scope is used:\n# - Disallowed: \"create\"\n# - Use instead: \"insert\", \"update\", \"delete\"\n```\n\n----------------------------------------\n\nTITLE: Updating hasSideEffects Declaration in Grafast Step Classes (TypeScript)\nDESCRIPTION: Illustrates the required change for Grafast step classes that indicate side effects, as per version 0.1.1-beta.12 (commit 1908e1ba1). Previously declared as a public field (`hasSideEffects = true`), this property must now be assigned within the constructor using `this.hasSideEffects = true`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nthis.hasSideEffects = true\n```\n\n----------------------------------------\n\nTITLE: Importing tamedevil (te) using ESM in JavaScript\nDESCRIPTION: Imports the 'te' tagged template literal function from the 'tamedevil' library using the ES Module 'import' syntax. This is the standard approach for modern JavaScript environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/tamedevil/importing.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { te } from \"tamedevil\";\n```\n\n----------------------------------------\n\nTITLE: TypeScript Types for Null Sorting Options in orderByAscDesc\nDESCRIPTION: This TypeScript code defines the `NullsSortMethod` union type, specifying possible strategies for sorting null values ('first', 'last', 'first-iff-ascending', 'last-iff-ascending', or `undefined` for default). It also defines the `OrderByAscDescOptions` interface, which includes optional `unique` (boolean) and `nulls` (`NullsSortMethod`) properties for configuring the `orderByAscDesc` helper.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-add-pg-table-order-by-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport type NullsSortMethod =\n  | \"first\"\n  | \"last\"\n  | \"first-iff-ascending\"\n  | \"last-iff-ascending\"\n  | undefined;\n\nexport interface OrderByAscDescOptions {\n  unique?: boolean;\n  nulls?: NullsSortMethod;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting Plugin with ES6 Module Syntax (JavaScript)\nDESCRIPTION: Shows how to export a plugin created with `makeWrapResolversPlugin` using ES6 `import` and `export default` syntax, as an alternative to the CommonJS `require`/`module.exports` shown in other examples.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeWrapResolversPlugin } from 'graphile-utils';\n\nexport default makeWrapResolversPlugin(\n...\n);\n```\n\n----------------------------------------\n\nTITLE: Applying Execute Method Migration with Diff (TypeScript and Diff)\nDESCRIPTION: This snippet shows the minimal, mechanical code changes required to transition an execute method from the legacy API to the new one. It demonstrates destructuring the count and newValues from an ExecutionDetails parameter and remapping the input values for compatibility. No external dependencies are required beyond the updated API types. Inputs are ExecutionDetails objects, and the output is a values array compatible with legacy code. The approach is straightforward but may be less efficient due to array allocations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/errors/ev2.mdx#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- async execute(count: number, values: any[][], extra: ExecutionExtra) {\\n+ async execute({ count, values: newValues, extra }: ExecutionDetails) {\\n+   const values = newValues.map((dep) =>\\n+     dep.isBatch ? dep.entries : new Array(count).fill(dep.value)\\n+   );\n```\n\n----------------------------------------\n\nTITLE: Resulting GraphQL Type After Export with db Imported (JavaScript)\nDESCRIPTION: Shows what the exported code might look like after Graphile Export handles importable values like db. Imports are created as specified by prior $$export, and the resolver code can now directly reference the imported db instance. Preserves compatibility with standard ESM-style imports. Inputs/outputs as with a typical compiled/exported file.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { GraphQLObjectType } from \"graphql\";\n// highlight-next-line\nimport { db } from \"./runtime/db\";\n\n/* ... */\n\nconst User = new GraphQLObjectType({\n  name: \"User\",\n  /* ... */\n  fields: {\n    friends: {\n      /* ... */\n      async resolve(user, args, context, resolveInfo) {\n        // highlight-next-line\n        return await db.friends.loadMany(user.id, context);\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote (Bash)\nDESCRIPTION: Associates a Heroku application with the local Git repository by adding a remote named 'heroku'. Replace `heroku_app_name` with the actual name of your Heroku application. This allows pushing code directly to Heroku for deployment. Requires the Heroku CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nheroku git:remote -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: GraphQL Resolver Execution Phase Overview (Conceptual)\nDESCRIPTION: Provides a conceptual overview of the steps taken within a GraphQL resolver when encountering a field associated with a Graphile Crystal plan. It involves establishing the execution context (`aether`), identifying the field's path and corresponding plan, executing the plan (potentially batching with parallel counterparts), handling errors, and passing the result (potentially wrapped) to the underlying resolver.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_33\n\nLANGUAGE: pseudocode\nCODE:\n```\n# Step 2: execution phase\n\nWe're in a GraphQL resolver. We don't know what's going on, but we've been given a parent object (which may or may not\nbe crystal-related), arguments (which will be identical for all of our counterparts), context (which will be identical\nfor all of our counterparts) and details of the GraphQL schema, the document and operationName being executed, the\nvariables provided, the rootValue provided, and our position within the operation.\n\nThe first thing we need to do is figure out our aether, {aether}, via {EstablishAether()}.\n\nNext we figure out our path identity, {pathIdentity}, within the operation.\n\nNext we find the plan for ourself, {plan}, by looking for the {plan}.{id} stored in the {pathIdentity} entry in\n{aether}.{planIdByPathIdentity}.\n\nIf there's no plan, we just call through to the underlying resolver and we're done. Otherwise...\n\nIf we're a \"plan root\" (that is to say, our parent field doesn't have a plan) then... Nothing special happens? Just\ncontinue as normal.\n\nWe must execute the plan passing the relevant information. Note that, if we have any, our counterparts will be doing\nthis too, in parallel, and the plan should batch all these calls together into a `Batch` so that only one request needs\nto be made to the underlying data store.\n\nIf executing the plan results in an error, throw the error. Otherwise we should wrap the result up into a object\n(keeping track of all the previous values too (see the parent object), perhaps using their plan id?) which we then pass\nthrough to the underlying resolver.\n```\n\n----------------------------------------\n\nTITLE: Defining Static Input Leaf Plans - Pseudocode\nDESCRIPTION: This pseudocode describes how to create a plan that always returns the same coerced value for static input, typical for scalar or enum GraphQL inputs. The plan object holds execution and evaluation logic, and always produces the same value. There are no external dependencies, and this is used for static (non-variable) leaf input values. It returns a plan object with overridden evaluation.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_17\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputStaticLeafPlan(aether, inputType, value):\n\n- Let {plan} be {NewPlan(aether)}.\n- Let {coercedValue} be the result of coercing {value} according to the input coercion rules of {inputType}.\n- Let the internal function provided by {plan} for executing the plan, {execute}, be a function that returns\n  {coercedValue} for each input crystal object.\n- Augment {plan} such that:\n  - Calls to `plan.eval()`:\n    - Return {coercedValue}.\n- Return {plan}.\n```\n\n----------------------------------------\n\nTITLE: Installing tamedevil Library via NPM\nDESCRIPTION: Installs the beta version of the 'tamedevil' package using the Node Package Manager (NPM). This command adds the library as a project dependency and saves it to the `package.json` file.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save tamedevil@beta\n```\n\n----------------------------------------\n\nTITLE: Defining V4 makeAddPgTableOrderByPlugin and Related Types in TypeScript\nDESCRIPTION: Presents the simplified V4 TypeScript signatures for the `makeAddPgTableOrderByPlugin` function, the `MakeAddPgTableOrderByPluginOrders` interface, `OrderSpec` and `OrderBySpecIdentity` types, and the `orderByAscDesc` helper function. These define how custom table ordering plugins were created in V4, relying on a build object and specific spec structures involving SQL fragments or column names.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-add-pg-table-order-by-plugin.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// V4 signature\nfunction makeAddPgTableOrderByPlugin(\n  schemaName: string,\n  tableName: string,\n  ordersGenerator: (build: Build) => MakeAddPgTableOrderByPluginOrders,\n  hint?: string,\n): Plugin;\n\nexport interface MakeAddPgTableOrderByPluginOrders {\n  [orderByEnumValue: string]: {\n    value: {\n      alias?: string;\n      specs: Array<OrderSpec>;\n      unique: boolean;\n    };\n  };\n}\n\ntype OrderSpec =\n  | [OrderBySpecIdentity, boolean]\n  | [OrderBySpecIdentity, boolean, boolean];\n\ntype OrderBySpecIdentity =\n  | string\n  | SQL\n  | ((options: { queryBuilder: QueryBuilder }) => SQL);\n\nexport function orderByAscDesc(\n  baseName: string,\n  columnOrSqlFragment: OrderBySpecIdentity,\n  uniqueOrOptions: boolean | OrderByAscDescOptions = false,\n): MakeAddPgTableOrderByPluginOrders;\n```\n\n----------------------------------------\n\nTITLE: Deploying Application to Heroku via Git Push (Bash)\nDESCRIPTION: Pushes the local 'master' branch to the 'heroku' remote repository, triggering a build and deployment process on Heroku. Requires Git and a previously configured Heroku remote.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit push heroku master\n```\n\n----------------------------------------\n\nTITLE: Migrating from $step.eval*() Methods in Grafast\nDESCRIPTION: Addresses the deprecation and planned removal of internal `$step.eval*()` methods in Grafast. Users are advised to migrate away from these methods. A new `.apply()` pattern available on various step classes is suggested as an alternative approach for specifying runtime modifications or adjustments to step execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/news/2025-03-24-grafast-0.1-beta.21.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n$step.eval*()\n```\n\nLANGUAGE: javascript\nCODE:\n```\n.apply()\n```\n\n----------------------------------------\n\nTITLE: Generated Basic GraphQL Schema with Node Interface (GraphQL)\nDESCRIPTION: Shows the structure of the basic GraphQL schema generated by the previous JavaScript example using `graphile-build`'s default plugins. It includes the Relay-compliant `Node` interface with a global `id` field and a root `Query` type also implementing `Node`, providing access points like `query` and `node(id:)` for fetching objects by their global ID.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/versioned_docs/version-4/getting-started.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  id: ID!\n\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    id: ID!\n  ): Node\n}\n```\n\n----------------------------------------\n\nTITLE: Running Grafast with DataLoader-based Schema Benchmark - JavaScript\nDESCRIPTION: Benchmarks Grafast by executing a query against the DataLoader-based schema 10,000 times. Requires the same setup as the DataLoader benchmark but uses Grafast for execution. Outputs the time taken upon completion, measuring resolver performance with Grafast.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/examples/users-and-friends/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnode index.mjs grafast-resolvers\n```\n\n----------------------------------------\n\nTITLE: Importing tamedevil Tagged Template Literal in ESM\nDESCRIPTION: Imports the `te` tagged template literal function from the 'tamedevil' library using ES Module syntax. This is the primary function used to construct safe dynamic code.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { te } from \"tamedevil\";\n```\n\n----------------------------------------\n\nTITLE: Defining Smart Comments Format for PostGraphile - SQL\nDESCRIPTION: This snippet demonstrates the expected format and content of smart comments for PostGraphile. It shows how multiple tags with and without payload, separated by newlines, are included in a comment block. The snippet is intended to be a source example, not to be executed directly, and underpins subsequent comment usage in SQL. Inputs are freeform comments; outputs are the parsed tags object and remaining description. There are no specific dependencies for using this comment pattern, but adoption assumes PostGraphile parses such comments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n@name meta\\n@isImportant\\n@jsonField date timestamp\\n@jsonField name text\\n@jsonField episode enum ONE=1 TWO=2\\nThis field has a load of arbitrary tags.\n```\n\n----------------------------------------\n\nTITLE: Adding Docker Repository on Linux (Shell)\nDESCRIPTION: Updates the apt package index, installs necessary packages (apt-transport-https, ca-certificates, curl, software-properties-common) for using HTTPS repositories, adds Docker's official GPG key, and sets up the stable Docker repository on a Debian-based Linux distribution like Ubuntu. These commands prepare the system for installing Docker CE.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt-get update\n$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n----------------------------------------\n\nTITLE: Setting up PostgreSQL Database Schema for HTML Sanitization Test in SQL\nDESCRIPTION: This SQL script prepares a PostgreSQL database named 'sanitise-html' for testing the `SanitizeHTMLTypePlugin`. It defines a custom domain 'html' based on the 'text' type, creates a table 'a' with columns including one of type 'html', and inserts an initial row of data into the table.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugin-gallery/customisation.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\n  # Create a database to test against\n  createdb sanitise-html\n  # Seed the database with our domain, table and some data\n  psql -1X sanitise-html <<SQL\n    CREATE DOMAIN html AS text;\n    CREATE TABLE a (id SERIAL PRIMARY KEY, t TEXT, h HTML);\n    INSERT INTO a (t, h) VALUES ('AaAaAa', 'BbBbBb');\n  SQL\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Prerequisites - Shell\nDESCRIPTION: These shell commands update the package index, install necessary transport and security utilities, add Docker\\'s GPG key, and register the Docker repository for Ubuntu. Required before installing Docker Community Edition (docker-ce). Inputs include the current Ubuntu codename from lsb_release. Outputs are updated repositories and added Docker sources. Requires root permissions and internet access.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt-get update\\n$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common\\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\\n$ sudo add-apt-repository \\\"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\\\"\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Sponsorship Page (JavaScript/JSX)\nDESCRIPTION: Imports React components (`Sponsor`, `Sponsors`, `SponsorButtons`, `Link`) required to render the sponsorship information and calls to action on the page. These components are sourced from the site's local components directory (`@site/src/components`) and the Docusaurus Link component.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/sponsor.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Sponsor from \"@site/src/components/Sponsor\";\nimport Sponsors from \"@site/src/components/Sponsors\";\nimport SponsorButtons from \"@site/src/components/SponsorButtons\";\nimport Link from \"@docusaurus/Link\";\n```\n\n----------------------------------------\n\nTITLE: Standard GraphQL Query Example (GraphQL)\nDESCRIPTION: A standard GraphQL query to fetch the names of all people. This serves as a baseline example before demonstrating how to convert it into a live query.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Available Endpoints After PostGraphile Start - Shell\nDESCRIPTION: Lists the endpoints served by PostGraphile after running; includes GraphQL and GraphiQL web endpoints. Useful for validation and quick reference to default local URLs. This snippet is output only, not a command.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n```\n  â€£ GraphQL endpoint served at http://localhost:5000/graphql\n  â€£ GraphiQL endpoint served at http://localhost:5000/graphiql\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring PostGraphile Simple Subscriptions - JavaScript\nDESCRIPTION: Defines the PostGraphile configuration file (.postgraphilerc.js) to enable simple subscriptions. Depends on the @graphile/pg-pubsub plugin and a PostgreSQL database connection named \"subs\". Key settings include specifying plugins, connection string, schema, and enabling simpleSubscriptions. Outputs a configuration object for consumption by PostGraphile tools.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/subscriptions.mdx#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  options: {\n    plugins: [\"@graphile/pg-pubsub\"],\n    connection: \"postgres:///subs\",\n    schema: [\"app_public\"],\n    simpleSubscriptions: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Smart Comments to a Fake Constraint Using Pipe as Delimiter - SQL\nDESCRIPTION: This snippet demonstrates the workaround of using a pipe (|) as a separator in comments for fake constraints on materialized views, since newlines would otherwise create multiple comments. The COMMENT ON MATERIALIZED VIEW statement applies two smart tags (@foreignKey and @fieldName) for the fake constraint, using the E-escape format. Prerequisites include a materialized view; limitation is that this pipe-delimited format is specific to fake constraints and not standard for others.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\ncomment on materialized view my_materialized_view is\\n  E'@foreignKey (post_id) references posts (id)|@fieldName yourNameHere';\n```\n\n----------------------------------------\n\nTITLE: Example of Smart Comment JSON Tags Object - JSON\nDESCRIPTION: This snippet provides an example of the resulting tags object after PostGraphile parses a smart comment according to the documented spec. It illustrates how multiple values for the same tag are aggregated into arrays and how boolean and string values are represented. There are no dependencies to interpret this JSON, but it is intended for consumer understanding and adoption into logic or test code.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/smart-comments.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"name\\\": \\\"meta\\\",\\n  \\\"isImportant\\\": true,\\n  \\\"jsonField\\\": [\\\"date timestamp\\\", \\\"name text\\\", \\\"episode enum ONE=1 TWO=2\\\"]\\n}\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Initial Files (Bash)\nDESCRIPTION: Stages all changes in the current directory for the next commit using `git add .` and then creates a new commit with the message \"Initial commit\" using `git commit -m`. This saves the initial project state in the Git repository.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit add . && git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server with Yarn (Shell)\nDESCRIPTION: Executes the `start` script defined in the project's `package.json` using Yarn. This command typically launches the Docusaurus local development server, which monitors file changes and automatically refreshes the browser (live reload).\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Calling registerNodeIdCodec Function in JavaScript\nDESCRIPTION: This snippet shows a reference to the `registerNodeIdCodec` function. The context indicates this function is used during schema export, and its usage was adjusted to fix issues caught by ESLint's 'no-use-before-define' check, ensuring proper definition order.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/CHANGELOG.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nregisterNodeIdCodec\n```\n\n----------------------------------------\n\nTITLE: Defining the EXPORTABLE Helper Function in TypeScript\nDESCRIPTION: Provides the TypeScript source code for the `EXPORTABLE` helper function. This function accepts a factory function, an array of dependency arguments, and an optional name hint. It executes the factory with the arguments and attaches special properties (`$exporter$factory`, `$exporter$args`, `$exporter$name`) to the resulting function or object to store the factory and dependency information needed for code export.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-export/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport function EXPORTABLE<T, TScope extends any[]>(\n  factory: (...args: TScope) => T,\n  args: [...TScope],\n  nameHint?: string,\n): T {\n  const fn: T = factory(...args);\n  if (\n    ((typeof fn === \"object\" && fn !== null) || typeof fn === \"function\") &&\n    !(\"$exporter$factory\" in fn)\n  ) {\n    Object.defineProperties(fn, {\n      $exporter$args: { value: args },\n      $exporter$factory: { value: factory },\n      $exporter$name: { writable: true, value: nameHint },\n    });\n  }\n  return fn;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in JavaScript/JSX\nDESCRIPTION: This JavaScript import statement loads CSS Modules from the specified path (`@site/src/css/common.module.css`). The `@site` alias typically resolves to the website's source directory in Docusaurus. The imported styles are assigned to the `styles` object, allowing class names to be accessed programmatically (e.g., `styles.graphileHeart`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/code-of-conduct.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Installing jest-serializer-graphql-schema using yarn\nDESCRIPTION: Installs the `jest-serializer-graphql-schema` package as a development dependency using the yarn package manager. The `@beta` tag indicates installation of a specific pre-release version.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add --dev jest-serializer-graphql-schema@beta\n```\n\n----------------------------------------\n\nTITLE: Finding 'source' Occurrences for Renaming using Regex\nDESCRIPTION: Provides a regular expression (`/:source\\b|\\bsource:[a-z$]/`) to help developers find instances of the term 'source' that need updating due to API renaming.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_3\n\nLANGUAGE: regex\nCODE:\n```\n/:source\\b|\\bsource:[a-z$]/\n```\n\n----------------------------------------\n\nTITLE: Example Output for ForumBySlug with Topics Condition Query - JSON\nDESCRIPTION: This JSON snippet is the expected result of the forumBySlug GraphQL query with a conditional filter on related topics. It contains a forum object with nodeId, id, name, and a topics array, each topic providing nodeId, id, title, and body. The JSON output reflects the response structure delivered by the Graphile/PostGraphile framework and is specifically tailored to queries filtering topics by authorId.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/collections.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"forumBySlug\": {\n    \"nodeId\": \"WyJmb3J1bXMiLDFd\",\n    \"id\": 1,\n    \"name\": \"Testimonials\",\n    \"topics\": {\n      \"nodes\": [\n        {\n          \"nodeId\": \"WyJ0b3BpY3MiLDFd\",\n          \"id\": 1,\n          \"title\": \"Thank you!\",\n          \"body\": \"500-1500 requests per second on a single server is pretty awesome.\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL intervalstyle Configuration\nDESCRIPTION: Specifies the required PostgreSQL configuration setting `intervalstyle` must be set to `'postgres'` for the Graphile Crystal project. This setting controls the format for interval output and is usually the default Postgres value.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/REQUIREMENTS.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nintervalstyle = 'postgres'\n```\n\n----------------------------------------\n\nTITLE: Renamed: 'PgAdaptorSettings' Type Name (TypeScript)\nDESCRIPTION: Introduces the new type name `PgAdaptorSettings` for PostgreSQL adaptor configuration in TypeScript, replacing the deprecated `PgAdaptorOptions` as of version 5.0.0-beta.26. Users should update their codebases accordingly.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nPgAdaptorSettings\n```\n\n----------------------------------------\n\nTITLE: Viewing Available Configuration Options with graphile CLI\nDESCRIPTION: This shell command uses the `graphile` CLI tool to display all available configuration options based on the current `graphile.config.*` file and its imported presets and plugins. This is useful during development to discover configurable parameters.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/config.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n```sh\ngraphile config options\n```\n```\n\n----------------------------------------\n\nTITLE: Creating the Pagila Database using createdb\nDESCRIPTION: This command uses the PostgreSQL `createdb` utility to create a new, empty database named 'pagila'. This database will subsequently be populated with the schema and data from the cloned Pagila repository.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/src/examples/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncreatedb pagila\n```\n\n----------------------------------------\n\nTITLE: Structuring an Empty JSONPgSmartTags Configuration with JSON5\nDESCRIPTION: Presents an example of a minimal, empty `JSONPgSmartTags` object using JSON5 syntax. This illustrates the basic required structure, including the `version` field (set to 1) and the top-level `config` object containing empty objects for supported PostgreSQL entity kinds (`class`, `attribute`, `constraint`, `procedure`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-pg-smart-tags-plugin.md#_snippet_4\n\nLANGUAGE: json5\nCODE:\n```\n```json5\n{\n  version: 1,\n  config: {\n    class: {},\n    attribute: {},\n    constraint: {},\n    procedure: {},\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via SSH using Yarn\nDESCRIPTION: Deploys the built website using Yarn, configured to use SSH for authentication via the `USE_SSH=true` environment variable. This method is often used for deploying to services like GitHub Pages when SSH key authentication is preferred or required.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Installing PostgreSQL Client on Debian/Ubuntu (Bash)\nDESCRIPTION: Updates the package list and installs the `postgresql-client` package using `apt` on Debian-based Linux distributions. This provides the `psql` command-line utility needed for interacting with the test database.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update && sudo apt install postgresql-client\n```\n\n----------------------------------------\n\nTITLE: Upgrading PostGraphile Dependencies Using Yarn (bash)\nDESCRIPTION: This bash command upgrades core PostGraphile-related devDependencies to their @beta versions suitable for V5 migration. Run this command after updating package.json. This ensures compatibility with V5 features and APIs.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add --dev \\\\n  graphile-build@beta \\\\n  graphile-build-pg@beta \\\\n  postgraphile@beta \\\\n  postgraphile-plugin-connection-filter@beta\n```\n\n----------------------------------------\n\nTITLE: Printing Resolved Configuration with Graphile CLI\nDESCRIPTION: This shell command uses the `graphile` CLI tool to compute and print the final, resolved configuration object after merging all extended presets and applying local settings. This is useful for debugging the configuration.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/config.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ngraphile config print\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with Yarn (Shell)\nDESCRIPTION: This command uses the Yarn package manager to download and install all the project dependencies listed in the `package.json` file. This is typically the first step after cloning the project repository.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Schema Field Renaming for Multi-Key Relationships - Diff\nDESCRIPTION: This diff snippet contrasts the previous verbose field naming for a reverse one-to-one or many-to-one relationship, demonstrating the switch from a concatenated multi-key field name to a more concise, readable single name. No dependencies required; represents output changes when upgrading the schema logic.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n-  goalByOrganizationIdAndTeamIdAndGoalUuid: Goal\n+  organizationTeamGoal: Goal\n```\n\n----------------------------------------\n\nTITLE: Running Docker Containers with Docker Compose Commands in Shell\nDESCRIPTION: Provides shell commands using `docker-compose up` to start and run the containers defined in the `docker-compose.yml` file. It demonstrates running all services in the foreground, running all services in the background (daemon mode) using the `-d` flag, and running specific services like `db` or `graphql` individually in daemon mode.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-as-a-library-in-docker.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n# Run containers for all services in docker-compose.yml\\n$ docker-compose up\\n\\n# Run containers as daemon (in background)\\n$ docker-compose up -d\\n\\n# Run only the database container as daemon\\n$ docker-compose up -d db\\n\\n# Run only the GraphQL container as daemon\\n$ docker-compose up -d graphql\n```\n\n----------------------------------------\n\nTITLE: Updating `getBehavior` Logic for Chain Following (Conceptual)\nDESCRIPTION: Mentions updates to the internal `getBehavior` function logic in version 5.0.0-0.14. This change ensures the function correctly follows the relevant inheritance chain (e.g., from codec to source to relation for relations) when determining the applicable behavior for a schema element.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_22\n\nLANGUAGE: plaintext\nCODE:\n```\n// v5.0.0-0.14: Conceptual change in getBehavior logic\n// Function: getBehavior\n// Updated logic: Follows the relevant chain for behavior resolution.\n// Example chain for relations: codec -> source -> relation\n```\n\n----------------------------------------\n\nTITLE: Trying PostGraphile V5 Beta with Plugins via Sample Project\nDESCRIPTION: These commands provide an alternative method to try PostGraphile V5, particularly with plugins, by using a sample project ('ouch-my-finger'). First, dependencies are installed using `yarn` within the cloned project directory. Then, `yarn postgraphile` is run (likely invoking a script defined in `package.json` or the locally installed binary) to start PostGraphile, connecting to a specified database (`-c`) and schema (`-s`). Users must replace the placeholder connection string and schema name(s). This approach requires cloning the specified repository first.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/news/2023-08-03-beta-release.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn\nyarn postgraphile -c postgres:///my_db -s public\n```\n\n----------------------------------------\n\nTITLE: Installing Docker CE on Linux (Shell)\nDESCRIPTION: Updates the apt package index again after adding the Docker repository and then installs the Docker Community Edition (docker-ce) package using the apt package manager. This step installs the Docker engine.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt-get update\n$ sudo apt-get install docker-ce\n```\n\n----------------------------------------\n\nTITLE: Finalizing All Plans in Aether - Pseudocode\nDESCRIPTION: At the end of planning, this function finds all distinct, currently-active plans in the Aether and finalizes each in reverse order (commonly for generating SQL, GraphQL queries, or other outputs). Inputs: aether with plans. Outputs: side effect â€” plans are finalized in place in the Aether. Limitations: Requires that FinalizePlan is defined elsewhere, and that plan order is meaningful.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_9\n\nLANGUAGE: pseudocode\nCODE:\n```\nFinalizePlans(aether):\n\n- Let {activePlans} be the _distinct_ active plans within {aether}.{plans}.\n- For each {activePlan} in {activePlans} in reverse order:\n  - Call {FinalizePlan(aether, activePlan)}.\n\nNote: FinalizePlans is the stage at which the SQL, GraphQL, etc query may be built; before this time it's not clear what\nthe selection will be as intermediate plans may have been discarded.\n\nThis is where the SQL generation would occur.\n```\n\n----------------------------------------\n\nTITLE: Recursively Planning GraphQL Input Values (Pseudocode)\nDESCRIPTION: Details the `PlanInput` algorithm, responsible for recursively processing input values based on their GraphQL type (Non-Null, List, Input Object). It handles null values, iterates through list items, and calls `PlanInputFields` for input objects. It expects to operate primarily on objects or lists, not scalars.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_30\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanInput(aether, inputType, trackedValuePlan, parentPlan):\n\n- If {inputType} is a non-null type:\n  - Let {innerInputType} be the inner type of {inputType}.\n  - Call {PlanInput(aether, innerInputType, trackedValuePlan, parentPlan)}.\n  - Return.\n- Otherwise, if {inputType} is a list type:\n  - If {trackedValuePlan} {evalIs} {null}:\n    - Call {parentPlan}.{null()}.\n    - Return.\n  - Let {innerInputType} be the inner type of {inputType}.\n  - Let {length} be {trackedValuePlan}.{evalLength()}.\n  - For {i} from {0...length-1}:\n    - Let {listItemParentPlan} be the result of calling {parentPlan}.{itemPlan()}.\n    - Let {trackedListValue} be {trackedValuePlan}.{at(i)}.\n    - Call {PlanInput(aether, innerInputType, trackedListValue, listItemParentPlan)}.\n  - Return.\n- Otherwise, if {inputType} is an input object type:\n  - If {trackedValuePlan} {evalIs} {null}:\n    - TODO: should we indicate to the parent that this is null as opposed to an empty object?\n    - Return.\n  - Call {PlanInputFields(aether, inputType, trackedValuePlan, parentPlan)}.\n- Otherwise, raise an invalid plan error.\n\nNote: we are only expecting to {PlanInput()} for objects or lists thereof, not scalars.\n```\n\n----------------------------------------\n\nTITLE: Installing tamedevil Library via Yarn\nDESCRIPTION: Installs the beta version of the 'tamedevil' package using the Yarn package manager. This command adds the library as a project dependency.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add tamedevil@beta\n```\n\n----------------------------------------\n\nTITLE: Calling pgl.getResolvedPreset() API (JavaScript/TypeScript)\nDESCRIPTION: This API function, accessed via the 'pgl' instance (likely representing the PostGraphile library instance or a similar context object), is used to retrieve the resolved preset configuration. It was added as part of the API enhancements in version 0.0.1-0.9.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/CHANGELOG.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\npgl.getResolvedPreset()\n```\n\n----------------------------------------\n\nTITLE: Creating a PostGraphile Schema Using postgraphile-core (Deprecated) in JavaScript\nDESCRIPTION: This snippet shows the legacy method for creating a PostGraphile schema using the now-removed 'postgraphile-core' package. It imports 'createPostGraphileSchema' and constructs a schema asynchronously from a database URL and optional settings. This approach is deprecated and superseded by the new 'graphile-build' and 'postgraphile' V5 APIs. The input requires a database connection string, the target schema name, and configuration options; output is the generated schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx#_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createPostGraphileSchema } from \"postgraphile-core\";\n\n// ...\n\nconst schema = await createPostGraphileSchema(DATABASE_URL, \"public\", {\n  // options\n});\n```\n\n----------------------------------------\n\nTITLE: Summarizing Backer Sponsors using Custom React Components\nDESCRIPTION: Uses the `<Sponsors>` React component with the `level` prop set to \"backers\". It contains a single `<Sponsor>` component configured with the `name` prop displaying summary text (\"plus 85 more backers...\") and the `plain` prop set. This indicates that it should render as simple text, serving as a concise summary for numerous smaller contributors or individual backers.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/sponsor.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Sponsors level=\"backers\">\n  <Sponsor name=\"plus 85 more backers...\" plain />\n</Sponsors>\n```\n\n----------------------------------------\n\nTITLE: Planning an Aether Mutation - Pseudocode\nDESCRIPTION: This snippet provides the routine for planning a GraphQL mutation, mirroring query planning logic but targeting the mutation root type. It ensures that the corresponding root, operation, and tracked root value are in place, and invokes selection set planning with a mutation context flag. This supports mutation execution within a custom planning engine.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_24\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanAetherMutation(aether):\n\n- Let {rootType} be the root Mutation type in {aether}.{schema}.\n- Assert {rootType} exists.\n- Let {selectionSet} be the top level Selection Set in {aether}.{operation}.\n- Let {trackedRootValuePlan} be {aether}.{trackedRootValuePlan}.\n- Call {PlanSelectionSet(aether, \"\", trackedRootValuePlan, rootType, selectionSet, true)}.\n```\n\n----------------------------------------\n\nTITLE: Deleting a Heroku Application (Bash)\nDESCRIPTION: Uses the Heroku CLI `apps:destroy` command to permanently delete the specified Heroku application (`myappname`). This action is irreversible and will remove the application and all its associated resources. Requires the Heroku CLI.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nheroku apps:destroy -a myappname\n```\n\n----------------------------------------\n\nTITLE: Displaying Unknown File Extension Error - Plaintext\nDESCRIPTION: This snippet presents a common error from Node.js when trying to load a `.ts` file as a module without proper loader configuration. It emphasizes the need for experimental loaders or compatible TypeScript-to-JavaScript transpilation when using ESM. This is expected to appear in the console output during misconfiguration.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/graphile-config/README.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nTypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension \".ts\" for /path/to/graphile.config.ts\n```\n\n----------------------------------------\n\nTITLE: Executing a Batch (Pseudocode)\nDESCRIPTION: Processes a collected batch of operations. It first removes the batch from the `aether` context to prevent further additions. Then, it extracts the parent Crystal objects and deferred result placeholders from the batch entries, executes the associated plan (`ExecutePlan`) potentially asynchronously with these objects, and finally resolves each deferred result with the corresponding output from the plan execution.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_42\n\nLANGUAGE: pseudocode\nCODE:\n```\nExecuteBatch(aether, batch, crystalContext):\n\n- Delete the value for key {batch}.{pathIdentity} within {aether}.{batchByPathIdentity} (Note: this means a new batch\n  will be used for later calls).\n- Let {crystalObjects} be the first entry in each tuple within {batch}.{entries}.\n- Let {deferredResults} be the second entry in each tuple within {batch}.{entries}.\n- Let {plan} be {batch}.{plan}.\n- Let {results} be the result of calling (asynchronously if necessary) {ExecutePlan(aether, plan, crystalContext,\n  crystalObjects)}.\n- Assert that the length of {results} matches the length of {deferredResults}.\n- For each {deferredResult} with index {i} in {deferredResults}:\n  - Let {result} be the {i}th entry in {results}.\n  - Resolve {deferredResult} with {result}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Granting Docker Group Permissions to User - Shell\nDESCRIPTION: Updates user permissions by adding the specified username to the 'docker' group using usermod. Requires 'sudo' privileges and username substitution. User must restart the machine after running this command to apply changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo usermod -a -G docker <username>\n```\n\n----------------------------------------\n\nTITLE: Accessing PostgreSQL Function Resources with Computed Property Names in JavaScript\nDESCRIPTION: Illustrates accessing a PostgreSQL function resource from `pgRegistry.pgResources` using computed property names in JavaScript. This approach was necessary when function resource names contained dashes (e.g., 'myService-mySchema-my_function_name'), which are invalid characters for standard identifiers. The surrounding text indicates this pattern is related to older naming conventions that were subsequently changed to use underscores for easier access.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst { [\"myService-mySchema-my_function_name\"]: myFunctionResource } = pgRegistry.pgResources\n```\n\n----------------------------------------\n\nTITLE: Planning a Single GraphQL Field Argument (Pseudocode)\nDESCRIPTION: Describes the `PlanFieldArgument` algorithm, which handles the planning for a single argument of a field. It looks for a custom plan resolver (`argumentSpec.extensions.graphile.plan`). If found, it calls the resolver and, if a plan is returned, recursively calls `PlanInput` to handle the argument's value based on its type.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_29\n\nLANGUAGE: pseudocode\nCODE:\n```\nPlanFieldArgument(aether, objectType, field, argument, trackedArgumentValuePlan, fieldPlan):\n\n- Let {fieldName} be the name of {field}.\n- Let {argumentName} be the name of {argument}.\n- Let {fieldSpec} be the field named {fieldName} on {objectType}.\n- Let {argumentSpec} be the argument named {argumentName} on {fieldSpec}.\n- Let {planResolver} be `argumentSpec.extensions.graphile.plan`.\n- If {planResolver} exists:\n  - Let {argumentPlan} be the result of calling {planResolver}, providing {fieldPlan}, {trackedArgumentValuePlan},\n    {aether}.{trackedContextPlan}.\n  - If {argumentPlan} is not {null}:\n    - Assert {argumentPlan} is an argument plan.\n    - Let {argumentType} be the expected type of {argument}.\n    - Call {PlanInput(aether, argumentType, trackedArgumentValuePlan, argumentPlan)}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Referencing PostgreSQL Function Definition Keywords\nDESCRIPTION: References the PostgreSQL keywords 'out' and 'returns table' used in function definitions. A bug fix related to recognizing the required-ness of arguments for functions using these constructs is mentioned.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\n`out`\n```\n\nLANGUAGE: sql\nCODE:\n```\n`returns table`\n```\n\n----------------------------------------\n\nTITLE: Optimizing All Plans in Aether - Pseudocode\nDESCRIPTION: This function iterates over all plans in the Aether's plan list in reverse and applies an optimizing transformation. Optimized plans are updated in place, though optimizations must not be applied to __ValuePlan plans. Dependencies: OptimizePlan(). Inputs: an Aether object containing the plans. Outputs: plans updated in the Aether object. Reverse order supports bottom-up optimizations.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_5\n\nLANGUAGE: pseudocode\nCODE:\n```\nOptimizePlans(aether):\n\n- For each {plan} with index {i} in {aether}.{plans} in reverse order:\n  - Let {optimizedPlan} be {OptimizePlan(aether, plan)}.\n  - Let the {i}th entry in {aether}.{plans} be {optimizedPlan}.\n- Return.\n```\n\n----------------------------------------\n\nTITLE: Configuring Collection Types on Constraint via @simpleCollections in SQL (Deprecated)\nDESCRIPTION: Applies the `@simpleCollections both` smart comment to the `email_user_id_fkey` constraint on the `email` table. This influences how PostGraphile generates collection fields related to this foreign key, enabling both simple lists and Relay connections. Note: `@simpleCollections` is deprecated in favor of `@behavior`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_28\n\nLANGUAGE: sql\nCODE:\n```\ncomment on constraint email_user_id_fkey on email is\n  E'@simpleCollections both';\n```\n\n----------------------------------------\n\nTITLE: Using --superuser-connection Option (CLI)\nDESCRIPTION: This command-line option is used with the relevant tool in the `graphile/crystal` project to enable installing watch fixtures with superuser privileges. It was introduced to provide specific permissions for certain setup tasks.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-pg/CHANGELOG.md#_snippet_2\n\nLANGUAGE: cli\nCODE:\n```\n--superuser-connection\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL User Environment Variable (Bash)\nDESCRIPTION: Exports the `PGUSER` environment variable, setting it to 'postgres'. This is required when connecting to the PostgreSQL instance, particularly the persistent Docker setup described previously.\nSOURCE: https://github.com/graphile/crystal/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport PGUSER=postgres\n```\n\n----------------------------------------\n\nTITLE: Installing JWT/JWKS and Express Dependencies - Bash\nDESCRIPTION: Demonstrates the package installation commands required to set up the Express-based Auth0 JWT/JWK authentication system. Installs express, express-jwt for JWT middleware/authentication, and jwks-rsa for fetching signing keys from a JWKS endpoint. Developers should run either the yarn or npm command to fulfill package prerequisites.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/jwk-verification.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add express express-jwt jwks-rsa\n# Or:\nnpm install --save express express-jwt jwks-rsa\n```\n\n----------------------------------------\n\nTITLE: Cloning the Pagila Sample Database Repository using Git\nDESCRIPTION: This command uses Git to clone the `pagila` sample database repository from GitHub. This repository contains the schema and data files necessary to set up the Pagila database, which can be used for testing Graphile Crystal examples.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/src/examples/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:devrimgunduz/pagila.git\n```\n\n----------------------------------------\n\nTITLE: Adding Ported V4 Utility Plugin Generators\nDESCRIPTION: Notes that `graphile-utils` now includes the `makeAddPgTableConditionPlugin` and `makeAddPgTableOrderByPlugin` generator functions, which have been ported from V4 with potentially slight signature changes.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nmakeAddPgTableConditionPlugin\nmakeAddPgTableOrderByPlugin\n```\n\n----------------------------------------\n\nTITLE: Updating makeWrapPlansPlugin Filter Signature (Conceptual)\nDESCRIPTION: Describes a breaking change in the filter functions used with `makeWrapPlansPlugin`. Filters now accept only three arguments (`context`, `build`, `field`), removing the redundant fourth `options` argument. Options can be accessed via `build.options`.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-utils/CHANGELOG.md#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nmakeWrapPlansPlugin filters now accept only three args (`context`, `build`, `field`) since the fourth argument (`options`) was redundant - get it from `build.options` instead.\n```\n\n----------------------------------------\n\nTITLE: Importing React Components in Docusaurus Markdown\nDESCRIPTION: This snippet demonstrates importing custom React components (`Grafast`, `Link`) into a Docusaurus Markdown file. `Grafast` likely renders specific styling or information related to Grafast, while `Link` is a Docusaurus component for creating navigation links.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/working-group.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Grafast from \"@site/src/components/Grafast\";\nimport Link from \"@docusaurus/Link\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Collection Types on Table via @simpleCollections in SQL (Deprecated)\nDESCRIPTION: Applies the `@simpleCollections both` smart comment to the `email` table. This instructs PostGraphile to generate both simple list and Relay connection fields for collections related to this table, overriding the global setting. Note: `@simpleCollections` is deprecated in favor of `@behavior +list +connection`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_27\n\nLANGUAGE: sql\nCODE:\n```\ncomment on table email is\n  E'@simpleCollections both';\n```\n\n----------------------------------------\n\nTITLE: Installing wal2json PostgreSQL Extension (Shell)\nDESCRIPTION: Provides shell commands to download, compile, and install the `wal2json` PostgreSQL extension. This extension is a dependency for the `@graphile/subscriptions-lds` plugin, used to format the logical replication stream into JSON.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/live-queries.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/eulerto/wal2json.git\ncd wal2json\nUSE_PGXS=1 make\nUSE_PGXS=1 make install\n```\n\n----------------------------------------\n\nTITLE: Shortening Plural and Singular Reverse Relation Field Names - Diff\nDESCRIPTION: These diff snippets highlight the simplification of both plural and singular field names in the generated GraphQL schema. It shows how relationships that previously used foreign key-based names are now named after their entity, enhancing readability and consistency. No special dependencies; represents improvements in auto-generated schema via upgrade.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/CHANGELOG.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n-  mascotsByCompanyId(\n+  mascots(\n```\n\nLANGUAGE: diff\nCODE:\n```\n-  mascotByCompanyId: Mascot\n+  mascot: Mascot\n```\n\n----------------------------------------\n\nTITLE: Example V5 Plugin Dependencies in package.json\nDESCRIPTION: Shows the `devDependencies` section of `package.json` after upgrading PostGraphile V4 dependencies to their V5 beta versions. This reflects the outcome of running the `yarn add` command shown previously.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"devDependencies\": {\n    \"graphile-build\": \"^5.0.0-beta.27\",\n    \"graphile-build-pg\": \"^5.0.0-beta.31\",\n    \"postgraphile\": \"^5.0.0-beta.32\",\n    \"postgraphile-plugin-connection-filter\": \"^3.0.0-beta.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding PostGraphile Dependency using Yarn (Bash)\nDESCRIPTION: Uses the Yarn package manager to add the `postgraphile` npm package as a dependency to the current project. Requires Yarn to be installed.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add postgraphile\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Compose on Linux - Shell\nDESCRIPTION: Installs Docker Compose using the system's package manager (apt). Required for orchestrating multi-container Docker setups. Assumes Docker is already installed. Output: docker-compose binary added to system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt install docker-compose\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via HTTPS using Yarn (Shell)\nDESCRIPTION: Executes the `deploy` script defined in `package.json` using HTTPS for authentication. The `GIT_USER` environment variable provides the necessary username (e.g., GitHub username) for authenticating the push operation when deploying the built site, typically to the `gh-pages` branch on GitHub. Replace `<Your GitHub username>` with the actual username.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Referencing the Recommended 'makePgService' Function (JavaScript)\nDESCRIPTION: Mentions the `makePgService` function, which is the recommended utility for creating PostgreSQL service configurations (`pgServices`). The changelog notes that users employing this function might be less affected by the breaking change related to adaptor loading, as it likely handles the import internally.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build-pg/CHANGELOG.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmakePgService\n```\n\n----------------------------------------\n\nTITLE: Setting GRAPHILE_LICENSE Environment Variable in Bash/Shell\nDESCRIPTION: Demonstrates how to set the `GRAPHILE_LICENSE` environment variable required for premium PostGraphile plugins across different shell environments (Bash for GNU/Linux/macOS, Heroku CLI, Windows Console, Windows PowerShell). This variable must contain the license key obtained from the Graphile Store.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/plugins.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# GNU/Linux and macOS bash:\nexport GRAPHILE_LICENSE=\"license_key_from_graphile_store\"\npostgraphile -c postgres://...\n\n# Heroku\nheroku config:set GRAPHILE_LICENSE=\"license_key_from_graphile_store\" -a my_heroku_app\n\n# Windows Console\nset GRAPHILE_LICENSE=\"license_key_from_graphile_store\" & postgraphile -c postgres://...\n\n# Windows PowerShell\n$env:GRAPHILE_LICENSE=\"license_key_from_graphile_store\"; postgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote (Library Setup) (Bash)\nDESCRIPTION: Adds a Git remote named 'heroku' to the local repository, using the SSH URL format (`git@heroku.com:myappname.git`). This method requires prior setup of SSH keys with Heroku. Replace `myappname` with the actual Heroku application name. Used in the library setup context.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add heroku git@heroku.com:myappname.git\n```\n\n----------------------------------------\n\nTITLE: Rendering Pricing Table Row with Responsive Icons - React (JavaScript)\nDESCRIPTION: This snippet renders table cells within a product pricing comparison table, using the Icon component, dynamic class assignments (via pricingStyles.showMobile), and support for both mobile and desktop views. It utilizes React JSX syntax and demonstrates conditional content rendering for responsive design. Dependencies include the Icon component, CSS modules (pricingStyles), and possibly a FontAwesome icon library. The code expects proper CSS classes for showMobile and showFull responsiveness. Inputs are not user-driven, but depend on CSS classes and the supplied icon props; outputs are styled table cell elements with appropriate icons for device type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/src/pages/pricing.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={pricingStyles.showMobile}>\n  <Icon icon=\"fa-solid fa-square-phone-flip\" size=\"lg\" />\n</span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n<span className={pricingStyles.showFull}>\n  Discounted consultancy packages\n</span>\n<span className={pricingStyles.showMobile}>\n  <Icon icon=\"fa-solid fa-circle-check\" size=\"lg\" />\n</span>\n```\n\n----------------------------------------\n\nTITLE: Installing jest-serializer-graphql-schema using npm\nDESCRIPTION: Installs the `jest-serializer-graphql-schema` package as a development dependency using the npm package manager. The `@beta` tag indicates installation of a specific pre-release version.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/jest-serializer-graphql-schema/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With npm\nnpm install --save-dev jest-serializer-graphql-schema@beta\n```\n\n----------------------------------------\n\nTITLE: Adding Query Builders and Metadata (TypeScript)\nDESCRIPTION: `PgInsertSingle`, `PgUpdateSingle`, and `PgDeleteSingle` steps now gain associated query builders. Query builders also gain a `meta` property, an object for attaching metadata (e.g., for cursor implementation like `clientMutationId`).\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nPgInsertSingle // Gains query builder\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgUpdateSingle // Gains query builder\n```\n\nLANGUAGE: typescript\nCODE:\n```\nPgDeleteSingle // Gains query builder\n```\n\nLANGUAGE: typescript\nCODE:\n```\nqb.meta // New property on query builders\n```\n\nLANGUAGE: typescript\nCODE:\n```\nclientMutationId // Example usage of meta\n```\n\n----------------------------------------\n\nTITLE: Creating Docusaurus Documentation Version\nDESCRIPTION: Uses the Docusaurus CLI via Yarn to create a new versioned copy of the documentation, labeled '6' in this example. This command is executed when beginning work on a new major software version ('6') to snapshot the current documentation under that version number.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn docusaurus docs:version 6\n```\n\n----------------------------------------\n\nTITLE: Running a Template Expression Fragment with te.run - JavaScript\nDESCRIPTION: This code snippet demonstrates how to use the `te.run` function to evaluate a pre-built template expression fragment. The fragment returns the result of an expression (`1 + 2`), and the final result is asserted using `assert.equal`. Dependencies include the `te` template engine and the `assert` library. Inputs are the code fragments, and expected outputs are the evaluation results. The main constraint is that only valid code fragments can be evaluated; otherwise, errors may be thrown.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fragment = te`return 1 + 2`;\nconst result = te.run(fragment);\n\nassert.equal(result, 3);\n```\n\n----------------------------------------\n\nTITLE: Versioning Documentation with Docusaurus for graphile-build - Shell\nDESCRIPTION: This shell command versions the documentation for the graphile-build package using the Docusaurus CLI. The 'docs:version' command creates a new versioned documentation snapshot (e.g., version 6). Before running, ensure Docusaurus and Yarn are installed and configured in the project. Replace 6 with the target major version as needed.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n```\nyarn docusaurus docs:version 6\n```\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Initial Project Files (Bash)\nDESCRIPTION: Adds all files in the current directory to the Git staging area and creates a new commit with the message \"Initial commit\". Requires Git.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit add . && git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Installing Preset using Yarn\nDESCRIPTION: This Bash command installs the `@graphile/simplify-inflection` package using the Yarn package manager. The `@beta` tag indicates installation of a beta version.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-simplify-inflection/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @graphile/simplify-inflection@beta\n```\n\n----------------------------------------\n\nTITLE: Versioning Documentation with Docusaurus for graphile-build-pg - Shell\nDESCRIPTION: This shell command creates a versioned documentation snapshot for the graphile-build-pg package using Yarn and the Docusaurus CLI. It differs from the graphile-build command with a more specific script name, docs:version:graphile-build-pg. Replace 6 with the required major version to snapshot. Ensure required scripts are present in package.json.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/website/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n```\nyarn run docusaurus docs:version:graphile-build-pg 6\n```\n```\n\n----------------------------------------\n\nTITLE: package.json Updates for Better Project Configuration - Diff\nDESCRIPTION: This diff shows recommended changes to package.json: marks the project as private, removes 'main', adds a 'start' script, and deletes unused metadata. Inputs are the previous package.json file; the output is the changes to be applied for a better development workflow.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/usage-library.md#_snippet_12\n\nLANGUAGE: Diff\nCODE:\n```\n {\n   \"name\": \"postgraphile_express\",\n   \"version\": \"1.0.0\",\n-  \"main\": \"index.js\",\n+  \"private\": true,\n+  \"type\": \"module\",\n   \"scripts\": {\n+    \"start\": \"node --env-file=./.env server.js\",\n     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n   },\n-  \"keywords\": [],\n-  \"author\": \"\",\n-  \"license\": \"ISC\",\n-  \"description\": \"\",\n   \"dependencies\": {\n     \"express\": \"^4.21.2\",\n     \"postgraphile\": \"^5.0.0-beta.38\"\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.7\nDESCRIPTION: This snippet indicates an update to the project's dependencies, specifically referencing version '0.0.1-0.7' of the 'grafast' package in the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.7\n```\n\n----------------------------------------\n\nTITLE: Initial Changesets Release Commit\nDESCRIPTION: This markdown line documents the initial release managed by 'changesets', linking to the relevant pull request (#125) and commit hash ('91f2256b3'). It attributes the change to user '@benjie'.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\n- [#125](https://github.com/benjie/crystal/pull/125)\n  [`91f2256b3`](https://github.com/benjie/crystal/commit/91f2256b3fd699bec19fc86f1ca79df057e58639)\n  Thanks [@benjie](https://github.com/benjie)! - Initial changesets release\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via SSH using Yarn (Shell)\nDESCRIPTION: Executes the `deploy` script defined in `package.json` using SSH for authentication (e.g., for GitHub Pages deployment). The `USE_SSH=true` environment variable instructs the deployment script (often Docusaurus's deploy command) to use SSH keys for pushing the built site to the `gh-pages` branch or another configured target.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Displaying Featured Sponsors using Custom React Components\nDESCRIPTION: Utilizes the custom `<Sponsors>` React component with the `level` prop set to \"featured\". Inside, multiple `<Sponsor>` components are nested, each configured with `name`, `avatar` (image path), `href` (link URL), and the `business` boolean prop to display individual featured business sponsors with their logos and links. This block dynamically renders the prominent featured sponsors section, populated by data passed as props.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/sponsor.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Sponsors level=\"featured\">\n  <Sponsor\n    name=\"The Guild\"\n    avatar=\"/images/sponsors/theguild.png\"\n    href=\"https://www.the-guild.dev/\"\n    business\n  />\n  <Sponsor\n    name=\"Dovetail\"\n    avatar=\"/images/sponsors/dovetail.png\"\n    href=\"https://dovetailapp.com/\"\n    business\n  />\n  <Sponsor\n    name=\"Stellate\"\n    avatar=\"/images/sponsors/Stellate.png\"\n    href=\"https://stellate.co/\"\n    business\n  />\n  <Sponsor\n    name=\"Steelhead\"\n    avatar=\"/images/sponsors/steelhead.svg\"\n    href=\"https://gosteelhead.com/\"\n    business\n  />\n  <Sponsor\n    name=\"LatchBio\"\n    avatar=\"/images/sponsors/latchbio.jpg\"\n    href=\"https://latch.bio/\"\n    business\n  />\n</Sponsors>\n```\n\n----------------------------------------\n\nTITLE: Initial Project Directory Structure\nDESCRIPTION: Displays the expected project directory layout before adding the GraphQL container files. It includes the database initialization scripts (`db/init`), the Dockerfile for the database (`db/Dockerfile`), the environment configuration file (`.env`), and the Docker Compose file (`docker-compose.yml`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-as-a-library-in-docker.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Creating New Crystal Context (Pseudocode)\nDESCRIPTION: Initializes a new Crystal context object for a specific execution. This context holds shared state like results and metadata grouped by plan ID. It generates a root ID and populates initial value plans for variable values, context, and the root value using `PopulateValuePlan`.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_38\n\nLANGUAGE: pseudocode\nCODE:\n```\nNewCrystalContext(aether, variableValues, context, rootValue):\n\n- Let {crystalContext} be an empty object.\n- Let {crystalContext}.{resultByIdByPlan} be an empty map.\n- Let {crystalContext}.{metaByPlan} be an empty map.\n- Let {rootId} be a new unique id.\n- Let {crystalContext}.{rootId} be {rootId}.\n- Let {variableValuesPlan} be {aether}.{variableValuesPlan}.\n- Call {PopulateValuePlan(crystalContext, variableValuesPlan, rootId, variableValues)}.\n- Let {contextPlan} be {aether}.{contextPlan}.\n- Call {PopulateValuePlan(crystalContext, contextPlan, rootId, context)}.\n- Let {rootValuePlan} be {aether}.{rootValuePlan}.\n- Call {PopulateValuePlan(crystalContext, rootValuePlan, rootId, rootValue)}.\n- Return {crystalContext}.\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Playground Component in React (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import a custom Playground component from a project-specific path and render it within a React JSX file. The import assumes the presence of the Playground component at '@site/src/components/Playground', which may require Docusaurus or a compatible framework as a prerequisite. The Playground component is then rendered as a self-closing JSX tag, likely displaying an interactive playground in the output HTML. No parameters are needed and the output depends on what the Playground component internally renders.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/playground.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport Playground from \"@site/src/components/Playground\";\n\n<Playground />\n```\n\n----------------------------------------\n\nTITLE: Project Structure After Database Setup\nDESCRIPTION: Shows the expected directory and file structure after setting up the initial database configuration, including SQL initialization scripts, the database Dockerfile, the environment file, and the Docker Compose file.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.3\nDESCRIPTION: This snippet indicates an update to project dependencies, highlighting version '0.0.1-0.3' of the 'grafast' package, as noted in the changelog entry.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.3\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in Docusaurus MDX - JavaScript\nDESCRIPTION: This snippet demonstrates how to import a scoped CSS module within a Docusaurus MDX file using ES module import syntax. The imported styles object allows you to apply hashed class names (from common.module.css) to components by referencing properties of the object. This enables modular, collision-free styling inside Docusaurus documentation pages. Dependency: Docusaurus project setup supporting MDX and CSS modules. Input: no arguments, simply makes the CSS classes available for in-file use.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/code-of-conduct.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport styles from \"@site/src/css/common.module.css\";\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.4\nDESCRIPTION: This snippet shows an update to project dependencies, specifically mentioning version '0.0.1-0.4' of the 'grafast' package within the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.4\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Bash)\nDESCRIPTION: Creates a new directory for the project using the `mkdir` command in a Unix-like shell. Replace `project_folder_name` with the desired name for your project directory.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir project_folder_name\n```\n\n----------------------------------------\n\nTITLE: Fixing peerDependencies Ranges\nDESCRIPTION: This note indicates a fix was applied to the ranges specified for peer dependencies, likely within a package configuration file (e.g., package.json). The specific commit hash '768f32681' is associated with this change.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n- [`768f32681`](undefined) - Fix peerDependencies ranges\n```\n\n----------------------------------------\n\nTITLE: Executing a Simple Test Query in psql using SQL\nDESCRIPTION: Demonstrates running a basic SQL query (`select 1 + 1 as two;`) within the `psql` interactive terminal after connecting to a database. The output shows the query result ('2' under the column 'two') and confirms the database is operational and can execute SQL commands.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\n=# select 1 + 1 as two;\n two\n-----\n   2\n(1 row)\n\n=#\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Community Edition - Shell\nDESCRIPTION: This shell command updates the package index and installs Docker Community Edition (docker-ce) on Debian-based systems. It must be run after adding Docker\\'s official repository. Outputs a functional Docker installation. Requires root access.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo apt-get update\\n$ sudo apt-get install docker-ce\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using Yarn (Shell)\nDESCRIPTION: Installs all the necessary project dependencies defined in the `package.json` file using the Yarn package manager. This is typically the first step after cloning the repository to set up the project environment.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Declaring a JSON Web Token Claim Structure in JSON (JSON)\nDESCRIPTION: Defines a sample JWT claim object with arbitrary keys and integer values, representing typical payload contents within a JWT. No dependencies are needed as this is conceptual and for illustrative purposes only. Inputs and outputs map 1:1; each key in the object corresponds to an encoded claim in the JWT. There are no constraints except for being valid JSON.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_27\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"a\": 1,\n  \"b\": 2,\n  \"c\": 3\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Database - Shell\nDESCRIPTION: Provides a command to create a new PostgreSQL database using the createdb tool from the terminal. Essential for environment setup, allowing users to prepare a fresh database for PostGraphile. Input is the name of the new database; output is a created database (no output on success).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/quick-start-guide.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n```\n$ createdb mydb\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.1\nDESCRIPTION: This snippet indicates an update to the project's dependencies, specifically referencing version '0.0.1-0.1' of the 'grafast' package in the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.1\n```\n\n----------------------------------------\n\nTITLE: Collecting GraphQL Fields with Tracked Variables (Pseudocode)\nDESCRIPTION: Outlines the `GraphQLCollectFields` algorithm, a modified version of the standard GraphQL `CollectFields`. This version integrates 'tracked' variable access using `__TrackedObjectPlan` and manages `groupId`/`maxGroupId` based on `@stream` and `@defer` directives. The specific implementation details are marked as TODO.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_27\n\nLANGUAGE: pseudocode\nCODE:\n```\nGraphQLCollectFields(objectType, selectionSet, trackedVariableValuesPlan):\n\n- TODO.\n```\n\n----------------------------------------\n\nTITLE: Testing Docker Installation with hello-world (Shell)\nDESCRIPTION: Runs the `hello-world` container image using the `docker run` command. Docker will automatically download the lightweight image if it's not already present locally. Executing this command successfully confirms that the Docker installation is functional.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker run hello-world\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via SSH with Yarn (Shell)\nDESCRIPTION: Initiates the deployment process using Yarn, specifically utilizing the `deploy` script. The `USE_SSH=true` environment variable signals that SSH authentication should be used for pushing the built site (from the `build` directory) to the configured deployment target, commonly the `gh-pages` branch on GitHub.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Displaying Graphile Logo using JSX and CSS Modules\nDESCRIPTION: This JSX snippet renders a `div` element assigned the CSS class `graphileHeart` from the imported CSS module (`styles` object). Inside the `div`, it uses Markdown syntax (within the MDX context) to display the Graphile logo image located at `@site/static/img/graphile.optimized.centered.svg`. This requires a JSX/MDX processing environment like Docusaurus.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/code-of-conduct.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div className={styles.graphileHeart}>\n\n![The Graphile logo - a stylized red heart](@site/static/img/graphile.optimized.centered.svg)\n\n</div>\n```\n\n----------------------------------------\n\nTITLE: Refactoring Field Argument Handling in Grafast (TypeScript)\nDESCRIPTION: Input handling is shifting towards runtime evaluation. `FieldArgs.get` is removed; use `FieldArgs.getRaw` for the raw value or `bakedInput()` for a processed version. Field arguments are now passed a `FieldArg` object instead of `FieldArgs`. The `FieldArgs` object gains a `typeAt(path)` method to inspect input types.\nSOURCE: https://github.com/graphile/crystal/blob/main/graphile-build/graphile-build/CHANGELOG.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArgs.get // Removed\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArgs.getRaw\n```\n\nLANGUAGE: typescript\nCODE:\n```\nbakedInput()\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArgs\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArg\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFieldArgs.typeAt(path)\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.11\nDESCRIPTION: This snippet indicates that the project's dependencies were updated, specifically mentioning version '0.0.1-0.11' of the 'grafast' package in the project's changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.11\n```\n\n----------------------------------------\n\nTITLE: Optimizing a Single Plan - Pseudocode\nDESCRIPTION: Stub: This function returns the original plan unchanged but is intended as a place to add plan deduplication, merging, or other optimizations. It acts as a pass-through until filled out. Inputs: aether, plan. Outputs: original plan (currently).\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_6\n\nLANGUAGE: pseudocode\nCODE:\n```\nOptimizePlan(aether, plan):\n\n- Return plan.\n\nTODO: merge similar plans, etc.\n\nNote: we must never optimise {__ValuePlan()} plans.\n```\n\n----------------------------------------\n\nTITLE: Specifying grafast Dependency Version 0.0.1-0.6\nDESCRIPTION: This snippet shows that project dependencies were updated, specifically mentioning version '0.0.1-0.6' of the 'grafast' package within the changelog.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/dataplan-json/CHANGELOG.md#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\ngrafast@0.0.1-0.6\n```\n\n----------------------------------------\n\nTITLE: Destroying a Heroku Application (Bash)\nDESCRIPTION: Permanently deletes the specified Heroku application (`-a myappname`) and all associated resources, including dynos, add-ons, and configuration variables. This action is irreversible and requires confirmation when run interactively. Replace `myappname` with the target application's name.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/deploying-heroku.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nheroku apps:destroy -a myappname\n```\n\n----------------------------------------\n\nTITLE: Project Structure After PostGraphile Setup\nDESCRIPTION: Shows the updated directory and file structure after adding the PostGraphile service configuration, including its dedicated `graphql` folder containing the Dockerfile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_15\n\nLANGUAGE: plaintext\nCODE:\n```\n/\nâ”œâ”€ db/\n|  â”œâ”€ init/\n|  |  â”œâ”€ 00-database.sql\n|  |  â””â”€ 01-data.sql\n|  â””â”€ Dockerfile\nâ”œâ”€ graphql/\n|  â””â”€ Dockerfile\nâ”œâ”€ .env\nâ””â”€ docker-compose.yml\n```\n\n----------------------------------------\n\nTITLE: Querying a View with GraphQL (GraphQL)\nDESCRIPTION: This GraphQL snippet shows how to query the 'comedies' view, retrieving the first 20 records with fields 'name' and 'releaseYear'. It expects that the GraphQL API generated by PostGraphile exposes the 'comedies' view as a node. Inputs are optional pagination (e.g., 'first'); outputs are fields from the view. Requires a running PostGraphile server with the view registered.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/views.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  comedies(first: 20) {\n    name\n    releaseYear\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Aether Compatibility - Pseudocode\nDESCRIPTION: This function determines whether a cached Aether can be reused for a provided GraphQL operation by deeply checking schema, document, and operation name equality, as well as variable, context, and root value constraints. Requires each constraint set and a utility function for constraint satisfaction. Inputs: an Aether object and current request parameters; Output: true or false. Limitation: Relies on correct constraint definition and matching logic for accuracy.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafast/CRYSTAL_FLOW.md#_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nIsAetherCompatible(aether, schema, document, operationName, variableValues, context, rootValue):\n\n- If {aether}.{schema} is not equal to {schema}:\n  - Return {false}.\n- If {aether}.{document} is not equal to {document}:\n  - Return {false}.\n- If {aether}.{operationName} is not equal to {operationName}:\n  - Return {false}.\n- Let {variableValuesConstraints} be {aether}.{variableValuesConstraints}.\n- Let {contextConstraints} be {aether}.{contextConstraints}.\n- Let {rootValueConstraints} be {aether}.{rootValueConstraints}.\n- If not {MatchesConstraints(variableValuesConstraints, variableValues)}:\n  - Return {false}.\n- If not {MatchesConstraints(contextConstraints, context)}:\n  - Return {false}.\n- If not {MatchesConstraints(rootValueConstraints, rootValue)}:\n  - Return {false}.\n- Return {true}.\n```\n\n----------------------------------------\n\nTITLE: Defining the pgSingleTablePolymorphic Function Signature in TypeScript\nDESCRIPTION: Defines the TypeScript function signature for `pgSingleTablePolymorphic`, which takes a step resolving to a GraphQL type name (`$typePlan`) and a step representing a database row (`$rowPlan` of type PgSelectSingleStep) to handle single-table polymorphism. This function is presented within commented-out documentation as a simpler alternative to `pgPolymorphic` for this specific polymorphism style.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport function pgSingleTablePolymorphic(\n  $typePlan: ExecutableStep<string>,\n  $rowPlan: PgSelectSingleStep,\n): PgSingleTablePolymorphicStep;\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Enum Type for Post Topics (SQL)\nDESCRIPTION: Defines a PostgreSQL enumerated type named `forum_example.post_topic` with possible values 'discussion', 'inspiration', 'help', and 'showcase'. This type is intended for use in a table column to categorize forum posts.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/postgresql-schema-design.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\ncreate type forum_example.post_topic as enum (\n  'discussion',\n  'inspiration',\n  'help',\n  'showcase'\n);\n```\n\n----------------------------------------\n\nTITLE: Applying Virtual @unique Constraints via JSON5\nDESCRIPTION: This snippet uses the 'unique' smart tag in JSON5 format to apply virtual unique constraints to a view, supporting both single-column and multi-column (composite) uniqueness. Dependencies are PostGraphile 4.9.1+ and usage of smart tags in a configuration file. The input is view or table name and columns for uniqueness. This does not enforce database constraints but marks fields as unique in GraphQL.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_20\n\nLANGUAGE: JSON5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    class: {\n      my_view: {\n        tags: {\n          unique: [\"id\", \"org_id,slug\"],\n          // or:\n          //   unique: \"id\"\n        },\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Wrapping User.email Plan for Access Control using makeWrapPlansPlugin (Method 1) in TypeScript\nDESCRIPTION: Provides an example using Method 1 of `makeWrapPlansPlugin` to implement access control on the `User.email` field. The wrapper retrieves the user's ID from the source step (`$user`), the current user's ID from the context (`context().get(\"jwtClaims\")`), and the email from the original plan (`plan()`). It uses a `lambda` step to compare the IDs and return the email only if they match, otherwise returning `null`. Dependencies include `makeWrapPlansPlugin`, `context`, and `lambda`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-wrap-plans-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeWrapPlansPlugin } from \"postgraphile/utils\";\nimport { context, lambda } from \"postgraphile/grafast\";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan, $user) {\n      const $userId = $user.get(\"id\");\n      const $currentUserId = context().get(\"jwtClaims\").get(\"user_id\");\n      const $email = plan();\n      return lambda(\n        [$userId, $currentUserId, $email],\n        ([userId, currentUserId, email]) =>\n          userId === currentUserId ? email : null,\n      );\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Running GraphQL Schema Benchmark with DataLoader - JavaScript\nDESCRIPTION: Executes a benchmark to measure the time taken for GraphQL.js to run a query against a DataLoader-based schema 10,000 times. Requires Node.js, the necessary schema files, and configured DataLoaders. Outputs the total time taken; should be run with 'node index.mjs graphql' in a terminal.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/examples/users-and-friends/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnode index.mjs graphql\n```\n\n----------------------------------------\n\nTITLE: Disambiguating SQL Function Arguments Using Numeric Placeholders\nDESCRIPTION: Shows an alternative method for creating a stable SQL function `get_user` using numeric arguments. It references the first function argument `id` using the positional placeholder `$1` to avoid conflicts with the table column `users.id`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/functions.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\n```sql {2}\ncreate function get_user(id int) returns users as $$\n  select * from users where users.id = $1;\n$$ language sql stable;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Update/Delete Policies for Personal Ownership (SQL)\nDESCRIPTION: These SQL commands define RLS policies that permit the \\\"forum_example_person\\\" role to update or delete only their own rows in the \\\"person\\\" table. Access is checked by comparing the row's \\\"id\\\" with the JWT claim \"person_id\". The use of \\\"current_setting('jwt.claims.person_id', true)\\\" integrates JWT authentication for per-row privileges. These are necessary to enforce user-specific write access.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/postgresql-schema-design.md#_snippet_39\n\nLANGUAGE: sql\nCODE:\n```\ncreate policy update_person on forum_example.person for update to forum_example_person\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n\ncreate policy delete_person on forum_example.person for delete to forum_example_person\n  using (id = nullif(current_setting('jwt.claims.person_id', true), '')::integer);\n```\n\n----------------------------------------\n\nTITLE: Applying Deprecated @omit Tag via Comment - SQL\nDESCRIPTION: Adds a deprecated '@omit' smart tag to a PostgreSQL table using SQL comment syntax. The comment disables create, update, and delete mutations for 'table_name' in GraphQL API generated by PostGraphile. Use for legacy configuration only. Value format: comma-separated list of actions.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags.md#_snippet_24\n\nLANGUAGE: SQL\nCODE:\n```\ncomment on table table_name is E'@omit create,update,delete';\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple DEBUG Namespaces (Bash)\nDESCRIPTION: This Bash command demonstrates how to enable multiple debug namespaces simultaneously by setting the `DEBUG` environment variable to a comma-separated list (`graphile-build:warn,@dataplan/pg:*`). This specific example enables warnings from `graphile-build` and all debug messages (`*`) from `@dataplan/pg`, providing broader debugging output when running PostGraphile.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/debugging.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Bash (Linux, macOS, etc)\nexport DEBUG=\"graphile-build:warn,@dataplan/pg:*\"\npostgraphile -c postgres://...\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Mutation with Transaction using makeExtendSchemaPlugin in PostGraphile V5 (JavaScript)\nDESCRIPTION: Demonstrates how to create a custom GraphQL mutation using `makeExtendSchemaPlugin` in PostGraphile V5. It utilizes `withPgClientTransaction` from `@dataplan/pg` to execute asynchronous operations, including SQL queries via `client.query`, within a database transaction. The example defines input/output types, retrieves the database executor, constructs a Grafast plan using `object` and `withPgClientTransaction`, executes SQL (`generate_series`), simulates async work, and returns the result.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { object } from \"postgraphile/grafast\";\n// highlight-next-line\nimport { withPgClientTransaction } from \"postgraphile/@dataplan/pg\";\nimport { makeExtendSchemaPlugin } from \"postgraphile/utils\";\n\nexport default makeExtendSchemaPlugin((build) => {\n  const { sql } = build;\n  /**\n   * The 'executor' tells us which database we're talking to.\n   * You can get this from the registry, the default executor name is `main`\n   * but you can override this and add extra sources/executors via the\n   * `pgServices` configuration option.\n   */\n  const executor = build.input.pgRegistry.pgExecutors.main;\n\n  return {\n    typeDefs: /* GraphQL */ `\n      input MyCustomMutationInput {\n        count: Int\n      }\n      type MyCustomMutationPayload {\n        numbers: [Int!]\n      }\n      extend type Mutation {\n        \"\"\"\n        An example mutation that doesn't really do anything; uses Postgres'\n        generate_series() to return a list of numbers.\n        \"\"\"\n        myCustomMutation(input: MyCustomMutationInput!): MyCustomMutationPayload\n      }\n    `,\n\n    plans: {\n      Mutation: {\n        myCustomMutation(_$root, { $input: { $count } }) {\n          /**\n           * This step dictates the data that will be passed as the second argument\n           * to the `withPgClientTransaction` callback. This is typically\n           * information about the field arguments, details from the GraphQL\n           * context, or data from previously executed steps.\n           */\n          const $data = object({\n            count: $count,\n          });\n\n          // Callback will be called with a client that's in a transaction,\n          // whatever it returns (plain data) will be the result of the\n          // `withPgClientTransaction` step; if it throws an error then the\n          // transaction will roll back and the error will be the result of the\n          // step.\n          // highlight-start\n          const $transactionResult = withPgClientTransaction(\n            executor,\n            $data,\n            async (client, data) => {\n              // The data from the `$data` step above\n              const { count } = data;\n\n              // Run some SQL\n              const { rows } = await client.query(\n                sql.compile(\n                  sql`select i from generate_series(1, ${sql.value(\n                    count ?? 1,\n                  )}) as i;`,\n                ),\n              );\n\n              // Do some asynchronous work (e.g. talk to Stripe or whatever)\n              await sleep(2);\n\n              // Maybe run some more SQL as part of the transaction\n              await client.query(sql.compile(sql`select 1;`));\n\n              // Return whatever data you'll need later\n              return rows.map((row) => row.i);\n            },\n          );\n          // highlight-end\n\n          return $transactionResult;\n        },\n      },\n      MyCustomMutationPayload: {\n        numbers($transactionResult) {\n          return $transactionResult;\n        },\n      },\n    },\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Heroku Git Remote (Bash)\nDESCRIPTION: Uses the Heroku CLI to associate the local Git repository with a specific Heroku application (`heroku_app_name`), adding a remote named 'heroku'. Requires the Heroku CLI and an existing Heroku app.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/deploying-heroku.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nheroku git:remote -a heroku_app_name\n```\n\n----------------------------------------\n\nTITLE: Equivalent PostGraphile Configuration File with Watch Mode (graphile.config.mjs) using JavaScript\nDESCRIPTION: A JavaScript configuration file (`graphile.config.mjs`) demonstrating how to configure PostGraphile to achieve the same result as the command-line invocation with the watch flag. It imports the Amber preset, uses `makePgService` to define the database connection string (`postgres:///mydb`), and sets `watch: true` within the `grafserv` options. Requires the `postgraphile` package and its dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/quick-start-guide.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\nimport { makePgService } from \"postgraphile/adaptors/pg\";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [PostGraphileAmberPreset],\n  pgServices: [makePgService({ connectionString: \"postgres:///mydb\" })],\n  grafserv: { watch: true },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Standard GraphQL Resolver with External Dependency (TypeScript)\nDESCRIPTION: This code defines a typical GraphQL resolver for a User.friends field in a TypeScript module. The resolver uses an external db instance imported from another module. The dependency on db means this function is impure and not directly exportable unless the dependency is handled explicitly. To make it exportable, the resolver must be transformed or wrapped.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/exportable.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"../runtime/db\";\n\nconst resolvers = {\n  User: {\n    async friends(user, args, context, resolveInfo) {\n      // highlight-next-line\n      return await db.friends.loadMany(user.id, context);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using the `first` Function in Graphile Crystal (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the usage of the `first` function. It takes a step that resolves to a list (`$list`) as input and returns a new step (`$firstItem`) that resolves to the first element of that list. This is useful for extracting a single item from a collection returned by a previous step in a plan.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/standard-steps/first.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst $firstItem = first($list);\n```\n```\n\n----------------------------------------\n\nTITLE: Extending PostGraphile Presets with Relay and Amber (JavaScript)\nDESCRIPTION: This JavaScript module demonstrates how to extend the PostGraphile configuration to include both the 'amber' and 'relay' presets. By importing and adding 'PostGraphileAmberPreset' and 'PostGraphileRelayPreset' to the 'extends' array, it configures the GraphQL schema to use the Relay conventions for global object identification. This method is typically applied in a 'graphile.config.mjs' file and requires both presets as dependencies.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/node-id.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { PostGraphileAmberPreset } from \"postgraphile/presets/amber\";\n// highlight-next-line\nimport { PostGraphileRelayPreset } from \"postgraphile/presets/relay\";\n\nexport default {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-next-line\n    PostGraphileRelayPreset,\n    //...\n  ],\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring PersistedPlugin in Grafserv using TypeScript\nDESCRIPTION: This TypeScript snippet shows how to import and add the `PersistedPlugin` to the `plugins` array within a `graphile.config.ts` file. It also illustrates setting a configuration option (`persistedOperationsDirectory`) within the `grafserv` section of the preset, pointing to a directory where persisted operation files are stored.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/grafserv-persisted/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"graphile-config\";\nimport PersistedPlugin from \"@grafserv/persisted\";\n\nconst preset: GraphileConfig.Preset = {\n  plugins: [PersistedPlugin],\n  grafserv: {\n    /* add configuration options here, e.g. */\n    persistedOperationsDirectory: `${process.cwd()}/.persisted_operations`,\n  },\n};\n\nexport default preset;\n```\n\n----------------------------------------\n\nTITLE: Listing Core Behavior Scopes for Graphile Build Plugins (Text)\nDESCRIPTION: This section lists the core behavior identifiers (scopes) utilized by PostGraphile/Graphile Build plugins. Scopes are structured hierarchically with specificity increasing from right to left (e.g., 'select' is broad, 'resource:select' is narrower). These behaviors define permissions and capabilities for various operations like selecting, inserting, updating, deleting data, filtering, ordering, handling connections, aggregates, and relationships across resources, attributes, constraints, and procedures.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/behavior.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n- `select` - can select this resource/column/etc. Note this does not necessarily\n  mean you can do `select * from users` but it might mean that it's possible to\n  see details about a `users` when it's returned by a function or similar. (In\n  this case the `codec` has `select` but the `resource` has `-select`.)\n- `resource:select` - can select rows from this resource\n- `insert:resource:select` - can select the row that was inserted (on the mutation payload)\n- `update:resource:select` - can select the row that was updated (on the mutation payload)\n- `delete:resource:select` - can select the row that was deleted (on the mutation payload)\n- `delete:resource:nodeId` - can select the nodeId of the row that was deleted (on the mutation payload)\n- `resource:insert` - can insert into this resource\n- `resource:update` - can update a record in this resource\n- `resource:delete` - can delete a record in this resource\n- `resource:list` - \"list\" field for a resource at any level\n- `resource:connection` - \"connection\" field for a resource at any level\n- `resource:list:filter` - can we filter this resource's results (when represented as a list)?\n- `resource:list:order` - can we order this resource's results (when represented as a list)?\n- `resource:connection:filter` - can we filter this resource's results (when represented as a connection)?\n- `resource:connection:order`- can we order this resource's results (when represented as a connection)?\n- `resource:connection:backwards` - can we paginate backwards through this resource's results (when represented as a connection)?\n- `resource:aggregates` - does this resource support aggregates across its attributes (i.e. does the `aggregates` field get added to connections)\n- `resource:groupedAggregates` - does this resource support grouped aggregates across its attributes (i.e. does the `groupedAggregates` field get added to connections)\n- `resource:groupedAggregates:having` - can groupedAggregates on this resource have a 'having' clause?\n- `sum:resource:groupedAggregates:having` - can groupedAggregates on this resource have a 'having' clause that uses the 'sum' aggregate?\n- `sum:resource:aggregates` - does this resource support 'sum' aggregates across its attributes (replace 'sum' with the aggregate id you care about) (i.e. does the `sum` field get added within the `aggregates` field on connections?)\n- `constraint:resource:update` - can update a record by this constraint\n- `constraint:resource:delete` - can delete a record by this constraint\n- `nodeId:resource:update` - can update a record by its NodeID\n- `nodeId:resource:delete` - can delete a record by its NodeID\n- `attribute:select` - can this attribute be selected?\n- `attribute:insert` - can this attribute be inserted into?\n- `attribute:update` - can this attribute be updated?\n- `attribute:base` - should we add this attribute to the \"base\" input type?\n- `attribute:aggregate` - can we aggregate on this attribute?\n- `sum:attribute:aggregate` - can we perform the 'sum' aggregate on this attribute? (replace 'sum' with the aggregate id you care about) (i.e. does this attribute get added to the `sum` field on the `aggregates` field on connections?)\n- `sum:resource:aggregate` - does this computed-column-like resource support the 'sum' aggregate when acting as an attribute (replace 'sum' with the aggregate id you care about)\n- `attribute:groupBy` - can we group by this attribute when performing grouped aggregates?\n- `attribute:havingBy` - can this attribute be used in the 'having' clause of a grouped aggregate?\n- `sum:attribute:havingBy` - can the sum of this attribute be used in the 'having' clause of a grouped aggregate?\n- `resource:havingBy` - can this computed-column-like resource be used in the 'having' clause of a grouped aggregate?\n- `sum:resource:havingBy` - can the sum of this computed-column-like resource be be used in the 'having' clause of a grouped aggregate?\n- `nodeId:insert` - can we insert to the columns represented by this nodeId which represents a table related via foreign key constraint?\n- `nodeId:update` - can we update the columns represented by this nodeId which represents a table related via foreign key constraint?\n- `nodeId:base` - should we add a nodeId input representing this foreign key constraint to the \"base\" input type?\n- `type:node` - should the GraphQLObjectType (`type`) this codec represents\n  implement the GraphQL Global Object Identification specification\n- `interface:node` - should the GraphQLInterfaceType (`interface`) this codec\n  represents implement the GraphQL Global Object Identification specification\n- `list` - list (simple collection)\n- `connection` - connection (GraphQL Cursor Pagination Spec)\n- `query:resource:list` - \"list\" field for a resource at the root Query level\n- `query:resource:connection` - \"connection\" field for a resource at the root Query level\n- `query:interface:list` - \"list\" field for a interface at the root Query level\n- `query:interface:connection` - \"connection\" field for a interface at the root Query level\n- `queryField` - for procedures: should it become a field on the `Query` type?\n- `typeField` - for procedures: should it become a field on a non-operation\n  type?\n- `queryField:resource:connection` - should we represent this resource with a connection on the `Query` type?\n- `queryField:resource:list` - should we represent this resource with a list on the `Query` type?\n- `typeField:resource:connection` - should we represent this resource with a connection on a non-operation type\n- `typeField:resource:list` - should we represent this resource with a list on a non-operation type\n- `mutationField` - for procedures: should it become a mutation (field on\n  `Mutation`)?\n- `order` - can we sort this thing? (resource)\n- `query:resource:list:order`\n- `query:resource:connection:order`\n- `resource:relatedAggregates:orderBy` - can we order this resource by aggregates on its relationships?\n- `orderBy` - can we order by this thing (e.g. column)?\n- `proc:orderBy` - can we order by the result of this proc (function resource)?\n- `attribute:orderBy` - can we order by this attribute (column, property)?\n- `attribute:aggregate:orderBy` - can we order by aggregates of this attribute (column, property)?\n- `sum:attribute:aggregate:orderBy` - can we order by 'sum' aggregates of this attribute (column, property)?\n- `filterBy` - can we filter by this thing (e.g. column, table, etc)?\n- `proc:filterBy` - can we filter by the result of this proc (function resource)\n- `attribute:filterBy` - can we filter by this attribute (column, property)?\n- `condition:attribute:filterBy` - can we filter by this attribute (column, property) in the `condition` argument?\n- `attribute:aggregate:filterBy` - can we filter by the aggregate of this attribute (column, property)?\n- `sum:attribute:aggregate:filterBy` - can we filter by the 'sum' aggregate of this attribute (column, property)?\n- `resource:aggregates:filterBy` - can we filter (a different resource) by this resource's aggregates?\n- `sum:resource:aggregates:filterBy` - can we filter (a different resource) by this resource's 'sum' aggregates?\n- `single` - can we get just one?\n- `query:resource:single` - can we get a single one of these (resource) at the root?\n- `singularRelation:resource:single` - can we get a single one of these (resource) from a\n  type?\n- `singularRelation:resource:list` - should we add a list field to navigate this singular\n  relationship (when we know there can be at most one)?\n- `singularRelation:resource:connection` - should we add a connection field to navigate\n  this singular relationship (when we know there can be at most one)?\n- `manyRelation:resource:list`\n- `manyRelation:resource:connection`\n- `manyRelation:aggregates:orderBy` - can we order by aggregates of this manyRelation?\n- `sum:manyRelation:aggregates:orderBy` - can we order by 'sum' aggregates of this manyRelation?\n- `jwt` - should the given codec behave as if it were a JWT?\n- `insert:input:record` - input to the 'insert' mutation\n- `totalCount` - on a codec, should we add the `totalCount` field?\n```\n\n----------------------------------------\n\nTITLE: Displaying Available Configuration Options with Graphile CLI\nDESCRIPTION: Executes the `graphile config options` command via the command line. This command inspects the project's presets and plugins to generate personalized documentation listing all available configuration settings that can be used in the project's configuration file, as shown in the accompanying screenshot.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/migrating-from-v4/v5-new-feature-summary.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngraphile config options\n```\n\n----------------------------------------\n\nTITLE: Returning Named Types from PostgreSQL Functions\nDESCRIPTION: Shows the recommended syntax `returns setof named_type` for PostgreSQL functions. Using named composite types or table types is preferred over anonymous structures for better schema generation and maintainability.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/customization-overview.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nreturns setof named_type\n```\n\n----------------------------------------\n\nTITLE: Granting Docker Permissions to a User - Shell\nDESCRIPTION: This command adds a specified user to the 'docker' group to allow running Docker commands without sudo. The <username> placeholder should be replaced by the actual username. Requires a system reboot to take effect. Outputs: user\\'s group membership updated.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo usermod -a -G docker <username>\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Ignore Rules for PostGraphile (dockerignore)\nDESCRIPTION: This snippet provides a recommended .dockerignore file to exclude local development artifacts, sensitive files, and build directories from the Docker image context. Properly ignoring these files speeds up Docker builds, enhances security, and reduces final image size. Key parameters include folder and file patterns, such as node_modules, .env, and Docker-related files, to ensure the Docker image remains lean and secure. No dependencies are required except Docker itself, and the expected result is a cleaner Docker context during builds.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/deploying-docker.md#_snippet_0\n\nLANGUAGE: dockerignore\nCODE:\n```\n# .dockerignore\\n.env\\n.git\\n.github\\n.next\\n.vscode\\nnode_modules\\n\\n*Dockerfile*\\n*docker-compose*\\n\\n**/dist\\n**/__tests__\n```\n\n----------------------------------------\n\nTITLE: Querying Forums Ordered by Most Recent Related Post â€“ GraphQL\nDESCRIPTION: This GraphQL query fetches forums ordered by the most recent related post's creation timestamp, using the custom 'LAST_POST_CREATED_AT_DESC' enum value added via a PostGraphile plugin. It expects that the backend supports this custom ordering option, returning each forum's 'id' and 'name'. No explicit dependencies beyond a plugin-enabled PostGraphile-generated schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/make-add-pg-table-order-by-plugin.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery ForumsOrderedByMostRecentPost {\n  allForums(orderBy: [LAST_POST_CREATED_AT_DESC]) {\n    nodes {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting JavaScript Function Source with toString()\nDESCRIPTION: Demonstrates the standard JavaScript `.toString()` method called on a simple function without external dependencies, showing how it returns the function's source code as a string.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n> (function add(a, b) { return a + b }).toString()\n'function add(a, b) { return a + b }'\n```\n\n----------------------------------------\n\nTITLE: Implementing Column-Based Union with SQL and Foreign Keys Â· SQL\nDESCRIPTION: Defines a table where multiple foreign key columns point to different possible types in a union relationship. Enforces that exactly one column is non-null to determine the union member, corresponding to the polymorphic entity. This table supports the GraphQL union concept in the database and integrates with planning code for discriminating favorite types.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\ncreate table person_favourites (\n  id serial primary key,\n  person_id int not null references people on delete cascade,\n  liked_person_id int references people on delete cascade,\n  liked_post_id int references posts on delete cascade,\n  liked_comment_id int references comments on delete cascade\n);\n\n```\n\n----------------------------------------\n\nTITLE: Selecting an Account by Email in PL/pgSQL - SQL/PLPGSQL\nDESCRIPTION: This snippet, from within the authentication function, queries the 'person_account' table for records matching the provided email and assigns the result to the local 'account' variable. It uses parameterized queries for security and accuracy in mapping arguments. Requires that such a variable and table exist within the PostgreSQL schema.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/postgresql-schema-design.mdx#_snippet_35\n\nLANGUAGE: plpgsql\nCODE:\n```\nselect a.* into account\\nfrom forum_example_private.person_account as a\\nwhere a.email = $1;\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Name and Result Field using PostGraphile Tags File (JSON5)\nDESCRIPTION: Uses the `postgraphile.tags.json5` file to configure a database procedure named `authenticate`. The `@name` tag renames the corresponding GraphQL mutation field to `login`, and the `@resultFieldName` tag specifies that the result of the mutation should be accessible via a field named `token` on the payload type.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/smart-tags.md#_snippet_8\n\nLANGUAGE: json5\nCODE:\n```\n{\n  version: 1,\n  config: {\n    procedure: {\n      authenticate: {\n        tags: {\n          name: \"login\",\n          resultFieldName: \"token\",\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Foreign Key Constraint via ALTER TABLE in SQL\nDESCRIPTION: Illustrates adding a named foreign key constraint (`users_organization_id_fkey`) to an existing `users` table after its creation using the `ALTER TABLE` statement. The constraint links the `organization_id` column to the `organizations` table and sets the `ON DELETE CASCADE` rule. An index on the foreign key column is also created separately.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/relations.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nALTER TABLE users\n  ADD CONSTRAINT users_organization_id_fkey\n  FOREIGN KEY (organization_id)\n  REFERENCES organizations\n  ON DELETE CASCADE;\nCREATE INDEX ON users (organization_id);\n```\n\n----------------------------------------\n\nTITLE: Custom orderBy Plugin Example for Sorting Movies by Average Review Rating (TypeScript)\nDESCRIPTION: Demonstrates usage of orderByAscDesc to create a plugin for sorting movies by average rating, with special handling for null values to ensure unrated movies appear last. Employs SQL AVG aggregate, table aliases, and typed SQL expressions. Requires postgraphile/utils, correct schema structure, and is suitable for any ordering where nullable aggregate results must be handled. Returns an orderBy mapping for use with makeAddPgTableOrderByPlugin.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-add-pg-table-order-by-plugin.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst customOrderBy = orderByAscDesc(\n  \"RATING\",\n  ($select) => {\n    const sqlIdentifier = sql.identifier(Symbol(\"movie_reviews\"));\n    return sql`(\n      select avg(${sqlIdentifier}.rating)\n      from app_public.movie_reviews as ${sqlIdentifier}\n      where ${sqlIdentifier}.movie_id = ${$select.alias}.id\n    )`;\n  },\n  { nulls: \"last\" },\n);\n```\n\n----------------------------------------\n\nTITLE: Replacing @pgQuery Directive with V5 SQL Expression Plans in JavaScript\nDESCRIPTION: Illustrates converting a PostGraphile V4 plugin using `@pgQuery` and `embed` for a computed field (`nameWithSuffix`) to a V5 plan. The V5 approach uses `$user.select` with an SQL fragment constructed using the `pgSql` tagged template literal (from `pg-sql2`) and `TYPES` constants to achieve the same database-level computation safely. It depends on `pgSql` from the build object and `TYPES`.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n module.exports = makeExtendSchemaPlugin(build => {\n   const { pgSql: sql } = build;\n   return {\n     typeDefs: gql`\n       extend type User {\n-        nameWithSuffix(suffix: String!): String! @pgQuery(\n-          fragment: ${embed(\n-            (queryBuilder, args) =>\n-              sql.fragment`(${queryBuilder.getTableAlias()}.name || ' ' || ${sql.value(\n-                args.suffix\n-              )}::text)`\n-          )}\n-        )\n+        nameWithSuffix(suffix: String!): String!\n       }\n     `,\n+    plans: {\n+      User: {\n+        nameWithSuffix($user, { $suffix }) {\n+          return $user.select(\n+            sql`${$user.getClassStep().alias}.name || ' ' || ${$user.placeholder($suffix, TYPES.text)}`,\n+            TYPES.text,\n+          );\n+        }\n+      }\n+    }\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing Step Classes and Adding Dependencies in Grafast (TypeScript)\nDESCRIPTION: This snippet illustrates how to define a custom step class (`AddStep`) in TypeScript and register dependencies using the `addDependency` method. `addDependency` is called from the constructor, associating upstream steps ($a and $b) as prerequisites for execution. The method returns the positional index of each dependency within the execution tuple. Dependencies must be handled carefully due to the ephemeral nature of steps; no reference should be kept beyond the dependency graph. Key parameters are input steps $a and $b; the expected output is proper dependency registration for planned execution. Requires Grafast base `Step` class and upstream steps as arguments.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-classes.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass AddStep extends Step {\n  constructor($a, $b) {\n    super();\n    this.addDependency($a); // Returns 0\n    this.addDependency($b); // Returns 1\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Websocket Support in PostGraphile (JavaScript)\nDESCRIPTION: Demonstrates enabling websocket support for GraphQL subscriptions in a PostGraphile API by setting the 'grafserv.websockets' option to true in the Graphile configuration file. Requires PostGraphile and the appropriate server environment. Setting this flag allows the server to accept websocket connections at the default GraphQL endpoint. No other configuration is necessary for basic subscription transport setup.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/subscriptions.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  //...\n  grafserv: {\n    websockets: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: package.json After Upgrading to PostGraphile V5 (json)\nDESCRIPTION: This snippet illustrates the package.json devDependencies after successful upgrade to PostGraphile V5 betas. It specifies compatible beta/releases for graphile-build, graphile-build-pg, postgraphile, and postgraphile-plugin-connection-filter. This ensures the plugin development environment benefits from the new V5 API.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/migrating-custom-plugins.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"devDependencies\\\": {\\n    \\\"graphile-build\\\": \\\"^5.0.0-beta.27\\\",\\n    \\\"graphile-build-pg\\\": \\\"^5.0.0-beta.31\\\",\\n    \\\"postgraphile\\\": \\\"^5.0.0-beta.32\\\",\\n    \\\"postgraphile-plugin-connection-filter\\\": \\\"^3.0.0-beta.5\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Installing wal2json PostgreSQL Extension (Shell)\nDESCRIPTION: Provides shell commands to download, compile, and install the `wal2json` PostgreSQL extension. This extension is required by the `@graphile/subscriptions-lds` plugin to process the logical decoding stream from PostgreSQL into a usable JSON format.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/live-queries.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/eulerto/wal2json.git\ncd wal2json\nUSE_PGXS=1 make\nUSE_PGXS=1 make install\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Community Edition - Shell Session\nDESCRIPTION: Updates package repositories and installs Docker Community Edition via apt. This ensures Docker is installed and ready for container management. Dependency: requires setup of Docker's package sources. Input: none. Output: docker-ce installed on the system.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/running-postgraphile-in-docker.md#_snippet_1\n\nLANGUAGE: shellsession\nCODE:\n```\n$ sudo apt-get update\\n$ sudo apt-get install docker-ce\n```\n\n----------------------------------------\n\nTITLE: Masking User.email Field Value (JavaScript)\nDESCRIPTION: Example using `makeWrapResolversPlugin` (Method 1) to wrap the `User.email` field. It first calls the original resolver to get the email value, then applies a regular expression to mask parts of the email address before returning the modified value. This demonstrates modifying the resolved data.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/make-wrap-resolvers-plugin.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst { makeWrapResolversPlugin } = require(\"graphile-utils\");\n\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    email: {\n      async resolve(resolver, user, args, context, _resolveInfo) {\n        const unmaskedValue = await resolver();\n        // someone@sub.example.com -> so***@su***.com\n        return unmaskedValue.replace(\n          /^(.{1,2})[^@]*@(.{,2})[^.]*\\.([A-z]{2,})$/,\n          \"$1***@$2***.$3\",\n        );\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images for Services with Docker Compose - Shell/Bash\nDESCRIPTION: This snippet provides shell commands for building Docker images as defined in the docker-compose.yml file. You can build all service images together or selectively (e.g., for 'db' or 'graphql' only). The context for each build is derived from the Docker Compose configuration, ensuring images are up-to-date. Requires Docker Compose to be installed and invoked from the project root.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/running-postgraphile-in-docker.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n\"# Build images for all services in docker-compose.yml\\n$ docker-compose build\\n\\n# You can also build images one by one\\n# For instance you can build the database image like this\\n$ docker-compose build db\\n\\n# And build the graphql image like this\\n$ docker-compose build graphql\\n\"\n```\n\n----------------------------------------\n\nTITLE: Importing makePgSmartTagsPlugin in TypeScript\nDESCRIPTION: Shows how to import the low-level makePgSmartTagsPlugin generator from PostGraphile utilities for defining smart tag rules using either string identifiers or custom match functions. Applicable for advanced and dynamic tagging of PostgreSQL entities based on rule sets. Assumes use of 'postgraphile/utils'; for TypeScript/ESM environments.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/make-pg-smart-tags-plugin.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { makePgSmartTagsPlugin } from \"postgraphile/utils\";\n```\n\n----------------------------------------\n\nTITLE: Planning Relational Polymorphic Table Traversal with pgPolymorphic Â· TypeScript\nDESCRIPTION: Uses Graphile's 'pgPolymorphic' utility to dynamically choose and traverse the appropriate subtype table based on a discriminator column. The 'itemsTypeMap' object provides a mapping from type names to relation traversal logic. The plan function for 'Comment.item' fetches the item's type and delegates traversal to the correct single relation. Requires access to the resource tree and 'pgPolymorphic' planner.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst itemsTypeMap = {\n  Topic: {\n    match: (t) => t === \"TOPIC\",\n    plan: (_, $item) => $item.singleRelation(\"topic\"),\n  },\n  Post: {\n    match: (t) => t === \"POST\",\n    plan: (_, $item) => $item.singleRelation(\"post\"),\n  },\n  Divider: {\n    match: (t) => t === \"DIVIDER\",\n    plan: (_, $item) => $item.singleRelation(\"divider\"),\n  },\n  Checklist: {\n    match: (t) => t === \"CHECKLIST\",\n    plan: (_, $item) => $item.singleRelation(\"checklist\"),\n  },\n  ChecklistItem: {\n    match: (t) => t === \"CHECKLIST_ITEM\",\n    plan: (_, $item) => $item.singleRelation(\"checklistItem\"),\n  },\n};\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      const $item = $comment.singleRelation(\"item\");\n      const $type = $item.get(\"type\");\n      return pgPolymorphic($item, $type, itemsTypeMap);\n    },\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Dynamic Function with tamedevil\nDESCRIPTION: Demonstrates the basic usage of `tamedevil`. It uses the `te` tagged template literal along with `te.ref` (for object references) and `te.lit` (for string literals) to construct a dynamic function string. The `te.run` function then compiles and executes this string, returning the defined function (`plan`). An assertion checks the generated function's string representation.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/tamedevil/README.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// Here's a string we want to embed into the function:\nconst spec = \"some string here\";\n\n// And here's a complex variable we want to use within the function's scope:\nconst source = new Source(/* ... */);\n\nconst toEval = te`\\\n  const source = ${te.ref(source)};\n  return function plan($record) {\n    const $records = source.find(${te.lit(spec)});\n    return connection($records);\n  }\n`;\n\nconst plan = te.run(toEval);\n\nassert.strictEqual(\n  plan.toString(),\n  `function plan($record) {\n    const $records = source.find(\"some string here\");\n    return connection($records);\n  }`,\n);\n```\n\n----------------------------------------\n\nTITLE: Embedding Smart Tags Directly in Config using makeJSONPgSmartTagsPlugin (JavaScript)\nDESCRIPTION: This JavaScript configuration code shows how to create and load a smart tags plugin without reading any file system entry, suitable for scenarios where the Node.js fs module is unavailable (e.g. in bundlers like webpack). The plugin is constructed using makeJSONPgSmartTagsPlugin with a provided tags object literal in JSON shape. The example tags out an 'update' operation for the 'post' entity. Dependencies required include 'postgraphile\\/utils' and PostGraphile. The plugin must be added to the plugins array.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/smart-tags-file.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeJSONPgSmartTagsPlugin } from \"postgraphile/utils\";\n\nconst MySmartTagsPlugin = makeJSONPgSmartTagsPlugin({\n  version: 1,\n  config: {\n    class: {\n      post: {\n        tags: {\n          omit: \"update\",\n        },\n      },\n    },\n  },\n});\n\nexport default {\n  // ...\n  plugins: [MySmartTagsPlugin],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the Graphile CLI to List Inflectors - Bash\nDESCRIPTION: This bash snippet provides the sequence of commands needed to install the sponsors-only 'graphile' CLI (in beta) and invoke it to list all available inflectors in your project. 'npm install' adds the package, while 'npx' runs the command without global install. Requires access to the graphile@beta package.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/postgraphile/inflection.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev graphile@beta\nnpx graphile inflection list\n```\n\n----------------------------------------\n\nTITLE: Checking Entity Behavior in Schema Hook (New Method) - TypeScript\nDESCRIPTION: Illustrates the updated, simplified approach for checking the behavior of a PostgreSQL relation within a `GraphQLObjectType_fields_field` hook following the behavior system overhaul. It uses a dedicated helper function `build.behavior.pgCodecRelationMatches` which encapsulates the complexity of determining the final behavior, making the hook code cleaner and easier to maintain.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/postgraphile/CHANGELOG.md#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nGraphQLObjectType_fields_field(field, build, context) {\n  const relation = context.scope.pgRelationOrWhatever;\n  // Do the thing if the relation has the given behavior. Simples.\n  if (build.behavior.pgCodecRelationMatches(relation, \"behavior_to_test\")) {\n    doTheThing();\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Forum by Slug - GraphQL\nDESCRIPTION: This snippet shows how to query for a single forum by its unique slug using the forumBySlug field. It retrieves nodeId, id, slug, name, and description fields. A GraphQL endpoint set up with PostGraphile and the pg-simplify-inflector plugin must be present; the query expects a single forum object in response whose slug matches the provided value.\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/examples/basic.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n{\n  forumBySlug(slug: \"testimonials\") {\n    nodeId\n    id\n    slug\n    name\n    description\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating selectGraphQLResultFromTable to V5 pgResource Execution Plan\nDESCRIPTION: Shows how to migrate from PostGraphile V4's `selectGraphQLResultFromTable` used to call a function (`match_user`) within a resolver to a V5 plan. The V5 solution retrieves the corresponding `pgResource` for the `match_user` function from `build.input.pgRegistry.pgResources` and uses its `execute` method within the field plan, passing the necessary argument (`$searchText`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-5/migrating-from-v4/make-extend-schema-plugin.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n```diff\n module.exports = makeExtendSchemaPlugin((build) => {\n+  const matchUser = build.input.pgRegistry.pgResources.match_user;\n   return {\n     typeDefs: /* GraphQL */ `\n       type Query {\n         matchingUser(searchText: String!): User\n       }\n     `,\n-    resolvers: {\n-      Query: {\n-        matchingUser: async (parent, args, context, resolveInfo) => {\n-          const [row] = await resolveInfo.graphile.selectGraphQLResultFromTable(\n-            sql.fragment`(select * from match_user(${sql.value(\n-              args.searchText,\n-            )}))`, // Assuming sql tagged template literal was available\n-            () => {}, // no-op\n-          );\n-          return row;\n-        },\n-      },\n-    },\n+    plans: {\n+      Query: {\n+        matchingUser($parent, { $searchText }) {\n+          return matchUser.execute({ step: $searchText });\n+        },\n+      },\n+    },\n   };\n });\n```\n```\n\n----------------------------------------\n\nTITLE: HTTP Example for GraphQL Variable Query (HTTP)\nDESCRIPTION: Demonstrates how to submit a GraphQL POST request over HTTP with variables using JSON encoding. The request targets the `/graphql` endpoint, contains necessary headers for JSON API, and provides a body with the full query as a string and a variables map. This pattern is applicable to any GraphQL server, including Gra*fast*. Replace `example.com`, query text, and variables as needed. Input is a POST request; output is a standard GraphQL JSON response.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/grafast/production-considerations.md#_snippet_3\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAccept: application/json\n\n{\n  \"query\": \"query UserDetails($userId: Int!) { userById(id: $userId) { username avatarUrl } }\",\n  \"variables\": {\n    \"userId\": 7\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Limitation of toString() with Closures in JavaScript\nDESCRIPTION: Illustrates a limitation of the `.toString()` method where it doesn't capture the values of variables defined in a higher scope (closure) that the function depends on. This example shows the function `add` depends on `a`, but `a`'s value (7) isn't part of the `toString()` output.\nSOURCE: https://github.com/graphile/crystal/blob/main/utils/website/graphile-export/how-it-works.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n> const a = 7;\nundefined\n> function add(b) { return a + b };\nundefined\n> add(3)\n10\n> add.toString()\n'function add(b) { return a + b }'\n```\n\n----------------------------------------\n\nTITLE: Rendering Sponsor Call-to-Action Buttons Component\nDESCRIPTION: Renders the custom `<SponsorButtons>` React component within the MDX page. This component is responsible for displaying call-to-action buttons or links that direct users to platforms or methods for sponsoring the Graphile projects (e.g., GitHub Sponsors, Open Collective). It encapsulates the logic and presentation of these sponsorship links.\nSOURCE: https://github.com/graphile/crystal/blob/main/grafast/website/src/pages/sponsor.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<SponsorButtons></SponsorButtons>\n```\n\n----------------------------------------\n\nTITLE: Running Docker Containers with Docker Compose\nDESCRIPTION: Provides shell commands using `docker-compose up` to start the containers defined in the `docker-compose.yml` file. It includes options for running in the foreground (`docker-compose up`), running in detached (background) mode (`docker-compose up -d`), and running specific services individually in detached mode (`docker-compose up -d db`, `docker-compose up -d graphql`).\nSOURCE: https://github.com/graphile/crystal/blob/main/postgraphile/website/versioned_docs/version-4/running-postgraphile-in-docker.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n# Run containers for all services in docker-compose.yml\n$ docker-compose up\n\n# Run containers as daemon (in background)\n$ docker-compose up -d\n\n# Run only the database container as daemon\n$ docker-compose up -d db\n\n# Run only the GraphQL container as daemon\n$ docker-compose up -d graphql\n```"
  }
]