[
  {
    "owner": "cbournhonesque",
    "repo": "lightyear",
    "content": "TITLE: Registering Network Components in Lightyear with Bevy\nDESCRIPTION: Example code showing how to set up network protocol components in a Lightyear application, including message registration, input handling, component replication configuration, and channel setup with different reliability modes.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// messages\napp.add_message::<Message1>(ChannelDirection::Bidirectional);\n\n// inputs\napp.add_plugins(InputPlugin::<Inputs>::default());\n\n// components\napp.register_component::<PlayerId>(ChannelDirection::ServerToClient)\n    .add_prediction(ComponentSyncMode::Once)\n    .add_interpolation(ComponentSyncMode::Once);\n    \n// channels\napp.add_channel::<Channel1>(ChannelSettings {\n    mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n    ..default()\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Ray Cast Speed Calculation with Predicted Components in Rust\nDESCRIPTION: Example of a system that calculates ray cast speed by comparing current and previous ray cast lengths, demonstrating when components need to be predicted with full synchronization.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/prediction.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// Stores the length of the ray cast from the previous tick.\n#[derive(Component)]\nstruct RayCastPrevLength(f32)\n\nfn calculate_ray_cast_speed(time: Res<Time>, mut query: Query<(&mut RayCastPrevLength, &Position)>) {\n  for (mut ray_cast_prev_length, position) in &mut query {\n    let curr_ray_cast_length = perform_ray_cast();\n\n    // Perform calculation that relies on information from previous tick.\n    let ray_cast_speed = (curr_ray_cast_length - ray_cast_prev_length.0) / time.delta_seconds();\n\n    // Do something with ray cast speed.\n\n    // Save current ray cast length to be used in the next tick.\n    ray_cast_prev_length.0 = curr_ray_cast_length;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Lightyear Protocol\nDESCRIPTION: Demonstrates a full implementation of a network protocol plugin that registers messages, inputs, components with prediction and interpolation settings, and a custom channel configuration.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/setup.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) struct ProtocolPlugin;\n\nimpl Plugin for ProtocolPlugin {\n    fn build(&self, app: &mut App) {\n        // messages\n        app.add_message::<Message1>(ChannelDirection::Bidirectional);\n        // inputs\n        app.add_plugins(InputPlugin::<Inputs>::default());\n        // components\n        app.register_component::<PlayerId>(ChannelDirection::ServerToClient)\n            .add_prediction::<PlayerId>(ComponentSyncMode::Once)\n            .add_interpolation::<PlayerId>(ComponentSyncMode::Once);\n\n        app.register_component::<PlayerPosition>(ChannelDirection::ServerToClient)\n            .add_prediction::<PlayerPosition>(ComponentSyncMode::Full)\n            .add_interpolation::<PlayerPosition>(ComponentSyncMode::Full)\n            .add_linear_interpolation_fn::<PlayerPosition>();\n\n        app.register_component::<PlayerColor>(ChannelDirection::ServerToClient)\n            .add_prediction::<PlayerColor>(ComponentSyncMode::Once)\n            .add_interpolation::<PlayerColor>(ComponentSyncMode::Once);\n        // channels\n        app.add_channel::<Channel1>(ChannelSettings {\n            mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n            ..default()\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Player Movement on Server in Lightyear\nDESCRIPTION: Server-side system that processes InputEvents and applies movement to the corresponding player entities. It maps client IDs to entity IDs using the Global resource and applies the shared movement behavior to the player positions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn movement(\n    mut position_query: Query<&mut PlayerPosition>,\n    /// Event that will contain the inputs for the correct tick\n    mut input_reader: EventReader<InputEvent<Inputs>>,\n    /// Retrieve the entity associated with a given client\n    global: Res<Global>,\n) {\n    for input in input_reader.read() {\n        let client_id = input.context();\n        if let Some(input) = input.input() {\n            if let Some(player_entity) = global.client_id_to_entity_id.get(client_id) {\n                if let Ok(position) = position_query.get_mut(*player_entity) {\n                    shared_movement_behaviour(position, input);\n                }\n            }\n        }\n    }\n}\napp.add_systems(FixedUpdate, movement);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Component Protocol with Interpolation in Rust\nDESCRIPTION: This code defines a custom component protocol with two components, one using default interpolation and another using a custom interpolation function. It demonstrates how to specify sync modes and custom interpolation functions for components.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interpolation.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Component, Message, Serialize, Deserialize, Debug, PartialEq, Clone)]\npub struct Component1(pub f32);\n#[derive(Component, Message, Serialize, Deserialize, Debug, PartialEq, Clone)]\npub struct Component2(pub f32);\n\n#[component_protocol(protocol = \"MyProtocol\")]\npub enum MyComponentProtocol {\n    #[sync(full)]\n    Component1(Component1),\n    #[sync(full, lerp = \"MyCustomInterpFn\")]\n    Component2(Component2),\n}\n\n// custom interpolation logic\npub struct MyCustomInterpFn;\nimpl<C> InterpFn<C> for MyCustomInterpFn {\n    fn lerp(start: C, _other: C, _t: f32) -> C {\n        start\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Protocol in Lightyear\nDESCRIPTION: Code that demonstrates how to define components for network replication in Lightyear, including registering components with proper synchronization modes and adding prediction/interpolation settings.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/setup.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use bevy::prelude::*;\n# use lightyear::prelude::{client::ComponentSyncMode, *};\n# use serde::{Deserialize, Serialize};\n# use std::ops::{Add, Mul};\n#\n/// A component that will identify which player the box belongs to\n#[derive(Component, Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct PlayerId(ClientId);\n\n/// A component that will store the position of the box. We could also directly use the `Transform` component.\n#[derive(Component, Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct PlayerPosition(Vec2);\n\n# impl Mul<f32> for &PlayerPosition {\n#     type Output = PlayerPosition;\n#\n#     fn mul(self, rhs: f32) -> Self::Output {\n#         PlayerPosition(self.0 * rhs)\n#     }\n# }\n#\n# impl Add for PlayerPosition {\n#     type Output = PlayerPosition;\n#     #[inline]\n#     fn add(self, rhs: PlayerPosition) -> PlayerPosition {\n#         PlayerPosition(self.0.add(rhs.0))\n#     }\n# }\n#\n/// A component that will store the color of the box, so that each player can have a different color.\n#[derive(Component, Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct PlayerColor(pub(crate) Color);\n\npub struct ProtocolPlugin;\n\nimpl Plugin for ProtocolPlugin{\n    fn build(&self, app: &mut App) {\n        app.register_component::<PlayerId>(ChannelDirection::ServerToClient)\n            .add_prediction(ComponentSyncMode::Once)\n            .add_interpolation(ComponentSyncMode::Once);\n\n        app.register_component::<PlayerPosition>(ChannelDirection::ServerToClient)\n            .add_prediction(ComponentSyncMode::Full)\n            .add_interpolation(ComponentSyncMode::Full)\n            .add_linear_interpolation_fn();\n\n        app.register_component::<PlayerColor>(ChannelDirection::ServerToClient)\n            .add_prediction(ComponentSyncMode::Once)\n            .add_interpolation(ComponentSyncMode::Once);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Authoritative Replication in Rust with Lightyear\nDESCRIPTION: Code showing how to set up client authoritative replication by handling connection events and spawning entities with the Replicate component. This allows client entities to be replicated to the server with specific network targeting options.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/client_replication.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_connection(\n    mut connection_event: EventReader<ConnectEvent>,\n    mut commands: Commands,\n) {\n    for event in connection_event.read() {\n        let local_client_id = event.client_id();\n        commands.spawn((\n            /* your other components here */\n            Replicate {\n                replication_target: NetworkTarget::All,\n                interpolation_target: NetworkTarget::AllExcept(vec![local_client_id]),\n                ..default()\n            },\n        ));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Complete Server with Network Settings in Rust\nDESCRIPTION: Demonstrates a complete server setup with Netcode protocol configuration, including server address, protocol ID, private key, and link conditioner. This example shows how to build a full server plugin with UDP socket transport and simulated network conditions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet server_addr = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), self.port);\n/// You need to provide the private key and protocol id when building the `NetcodeConfig`\nlet netcode_config = NetcodeConfig::default()\n    .with_protocol_id(PROTOCOL_ID)\n    .with_key(KEY);\n/// You can also add a link conditioner to simulate network conditions for packets received by the server\nlet link_conditioner = LinkConditionerConfig {\n    incoming_latency: Duration::from_millis(100),\n    incoming_jitter: Duration::from_millis(0),\n    incoming_loss: 0.00,\n};\nlet net_config = NetConfig::Netcode {\n    config: netcode_config,\n    io: IoConfig::from_transport(TransportConfig::UdpSocket(server_addr))\n        .with_conditioner(link_conditioner),\n};\nlet config = ServerConfig {\n    shared: shared_config().clone(),\n    /// Here we only provide a single net config, but you can provide multiple!\n    net: vec![net_config],\n    ..default()\n};\n/// Finally build the server plugin\nlet server_plugin = server::ServerPlugin::new(server_config);\n```\n\n----------------------------------------\n\nTITLE: Registering and Configuring Resource Replication in Rust\nDESCRIPTION: This code demonstrates how to define a replication channel, create a replicable resource, and register them properly in a Bevy application. It shows the basic setup required for resource replication.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/replicate.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Channel)]\npub struct Channel1;\n\n#[derive(Resource, Clone, Serialize, Deserialize)]\npub struct MyResource(pub f32);\n\npub fn plugin(app: &mut App) {\n    app.add_channel::<Channel1>(ChannelSettings {\n        mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n        ..Default::default()\n    });\n\n    app.register_resource::<MyResource>(ChannelDirection::ServerToClient);\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring Authority in Rust using Lightyear\nDESCRIPTION: Demonstrates how to transfer authority of an entity to a different peer using the EntityCommand system in Lightyear. This operation updates the HasAuthority and AuthorityPeer components on the server and notifies clients of the change.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/authority.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncommands.entity(entity).transfer_authority(new_owner)\n```\n\n----------------------------------------\n\nTITLE: Defining Message Protocol in Lightyear\nDESCRIPTION: Example showing how to define and register network messages in Lightyear using the message_protocol macro and registering them with appropriate channel directions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/setup.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// We don't really use messages in the example, but here is how you would define them.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Message1(pub usize);\n\n/// Again, you need to use the macro `message_protocol` to define a message protocol.\n#[message_protocol(protocol = \"MyProtocol\")]\npub enum Messages {\n    Message1(Message1),\n}\n\nimpl Plugin for ProtocolPlugin{\n  fn build(&self, app: &mut App) {\n    // Register messages\n    app.add_message::<Message1>(ChannelDirection::Bidirectional);\n    \n    // Register components\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Shared Movement Behavior in Lightyear\nDESCRIPTION: A shared function that defines how player movement is simulated based on inputs. This logic can be used on both client and server, supporting client prediction. It updates the player position based on direction inputs with a constant move speed.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn shared_movement_behaviour(mut position: Mut<PlayerPosition>, input: &Inputs) {\n    const MOVE_SPEED: f32 = 10.0;\n    match input {\n        Inputs::Direction(direction) => {\n            if direction.up {\n                position.y += MOVE_SPEED;\n            }\n            if direction.down {\n                position.y -= MOVE_SPEED;\n            }\n            if direction.left {\n                position.x -= MOVE_SPEED;\n            }\n            if direction.right {\n                position.x += MOVE_SPEED;\n            }\n        }\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning a Prespawned Entity in Rust using Lightyear\nDESCRIPTION: Demonstrates how to spawn a bullet as a prespawned entity on both client and server. The PreSpawnedPlayerObject component is added to enable prespawning functionality.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/prespawning.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncommands.spawn((BulletBundle::default(), PreSpawnedPlayerObject));\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Prediction for Player Entities in Rust\nDESCRIPTION: This code snippet demonstrates how to set up client prediction for player entities on the server side. It adds a Replicate component with a prediction target to enable client-side prediction for the controlling player.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/advanced_systems.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn handle_connections(\n    mut connections: EventReader<ConnectEvent>,\n    mut global: ResMut<Global>,\n    mut commands: Commands,\n) {\n    for connection in connections.read() {\n        let client_id = *connection.context();\n        \n        let replicate = Replicate {\n          prediction_target: NetworkTarget::Single(client_id),\n          ..default()\n        };\n        let entity = commands.spawn((PlayerBundle::new(client_id, Vec2::ZERO), replicate));\n        \n        global.client_id_to_entity_id.insert(client_id, entity.id());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buffering Client Input in Lightyear\nDESCRIPTION: System that reads user keypresses and converts them into network inputs. It uses the InputManager to send the inputs to the server, with the current tick from the TickManager. The system must run in the BufferInputs SystemSet in the FixedPreUpdate schedule.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn buffer_input(\n    /// You will need to specify the exact tick at which the input was emitted. You can use \n    /// the `TickManager` to retrieve the current tick\n    tick_manager: Res<TickManager>,\n    /// You will use the `InputManager` to send an input\n    mut input_manager: ResMut<InputManager<Inputs>>,\n    keypress: Res<ButtonInput<KeyCode>>,\n) {\n    let tick = tick_manager.tick();\n    let mut input = Inputs::None;\n    let mut direction = Direction {\n        up: false,\n        down: false,\n        left: false,\n        right: false,\n    };\n    if keypress.pressed(KeyCode::KeyW) || keypress.pressed(KeyCode::ArrowUp) {\n        direction.up = true;\n    }\n    if keypress.pressed(KeyCode::KeyS) || keypress.pressed(KeyCode::ArrowDown) {\n        direction.down = true;\n    }\n    if keypress.pressed(KeyCode::KeyA) || keypress.pressed(KeyCode::ArrowLeft) {\n        direction.left = true;\n    }\n    if keypress.pressed(KeyCode::KeyD) || keypress.pressed(KeyCode::ArrowRight) {\n        direction.right = true;\n    }\n    if !direction.is_none() {\n        input = Inputs::Direction(direction);\n    }\n    input_manager.add_input(input, tick)\n}\napp.add_systems(FixedPreUpdate, buffer_input.in_set(InputSystemSet::BufferInputs));\n```\n\n----------------------------------------\n\nTITLE: Direct Relevance Management System in Rust\nDESCRIPTION: System demonstrating how to directly update entity visibility for specific clients using the RelevanceManager resource.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interest_management.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\nuse lightyear::prelude::*;\nuse lightyear::prelude::server::*;\n\nfn my_system(\n    mut relevance_manager: ResMut<RelevanceManager>,\n) {\n    // you can update the relevance like so\n    relevance_manager.gain_relevance(ClientId::Netcode(1), Entity::PLACEHOLDER);\n    relevance_manager.lose_relevance(ClientId::Netcode(2), Entity::PLACEHOLDER);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Movement Prediction in Rust\nDESCRIPTION: This code snippet shows how to implement client-side movement prediction. It applies user inputs to the Predicted entity on the client, ensuring immediate responsiveness to player actions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/advanced_systems.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn player_movement(\n    mut position_query: Query<&mut PlayerPosition, With<Predicted>>,\n    mut input_reader: EventReader<InputEvent<Inputs>>,\n) {\n    for input in input_reader.read() {\n        if let Some(input) = input.input() {\n            for position in position_query.iter_mut() {\n                shared_movement_behaviour(position, input);\n            }\n        }\n    }\n}\napp.add_systems(FixedUpdate, movement);\n```\n\n----------------------------------------\n\nTITLE: Replicating and Managing Resources in Rust\nDESCRIPTION: This snippet shows how to replicate a resource to all clients and how to modify it. It demonstrates the commands for initiating resource replication and inserting the resource that will be automatically synced to clients.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/replicate.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ncommands.replicate_resource::<MyResource, Channel1>(NetworkTarget::All);\n// This will be replicated to all clients; any changes to the resource will also be replicated\ncommands.insert_resource(MyResource(1.0));\n```\n\n----------------------------------------\n\nTITLE: Enabling Visual Interpolation with Avian Physics in Rust\nDESCRIPTION: Shows how to set up visual interpolation for Position and Rotation components when using Avian Physics. Includes adding plugins and observer systems to handle component addition.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/visual_interpolation.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\napp.add_plugins(VisualInterpolationPlugin::<Position>::default());\napp.add_plugins(VisualInterpolationPlugin::<Rotation>::default());\n\napp.add_observer(add_visual_interpolation_components::<Position>);\napp.add_observer(add_visual_interpolation_components::<Rotation>);\n\n// ...\n\nfn add_visual_interpolation_components<T: Component>(\n    trigger: Trigger<OnAdd, T>,\n    q: Query<&RigidBody, With<T>>,\n    mut commands: Commands,\n) {\n    let Ok(rigid_body) = q.get(trigger.entity()) else {\n        return;\n    };\n    // No need to interp static bodies\n    if matches!(rigid_body, RigidBody::Static) {\n        return;\n    }\n    // triggering change detection necessary for SyncPlugin to work\n    commands\n        .entity(trigger.entity())\n        .insert(VisualInterpolateStatus::<T> {\n            trigger_change_detection: true,\n            ..default()\n        });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Channel in Lightyear\nDESCRIPTION: Creates a custom network channel by deriving the Channel trait on an empty struct and registering it with specific settings in a plugin. This channel controls message reliability, ordering, and priority.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/setup.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n/// A channel is basically a ZST (Zero Sized Type) with the `Channel` derive macro.\n#[derive(Channel)]\npub struct Channel1;\n\npub(crate) struct ProtocolPlugin;\n\nimpl Plugin for ProtocolPlugin {\n    fn build(&self, app: &mut App) {\n        // channels\n        app.add_channel::<Channel1>(ChannelSettings {\n          mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n          ..default()\n        });\n        // register messages, inputs, components\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Entity Interpolation for Non-Player Entities in Rust\nDESCRIPTION: This code snippet demonstrates how to set up entity interpolation for non-player entities. It adds a Replicate component with both prediction and interpolation targets to enable smooth movement for other players' entities.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/advanced_systems.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn handle_connections(\n    mut connections: EventReader<ConnectEvent>,\n    mut global: ResMut<Global>,\n    mut commands: Commands,\n) {\n    for connection in connections.read() {\n        let client_id = *connection.context();\n        \n        let replicate = Replicate {\n          prediction_target: NetworkTarget::Single(client_id),\n          interpolation_target: NetworkTarget::AllExceptSingle(client_id),\n          ..default()\n        };\n        let entity = commands.spawn((PlayerBundle::new(client_id, Vec2::ZERO), replicate));\n        \n        global.client_id_to_entity_id.insert(client_id, entity.id());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Replicate for Entity Interpolation in Rust\nDESCRIPTION: This snippet shows how to configure a replicated entity to be interpolated for all clients except one specific client. It uses the Replicate struct to set the interpolation target.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interpolation.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nReplicate {\n    interpolation_target: NetworkTarget::AllExcept(vec![id]),\n    ..default()\n},\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared Settings for Lightyear Networking in Rust\nDESCRIPTION: Defines shared configuration options that must be consistent between client and server, including send intervals, tick rate, and operational mode. This function is reused when creating both client and server configurations.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn shared_config(mode: Mode) -> SharedConfig {\n    SharedConfig {\n        /// How often the client will send packets to the server (by default it is every frame).\n        /// Currently, the client only works if it sends packets every frame, for proper input handling.\n        client_send_interval: Duration::default(),\n        /// How often the server will send packets to clients? You can reduce this to save bandwidth.\n        server_send_interval: Duration::from_millis(40),\n        /// The tick rate that will be used for the FixedUpdate schedule\n        tick: TickConfig {\n            tick_duration: Duration::from_secs_f64(1.0 / 64.0),\n        },\n        /// Here we make the `Mode` an argument so that we can run `lightyear` either in `Separate` mode (distinct client and server apps)\n        /// or in `HostServer` mode (the server also acts as a client).\n        mode,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring a Channel in Lightyear\nDESCRIPTION: This snippet demonstrates how to create a custom channel by deriving the Channel trait and adding it to a protocol with specific reliability, ordering, and direction settings. The example configures an OrderedReliable channel with bidirectional communication.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/reliability/channels.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Channel)]\nstruct MyChannel;\n\npub fn protocol() -> MyProtocol {\n    let mut p = MyProtocol::default();\n    p.add_channel::<MyChannel>(ChannelSettings {\n        mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n        direction: ChannelDirection::Bidirectional,\n    });\n    p\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EntityMap Trait in Rust\nDESCRIPTION: Definition of the EntityMap trait used for mapping entities from the server world to the client world.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/map_entities.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait MapEntities {\n    /// Map the entities inside the message or component from the remote World to the local World\n    fn map_entities(&mut self, entity_map: &EntityMap);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ServerConfig for Lightyear Server in Rust\nDESCRIPTION: Initializes the server configuration with shared settings and network configurations. This example demonstrates how to create a basic server plugin using the ServerConfig structure, supporting connections from multiple clients.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet server_config = server::ServerConfig {\n    shared: shared_config(Mode::Separate),\n    net: net_configs,\n    ..default()\n};\nlet server_plugin = server::ServerPlugin::new(server_config);\n```\n\n----------------------------------------\n\nTITLE: Handling Client Connections and Entity Replication in Lightyear\nDESCRIPTION: System that creates a player entity when a client connects to the server. It maintains a mapping from ClientId to Entity and adds the Replicate bundle to enable automatic entity replication to all clients.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// We will maintain a mapping from client id to entity id\n// so that we know which entity to despawn when the client disconnects\n#[derive(Resource)]\npub(crate) struct Global {\n    pub client_id_to_entity_id: HashMap<ClientId, Entity>,\n}\n\n/// Create a player entity whenever a client connects\npub(crate) fn handle_connections(\n    /// Here we listen for the `ConnectEvent` event\n    mut connections: EventReader<ConnectEvent>,\n    mut global: ResMut<Global>,\n    mut commands: Commands,\n) {\n    for connection in connections.read() {\n        /// on the server, the `context()` method returns the `ClientId` of the client that connected\n        let client_id = *connection.context();\n        \n        /// We add the `Replicate` bundle to start replicating the entity to clients\n        /// By default, the entity will be replicated to all clients\n        let replicate = Replicate::default(); \n        let entity = commands.spawn((PlayerBundle::new(client_id, Vec2::ZERO), replicate));\n        \n        // Add a mapping from client id to entity id\n        global.client_id_to_entity_id.insert(client_id, entity.id());\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Defining InterpFn Trait for Custom Interpolation in Rust\nDESCRIPTION: This snippet defines the InterpFn trait, which is used to implement custom interpolation functions for components in Lightyear. It specifies a single method 'lerp' for linear interpolation between two values.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interpolation.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait InterpFn<C> {\n    fn lerp(start: C, other: C, t: f32) -> C;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Server Connection in Lightyear with Bevy\nDESCRIPTION: Server initialization system that starts the server at application startup using Lightyear's ServerCommands. This system is added to Bevy's Startup schedule.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn init(mut commands: Commands) {\n    commands.start_server();\n}\napp.add_systems(Startup, init);\n```\n\n----------------------------------------\n\nTITLE: Building Complete NetConfig for Client in Rust\nDESCRIPTION: Combines authentication and IO configuration to create a complete Netcode network configuration for the client. This configuration defines how the client will securely connect to the server using the Netcode protocol with custom authentication parameters.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet net_config = NetConfig::Netcode {\n    auth,\n    io: io_config,\n    ..default()\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Predicted Entity Despawn in Rust with Lightyear\nDESCRIPTION: This code defines a trait extension for EntityCommands that enables predicted despawning of entities. The trait adds a prediction_despawn method that removes synced components while keeping the entity alive to enable potential rollback if the server doesn't confirm the despawn.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/prediction.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait PredictionCommandsExt {\n    fn prediction_despawn<P: Protocol>(&mut self);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Client Connection in Lightyear with Bevy\nDESCRIPTION: Client initialization system that connects to the server at application startup using Lightyear's ClientCommands. This system is added to Bevy's Startup schedule.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn init(mut commands: Commands) {\n    commands.connect_client();\n}\napp.add_systems(Startup, init);\n```\n\n----------------------------------------\n\nTITLE: Defining Network Visibility Modes in Rust\nDESCRIPTION: Enum definition for specifying how entity replication should be handled, with options for interest-based management or replicating to all clients.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interest_management.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Default)]\npub enum VisibilityMode {\n  /// We will replicate this entity to all clients that are present in the [`NetworkTarget`] AND use relevance on top of that\n  InterestManagement,\n  /// We will replicate this entity to all clients that are present in the [`NetworkTarget`]\n  #[default]\n  All\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Visual Interpolation Plugin in Rust\nDESCRIPTION: Shows how to add the VisualInterpolationPlugin to a Bevy application for a Position component. This is the first step in enabling visual interpolation for a component type.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/visual_interpolation.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\napp.add_plugins(VisualInterpolationPlugin::<Position>::default());\n```\n\n----------------------------------------\n\nTITLE: Creating ClientConfig with Default Settings in Rust\nDESCRIPTION: Demonstrates how to create a basic ClientConfig object using shared settings and network configuration. This example initializes a client plugin with the specified configuration, using the Separate mode for distinct client and server applications.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n  let client_config = client::ClientConfig {\n      shared: shared_config(Mode::Separate),\n      net: net_config,\n      ..default()\n  };\n  let client_plugin = client::ClientPlugin::new(client_config);\n```\n\n----------------------------------------\n\nTITLE: Defining Authority Owner Enum in Rust for Network Replication\nDESCRIPTION: Defines an enum for tracking entity ownership in a networked system. It specifies whether the server, a specific client, or no peer has authority over an entity, which determines which peer is responsible for simulating the entity.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/NOTES.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum AuthorityOwner {\n    Server,\n    Client(ClientId),\n    // the entity becomes orphaned and are not simulated\n    None,\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Implementation of MapEntities for SpawnedEntity in Rust\nDESCRIPTION: Example of a custom implementation of the MapEntities trait for a struct that needs entity mapping.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/map_entities.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Message)]\n#[message(custom_map)]\nstruct SpawnedEntity {\n    entity: Entity,\n}\n\nimpl MapEntities for SpawnedEntity {\n    fn map_entities(&mut self, entity_map: &EntityMap) {\n        self.entity.map_entities(entity_map);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Replicable Components in Rust\nDESCRIPTION: Shows how to register a component for replication with additional behaviors like prediction and interpolation.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/protocol.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\napp.register_component::<PlayerId>(ChannelDirection::ServerToClient)\n  .add_prediction::<PlayerId>(ComponentSyncMode::Once)\n  .add_interpolation::<PlayerId>(ComponentSyncMode::Once);\n```\n\n----------------------------------------\n\nTITLE: Defining Input Protocol in Lightyear\nDESCRIPTION: Code demonstrating how to define user input types for network replication, including creating an input enum and registering the InputPlugin to handle client-to-server input transmission.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/setup.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// The different directions that the player can move the box\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]\npub struct Direction {\n    pub(crate) up: bool,\n    pub(crate) down: bool,\n    pub(crate) left: bool,\n    pub(crate) right: bool,\n}\n\n/// The `InputProtocol` needs to be an enum of the various inputs that the client can send to the server.\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]\npub enum Inputs {\n    Direction(Direction),\n    Delete,\n    Spawn,\n    /// NOTE: we NEED to provide a None input so that the server can distinguish between lost input packets and 'None' inputs\n    None,\n}\n\nimpl Plugin for ProtocolPlugin{\n  fn build(&self, app: &mut App) {\n    // Register inputs\n    app.add_plugins(InputPlugin::<Inputs>::default());\n    // Register messages\n    ...\n    // Register components\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding VisualInterpolateState Component in Rust\nDESCRIPTION: Demonstrates how to add the VisualInterpolateState component to an entity to enable visual interpolation for its Position component. This is required for each entity that needs visual interpolation.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/visual_interpolation.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn spawn_entity(mut commands: Commands) {\n    commands.spawn().insert(VisualInterpolateState::<Position>::default());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Transport Traits for Network Communication in Rust\nDESCRIPTION: Defines the core transport traits for the Lightyear networking library: PacketSender for sending data to remote addresses and PacketReceiver for receiving packets. Both traits require Send and Sync to be thread-safe.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/transport/title.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait PacketSender: Send + Sync {\n    /// Send data on the socket to the remote address\n    fn send(&mut self, payload: &[u8], address: &SocketAddr) -> Result<()>;\n}\npub trait PacketReceiver: Send + Sync {\n    /// Receive a packet from the socket. Returns the data read and the origin.\n    ///\n    /// Returns Ok(None) if no data is available\n    fn recv(&mut self) -> Result<Option<(&mut [u8], SocketAddr)>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Channels in Rust\nDESCRIPTION: Demonstrates how to add and configure a network channel with specific reliability and ordering settings.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/protocol.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\napp.add_channel::<Channel1>(ChannelSettings {\n    mode: ChannelMode::OrderedReliable(ReliableSettings::default()),\n    ..default()\n});\n```\n\n----------------------------------------\n\nTITLE: Room-Based Interest Management System in Rust\nDESCRIPTION: System showing how to manage entity visibility using a room-based approach, where entities and clients can join rooms to determine replication scope.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/interest_management.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\nuse lightyear::prelude::*;\nuse lightyear::prelude::server::*;\n\nfn room_system(mut manager: ResMut<RoomManager>) {\n   // the entity will now be visible to the client\n   manager.add_client(ClientId::Netcode(0), RoomId(0));\n   manager.add_entity(Entity::PLACEHOLDER, RoomId(0));\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Reliability Layer Features in Markdown\nDESCRIPTION: This snippet outlines the key features of the reliability layer, including reliability, ordering, and channels. It also mentions a similar implementation by Glenn Fiedler.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/reliability/title.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Reliability\n\nIn this layer we add some mechanisms to be able to send and receive messages reliably or in a given order.\n\nIt is similar to the [reliable](https://github.com/networkprotocol/reliable) layer created by Glenn Fiedler on top of his netcode.io code.\n\nThis layer introduces:\n- reliability: make sure a packets is received by the remote peer\n- ordering: make sure packets are received in the same order they were sent\n- channels: allow to send packets on different channels, which can have different reliability and ordering guarantees\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Link Conditions for Simulation in Rust\nDESCRIPTION: Sets up a link conditioner to simulate network conditions such as latency, jitter, and packet loss. This example creates an IoConfig with UDP transport and applies the conditioner to simulate network behavior during development and testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// You can add a link conditioner to simulate network conditions\nlet link_conditioner = LinkConditionerConfig {\n    incoming_latency: Duration::from_millis(100),\n    incoming_jitter: Duration::from_millis(0),\n    incoming_loss: 0.00,\n};\n/// Here we use the `UdpSocket` transport layer, with the link conditioner\nlet io_config = IoConfig::from_transport(TransportConfig::UdpSocket(addr))\n    .with_conditioner(link_conditioner);\n```\n\n----------------------------------------\n\nTITLE: Defining Entity-Referencing Structs in Rust\nDESCRIPTION: Example of structs that contain references to entities, which need special handling for replication between server and client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/map_entities.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Message)]\nstruct SpawnedEntity {\n    entity: Entity,\n}\n\n#[derive(Component, Message)]\nstruct Parent {\n    entity: Entity,\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Player Entities with Bevy Gizmos in Lightyear\nDESCRIPTION: Visual rendering system that draws boxes to represent player entities. It queries for PlayerPosition and PlayerColor components and uses Bevy's Gizmos to draw colored rectangles at the player positions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/basic_systems.md#2025-04-23_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn draw_boxes(\n    mut gizmos: Gizmos,\n    players: Query<(&PlayerPosition, &PlayerColor)>,\n) {\n    for (position, color) in &players {\n        gizmos.rect(\n            Vec3::new(position.x, position.y, 0.0),\n            Quat::IDENTITY,\n            Vec2::ONE * 50.0,\n            color.0,\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SyncPlugin with FixedUpdate in Rust\nDESCRIPTION: Demonstrates how to properly configure the Avian SyncPlugin when using FixedUpdate for physics. This ensures that visual interpolation changes are properly synced to transforms.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/visual_interpolation.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Run physics in FixedUpdate, but run the SyncPlugin in PostUpdate\napp\n  .add_plugins(\n    PhysicsPlugins::new(FixedUpdate)\n      .build()\n      .disable::<SyncPlugin>(),\n  )\n  .add_plugins(SyncPlugin::new(PostUpdate));\n```\n\n----------------------------------------\n\nTITLE: Referencing ReplicationGroup in Rust\nDESCRIPTION: This code snippet demonstrates how to reference the ReplicationGroup struct from the Lightyear crate. It's used to group entities whose actions and updates are sent as a single network message, ensuring consistency across replicated entities.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/replication_logic.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n[`ReplicationGroup`](crate::prelude::ReplicationGroup)\n```\n\n----------------------------------------\n\nTITLE: Running a basic Lightyear training example\nDESCRIPTION: Python script demonstrating how to initialize and run a training experiment with Lightyear, showcasing the main components and workflow.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/server.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Import modules\nfrom lightyear.train import get_trainer\nfrom lightyear.utils.config import get_config\n\nif __name__ == \"__main__\":\n    # Get config\n    config = get_config()\n    # Get trainer\n    trainer = get_trainer(config)\n    # Train\n    trainer.train()\n```\n\n----------------------------------------\n\nTITLE: Serialization Buffer Management in Rust\nDESCRIPTION: Demonstrates the use of Buffer for message serialization/deserialization to optimize memory allocations. ReadBuffer is created from raw byte slices by copying data into the buffer.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/transport/serialization.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Example implied from documentation:\nlet packet: &[u8] = // incoming packet data\nlet read_buffer = ReadBuffer::new(packet); // copies bytes into buffer\n```\n\n----------------------------------------\n\nTITLE: Basic Logging in Python with Lightyear\nDESCRIPTION: Example of how to set up basic logging with Lightyear in a Python application, including initializing the client, logging model outputs, and setting up attributes for filtering and analyzing logs.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/client/title.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport lightyear as lr\n\n# Initialize the client\nlr.init()\n\n# Log model outputs\ndefault_attributes = {\"user_id\": \"user-123\"}\n\nwith lr.Track(model_name=\"gpt-4\", inputs=\"What is ML?\", attributes=default_attributes) as span:\n    span.log_output(\"Machine Learning is...\")\n```\n\n----------------------------------------\n\nTITLE: Registering Network Messages in Rust\nDESCRIPTION: Illustrates how to register a message type with the MessageRegistry, specifying the direction it can travel.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/protocol.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\napp.add_message::<Message1>(ChannelDirection::Bidirectional);\n```\n\n----------------------------------------\n\nTITLE: Pre-spawned Predicted Entities Flow Diagram\nDESCRIPTION: Sequence diagram showing the replication flow for pre-spawned predicted entities, illustrating how a client can spawn a predicted entity locally and have it properly synchronized with the server and other clients.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/client_replication.md#2025-04-23_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: Client PrePredicted\n---\nsequenceDiagram\n    participant Client1\n    participant Server\n    participant Client2\n    participant Client3\n    Client1->>Server: Connect()\n    Server->>Client1: Connected\n    Client1->>Client1: ConnectEvent\n    Client1->>Client1: SpawnPredicted(PlayerID: 1)\n    Client1->>Server: Replicate(PlayerID: 1)\n    Server-->>Client1: Replicate(PlayerID: 1)\n    Client1->>Client1: SpawnConfirmed(PlayerID: 1)\n    Server-->>Client2: Replicate(PlayerID: 1)\n    Client2->>Client2: SpawnConfirmed(PlayerID: 1)\n    Server-->>Client3: Replicate(PlayerID: 1)\n    Client3->>Client3: SpawnConfirmed(PlayerID: 1)\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Server in Headless Mode\nDESCRIPTION: Command to start the Lightyear server process in headless mode with the interest management example.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/guides/remote_server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --example interest_management -- server --headless\n```\n\n----------------------------------------\n\nTITLE: Setting Up Authentication for Netcode Connection in Rust\nDESCRIPTION: Creates a manual authentication configuration for Netcode protocol. This code defines the server address, client ID, private key, and protocol ID needed to establish a secure connection between client and server using the Netcode standard.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/tutorial/build_client_server.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet server_addr = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), server_port);\nlet auth = Authentication::Manual {\n    // server's IP address\n    server_addr,\n    // ID to uniquely identify the client\n    client_id: client_id,\n    // private key shared between the client and server\n    private_key: KEY,\n    // PROTOCOL_ID identifies the version of the protocol\n    protocol_id: PROTOCOL_ID,\n};\n```\n\n----------------------------------------\n\nTITLE: Client Authoritative Replication Flow Diagram\nDESCRIPTION: Sequence diagram illustrating the client authoritative replication flow between multiple clients and the server. Shows the process from connection to entity replication across the network.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/client_replication.md#2025-04-23_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: Client Authoritative\n---\nsequenceDiagram\n    participant Client1\n    participant Server\n    participant Client2\n    participant Client3\n    Client1->>Server: Connect()\n    Server->>Client1: Connected\n    Client1->>Client1: ConnectEvent\n    Client1->>Client1: SpawnPredicted(PlayerID: 1)\n    Client1->>Server: Replicate(PlayerID: 1)\n    Server-->>Client2: Replicate(PlayerID: 1)\n    Client2->>Client2: SpawnConfirmed(PlayerID: 1)\n    Server-->>Client3: Replicate(PlayerID: 1)\n    Client3->>Client3: SpawnConfirmed(PlayerID: 1)\n```\n\n----------------------------------------\n\nTITLE: Default Implementation of MapEntities Trait in Rust\nDESCRIPTION: The default implementation of the MapEntities trait, which doesn't perform any mapping.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/map_entities.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait MapEntities {\n    fn map_entities(&mut self, entity_map: &EntityMap) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Code Reference in Markdown\nDESCRIPTION: References to key code structures including NetClient, NetServer, NetcodeClient, NetcodeServer traits and structs used for connection management in the Lightyear library.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/connection/title.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`lightyear`\n`NetClient`\n`NetServer`\n`ConnectToken`\n`Authentication::Manual`\n`protocol_id`\n`private_key`\n`World`\n```\n\n----------------------------------------\n\nTITLE: Setting Up WASM with WebTransport\nDESCRIPTION: Commands for testing the example in WebAssembly using WebTransport, which requires generating SSL certificates and running both server and WASM client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -- server\n```\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Full SystemSet Order Diagram in Mermaid\nDESCRIPTION: A comprehensive flowchart detailing the complete system order in Lightyear, showing all stages of processing including prediction, interpolation, rollback, and packet handling with their respective flush operations.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/system_order.md#2025-04-23_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: SystemSet order\n---\nstateDiagram-v2\n\n   classDef flush font-style:italic;\n   \n   SpawnPredictionHistory : SpawnHistory\n   SpawnInterpolationHistory : SpawnHistory\n   SpawnPredictionHistoryFlush : Flush\n   SpawnInterpolationHistoryFlush : Flush\n   SpawnPredictionFlush : Flush\n   SpawnInterpolationFlush: Flush\n   CheckRollbackFlush: Flush\n   DespawnFlush: Flush\n   ReceiveFlush: Flush\n   FixedUpdatePrediction: Prediction\n   \n   PreUpdate --> FixedUpdate\n   FixedUpdate --> PostUpdate \n   state PreUpdate {\n      Receive --> ReceiveFlush\n      ReceiveFlush --> Prediction\n      ReceiveFlush --> Interpolation\n   }\n   state Prediction {\n      SpawnPrediction --> SpawnPredictionFlush\n      SpawnPredictionFlush --> SpawnPredictionHistory\n      SpawnPredictionHistory --> SpawnPredictionHistoryFlush\n      SpawnPredictionHistoryFlush --> CheckRollback\n      CheckRollback --> CheckRollbackFlush\n      CheckRollbackFlush --> Rollback\n   }\n   state Interpolation {\n       SpawnInterpolation --> SpawnInterpolationFlush\n       SpawnInterpolationFlush --> SpawnInterpolationHistory\n       SpawnInterpolationHistory --> SpawnInterpolationHistoryFlush\n       SpawnInterpolationHistoryFlush --> Despawn\n       Despawn --> DespawnFlush\n       DespawnFlush --> Interpolate\n   }\n   state FixedUpdate {\n      TickUpdate --> BufferInputs\n      BufferInputs --> WriteInputEvent\n      WriteInputEvent --> Main\n      Main --> ClearInputEvent\n      Main --> FixedUpdatePrediction\n   }\n   state FixedUpdatePrediction {\n      PredictionEntityDespawn --> PredictionEntityDespawnFlush\n      PredictionEntityDespawnFlush --> UpdatePredictionHistory\n      UpdatePredictionHistory --> IncrementRollbackTick : if rollback\n   }\n   state PostUpdate {\n        state Send {\n            SendEntityUpdates --> SendComponentUpdates\n            SendComponentUpdates --> SendInputMessage\n            SendInputMessage --> SendPackets\n        }\n        --\n        Sync\n   }\n```\n\n----------------------------------------\n\nTITLE: Configuring Lightyear with pyproject.toml\nDESCRIPTION: Example configuration for Lightyear in a pyproject.toml file, which includes selecting an actor, observer provider, and environment wrapper.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/server.md#2025-04-23_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.lightyear.train]\nactor = \"PPO\"\nobserver_provider = \"WorldModelObserverProvider\"\nenv_wrapper = \"EnvWrapper\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebTransport for WASM Testing\nDESCRIPTION: Commands to generate SSL certificates and run the server and WebAssembly client for WebTransport testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- server\n```\n\nLANGUAGE: shell\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Simplified SystemSet Order Diagram in Mermaid\nDESCRIPTION: A simplified flowchart showing the main system order in Lightyear, illustrating the relationship between PreUpdate, FixedUpdate, and PostUpdate stages including packet receiving, prediction, interpolation, and sending.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/system_order.md#2025-04-23_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: Simplified SystemSet order\n---\nstateDiagram-v2\n\n   classDef flush font-style:italic;\n   \n   ReceiveFlush: Flush\n\n   \n   PreUpdate --> FixedUpdate\n   FixedUpdate --> PostUpdate \n   state PreUpdate {\n      Receive --> ReceiveFlush\n      ReceiveFlush --> Prediction\n      ReceiveFlush --> Interpolation\n   }\n   state FixedUpdate {\n      TickUpdate --> BufferInputs\n      BufferInputs --> Main\n   }\n   state PostUpdate {\n       Send\n   }\n```\n\n----------------------------------------\n\nTITLE: Executing Server Binary Based on Environment Variable in Bash\nDESCRIPTION: A Bash script that serves as the Docker entrypoint, executing the appropriate server binary based on the EXAMPLE_NAME environment variable. This script is not used in the final implementation due to the use of a minimal Docker image without a shell.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/launcher/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\nexec /apps/$EXAMPLE_NAME/$EXAMPLE_NAME server\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebTransport for WASM Testing\nDESCRIPTION: Commands for testing the example in WebAssembly using WebTransport, including generating SSL certificates and running the server and WASM client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\ncargo run -- server\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Registering Input Plugin in Rust\nDESCRIPTION: Shows how to add the InputPlugin to handle user inputs defined in the Protocol.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/protocol.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\napp.add_plugins(InputPlugin::<I>::default());\n```\n\n----------------------------------------\n\nTITLE: Running Server and Client Commands for Avian3D Demo\nDESCRIPTION: Commands for running the server and client components in various configurations, including standalone mode, separate mode, headless server, and host-server mode.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/avian_3d_character/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\ncargo run client -c 1\ncargo run client -c 2\ncargo run\ncargo run separate\ncargo run --no-default-features --features=server\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebTransport for WASM Testing\nDESCRIPTION: Commands to generate SSL certificates and run a WebTransport-enabled server and WASM client for web testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- server\n```\n\nLANGUAGE: shell\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Registering Leafwing Input Plugin in Rust\nDESCRIPTION: Demonstrates how to add the LeafwingInputPlugin when the leafwing feature is enabled.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/replication/protocol.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\napp.add_plugins(LeafwingInputPlugin::<I>::default());\n```\n\n----------------------------------------\n\nTITLE: Configuring Lightyear Project with Poetry in TOML\nDESCRIPTION: Defines the project configuration using Poetry, including metadata, dependencies, and development tools. It specifies Python version requirements, project dependencies, and development dependencies like pytest and mypy.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/title.md#2025-04-23_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[tool.poetry]\nname = \"lightyear\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Cdric Bournhonesque <cedric@bournhonesque.eu>\"]\nreadme = \"README.md\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.3.1\"\nmypy = \"^1.3.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n```\n\n----------------------------------------\n\nTITLE: Running Server and Client Configurations\nDESCRIPTION: Command line instructions for running different server and client configurations, including GUI and headless modes.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/avian_physics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\ncargo run client -c 1\ncargo run client -c 2\ncargo run\ncargo run separate\ncargo run --no-default-features --features=server\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running WASM Client with WebTransport for Avian3D Demo\nDESCRIPTION: Commands for setting up and running the WASM client with WebTransport support, including generating SSL certificates and starting both server and WASM client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/avian_3d_character/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\ncargo run -- server\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Configuring Lightyear Project in TOML\nDESCRIPTION: Defines the project metadata, dependencies, and development tools for the Lightyear project using pyproject.toml. It includes package information, required Python version, and various development dependencies.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/advanced_replication/component_sync_mode.md#2025-04-23_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[project]\nname = \"lightyear\"\nversion = \"0.1.0\"\ndescription = \"A lightweight year tracker\"\nauthors = [{name = \"Cdric Bournhonesque\", email = \"cedric@bournhonesque.com\"}]\nreadme = \"README.md\"\nrequires-python = \">=3.9\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest\",\n    \"pytest-cov\",\n    \"mypy\",\n    \"ruff\",\n    \"black\",\n]\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.pytest.ini_options]\naddopts = [\n    \"--import-mode=importlib\",\n]\n\n[tool.mypy]\nwarn_unused_configs = true\ndisallow_any_generics = true\ndisallow_subclassing_any = true\ndisallow_untyped_calls = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\ndisallow_untyped_decorators = true\nno_implicit_optional = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_return_any = true\nno_implicit_reexport = true\nstrict_equality = true\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py39\"\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"C\",  # flake8-comprehensions\n    \"B\",  # flake8-bugbear\n]\nignore = [\n    \"E501\",  # line too long, handled by black\n    \"B008\",  # do not perform function calls in argument defaults\n    \"C901\",  # too complex\n]\n\n[tool.ruff.per-file-ignores]\n\"__init__.py\" = [\"F401\"]\n\n[tool.ruff.isort]\nknown-first-party = [\"lightyear\"]\n\n[tool.black]\nline-length = 88\ntarget-version = ['py39']\ninclude = '\\.pyi?$'\nextend-exclude = '''\n/(\\n  # directories\n  \\.eggs\n  | \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | build\n  | dist\n)/\n'''\n\n```\n\n----------------------------------------\n\nTITLE: Running in HostServer Mode in Rust\nDESCRIPTION: Command to run the client and server in 'HostServer' mode, where the server is also a client in a single Bevy App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: WebTransport WASM Setup Commands\nDESCRIPTION: Commands for setting up and running the WebTransport WASM example, including certificate generation and server startup.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/avian_physics/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\ncargo run -- server\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Running Server Without GUI in Rust\nDESCRIPTION: Command to run the server without a graphical user interface, using specific features.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server Separately in Rust\nDESCRIPTION: Command to run the client and server in two separate Bevy Apps using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Server and Client Commands\nDESCRIPTION: Terminal commands for launching the Lightyear application in either server or client mode using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_setup/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- server\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --client\n```\n\n----------------------------------------\n\nTITLE: Running Headless Server\nDESCRIPTION: Command to run the server without a graphical interface by disabling default features and enabling only the server feature.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server Separately in Rust\nDESCRIPTION: Commands to run the client and server in two separate Bevy Apps using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in Separate Bevy Apps\nDESCRIPTION: Command to run the client and server in two separate Bevy application instances.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Running Server in Headless Mode\nDESCRIPTION: Command to run the server without a graphical user interface by disabling default features and only enabling the server feature.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in Separate Bevy Apps\nDESCRIPTION: Commands to run the client and server in two separate Bevy applications, which is useful for development and testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Running Server in Host Mode\nDESCRIPTION: Command to run the server in \"HostServer\" mode where the server also acts as a client within a single Bevy App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running Server Without GUI in Bash\nDESCRIPTION: Command to run the server without a graphical user interface by disabling default features and enabling only the server feature.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Starting Server for WASM Testing\nDESCRIPTION: Command to start the server for WASM testing using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -- server\n```\n\n----------------------------------------\n\nTITLE: Running Headless Server\nDESCRIPTION: Command to run the server without GUI by disabling default features\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/fps/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Server with GUI in Rust\nDESCRIPTION: Command to run the server with a graphical user interface.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Dedicated Server in Rust\nDESCRIPTION: Command to run the dedicated server with the 'server' feature enabled.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/lobby/README.md#2025-04-23_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client Instances\nDESCRIPTION: Commands to run multiple client instances with different client IDs\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/fps/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 1\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running the Server with GUI\nDESCRIPTION: Command to run the server instance with graphical user interface enabled.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Server in Headless Mode\nDESCRIPTION: Command to run the server without a graphical user interface using feature flags.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running in HostServer Mode in Rust\nDESCRIPTION: Command to run the client and server in \"HostServer\" mode, where the server is also a client in a single App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running Server with GUI\nDESCRIPTION: Command to run the server component with graphical user interface enabled\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/fps/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Server with GUI\nDESCRIPTION: Command to run the server with a graphical user interface, which will allow visualization of the authority transfer.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Server without GUI in Rust\nDESCRIPTION: Command to run the server without a graphical user interface, using specific features.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID in Rust\nDESCRIPTION: Commands to run clients with different IDs.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 1\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running the Server with GUI\nDESCRIPTION: Command to run the server with a graphical user interface, allowing visualization of the server-side gameplay.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in HostServer Mode in Rust\nDESCRIPTION: Command to run the client and server in 'HostServer' mode, where the server is also a client in a single App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID in Rust\nDESCRIPTION: Commands to run clients with specific IDs using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Server with GUI in Rust\nDESCRIPTION: Command to run the server with a graphical user interface using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Running Server Without GUI in Rust\nDESCRIPTION: Command to run the server without a graphical user interface using Cargo, specifying features.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in Separate Bevy Apps\nDESCRIPTION: Command to run the client and server in two separate Bevy applications.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Running Server with GUI in Rust\nDESCRIPTION: Command to run the server with a graphical user interface using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Starting Server for WebTransport Testing in Rust\nDESCRIPTION: Command to start the server for WebTransport testing using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- server\n```\n\n----------------------------------------\n\nTITLE: Running in Host-Server Mode in Bash\nDESCRIPTION: Command to run in host-server mode where the server also acts as a client within a single Bevy App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Server with GUI\nDESCRIPTION: Command to run the server component with a graphical user interface.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Starting WebAssembly Client for WebTransport Testing\nDESCRIPTION: Command to start the WebAssembly client for WebTransport testing using trunk, with specific Rust flags and features.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Running in Host-Server Mode\nDESCRIPTION: Command to run the client and server in a single Bevy App instance where the server also acts as a client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Server with GUI in Bash\nDESCRIPTION: Command to run the server component with a graphical user interface.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run server\n```\n\n----------------------------------------\n\nTITLE: Generating SSL Certificates for WebTransport Testing\nDESCRIPTION: Shell command to generate temporary SSL certificates for testing WebTransport in WebAssembly.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\n----------------------------------------\n\nTITLE: Running in Host-Server Mode\nDESCRIPTION: Command to run in Host-Server mode where the server also acts as a client, all within a single Bevy App.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Generating SSL Certificates for WebTransport in Bash\nDESCRIPTION: Command to generate temporary SSL certificates for testing WebTransport in WASM, valid for 2 weeks.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear in HostServer Mode\nDESCRIPTION: Command to run the server and client in a single Bevy App where the server also acts as a client.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run host-server\n```\n\n----------------------------------------\n\nTITLE: Running WebTransport WASM Client\nDESCRIPTION: Commands for setting up and running the WebAssembly client with WebTransport support\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/fps/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\ncargo run -- server\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk serve --features=client\n```\n\n----------------------------------------\n\nTITLE: Generating SSL Certificates for WebTransport\nDESCRIPTION: Command to generate temporary SSL certificates for testing the example in WASM using WebTransport.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Client and Server in Separate Bevy Apps\nDESCRIPTION: Command to run the client and server as separate Bevy applications.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Starting Server for WebTransport Testing in Bash\nDESCRIPTION: Command to start the server for WebTransport testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -- server\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID in Rust\nDESCRIPTION: Commands to run clients with specific IDs using Cargo.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/simple_box/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Server in Headless Mode\nDESCRIPTION: Command to run the server without a graphical user interface, useful for dedicated server deployments or testing.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --no-default-features --features=server\n```\n\n----------------------------------------\n\nTITLE: Installing Lightyear via pip\nDESCRIPTION: Command for installing the Lightyear package using pip, Python's package installer.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install lightyear\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID\nDESCRIPTION: Commands to run clients with specific IDs, allowing multiple clients to connect to the server with distinct identities.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/distributed_authority/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in Separate Bevy Apps\nDESCRIPTION: Command to run both client and server in separate Bevy applications within the same process.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Installing Lightyear via pip\nDESCRIPTION: Command to install the Lightyear package using pip, the Python package manager.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/client/title.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install lightyear-ai\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID\nDESCRIPTION: Commands to run client instances with specific client IDs, allowing multiple clients to connect to the server.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/spaceships/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Client with ID Parameter in Bash\nDESCRIPTION: Commands to run client instances with different client IDs.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Installing Lightyear from source\nDESCRIPTION: Commands for cloning the Lightyear repository from GitHub and installing it in development mode.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/concepts/bevy_integration/server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/cbournhonesque/lightyear.git\ncd lightyear\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Running Lightyear Client with Specific ID\nDESCRIPTION: Commands to run client instances with specified client IDs.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/priority/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 1\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Separate Client and Server in Bash\nDESCRIPTION: Command to run the client and server in two separate Bevy Apps.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook-mermaid CSS/JS\nDESCRIPTION: Command to install mdbook-mermaid's CSS and JavaScript files into the book's directory.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmdbook-mermaid install book\n```\n\n----------------------------------------\n\nTITLE: Running WASM Client with Trunk in Rust\nDESCRIPTION: Command to start the WASM client using Trunk, with specific Rust flags and features for WebTransport support.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Running Client and Server in Separate Mode in Bash\nDESCRIPTION: Alternative command for running client and server in separate mode.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run separate\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook and related tools using Nix\nDESCRIPTION: Command to install mdbook, mdbook-mermaid, and mdbook-linkcheck using Nix package manager.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnix-shell -p mdbook mdbook-mermaid mdbook-linkcheck\n```\n\n----------------------------------------\n\nTITLE: Starting WASM Client with Trunk\nDESCRIPTION: Command to start the WASM client using Trunk, with specific Rust flags and features.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/replication_groups/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Starting WASM Client with Trunk in Bash\nDESCRIPTION: Command to start the WASM client using Trunk with specific Rust flags for WebTransport compatibility.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/auth/README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"' trunk server --features=client\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook and related tools using Cargo\nDESCRIPTION: Command to install mdbook, mdbook-mermaid, and mdbook-linkcheck using Cargo package manager.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo install mdbook mdbook-mermaid mdbook-linkcheck\n```\n\n----------------------------------------\n\nTITLE: Generating SSL Certificates for WebTransport in Rust\nDESCRIPTION: Command to generate temporary SSL certificates for testing the example in WASM using WebTransport.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/delta_compression/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(git rev-parse --show-toplevel)\" && sh examples/certificates/generate.sh\n```\n\n----------------------------------------\n\nTITLE: Launching Clients with Custom IDs in Rust\nDESCRIPTION: Commands to launch client instances with specific client IDs using command-line arguments.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/lobby/README.md#2025-04-23_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --features=client -- -c 1\n```\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --features=client -- -c 2\n```\n\n----------------------------------------\n\nTITLE: Running Client with Specific ID\nDESCRIPTION: Commands to run client instances with specific client IDs for testing client-to-client interactions.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/examples/client_replication/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run client -c 1\ncargo run client -c 2\n```\n\n----------------------------------------\n\nTITLE: Connecting Lightyear Client to Remote Server\nDESCRIPTION: Command to run a Lightyear client and connect to a remote server using specific IP address and port configurations.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/src/guides/remote_server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --example interest_management -- client -c 1 --server-addr=S-IP --server-port=S-P\n```\n\n----------------------------------------\n\nTITLE: Serving the book locally\nDESCRIPTION: Command to serve the book locally for development and preview purposes.\nSOURCE: https://github.com/cbournhonesque/lightyear/blob/main/book/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nmdbook serve book\n```"
  }
]