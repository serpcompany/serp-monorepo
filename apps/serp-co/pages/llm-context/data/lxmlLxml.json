[
  {
    "owner": "lxml",
    "repo": "lxml",
    "content": "TITLE: Parsing Large XML Files with Selective Tag Processing\nDESCRIPTION: Shows how to efficiently parse large XML files by filtering for specific tags using the tag parameter in iterparse(), and clearing memory after processing each element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n>>> xml_file = BytesIO(b'''\\\n... <root>\n...   <a><b>ABC</b><c>abc</c></a>\n...   <a><b>MORE DATA</b><c>more data</c></a>\n...   <a><b>XYZ</b><c>xyz</c></a>\n... </root>''')\n\n>>> for _, element in etree.iterparse(xml_file, tag='a'):\n...     print('%s -- %s' % (element.findtext('b'), element[1].text))\n...     element.clear(keep_tail=True)\nABC -- abc\nMORE DATA -- more data\nXYZ -- xyz\n```\n\n----------------------------------------\n\nTITLE: Working with Element Text Content in lxml.etree\nDESCRIPTION: Shows how to set and access text content within XML elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.Element(\"root\")\nroot.text = \"TEXT\"\n\nprint(root.text)\n\netree.tostring(root)\n```\n\n----------------------------------------\n\nTITLE: Working with Element Attributes in lxml.etree\nDESCRIPTION: Shows how to create elements with attributes and access them using dictionary-like operations.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.Element(\"root\", interesting=\"totally\")\netree.tostring(root)\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(root.get(\"interesting\"))\n\nprint(root.get(\"hello\"))\nroot.set(\"hello\", \"Huhu\")\nprint(root.get(\"hello\"))\n\netree.tostring(root)\n\nsorted(root.keys())\n\nfor name, value in sorted(root.items()):\n    print('%s = %r' % (name, value))\n```\n\n----------------------------------------\n\nTITLE: Importing lxml.etree Module in Python\nDESCRIPTION: Basic code example showing how to import the lxml.etree module for XML processing in Python. This is the standard way to access lxml's main functionality.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml import etree\n```\n\n----------------------------------------\n\nTITLE: Iterating Through XML Element Trees\nDESCRIPTION: Demonstrates how to use the iter() method to traverse an XML tree in document order, yielding elements as they would appear in serialized XML.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.Element(\"root\")\n>>> etree.SubElement(root, \"child\").text = \"Child 1\"\n>>> etree.SubElement(root, \"child\").text = \"Child 2\"\n>>> etree.SubElement(root, \"another\").text = \"Child 3\"\n\n>>> prettyprint(root)\n<root>\n  <child>Child 1</child>\n  <child>Child 2</child>\n  <another>Child 3</another>\n</root>\n\n>>> for element in root.iter():\n...     print(f\"{element.tag} - {element.text}\")\nroot - None\nchild - Child 1\nchild - Child 2\nanother - Child 3\n```\n\n----------------------------------------\n\nTITLE: Importing lxml.etree in Python\nDESCRIPTION: Shows how to import lxml.etree module, including a fallback pattern to use the standard library's ElementTree when lxml is not available.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml import etree\n```\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from lxml import etree\n    print(\"running with lxml.etree\")\nexcept ImportError:\n    import xml.etree.ElementTree as etree\n    print(\"running with Python's xml.etree.ElementTree\")\n```\n\n----------------------------------------\n\nTITLE: Basic XML Serialization with tostring()\nDESCRIPTION: Shows basic XML serialization using the tostring() function, including options for adding XML declarations, setting encodings, and enabling pretty printing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML('<root><a><b/></a></root>')\n\n>>> etree.tostring(root)\nb'<root><a><b/></a></root>'\n\n>>> xml_string = etree.tostring(root, xml_declaration=True)\n>>> print(xml_string.decode(), end='')\n<?xml version='1.0' encoding='ASCII'?>\n<root><a><b/></a></root>\n\n>>> latin1_bytesstring = etree.tostring(root, encoding='iso8859-1')\n>>> print(latin1_bytesstring.decode('iso8859-1'), end='')\n<?xml version='1.0' encoding='iso8859-1'?>\n<root><a><b/></a></root>\n\n>>> print(etree.tostring(root, pretty_print=True).decode(), end='')\n<root>\n  <a>\n    <b/>\n  </a>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Adding Child Elements with append() and SubElement in lxml.etree\nDESCRIPTION: Shows two methods for adding child elements to a parent element, using append() and the more efficient SubElement factory.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nroot.append( etree.Element(\"child1\") )\n\nchild2 = etree.SubElement(root, \"child2\")\nchild3 = etree.SubElement(root, \"child3\")\n```\n\n----------------------------------------\n\nTITLE: Using iterparse() to Process XML Elements and Clear Memory\nDESCRIPTION: Demonstrates how to use etree.iterparse() to process XML data incrementally, accessing elements as they are parsed and clearing memory with element.clear() to avoid memory build-up.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n>>> some_file_like = BytesIO(\n...     b\"<root><a><b>data</b></a><a><b/></a></root>\")\n\n>>> for event, element in etree.iterparse(some_file_like):\n...     if element.tag == 'b':\n...         print(element.text)\n...     elif element.tag == 'a':\n...         print(\"** cleaning up the subtree\")\n...         element.clear(keep_tail=True)\ndata\n** cleaning up the subtree\nNone\n** cleaning up the subtree\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tree Structure and Navigation in lxml.etree\nDESCRIPTION: Creates an XML tree structure and demonstrates navigation methods like getparent(), getnext(), and getprevious(). Also shows how to retrieve the root of a document.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.Element(\"root\")\na = etree.SubElement(root, \"a\")\nb = etree.SubElement(root, \"b\")\nc = etree.SubElement(root, \"c\")\nd = etree.SubElement(root, \"d\")\ne = etree.SubElement(d,    \"e\")\nb.getparent() == root\nprint(b.getnext().tag)\nprint(c.getprevious().tag)\n\ntree = d.getroottree()\nprint(tree.getroot().tag)\n```\n\n----------------------------------------\n\nTITLE: Parsing XML from Strings with fromstring() in Python\nDESCRIPTION: Demonstrates using the fromstring() function to parse XML data from a string into an Element object. Shows basic tag access and serialization back to XML.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> some_xml_data = \\\"<root>data</root>\\\"\n\n>>> root = etree.fromstring(some_xml_data)\n>>> print(root.tag)\nroot\n>>> etree.tostring(root)\nb'<root>data</root>'\n```\n\n----------------------------------------\n\nTITLE: Installing lxml using pip\nDESCRIPTION: This command installs the latest version of lxml using pip, the Python package manager.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install lxml\n```\n\n----------------------------------------\n\nTITLE: Using the E-factory for Compact XML Generation\nDESCRIPTION: Demonstrates the E-factory, which provides a simple and compact syntax for generating XML and HTML documents programmatically with Python.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_53\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.builder import E\n\n>>> def CLASS(*args):  # class is a reserved word in Python\n...     return {\"class\":' '.join(args)}\n\n>>> html = page = (\n...   E.html(       # create an Element called \"html\"\n...     E.head(\n...       E.title(\"This is a sample document\")\n...     ),\n...     E.body(\n...       E.h1(\"Hello!\", CLASS(\"title\")),\n...       E.p(\"This is a paragraph with \", E.b(\"bold\"), \" text in it!\"),\n...       E.p(\"This is another paragraph, with a\", \"\\n      \",\n...         E.a(\"link\", href=\"http://www.python.org\"), \".\"),\n...       E.p(\"Here are some reserved characters: <spam&egg>.\"),\n...       etree.XML(\"<p>And finally an embedded XHTML fragment.</p>\"),\n...     )\n...   )\n... )\n```\n\n----------------------------------------\n\nTITLE: Using XPath to Extract Text from XML Trees\nDESCRIPTION: Shows different ways to extract text content using XPath expressions, including string() to get all concatenated text and //text() to get a list of all text nodes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> print(html.xpath(\"string()\")) # lxml.etree only!\nTEXTTAIL\n>>> print(html.xpath(\"//text()\")) # lxml.etree only!\n['TEXT', 'TAIL']\n```\n\n----------------------------------------\n\nTITLE: Implementing a Parser Target in lxml\nDESCRIPTION: Example of creating a custom parser target that handles SAX-like events while parsing XML. The target object provides methods to handle element start/end, text data, comments, and parser close events.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> class EchoTarget(object):\n...     def start(self, tag, attrib):\n...         print(\"start %s %r\" % (tag, dict(attrib)))\n...     def end(self, tag):\n...         print(\"end %s\" % tag)\n...     def data(self, data):\n...         print(\"data %r\" % data)\n...     def comment(self, text):\n...         print(\"comment %s\" % text)\n...     def close(self):\n...         print(\"close\")\n...         return \"closed!\"\n\n>>> parser = etree.XMLParser(target = EchoTarget())\n\n>>> result = etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\nstart element {}\ndata 'some'\ncomment comment\ndata 'text'\nend element\nclose\n\n>>> print(result)\nclosed!\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing XML with lxml\nDESCRIPTION: Demonstrates how to format XML output with proper indentation using lxml's pretty print option.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><test/></root>\")\n>>> etree.tostring(root)\nb'<root><test/></root>'\n\n>>> print(etree.tostring(root, pretty_print=True))\n<root>\n  <test/>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Serializing XML Elements to Strings in lxml.etree\nDESCRIPTION: Shows how to convert XML elements to strings using tostring() and a custom pretty-print function.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\netree.tostring(root)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef prettyprint(element, **kwargs):\n    xml = etree.tostring(element, pretty_print=True, **kwargs)\n    print(xml.decode(), end='')\n```\n\n----------------------------------------\n\nTITLE: Initializing lxml.etree and Importing BytesIO\nDESCRIPTION: Sets up the environment for using lxml.etree and defines a custom StringIO function for handling both string and byte input.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom io import BytesIO\ndef StringIO(s=None):\n    if isinstance(s, str): s = s.encode(\"UTF-8\")\n    return BytesIO(s)\n\nfrom lxml import etree\n```\n\n----------------------------------------\n\nTITLE: Using the attrib Property for Element Attributes in lxml.etree\nDESCRIPTION: Demonstrates how to work with the attrib property which provides a dictionary-like view of element attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nattributes = root.attrib\n\nprint(attributes[\"interesting\"])\nprint(attributes.get(\"no-such-attribute\"))\n\nattributes[\"hello\"] = \"Guten Tag\"\nprint(attributes[\"hello\"])\nprint(root.get(\"hello\"))\n```\n\nLANGUAGE: python\nCODE:\n```\nd = dict(root.attrib)\nsorted(d.items())\n```\n\n----------------------------------------\n\nTITLE: Using XML() Function for XML Literals in Python\nDESCRIPTION: Shows the XML() function which works like fromstring() but is commonly used for XML literals in code. Demonstrates basic parsing and access to the resulting Element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\\\"<root>data</root>\\\")\n>>> print(root.tag)\nroot\n>>> etree.tostring(root)\nb'<root>data</root>'\n```\n\n----------------------------------------\n\nTITLE: Element Movement and Parent Access in lxml.etree\nDESCRIPTION: Demonstrates how lxml.etree moves elements when assigned to new positions rather than copying them, and how to access an element's parent.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfor child in root:\n    print(child.tag)\nroot[0] = root[-1]  # this moves the element in lxml.etree!\nfor child in root:\n    print(child.tag)\n```\n\nLANGUAGE: python\nCODE:\n```\nroot is root[0].getparent()  # lxml.etree only!\n```\n\n----------------------------------------\n\nTITLE: Parsing XML from Files with parse() in Python\nDESCRIPTION: Demonstrates using the parse() function to read XML from file-like objects. Uses BytesIO to simulate a file for the example and shows how parse() returns an ElementTree object rather than an Element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> from io import BytesIO\n>>> some_file_or_file_like_object = BytesIO(b\\\"<root>data</root>\\\")\n\n>>> tree = etree.parse(some_file_or_file_like_object)\n\n>>> etree.tostring(tree)\nb'<root>data</root>'\n\n>>> root = tree.getroot()\n>>> print(root.tag)\nroot\n>>> etree.tostring(root)\nb'<root>data</root>'\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Elements in lxml.etree\nDESCRIPTION: Demonstrates how to create elements, add child elements, and access element properties like tags.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.Element(\"root\")\n\nprint(root.tag)\n```\n\n----------------------------------------\n\nTITLE: Working with XML attributes in lxml ElementTree\nDESCRIPTION: Shows how to get and set XML attributes using the .get() and .set() methods, as well as accessing the .attrib dictionary property in lxml.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.fromstring(\n...     '<root a=\"the value\" b=\"of an\" c=\"attribute\"/>')\n\n>>> root.get('a')\n'the value'\n\n>>> root.set('a', \"THE value\")\n>>> root.get('a')\n'THE value'\n\n>>> d = root.attrib\n\n>>> list(sorted(d.keys()))\n['a', 'b', 'c']\n>>> list(sorted(d.values()))\n['THE value', 'attribute', 'of an']\n```\n\n----------------------------------------\n\nTITLE: Defining XPath Extension Functions in Python\nDESCRIPTION: This snippet shows how to define Python functions that can be used as XPath extension functions. These functions always receive a context object as the first argument, followed by any additional arguments passed from the XPath expression.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef hello(context, a):\n    return \"Hello %s\" % a\n\ndef ola(context, a):\n    return \"Ola %s\" % a\n\ndef loadsofargs(context, *args):\n    return \"Got %d arguments.\" % len(args)\n```\n\n----------------------------------------\n\nTITLE: Accessing Element Children with List Operations in lxml.etree\nDESCRIPTION: Demonstrates how to access child elements using list-like operations such as indexing, length checking, and iteration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nchild = root[0]\nprint(child.tag)\n\nprint(len(root))\n\nroot.index(root[1])  # lxml.etree only!\n\nchildren = list(root)\n\nfor child in root:\n    print(child.tag)\n\nroot.insert(0, etree.Element(\"child0\"))\nstart = root[:1]\nend   = root[-1:]\n\nprint(start[0].tag)\nprint(end[0].tag)\n```\n\n----------------------------------------\n\nTITLE: Using ElementPath for XML Navigation\nDESCRIPTION: Shows how to use ElementPath expressions to find and navigate XML elements. Includes examples of finding children, descendants, and elements with specific attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_56\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><a x='123'>aText<b/><c/><b/></a></root>\")\n\n>>> print(root.find(\"b\"))\nNone\n>>> print(root.find(\"a\").tag)\na\n\n>>> print(root.find(\".//b\").tag)\nb\n>>> [ b.tag for b in root.iterfind(\".//b\") ]\n['b', 'b']\n\n>>> print(root.findall(\".//a[@x]\")[0].tag)\na\n>>> print(root.findall(\".//a[@y]\"))\n[]\n```\n\n----------------------------------------\n\nTITLE: Using Extension Functions in XPath Evaluators and XSLT\nDESCRIPTION: This snippet shows how to use extension functions with XPath evaluators and XSLT transformations. It demonstrates creating evaluators with namespaces and using extension functions in XSLT stylesheets.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ne = etree.XPathEvaluator(doc)\nprint(e('es:hello(local-name(/a))'))\n\nnamespaces = {'f' : 'http://mydomain.org/myfunctions'}\ne = etree.XPathEvaluator(doc, namespaces=namespaces)\nprint(e('f:hello(local-name(/a))'))\n\nxslt = etree.XSLT(etree.XML('''\n  <stylesheet version=\"1.0\"\n         xmlns=\"http://www.w3.org/1999/XSL/Transform\"\n         xmlns:es=\"http://mydomain.org/myother/functions\">\n    <output method=\"text\" encoding=\"ASCII\"/>\n    <template match=\"/\">\n      <value-of select=\"es:hello(string(//b))\"/>\n    </template>\n  </stylesheet>\n'''))\nprint(xslt(doc))\n```\n\n----------------------------------------\n\nTITLE: Using XPath and CSS selectors in lxml\nDESCRIPTION: Demonstrates how to use XPath expressions and CSS selectors to search and extract data from XML documents in lxml.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> find_paragraphs = etree.XPath(\"//p\")\n>>> paragraphs = find_paragraphs(xml_tree)\n\n>>> print([ p.text for p in paragraphs ])\n['So be it!', 'stuff']\n\n>>> find_dialogs = cssselect.CSSSelector(\"speech.dialog p\")\n>>> paragraphs = find_dialogs(xml_tree)\n\n>>> print([ p.text for p in paragraphs ])\n['So be it!']\n```\n\n----------------------------------------\n\nTITLE: Rewriting Links in HTML Documents with Python and lxml\nDESCRIPTION: This method rewrites all links in an HTML document using a provided replacement function. It can handle base URLs and resolve <base href> tags. The replacement function is called for each link and can return a new link or None to remove it.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.rewrite_links(link_repl_func, resolve_base_href=True, base_href=None)\n```\n\n----------------------------------------\n\nTITLE: Using XMLPullParser for Event-Based XML Parsing in Python\nDESCRIPTION: Demonstrates how to use etree.XMLPullParser to parse XML in an event-driven manner, registering event types and processing events as they occur. This snippet shows basic parser setup and event processing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nevent_types = (\"start\", \"end\", \"start-ns\", \"end-ns\")\nparser = etree.XMLPullParser(event_types)\nevents = parser.read_events()\n\nparser.feed('<root><element>')\nprint_events(events)\nparser.feed('text</element><element>text</element>')\nprint_events(events)\nparser.feed('<empty-element xmlns=\"http://testns/\" />')\nprint_events(events)\nparser.feed('</root>')\nprint_events(events)\n```\n\n----------------------------------------\n\nTITLE: Handling XML Parsing Errors in lxml.etree\nDESCRIPTION: Demonstrates error handling when parsing invalid XML, showing how to access the error log attached to the exception.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\netree.clear_error_log()\nbroken_xml = '''\n<root>\n  <a>\n</root>\n'''\ntry:\n  etree.parse(StringIO(broken_xml))\nexcept etree.XMLSyntaxError as e:\n  pass # just put the exception into e\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RelaxNG Validator in Python with lxml\nDESCRIPTION: Demonstrates creating a RelaxNG validator from a RelaxNG schema definition and using it to validate XML content. It shows both successful and failed validation scenarios.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nf = StringIO('''\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n <zeroOrMore>\n    <element name=\"b\">\n      <text />\n    </element>\n </zeroOrMore>\n</element>\n''')\nrelaxng_doc = etree.parse(f)\nrelaxng = etree.RelaxNG(relaxng_doc)\n\nvalid = StringIO('<a><b></b></a>')\ndoc = etree.parse(valid)\nrelaxng.validate(doc)\n\ninvalid = StringIO('<a><c></c></a>')\ndoc2 = etree.parse(invalid)\nrelaxng.validate(doc2)\n\nif not relaxng(doc2):\n    print(\"invalid!\")\n\nlog = relaxng.error_log\nprint(log.last_error)\n```\n\n----------------------------------------\n\nTITLE: Filtering Tree Iteration by Element Tag\nDESCRIPTION: Shows how to filter tree iteration to include only specific element tags by passing tag names to the iter() method, allowing selective processing of elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> for element in root.iter(\"child\"):\n...     print(f\"{element.tag} - {element.text}\")\nchild - Child 1\nchild - Child 2\n\n>>> for element in root.iter(\"another\", \"child\"):\n...     print(f\"{element.tag} - {element.text}\")\nchild - Child 1\nchild - Child 2\nanother - Child 3\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML Form and Accessing Form Elements with lxml.html in Python\nDESCRIPTION: This snippet demonstrates how to parse an HTML form using lxml.html, access form elements, and manipulate input values. It covers various input types including hidden fields, text inputs, checkboxes, radio buttons, and select dropdowns.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_forms.txt#2025-04-16_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html import usedoctest\n>>> from lxml.html import fromstring, tostring\n>>> h = fromstring('''<html><body>\n... <form action=\"test\">\n...   <input type=\"hidden\" name=\"hidden_field\" value=\"hidden_value\">\n...   <input type=\"text\" name=\"text_field\" value=\"text_value\">\n...   <input type=\"checkbox\" name=\"single_checkbox\">\n...   <input type=\"checkbox\" name=\"single_checkbox2\" value=\"good\">\n...   <input type=\"checkbox\" name=\"check_group\" value=\"1\">\n...   <input type=\"checkbox\" name=\"check_group\" value=\"2\" checked>\n...   <input type=\"checkbox\" name=\"check_group\" value=\"3\" checked>\n...   <input type=\"checkbox\" name=\"check_group\" value=\"4\">\n...   <textarea name=\"textarea_field\">some text</textarea>\n...   <label for=\"value1\">value 1</label>\n...     <input type=\"radio\" name=\"radios\" value=\"value1\" id=\"value1\">\n...   <label for=\"value2\">value 2</label>\n...     <input type=\"radio\" name=\"radios\" value=\"value2\" id=\"value2\">\n...   <label for=\"value3\">value 3</label>\n...     <input type=\"radio\" name=\"radios\" value=\"value3\" id=\"value3\" checked>\n...   <select name=\"select1\">\n...     <option> No value </option>\n...     <option value=\"\">Empty</option>\n...     <option value=\"1\">number 1</option>\n...   </select>\n...   <select name=\"select2\" multiple>\n...     <option value=\"1\">number 1</option>\n...     <option value=\"2\">number 2</option>\n...     <option value=\"3\">number 3</option>\n...     <option>number 4</option>\n...   </select>\n...   <select name=\"select3\">\n...     <option value=\"01 \" selected>text 1</option>\n...     <option value=\" 02\">text 2</option>\n...   </select>\n...   <select name=\"select4\" multiple>\n...     <option value=\"01 \" selected>text 1</option>\n...     <option value=\" 02\">text 2</option>\n...   </select>\n...   <input type=\"file\" name=\"file_field\" value=\"nonsense_value\">\n...   <input type=\"submit\" name=\"submit1\" value=\"submit\">\n...   <input type=\"submit\" name=\"submit2\" value=\"submit\">\n...   <input type=\"reset\" name=\"reset1\">linksys\n... </form>\n... </body></html>''', base_url='http://example.org/form.html')\n>>> h.base_url\n'http://example.org/form.html'\n>>> f = h.forms[0]\n>>> f.action\n'http://example.org/test'\n>>> f.method\n'GET'\n\n>>> f.inputs # doctest:+NOPARSE_MARKUP\n<InputGetter for form 0>\n>>> len(f.inputs)\n20\n>>> len(list(f.inputs))\n20\n>>> len(f.inputs.keys())\n15\n>>> len(f.inputs.items())\n15\n>>> len([f.inputs[name] for name in f.inputs.keys()])\n15\n\n>>> hidden = f.inputs['hidden_field']\n>>> hidden.checkable\nFalse\n>>> hidden.value\n'hidden_value'\n>>> hidden.value = 'new value'\n>>> tostring(hidden, with_tail=False)\nb'<input type=\"hidden\" name=\"hidden_field\" value=\"new value\">'\n>>> checkbox = f.inputs['single_checkbox']\n>>> checkbox.checkable\nTrue\n>>> checkbox.type\n'checkbox'\n>>> checkbox.checked\nFalse\n>>> print(checkbox.value)\nNone\n>>> checkbox.checked = True\n>>> checkbox.value\n'on'\n>>> tostring(checkbox, with_tail=False)\nb'<input type=\"checkbox\" name=\"single_checkbox\" checked>'\n>>> checkbox2 = f.inputs['single_checkbox2']\n>>> checkbox2.checked = True\n>>> checkbox2.value\n'good'\n>>> group = f.inputs['check_group']\n>>> group.value # doctest:+NOPARSE_MARKUP\n<CheckboxValues {'2', '3'} for checkboxes name='check_group'>\n>>> group.value.add('1')\n>>> group.value # doctest:+NOPARSE_MARKUP\n<CheckboxValues {'1', '2', '3'} for checkboxes name='check_group'>\n>>> tostring(group[0], with_tail=False)\nb'<input type=\"checkbox\" name=\"check_group\" value=\"1\" checked>'\n>>> group.value_options\n['1', '2', '3', '4']\n>>> group.value.add('doesnotexist')\nTraceback (most recent call last):\n    ...\nKeyError: \"No checkbox with value 'doesnotexist'\"\n>>> textarea = f.inputs['textarea_field']\n>>> textarea.value\n'some text'\n>>> radios = f.inputs['radios']\n>>> radios[0].label.text\n'value 1'\n>>> radios.value\n'value3'\n>>> radios.value = 'value1'\n>>> radios.value\n'value1'\n>>> tostring(radios[0], with_tail=False)\nb'<input type=\"radio\" name=\"radios\" value=\"value1\" id=\"value1\" checked>'\n>>> radios.value = None\n>>> tostring(radios[0], with_tail=False)\nb'<input type=\"radio\" name=\"radios\" value=\"value1\" id=\"value1\">'\n>>> radios.value_options\n['value1', 'value2', 'value3']\n>>> select = f.inputs['select1']\n>>> print(select.value)\nNo value\n>>> select.value = \"\"\n>>> select.value\n''\n>>> select.value = 'asdf'\nTraceback (most recent call last):\n    ...\nValueError: There is no option with the value of 'asdf'\n>>> select.value_options\n['No value', '', '1']\n>>> select.value = 'No value'\n>>> select.value\n'No value'\n>>> select = f.inputs['select2']\n>>> select.value # doctest:+NOPARSE_MARKUP\n<MultipleSelectOptions {} for select name='select2'>\n>>> select.value.update(['2', '3'])\n>>> select.value # doctest:+NOPARSE_MARKUP\n<MultipleSelectOptions {'2', '3'} for select name='select2'>\n>>> select.value.remove('3')\n>>> select.value.add('asdf')\nTraceback (most recent call last):\n    ...\nValueError: There is no option with the value 'asdf'\n>>> select.value.add('number 4')\n>>> select.value # doctest:+NOPARSE_MARKUP\n<MultipleSelectOptions {'2', 'number 4'} for select name='select2'>\n>>> select.value.remove('number 4')\n>>> select.value_options\n['1', '2', '3', 'number 4']\n>>> select = f.inputs['select3']\n>>> select.value\n'01 '\n>>> select.value_options\n['01 ', ' 02']\n>>> select.value = \" 02\"\n>>> select.value\n' 02'\n>>> select = f.inputs['select4']\n>>> select.value # doctest:+NOPARSE_MARKUP\n<MultipleSelectOptions {'01 '} for select name='select4'>\n>>> select.value.add(' 02')\n>>> select.value # doctest:+NOPARSE_MARKUP\n<MultipleSelectOptions {'01 ', ' 02'} for select name='select4'>\n>>> try: from urllib import urlencode\n... except ImportError: from urllib.parse import urlencode\n>>> print(urlencode(f.form_values()))\nhidden_field=new+value&text_field=text_value&single_checkbox=on&single_checkbox2=good&check_group=1&check_group=2&check_group=3&textarea_field=some+text&select1=No+value&select2=2&select3=+02&select4=01+&select4=+02\n>>> fields = f.fields\n>>> fields # doctest:+NOPARSE_MARKUP\n<FieldsDict for form 0>\n>>> len(fields)\n20\n>>> for name, value in sorted(fields.items()):\n...     print('%s: %r' % (name, value))\ncheck_group: <CheckboxValues {'1', '2', '3'} for checkboxes name='check_group'>\nfile_field: 'nonsense_value'\nhidden_field: 'new value'\nradios: None\nreset1: None\nselect1: 'No value'\nselect2: <MultipleSelectOptions {'2'} for select name='select2'>\nselect3: ' 02'\nselect4: <MultipleSelectOptions {'01 ', ' 02'} for select name='select4'>\nsingle_checkbox: 'on'\nsingle_checkbox2: 'good'\nsubmit1: 'submit'\nsubmit2: 'submit'\ntext_field: 'text_value'\ntextarea_field: 'some text'\n```\n\n----------------------------------------\n\nTITLE: Reusing XML Parser Objects in Python\nDESCRIPTION: Demonstrates how to reuse an XML parser after closing it. Shows that the same parser instance can be used for multiple parsing operations by feeding it new content after closing the previous parse operation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> parser.feed(\\\"<root/>\\\")\n>>> root = parser.close()\n>>> etree.tostring(root)\nb'<root/>'\n```\n\n----------------------------------------\n\nTITLE: Using CSSSelector Class in Python with lxml\nDESCRIPTION: Demonstrates how to create and use a CSSSelector object to select elements from an XML document using CSS selectors. Shows how to inspect the compiled XPath expression.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/cssselect.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.cssselect import CSSSelector\n>>> sel = CSSSelector('div.content')\n>>> sel  #doctest: +ELLIPSIS\n<CSSSelector ... for 'div.content'>\n>>> sel.css\n'div.content'\n>>> sel.path\n\"descendant-or-self::div[@class and contains(concat(' ', normalize-space(@class), ' '), ' content ')]\"\n```\n\n----------------------------------------\n\nTITLE: Accessing DOCTYPE and XML Information in lxml\nDESCRIPTION: Shows how to access and modify DOCTYPE information, XML version, and encoding from parsed documents using the docinfo property of an ElementTree object.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> pub_id  = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n>>> sys_url = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n>>> doctype_string = '<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_url)\n>>> xml_header = '<?xml version=\"1.0\" encoding=\"ascii\"?>'\n>>> xhtml = xml_header + doctype_string + '<html><body></body></html>'\n\n>>> tree = etree.parse(StringIO(xhtml))\n>>> docinfo = tree.docinfo\n>>> print(docinfo.public_id)\n-//W3C//DTD XHTML 1.0 Transitional//EN\n>>> print(docinfo.system_url)\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\n>>> docinfo.doctype == doctype_string\nTrue\n\n>>> print(docinfo.xml_version)\n1.0\n>>> print(docinfo.encoding)\nascii\n\n>>> docinfo.system_url = None\n>>> docinfo.public_id = None\n>>> print(etree.tostring(tree))\n<!DOCTYPE html>\n<html><body/></html>\n```\n\n----------------------------------------\n\nTITLE: Testing Element Type and Length in lxml.etree\nDESCRIPTION: Shows proper ways to test if an object is an Element and if an Element has children, avoiding old patterns that relied on truthy evaluation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(etree.iselement(root))  # test if it's some kind of Element\nif len(root):                 # test if it has children\n    print(\"The root element has children\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying XSLT Transformation in Python with lxml.etree\nDESCRIPTION: This snippet demonstrates how to create an XSLT stylesheet, transform an XML document, and access the error log. It shows the creation of XSLT and XML strings, transformation, and error log iteration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> xslt_root = etree.XML('''\n... <xsl:stylesheet version=\"1.0\"\n...     xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n...     <xsl:template match=\"/\">\n...         <xsl:message terminate=\"no\">STARTING</xsl:message>\n...         <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n...         <xsl:message terminate=\"no\">DONE</xsl:message>\n...     </xsl:template>\n... </xsl:stylesheet>''')\n>>> transform = etree.XSLT(xslt_root)\n\n>>> doc_root = etree.XML('<a><b>Text</b></a>')\n>>> result = transform(doc_root)\n>>> bytes(result)\nb'<?xml version=\"1.0\"?>\\n<foo>Text</foo>\\n'\n\n>>> print(transform.error_log)\n<string>:0:0:ERROR:XSLT:ERR_OK: STARTING\n<string>:0:0:ERROR:XSLT:ERR_OK: DONE\n\n>>> for entry in transform.error_log:\n...     print('message from line %s, col %s: %s' % (\n...                entry.line, entry.column, entry.message))\n...     print('domain: %s (%d)' % (entry.domain_name, entry.domain))\n...     print('type: %s (%d)' % (entry.type_name, entry.type))\n...     print('level: %s (%d)' % (entry.level_name, entry.level))\n...     print('filename: %s' % entry.filename)\nmessage from line 0, col 0: STARTING\ndomain: XSLT (22)\ntype: ERR_OK (0)\nlevel: ERROR (2)\nfilename: <string>\nmessage from line 0, col 0: DONE\ndomain: XSLT (22)\ntype: ERR_OK (0)\nlevel: ERROR (2)\nfilename: <string>\n```\n\n----------------------------------------\n\nTITLE: Event-driven Parsing with iterparse() in Python\nDESCRIPTION: Shows how to use iterparse() for event-driven XML parsing. This approach generates parser events while building the tree, allowing for memory-efficient processing of large XML documents.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> some_file_like = BytesIO(b\\\"<root><a>data</a></root>\\\")\n\n>>> for event, element in etree.iterparse(some_file_like):\n...     print(f\\\"{event}, {element.tag:>4}, {element.text}\\\")\nend,    a, data\nend, root, None\n```\n\n----------------------------------------\n\nTITLE: Creating an XMLSchema Validator in Python\nDESCRIPTION: Shows how to create an XML Schema validator by parsing an XSD schema and instantiating the XMLSchema class. The example defines a simple schema that requires an 'a' element containing a 'b' element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('''\n... <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n... <xsd:element name=\"a\" type=\"AType\"/>\n... <xsd:complexType name=\"AType\">\n...   <xsd:sequence>\n...     <xsd:element name=\"b\" type=\"xsd:string\" />\n...   </xsd:sequence>\n... </xsd:complexType>\n... </xsd:schema>\n... ''')\n>>> xmlschema_doc = etree.parse(f)\n>>> xmlschema = etree.XMLSchema(xmlschema_doc)\n```\n\n----------------------------------------\n\nTITLE: Incremental Parsing with Feed Parser Interface in Python\nDESCRIPTION: Shows how to use the feed parser interface for incremental XML parsing. Demonstrates feeding XML fragments into the parser one at a time and getting the complete result upon close().\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser()\n\n>>> parser.feed(\\\"<roo\\\")\n>>> parser.feed(\\\"t><\\\")\n>>> parser.feed(\\\"a/\\\")\n>>> parser.feed(\\\"><\\\")\n>>> parser.feed(\\\"/root>\\\")\n\n>>> root = parser.close()\n\n>>> etree.tostring(root)\nb'<root><a/></root>'\n```\n\n----------------------------------------\n\nTITLE: Managing Element Text and Tail Properties in lxml.etree\nDESCRIPTION: Demonstrates how to work with the text and tail properties of Element objects to handle text content in XML documents, showing how they represent text that appears within elements and after closing tags.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> html = etree.Element(\"html\")\n>>> body = etree.SubElement(html, \"body\")\n>>> body.text = \"TEXT\"\n\n>>> etree.tostring(html)\nb'<html><body>TEXT</body></html>'\n\n>>> br = etree.SubElement(body, \"br\")\n>>> etree.tostring(html)\nb'<html><body>TEXT<br/></body></html>'\n\n>>> br.tail = \"TAIL\"\n>>> etree.tostring(html)\nb'<html><body>TEXT<br/>TAIL</body></html>'\n```\n\n----------------------------------------\n\nTITLE: Creating an ElementTree from XML in Python\nDESCRIPTION: Demonstrates creating an ElementTree object from an XML string, accessing document information, and modifying DOCTYPE declarations. Shows how ElementTree wraps a root node and provides methods for document handling.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML('''\n... <?xml version=\\\"1.0\\\"?>\n... <!DOCTYPE root SYSTEM \\\"test\\\" [ <!ENTITY tasty \\\"parsnips\\\"> ]>\n... <root>\n...   <a>&tasty;</a>\n... </root>\n... ''')\n\n>>> tree = etree.ElementTree(root)\n>>> print(tree.docinfo.xml_version)\n1.0\n>>> print(tree.docinfo.doctype)\n<!DOCTYPE root SYSTEM \\\"test\\\">\n\n>>> tree.docinfo.public_id = '-//W3C//DTD XHTML 1.0 Transitional//EN'\n>>> tree.docinfo.system_url = 'file://local.dtd'\n>>> print(tree.docinfo.doctype)\n<!DOCTYPE root PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"file://local.dtd\\\">\n```\n\n----------------------------------------\n\nTITLE: Using the XPath Class for Compiled Expressions\nDESCRIPTION: Demonstrates the XPath class which compiles expressions for efficient repeated evaluation. Shows basic usage and how to pass variables to compiled expressions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><a><b/></a><b/></root>\")\n\n>>> find = etree.XPath(\"//b\")\n>>> print(find(root)[0].tag)\nb\n```\n\n----------------------------------------\n\nTITLE: Converting XML Elements to Dictionary in Python\nDESCRIPTION: A recursive function to convert an XML element to a dictionary structure. It maps each element's tag as a key and handles nested elements by recursively converting them to nested dictionaries.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef recursive_dict(element):\n     return element.tag, \\\n            dict(map(recursive_dict, element)) or element.text\n```\n\n----------------------------------------\n\nTITLE: Using XPath Method on ElementTree\nDESCRIPTION: Shows how to use the xpath() method on an ElementTree object to query for elements. The example demonstrates both absolute and relative XPath paths against a document.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('<foo><bar></bar></foo>')\n>>> tree = etree.parse(f)\n\n>>> r = tree.xpath('/foo/bar')\n>>> len(r)\n1\n>>> r[0].tag\n'bar'\n\n>>> r = tree.xpath('bar')\n>>> r[0].tag\n'bar'\n```\n\n----------------------------------------\n\nTITLE: Creating and Using DTD Validator in Python with lxml\nDESCRIPTION: Shows how to create a DTD object from a DTD definition string and use it to validate XML content. It also demonstrates accessing the error log for validation failures.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nf = StringIO(\"<!ELEMENT b EMPTY>\")\ndtd = etree.DTD(f)\n\nroot = etree.XML(\"<b/>\")\nprint(dtd.validate(root))\n\nroot = etree.XML(\"<b><a/></b>\")\nprint(dtd.validate(root))\n\nprint(dtd.error_log.filter_from_errors()[0])\n```\n\n----------------------------------------\n\nTITLE: Parsing XML from a string using lxml\nDESCRIPTION: Shows how to parse XML data from a string using the etree.fromstring() function in lxml.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> root_element = etree.fromstring(some_xml_data)\n```\n\n----------------------------------------\n\nTITLE: Using xslt() Tree Method for XSLT Transformation in Python with lxml.etree\nDESCRIPTION: This snippet shows how to use the xslt() tree method for one-shot XSLT transformations. It demonstrates the shorthand method and compares it to the standard approach using XSLT() constructor.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> result = doc.xslt(xslt_tree, a=\"'A'\")\n>>> bytes(result)\nb'<?xml version=\"1.0\"?>\\n<foo>A</foo>\\n'\n\n>>> transform = etree.XSLT(xslt_tree)\n>>> result = transform(doc, a=\"'A'\")\n>>> bytes(result)\nb'<?xml version=\"1.0\"?>\\n<foo>A</foo>\\n'\n```\n\n----------------------------------------\n\nTITLE: Incremental Parsing with File-like Objects in Python\nDESCRIPTION: Demonstrates incremental XML parsing using file-like objects that implement read() method. Creates a custom DataSource class that returns XML fragments on each read call.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> class DataSource:\n...     data = [ b\\\"<roo\\\", b\\\"t><\\\", b\\\"a/\\\", b\\\"<\\\", b\\\"/root>\\\" ]\n...     def read(self, requested_size):\n...         try:\n...             return self.data.pop(0)\n...         except IndexError:\n...             return b''\n\n>>> tree = etree.parse(DataSource())\n\n>>> etree.tostring(tree)\nb'<root><a/></root>'\n```\n\n----------------------------------------\n\nTITLE: Iterative XML Parsing with iterparse\nDESCRIPTION: Demonstrates how to use iterparse to parse XML content incrementally, tracking start and end events for elements with a specific tag.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO(xml)\n>>> context = etree.iterparse(\n...             f, events=(\"start\", \"end\"), tag=\"element\")\n\n>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: element\nend: element\nstart: element\nend: element\n\n>>> root = context.root\n```\n\n----------------------------------------\n\nTITLE: Creating Elements with XML Namespaces using Clark Notation\nDESCRIPTION: Demonstrates how to create XML elements with namespaces using the Clark notation {namespace}localname, which avoids the complexities of namespace prefixes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n>>> xhtml = etree.Element(\"{http://www.w3.org/1999/xhtml}html\")\n>>> body = etree.SubElement(xhtml, \"{http://www.w3.org/1999/xhtml}body\")\n>>> body.text = \"Hello World\"\n\n>>> prettyprint(xhtml)\n<html:html xmlns:html=\"http://www.w3.org/1999/xhtml\">\n  <html:body>Hello World</html:body>\n</html:html>\n```\n\n----------------------------------------\n\nTITLE: Making Links Absolute in HTML Documents with Python and lxml\nDESCRIPTION: This method converts all relative links in an HTML document to absolute URLs based on a provided base_href. It can optionally resolve <base href> tags as well.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.make_links_absolute(base_href, resolve_base_href=True)\n```\n\n----------------------------------------\n\nTITLE: Initializing XML Parser with DTD Validation in Python\nDESCRIPTION: Creates an XMLParser object with DTD validation enabled. This allows for on-the-fly validation of a document against its DTD during parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nparser = etree.XMLParser(dtd_validation=True)\n```\n\n----------------------------------------\n\nTITLE: Serializing to HTML and Plain Text\nDESCRIPTION: Shows how to serialize XML trees to different formats using the method parameter, including HTML and plain text output with various encoding options.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\n...    '<html><head/><body><p>Hello<br/>World</p></body></html>')\n\n>>> etree.tostring(root)  # default: method = 'xml'\nb'<html><head/><body><p>Hello<br/>World</p></body></html>'\n\n>>> etree.tostring(root, method='xml')  # same as above\nb'<html><head/><body><p>Hello<br/>World</p></body></html>'\n\n>>> etree.tostring(root, method='html')\nb'<html><head></head><body><p>Hello<br>World</p></body></html>'\n\n>>> prettyprint(root, method='html')\n<html>\n<head></head>\n<body><p>Hello<br>World</p></body>\n</html>\n\n>>> etree.tostring(root, method='text')\nb'HelloWorld'\n```\n\n----------------------------------------\n\nTITLE: Filtering XML Error Logs in Python using lxml\nDESCRIPTION: Demonstrates how to retrieve and filter XML error log entries by error level using lxml's error logging functionality.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> log = e.error_log.filter_from_level(etree.ErrorLevels.FATAL)\n>>> print(log[0])\n<string>:4:8:FATAL:PARSER:ERR_TAG_NAME_MISMATCH: Opening and ending tag mismatch: a line 3 and root\n```\n\n----------------------------------------\n\nTITLE: Creating and Using XML Schema Validator in Python with lxml\nDESCRIPTION: Demonstrates how to create an XML Schema object from a schema definition and use it to validate XML content during parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nschema_root = etree.XML('''\n  <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <xsd:element name=\"a\" type=\"xsd:integer\"/>\n  </xsd:schema>\n''')\nschema = etree.XMLSchema(schema_root)\n\nparser = etree.XMLParser(schema = schema)\nroot = etree.fromstring(\"<a>5</a>\", parser)\n```\n\n----------------------------------------\n\nTITLE: Resolving Base HREF in HTML Documents with Python and lxml\nDESCRIPTION: This method modifies an HTML document in-place to account for <base href> tags, removing the tag afterwards. It handles the base URL for relative links in the document.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.resolve_base_href()\n```\n\n----------------------------------------\n\nTITLE: Serializing ElementTree and Element Objects in Python\nDESCRIPTION: Shows the difference between serializing an ElementTree (complete document with DTD) versus serializing just the root Element. Demonstrates how lxml handles DTD content during serialization.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> prettyprint(tree)  # lxml 1.3.4 and later\n<!DOCTYPE root PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"file://local.dtd\\\" [\n<!ENTITY tasty \\\"parsnips\\\">\n]>\n<root>\n  <a>parsnips</a>\n</root>\n\n>>> prettyprint(tree.getroot())\n<root>\n  <a>parsnips</a>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Processing XInclude in lxml XML Documents\nDESCRIPTION: This snippet demonstrates how to use lxml to process XInclude statements in an XML document. It shows how to parse XML content with XInclude directives and then apply the xinclude() method to resolve and include the referenced content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> data = StringIO('''\n... <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n... <foo/>\n... <xi:include href=\"doc/test.xml\" />\n... </doc>''')\n\n>>> tree = etree.parse(data)\n>>> tree.xinclude()\n>>> print(etree.tostring(tree.getroot()))\n<doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n<foo/>\n<a xml:base=\"doc/test.xml\"/>\n</doc>\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable XPath Text Extractors\nDESCRIPTION: Demonstrates how to create a reusable XPath function for text extraction and how to work with the special text objects returned by XPath, including accessing their parent elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> build_text_list = etree.XPath(\"//text()\") # lxml.etree only!\n>>> print(build_text_list(html))\n['TEXT', 'TAIL']\n```\n\n----------------------------------------\n\nTITLE: Creating XML Documents with ElementMaker\nDESCRIPTION: Demonstrates how to use lxml's ElementMaker to create XML documents with custom namespaces and tags. Shows the creation of a structured document with nested elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_55\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.builder import ElementMaker  # lxml only !\n\n>>> E = ElementMaker(namespace=\"http://my.de/fault/namespace\",\n...                  nsmap={'p' : \"http://my.de/fault/namespace\"})\n\n>>> DOC = E.doc\n>>> TITLE = E.title\n>>> SECTION = E.section\n>>> PAR = E.par\n\n>>> my_doc = DOC(\n...   TITLE(\"The dog and the hog\"),\n...   SECTION(\n...     TITLE(\"The dog\"),\n...     PAR(\"Once upon a time, ...\"),\n...     PAR(\"And then ...\")\n...   ),\n...   SECTION(\n...     TITLE(\"The hog\"),\n...     PAR(\"Sooner or later ...\")\n...   )\n... )\n\n>>> prettyprint(my_doc)\n<p:doc xmlns:p=\"http://my.de/fault/namespace\">\n  <p:title>The dog and the hog</p:title>\n  <p:section>\n    <p:title>The dog</p:title>\n    <p:par>Once upon a time, ...</p:par>\n    <p:par>And then ...</p:par>\n  </p:section>\n  <p:section>\n    <p:title>The hog</p:title>\n    <p:par>Sooner or later ...</p:par>\n  </p:section>\n</p:doc>\n```\n\n----------------------------------------\n\nTITLE: Using iterparse with Custom Event Types in lxml.etree\nDESCRIPTION: Demonstrates how to use iterparse with custom event types to capture start and end events during XML parsing. This provides more granular control over the parsing process.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nevents = (\"start\", \"end\")\ncontext = etree.iterparse(StringIO(xml), events=events)\nfor action, elem in context:\n    print(\"%s: %s\" % (action, elem.tag))\n```\n\n----------------------------------------\n\nTITLE: One-Shot RelaxNG Validation in Python\nDESCRIPTION: Demonstrates the shortcut method for performing RelaxNG validation directly on a document. This approach is less efficient but simpler than creating a separate validator object.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> doc.relaxng(relaxng_doc)\nTrue\n>>> doc2.relaxng(relaxng_doc)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Creating HTML with E-factory Builder\nDESCRIPTION: Demonstrates using lxml's E-factory builder to programmatically generate HTML documents with a clean, Pythonic syntax. Shows creation of a complete HTML document with head, body, and nested elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.html import builder as E\n>>> from lxml.html import usedoctest\n>>> html = E.HTML(\n...   E.HEAD(\n...     E.LINK(rel=\"stylesheet\", href=\"great.css\", type=\"text/css\"),\n...     E.TITLE(\"Best Page Ever\")\n...   ),\n...   E.BODY(\n...     E.H1(E.CLASS(\"heading\"), \"Top News\"),\n...     E.P(\"World News only on this page\", style=\"font-size: 200%\"),\n...     \"Ah, and here's some more text, by the way.\",\n...     lxml.html.fromstring(\"<p>... and this is a parsed fragment ...</p>\")\n...   )\n... )\n\n>>> print lxml.html.tostring(html)\n```\n\n----------------------------------------\n\nTITLE: Basic XPath Usage in lxml\nDESCRIPTION: Demonstrates the standard setup for using XPath in lxml and importing the etree module, which is the foundation for XML processing in lxml.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml import etree\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML Tag Soup with BeautifulSoup Parser in lxml\nDESCRIPTION: Demonstrates how to parse broken HTML (tag soup) using lxml's soupparser.fromstring() function and how the parser attempts to create a valid HTML structure.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/elementsoup.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> tag_soup = '''\n... <meta/><head><title>Hello</head><body onload=crash()>Hi all<p>'''\n\n>>> from lxml.html.soupparser import fromstring\n>>> root = fromstring(tag_soup)\n\n>>> from lxml.etree import tostring\n>>> print(tostring(root, pretty_print=True).strip())\n<html>\n  <meta/>\n  <head>\n    <title>Hello</title>\n  </head>\n  <body onload=\"crash()\">Hi all<p/></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements Through Object Attributes\nDESCRIPTION: Demonstrates how to access XML elements using Python object attribute notation, including indexing, slicing, and tag-based iteration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"root\")\n>>> b = objectify.SubElement(root, \"b\")\n>>> print(root.b[0].tag)\nb\n>>> root.index(root.b[0])\n0\n>>> b = objectify.SubElement(root, \"b\")\n>>> print(root.b[0].tag)\nb\n>>> print(root.b[1].tag)\nb\n>>> root.index(root.b[1])\n1\n```\n\n----------------------------------------\n\nTITLE: HTML Diff Example with Python and lxml\nDESCRIPTION: This example demonstrates how to use lxml's HTML diff functionality to compare HTML documents and highlight changes. It shows both the htmldiff and html_annotate functions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html.diff import htmldiff, html_annotate\n>>> doc1 = '''<p>Here is some text.</p>'''\n>>> doc2 = '''<p>Here is <b>a lot</b> of <i>text</i>.</p>'''\n>>> doc3 = '''<p>Here is <b>a little</b> <i>text</i>.</p>'''\n>>> print htmldiff(doc1, doc2)\n>>> print html_annotate([(doc1, 'author1'), (doc2, 'author2'),\n...                      (doc3, 'author3')])\n```\n\n----------------------------------------\n\nTITLE: XSLT Transformation Example\nDESCRIPTION: Shows how to create and apply an XSLT transformation to XML data using LXML's XSLT class.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nxslt_root = etree.XML('''\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"/\">\n        <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n    </xsl:template>\n</xsl:stylesheet>''')\ntransform = etree.XSLT(xslt_root)\n\nf = StringIO('<a><b>Text</b></a>')\ndoc = etree.parse(f)\nresult_tree = transform(doc)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over XML Elements in lxml.etree\nDESCRIPTION: Shows various methods of iterating over XML elements, including children, siblings, ancestors, and descendants. Demonstrates filtering by tag name during iteration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n[ child.tag for child in root ]\n\n[ el.tag for el in root.iter() ]\n\n[ child.tag for child in root.iterchildren() ]\n[ child.tag for child in root.iterchildren(reversed=True) ]\n[ sibling.tag for sibling in b.itersiblings() ]\n[ sibling.tag for sibling in c.itersiblings(preceding=True) ]\n[ ancestor.tag for ancestor in e.iterancestors() ]\n[ el.tag for el in root.iterdescendants() ]\n\n[ child.tag for child in root.iterchildren('a') ]\n[ child.tag for child in d.iterchildren('a') ]\n[ el.tag for el in root.iterdescendants('d') ]\n[ el.tag for el in root.iter('d') ]\n[ el.tag for el in root.iter('d', 'a') ]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Element Classes with lxml.objectify in Python\nDESCRIPTION: Shows how to create a custom FeedElement class that extends objectify.ObjectifiedElement. The example implements an addIDs method that adds ID elements to feed and entry elements if they don't exist already.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom itertools import chain\n\nclass FeedElement(objectify.ObjectifiedElement):\n\n    def addIDs(self):\n        \"initialise the IDs of feed and entries\"\n\n\tfor element in chain([self], self.entry):\n\t    if element.find(_ATOM_NS + \"id\") is None:\n\t        id = etree.SubElement(self, _ATOM_NS + \"id\")\n\t        id.text = make_guid()\n```\n\n----------------------------------------\n\nTITLE: Validating Documents with Schematron in Python\nDESCRIPTION: Demonstrates validating XML documents against a Schematron schema. The example validates a document with Percent elements that sum to 100, then adds another element that makes the sum exceed 100, causing validation to fail.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> valid = StringIO('''\n... <Total>\n...   <Percent>20</Percent>\n...   <Percent>30</Percent>\n...   <Percent>50</Percent>\n... </Total>\n... ''')\n\n>>> doc = etree.parse(valid)\n>>> schematron.validate(doc)\nTrue\n\n>>> etree.SubElement(doc.getroot(), \"Percent\").text = \"10\"\n\n>>> schematron.validate(doc)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Using XPath Method on Elements\nDESCRIPTION: Demonstrates how XPath expressions work when executed against individual Element objects. Shows the behavior of both relative and absolute paths in this context.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> root = tree.getroot()\n>>> r = root.xpath('bar')\n>>> r[0].tag\n'bar'\n\n>>> bar = root[0]\n>>> r = bar.xpath('/foo/bar')\n>>> r[0].tag\n'bar'\n\n>>> tree = bar.getroottree()\n>>> r = tree.xpath('/foo/bar')\n>>> r[0].tag\n'bar'\n```\n\n----------------------------------------\n\nTITLE: Using CDATA() Wrapper in lxml for XML Content\nDESCRIPTION: This snippet shows how to use the CDATA() wrapper in lxml to ensure that text content is wrapped in a CDATA block when serializing XML. It demonstrates the difference between regular text content and CDATA-wrapped content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> root.text = 'test'\n\n>>> root.text\n'test'\n>>> etree.tostring(root)\nb'<root>test</root>'\n\n>>> root.text = etree.CDATA(root.text)\n\n>>> root.text\n'test'\n>>> etree.tostring(root)\nb'<root><![CDATA[test]]></root>'\n```\n\n----------------------------------------\n\nTITLE: Using XPath Extension Functions in Python\nDESCRIPTION: This snippet shows how to use the registered extension functions in XPath expressions. It demonstrates calling both Python functions and XPath built-in functions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.XML('<a><b>Haegar</b></a>')\ndoc = etree.ElementTree(root)\n\nprint(root.xpath(\"hello('Dr. Falken')\"))\nprint(root.xpath('hello(local-name(*))'))\nprint(root.xpath('hello(string(b))'))\nprint(root.xpath('countargs(., b, ./*)'))\n```\n\n----------------------------------------\n\nTITLE: Using XPath with Fully Qualified Names\nDESCRIPTION: Demonstrates how to use XPath with fully qualified namespace URIs using the ETXPath extension in lxml, which allows namespace-aware XPath queries.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n>>> find_xhtml_body = etree.ETXPath(      # lxml only !\n...     \"//{%s}body\" % XHTML_NAMESPACE)\n>>> results = find_xhtml_body(xhtml)\n\n>>> print(results[0].tag)\n{http://www.w3.org/1999/xhtml}body\n```\n\n----------------------------------------\n\nTITLE: XML Serialization to Different Encodings\nDESCRIPTION: Demonstrates various methods of serializing XML content to different encodings, including ASCII, UTF-8, and Unicode strings.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> etree.tostring(root)\nb'<test> &#63697; + &#63698; </test>'\n\n>>> etree.tostring(root, encoding='UTF-8', xml_declaration=False)\nb'<test> \\xef\\xa3\\x91 + \\xef\\xa3\\x92 </test>'\n\n>>> etree.tostring(root, encoding='unicode')\n'<test> \\uf8d1 + \\uf8d2 </test>'\n\n>>> el = etree.Element(\"test\")\n>>> etree.tostring(el, encoding='unicode')\n'<test/>'\n\n>>> subel = etree.SubElement(el, \"subtest\")\n>>> etree.tostring(el, encoding='unicode')\n'<test><subtest/></test>'\n\n>>> tree = etree.ElementTree(el)\n>>> etree.tostring(tree, encoding='unicode')\n'<test><subtest/></test>'\n```\n\n----------------------------------------\n\nTITLE: Parsing XML with lxml.objectify in Python\nDESCRIPTION: Demonstrates how to parse an XML file using lxml.objectify and access elements through the objectified tree structure. Shows basic navigation of XML elements including accessing titles and iterating through entry elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml import objectify\n\n>>> feed = objectify.parse(\"atom-example.xml\")\n>>> print(feed.title)\nExample Feed\n\n>>> print([entry.title for entry in feed.entry])\n['Atom-Powered Robots Run Amok']\n\n>>> print(feed.entry[0].title)\nAtom-Powered Robots Run Amok\n```\n\n----------------------------------------\n\nTITLE: Registering Namespaces with XPath Evaluators\nDESCRIPTION: This snippet demonstrates how to register namespaces with an XPath evaluator after its creation. It shows how to access elements in a specific namespace using a registered prefix.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nf = StringIO('<a xmlns=\"http://mydomain.org/myfunctions\" />')\nns_doc = etree.parse(f)\ne = etree.XPathEvaluator(ns_doc)\ne('/a')\n\ne.register_namespace('foo', 'http://mydomain.org/myfunctions')\ne('/foo:a')[0].tag\n```\n\n----------------------------------------\n\nTITLE: Element Iteration Methods Comparison\nDESCRIPTION: Compares different methods for finding elements in an XML tree, including find(), iterfind(), and iter(). Shows equivalent ways to locate elements and their differences in handling no-match cases.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_58\n\nLANGUAGE: python\nCODE:\n```\n>>> print(root.find(\".//b\").tag)\nb\n>>> print(next(root.iterfind(\".//b\")).tag)\nb\n>>> print(next(root.iter(\"b\")).tag)\nb\n```\n\n----------------------------------------\n\nTITLE: Controlling XML Indentation with indent() Function\nDESCRIPTION: Demonstrates how to use the indent() function (added in lxml 4.5) for fine-grained control over pretty-printing with customizable indentation spacing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML('<root><a><b/>\\n</a></root>')\n>>> print(etree.tostring(root).decode())\n<root><a><b/>\n</a></root>\n\n>>> etree.indent(root)\n>>> print(etree.tostring(root).decode())\n<root>\n  <a>\n    <b/>\n  </a>\n</root>\n\n>>> root.text\n'\\n  '\n>>> root[0].text\n'\\n    '\n\n>>> etree.indent(root, space=\"    \")\n>>> print(etree.tostring(root).decode())\n<root>\n    <a>\n        <b/>\n    </a>\n</root>\n\n>>> etree.indent(root, space=\"\\t\")\n>>> etree.tostring(root)\nb'<root>\\n\\t<a>\\n\\t\\t<b/>\\n\\t</a>\\n</root>'\n```\n\n----------------------------------------\n\nTITLE: Generating XPath Expressions with getpath()\nDESCRIPTION: Shows how to use the getpath() method to automatically generate XPath expressions that identify specific elements in a document.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> a  = etree.Element(\"a\")\n>>> b  = etree.SubElement(a, \"b\")\n>>> c  = etree.SubElement(a, \"c\")\n>>> d1 = etree.SubElement(c, \"d\")\n>>> d2 = etree.SubElement(c, \"d\")\n\n>>> tree = etree.ElementTree(c)\n>>> print(tree.getpath(d2))\n/c/d[2]\n>>> tree.xpath(tree.getpath(d2)) == [d2]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Modifying XML Tree During Parsing with lxml.etree\nDESCRIPTION: Shows how to modify the XML tree during parsing to save memory, particularly by clearing elements after processing them. This technique helps with large XML files by freeing memory as you go.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nparser = etree.XMLPullParser()\nevents = parser.read_events()\n\nparser.feed('<root><element key=\"value\">text</element>')\nparser.feed('<element><child /></element>')\nfor action, elem in events:\n    print('%s: %d' % (elem.tag, len(elem)))  # processing\n    elem.clear(keep_tail=True)               # delete children\nparser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\nfor action, elem in events:\n    print('%s: %d' % (elem.tag, len(elem)))  # processing\n    elem.clear(keep_tail=True)               # delete children\n\nroot = parser.close()\netree.tostring(root)\n```\n\n----------------------------------------\n\nTITLE: Using iterparse for Incremental XML Parsing in lxml.etree\nDESCRIPTION: Shows how to use iterparse to incrementally parse XML files while building the tree. This utility function works like a blocking wrapper around XMLPullParser that reads data from a file.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nxml = '''\n<root>\n  <element key='value'>text</element>\n  <element>text</element>tail\n  <empty-element xmlns=\"http://testns/\" />\n</root>\n'''\n\ncontext = etree.iterparse(StringIO(xml))\nfor action, elem in context:\n    print(\"%s: %s\" % (action, elem.tag))\n\ncontext.root.tag\n```\n\n----------------------------------------\n\nTITLE: Handling XML Declarations and Encoding with lxml\nDESCRIPTION: Shows various ways to handle XML declarations and encoding when serializing XML content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> unicode_root = etree.Element( \"t\\u3120st\" )\n>>> unicode_root.text = \"t\\u0A0Ast\"\n>>> etree.tostring(unicode_root, encoding=\"utf-8\")\nb't\\xe3\\x84\\xa0st>t\\xe0\\xa8\\x8ast</t\\xe3\\x84\\xa0st>'\n\n>>> print(etree.tostring(unicode_root, encoding=\"iso-8859-1\"))\n<?xml version='1.0' encoding='iso-8859-1'?>\n<t&#12576;st>t&#2570;st</t&#12576;st>\n```\n\n----------------------------------------\n\nTITLE: Creating Objectify Trees from XML\nDESCRIPTION: Demonstrates how to create objectify trees by parsing XML documents using parse() or fromstring() functions, which produce ObjectifiedElement instances.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> fileobject = StringIO('<test/>')\n\n>>> tree = objectify.parse(fileobject)\n>>> print(isinstance(tree.getroot(), objectify.ObjectifiedElement))\nTrue\n\n>>> root = objectify.fromstring('<test/>')\n>>> print(isinstance(root, objectify.ObjectifiedElement))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Element Classes in lxml\nDESCRIPTION: Shows how to define a custom Element class by subclassing ElementBase to add custom properties. This example adds a 'honking' property that reads from an attribute.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> class HonkElement(etree.ElementBase):\n...    @property\n...    def honking(self):\n...       return self.get('honking') == 'true'\n\n>>> lookup = etree.ElementDefaultClassLookup(\n...                             element=HonkElement)\n\n>>> parser = etree.XMLParser()\n>>> parser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Applying CSSSelector to XML Document in Python\nDESCRIPTION: Shows how to apply a CSSSelector object to an XML document to select elements. The example creates an XML string, parses it, and then applies the selector.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/cssselect.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.etree import fromstring\n>>> h = fromstring('''<div id=\"outer\">\n...   <div id=\"inner\" class=\"content body\">\n...       text\n...   </div></div>''')\n>>> [e.get('id') for e in sel(h)]\n['inner']\n```\n\n----------------------------------------\n\nTITLE: Making Links Absolute with make_links_absolute\nDESCRIPTION: Example of converting relative links to absolute URLs using make_links_absolute function, including handling of various HTML elements and CSS URLs.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_rewritelinks.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml.html import make_links_absolute\nhtml = lxml.html.fromstring(\"\"\"\\\n<html>\n  <head>\n     <title>Test</title>\n     <style type='text/css'>\n       .bg1 {\n           background: url(images/bg1.png);\n       }\n       .bg2 {\n           background: url(images/bg2.png);\n       }\n     </style>\n  </head>\n  <body>\n     <p>Hi</p>\n  </body>\n</html>\n\"\"\",\nbase_url = 'http://www.example.com/')\n\nhtml.make_links_absolute()\n```\n\n----------------------------------------\n\nTITLE: Accessing Namespace Mappings with the nsmap Property\nDESCRIPTION: Shows how to access the namespace mappings defined for an element using the nsmap property, which includes all prefixes known in the context of an element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n>>> xhtml.nsmap\n{None: 'http://www.w3.org/1999/xhtml'}\n```\n\n----------------------------------------\n\nTITLE: Getting Text Content from Elements\nDESCRIPTION: Demonstrates the text_content() method which extracts the textual content of an element without the tags, recursively collecting all text from the element and its descendants.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> el = fragment_fromstring('''\n... <div>This is <a href=\"foo\">a <b>bold</b> link</a></div>''')\n>>> el.text_content()\n'This is a bold link'\n>>> type(el.text_content()) is str  or  type(el.text_content())\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating ElementTree Objects\nDESCRIPTION: Demonstrates creating an ElementTree with a specific root, and shows how ElementTree operations are limited to the chosen root.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntree = etree.ElementTree(d)\nprint(tree.getroot().tag)\netree.tostring(tree)\n\nelement = tree.getroot()\nprint(element.tag)\nprint(element.getparent().tag)\nprint(element.getroottree().getroot().tag)\n```\n\n----------------------------------------\n\nTITLE: Form Filling Example with Python and lxml\nDESCRIPTION: This example demonstrates how to fill out an HTML form using lxml. It creates a form with text and checkbox inputs, then sets values for those inputs programmatically.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html import fromstring, tostring\n>>> form_page = fromstring('''<html><body><form>\n...   Your name: <input type=\"text\" name=\"name\"> <br>\n...   Your phone: <input type=\"text\" name=\"phone\"> <br>\n...   Your favorite pets: <br>\n...   Dogs: <input type=\"checkbox\" name=\"interest\" value=\"dogs\"> <br>\n...   Cats: <input type=\"checkbox\" name=\"interest\" value=\"cats\"> <br>\n...   Llamas: <input type=\"checkbox\" name=\"interest\" value=\"llamas\"> <br>\n...   <input type=\"submit\"></form></body></html>''')\n>>> form = form_page.forms[0]\n>>> form.fields = dict(\n...     name='John Smith',\n...     phone='555-555-3949',\n...     interest=set(['cats', 'llamas']))\n>>> print(tostring(form))\n```\n\n----------------------------------------\n\nTITLE: Extracting Only Text Content from XML Elements\nDESCRIPTION: Demonstrates how to extract just the text content from an XML tree by using the method='text' parameter with tostring(), which concatenates all text and tail attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> etree.tostring(html, method=\"text\")\nb'TEXTTAIL'\n```\n\n----------------------------------------\n\nTITLE: Using Custom Atom API with lxml in Python\nDESCRIPTION: Shows how to use a custom Atom API built with lxml. The example demonstrates parsing an Atom XML file, accessing entries and titles, and finding links using the iter method with namespace-aware tag names.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import atom\n>>> feed = atom.parse(\"ep2008/atom-example.xml\").getroot()\n\n>>> print(len(feed.entry))\n1\n>>> print([entry.title for entry in feed.entry])\n['Atom-Powered Robots Run Amok']\n\n>>> link_tag = \"{%s}link\" % atom.ATOM_NAMESPACE\n>>> print([link.get(\"href\") for link in feed.iter(link_tag)])\n['http://example.org/', 'http://example.org/2003/12/13/atom03']\n```\n\n----------------------------------------\n\nTITLE: Using XMLPullParser for Incremental Event Parsing in lxml\nDESCRIPTION: Demonstrates how to use the XMLPullParser class for incremental event parsing, which allows processing parse events after each parsing step.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLPullParser(events=('start', 'end'))\n\n>>> def print_events(parser):\n...     for action, element in parser.read_events():\n...         print('%s: %s' % (action, element.tag))\n\n>>> parser.feed('<root>some text')\n>>> print_events(parser)\nstart: root\n>>> print_events(parser)    # well, no more events, as before ...\n\n>>> parser.feed('<child><a />')\n>>> print_events(parser)\nstart: child\nstart: a\nend: a\n\n>>> parser.feed('</child></roo')\n>>> print_events(parser)\nend: child\n>>> parser.feed('t>')\n>>> print_events(parser)\nend: root\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring an XMLParser in Python\nDESCRIPTION: Shows how to create a custom XMLParser with specific options. The example demonstrates using remove_blank_text to eliminate whitespace between tags during parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser(remove_blank_text=True)  # lxml.etree only!\n\n>>> root = etree.XML(\\\"<root>  <a/>   <b>  </b>     </root>\\\", parser)\n\n>>> etree.tostring(root)\nb'<root><a/><b>  </b></root>'\n```\n\n----------------------------------------\n\nTITLE: Accessing RelaxNG Error Information in Python\nDESCRIPTION: Shows how to access error details from the RelaxNG validation log. The example demonstrates retrieving domain name and error type information from the last error in the log.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> error = log.last_error\n>>> print(error.domain_name)\nRELAXNGV\n>>> print(error.type_name)\nRELAXNG_ERR_ELEMWRONG\n```\n\n----------------------------------------\n\nTITLE: Form Submission Example with Python and lxml\nDESCRIPTION: This example shows how to submit an HTML form using lxml. It loads a form from a URL, sets a field value, then submits the form and parses the result.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html import parse, submit_form\n>>> page = parse('http://tinyurl.com').getroot()\n>>> page.forms[0].fields['url'] = 'http://lxml.de/'\n>>> result = parse(submit_form(page.forms[0])).getroot()\n\n>>> [a.attrib['href'] for a in result.xpath(\"//a[@target='_blank']\")] \n```\n\n----------------------------------------\n\nTITLE: Handling Namespaces in XPath Queries\nDESCRIPTION: Demonstrates how to handle namespaces in XPath expressions by mapping prefixes to namespace URIs using the namespaces keyword argument.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('''\\\n... <a:foo xmlns:a=\"http://codespeak.net/ns/test1\"\n...        xmlns:b=\"http://codespeak.net/ns/test2\">\n...    <b:bar>Text</b:bar>\n... </a:foo>\n... ''')\n>>> doc = etree.parse(f)\n\n>>> r = doc.xpath('/x:foo/b:bar',\n...               namespaces={'x': 'http://codespeak.net/ns/test1',\n...                           'b': 'http://codespeak.net/ns/test2'})\n>>> len(r)\n1\n>>> r[0].tag\n'{http://codespeak.net/ns/test2}bar'\n>>> r[0].text\n'Text'\n```\n\n----------------------------------------\n\nTITLE: Custom Element Class Lookup in lxml\nDESCRIPTION: Demonstrates how to create a custom lookup class by subclassing CustomElementClassLookup. The example implementation returns a custom class based on node type.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass MyLookup(etree.CustomElementClassLookup):\n    def lookup(self, node_type, document, namespace, name):\n        if node_type == 'element':\n            return honk  # be a bit more selective here ...\n        else:\n            return None  # pass on to (default) fallback\n\nparser = etree.XMLParser()\nparser.set_element_class_lookup(MyLookup())\n\nroot = etree.fromstring(\n    '<root honking=\"true\"><!--comment--></root>', parser)\nroot.honking\nTrue\nprint(root[0].text)\ncomment\n```\n\n----------------------------------------\n\nTITLE: Validating XML Documents with Schematron in lxml\nDESCRIPTION: Shows how to validate an XML document against a Schematron schema using the validate() method. The method returns True for valid documents and False for invalid ones.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> valid = StringIO('''\n... <Total>\n...   <Percent>20</Percent>\n...   <Percent>30</Percent>\n...   <Percent>50</Percent>\n... </Total>\n... ''')\n\n>>> doc = etree.parse(valid)\n>>> schematron.validate(doc)\nTrue\n\n>>> etree.SubElement(doc.getroot(), \"Percent\").text = \"10\"\n\n>>> schematron.validate(doc)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Simplified Namespace Registration Using Class Name as Tag in lxml\nDESCRIPTION: Demonstrates a simplified registration approach where the class name matches the tag name, allowing the use of the blank decorator. The example defines a 'honkel' class with a custom 'honking' property that reads an XML attribute.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> @honk_elements\n... class honkel(HonkNSElement):\n...    @property\n...    def honking(self):\n...       return self.get('honking') == 'true'\n\n>>> xml = '<honkel xmlns=\"http://hui.de/honk\" honking=\"true\"><bla/><!--comment--></honkel>'\n>>> honk_element = etree.fromstring(xml, parser)\n\n>>> print(type(honk_element))\n<class 'honkel'>\n>>> print(type(honk_element[0]))\n<class 'HonkNSElement'>\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying XML Attributes\nDESCRIPTION: Shows how to access and modify XML attributes using the get() and set() methods, maintaining the standard ElementTree API pattern.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> c = objectify.SubElement(root, \"c\", myattr=\"someval\")\n>>> print(root.c.get(\"myattr\"))\nsomeval\n\n>>> root.c.set(\"c\", \"oh-oh\")\n>>> print(root.c.get(\"c\"))\noh-oh\n```\n\n----------------------------------------\n\nTITLE: Inspecting XPath Text Result Origins\nDESCRIPTION: Shows how to examine the origins of text nodes returned by XPath queries, including finding parent elements and determining whether it's normal text content or tail text.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> texts = build_text_list(html)\n>>> print(texts[0])\nTEXT\n>>> parent = texts[0].getparent()\n>>> print(parent.tag)\nbody\n\n>>> print(texts[1])\nTAIL\n>>> print(texts[1].getparent().tag)\nbr\n```\n\n----------------------------------------\n\nTITLE: Registering and Using XPath Extension Functions in lxml\nDESCRIPTION: This snippet demonstrates how to create XPath extensions with the Extension class and use them in an XPathEvaluator. The example shows registering functions with namespaces and calling them in XPath expressions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nextensions = etree.Extension(ext_module, functions)\ne = etree.XPathEvaluator(doc, extensions=extensions)\nprint(e('function1(function2(function3(string(b))))'))\n```\n\nLANGUAGE: python\nCODE:\n```\nextensions1 = etree.Extension(ext_module)\nextensions2 = etree.Extension(ext_module, ns='local-ns')\ne = etree.XPathEvaluator(doc, extensions=[extensions1, extensions2],\n                        namespaces=namespaces)\nprint(e('function1(l:function2(function3(string(b))))'))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic XSLT Extension Element\nDESCRIPTION: Demonstrates creating a custom XSLT extension element by implementing the XSLTExtension class with an execute method that handles the extension's behavior when encountered in a stylesheet.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass MyExtElement(etree.XSLTExtension):\n    def execute(self, context, self_node, input_node, output_parent):\n        print(\"Hello from XSLT!\")\n        output_parent.text = \"I did it!\"\n        # just copy own content input to output\n        output_parent.extend( list(self_node) )\n```\n\n----------------------------------------\n\nTITLE: Using HTML() Function for HTML Literals in Python\nDESCRIPTION: Demonstrates using the HTML() function to parse HTML literals in code. Shows how lxml automatically adds missing html and body tags when parsing HTML fragments.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.HTML(\\\"<p>data</p>\\\")\n>>> etree.tostring(root)\nb'<html><body><p>data</p></body></html>'\n```\n\n----------------------------------------\n\nTITLE: Registering Element Classes with Namespace Decorators in lxml\nDESCRIPTION: Shows how to register a custom element class for a specific namespace using the namespace registry decorator approach introduced in lxml 4.1. The example defines a 'HonkNSElement' class with a custom 'honk()' method.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> honk_elements = lookup.get_namespace('http://hui.de/honk')\n\n>>> @honk_elements(None)\n... class HonkNSElement(etree.ElementBase):\n...    def honk(self):\n...       return \"HONK\"\n```\n\n----------------------------------------\n\nTITLE: Using cssselect Method on lxml Element Objects\nDESCRIPTION: Shows how to use the cssselect convenience method available on lxml Element objects. This method allows direct application of CSS selectors to elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/cssselect.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> h.cssselect('div.content') == sel(h)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using Selective Validation with Schematron Phases in Python\nDESCRIPTION: Shows how to use Schematron phases to selectively enable or disable validation patterns. The example creates a validator that only applies the sum check pattern, ignoring whether percentages are positive.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> selective = isoschematron.Schematron(sct_doc, phase=\"phase.sum_check\")\n>>> selective.validate(doc)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Parsing XML and HTML with shortcut functions in lxml\nDESCRIPTION: Demonstrates the convenient XML() and HTML() shortcut functions for parsing XML and HTML literals directly in code without creating a separate parser.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> root_element = etree.XML(\"<root><child/></root>\")\n>>> root_element = etree.HTML(\"<p>some<br>paragraph</p>\")\n```\n\n----------------------------------------\n\nTITLE: XSLT Parameter Passing\nDESCRIPTION: Demonstrates how to pass parameters to XSLT transformations using different value types and expressions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nxslt_tree = etree.XML('''\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:param name=\"a\" />\n    <xsl:template match=\"/\">\n        <foo><xsl:value-of select=\"$a\" /></foo>\n    </xsl:template>\n</xsl:stylesheet>''')\ntransform = etree.XSLT(xslt_tree)\ndoc_root = etree.XML('<a><b>Text</b></a>')\n\nresult = transform(doc_root, a=\"5\")\nresult = transform(doc_root, a=\"/a/b/text()\")\nresult = transform(doc_root, a=etree.XPath(\"/a/b/text()\"))\n```\n\n----------------------------------------\n\nTITLE: Using the Feed Parser Interface in lxml\nDESCRIPTION: Shows how to use the feed parser interface to parse XML in a controlled step-by-step way by feeding data chunks incrementally.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser()\n\n>>> for data in ('<?xml versio', 'n=\"1.0\"?', '><roo', 't><a', '/></root>'):\n...     parser.feed(data)\n\n>>> root = parser.close()\n\n>>> print(root.tag)\nroot\n>>> print(root[0].tag)\na\n```\n\n----------------------------------------\n\nTITLE: Using Namespaced XPath Extension Functions\nDESCRIPTION: This snippet demonstrates how to use namespaced extension functions in XPath expressions. It shows how to register functions with a specific namespace and use them with a prefix.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nns = etree.FunctionNamespace('http://mydomain.org/myfunctions')\nns['hello'] = hello\n\nprefixmap = {'f' : 'http://mydomain.org/myfunctions'}\nprint(root.xpath('f:hello(local-name(*))', namespaces=prefixmap))\n```\n\n----------------------------------------\n\nTITLE: Creating a Schematron Validator in Python\nDESCRIPTION: Shows how to create a Schematron validator by parsing a schema document and instantiating the Schematron class. The example creates a validator that checks if the sum of all Percent elements equals 100.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml import isoschematron\n>>> f = StringIO('''\n... <schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n...   <pattern id=\"sum_equals_100_percent\">\n...     <title>Sum equals 100%.</title>\n...     <rule context=\"Total\">\n...       <assert test=\"sum(//Percent)=100\">Sum is not 100%.</assert>\n...     </rule>\n...   </pattern>\n... </schema>\n... ''')\n\n>>> sct_doc = etree.parse(f)\n>>> schematron = isoschematron.Schematron(sct_doc)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Element Namespace Mapping in lxml\nDESCRIPTION: Demonstrates how to set up a namespace class lookup for custom element classes in lxml. This code maps custom element classes to specific tag names in the Atom namespace and creates a specialized parser that uses these mappings.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# ...\n_atom_lookup = etree.ElementNamespaceClassLookup(\n                  objectify.ObjectifyElementClassLookup())\n\n# map the classes to tag names\nns = _atom_lookup.get_namespace(ATOM_NAMESPACE)\nns[\"feed\"]  = FeedElement\nns[\"entry\"] = EntryElement\n# ... and so on\n# or use ns.update(vars()) with appropriate class names\n\n# create a parser that does some whitespace cleanup\natom_parser = etree.XMLParser(remove_blank_text=True)\n\n# make it use our Atom classes\natom_parser.set_element_class_lookup(_atom_lookup)\n\n# and help users in using our parser setup\ndef parse(input):\n    return etree.parse(input, atom_parser)\n```\n\n----------------------------------------\n\nTITLE: XML Tree Walking with iterwalk\nDESCRIPTION: Shows how to use iterwalk to traverse an in-memory XML tree, producing the same event sequence as iterparse without reparsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> context = etree.iterwalk(\n...             root, events=(\"start\", \"end\"), tag=\"element\")\n\n>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: element\nend: element\nstart: element\nend: element\n```\n\n----------------------------------------\n\nTITLE: Registering Element Classes with Namespaces in lxml\nDESCRIPTION: Shows how to register element classes with specific tag names in a namespace. The example demonstrates how to associate the 'honk' class with the 'honk' tag in the namespace.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnamespace['honk'] = honk\n```\n\n----------------------------------------\n\nTITLE: Event-based tree iteration in lxml.etree\nDESCRIPTION: Shows how to use etree.iterwalk() for event-based traversal of an XML tree, yielding 'start' and 'end' events for each element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.fromstring(\n...   \"<root> <a><b/><b/></a> <c><d/><e><f/></e><g/></c> </root>\")\n\n>>> tree_walker = etree.iterwalk(root, events=('start', 'end'))\n\n>>> for (event, element) in tree_walker:\n...     print(\"%s (%s)\" % (element.tag, event))\nroot (start)\na (start)\nb (start)\nb (end)\nb (start)\nb (end)\na (end)\nc (start)\nd (start)\nd (end)\ne (start)\nf (start)\nf (end)\ne (end)\ng (start)\ng (end)\nc (end)\nroot (end)\n```\n\n----------------------------------------\n\nTITLE: Creating a Schematron Validator in lxml.etree\nDESCRIPTION: Demonstrates how to create a Schematron validator by parsing a Schematron schema from a string and initializing the etree.Schematron class. Requires at least libxml2 2.6.21 to work.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('''\n... <schema xmlns=\"http://www.ascc.net/xml/schematron\" >\n...   <pattern name=\"Sum equals 100%.\">\n...     <rule context=\"Total\">\n...       <assert test=\"sum(//Percent)=100\">Sum is not 100%.</assert>\n...     </rule>\n...   </pattern>\n... </schema>\n... ''')\n\n>>> sct_doc = etree.parse(f)\n>>> schematron = etree.Schematron(sct_doc)\n```\n\n----------------------------------------\n\nTITLE: Handling Unicode Text in Serialization\nDESCRIPTION: Demonstrates how to handle non-ASCII characters during serialization by specifying appropriate encodings, including using 'unicode' for Python string output.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> br = next(root.iter('br'))  # get first result of iteration\n>>> br.tail = 'Wrld'\n\n>>> etree.tostring(root, method='text')  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xf6' ...\n\n>>> etree.tostring(root, method='text', encoding=\"UTF-8\")\nb'HelloW\\xc3\\xb6rld'\n\n>>> etree.tostring(root, encoding='unicode', method='text')\n'HelloWrld'\n>>> etree.tostring(root, encoding='unicode')\n'<html><head/><body><p>Hello<br/>Wrld</p></body></html>'\n```\n\n----------------------------------------\n\nTITLE: Handling Namespaces with Compiled XPath Expressions\nDESCRIPTION: Demonstrates how to handle namespaces when using the XPath class for compiled expressions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root xmlns='NS'><a><b/></a><b/></root>\")\n\n>>> find = etree.XPath(\"//n:b\", namespaces={'n':'NS'})\n>>> print(find(root)[0].tag)\n{NS}b\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Functions for hCard Parsing with lxml in Python\nDESCRIPTION: Four utility functions for extracting information from HTML elements with lxml: getting text by class name, getting element values, getting all texts with a specific class, and parsing address elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> def get_text(el, class_name):\n...     els = el.find_class(class_name)\n...     if els:\n...         return els[0].text_content()\n...     else:\n...         return ''\n>>> def get_value(el):\n...     return get_text(el, 'value') or el.text_content()\n>>> def get_all_texts(el, class_name):\n...     return [e.text_content() for e in els.find_class(class_name)]\n>>> def parse_addresses(el):\n...     # Ideally this would parse street, etc.\n...     return el.find_class('adr')\n```\n\n----------------------------------------\n\nTITLE: Creating Schematron with Multiple Validation Phases in Python\nDESCRIPTION: Demonstrates creating a Schematron validator with multiple validation phases that can be selectively activated. The example defines two patterns: one checking if percentages sum to 100, and another ensuring all percentages are positive.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('''\n... <schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n...   <phase id=\"phase.sum_check\">\n...     <active pattern=\"sum_equals_100_percent\"/>\n...   </phase>\n...   <phase id=\"phase.entries_check\">\n...     <active pattern=\"all_positive\"/>\n...   </phase>\n...   <pattern id=\"sum_equals_100_percent\">\n...     <title>Sum equals 100%.</title>\n...     <rule context=\"Total\">\n...       <assert test=\"sum(//Percent)=100\">Sum is not 100%.</assert>\n...     </rule>\n...   </pattern>\n...   <pattern id=\"all_positive\">\n...     <title>All entries must be positive.</title>\n...     <rule context=\"Percent\">\n...       <assert test=\"number(.)>0\">Number (<value-of select=\".\"/>) not positive</assert>\n...     </rule>\n...   </pattern>\n... </schema>\n... ''')\n\n>>> sct_doc = etree.parse(f)\n>>> schematron = isoschematron.Schematron(sct_doc)\n\n>>> valid = StringIO('''\n... <Total>\n...   <Percent>20</Percent>\n...   <Percent>30</Percent>\n...   <Percent>50</Percent>\n... </Total>\n... ''')\n\n>>> doc = etree.parse(valid)\n>>> schematron.validate(doc)\nTrue\n\n>>> invalid_positive = StringIO('''\n... <Total>\n...   <Percent>0</Percent>\n...   <Percent>50</Percent>\n...   <Percent>50</Percent>\n... </Total>\n... ''')\n\n>>> doc = etree.parse(invalid_positive)\n\n>>> schematron.validate(doc)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Using Wildcards in Element Iteration with Namespaces\nDESCRIPTION: Shows how to use wildcards (*) in element iterators to match any tag or any namespace, providing flexible element selection regardless of namespaces.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n>>> for el in xhtml.iter('*'): print(el.tag)   # any element\n{http://www.w3.org/1999/xhtml}html\n{http://www.w3.org/1999/xhtml}body\n\n>>> for el in xhtml.iter('{http://www.w3.org/1999/xhtml}*'): print(el.tag)\n{http://www.w3.org/1999/xhtml}html\n{http://www.w3.org/1999/xhtml}body\n\n>>> for el in xhtml.iter('{*}body'): print(el.tag)\n{http://www.w3.org/1999/xhtml}body\n```\n\n----------------------------------------\n\nTITLE: Finding Links by Rel Attribute\nDESCRIPTION: Demonstrates the find_rel_links method for searching links by their rel attribute. This is used to find elements like <a rel=\"tag\"> with case-insensitive matching.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> h = document_fromstring('''\n... <a href=\"1\">test 1</a>\n... <a href=\"2\" rel=\"tag\">item 2</a>\n... <a href=\"3\" rel=\"tagging\">item 3</a>\n... <a href=\"4\" rel=\"TAG\">item 4</a>''')\n>>> print([e.attrib['href'] for e in h.find_rel_links('tag')])\n['2', '4']\n>>> print([e.attrib['href'] for e in h.find_rel_links('nofollow')])\n[]\n```\n\n----------------------------------------\n\nTITLE: Adding SubElements to Objectify Trees\nDESCRIPTION: Demonstrates how to add subelements to objectify trees using SubElement(), and how elements inherit the objectify behavior from their parent tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> child = objectify.SubElement(obj_el, \"newchild\", attr=\"value\")\n\n>>> subel = objectify.SubElement(obj_el, \"sub\")\n>>> print(isinstance(subel, objectify.ObjectifiedElement))\nTrue\n\n>>> independent_el = etree.Element(\"new\")\n>>> print(isinstance(independent_el, objectify.ObjectifiedElement))\nFalse\n```\n\n----------------------------------------\n\nTITLE: Schema Validation with Objectify\nDESCRIPTION: Demonstrates how to validate XML documents against a schema using objectify, ensuring the expected object structure and types.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> f = StringIO('''\\\n...   <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n...     <xsd:element name=\"a\" type=\"AType\"/>\n...     <xsd:complexType name=\"AType\">\n...       <xsd:sequence>\n...         <xsd:element name=\"b\" type=\"xsd:string\" />\n...       </xsd:sequence>\n...     </xsd:complexType>\n...   </xsd:schema>\n... ''')\n>>> schema = etree.XMLSchema(file=f)\n\n>>> parser = objectify.makeparser(schema = schema)\n\n>>> xml = \"<a><b>test</b></a>\"\n>>> a = objectify.fromstring(xml, parser)\n\n>>> print(a.b)\ntest\n\n>>> xml = b\"<a><b>test</b><c/></a>\"\n>>> a = objectify.fromstring(xml, parser)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\nlxml.etree.XMLSyntaxError: Element 'c': This element is not expected...\n```\n\n----------------------------------------\n\nTITLE: Creating Elements with Namespaces Using ElementMaker\nDESCRIPTION: Example of creating Element objects with namespaces using the objectify.ElementMaker class. The example shows how to define namespaces and create a simple XML tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> myE = objectify.ElementMaker(annotate=False,\n...           namespace=\"http://my/ns\", nsmap={None : \"http://my/ns\"})\n\n>>> root = myE.root( myE.someint(2) )\n\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns=\"http://my/ns\">\n  <someint>2</someint>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Iteration and Slicing with XML Elements\nDESCRIPTION: Shows iteration and slicing operations on XML elements by tag name, including creating, accessing, and deleting elements by slice indices.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> x1 = objectify.SubElement(root, \"x\")\n>>> x2 = objectify.SubElement(root, \"x\")\n>>> x3 = objectify.SubElement(root, \"x\")\n\n>>> [ el.tag for el in root.x ]\n['x', 'x', 'x']\n\n>>> [ el.tag for el in root.x[1:3] ]\n['x', 'x']\n\n>>> [ el.tag for el in root.x[-1:] ]\n['x']\n\n>>> del root.x[1:2]\n>>> [ el.tag for el in root.x ]\n['x', 'x']\n```\n\n----------------------------------------\n\nTITLE: Accessing Element Siblings in lxml.etree\nDESCRIPTION: Demonstrates how to access an element's previous and next siblings using getprevious() and getnext() methods.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nroot[0] is root[1].getprevious() # lxml.etree only!\nroot[1] is root[0].getnext() # lxml.etree only!\n```\n\n----------------------------------------\n\nTITLE: Controlling Deannotation Options with xsi_nil in lxml.objectify\nDESCRIPTION: Shows how to control the removal of specific type attributes during deannotation with the 'pytype', 'xsi', and 'xsi_nil' parameters. The example demonstrates how null values are handled.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring('''\\\n... <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n...       xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n...   <d xsi:type=\"xsd:double\">5</d>\n...   <i xsi:type=\"xsd:int\"   >5</i>\n...   <s xsi:type=\"xsd:string\">5</s>\n...   <n xsi:nil=\"true\"/>\n... </root>''')\n>>> objectify.annotate(root)\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    d = 5.0 [FloatElement]\n      * py:pytype = 'float'\n      * xsi:type = 'xsd:double'\n    i = 5 [IntElement]\n      * py:pytype = 'int'\n      * xsi:type = 'xsd:int'\n    s = '5' [StringElement]\n      * py:pytype = 'str'\n      * xsi:type = 'xsd:string'\n    n = None [NoneElement]\n      * py:pytype = 'NoneType'\n      * xsi:nil = 'true'\n>>> objectify.deannotate(root, xsi_nil=True)\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    d = 5 [IntElement]\n    i = 5 [IntElement]\n    s = 5 [IntElement]\n    n = '' [StringElement]\n```\n\n----------------------------------------\n\nTITLE: Tree iteration methods in lxml.etree\nDESCRIPTION: Demonstrates different ways to iterate over XML trees in lxml, including iterating over children, descendants, and breadth-first traversal.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.fromstring(\n...   \"<root> <a><b/><b/></a> <c><d/><e><f/></e><g/></c> </root>\")\n\n>>> print([child.tag for child in root])   # children\n['a', 'c']\n\n>>> print([el.tag for el in root.iter()])  # self and descendants\n['root', 'a', 'b', 'b', 'c', 'd', 'e', 'f', 'g']\n\n>>> print([el.tag for el in root.iterdescendants()])\n['a', 'b', 'b', 'c', 'd', 'e', 'f', 'g']\n\n\n>>> def iter_breadth_first(root):\n...     bfs_queue = collections.deque([root])\n...     while bfs_queue:\n...         el = bfs_queue.popleft()  # pop next element\n...         bfs_queue.extend(el)      # append its children\n...         yield el\n\n>>> print([el.tag for el in iter_breadth_first(root)])\n['root', 'a', 'c', 'b', 'b', 'd', 'e', 'g', 'f']\n```\n\n----------------------------------------\n\nTITLE: Finding Element by ID\nDESCRIPTION: Shows how to use the get_element_by_id method to retrieve an element with a specific ID attribute, similar to the DOM getElementById function.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> print(tostring(fragment_fromstring('''\n... <div>\n...  <span id=\"test\">stuff</span>\n... </div>''').get_element_by_id('test'), encoding=unicode))\n<span id=\"test\">stuff</span>\n```\n\n----------------------------------------\n\nTITLE: Using Custom Targets with XMLPullParser in lxml.etree\nDESCRIPTION: Shows how to combine XMLPullParser with a custom parser target that generates event values. This allows for complete customization of how XML parsing events are handled and transformed.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Target(object):\n    def start(self, tag, attrib):\n        print('-> start(%s)' % tag)\n        return '>>START: %s<<' % tag\n    def end(self, tag):\n        print('-> end(%s)' % tag)\n        return '>>END: %s<<' % tag\n    def close(self):\n        print('-> close()')\n        return \"CLOSED!\"\n\nevent_types = ('start', 'end')\nparser = etree.XMLPullParser(event_types, target=Target())\n\nparser.feed('<root><child1 /><child2 /></root>')\n\nfor action, value in parser.read_events():\n    print('%s: %s' % (action, value))\n\nprint(parser.close())\n```\n\n----------------------------------------\n\nTITLE: Implementing XPath Extension Functions with Various Return Types\nDESCRIPTION: Shows how to implement XPath extension functions that return different data types (float, integer, boolean, node) and how lxml handles these return values in XPath expressions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef returnsFloat(_):\n   return 1.7\ndef returnsInteger(_):\n   return 1\ndef returnsBool(_):\n   return True\ndef returnFirstNode(_, nodes):\n   return nodes[0]\n\nns = etree.FunctionNamespace(None)\nns['float'] = returnsFloat\nns['int']   = returnsInteger\nns['bool']  = returnsBool\nns['first'] = returnFirstNode\n\ne = etree.XPathEvaluator(doc)\ne(\"float()\")\ne(\"int()\")\nint( e(\"int()\") )\ne(\"bool()\")\ne(\"count(first(//b))\")\n```\n\n----------------------------------------\n\nTITLE: Checking Text Node Types from XPath Results\nDESCRIPTION: Demonstrates how to check whether XPath text results are normal text content or tail text using the is_text and is_tail properties of text nodes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> print(texts[0].is_text)\nTrue\n>>> print(texts[1].is_text)\nFalse\n>>> print(texts[1].is_tail)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating XML with ElementMaker in lxml\nDESCRIPTION: Shows how to use the ElementMaker (E-factory) to construct XML documents in a Pythonic way. This example creates an Atom feed with namespace configuration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.builder import ElementMaker\n>>> A = ElementMaker(namespace=\"http://www.w3.org/2005/Atom\",\n...                  nsmap={None : \"http://www.w3.org/2005/Atom\"})\n```\n\n----------------------------------------\n\nTITLE: Setting up the lxml.objectify Environment\nDESCRIPTION: Demonstrates how to import and set up the necessary modules for using lxml.objectify functionality, including etree and objectify modules.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml import etree\n>>> from lxml import objectify\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespace-Specific Class Lookup in lxml.objectify\nDESCRIPTION: Demonstrates how to combine the objectify lookup with namespace-specific lookups. This allows for custom element classes based on namespaces while maintaining objectify functionality.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n>>> lookup = etree.ElementNamespaceClassLookup(\n...                   objectify.ObjectifyElementClassLookup() )\n>>> parser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Using iterchildren() for Element Iteration\nDESCRIPTION: Demonstrates how to use the iterchildren() method to iterate over all children or filter by tag name, providing more control than direct attribute access.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> [ el.tag for el in root.iterchildren() ]\n['b', 'x', 'x']\n\n>>> [ el.tag for el in root.iterchildren(tag='b') ]\n['b']\n\n>>> [ el.tag for el in root.b ]\n['b']\n```\n\n----------------------------------------\n\nTITLE: Generating ElementPath Expressions\nDESCRIPTION: Demonstrates how to generate and use structural ElementPath expressions to identify specific elements in an XML tree. Shows path generation for different elements and verification of the generated paths.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_57\n\nLANGUAGE: python\nCODE:\n```\n>>> tree = etree.ElementTree(root)\n>>> a = root[0]\n>>> print(tree.getelementpath(a[0]))\na/b[1]\n>>> print(tree.getelementpath(a[1]))\na/c\n>>> print(tree.getelementpath(a[2]))\na/b[2]\n>>> tree.find(tree.getelementpath(a[2])) == a[2]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using XMLSchema in Conditional Statements in Python\nDESCRIPTION: Shows how to use the callable interface of the XMLSchema object in conditional statements. This is a more concise way to perform validation checks.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> invalid = StringIO('<a><c></c></a>')\n>>> doc2 = etree.parse(invalid)\n>>> if not xmlschema(doc2):\n...     print(\"invalid!\")\ninvalid!\n```\n\n----------------------------------------\n\nTITLE: Implementing Namespaces with Element Classes in lxml\nDESCRIPTION: Shows how to associate element classes with namespaces using ElementNamespaceClassLookup. The example demonstrates registering a class for a specific namespace and tag name.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nlookup = etree.ElementNamespaceClassLookup()\nparser = etree.XMLParser()\nparser.set_element_class_lookup(lookup)\n\nnamespace = lookup.get_namespace('http://hui.de/honk')\n```\n\n----------------------------------------\n\nTITLE: Attribute Based Element Class Lookup in lxml\nDESCRIPTION: Shows how to implement AttributeBasedElementClassLookup to associate element classes based on attribute values. The example maps the 'id' attribute values to custom element classes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nid_class_mapping = {'1234' : honk} # maps attribute values to classes\n\nlookup = etree.AttributeBasedElementClassLookup(\n                                 'id', id_class_mapping)\nparser = etree.XMLParser()\nparser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Preserving CDATA Sections in lxml XML Parsing\nDESCRIPTION: This snippet demonstrates how to configure the lxml XMLParser to preserve CDATA sections in the parsed XML document. It shows how to create a parser with strip_cdata=False and use it to parse XML content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser(strip_cdata=False)\n>>> root = etree.XML('<root><![CDATA[test]]></root>', parser)\n>>> root.text\n'test'\n\n>>> etree.tostring(root)\nb'<root><![CDATA[test]]></root>'\n```\n\n----------------------------------------\n\nTITLE: Removing Whitespace Text in XML Elements in Python\nDESCRIPTION: Shows how to traverse an XML tree and remove whitespace text from leaf elements. This example builds upon the previous parser example and demonstrates iterating over all elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> for element in root.iter(\\\"*\\\"):\n...     if element.text is not None and not element.text.strip():\n...         element.text = None\n\n>>> etree.tostring(root)\nb'<root><a/><b/></root>'\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Data Classes in lxml.objectify\nDESCRIPTION: Shows how to create custom data classes that integrate with objectify's type system. Demonstrates defining a class, creating type checks, and registering it with PyType.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_45\n\nLANGUAGE: python\nCODE:\n```\n>>> class ChristmasDate(objectify.ObjectifiedDataElement):\n...     def call_santa(self):\n...         print(\"Ho ho ho!\")\n\n>>> def checkChristmasDate(date_string):\n...     if not date_string.startswith('24.12.'):\n...         raise ValueError # or TypeError\n\n>>> xmas_type = objectify.PyType('date', checkChristmasDate, ChristmasDate)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Clark notation for XML namespaces in lxml\nDESCRIPTION: Shows how to create an XML element with a namespaced tag using Clark notation in lxml. The namespace URI is wrapped in curly braces and prepended to the tag name.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> tag = \"{http://www.w3.org/the/namespace}tagname\"\n>>> element = etree.Element(tag)\n```\n\n----------------------------------------\n\nTITLE: Global Prefix Assignment for FunctionNamespace\nDESCRIPTION: This snippet shows how to assign a global prefix to a FunctionNamespace, allowing the use of extension functions without specifying the prefix in each XPath call.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nns = etree.FunctionNamespace('http://mydomain.org/myother/functions')\nns.prefix = 'es'\nns['hello'] = ola\n\nprint(root.xpath('es:hello(local-name(*)'))\n```\n\n----------------------------------------\n\nTITLE: Inheriting Namespace Mappings in Child Elements\nDESCRIPTION: Demonstrates how namespace mappings are inherited from parent elements, with child elements having access to all namespaces defined by their ancestors.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.Element('root', nsmap={'a': 'http://a.b/c'})\n>>> child = etree.SubElement(root, 'child',\n...                          nsmap={'b': 'http://b.c/d'})\n>>> len(root.nsmap)\n1\n>>> len(child.nsmap)\n2\n>>> child.nsmap['a']\n'http://a.b/c'\n>>> child.nsmap['b']\n'http://b.c/d'\n```\n\n----------------------------------------\n\nTITLE: Manipulating Trees with ObjectPath\nDESCRIPTION: Demonstrates how to use ObjectPath objects to manipulate XML trees, including setting attributes, adding children, and working with lists.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"{http://ns/}root\")\n\n>>> path = objectify.ObjectPath(\".some.child.{http://other/}unknown\")\n>>> path.hasattr(root)\nFalse\n>>> path.find(root)\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: {http://ns/}some\n\n>>> path.setattr(root, \"my value\") # creates children as necessary\n>>> path.hasattr(root)\nTrue\n>>> print(path.find(root).text)\nmy value\n>>> print(root.some.child[\"{http://other/}unknown\"].text)\nmy value\n\n>>> print(len( path.find(root) ))\n1\n>>> path.addattr(root, \"my new value\")\n>>> print(len( path.find(root) ))\n2\n>>> [ el.text for el in path.find(root) ]\n['my value', 'my new value']\n\n>>> path.setattr(root, [\"v1\", \"v2\", \"v3\"])\n>>> [ el.text for el in path.find(root) ]\n['v1', 'v2', 'v3']\n\n>>> path = objectify.ObjectPath(\".{non}existing[1]\")\n>>> path.setattr(root, \"my value\")\nTraceback (most recent call last):\n  ...\nTypeError: creating indexed path attributes is not supported\n```\n\n----------------------------------------\n\nTITLE: Implementing Breadth-First XML Tree Traversal\nDESCRIPTION: Demonstrates how to perform a breadth-first traversal of an XML tree using a deque from the collections module.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.XML('<root><a><b/><c/></a><d><e/></d></root>')\nprint(etree.tostring(root, pretty_print=True, encoding='unicode'))\n\nfrom collections import deque\nqueue = deque([root])\nwhile queue:\n   el = queue.popleft()  # pop next element\n   queue.extend(el)      # append its children\n   print(el.tag)\n```\n\n----------------------------------------\n\nTITLE: Profiling XSLT Transformations in Python with lxml.etree\nDESCRIPTION: This snippet demonstrates how to enable profiling for XSLT transformations and access the profiling data. It shows how to use the profile_run parameter and access the xslt_profile property.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> result = transform(doc, a=\"/a/b/text()\", profile_run=True)\n>>> profile = result.xslt_profile\n\n>>> del result.xslt_profile\n```\n\n----------------------------------------\n\nTITLE: Displaying HTML Document Structure using prettyprint\nDESCRIPTION: Shows how to display a formatted HTML document structure with proper indentation and tag hierarchy.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_54\n\nLANGUAGE: python\nCODE:\n```\n>>> prettyprint(page)\n<html>\n  <head>\n    <title>This is a sample document</title>\n  </head>\n  <body>\n    <h1 class=\"title\">Hello!</h1>\n    <p>This is a paragraph with <b>bold</b> text in it!</p>\n    <p>This is another paragraph, with a\n      <a href=\"http://www.python.org\">link</a>.</p>\n    <p>Here are some reserved characters: &lt;spam&amp;egg&gt;.</p>\n    <p>And finally an embedded XHTML fragment.</p>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using Regular Expressions in XPath via EXSLT\nDESCRIPTION: Shows how to use EXSLT regular expression functions within XPath expressions in lxml.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> regexpNS = \"http://exslt.org/regular-expressions\"\n>>> find = etree.XPath(\"//*[re:test(., '^abc$', 'i')]\",\n...                    namespaces={'re':regexpNS})\n\n>>> root = etree.XML(\"<root><a>aB</a><b>aBc</b></root>\")\n>>> print(find(root)[0].text)\naBc\n```\n\n----------------------------------------\n\nTITLE: Using QName Helper Class for XML Namespace Handling\nDESCRIPTION: Demonstrates the QName class which helps build or split qualified tag names, extracting namespace and local name components from Clark notation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n>>> tag = etree.QName('http://www.w3.org/1999/xhtml', 'html')\n>>> print(tag.localname)\nhtml\n>>> print(tag.namespace)\nhttp://www.w3.org/1999/xhtml\n>>> print(tag.text)\n{http://www.w3.org/1999/xhtml}html\n\n>>> tag = etree.QName('{http://www.w3.org/1999/xhtml}html')\n>>> print(tag.localname)\nhtml\n>>> print(tag.namespace)\nhttp://www.w3.org/1999/xhtml\n\n>>> root = etree.Element('{http://www.w3.org/1999/xhtml}html')\n>>> tag = etree.QName(root)\n>>> print(tag.localname)\nhtml\n\n>>> tag = etree.QName(root, 'script')\n>>> print(tag.text)\n{http://www.w3.org/1999/xhtml}script\n>>> tag = etree.QName('{http://www.w3.org/1999/xhtml}html', 'script')\n>>> print(tag.text)\n{http://www.w3.org/1999/xhtml}script\n```\n\n----------------------------------------\n\nTITLE: Finding Elements in Specific Namespaces or with No Namespace\nDESCRIPTION: Demonstrates how to specifically look for elements with or without namespaces, using either the plain tag name or explicitly specifying an empty namespace.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_52\n\nLANGUAGE: python\nCODE:\n```\n>>> [ el.tag for el in xhtml.iter('{http://www.w3.org/1999/xhtml}body') ]\n['{http://www.w3.org/1999/xhtml}body']\n>>> [ el.tag for el in xhtml.iter('body') ]\n[]\n>>> [ el.tag for el in xhtml.iter('{}body') ]\n[]\n>>> [ el.tag for el in xhtml.iter('{}*') ]\n[]\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Attribute Filter with TreeBuilder in lxml.etree\nDESCRIPTION: Demonstrates how to create a custom TreeBuilder that filters attributes during XML parsing. This example removes any attribute named 'evil' from elements as they're being parsed.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass AttributeFilter(etree.TreeBuilder):\n    def start(self, tag, attrib):\n        attrib = dict(attrib)\n        if 'evil' in attrib:\n            del attrib['evil']\n        return super(AttributeFilter, self).start(tag, attrib)\n\nparser = etree.XMLPullParser(target=AttributeFilter())\nparser.feed('<root><child1 test=\"123\" /><child2 evil=\"YES\" /></root>')\n\nfor action, element in parser.read_events():\n    print('%s: %s(%r)' % (action, element.tag, element.attrib))\n\nroot = parser.close()\n```\n\n----------------------------------------\n\nTITLE: Using ObjectPath for Tree Navigation\nDESCRIPTION: Introduction to ObjectPath, a custom path language for convenient element navigation in objectify trees. Shows basic path expressions and element finding.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"{http://ns/}root\")\n>>> b1 = objectify.SubElement(root, \"{http://ns/}b\")\n>>> c  = objectify.SubElement(b1,   \"{http://ns/}c\")\n>>> b2 = objectify.SubElement(root, \"{http://ns/}b\")\n>>> d  = objectify.SubElement(root, \"{http://other/}d\")\n\n>>> path = objectify.ObjectPath(\"root.b.c\")\n>>> print(path)\nroot.b.c\n>>> path.hasattr(root)\nTrue\n>>> print(path.find(root).tag)\n{http://ns/}c\n\n>>> find = objectify.ObjectPath(\"root.b.c\")\n>>> print(find(root).tag)\n{http://ns/}c\n\n>>> find = objectify.ObjectPath(\"root.{http://other/}d\")\n>>> print(find(root).tag)\n{http://other/}d\n\n>>> find = objectify.ObjectPath(\"root.{not}there\")\n>>> print(find(root).tag)\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: {not}there\n\n>>> find = objectify.ObjectPath(\"{not}there\")\n>>> print(find(root).tag)\nTraceback (most recent call last):\n  ...\nValueError: root element does not match: need {not}there, got {http://ns/}root\n\n>>> find = objectify.ObjectPath(\"root.b[1]\")\n>>> print(find(root).tag)\n{http://ns/}b\n\n>>> find = objectify.ObjectPath(\"root.{http://ns/}b[1]\")\n>>> print(find(root).tag)\n{http://ns/}b\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Parser for lxml.objectify\nDESCRIPTION: Demonstrates how to create a custom parser for objectify documents that removes whitespace-only text. This is useful for data-centric XML as opposed to document XML with mixed content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = objectify.makeparser(remove_blank_text=True)\n```\n\n----------------------------------------\n\nTITLE: Microformat Parsing Example with Python and lxml\nDESCRIPTION: This example shows how to parse hCard microformat data from an HTML page using lxml. It defines classes to store the parsed data and demonstrates fetching and parsing a web page.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n>>> import urllib\n>>> from lxml.html import fromstring\n>>> url = 'http://microformats.org/'\n>>> content = urllib.urlopen(url).read()\n>>> doc = fromstring(content)\n>>> doc.make_links_absolute(url)\n\n>>> class Card(object):\n...     def __init__(self, **kw):\n...         for name, value in kw:\n...             setattr(self, name, value)\n>>> class Phone(object):\n...     def __init__(self, phone, types=()):\n...         self.phone, self.types = phone, types\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Element Class in Python for lxml\nDESCRIPTION: Example of defining a custom Element class by inheriting from etree.ElementBase. The class adds a 'honking' property that checks if the 'honking' attribute equals 'true'.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml import etree\n\nclass honk(etree.ElementBase):\n   @property\n   def honking(self):\n      return self.get('honking') == 'true'\n```\n\n----------------------------------------\n\nTITLE: Read-Ahead Generator for Safe XML Tree Modification During Iteration in Python\nDESCRIPTION: This code defines a read-ahead generator that allows safe modification of an XML tree during iteration. It uses a deque to buffer elements, preventing issues with concurrent modification.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom itertools import islice\nfrom collections import deque\n\ndef readahead(iterator, count=1):\n    iterator = iter(iterator)  # allow iterables as well\n    elements = deque(islice(iterator, 0, count))\n    for element in iterator:\n        elements.append(element)\n        yield elements.popleft()\n    yield from elements\n\nfor element in readahead(root.iterfind(\"path/to/children\")):\n    element.getparent().remove(element)\n```\n\n----------------------------------------\n\nTITLE: Smart Strings in XPath Results\nDESCRIPTION: Demonstrates the 'smart' string feature where string results from XPath queries include a getparent() method that allows accessing the parent Element. Shows how to disable this behavior when needed.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><a>TEXT</a></root>\")\n\n>>> find_text = etree.XPath(\"//text()\")\n>>> text = find_text(root)[0]\n>>> print(text)\nTEXT\n>>> print(text.getparent().text)\nTEXT\n\n>>> find_text = etree.XPath(\"//text()\", smart_strings=False)\n>>> text = find_text(root)[0]\n>>> print(text)\nTEXT\n>>> hasattr(text, 'getparent')\nFalse\n```\n\n----------------------------------------\n\nTITLE: Handling Comments and Processing Instructions in XMLPullParser\nDESCRIPTION: Demonstrates how to parse and process XML comments and processing instructions using additional event types in XMLPullParser. This extends beyond ElementTree's capability.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nevent_types = (\"start\", \"end\", \"comment\", \"pi\")\nparser = etree.XMLPullParser(event_types)\n\nparser.feed('<?some pi ?><!-- a comment --><root>')\nparser.feed('<element key=\"value\">text</element>')\nparser.feed('<!-- another comment -->')\nparser.feed('<element>text</element>tail')\nparser.feed('<empty-element xmlns=\"http://testns/\" />')\nparser.feed('</root>')\n\nfor action, elem in parser.read_events():\n    if action in ('start', 'end'):\n        print(\"%s: %s\" % (action, elem.tag))\n    elif action == 'pi':\n        print(\"%s: -%s=%s-\" % (action, elem.target, elem.text))\n    else: # 'comment'\n        print(\"%s: -%s-\" % (action, elem.text))\n\nroot = parser.close()\nprint(root.tag)\n```\n\n----------------------------------------\n\nTITLE: Python Data Types in Objectify\nDESCRIPTION: Shows how objectify handles Python data types, allowing element content to behave like native Python types with support for math operations and other type-specific behavior.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\n...             \"<root><a>5</a><b>11</b><c>true</c><d>hoi</d></root>\")\n>>> root.a + root.b\n16\n>>> root.a += root.b\n>>> print(root.a)\n16\n\n>>> root.a = 2\n>>> print(root.a + 2)\n4\n>>> print(1 + root.a)\n3\n\n>>> print(root.c)\nTrue\n>>> root.c = False\n>>> if not root.c:\n...     print(\"false!\")\nfalse!\n\n>>> print(root.d + \" test !\")\nhoi test !\n>>> root.d = \"%s - %s\"\n>>> print(root.d % (1234, 12345))\n1234 - 12345\n```\n\n----------------------------------------\n\nTITLE: Using TreeBuilder as a Parser Target in lxml\nDESCRIPTION: Demonstrates how to use the built-in TreeBuilder as a parser target to construct an XML tree programmatically during parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser(target = etree.TreeBuilder())\n\n>>> result = etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\n\n>>> print(result.tag)\nelement\n>>> print(result[0].text)\ncomment\n```\n\n----------------------------------------\n\nTITLE: Custom SAX Content Handler Implementation\nDESCRIPTION: Example of a custom SAX ContentHandler that tracks element occurrences and text content. Implements namespace-aware processing through startElementNS method.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/sax.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom xml.sax.handler import ContentHandler\nclass MyContentHandler(ContentHandler):\n    def __init__(self):\n        self.a_amount = 0\n        self.b_amount = 0\n        self.text = None\n\n    def startElementNS(self, name, qname, attributes):\n        uri, localname = name\n        if localname == 'a':\n            self.a_amount += 1\n        if localname == 'b':\n            self.b_amount += 1\n\n    def characters(self, data):\n        self.text = data\n```\n\n----------------------------------------\n\nTITLE: Filtering XML Parse Events by Tag in lxml.etree\nDESCRIPTION: Shows how to use the tag parameter to filter parse events and only process elements with specific tags or namespaces. This helps focus processing on relevant parts of the XML.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nparser = etree.XMLPullParser(tag=\"element\")\n\nparser.feed('<root><element key=\"value\">text</element>')\nparser.feed('<element><child /></element>')\nparser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\n\nfor action, elem in parser.read_events():\n    print(\"%s: %s\" % (action, elem.tag))\n\nevent_types = (\"start\", \"end\")\nparser = etree.XMLPullParser(event_types, tag=\"{http://testns/}*\")\n\nparser.feed('<root><element key=\"value\">text</element>')\nparser.feed('<element><child /></element>')\nparser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\n\nfor action, elem in parser.read_events():\n    print(\"%s: %s\" % (action, elem.tag))\n```\n\n----------------------------------------\n\nTITLE: Accessing Real Python Values from ObjectifiedElements in Python\nDESCRIPTION: This snippet demonstrates how to access the real Python values from ObjectifiedElements using the .text and .pyval attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"<root><a>test</a><b>5</b></root>\")\n>>> root.a.text\n'test'\n>>> root.a.pyval\n'test'\n\n>>> root.b.text\n'5'\n>>> root.b.pyval\n5\n```\n\n----------------------------------------\n\nTITLE: C14N XML Canonicalization with lxml\nDESCRIPTION: Example of converting XML to its canonical form using lxml's canonicalize() function.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> c14n_xml = etree.canonicalize(\"<root><test z='1' y='2'/></root>\")\n>>> print(c14n_xml)\n<root><test y=\"2\" z=\"1\"></test></root>\n```\n\n----------------------------------------\n\nTITLE: Serializing XML with tostring function\nDESCRIPTION: Shows how to convert an XML Element tree to a string representation with pretty_print formatting. Used to display the generated Atom feed.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.etree import tostring\n>>> print( tostring(atom, pretty_print=True) )\n```\n\n----------------------------------------\n\nTITLE: Using Assertion Methods with XMLSchema in Python\nDESCRIPTION: Demonstrates the use of assert_ and assertValid methods that raise exceptions on validation errors rather than returning a boolean. This is useful when you want validation errors to be treated as exceptions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> xmlschema.assertValid(doc2)\nTraceback (most recent call last):\n  ...\nlxml.etree.DocumentInvalid: Element 'c': This element is not expected. Expected is ( b )., line 1\n\n>>> xmlschema.assert_(doc2)\nTraceback (most recent call last):\n  ...\nAssertionError: Element 'c': This element is not expected. Expected is ( b )., line 1\n```\n\n----------------------------------------\n\nTITLE: Sorting XML Element Attributes in Python using lxml\nDESCRIPTION: This function recursively sorts the attributes of all elements in an XML tree by name. It clears the existing attributes and updates them with the sorted version.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef sort_attributes(root):\n    for el in root.iter():\n        attrib = el.attrib\n        if len(attrib) > 1:\n            attributes = sorted(attrib.items())\n            attrib.clear()\n            attrib.update(attributes)\n```\n\n----------------------------------------\n\nTITLE: Assigning Subtrees to Element Attributes\nDESCRIPTION: Demonstrates how to assign XML subtrees to object attributes, which automatically deep copies the tree and updates the tag name accordingly.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> el = objectify.Element(\"yet_another_child\")\n>>> root.new_child = el\n>>> print(root.new_child.tag)\nnew_child\n>>> print(el.tag)\nyet_another_child\n\n>>> root.y = [ objectify.Element(\"y\"), objectify.Element(\"y\") ]\n>>> [ el.tag for el in root.y ]\n['y', 'y']\n```\n\n----------------------------------------\n\nTITLE: Using iterparse() for XML Parsing with ElementTree\nDESCRIPTION: An implementation that uses ElementTree's iterparse() to efficiently search for verses containing 'begat' in a large XML file. This approach reduces memory usage by clearing processed elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef bench_ET_iterparse():\n    result = []\n    for event, v in ElementTree.iterparse(\"ot.xml\"):\n        if v.tag == 'v':\n            text = v.text\n            if 'begat' in text:\n                result.append(text)\n        v.clear()\n    return len(result)\n```\n\n----------------------------------------\n\nTITLE: Working with Read-Only Elements in XSLT Extensions\nDESCRIPTION: Demonstrates how to handle read-only elements in XSLT extensions by using deepcopy to create modifiable copies. This allows the extension to modify the elements before adding them to the output.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom copy import deepcopy\nclass MyExtElement(etree.XSLTExtension):\n    def execute(self, context, self_node, input_node, output_parent):\n        child = deepcopy(self_node[0])\n        child.text = \"NEW TEXT\"\n        output_parent.append(child)\n\nmy_extension = MyExtElement()\nextensions = { ('testns', 'ext') : my_extension }\ntransform = etree.XSLT(xslt_ext_tree, extensions = extensions)\n\nroot = etree.XML('<dummy/>')\nresult = transform(root)\nstr(result)\n```\n\n----------------------------------------\n\nTITLE: Using Evaluator-Local Extension Functions\nDESCRIPTION: This snippet shows how to use extension functions that are local to a specific evaluator or XSLT transformation. It demonstrates passing extensions as a dictionary and using the Extension helper for larger sets of functions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nextensions = {('local-ns', 'local-hello') : hello}\nnamespaces = {'l' : 'local-ns'}\n\ne = etree.XPathEvaluator(doc, namespaces=namespaces, extensions=extensions)\nprint(e('l:local-hello(string(b))'))\n\nclass MyExt:\n    def function1(self, _, arg):\n        return '1'+arg\n    def function2(self, _, arg):\n        return '2'+arg\n    def function3(self, _, arg):\n        return '3'+arg\n\next_module = MyExt()\nfunctions = ('function1', 'function2')\nextensions = etree.Extension( ext_module, functions, ns='local-ns' )\n\ne = etree.XPathEvaluator(doc, namespaces=namespaces, extensions=extensions)\nprint(e('l:function1(string(b))'))\n```\n\n----------------------------------------\n\nTITLE: Manipulating Element Classes with Set-like Interface\nDESCRIPTION: Shows how to use the classes property to manipulate element classes with a set-like interface. Demonstrates operations like adding, removing, checking membership, updating, and clearing CSS classes on an element.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> el = fragment_fromstring('<span class=\"foo bar\"></span>')\n>>> 'foo' in el.classes\nTrue\n>>> 'f00' in el.classes\nFalse\n>>> el.classes.update(('qux', 'quux'))\n>>> sorted(el.get('class').split())\n['bar', 'foo', 'quux', 'qux']\n>>> el.classes.clear()\n>>> el.get('class')\n>>> list(el.classes)\n[]\n>>> el.classes.add('a')\n>>> el.classes.add('b')\n>>> el.classes.remove('a')\n>>> el.classes.remove('c')\nTraceback (most recent call last):\n...\nKeyError: 'c'\n>>> el.classes.discard('c')\n>>> el.get('class')\n'b'\n>>> el.classes.add('b')\n>>> el.get('class')\n'b'\n>>> el.classes |= ('a', 'b')\n>>> el.get('class')\n'b a'\n>>> el.classes -= ('b', 'c', 'd')\n>>> el.get('class')\n'a'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating XML Element Text and Tail Properties\nDESCRIPTION: Example showing how text and tail properties work in lxml Elements, illustrating that the tail is part of the Element's serialized output even though it appears after the closing tag.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.Element(\"test\")\n\n>>> root.text = \"TEXT\"\n>>> print(etree.tostring(root))\n<test>TEXT</test>\n\n>>> root.tail = \"TAIL\"\n>>> print(etree.tostring(root))\n<test>TEXT</test>TAIL\n\n>>> root.tail = None\n>>> print(etree.tostring(root))\n<test>TEXT</test>\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Parser Target for SAX-like Events\nDESCRIPTION: Demonstrates how to use the target parser interface to generate SAX-like events by implementing methods that get called during parsing, avoiding tree building altogether.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n>>> class ParserTarget:\n...     events = []\n...     close_count = 0\n...     def start(self, tag, attrib):\n...         self.events.append((\"start\", tag, attrib))\n...     def close(self):\n...         events, self.events = self.events, []\n...         self.close_count += 1\n...         return events\n\n>>> parser_target = ParserTarget()\n\n>>> parser = etree.XMLParser(target=parser_target)\n>>> events = etree.fromstring('<root test=\"true\"/>', parser)\n\n>>> print(parser_target.close_count)\n1\n\n>>> for event in events:\n...     print(f'event: {event[0]} - tag: {event[1]}')\n...     for attr, value in event[2].items():\n...         print(f' * {attr} = {value}')\nevent: start - tag: root\n * test = true\n```\n\n----------------------------------------\n\nTITLE: Combining Feed Parser with Target Parser in lxml\nDESCRIPTION: Example of using both the feed parser interface and a custom target object together for incremental, event-based XML parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser(target = EchoTarget())\n\n>>> parser.feed(\"<eleme\")\n>>> parser.feed(\"nt>some text</elem\")\nstart element {}\ndata 'some text'\n>>> parser.feed(\"ent>\")\nend element\n\n>>> result = parser.close()\nclose\n>>> print(result)\nclosed!\n```\n\n----------------------------------------\n\nTITLE: Multiple Input Form Filling in Python using lxml\nDESCRIPTION: Shows how to fill multiple input fields with the same name using an array of values.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_formfill.txt#2025-04-16_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fill_form_html('''\n... <form>\n...   <input type=\"text\" name=\"foo\">\n...   <input type=\"text\" name=\"foo\">\n... </form>''', dict(foo=['bar1', 'bar2'])))\n<form>\n  <input type=\"text\" name=\"foo\" value=\"bar1\">\n  <input type=\"text\" name=\"foo\" value=\"bar2\">\n</form>\n```\n\n----------------------------------------\n\nTITLE: Creating an XML Generator Module for Atom\nDESCRIPTION: Illustrates how to build a dedicated module for generating Atom XML documents. This approach provides better 'type safety' by exposing only valid element names as functions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# atomgen.py\n\nfrom lxml import etree\nfrom lxml.builder import ElementMaker\n\nATOM_NAMESPACE = \"http://www.w3.org/2005/Atom\"\n\nA = ElementMaker(namespace=ATOM_NAMESPACE,\n                 nsmap={None : ATOM_NAMESPACE})\n\nfeed = A.feed\nentry = A.entry\ntitle = A.title\n# ... and so on and so forth ...\n\n\n# plus a little validation function: isvalid()\nisvalid = etree.RelaxNG(file=\"atom.rng\")\n```\n\n----------------------------------------\n\nTITLE: Handling Disabled Form Inputs with lxml.html in Python\nDESCRIPTION: This snippet shows how lxml.html handles disabled form inputs. It demonstrates that disabled inputs are not included in the form's fields collection.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_forms.txt#2025-04-16_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> import lxml.html\n>>> tree = lxml.html.fromstring('''\n... <html><body>\n...  <form>\n...   <input name=\"foo\" value=\"bar\" disabled/>\n...   <input type=\"submit\" />\n...  </form>\n... </body></html>\n... ''')\n>>> tree # doctest: +ELLIPSIS\n<Element html at ...>\n>>> tree.forms[0] # doctest: +ELLIPSIS\n<Element form at ...>\n>>> tree.forms[0].fields # doctest: +NOPARSE_MARKUP\n<FieldsDict for form 0>\n>>> len(tree.forms[0].fields)\n2\n>>> list(tree.forms[0].fields.keys())\n['foo']\n>>> list(tree.forms[0].fields.items())\n[('foo', 'bar')]\n>>> list(tree.forms[0].fields.values())\n['bar']\n\n>>> ('foo', 'bar') not in tree.forms[0].form_values()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Deep Copies of Elements in lxml.etree\nDESCRIPTION: Shows how to create independent deep copies of elements using Python's deepcopy function.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom copy import deepcopy\n\nelement = etree.Element(\"neu\")\nelement.append( deepcopy(root[1]) )\n\nprint(element[0].tag)\nprint([ c.tag for c in root ])\n```\n\n----------------------------------------\n\nTITLE: Custom Event Selection with iterparse() in Python\nDESCRIPTION: Demonstrates how to control which events are generated by iterparse() using the events parameter. Shows both start and end events for each element, giving more control over the parsing process.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> some_file_like = BytesIO(b\\\"<root><a>data</a></root>\\\")\n\n>>> for event, element in etree.iterparse(some_file_like,\n...                                       events=(\\\"start\\\", \\\"end\\\")):\n...     print(f\\\"{event:>5}, {element.tag:>4}, {element.text}\\\")\nstart, root, None\nstart,    a, data\n  end,    a, data\n  end, root, None\n```\n\n----------------------------------------\n\nTITLE: Using DataElement Factory for Creating Typed Elements in lxml.objectify\nDESCRIPTION: Demonstrates the DataElement factory which creates Element objects with Python values in one step. Shows how to set type attributes using _pytype and _xsi parameters.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"root\")\n>>> root.x = objectify.DataElement(5, _pytype=\"int\")\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    x = 5 [IntElement]\n      * py:pytype = 'int'\n\n>>> root.x = objectify.DataElement(5, _pytype=\"str\", myattr=\"someval\")\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    x = '5' [StringElement]\n      * myattr = 'someval'\n      * py:pytype = 'str'\n\n>>> root.x = objectify.DataElement(5, _xsi=\"integer\")\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    x = 5 [IntElement]\n      * py:pytype = 'int'\n      * xsi:type = 'xsd:integer'\n```\n\n----------------------------------------\n\nTITLE: Using XPath in lxml for Text Content Filtering\nDESCRIPTION: An implementation using lxml's XPath capabilities to directly filter elements by text content. This compact approach uses a single XPath expression to find all verses containing 'begat'.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef bench_lxml_xpath_all():\n    tree = etree.parse(\"ot.xml\")\n    result = tree.xpath(\"//v[contains(., 'begat')]/text()\")\n    return len(result)\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML with HTMLParser in lxml\nDESCRIPTION: Shows how to parse HTML data using the etree.HTMLParser with configuration options. The remove_comments parameter is used to strip comments from the parsed document.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.HTMLParser(remove_comments=True)\n>>> root_element = etree.fromstring(some_html_data, parser)\n```\n\n----------------------------------------\n\nTITLE: Registering and Using XSLT Extension Elements\nDESCRIPTION: Demonstrates how to register a custom extension element with an XSLT transformer and use it in a transformation. The example shows creating an instance of the extension, mapping it to a namespace and element name, and applying it.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmy_extension = MyExtElement()\nextensions = { ('testns', 'ext') : my_extension }\ntransform = etree.XSLT(xslt_ext_tree, extensions = extensions)\n\nroot = etree.XML('<dummy/>')\nresult = transform(root)\nstr(result)\n```\n\n----------------------------------------\n\nTITLE: Unicode XML Parsing\nDESCRIPTION: Shows how lxml handles Unicode strings in XML parsing, including limitations with encoding declarations.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML( '<test> \\uf8d1 + \\uf8d2 </test>' )\n\n>>> etree.XML( '<?xml version=\"1.0\" encoding=\"ASCII\"?>\\n' +\n...            '<test> \\uf8d1 + \\uf8d2 </test>' )\nTraceback (most recent call last):\n  ...\nValueError: Unicode strings with encoding declaration are not supported. Please use bytes input or XML fragments without declaration.\n```\n\n----------------------------------------\n\nTITLE: Checkbox Form Filling in Python using lxml\nDESCRIPTION: Demonstrates filling checkbox inputs using boolean values and arrays of selected values.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_formfill.txt#2025-04-16_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fill_form_html('''\n... <form>\n...   Would you like to be spammed?\n...   <input type=\"checkbox\" name=\"spam_me\"> <br>\n...   Spam you'd like to receive:<br>\n...   Viagra spam:\n...       <input type=\"checkbox\" name=\"type\" value=\"viagra\"><br>\n...   Stock spam:\n...       <input type=\"checkbox\" name=\"type\" value=\"stock\"><br>\n...   Other spam:\n...       <input type=\"checkbox\" name=\"type\" value=\"other\"><br>\n...   <input type=\"submit\" value=\"Spam!\">\n... </form>''', dict(spam_me=True, type=['viagra', 'other'])))\n```\n\n----------------------------------------\n\nTITLE: Building Objectify Trees in Memory\nDESCRIPTION: Shows how to build new objectify trees in memory using the Element() factory function, which creates instances of ObjectifiedElement.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> obj_el = objectify.Element(\"new\")\n>>> print(isinstance(obj_el, objectify.ObjectifiedElement))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Reusing Parser Target Objects in lxml\nDESCRIPTION: Demonstrates how parser target objects can be reused for multiple parsing operations by properly implementing the close() method to reset the parser state.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> result = etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\nstart element {}\ndata 'some'\ncomment comment\ndata 'text'\nend element\nclose\n\n>>> print(result)\nclosed!\n```\n\n----------------------------------------\n\nTITLE: Importing Element in lxml.etree and ElementTree\nDESCRIPTION: Demonstrates the different import statements for the Element class in lxml.etree, ElementTree, and the Python 2.5 standard library version of ElementTree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# etree\nfrom lxml.etree import Element\n\n# ElementTree\nfrom elementtree.ElementTree import Element\n\n# ElementTree in the Python 2.5 standard library\nfrom xml.etree.ElementTree import Element\n```\n\n----------------------------------------\n\nTITLE: Using soupparser as a Fallback for Encoding Issues\nDESCRIPTION: Demonstrates how to use soupparser as a fallback when lxml's HTML parser fails to handle encoding correctly, particularly with misplaced meta tags.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/elementsoup.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> tag_soup = '''\\\n... <meta http-equiv=\"Content-Type\"\n...       content=\"text/html;charset=utf-8\" />\n... <html>\n...   <head>\n...     <title>Hello W\\xc3\\xb6rld!</title>\n...   </head>\n...   <body>Hi all</body>\n... </html>'''\n\n>>> import lxml.html\n>>> import lxml.html.soupparser\n\n>>> root = lxml.html.fromstring(tag_soup)\n>>> try:\n...     ignore = tostring(root, encoding='unicode')\n... except UnicodeDecodeError:\n...     root = lxml.html.soupparser.fromstring(tag_soup)\n```\n\n----------------------------------------\n\nTITLE: Accessing XPath Context in Extension Functions\nDESCRIPTION: This snippet demonstrates how to access the XPath context within extension functions. It shows how to use the context_node and eval_context properties of the context object.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef print_tag(context, nodes):\n    print(\"%s: %s\" % (context.context_node.tag, [ n.tag for n in nodes ]))\n\nns = etree.FunctionNamespace('http://mydomain.org/printtag')\nns.prefix = \"pt\"\nns[\"print_tag\"] = print_tag\n\nignore = root.xpath(\"//*[pt:print_tag(.//*)]\")\n\ndef print_context(context):\n    context.eval_context[context.context_node.tag] = \"done\"\n    print(sorted(context.eval_context.items()))\nns[\"print_context\"] = print_context\n\nignore = root.xpath(\"//*[pt:print_context()]\")\n```\n\n----------------------------------------\n\nTITLE: Namespace Handling in Element Lookups\nDESCRIPTION: Demonstrates how namespaces are handled during tag lookups. When accessing a child without specifying a namespace, the lookup uses the parent's namespace.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"{http://ns/}root\")\n>>> b = objectify.SubElement(root, \"{http://ns/}b\")\n>>> c = objectify.SubElement(root, \"{http://other/}c\")\n\n>>> print(root.b.tag)\n{http://ns/}b\n```\n\n----------------------------------------\n\nTITLE: Reusing a Parser Target for Multiple Documents\nDESCRIPTION: Shows how to reuse a parser and its target for parsing multiple XML documents, which requires proper state cleanup in the close() method.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n>>> events = etree.fromstring('<root test=\"true\"/>', parser)\n>>> print(parser_target.close_count)\n2\n>>> events = etree.fromstring('<root test=\"true\"/>', parser)\n>>> print(parser_target.close_count)\n3\n>>> events = etree.fromstring('<root test=\"true\"/>', parser)\n>>> print(parser_target.close_count)\n4\n\n>>> for event in events:\n...     print(f'event: {event[0]} - tag: {event[1]}')\n...     for attr, value in event[2].items():\n...         print(f' * {attr} = {value}')\nevent: start - tag: root\n * test = true\n```\n\n----------------------------------------\n\nTITLE: Creating XML Fragments with Custom Element Classes in lxml\nDESCRIPTION: Demonstrates creating nested XML structures using custom element classes. The example shows how to combine different element types with text content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass hale(etree.ElementBase): pass\nclass bopp(etree.ElementBase): pass\n\nel = hale( \"some \", honk(honking = 'true'), bopp, \" text\" )\n\nprint(etree.tostring(el, encoding='unicode'))\n<hale>some <honk honking=\"true\"/><bopp/> text</hale>\n```\n\n----------------------------------------\n\nTITLE: Parsing Complete hCard Data with lxml in Python\nDESCRIPTION: A loop that extracts complete hCard information from a document. It processes each card to find the formatted name, phone numbers with types, and addresses.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> for el in doc.find_class('hcard'):\n...     card = Card()\n...     card.el = el\n...     card.fn = get_text(el, 'fn')\n...     card.tels = []\n...     for tel_el in card.find_class('tel'):\n...         card.tels.append(Phone(get_value(tel_el),\n...                                get_all_texts(tel_el, 'type')))\n...     card.addresses = parse_addresses(el)\n```\n\n----------------------------------------\n\nTITLE: Using Attribute Based Element Class Lookup in lxml\nDESCRIPTION: Demonstrates how to use AttributeBasedElementClassLookup with XML content. Shows how elements with matching attribute values get the custom class behavior, while others don't.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nxml = '<a id=\"123\"><b id=\"1234\"/><b id=\"1234\" honking=\"true\"/></a>'\na = etree.fromstring(xml, parser)\n\na.honking       # id does not match !\nTraceback (most recent call last):\nAttributeError: 'lxml.etree._Element' object has no attribute 'honking'\n\na[0].honking\nFalse\na[1].honking\nTrue\n```\n\n----------------------------------------\n\nTITLE: Basic Form Input Filling in Python using lxml\nDESCRIPTION: Demonstrates importing required modules and filling a simple text input field with a value using fill_form_html function.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_formfill.txt#2025-04-16_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html import usedoctest\n>>> from lxml.html.formfill import fill_form_html\n\n>>> print(fill_form_html('''\n... <form><input type=\"text\" name=\"foo\"></form>''', dict(foo='bar')))\n<form><input type=\"text\" name=\"foo\" value=\"bar\"></form>\n```\n\n----------------------------------------\n\nTITLE: Combining XPath and Python Filtering in lxml\nDESCRIPTION: A hybrid approach using lxml's XPath to select elements and Python code to filter the content. This implementation uses XPath for element selection but Python for text content matching.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef bench_lxml_xpath():\n    tree = etree.parse(\"ot.xml\")\n    result = []\n    for v in tree.xpath(\"//v\"):\n        text = v.text\n        if 'begat' in text:\n            result.append(text)\n    return len(result)\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements with Invalid Python Identifiers\nDESCRIPTION: Demonstrates how to access elements with tag names that aren't valid Python identifiers or have special meaning in objectify.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> el = objectify.SubElement(root, \"{http://ns/}tag-name\")\n>>> print(root[\"tag-name\"].tag)\n{http://ns/}tag-name\n\n>>> new_el = objectify.Element(\"{http://ns/}new-element\")\n>>> el = objectify.SubElement(new_el, \"{http://ns/}child\")\n>>> el = objectify.SubElement(new_el, \"{http://ns/}child\")\n>>> el = objectify.SubElement(new_el, \"{http://ns/}child\")\n\n>>> root[\"tag-name\"] = [ new_el, new_el ]\n>>> print(len(root[\"tag-name\"]))\n2\n>>> print(root[\"tag-name\"].tag)\n{http://ns/}tag-name\n\n>>> print(len(root[\"tag-name\"].child))\n3\n>>> print(root[\"tag-name\"].child.tag)\n{http://ns/}child\n>>> print(root[\"tag-name\"][1].child.tag)\n{http://ns/}child\n```\n\n----------------------------------------\n\nTITLE: Toggling Element Classes\nDESCRIPTION: Demonstrates the toggle method for switching the state of CSS classes on an HTML element. Shows how to toggle class presence on and off, and validation of class names with invalid characters.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> el.get('class')\n'a'\n>>> el.classes.toggle('a')\nFalse\n>>> el.get('class')\n>>> el.classes.toggle('foo')\nTrue\n>>> el.get('class')\n'foo'\n>>> el.classes.toggle('foo')\nFalse\n>>> el.get('class')\n>>> el.classes.add(\"foo\\n\")\nTraceback (most recent call last):\n...\nValueError: Invalid class name: 'foo\\n'\n>>> el.classes.remove(\"foo \")\nTraceback (most recent call last):\n...\nValueError: Invalid class name: 'foo '\n```\n\n----------------------------------------\n\nTITLE: Designing an Atom API with Custom Element Classes\nDESCRIPTION: Shows how to create a domain-specific API for Atom XML by defining custom Element classes. The FeedElement class adds properties for accessing entries and title elements in an Atom feed.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# atom.py\n\nATOM_NAMESPACE = \"http://www.w3.org/2005/Atom\"\n_ATOM_NS = \"{%s}\" % ATOM_NAMESPACE\n\nclass FeedElement(etree.ElementBase):\n    @property\n    def entries(self):\n       return self.findall(_ATOM_NS + \"entry\")\n\nclass FeedElement(etree.ElementBase):\n    # ...\n    @property\n    def title(self):\n        \"return the title or None\"\n        return self.find(\"title\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Proxy Cache for Element Instances in Python\nDESCRIPTION: Example of creating a cache to keep Element proxy instances alive. This technique allows for storing local state in custom Element classes by maintaining Python references to the proxies.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nproxy_cache = list(root.iter())\n```\n\n----------------------------------------\n\nTITLE: Link Rewriting with rewrite_links Function\nDESCRIPTION: Examples of using rewrite_links function to transform URLs in various HTML elements including anchors, scripts, and link tags.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_rewritelinks.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml.html import usedoctest, tostring\nfrom lxml.html import rewrite_links\nprint(rewrite_links(\n    '<a href=\"http://old/blah/blah.html\">link</a>', relocate_href))\nprint(rewrite_links(\n    '<script src=\"http://old/foo.js\"></script>', relocate_href))\nprint(rewrite_links(\n    '<link href=\"foo.css\">', relocate_href))\n```\n\n----------------------------------------\n\nTITLE: ObjectPath with Path Segments and Relative Paths\nDESCRIPTION: Shows how to use ObjectPath with lists of path segments and relative paths that inherit parent namespaces.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> find = objectify.ObjectPath(['root', 'b', 'c'])\n>>> print(find(root).tag)\n{http://ns/}c\n\n>>> find = objectify.ObjectPath(['root', '{http://ns/}b[1]'])\n>>> print(find(root).tag)\n{http://ns/}b\n\n>>> find = objectify.ObjectPath(\".b[1]\")\n>>> print(find(root).tag)\n{http://ns/}b\n\n>>> find = objectify.ObjectPath(['', 'b[1]'])\n>>> print(find(root).tag)\n{http://ns/}b\n\n>>> find = objectify.ObjectPath(\".unknown[1]\")\n>>> print(find(root).tag)\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: {http://ns/}unknown\n\n>>> find = objectify.ObjectPath(\".{http://other/}unknown[1]\")\n>>> print(find(root).tag)\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: {http://other/}unknown\n\n>>> find = objectify.ObjectPath(\".\")\n>>> print(find(root).tag)\n{http://ns/}root\n```\n\n----------------------------------------\n\nTITLE: Using XPathEvaluator for ElementTrees or Elements\nDESCRIPTION: Demonstrates the XPathEvaluator helper which automatically selects the appropriate evaluator type based on the input.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><a><b/></a><b/></root>\")\n>>> xpatheval = etree.XPathEvaluator(root)\n```\n\n----------------------------------------\n\nTITLE: Skipping Subtrees with iterwalk\nDESCRIPTION: Demonstrates how to use skip_subtree() method to skip processing specific subtrees during iteration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML('''\n... <root>\n...   <a> <b /> </a>\n...   <c />\n... </root>\n... ''')\n\n>>> context = etree.iterwalk(root, events=(\"start\", \"end\"))\n\n>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\n...     if action == 'start' and elem.tag == 'a':\n...         context.skip_subtree()  # ignore <b>\nstart: root\nstart: a\nend: a\nstart: c\nend: c\nend: root\n```\n\n----------------------------------------\n\nTITLE: XSLT Extension with Apply Templates Functionality\nDESCRIPTION: Shows how to create an XSLT extension element that applies templates to process content. The extension uses the apply_templates method to process child elements through the XSLT processor.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass MyExtElement(etree.XSLTExtension):\n    def execute(self, context, self_node, input_node, output_parent):\n        child = self_node[0]\n        results = self.apply_templates(context, child)\n        output_parent.append(results[0])\n\nmy_extension = MyExtElement()\nextensions = { ('testns', 'ext') : my_extension }\ntransform = etree.XSLT(xslt_ext_tree, extensions = extensions)\n\nroot = etree.XML('<dummy/>')\nresult = transform(root)\nstr(result)\n```\n\n----------------------------------------\n\nTITLE: Building Tree from SAX Events\nDESCRIPTION: Demonstrates creation of an XML tree using SAX events with ElementTreeContentHandler. Shows how to create elements with attributes and text content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/sax.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport lxml.sax\nhandler = lxml.sax.ElementTreeContentHandler()\nhandler.startElementNS((None, 'a'), 'a', {})\nhandler.startElementNS((None, 'b'), 'b', {(None, 'foo'): 'bar'})\nhandler.characters('Hello world')\nhandler.endElementNS((None, 'b'), 'b')\nhandler.endElementNS((None, 'a'), 'a')\ntree = handler.etree\nlxml.etree.tostring(tree.getroot())\n```\n\n----------------------------------------\n\nTITLE: Annotating and Deannotating XML Elements in lxml.objectify\nDESCRIPTION: Demonstrates how to add and remove type annotations in objectify XML elements. The example shows how annotate() adds type information and deannotate() removes it, affecting how elements are interpreted.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring('''\\\n... <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n...       xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n...   <d xsi:type=\"xsd:double\">5</d>\n...   <i xsi:type=\"xsd:int\"   >5</i>\n...   <s xsi:type=\"xsd:string\">5</s>\n... </root>''')\n>>> objectify.annotate(root)\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    d = 5.0 [FloatElement]\n      * py:pytype = 'float'\n      * xsi:type = 'xsd:double'\n    i = 5 [IntElement]\n      * py:pytype = 'int'\n      * xsi:type = 'xsd:int'\n    s = '5' [StringElement]\n      * py:pytype = 'str'\n      * xsi:type = 'xsd:string'\n>>> objectify.deannotate(root)\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    d = 5 [IntElement]\n    i = 5 [IntElement]\n    s = 5 [IntElement]\n```\n\n----------------------------------------\n\nTITLE: Alternative Proxy Cache Using Set in Python\nDESCRIPTION: Alternative method for creating a proxy cache using a set instead of a list. This allows for faster lookups when checking for element existence.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nproxy_cache = set(root.iter())\n```\n\n----------------------------------------\n\nTITLE: Demonstrating HTML Normalization with html5lib Parser in Python\nDESCRIPTION: This code snippet demonstrates how html5lib automatically normalizes HTML elements, showing how it adds missing tbody elements in tables. The example uses the fromstring function from lxml.html.html5parser to parse a simple table without a tbody element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/html5parser.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.html import tostring, html5parser\n>>> tostring(html5parser.fromstring(\"<table><td>foo\"))\n'<table><tbody><tr><td>foo</td></tr></tbody></table>'\n```\n\n----------------------------------------\n\nTITLE: Tree Generation with E-factory\nDESCRIPTION: Shows how to use the E-factory to create XML trees with a concise syntax, automatically handling data types and element creation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> E = objectify.E\n>>> root = E.root(\n...   E.a(5),\n...   E.b(6.21),\n...   E.c(True),\n...   E.d(\"how\", tell=\"me\")\n... )\n\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n  <a py:pytype=\"int\">5</a>\n  <b py:pytype=\"float\">6.21</b>\n  <c py:pytype=\"bool\">true</c>\n  <d py:pytype=\"str\" tell=\"me\">how</d>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Incremental XML Generation with lxml\nDESCRIPTION: Demonstrates using lxml's xmlfile API for incremental XML generation using context managers and the with statement.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> f = BytesIO()\n>>> with etree.xmlfile(f) as xf:\n...     with xf.element('abc'):\n...         xf.write('text')\n\n>>> print(f.getvalue().decode('utf-8'))\n<abc>text</abc>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ObjectifiedElement Behavior in Python\nDESCRIPTION: This snippet shows how ObjectifiedElements behave differently from regular Python types, including string concatenation, length, and slicing operations.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"<root><a>test</a><b>toast</b></root>\")\n>>> print(root.a + ' me') # behaves like a string, right?\ntest me\n>>> len(root.a) # but there's only one 'a' element!\n1\n>>> [ a.tag for a in root.a ]\n['a']\n>>> print(root.a[0].tag)\na\n\n>>> print(root.a)\ntest\n>>> [ str(a) for a in root.a[:1] ]\n['test']\n```\n\n----------------------------------------\n\nTITLE: Setting Up Namespace Class Lookup in lxml\nDESCRIPTION: Creates a namespace-aware class lookup mechanism for an XML parser in lxml. This allows for different element classes to be used based on the namespace and tag name of elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlookup = etree.ElementNamespaceClassLookup()\nparser = etree.XMLParser()\nparser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Parser Targets with lxml\nDESCRIPTION: Shows how the close() method of parser targets is called even in error cases, allowing for cleanup of target state. This example uses a CollectorTarget that stores parser events in a list.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> class CollectorTarget(object):\n...     def __init__(self):\n...         self.events = []\n...     def start(self, tag, attrib):\n...         self.events.append(\"start %s %r\" % (tag, dict(attrib)))\n...     def end(self, tag):\n...         self.events.append(\"end %s\" % tag)\n...     def data(self, data):\n...         self.events.append(\"data %r\" % data)\n...     def comment(self, text):\n...         self.events.append(\"comment %s\" % text)\n...     def close(self):\n...         self.events.append(\"close\")\n...         return \"closed!\"\n\n>>> parser = etree.XMLParser(target = CollectorTarget())\n\n>>> result = etree.XML(\"<element>some</error>\",\n...                    parser)        # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nlxml.etree.XMLSyntaxError: Opening and ending tag mismatch...\n\n>>> for event in parser.target.events:\n...     print(event)\nstart element {}\ndata 'some'\nclose\n```\n\n----------------------------------------\n\nTITLE: Creating Domain-Specific XML Languages with E-factory\nDESCRIPTION: Demonstrates how to define custom tag variables for creating a domain-specific XML language, including how to handle tag names with special characters.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> ROOT = objectify.E.root\n>>> TITLE = objectify.E.title\n>>> HOWMANY = getattr(objectify.E, \"how-many\")\n\n>>> root = ROOT(\n...   TITLE(\"The title\"),\n...   HOWMANY(5)\n... )\n\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n  <title py:pytype=\"str\">The title</title>\n  <how-many py:pytype=\"int\">5</how-many>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Replacing Children with Element Assignment\nDESCRIPTION: Demonstrates how to replace children by assigning new elements to existing attribute positions, including how the element structure is preserved.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> child1 = objectify.SubElement(root, \"child\")\n>>> child2 = objectify.SubElement(root, \"child\")\n>>> child3 = objectify.SubElement(root, \"child\")\n\n>>> el = objectify.Element(\"new_child\")\n>>> subel = objectify.SubElement(el, \"sub\")\n\n>>> root.child = el\n>>> print(root.child.sub.tag)\nsub\n\n>>> root.child[2] = el\n>>> print(root.child[2].sub.tag)\nsub\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements in Different Namespaces\nDESCRIPTION: Shows how to access elements in different namespaces than their parent using getattr() and item access syntax.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> print(root.c)\nTraceback (most recent call last):\n    ...\nAttributeError: no such child: {http://ns/}c\n\n>>> c = getattr(root, \"{http://other/}c\")\n>>> print(c.tag)\n{http://other/}c\n\n>>> c = root[\"{http://other/}c\"]\n>>> print(c.tag)\n{http://other/}c\n```\n\n----------------------------------------\n\nTITLE: Setting Namespaced Attributes in XML Elements\nDESCRIPTION: Shows how attributes with namespaces are handled differently than elements, with lxml ensuring that they use prefixed namespace declarations to comply with XML namespace specifications.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n>>> body.set(XHTML + \"bgcolor\", \"#CCFFAA\")\n\n>>> prettyprint(xhtml)\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n  <body xmlns:html=\"http://www.w3.org/1999/xhtml\" html:bgcolor=\"#CCFFAA\">Hello World</body>\n</html>\n\n>>> print(body.get(\"bgcolor\"))\nNone\n>>> body.get(XHTML + \"bgcolor\")\n'#CCFFAA'\n```\n\n----------------------------------------\n\nTITLE: Element Access with Index Omission\nDESCRIPTION: Shows how you can omit the index [0] to access the first child of an element in objectify, and how to delete elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> print(root.b.tag)\nb\n>>> root.index(root.b)\n0\n>>> del root.b\n```\n\n----------------------------------------\n\nTITLE: Handling XML Schema Types and Namespaces in DataElement Factory\nDESCRIPTION: Explains how DataElement handles XML Schema types and namespace prefixing. Shows how namespaces are managed when creating new elements and adding them to existing trees.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.Element(\"root\")\n>>> root.s = objectify.DataElement(5, _xsi=\"string\")\n\n>>> objectify.deannotate(root, xsi=False)\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <s xsi:type=\"xsd:string\">5</s>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Accessing XMLSchema Error Information in Python\nDESCRIPTION: Shows how to access error details from the XMLSchema validation log. The example demonstrates retrieving domain name and type name information from the last error in the log.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> log = xmlschema.error_log\n>>> error = log.last_error\n>>> print(error.domain_name)\nSCHEMASV\n>>> print(error.type_name)\nSCHEMAV_ELEMENT_CONTENT\n```\n\n----------------------------------------\n\nTITLE: Using XPath with cssselect Translation in Python\nDESCRIPTION: Demonstrates how to use the cssselect GenericTranslator to convert a CSS selector to XPath, then use it with lxml's XPath class. This is equivalent to using CSSSelector.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/cssselect.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from cssselect import GenericTranslator\n>>> from lxml.etree import XPath\n>>> sel = XPath(GenericTranslator().css_to_xpath('div.content'))\n```\n\n----------------------------------------\n\nTITLE: XPath with Namespaces Using Clark Notation\nDESCRIPTION: Demonstrates using ETXPath class to handle namespaces with Clark notation instead of namespace prefixes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nroot = etree.XML(\"<root xmlns='ns'><a><b/></a><b/></root>\")\n\nfind = etree.XPath(\"//p:b\", namespaces={'p' : 'ns'})\nprint(find(root)[0].tag)\n\nfind = etree.ETXPath(\"//{ns}b\")\nprint(find(root)[0].tag)\n```\n\n----------------------------------------\n\nTITLE: Accessing XML Error Log Entry Details with lxml\nDESCRIPTION: Shows how to access specific error details from an XML error log entry including domain name, error type and filename.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> entry = log[0]\n>>> print(entry.domain_name)\nPARSER\n>>> print(entry.type_name)\nERR_TAG_NAME_MISMATCH\n>>> print(entry.filename)\n<string>\n```\n\n----------------------------------------\n\nTITLE: Custom DTD Resolver Implementation\nDESCRIPTION: Example of a custom resolver that generates dynamic DTD fragments for entity resolution based on URLs.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/resolvers.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml import etree\n\nclass DTDResolver(etree.Resolver):\n    def resolve(self, url, id, context):\n        print(\"Resolving URL '%s'\" % url)\n        return self.resolve_string(\n            '<!ENTITY myentity \"[resolved text: %s]\">' % url, context)\n```\n\n----------------------------------------\n\nTITLE: Building Atom XML document with ElementMaker\nDESCRIPTION: Demonstrates creating an Atom feed document with multiple nested elements using the ElementMaker. The example includes author, entry, title, link, and summary elements with attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> atom = A.feed(\n...   A.author( A.name(\"Stefan Behnel\") ),\n...   A.entry(\n...     A.title(\"News from lxml\"),\n...     A.link(href=\"http://codespeak.net/lxml/\"),\n...     A.summary(\"See what's <b>fun</b> about lxml...\",\n...               type=\"html\"),\n...   )\n... )\n```\n\n----------------------------------------\n\nTITLE: Using Schematron in Conditional Statements in Python\nDESCRIPTION: Shows how to use the callable interface of the Schematron object in conditional statements. This is a more concise way to perform validation checks.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> is_valid = isoschematron.Schematron(sct_doc)\n\n>>> if not is_valid(doc):\n...     print(\"invalid!\")\ninvalid!\n```\n\n----------------------------------------\n\nTITLE: Validating Documents with XMLSchema in Python\nDESCRIPTION: Demonstrates validating XML documents against an XML Schema. The example shows validation of both valid and invalid documents, with the validate method returning a boolean result.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> valid = StringIO('<a><b></b></a>')\n>>> doc = etree.parse(valid)\n>>> xmlschema.validate(doc)\nTrue\n\n>>> invalid = StringIO('<a><c></c></a>')\n>>> doc2 = etree.parse(invalid)\n>>> xmlschema.validate(doc2)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Modifying ObjectifiedElement Values in Python\nDESCRIPTION: This snippet shows how to modify ObjectifiedElement values by direct assignment, as .text and .pyval attributes are read-only.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> root.a.text  = \"25\"\nTraceback (most recent call last):\n  ...\nTypeError: attribute 'text' of 'StringElement' objects is not writable\n\n>>> root.a.pyval = 25\nTraceback (most recent call last):\n  ...\nTypeError: attribute 'pyval' of 'StringElement' objects is not writable\n\n>>> root.a = 25\n>>> print(root.a)\n25\n>>> print(root.a.pyval)\n25\n```\n\n----------------------------------------\n\nTITLE: Using XML Schema Datatype Annotations for ObjectifiedElements in Python\nDESCRIPTION: This snippet shows how to use XML Schema datatype annotations to specify data types for ObjectifiedElements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring('''\n...    <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n...          xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n...      <d xsi:type=\"xsd:double\">5</d>\n...      <i xsi:type=\"xsd:int\"   >5</i>\n...      <s xsi:type=\"xsd:string\">5</s>\n...    </root>\n...    ''')\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    d = 5.0 [FloatElement]\n      * xsi:type = 'xsd:double'\n    i = 5 [IntElement]\n      * xsi:type = 'xsd:int'\n    s = '5' [StringElement]\n      * xsi:type = 'xsd:string'\n```\n\n----------------------------------------\n\nTITLE: Importing ElementTree as lxml.etree\nDESCRIPTION: Shows how to switch from using ElementTree to lxml.etree by aliasing the import.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# instead of\nfrom elementtree import ElementTree\n# use\nfrom lxml import etree as ElementTree\n```\n\n----------------------------------------\n\nTITLE: Filtering Tree Iteration by Node Type\nDESCRIPTION: Demonstrates how to filter tree iteration to include only specific node types, such as Element, Entity, or Comment objects, by passing the type factory to iter().\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> root.append(etree.Entity(\"#234\"))\n>>> root.append(etree.Comment(\"some comment\"))\n\n>>> for element in root.iter():\n...     if isinstance(element.tag, str):\n...         print(f\"{element.tag} - {element.text}\")\n...     else:\n...         print(f\"SPECIAL: {element} - {element.text}\")\nroot - None\nchild - Child 1\nchild - Child 2\nanother - Child 3\nSPECIAL: &#234; - &#234;\nSPECIAL: <!--some comment--> - some comment\n\n>>> for element in root.iter(tag=etree.Element):\n...     print(f\"{element.tag} - {element.text}\")\nroot - None\nchild - Child 1\nchild - Child 2\nanother - Child 3\n\n>>> for element in root.iter(tag=etree.Entity):\n...     print(element.text)\n&#234;\n```\n\n----------------------------------------\n\nTITLE: Configuring XML Parser for Pretty Printing\nDESCRIPTION: Demonstrates how to create an XML parser with remove_blank_text option enabled to allow pretty printing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nparser = etree.XMLParser(remove_blank_text=True)\ntree = etree.parse(filename, parser)\n```\n\n----------------------------------------\n\nTITLE: Handling HTML Fragment Types\nDESCRIPTION: Demonstrates the behavior of lxml.html.fromstring with different types of HTML fragments, including frameset, div, and head fragments. Shows how fromstring decides what to return based on the fragment type.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.html\n>>> content='''\n... <frameset>\n...  <frame src=\"main.php\" name=\"srcpg\">\n... </frameset>'''\n>>> etree_document = lxml.html.fromstring(content)\n>>> print(tostring(etree_document, encoding=unicode))\n<html><frameset><frame src=\"main.php\" name=\"srcpg\"></frameset></html>\n\n>>> import lxml.html\n>>> content='<div></div>'\n>>> etree_document = lxml.html.fromstring(content)\n>>> print(tostring(etree_document, encoding=unicode))\n<div></div>\n\n>>> import lxml.html\n>>> content='<head></head>'\n>>> etree_document = lxml.html.fromstring(content)\n>>> print(tostring(etree_document, encoding=unicode))\n<html><head></head></html>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Default Element Class Lookup in lxml\nDESCRIPTION: Demonstrates how to configure a parser to use a custom Element class as the default for all elements. This uses ElementDefaultClassLookup to associate the 'honk' class with the parser.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nparser_lookup = etree.ElementDefaultClassLookup(element=honk)\nparser = etree.XMLParser()\nparser.set_element_class_lookup(parser_lookup)\n```\n\n----------------------------------------\n\nTITLE: Using Variables with Compiled XPath Expressions\nDESCRIPTION: Shows how to use variables with compiled XPath expressions, allowing for efficient parameterized queries.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> count_elements = etree.XPath(\"count(//*[local-name() = $name])\")\n\n>>> print(count_elements(root, name = \"a\"))\n1.0\n>>> print(count_elements(root, name = \"b\"))\n2.0\n```\n\n----------------------------------------\n\nTITLE: Working with XML Schema Type Information in lxml.objectify\nDESCRIPTION: Demonstrates how XML Schema type information overrides custom type check functions. This example shows how an element with xsi:type='date' still maintains functionality from a previously registered type.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring('''\\\n...    <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n...      <a xsi:type=\"date\">12.24.2000</a>\n...    </root>\n...    ''')\n>>> print(root.a)\n12.24.2000\n>>> root.a.call_santa()\nHo ho ho!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating XML Element Serialization with Trailing Text\nDESCRIPTION: Examples showing how the ElementTree model handles text, child elements, and trailing text (tail) during XML serialization. Illustrates how the tail property is preserved when serializing individual elements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<root><tag>text<child/></tag>tail</root>\")\n>>> print(etree.tostring(root[0]))\n<tag>text<child/></tag>tail\n```\n\n----------------------------------------\n\nTITLE: Annotating ObjectifiedElements with XML Schema Datatypes in Python\nDESCRIPTION: This snippet demonstrates how to use the xsiannotate() function to recursively generate XML Schema datatype annotations for the elements of a tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring('''\n...    <root><a>test</a><b>5</b><c>true</c></root>\n...    ''')\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 'test' [StringElement]\n    b = 5 [IntElement]\n    c = True [BoolElement]\n\n>>> objectify.xsiannotate(root)\n\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 'test' [StringElement]\n      * xsi:type = 'xsd:string'\n    b = 5 [IntElement]\n      * xsi:type = 'xsd:integer'\n    c = True [BoolElement]\n      * xsi:type = 'xsd:boolean'\n```\n\n----------------------------------------\n\nTITLE: Navigating the Node-Set Element Relationships\nDESCRIPTION: Shows the behavior of node-set elements returned by extension functions, specifically highlighting how deep-copying affects element relationships in the result tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(\"%s - %s\" % (r[1][-1].tag, r[2].tag))\nprint(r[1][-1] == r[2])\nprint(r[1][-1].getparent().tag)\nprint(r[2].getparent())\n```\n\n----------------------------------------\n\nTITLE: Registering Custom PyTypes with XML Schema Types\nDESCRIPTION: Demonstrates how to associate a custom PyType with an XML Schema type name. Shows how to register the type and use it to handle XML elements of the specified type.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n>>> xmas_type.xmlSchemaTypes = (\"date\",)\n\n>>> xmas_type.register()\n\n>>> root = objectify.fromstring(\n...             \"<root><a>24.12.2000</a><b>12.24.2000</b></root>\")\n>>> root.a.call_santa()\nHo ho ho!\n>>> root.b.call_santa()\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: call_santa\n```\n\n----------------------------------------\n\nTITLE: Parsing Bytes in Python 3\nDESCRIPTION: Demonstrates parsing HTML from bytes objects in Python 3, showing how to use the HTMLParser with an encoding specified to handle byte-encoded HTML strings.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.html import HTMLParser\n>>> enc = 'utf-8'\n>>> html_parser = HTMLParser(encoding=enc)\n>>> src = '<html><body>Test</body></html>'.encode(enc)\n\n>>> doc = fromstring(src, parser=html_parser)\n>>> print(tostring(doc, encoding=unicode))\n<html><body>Test</body></html>\n\n>>> docs = fragments_fromstring(src, parser=html_parser)\n>>> len(docs)\n1\n>>> print(docs[0])\nTest\n```\n\n----------------------------------------\n\nTITLE: Creating Module-Level Element Factory in lxml\nDESCRIPTION: Shows how to create a module-level Element factory that uses a specific parser with custom Element classes. This is useful for consistently creating elements with your custom classes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmodule_level_parser = etree.XMLParser()\nElement = module_level_parser.makeelement\n```\n\n----------------------------------------\n\nTITLE: Setting Default Namespaces for XML Element Creation\nDESCRIPTION: Shows how to define namespace prefixes for serialization and set a default namespace (with no prefix) using the nsmap parameter during element creation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_45\n\nLANGUAGE: python\nCODE:\n```\n>>> XHTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\"\n>>> XHTML = \"{%s}\" % XHTML_NAMESPACE\n\n>>> NSMAP = {None : XHTML_NAMESPACE} # the default namespace (no prefix)\n\n>>> xhtml = etree.Element(XHTML + \"html\", nsmap=NSMAP) # lxml only!\n>>> body = etree.SubElement(xhtml, XHTML + \"body\")\n>>> body.text = \"Hello World\"\n\n>>> prettyprint(xhtml)\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n  <body>Hello World</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Handling Textarea Content with lxml.html in Python\nDESCRIPTION: This snippet demonstrates how lxml.html handles textarea content, including the preservation of HTML tags within the textarea value.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_forms.txt#2025-04-16_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> tree = lxml.html.fromstring('''\n... <html><body>\n...  <form>\n...   <textarea name=\"foo\">some <b>text<br>content</b> with tags</textarea>\n...  </form>\n... </body></html>\n... ''')\n>>> list(tree.forms[0].fields.keys())\n['foo']\n>>> ta = tree.forms[0].inputs['foo']\n>>> print(ta.value)\nsome <b>text<br>content</b> with tags\n>>> ta.value = 'abc<br>def'\n>>> print(ta.value)\nabc<br>def\n>>> len(ta)\n0\n```\n\n----------------------------------------\n\nTITLE: Textarea Form Filling in Python using lxml\nDESCRIPTION: Demonstrates filling textarea elements while preserving the name attribute.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_formfill.txt#2025-04-16_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fill_form_html('''\n... <form>\n...   <textarea name=\"foo\">Initial value</textarea>\n... </form>''', dict(foo=\"Bar\")))\n<form>\n  <textarea name=\"foo\">Bar</textarea>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Child Access Performance Benchmarks in XML Libraries\nDESCRIPTION: Performance comparison of child access operations between lxml.etree and cElementTree, showing execution times in milliseconds per pass for listing children and accessing individual children.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nlxe: root_list_children        (--TR T1)    0.0036 msec/pass\ncET: root_list_children        (--TR T1)    0.0005 msec/pass\n\nlxe: root_list_children        (--TR T2)    0.0634 msec/pass\ncET: root_list_children        (--TR T2)    0.0086 msec/pass\n\nlxe: first_child               (--TR T2)    0.0601 msec/pass\ncET: first_child               (--TR T2)    0.0548 msec/pass\n\nlxe: last_child                (--TR T1)    0.0570 msec/pass\ncET: last_child                (--TR T1)    0.0534 msec/pass\n\nlxe: middle_child              (--TR T1)    0.0892 msec/pass\ncET: middle_child              (--TR T1)    0.0510 msec/pass\n\nlxe: middle_child              (--TR T2)    2.3038 msec/pass\ncET: middle_child              (--TR T2)    0.0508 msec/pass\n```\n\n----------------------------------------\n\nTITLE: Embedding HTML in Atom XML (Serialized)\nDESCRIPTION: Demonstrates how to embed serialized HTML content within Atom XML. The HTML is first created using lxml.html.builder, then serialized and included in an Atom summary element as escaped HTML.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.html.builder as h\n\n>>> html_fragment = h.DIV(\n...   \"this is some\\n\",\n...   h.A(\"HTML\", href=\"http://w3.org/MarkUp/\"),\n...   \"\\ncontent\")\n\n>>> serialised_html = etree.tostring(html_fragment, method=\"html\")\n\n>>> summary = A.summary(serialised_html, type=\"html\")\n\n>>> print(etree.tostring(summary))\n<summary xmlns=\"http://www.w3.org/2005/Atom\" type=\"html\">\n   &lt;div&gt;this is some\n   &lt;a href=\"http://w3.org/MarkUp/\"&gt;HTML&lt;/a&gt;\n   content&lt;/div&gt;\n</summary>\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Namespace Prefixes in DataElement\nDESCRIPTION: Demonstrates how to provide custom namespace prefixes when creating elements with DataElement. Shows the importance of providing valid namespace information for custom prefixes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n>>> el = objectify.DataElement('5', _xsi='foo:string',\n...          nsmap={'foo': 'http://www.w3.org/2001/XMLSchema'})\n>>> namespaces = list(el.nsmap.items())\n>>> namespaces.sort()\n>>> for prefix, namespace in namespaces:\n...     print(\"%s - %s\" % (prefix, namespace))\nfoo - http://www.w3.org/2001/XMLSchema\npy - http://codespeak.net/lxml/objectify/pytype\nxsi - http://www.w3.org/2001/XMLSchema-instance\n\n>>> print(el.get(\"{http://www.w3.org/2001/XMLSchema-instance}type\"))\nfoo:string\n```\n\n----------------------------------------\n\nTITLE: Using lxml.etree C-API in Cython\nDESCRIPTION: Example of using lxml.etree's C-API functions in Cython code to create namespaced tag names.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/capi.txt#2025-04-16_snippet_1\n\nLANGUAGE: cython\nCODE:\n```\n# build a tag name from namespace and element name\npy_tag = cetree.namespacedNameFromNsName(\"http://some/url\", \"myelement\")\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements or Trees\nDESCRIPTION: Shows how to use drop_tag() to remove an element but keep its content, and drop_tree() to remove an element completely with all its content. Also demonstrates the different behavior with comments.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> doc = document_fromstring('''\n... <html>\n...  <body>\n...   <div id=\"body\">\n...    This is a <a href=\"foo\" id=\"link\">test</a> of stuff.\n...   </div>\n...   <!-- a comment -->\n...   <div>footer</div>\n...  </body>\n... </html>''')\n>>> doc.get_element_by_id('link').drop_tag()\n>>> print(tostring(doc, encoding=unicode))\n<html>\n <body>\n  <div id=\"body\">\n   This is a test of stuff.\n  </div>\n  <!-- a comment -->\n  <div>footer</div>\n </body>\n</html>\n>>> doc.get_element_by_id('body').drop_tree()\n>>> print(tostring(doc, encoding=unicode))\n<html>\n <body>\n  <!-- a comment -->\n  <div>footer</div>\n </body>\n</html>\n\n>>> for comment in doc.getiterator(Comment):\n...     comment.drop_tag()\n>>> print(tostring(doc, encoding=unicode))\n<html>\n <body>\n  <div>footer</div>\n </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: XSLT Extension Function Call\nDESCRIPTION: Example of calling XSLT objects with XPath objects as stylesheet parameters\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nXSLTExtension.apply_templates(output_parent=output_element)\n```\n\n----------------------------------------\n\nTITLE: Basic Element Namespace Class Lookup in lxml\nDESCRIPTION: Demonstrates how to set up and use ElementNamespaceClassLookup to associate custom element classes with XML elements. The example shows accessing a custom 'honking' property and comment text.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nlookup = etree.ElementNamespaceClassLookup(fallback)\nparser.set_element_class_lookup(lookup)\n\nroot = etree.fromstring(\n    '<root honking=\"true\"><!--comment--></root>', parser)\nroot.honking\nTrue\nprint(root[0].text)\ncomment\n```\n\n----------------------------------------\n\nTITLE: Setting up lxml.html Environment and URL Relocation Function\nDESCRIPTION: Basic setup for lxml.html usage and definition of a URL relocation function that converts old domain URLs to new domain URLs while handling relative paths.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_rewritelinks.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport lxml.html\n\nbase_href = 'http://old/base/path.html'\ntry: import urlparse\nexcept ImportError: import urllib.parse as urlparse\ndef relocate_href(link):\n    link = urlparse.urljoin(base_href, link)\n    if link.startswith('http://old'):\n        return 'https://new' + link[len('http://old'):]\n    else:\n        return link\n```\n\n----------------------------------------\n\nTITLE: Annotating ObjectifiedElements with Python Type Hints in Python\nDESCRIPTION: This snippet demonstrates how to use the annotate() function to recursively generate Python type hint attributes for the elements of a tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"<root><a>test</a><b>5</b></root>\")\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 'test' [StringElement]\n    b = 5 [IntElement]\n\n>>> objectify.annotate(root)\n\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 'test' [StringElement]\n      * py:pytype = 'str'\n    b = 5 [IntElement]\n      * py:pytype = 'int'\n```\n\n----------------------------------------\n\nTITLE: Embedding XHTML in Atom XML (Non-escaped)\nDESCRIPTION: Shows how to embed non-escaped XHTML content in Atom XML. The HTML fragment is converted to XHTML and included directly in the document tree with proper namespacing.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from copy import deepcopy\n>>> xhtml_fragment = deepcopy(html_fragment)\n\n>>> from lxml.html import html_to_xhtml\n>>> html_to_xhtml(xhtml_fragment)\n\n>>> summary = A.summary(xhtml_fragment, type=\"xhtml\")\n\n>>> print(etree.tostring(summary, pretty_print=True))\n<summary xmlns=\"http://www.w3.org/2005/Atom\" type=\"xhtml\">\n  <html:div xmlns:html=\"http://www.w3.org/1999/xhtml\">this is some\n  <html:a href=\"http://w3.org/MarkUp/\">HTML</html:a>\n  content</html:div>\n</summary>\n```\n\n----------------------------------------\n\nTITLE: Caching lxml Element Objects in Python\nDESCRIPTION: This code snippet shows how to cache lxml element objects to improve performance. It creates a cache dictionary for the root element and its descendants, and demonstrates how to clear the cache when done.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncache[root] = list(root.iter())\n\n# When done with the tree\ndel cache[root]\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Element Properties and Methods in lxml\nDESCRIPTION: Demonstrates accessing a custom 'honking' property and 'honk()' method on a specialized lxml Element. Shows how custom properties are available on root elements but not necessarily on child elements that haven't been specifically registered.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> print(honk_element.honking)\nTrue\n>>> print(honk_element.honk())\nHONK\n\n>>> print(honk_element[0].honk())\nHONK\n>>> print(honk_element[0].honking)\nTraceback (most recent call last):\n...\nAttributeError: 'HonkNSElement' object has no attribute 'honking'\n\n>>> print(honk_element[1].text)  # uses fallback for non-elements\ncomment\n```\n\n----------------------------------------\n\nTITLE: Python Element Class Lookup in lxml\nDESCRIPTION: Demonstrates PythonElementClassLookup which allows accessing the element tree during lookup. This provides a more flexible way to make lookup decisions based on the element's context.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass MyLookup(etree.PythonElementClassLookup):\n    def lookup(self, document, element):\n        return MyElementClass # defined elsewhere\n\nparser = etree.XMLParser()\nparser.set_element_class_lookup(MyLookup())\n```\n\n----------------------------------------\n\nTITLE: Element Tree Method Calls\nDESCRIPTION: Examples of various ElementTree method calls for transformation and parsing.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nET.write()\ntostring()\ntounicode()\n```\n\n----------------------------------------\n\nTITLE: Memory-Optimized XML Parsing by Clearing Previous Siblings\nDESCRIPTION: Demonstrates how to save memory during parsing by clearing not only the current element's children but also its preceding siblings. This is useful for large XML files with many siblings.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfor event, element in parser.read_events():\n    # ... do something with the element\n    element.clear(keep_tail=True)   # clean up children\n    while element.getprevious() is not None:\n        del element.getparent()[0]  # clean up preceding siblings\n```\n\n----------------------------------------\n\nTITLE: Recursive Tree Dump of ObjectifiedElements in Python\nDESCRIPTION: This snippet demonstrates the use of the objectify.dump() function to get a recursive string representation of ObjectifiedElements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"\"\"\n... <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n...   <a attr1=\"foo\" attr2=\"bar\">1</a>\n...   <a>1.2</a>\n...   <b>1</b>\n...   <b>true</b>\n...   <c>what?</c>\n...   <d xsi:nil=\"true\"/>\n... </root>\n... \"\"\")\n\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 1 [IntElement]\n      * attr1 = 'foo'\n      * attr2 = 'bar'\n    a = 1.2 [FloatElement]\n    b = 1 [IntElement]\n    b = True [BoolElement]\n    c = 'what?' [StringElement]\n    d = None [NoneElement]\n      * xsi:nil = 'true'\n```\n\n----------------------------------------\n\nTITLE: Overriding Default XML Schema Instance Namespace Prefix\nDESCRIPTION: Shows how to override the default prefix for the XML Schema Instance namespace when creating elements with DataElement. Demonstrates namespace prefix customization.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n>>> el = objectify.DataElement('5', _xsi='foo:string',\n...          nsmap={'foo': 'http://www.w3.org/2001/XMLSchema',\n...                 'myxsi': 'http://www.w3.org/2001/XMLSchema-instance'})\n>>> namespaces = list(el.nsmap.items())\n>>> namespaces.sort()\n>>> for prefix, namespace in namespaces:\n...     print(\"%s - %s\" % (prefix, namespace))\nfoo - http://www.w3.org/2001/XMLSchema\nmyxsi - http://www.w3.org/2001/XMLSchema-instance\npy - http://codespeak.net/lxml/objectify/pytype\n\n>>> print(el.get(\"{http://www.w3.org/2001/XMLSchema-instance}type\"))\nfoo:string\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaced Elements with Custom Classes in lxml\nDESCRIPTION: Shows how to create namespaced elements using the parser.makeelement method. The example demonstrates that the custom element class is automatically associated with the created element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nhonk_element = parser.makeelement('{http://hui.de/honk}honk',\n                               honking='true')\nprint(honk_element.honking)\nTrue\n```\n\n----------------------------------------\n\nTITLE: One-Shot XMLSchema Validation in Python\nDESCRIPTION: Demonstrates the shortcut method for performing XMLSchema validation directly on a document. This approach is less efficient but simpler than creating a separate validator object.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> doc.xmlschema(xmlschema_doc)\nTrue\n>>> doc2.xmlschema(xmlschema_doc)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Identifying XML Comments and Processing Instructions\nDESCRIPTION: Demonstrates how to identify special XML node types like comments and processing instructions in lxml by comparing their tag property against the predefined etree.Comment and etree.PI constants.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML(\"<?my PI?><root><!-- empty --></root>\")\n\n>>> root.tag\n'root'\n>>> root.getprevious().tag is etree.PI\nTrue\n>>> root[0].tag is etree.Comment\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Elements with Custom Classes in lxml\nDESCRIPTION: Shows how to instantiate custom element classes directly to create XML fragments. The examples demonstrate creating elements with child elements and mixed content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nel = honk(honking='true')\nel.tag\n'honk'\nel.honking\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using XPath Variables\nDESCRIPTION: Shows how to use the xpath() method with variables, which allows parameterizing XPath expressions for more flexible queries.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> expr = \"//*[local-name() = $name]\"\n\n>>> print(root.xpath(expr, name = \"foo\")[0].tag)\nfoo\n\n>>> print(root.xpath(expr, name = \"bar\")[0].tag)\nbar\n\n>>> print(root.xpath(\"$text\", text = \"Hello World!\"))\nHello World!\n```\n\n----------------------------------------\n\nTITLE: Using the Atom Generator Module\nDESCRIPTION: Shows how to use the dedicated Atom generator module to create valid Atom feeds. The example demonstrates error handling for invalid element names and validation of the XML structure.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import atomgen as A\n\n>>> atom = A.feed(\n...   A.author( A.name(\"Stefan Behnel\") ),\n...   A.entry(\n...     A.link(href=\"http://codespeak.net/lxml/\"),\n...     A.title(\"News from lxml\"),\n...     A.summary(\"See what's <b>fun</b> about lxml...\",\n...               type=\"html\"),\n...   )\n... )\n\n>>> A.isvalid(atom) # ok, forgot the ID's => invalid XML ...\nFalse\n\n>>> title = A.titel(\"News from lxml\")\nTraceback (most recent call last):\n  ...\nAttributeError: 'module' object has no attribute 'titel'\n```\n\n----------------------------------------\n\nTITLE: Switching Between Data Types in ObjectifiedElements with Python\nDESCRIPTION: This snippet shows how to switch between different data types for the same child element in an ObjectifiedElement.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"<root><a>5</a></root>\")\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 5 [IntElement]\n\n>>> root.a = 'nice string!'\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 'nice string!' [StringElement]\n      * py:pytype = 'str'\n\n>>> root.a = True\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = True [BoolElement]\n      * py:pytype = 'bool'\n\n>>> root.a = [1, 2, 3]\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 1 [IntElement]\n      * py:pytype = 'int'\n    a = 2 [IntElement]\n      * py:pytype = 'int'\n    a = 3 [IntElement]\n      * py:pytype = 'int'\n\n>>> root.a = (1, 2, 3)\n>>> print(objectify.dump(root))\nroot = None [ObjectifiedElement]\n    a = 1 [IntElement]\n      * py:pytype = 'int'\n    a = 2 [IntElement]\n      * py:pytype = 'int'\n    a = 3 [IntElement]\n      * py:pytype = 'int'\n```\n\n----------------------------------------\n\nTITLE: Form Error Message Insertion in Python using lxml\nDESCRIPTION: Shows how to insert error messages into forms, adding error classes to inputs and labels, and displaying error messages.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_formfill.txt#2025-04-16_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from lxml.html.formfill import insert_errors_html\n>>> print(insert_errors_html('''\n... <form>\n...   <fieldset id=\"fieldset\">\n...     <input name=\"v1\"><br>\n...     <label for=\"v2\">label</label>\n...     <input name=\"v2\" id=\"v2\"><br>\n...   </fieldset>\n...   <input name=\"v3\" class=\"foo\">\n...   <input name=\"v3\" class=\"foo\">\n...   <input name=\"v4\">\n...   <input name=\"v4\">\n... </form>''', {\n...   'v1': \"err1\",\n...   'v2': \"err2\",\n...   'v3': [None, \"err3-2\"],\n...   'v4': \"err4\",\n...   None: 'general error',\n...   '#fieldset': 'area error',\n... }))\n```\n\n----------------------------------------\n\nTITLE: Displaying lxml Version Information in Python\nDESCRIPTION: This code snippet shows how to check and display version information for Python, lxml, and the underlying libxml2 and libxslt libraries. This is useful for troubleshooting compatibility issues and when reporting bugs.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom lxml import etree\n\nprint(\"%-20s: %s\" % ('Python',           sys.version_info))\nprint(\"%-20s: %s\" % ('lxml.etree',       etree.LXML_VERSION))\nprint(\"%-20s: %s\" % ('libxml used',      etree.LIBXML_VERSION))\nprint(\"%-20s: %s\" % ('libxml compiled',  etree.LIBXML_COMPILED_VERSION))\nprint(\"%-20s: %s\" % ('libxslt used',     etree.LIBXSLT_VERSION))\nprint(\"%-20s: %s\" % ('libxslt compiled', etree.LIBXSLT_COMPILED_VERSION))\n```\n\n----------------------------------------\n\nTITLE: Using Python Type Hints for ObjectifiedElements in Python\nDESCRIPTION: This snippet shows how to use Python type hints to determine the element class for ObjectifiedElements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> print(objectify.PYTYPE_ATTRIBUTE)\n{http://codespeak.net/lxml/objectify/pytype}pytype\n>>> ns, name = objectify.PYTYPE_ATTRIBUTE[1:].split('}')\n\n>>> root = objectify.fromstring(\"\"\"\n... <root xmlns:py='%s'>\n...   <a py:pytype='str'>5</a>\n...   <b py:pytype='int'>5</b>\n...   <c py:pytype='NoneType' />\n... </root>\n... \"\"\" % ns)\n\n>>> print(root.a + 10)\n510\n>>> print(root.b + 10)\n15\n>>> print(root.c)\nNone\n```\n\n----------------------------------------\n\nTITLE: Controlling Element Serialization with with_tail Parameter\nDESCRIPTION: Shows how to control whether tail text is included when serializing individual elements using the with_tail parameter of the tostring() function.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> etree.tostring(br)\nb'<br/>TAIL'\n>>> etree.tostring(br, with_tail=False) # lxml.etree only!\nb'<br/>'\n```\n\n----------------------------------------\n\nTITLE: Element Assignment with Slices\nDESCRIPTION: Shows how to use slice operations for replacing multiple elements at once, which is equivalent to assigning a list to an attribute.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> root.y[:] = [ objectify.Element(\"y\") ]\n>>> [ el.tag for el in root.y ]\n['y']\n```\n\n----------------------------------------\n\nTITLE: Utilizing BeautifulSoup's Encoding Detection with lxml's Parser\nDESCRIPTION: Shows how to leverage BeautifulSoup's UnicodeDammit class for encoding detection while still using lxml's faster HTML parser. Handles both BeautifulSoup 3 and 4 API differences.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/elementsoup.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> try:\n...    from bs4 import UnicodeDammit             # BeautifulSoup 4\n...\n...    def decode_html(html_string):\n...        converted = UnicodeDammit(html_string)\n...        if not converted.unicode_markup:\n...            raise UnicodeDecodeError(\n...                \"Failed to detect encoding, tried [%s]\",\n...                ', '.join(converted.tried_encodings))\n...        # print converted.original_encoding\n...        return converted.unicode_markup\n...\n... except ImportError:\n...    from BeautifulSoup import UnicodeDammit   # BeautifulSoup 3\n...\n...    def decode_html(html_string):\n...        converted = UnicodeDammit(html_string, isHTML=True)\n...        if not converted.unicode:\n...            raise UnicodeDecodeError(\n...                \"Failed to detect encoding, tried [%s]\",\n...                ', '.join(converted.triedEncodings))\n...        # print converted.originalEncoding\n...        return converted.unicode\n\n>>> root = lxml.html.fromstring(decode_html(tag_soup))\n```\n\n----------------------------------------\n\nTITLE: Using Element Namespace Class Lookup as Fallback in lxml\nDESCRIPTION: Shows how to create a chain of lookup mechanisms by setting ElementNamespaceClassLookup as the fallback for AttributeBasedElementClassLookup.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfallback = etree.ElementNamespaceClassLookup()\nlookup = etree.AttributeBasedElementClassLookup(\n                      'id', id_class_mapping, fallback)\nparser = etree.XMLParser()\nparser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Handling Namespace Prefix Conflicts in DataElement\nDESCRIPTION: Demonstrates how namespace prefixes are handled when adding elements to a tree with different namespace prefixes for the same namespace. Shows the xsiannotate() utility to fix prefix issues.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.fromstring(\"\"\"<root xmlns:schema=\"http://www.w3.org/2001/XMLSchema\"/>\"\"\")\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:schema=\"http://www.w3.org/2001/XMLSchema\"/>\n\n>>> s = objectify.DataElement(\"17\", _xsi=\"string\")\n>>> print(etree.tostring(s, pretty_print=True))\n<value xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" py:pytype=\"str\" xsi:type=\"xsd:string\">17</value>\n\n>>> root.s = s\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:schema=\"http://www.w3.org/2001/XMLSchema\">\n  <s xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" py:pytype=\"str\" xsi:type=\"xsd:string\">17</s>\n</root>\n\n>>> objectify.xsiannotate(root)\n>>> print(etree.tostring(root, pretty_print=True))\n<root xmlns:schema=\"http://www.w3.org/2001/XMLSchema\">\n  <s xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" py:pytype=\"str\" xsi:type=\"schema:string\">17</s>\n</root>\n```\n\n----------------------------------------\n\nTITLE: Using Schematron Validator as a Callable Object in lxml\nDESCRIPTION: Demonstrates how to use a Schematron validator instance as a callable object in conditional statements, which is equivalent to calling its validate method.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/validation.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> is_valid = etree.Schematron(sct_doc)\n\n>>> if not is_valid(doc):\n...     print(\"invalid!\")\ninvalid!\n```\n\n----------------------------------------\n\nTITLE: Using ensure_head_body Option with document_fromstring\nDESCRIPTION: Demonstrates the ensure_head_body option which ensures the created document has both head and body elements regardless of input. Shows behavior with different fragment types.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.html import document_fromstring, tostring\n>>> from functools import partial\n>>> tos = partial(tostring, encoding=unicode)\n>>> print(tos(document_fromstring('<p>test</p>')))\n<html><body><p>test</p></body></html>\n>>> print(tos(document_fromstring('<p>test</p>', ensure_head_body=True)))\n<html><head></head><body><p>test</p></body></html>\n>>> print(tos(document_fromstring('<meta>')))\n<html><head><meta></head></html>\n>>> print(tos(document_fromstring('<meta>', ensure_head_body=True)))\n<html><head><meta></head><body></body></html>\n>>> print(tos(document_fromstring('<html></html>')))\n<html></html>\n>>> print(tos(document_fromstring('<html></html>', ensure_head_body=True)))\n<html><head></head><body></body></html>\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements with Special Names in Objectify\nDESCRIPTION: Shows how to access elements that have names with special meaning in objectify, such as 'text'.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> root = objectify.XML(\"<root><text>TEXT</text></root>\")\n\n>>> print(root.text.text)\nTraceback (most recent call last):\n  ...\nAttributeError: 'NoneType' object has no attribute 'text'\n\n>>> print(root[\"text\"].text)\nTEXT\n```\n\n----------------------------------------\n\nTITLE: HTML and XHTML Parser Usage\nDESCRIPTION: Demonstrates using HTMLParser and XHTMLParser to parse HTML content into document trees\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_xhtml.txt#2025-04-16_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom lxml.html import HTMLParser, XHTMLParser\nhtml = \"<html><body><p>Hi!</p></body></html>\"\n\nroot = document_fromstring(html, parser=HTMLParser())\nprint(root.tag)\n\nroot = document_fromstring(html, parser=XHTMLParser())\nprint(root.tag)\n```\n\n----------------------------------------\n\nTITLE: Returning Node Sets from XPath Extension Functions\nDESCRIPTION: Demonstrates creating and returning Element node sets from XPath extension functions. The example builds a complex tree structure and shows how to access the results in different ways.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef returnsNodeSet(_):\n    results1 = etree.Element('results1')\n    etree.SubElement(results1, 'result').text = \"Alpha\"\n    etree.SubElement(results1, 'result').text = \"Beta\"\n\n    results2 = etree.Element('results2')\n    etree.SubElement(results2, 'result').text = \"Gamma\"\n    etree.SubElement(results2, 'result').text = \"Delta\"\n\n    results3 = etree.SubElement(results2, 'subresult')\n    return [results1, results2, results3]\n\nns['new-node-set'] = returnsNodeSet\n\ne = etree.XPathEvaluator(doc)\n\nr = e(\"new-node-set()/result\")\nprint([ t.text for t in r ])\n\nr = e(\"new-node-set()\")\nprint([ t.tag for t in r ])\nprint([ len(t) for t in r ])\nr[0][0].text\n\netree.tostring(r[0])\n\netree.tostring(r[1])\n\netree.tostring(r[2])\n```\n\n----------------------------------------\n\nTITLE: Using find_class Method in lxml.html\nDESCRIPTION: Demonstrates how to use the find_class method to search for elements with specific CSS classes. This snippet shows importing necessary functions and using find_class to find elements with classes 'fn' and 'vcard'.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from lxml.etree import Comment\n>>> from lxml.html import document_fromstring, fragment_fromstring, tostring\n>>> from lxml.html import fragments_fromstring, fromstring\n>>> from lxml.html import usedoctest\n>>> try: unicode = unicode\n... except NameError: unicode = str\n\n>>> h = document_fromstring('''\n... <html><head></head>\n... <body>\n...   <a class=\"vcard\nfn   url\" href=\"foobar\">P1</a>\n...   <a class=\"not-fn vcard\" href=\"baz\">P2</a>\n... </body></html>''')\n>>> print(tostring(h, encoding=unicode))\n<html>\n  <head></head>\n  <body>\n    <a class=\"vcard\nfn   url\" href=\"foobar\">P1</a>\n    <a class=\"not-fn vcard\" href=\"baz\">P2</a>\n  </body>\n</html>\n>>> print([e.text for e in h.find_class('fn')])\n['P1']\n>>> print([e.text for e in h.find_class('vcard')])\n['P1', 'P2']\n```\n\n----------------------------------------\n\nTITLE: Examining Default Namespace Mappings in DataElement\nDESCRIPTION: Shows the default namespace mappings used by DataElement for XML Schema and XML Schema Instance namespaces. Demonstrates how the namespace information is reflected in element attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n>>> el = objectify.DataElement('5', _xsi='string')\n>>> namespaces = list(el.nsmap.items())\n>>> namespaces.sort()\n>>> for prefix, namespace in namespaces:\n...     print(\"%s - %s\" % (prefix, namespace))\npy - http://codespeak.net/lxml/objectify/pytype\nxsd - http://www.w3.org/2001/XMLSchema\nxsi - http://www.w3.org/2001/XMLSchema-instance\n\n>>> print(el.get(\"{http://www.w3.org/2001/XMLSchema-instance}type\"))\nxsd:string\n```\n\n----------------------------------------\n\nTITLE: Setting Up Element Class Lookup in lxml.objectify Parser\nDESCRIPTION: Shows the internal implementation of the makeparser function, which creates an XMLParser with custom element class lookup settings for objectify.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n>>> parser = etree.XMLParser(remove_blank_text=True)\n\n>>> lookup = objectify.ObjectifyElementClassLookup()\n>>> parser.set_element_class_lookup(lookup)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Element Proxy Objects in Cython\nDESCRIPTION: Shows the correct way to instantiate _Element proxy objects using a factory function. This ensures proper setup of C-level members.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml-source-howto.txt#2025-04-16_snippet_1\n\nLANGUAGE: Cython\nCODE:\n```\ncdef xmlNode* c_node\ncdef _Document doc\ncdef _Element element\n...\nelement = _elementFactory(doc, c_node)\n```\n\n----------------------------------------\n\nTITLE: Understanding Limitations of XPath string() Functions\nDESCRIPTION: Shows that XPath functions like string() and concat() don't preserve parent information in their results, unlike the text() function.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/tutorial.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> stringify = etree.XPath(\"string()\")\n>>> print(stringify(html))\nTEXTTAIL\n>>> print(stringify(html).getparent())\nNone\n```\n\n----------------------------------------\n\nTITLE: XSLT Document with External References\nDESCRIPTION: Example XSLT stylesheet demonstrating usage of xsl:include and document() function with external URI references.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/resolvers.txt#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<xsl:stylesheet version=\"1.0\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:include href=\"honk:test\"/>\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:value-of select=\"document('hoi:test')/*/*/text()\"/>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n```\n\n----------------------------------------\n\nTITLE: Benchmarking XML Parsing with lxml's Native Tree Iterator in Python\nDESCRIPTION: This code snippet demonstrates a benchmarking function for parsing XML using lxml's native tree iterator. It parses an XML file, iterates over 'v' elements, and collects text containing 'begat'.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef bench_lxml_getiterator():\n    tree = etree.parse(\"ot.xml\")\n    result = []\n    for v in tree.getiterator(\"v\"):\n        text = v.text\n        if 'begat' in text:\n            result.append(text)\n    return len(result)\n```\n\n----------------------------------------\n\nTITLE: Using Namespaced Element Classes in lxml\nDESCRIPTION: Demonstrates how namespaced element classes are used when parsing or creating XML. Both examples show accessing the custom 'honking' property on the element.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nxml = '<honk xmlns=\"http://hui.de/honk\" honking=\"true\"/>'\nhonk_element = etree.XML(xml, parser)\nprint(honk_element.honking)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Removing Tail Text from XML Elements\nDESCRIPTION: Shows how to remove all tail text from XML elements by iterating through the tree.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfor element in root.iter():\n    element.tail = None\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Parsed Tree from XMLPullParser in lxml\nDESCRIPTION: Shows how to retrieve the complete parsed tree from an XMLPullParser after all parsing is complete using the close() method.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> root = parser.close()\n>>> etree.tostring(root)\nb'<root>some text<child><a/></child></root>'\n```\n\n----------------------------------------\n\nTITLE: HTML Tag Manipulation Utilities in Python\nDESCRIPTION: Utility functions for manipulating HTML tags including fixup_ins_del_tags(), split_unbalanced(), and split_trailing_whitespace() for handling HTML tag balancing and whitespace.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_diff.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml.html.diff import fixup_ins_del_tags, split_unbalanced, split_trailing_whitespace\ndef pfixup(text):\n    print(fixup_ins_del_tags(text).strip())\n```\n\n----------------------------------------\n\nTITLE: Enabling Recursive String Representation for ObjectifiedElements in Python\nDESCRIPTION: This snippet demonstrates how to enable and disable a pretty-print representation for objectify elements using enable_recursive_str().\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> objectify.enable_recursive_str()\n\n>>> root = objectify.fromstring(\"\"\"\n... <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n...   <a attr1=\"foo\" attr2=\"bar\">1</a>\n...   <a>1.2</a>\n...   <b>1</b>\n...   <b>true</b>\n...   <c>what?</c>\n...   <d xsi:nil=\"true\"/>\n... </root>\n... \"\"\")\n\n>>> print(str(root))\nroot = None [ObjectifiedElement]\n    a = 1 [IntElement]\n      * attr1 = 'foo'\n      * attr2 = 'bar'\n    a = 1.2 [FloatElement]\n    b = 1 [IntElement]\n    b = True [BoolElement]\n    c = 'what?' [StringElement]\n    d = None [NoneElement]\n      * xsi:nil = 'true'\n\n>>> objectify.enable_recursive_str(False)\n```\n\n----------------------------------------\n\nTITLE: Memory Usage Benchmarks for XML Parsing of Hamlet.xml\nDESCRIPTION: Memory usage statistics for different XML parsers processing a 274KB hamlet.xml file, showing before and after parsing memory consumption in KB. The benchmark compares various Python XML libraries including ElementTree, cElementTree, lxml, and minidom.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nMemory usage: 9256\nxml.etree.ElementTree.parse done in 0.006 seconds\nMemory usage: 12764 (+3508)\nxml.etree.cElementTree.parse done in 0.007 seconds\nMemory usage: 12764 (+3508)\nxml.etree.cElementTree.XMLParser.feed(): 6636 nodes read in 0.006 seconds\nMemory usage: 12720 (+3464)\nlxml.etree.parse done in 0.004 seconds\nMemory usage: 15052 (+5796)\ndrop_whitespace.parse done in 0.004 seconds\nMemory usage: 14040 (+4784)\nlxml.etree.XMLParser.feed(): 6636 nodes read in 0.004 seconds\nMemory usage: 15812 (+6556)\nminidom tree read in 0.066 seconds\nMemory usage: 15332 (+6076)\n```\n\n----------------------------------------\n\nTITLE: Element Class Specificity in Namespaces in lxml\nDESCRIPTION: Demonstrates that element classes are specific to tag names within a namespace. Elements with different tags in the same namespace get different classes unless a default is specified.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nxml = ('<honk xmlns=\"http://hui.de/honk\" honking=\"true\">'\n       '<bla/><!--comment-->'\n       '</honk>')\nhonk_element = etree.XML(xml, parser)\nprint(honk_element.honking)\nTrue\nprint(honk_element[0].honking)\nTraceback (most recent call last):\n  ...\nAttributeError: 'lxml.etree._Element' object has no attribute 'honking'\nprint(honk_element[1].text)\ncomment\n```\n\n----------------------------------------\n\nTITLE: Integrating with PullDOM and MiniDOM\nDESCRIPTION: Shows how to convert lxml trees to Python's built-in minidom format using xml.dom.pulldom.SAX2DOM handler.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/sax.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom xml.dom.pulldom import SAX2DOM\nhandler = SAX2DOM()\nlxml.sax.saxify(tree, handler)\ndom = handler.document\nprint(dom.firstChild.localName)\n```\n\n----------------------------------------\n\nTITLE: Unregistering Custom Types in lxml.objectify\nDESCRIPTION: Shows how to unregister a previously registered type using the unregister() method. The example demonstrates how unregistering a type removes its associated methods from element objects.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n>>> root.a.call_santa()\nHo ho ho!\n>>> xmas_type.unregister()\n>>> root.a.call_santa()\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: call_santa\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Document Links with iterlinks\nDESCRIPTION: Demonstration of the iterlinks method which extracts all links from a document along with their context elements and attributes.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_rewritelinks.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml.html import iterlinks, document_fromstring, tostring\ndef print_iter(seq):\n    for element, attrib, link, pos in seq:\n        if pos:\n            extra = '@%s' % pos\n        else:\n            extra = ''\n        print('%s %s=\"%s\"%s' % (element.tag, attrib, link, extra))\n```\n\n----------------------------------------\n\nTITLE: Handling Tag Name Changes\nDESCRIPTION: Shows the effect of changing an element's tag name on attribute access, which renders the element inaccessible by its old tag name.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> print(root.b.tag)\nb\n>>> root.b.tag = \"notB\"\n>>> root.b\nTraceback (most recent call last):\n  ...\nAttributeError: no such child: b\n>>> print(root.notB.tag)\nnotB\n```\n\n----------------------------------------\n\nTITLE: Using Element Slicing in lxml\nDESCRIPTION: Demonstrates extended slicing functionality for Elements in both etree and objectify modules.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nelement[1:-1:2]\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Namespace Classes in lxml\nDESCRIPTION: Shows how to create a class hierarchy for elements in a namespace, with a default base class and specialized element classes. This allows shared behavior across all elements in a namespace.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nclass HonkNSElement(etree.ElementBase):\n   def honk(self):\n      return \"HONK\"\nnamespace[None] = HonkNSElement  # default Element for namespace\n\nclass HonkElement(HonkNSElement):\n   @property\n   def honking(self):\n      return self.get('honking') == 'true'\nnamespace['honk'] = HonkElement  # Element for specific tag\n```\n\n----------------------------------------\n\nTITLE: Creating a Mock etree for Doctest Compatibility\nDESCRIPTION: Sets up a mock wrapper around etree to normalize output across Python versions, primarily handling newlines and encoding differences.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import sys\n>>> from lxml import etree as _etree\n>>> if sys.version_info[0] >= 3:\n...   class etree_mock(object):\n...     def __getattr__(self, name): return getattr(_etree, name)\n...     def tostring(self, *args, **kwargs):\n...       s = _etree.tostring(*args, **kwargs)\n...       if isinstance(s, bytes) and bytes([10]) in s: s = s.decode(\"utf-8\") # CR\n...       if s[-1] == '\\n': s = s[:-1]\n...       return s\n... else:\n...   class etree_mock(object):\n...     def __getattr__(self, name): return getattr(_etree, name)\n...     def tostring(self, *args, **kwargs):\n...       s = _etree.tostring(*args, **kwargs)\n...       if s[-1] == '\\n': s = s[:-1]\n...       return s\n>>> etree = etree_mock()\n```\n\n----------------------------------------\n\nTITLE: Handling Whitespace Before DOCTYPE\nDESCRIPTION: Shows how lxml.html handles leading whitespace before DOCTYPE declarations, demonstrating that it doesn't raise an error and properly parses the HTML document.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_basic.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.html\n>>> content='''\n...     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n...     <html>\n...     </html>'''\n>>> etree_document = lxml.html.fromstring(content)\n>>> print(tostring(etree_document, encoding=unicode))\n<html></html>\n```\n\n----------------------------------------\n\nTITLE: Defining lxml API Reference Table of Contents in reStructuredText\nDESCRIPTION: This snippet defines the structure of the lxml API reference documentation using reStructuredText directives. It includes a table of contents and links to index pages.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/api/index.rst#2025-04-16_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nlxml API Reference\n==================\n\n.. toctree::\n   :maxdepth: 4\n\n   lxml\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n```\n\n----------------------------------------\n\nTITLE: Finding Elements with ElementTree\nDESCRIPTION: A basic implementation using ElementTree's findall() method to search for verses containing 'begat' in an XML file. This approach first loads the entire document into memory.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef bench_ET():\n    tree = ElementTree.parse(\"ot.xml\")\n    result = []\n    for v in tree.findall(\"//v\"):\n        text = v.text\n        if 'begat' in text:\n            result.append(text)\n    return len(result)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Element Classes with XML Parsing\nDESCRIPTION: Demonstrates using a custom Element class to parse XML and access the custom properties. The HonkElement class provides a 'honking' property that interprets an attribute value.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> root = etree.XML('<root><honk honking=\"true\"/></root>',\n...                  parser)\n\n>>> root.honking\nFalse\n>>> root[0].honking\nTrue\n```\n\n----------------------------------------\n\nTITLE: Element Placement in Trees (ElementTree vs lxml.etree)\nDESCRIPTION: Illustrates the difference in element placement behavior between ElementTree and lxml.etree when adding an element to multiple trees.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na = Element('a')\nb = SubElement(a, 'b')\nc = Element('c')\nc.append(b)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating XPath Element Evaluator\nDESCRIPTION: Shows basic usage of XPathElementEvaluator and element finding in LXML.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/xpathxslt.txt#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(isinstance(xpatheval, etree.XPathElementEvaluator))\nprint(xpatheval(\"//b\")[0].tag)\n```\n\n----------------------------------------\n\nTITLE: Importing StringIO in Python 2/3 Compatible Way\nDESCRIPTION: Shows how to import StringIO module with Python 2 and 3 compatibility using try/except block.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/FAQ.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntry: from StringIO import StringIO\nexcept ImportError: from io import StringIO # Py3\nfilename = StringIO(\"<root/>\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Fallback Lookup Mechanism in lxml\nDESCRIPTION: Demonstrates how to create a fallback lookup mechanism that will be used when a namespace/tag combination is not found in the primary lookup. This example uses the 'honk' class as the default.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfallback = etree.ElementDefaultClassLookup(element=honk)\n```\n\n----------------------------------------\n\nTITLE: HTML/XHTML Conversion Functions\nDESCRIPTION: Shows how to convert between HTML and XHTML formats using conversion functions and verify the output\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_xhtml.txt#2025-04-16_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom lxml.html import xhtml_to_html, html_to_xhtml\n\ndoc = document_fromstring(html, parser=HTMLParser())\ntostring(doc)\n\nhtml_to_xhtml(doc)\ntostring(doc)\n\nxhtml_to_html(doc)\ntostring(doc)\n```\n\n----------------------------------------\n\nTITLE: Defining Element Proxy Class in Cython\nDESCRIPTION: Demonstrates the class declaration for the _Element proxy object, showing how it links to the underlying libxml2 node structure. Includes naming conventions for C-level members.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml-source-howto.txt#2025-04-16_snippet_0\n\nLANGUAGE: Cython\nCODE:\n```\ncdef class _Element:\n    cdef _Document _doc\n    cdef xmlNode* _c_node\n```\n\n----------------------------------------\n\nTITLE: Accessing text content in lxml ElementTree objects\nDESCRIPTION: Demonstrates how to access text content of HTML elements using the .text and .tail attributes in lxml. This shows the difference between element text and tail text.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/s5/lxml-ep2008.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> div = html.fragment_fromstring(\n...     \"<div><p>a paragraph<br>split in two</p> parts</div>\")\n>>> p = div[0]\n>>> br = p[0]\n\n>>> p.text\n'a paragraph'\n>>> br.text\n>>> br.tail\n'split in two'\n>>> p.tail\n' parts'\n```\n\n----------------------------------------\n\nTITLE: XML Tree Structure for Element 'a' in lxml.etree\nDESCRIPTION: Shows the resulting XML structure for element 'a' in lxml.etree after the element placement operation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<a></a>\n```\n\n----------------------------------------\n\nTITLE: Using Hierarchical Element Classes with Namespaces in lxml\nDESCRIPTION: Demonstrates using a class hierarchy for elements in a namespace. Shows how elements with the specific tag get the specialized class, while other elements get the default namespace class.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/element_classes.txt#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nxml = ('<honk xmlns=\"http://hui.de/honk\" honking=\"true\">'\n       '<bla/><!--comment-->'\n       '</honk>')\nhonk_element = etree.fromstring(xml, parser)\n\nprint(type(honk_element))\n<class 'HonkElement'>\nprint(type(honk_element[0]))\n<class 'HonkNSElement'>\n```\n\n----------------------------------------\n\nTITLE: Handling String/BytesIO Import Compatibility\nDESCRIPTION: Compatibility code for handling StringIO imports between Python 2 and 3, with UTF-8 encoding support for string inputs.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/sax.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry: from StringIO import StringIO\nexcept ImportError:\n   from io import BytesIO\n   def StringIO(s):\n       if isinstance(s, str): s = s.encode(\"UTF-8\")\n       return BytesIO(s)\n```\n\n----------------------------------------\n\nTITLE: Running HTML Doctests with lxml\nDESCRIPTION: Example showing how to use lxml's doctest comparison functionality for HTML documents, demonstrating different HTML formatting outputs that are considered equivalent.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxmlhtml.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.html.usedoctest\n>>> import lxml.html\n>>> html = lxml.html.fromstring('''\\\n...    <html><body onload=\"\" color=\"white\">\n...      <p>Hi  !</p>\n...    </body></html>\n... ''')\n\n>>> print lxml.html.tostring(html)\n<html><body onload=\"\" color=\"white\"><p>Hi !</p></body></html>\n\n>>> print lxml.html.tostring(html)\n<html> <body color=\"white\" onload=\"\"> <p>Hi    !</p> </body> </html>\n\n>>> print lxml.html.tostring(html)\n<html>\n  <body color=\"white\" onload=\"\">\n    <p>Hi !</p>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: XML Document with Root and Child Elements\nDESCRIPTION: A basic XML document starting with the XML declaration, followed by a root element 'foo' containing a child element with text content 'NEW TEXT'.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_18\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<foo><child>NEW TEXT</child></foo>\n\n```\n\n----------------------------------------\n\nTITLE: Importing lxml HTML Parsing Functions\nDESCRIPTION: Shows how to import basic HTML parsing and manipulation functions from lxml.html\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_xhtml.txt#2025-04-16_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom lxml.html import document_fromstring, fragment_fromstring, tostring\n```\n\n----------------------------------------\n\nTITLE: XML Tree Structure for Element 'c' in lxml.etree\nDESCRIPTION: Shows the resulting XML structure for element 'c' in lxml.etree after the element placement operation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n<c><b/></c>\n```\n\n----------------------------------------\n\nTITLE: XML Tree Structure for Element 'a' in ElementTree\nDESCRIPTION: Shows the resulting XML structure for element 'a' in ElementTree after the element placement operation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<a><b /></a>\n```\n\n----------------------------------------\n\nTITLE: Implementing StringIO Compatibility Layer\nDESCRIPTION: Compatibility code for handling StringIO across Python 2 and 3, with UTF-8 encoding support for string inputs.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/resolvers.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry: from StringIO import StringIO\nexcept ImportError:\n   from io import BytesIO\n   def StringIO(s):\n       if isinstance(s, str): s = s.encode(\"UTF-8\")\n       return BytesIO(s)\n```\n\n----------------------------------------\n\nTITLE: Installing lxml on Debian/Ubuntu using apt-get\nDESCRIPTION: This command installs the Python 3 version of lxml using the system package manager on Debian/Ubuntu systems.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install python3-lxml\n```\n\n----------------------------------------\n\nTITLE: Implementing Schematron Validation Pipeline with ANT\nDESCRIPTION: ANT build target that demonstrates the complete Schematron processing pipeline including inclusion expansion, abstract pattern expansion, schema compilation, and validation. Uses Saxon 9 XSLT processor for XSLT2 processing.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/readme.txt#2025-04-16_snippet_0\n\nLANGUAGE: ant\nCODE:\n```\n<target  name=\"schematron-compile-test\" >\n\n\t   <!-- expand inclusions -->\n\t   <xslt basedir=\"test/schematron\"\n\t   \t\tstyle=\"iso_dsdl_include.xsl\" in=\"test.sch\"  out=\"test1.sch\"> \n\t   \t\t\t\t<classpath>\n\t   \t\t\t\t\t<pathelement location=\"${lib.dir}/saxon9.jar\"/>\n\t   \t\t\t\t</classpath>\n\t   </xslt>\n\n\t   <!-- expand abstract patterns -->\n\t   <xslt basedir=\"test/schematron\"\n\t   \t\tstyle=\"iso_abstract_expand.xsl\" in=\"test1.sch\"  out=\"test2.sch\"> \n\t   \t\t\t\t<classpath>\n\t   \t\t\t\t\t<pathelement location=\"${lib.dir}/saxon9.jar\"/>\n\t   \t\t\t\t</classpath>\n\t   </xslt>\n\n\n\n\t   <!-- compile it -->\n\t   <xslt basedir=\"test/schematron\"\n\t   \t\tstyle=\"iso_svrl_for_xslt2.xsl\" in=\"test2.sch\"  out=\"test.xsl\"> \n\t   \t\t\t\t<classpath>\n\t   \t\t\t\t\t<pathelement location=\"${lib.dir}/saxon9.jar\"/>\n\t   \t\t\t\t</classpath>\n\t   </xslt>\n\t   \n\t   <!-- validate -->\n\t   <xslt basedir=\"test/schematron\"\n\t\t   \t\tstyle=\"test.xsl\" in=\"instance.xml\"  out=\"instance.svrlt\"> \n\t\t   \t\t\t\t<classpath>\n\t\t   \t\t\t\t\t<pathelement location=\"${lib.dir}/saxon9.jar\"/>\n\t\t   \t\t\t\t</classpath>\n\t</xslt>\n\t\t</target>\n```\n\n----------------------------------------\n\nTITLE: Defining an XSLT Stylesheet with Extension Element\nDESCRIPTION: Shows how to create an XSLT stylesheet that uses a custom extension element with the proper namespace declaration and extension-element-prefixes attribute.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_14\n\nLANGUAGE: xml\nCODE:\n```\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:my=\"testns\"\n    extension-element-prefixes=\"my\">\n    <xsl:template match=\"/\">\n        <foo><my:ext><child>XYZ</child></my:ext></foo>\n    </xsl:template>\n    <xsl:template match=\"child\">\n        <CHILD>--xyz--</CHILD>\n    </xsl:template>\n</xsl:stylesheet>\n```\n\n----------------------------------------\n\nTITLE: Initializing Cython Extension for lxml\nDESCRIPTION: Basic setup code for a Cython extension that interfaces with lxml.etree. Includes necessary imports and C-API initialization.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/capi.txt#2025-04-16_snippet_0\n\nLANGUAGE: cython\nCODE:\n```\n# My Cython extension\n\n# directive pointing compiler to lxml header files;\n# use ``aliases={\"LXML_PACKAGE_DIR\": lxml.__path__}``\n# argument to cythonize in setup.py to dynamically\n# determine dir at compile time\n# distutils: include_dirs = LXML_PACKAGE_DIR\n\n# import the public functions and classes of lxml.etree\ncimport lxml.includes.etreepublic as cetree\n\n# import the lxml.etree module in Python\ncdef object etree\nfrom lxml import etree\n\n# initialize the access to the C-API of lxml.etree\ncetree.import_lxml__etree()\n```\n\n----------------------------------------\n\nTITLE: Using lxml.etree In-Place in Python\nDESCRIPTION: Example of importing and using lxml.etree in a Python interactive session with proper path setup\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# cd lxml\n# PYTHONPATH=src python3\nPython 3.10.2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from lxml import etree\n>>>\n```\n\n----------------------------------------\n\nTITLE: Doctest Markup Suppression\nDESCRIPTION: Shows how to suppress special markup checking in doctests using the NOPARSE_MARKUP option.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n# doctest: +NOPARSE_MARKUP\n```\n\n----------------------------------------\n\nTITLE: Custom Prefix-Based URI Resolver\nDESCRIPTION: Implementation of a resolver that handles URIs based on specific prefixes, returning XSLT stylesheet content.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/resolvers.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass PrefixResolver(etree.Resolver):\n    def __init__(self, prefix):\n        self.prefix = prefix\n        self.result_xml = '''\\\n             <xsl:stylesheet\n                    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n               <test xmlns=\"testNS\">%s-TEST</test>\n             </xsl:stylesheet>\n             ''' % prefix\n    def resolve(self, url, pubid, context):\n        if url.startswith(self.prefix):\n            print(\"Resolved url %s as prefix %s\" % (url, self.prefix))\n            return self.resolve_string(self.result_xml, context)\n```\n\n----------------------------------------\n\nTITLE: XML Tree Structure for Element 'c' in ElementTree\nDESCRIPTION: Shows the resulting XML structure for element 'c' in ElementTree after the element placement operation.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/compatibility.txt#2025-04-16_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<c><b /></c>\n```\n\n----------------------------------------\n\nTITLE: Memory Usage Benchmarks for XML Parsing of Old Testament XML\nDESCRIPTION: Memory usage statistics for different XML parsers processing a 3.4MB Old Testament XML file, showing before and after parsing memory consumption in KB. The benchmark compares the same set of Python XML libraries on a larger file.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nMemory usage: 12456\nxml.etree.ElementTree.parse done in 0.037 seconds\nMemory usage: 23288 (+10832)\nxml.etree.cElementTree.parse done in 0.036 seconds\nMemory usage: 23288 (+10832)\nxml.etree.cElementTree.XMLParser.feed(): 25317 nodes read in 0.036 seconds\nMemory usage: 23644 (+11220)\nlxml.etree.parse done in 0.025 seconds\nMemory usage: 31404 (+18948)\ndrop_whitespace.parse done in 0.022 seconds\nMemory usage: 28752 (+16296)\nlxml.etree.XMLParser.feed(): 25317 nodes read in 0.026 seconds\nMemory usage: 33924 (+21500)\nminidom tree read in 0.194 seconds\nMemory usage: 31284 (+18828)\n```\n\n----------------------------------------\n\nTITLE: Initializing C Extension for lxml\nDESCRIPTION: Basic setup code for a C extension that interfaces with lxml.etree, including necessary header includes and initialization.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/capi.txt#2025-04-16_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* My C extension */\n\n/* common includes */\n#include \"Python.h\"\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdarg.h\"\n#include \"libxml/xmlversion.h\"\n#include \"libxml/encoding.h\"\n#include \"libxml/hash.h\"\n#include \"libxml/tree.h\"\n#include \"libxml/xmlIO.h\"\n#include \"libxml/xmlsave.h\"\n#include \"libxml/globals.h\"\n#include \"libxml/xmlstring.h\"\n\n/* lxml.etree specific includes */\n#include \"lxml-version.h\"\n#include \"etree_defs.h\"\n#include \"etree.h\"\n\n/* setup code */\nimport_lxml__etree()\n```\n\n----------------------------------------\n\nTITLE: XML Tree Setup Time Benchmarks\nDESCRIPTION: Comparison of tree setup times in seconds between lxml.etree and cElementTree across different test cases and configurations, showing lxml's overhead due to its different tree model.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nlxe:       --     S-     U-     -A     SA     UA\n     T1: 0.0219 0.0254 0.0257 0.0216 0.0259 0.0259\n     T2: 0.0234 0.0279 0.0283 0.0271 0.0318 0.0307\n     T3: 0.0051 0.0050 0.0058 0.0218 0.0233 0.0231\n     T4: 0.0001 0.0001 0.0001 0.0004 0.0004 0.0004\ncET:       --     S-     U-     -A     SA     UA\n     T1: 0.0035 0.0029 0.0078 0.0031 0.0031 0.0029\n     T2: 0.0047 0.0051 0.0053 0.0046 0.0055 0.0048\n     T3: 0.0016 0.0216 0.0027 0.0021 0.0023 0.0026\n     T4: 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000\n```\n\n----------------------------------------\n\nTITLE: Initializing HTML Diff Helper Functions in Python\nDESCRIPTION: Helper functions for normalizing whitespace and displaying HTML diffs. Includes pwrapped() for text normalization and pdiff() for displaying HTML differences.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_diff.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport re, textwrap\ndef pwrapped(text):\n    text = re.sub(r'[ \\n\\t\\r]+', ' ', text)\n    text = textwrap.fill(text)\n    print(text)\ndef pdiff(text1, text2):\n    pwrapped(htmldiff(text1, text2))\n```\n\n----------------------------------------\n\nTITLE: Entity Handling with BeautifulSoup Parser in lxml\nDESCRIPTION: Shows how the BeautifulSoup parser handles HTML entities by default (replacing them with character equivalents) and demonstrates various serialization options to control entity output.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/elementsoup.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> tag_soup = '<body>&copy;&euro;&#45;&#245;&#445;<p>'\n>>> body = fromstring(tag_soup).find('.//body')\n>>> body.text\n'\\xa9\\u20ac-\\xf5\\u01bd'\n\n>>> tostring(body)\n'<body>&#169;&#8364;-&#245;&#445;<p/></body>'\n\n>>> tostring(body, method=\"html\")\n'<body>&#169;&#8364;-&#245;&#445;<p></p></body>'\n\n>>> tostring(body, encoding=\"utf-8\")\n'<body>\\xc2\\xa9\\xe2\\x82\\xac-\\xc3\\xb5\\xc6\\xbd<p/></body>'\n\n>>> tostring(body, method=\"html\", encoding=\"utf-8\")\n'<body>\\xc2\\xa9\\xe2\\x82\\xac-\\xc3\\xb5\\xc6\\xbd<p></p></body>'\n\n>>> tostring(body, encoding='unicode')\n'<body>\\xa9\\u20ac-\\xf5\\u01bd<p/></body>'\n\n>>> tostring(body, method=\"html\", encoding='unicode')\n'<body>\\xa9\\u20ac-\\xf5\\u01bd<p></p></body>'\n```\n\n----------------------------------------\n\nTITLE: Installing a specific version of lxml using pip\nDESCRIPTION: This command installs a specific version (5.0.0) of lxml using pip.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install lxml==5.0.0\n```\n\n----------------------------------------\n\nTITLE: Setting Standalone XML Declaration Example\nDESCRIPTION: Example showing usage of the standalone flag in XML declarations accessible through tree.docinfo.standalone and configurable during serialization.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nstandalone=True/False\n```\n\n----------------------------------------\n\nTITLE: Building Static lxml with Custom Versions\nDESCRIPTION: Command for building lxml with specific versions of libxml2 and libxslt as static dependencies\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py build --static-deps \\\n         --libxml2-version=2.9.12 \\\n         --libxslt-version=1.1.34 \\\n\nsudo python setup.py install\n```\n\n----------------------------------------\n\nTITLE: Building lxml with Cython Support\nDESCRIPTION: Commands for building lxml with explicit Cython support and in-place building\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py build --with-cython\n\npython setup.py build_ext -i --with-cython\n```\n\n----------------------------------------\n\nTITLE: Running Python Tests with Valgrind Memory Checker\nDESCRIPTION: Command to execute Python tests using Valgrind memcheck tool with full leak checking and Python-specific suppressions. The command uses Python 3.10 and includes a suppression file to ignore known Python-related memory issues.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/valgrind.txt#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --tool=memcheck --leak-check=full --suppressions=valgrind-python.supp python3.10 test.py\n```\n\n----------------------------------------\n\nTITLE: Using Event Types with XMLPullParser in lxml\nDESCRIPTION: Partial example showing the beginning of a function that handles different types of parse events from an XMLPullParser.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/parsing.txt#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> def print_events(events):\n...     for action, obj in events:\n...         if action in ('start', 'end'):\n```\n\n----------------------------------------\n\nTITLE: Installing libxml2 and libxslt development packages on Debian/Ubuntu\nDESCRIPTION: This command installs the required development packages for libxml2, libxslt, and Python on Debian/Ubuntu systems.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libxml2-dev libxslt-dev python-dev\n```\n\n----------------------------------------\n\nTITLE: Using StringIO for Testing\nDESCRIPTION: Sets up a StringIO helper function for the doctests to handle string input, with Python 3 compatibility logic using BytesIO.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/objectify.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> try: from StringIO import StringIO\n... except ImportError:\n...     from io import BytesIO # Python 3\n...     def StringIO(s):\n...         if isinstance(s, str): s = s.encode('UTF-8')\n...         return BytesIO(s)\n```\n\n----------------------------------------\n\nTITLE: Checking Schematron Schema Validation Support\nDESCRIPTION: Code example showing how to check if schema file validation is supported in the ISO-Schematron implementation using a module constant.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlxml.isoschematron.schematron_schema_valid_supported\n```\n\n----------------------------------------\n\nTITLE: Building Windows Installer with Static Dependencies\nDESCRIPTION: Command to create a Windows installer for lxml with statically linked dependencies. Requires a properly configured C compiler for Python extensions.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\npython setup.py bdist_wininst --static-deps\n```\n\n----------------------------------------\n\nTITLE: Building lxml with Python Setup Tools\nDESCRIPTION: Basic build commands for compiling lxml from source using setup.py\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py build\n\npython setup.py bdist_egg     # requires 'setuptools' or 'distribute'\n```\n\n----------------------------------------\n\nTITLE: Installing Cython Dependencies with pip\nDESCRIPTION: Installs required dependencies listed in requirements.txt file for building lxml with Cython\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Benchmarks for iterparse Function in XML Libraries\nDESCRIPTION: Performance comparison of iterparse() function between lxml.etree and cElementTree, showing execution times in milliseconds per pass for different test scenarios.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nlxe: iterparse_bytesIO   (SAXR T1)   20.3598 msec/pass\ncET: iterparse_bytesIO   (SAXR T1)   10.8948 msec/pass\n\nlxe: iterparse_bytesIO   (UAXR T3)    10.1640 msec/pass\ncET: iterparse_bytesIO   (UAXR T3)   12.9926 msec/pass\n```\n\n----------------------------------------\n\nTITLE: Installing cssselect Package for Python\nDESCRIPTION: Command to install the cssselect package using pip. This package is required for lxml to use CSS selection functionality.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/cssselect.txt#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install cssselect\n```\n\n----------------------------------------\n\nTITLE: Enabling XML Doctest Comparison in Python\nDESCRIPTION: Code to enable relaxed XML comparison functionality in doctests using lxml.doctestcompare module.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml2.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.usedoctest\n```\n\n----------------------------------------\n\nTITLE: Python Async XMLFile Usage\nDESCRIPTION: Example showing xmlfile usage with async/await syntax\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nasync with xmlfile() as xf:\n    await xf.write(content)\n```\n\n----------------------------------------\n\nTITLE: XSLT File Output Example\nDESCRIPTION: Example of writing XSLT output to a file using the new write_output() method according to xsl:output configuration\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nxslt_result.write_output(file)\n```\n\n----------------------------------------\n\nTITLE: Cloning lxml Repository with Git\nDESCRIPTION: Command to clone the latest development version of lxml from GitHub. This allows developers to access the most recent codebase for building from source.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/main.txt#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/lxml/lxml.git lxml\n```\n\n----------------------------------------\n\nTITLE: Installing lxml build dependencies on Debian-based systems\nDESCRIPTION: This command installs all known build dependencies for the lxml package on Debian-based systems.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install build-dep python3-lxml\n```\n\n----------------------------------------\n\nTITLE: HTML Annotation Helper Functions in Python\nDESCRIPTION: Functions for annotating HTML content with version information. Includes markup() for adding version attributes and panno() for processing multiple document versions.\nSOURCE: https://github.com/lxml/lxml/blob/master/src/lxml/html/tests/test_diff.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef markup(text, annotation):\n    return '<span version=\"%s\">%s</span>' % (annotation, text)\ndef panno(*docs):\n    pwrapped(html_annotate([(doc, index) for index, doc in enumerate(docs)],\n                           markup=markup))\n```\n\n----------------------------------------\n\nTITLE: Example of Deprecated Function Names\nDESCRIPTION: Examples of deprecated CamelCase function names and their new underscore-style replacements following PEP 8 naming conventions\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml2.txt#2025-04-16_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# Old\netree.clearErrorLog()\netree.useGlobalPythonLog()\netree.ElementClassLookup.setFallback()\n\n# New\netree.clear_error_log()\netree.use_global_python_log()\netree.ElementClassLookup.set_fallback()\n```\n\n----------------------------------------\n\nTITLE: Enabling HTML Doctest Comparison in Python\nDESCRIPTION: Code to enable relaxed HTML comparison functionality in doctests using lxml.html.usedoctest module.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml2.txt#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import lxml.html.usedoctest\n```\n\n----------------------------------------\n\nTITLE: Installing lxml on macOS using MacPorts\nDESCRIPTION: This command installs lxml for Python 3.9 using the MacPorts package manager on macOS.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo port install py39-lxml\n```\n\n----------------------------------------\n\nTITLE: Installing lxml with static dependencies on macOS\nDESCRIPTION: This command installs lxml on macOS using pip, building static dependencies from source.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nSTATIC_DEPS=true sudo pip install lxml\n```\n\n----------------------------------------\n\nTITLE: Cloning lxml Repository using Mercurial\nDESCRIPTION: Clone the lxml source code repository using Mercurial (hg) with git support\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhg clone git+ssh://git@github.com/lxml/lxml.git lxml\n```\n\n----------------------------------------\n\nTITLE: Outdated Method References\nDESCRIPTION: List of deprecated methods that were removed from the lxml library.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nparser.setElementClassLookup()\nxslt_transform.apply()\nxpath.evaluate()\n```\n\n----------------------------------------\n\nTITLE: Installing lxml with disabled C compiler optimizations\nDESCRIPTION: This command installs lxml using pip with C compiler optimizations disabled, which can speed up the build in test environments.\nSOURCE: https://github.com/lxml/lxml/blob/master/INSTALL.txt#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCFLAGS=\"-O0\"  pip install lxml\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Element Class in Cython\nDESCRIPTION: Implementation of a custom element class by subclassing ElementBase and setting it as the default element class.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/capi.txt#2025-04-16_snippet_2\n\nLANGUAGE: cython\nCODE:\n```\nfrom lxml.includes.etreepublic cimport ElementBase\ncdef class NewElementClass(ElementBase):\n     def set_value(self, myval):\n         self.set(\"my_attribute\", myval)\n\netree.set_element_class_lookup(\n     etree.ElementDefaultClassLookup(element=NewElementClass))\n```\n\n----------------------------------------\n\nTITLE: Python ElementPath Predicate Example\nDESCRIPTION: Example showing ElementPath text predicate syntax for current node matching\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_3\n\nLANGUAGE: XML\nCODE:\n```\n[.='text']\n```\n\n----------------------------------------\n\nTITLE: Installing lxml with Static Dependencies on Linux\nDESCRIPTION: Command to install lxml package system-wide with static dependencies using pip and sudo. Uses STATIC_DEPS environment variable to ensure static linking.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nSTATIC_DEPS=true sudo pip install lxml\n```\n\n----------------------------------------\n\nTITLE: Example of New Python API Call\nDESCRIPTION: Example showing the replaced tounicode() function with the new tostring() call with unicode encoding parameter\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/lxml2.txt#2025-04-16_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ntostring(encoding='unicode')\n```\n\n----------------------------------------\n\nTITLE: Copyright Disclaimer Template for Employers\nDESCRIPTION: A sample copyright disclaimer form that employers can use to disclaim copyright interest in programs written by their employees under GPL. This helps clarify intellectual property ownership when applying the GPL license.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/licenses/GPL.txt#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nYoyodyne, Inc., hereby disclaims all copyright interest in the program\n`Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n<signature of Ty Coon>, 1 April 1989\nTy Coon, President of Vice\n```\n\n----------------------------------------\n\nTITLE: Interactive Program GPL Notice Example\nDESCRIPTION: A sample notice for interactive programs to display when starting in interactive mode. It includes copyright information and instructions for viewing warranty and redistribution details through hypothetical commands.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/licenses/GPL.txt#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nGnomovision version 69, Copyright (C) year  name of author\nGnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Cloning lxml Repository using Git\nDESCRIPTION: Clone the lxml source code repository using Git directly\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/build.txt#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone ssh://git@github.com/lxml/lxml.git lxml\n```\n\n----------------------------------------\n\nTITLE: Benchmarks for Serialization-Parse Cycle in XML Libraries\nDESCRIPTION: Performance comparison of complete round-trip serialization-parse cycles between lxml.etree and cElementTree, showing execution times in milliseconds per pass for various test scenarios.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nlxe: write_utf8_parse_bytesIO   (S-TR T1)   18.9857 msec/pass\ncET: write_utf8_parse_bytesIO   (S-TR T1)   35.7475 msec/pass\n\nlxe: write_utf8_parse_bytesIO   (UATR T2)   22.4853 msec/pass\ncET: write_utf8_parse_bytesIO   (UATR T2)   42.6254 msec/pass\n\nlxe: write_utf8_parse_bytesIO   (S-TR T3)    3.3801 msec/pass\ncET: write_utf8_parse_bytesIO   (S-TR T3)   11.2493 msec/pass\n\nlxe: write_utf8_parse_bytesIO   (SATR T4)    0.4263 msec/pass\ncET: write_utf8_parse_bytesIO   (SATR T4)    1.0326 msec/pass\n```\n\n----------------------------------------\n\nTITLE: Element Creation Performance Benchmarks in XML Libraries\nDESCRIPTION: Performance comparison of element creation operations between lxml.etree and cElementTree, showing execution times in milliseconds per pass for creating elements, making elements, and creating subelements.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nlxe: create_elements           (--TC T2)    0.8032 msec/pass\ncET: create_elements           (--TC T2)    0.0675 msec/pass\n\nlxe: makeelement               (--TC T2)    0.8030 msec/pass\ncET: makeelement               (--TC T2)    0.0625 msec/pass\n\nlxe: create_subelements        (--TC T2)    0.8621 msec/pass\ncET: create_subelements        (--TC T2)    0.0923 msec/pass\n```\n\n----------------------------------------\n\nTITLE: Document Merging Performance Benchmarks in XML Libraries\nDESCRIPTION: Performance comparison of merging operations between lxml.etree and cElementTree, showing execution times in milliseconds per pass for appending elements from one document to another.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/performance.txt#2025-04-16_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nlxe: append_from_document      (--TR T1,T2)    1.3800 msec/pass\ncET: append_from_document      (--TR T1,T2)    0.0513 msec/pass\n\nlxe: append_from_document      (--TR T3,T4)    0.0150 msec/pass\ncET: append_from_document      (--TR T3,T4)    0.0026 msec/pass\n```\n\n----------------------------------------\n\nTITLE: Specifying Cython Dependency for lxml Project\nDESCRIPTION: Defines the minimum required Cython version (3.1.0a1 or newer) needed for building or developing the lxml project. This is likely part of a requirements.txt or similar dependency specification file.\nSOURCE: https://github.com/lxml/lxml/blob/master/requirements.txt#2025-04-16_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCython>=3.1.0a1\n```\n\n----------------------------------------\n\nTITLE: GPL License Application Template for Source Files\nDESCRIPTION: A template notice to attach at the beginning of source files to apply the GPL license. It includes placeholders for program name, copyright year, and author name, followed by the standard GPL terms and contact information.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/licenses/GPL.txt#2025-04-16_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n```\n\n----------------------------------------\n\nTITLE: Registering XPath Extension Functions with FunctionNamespace\nDESCRIPTION: This snippet demonstrates how to use the FunctionNamespace class to register Python functions for use in XPath expressions. It shows both direct assignment and decorator-based registration.\nSOURCE: https://github.com/lxml/lxml/blob/master/doc/extensions.txt#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom lxml import etree\nns = etree.FunctionNamespace(None)\nns['hello'] = hello\nns['countargs'] = loadsofargs\n\n@ns\ndef hello(context, a):\n   return \"Hello %s\" % a\n```\n\n----------------------------------------\n\nTITLE: Configuring ISO-Schematron Validation\nDESCRIPTION: Code example showing how to disable schema validation in ISO-Schematron using the validate_schema parameter, which is useful when RNG validation schema files are not available due to licensing issues.\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nSchematron(..., validate_schema=False)\n```\n\n----------------------------------------\n\nTITLE: CSS Attribute Selector Pattern\nDESCRIPTION: Example showing the difference between CSS attribute selectors with and without spaces, where x[attr=\"val\"] and x [attr=\"val\"] have different matching behavior\nSOURCE: https://github.com/lxml/lxml/blob/master/CHANGES.txt#2025-04-16_snippet_7\n\nLANGUAGE: CSS\nCODE:\n```\nx[attr=\"val\"]\nx [attr=\"val\"]\n```"
  }
]