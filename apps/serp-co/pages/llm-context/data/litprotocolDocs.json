[
  {
    "owner": "lit-protocol",
    "repo": "docs",
    "content": "TITLE: Importing Lit SDK\nDESCRIPTION: Basic import statement for the Lit Protocol SDK.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient Connection in TypeScript\nDESCRIPTION: Demonstrates how to create a LitNodeClient instance and establish a connection to the Lit network using the DatilDev network configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/connecting-to-lit.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: false,\n});\n\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Client-Side Lit Implementation\nDESCRIPTION: Setup for client-side usage of Lit Protocol, including connection initialization and management.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nclass Lit {\n   litNodeClient;\n   chain;\n\n   constructor(chain){\n     this.chain = chain;\n   }\n\n   async connect() {\n      this.litNodeClient = new LitJsSdk.LitNodeClient({\n        litNetwork: LIT_NETWORK.DatilDev,\n      });\n      await this.litNodeClient.connect();\n   }\n}\n\nconst chain = \"ethereum\";\n\nlet myLit = new Lit(chain);\nawait myLit.connect();\n```\n\n----------------------------------------\n\nTITLE: Client-Side NodeJS Implementation\nDESCRIPTION: NodeJS implementation of Lit Action execution with predefined AuthSig\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {  \n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await Lit.Actions.signEcdsa({ toSign, publicKey , sigName });\n};\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\n    litNetwork: \"serrano\",\n  });\n  await litNodeClient.connect();\n  const signatures = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n      publicKey:\n        \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n      sigName: \"sig1\",\n    },\n  });\n  console.log(\"signatures: \", signatures);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Multiple Blockchain Wallets for Unified Access Control\nDESCRIPTION: This code demonstrates how to obtain authentication signatures from different blockchain wallets (Solana, Ethereum, Cosmos, and Kyve) and use them together when making requests to the Lit Node Client with unified access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/condition-types/unified-access-control-conditions.md#2025-04-18_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// first, obtain auth sigs from both chains\nvar solAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"solana\",\n});\n\nvar ethAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"ethereum\",\n});\n\nvar cosmosAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"cosmos\",\n});\n\nvar kyveAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"kyve\",\n});\n\n// now, when you want to use the auth sigs, pass them as an object, with the key being the chain name.\nawait litNodeClient.encryptString({\n  unifiedAccessControlConditions,\n  authSig: {\n    cosmos: cosmosAuthSig,\n    kyve: kyveAuthSig,\n    solana: solAuthSig,\n    ethereum: ethAuthSig, // note that the key here is \"ethereum\" for any and all EVM chains.  If you're using Polygon, for example, you should still have \"ethereum\" here.\n  },\n  dataToEncrypt: \"blah\",\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Session Keys with Lit Protocol in JavaScript\nDESCRIPTION: Demonstrates the complete flow of generating and signing a session key using Lit Actions. The code sets up a Lit Node Client, implements authentication callback using SIWE (Sign-In with Ethereum), and executes a Lit Action to sign data with the session key. Requires @lit-protocol/lit-node-client, ethers.js, and SIWE dependencies.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/additionalExamples/generatingSessionKey.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// this example will generate and sign a session key and use it for a request\n\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { SiweMessage } from \"siwe\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the response from the node\n  // and combined into a full signature by the LitJsSdk for you to use on the client\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await LitActions.signEcdsa({ toSign, publicKey, sigName });\n};\n\ngo();\n`;\n\nconst runLitAction = async () => {\n  // mock a wallet\n  const wallet = new Wallet(process.env.LIT_MUMBAI_DEPLOYER_PRIVATE_KEY);\n\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"localhost\",\n    debug: true,\n  });\n  await litNodeClient.connect();\n\n  // when the getSessionSigs function is called, it will generate a session key and sign it\n  // using this function. the session key will be used for all requests until the session expires\n  let authNeededCallback = async ({ chain, resources, expiration, uri }) => {\n    const domain = \"localhost:3000\";\n    const message = new SiweMessage({\n      domain,\n      address: wallet.address,\n      statement: \"Sign a session key to use with Lit Protocol\",\n      uri,\n      version: \"1\",\n      chainId: \"1\",\n      expirationTime: expiration,\n      resources,\n    });\n    const toSign = message.prepareMessage();\n    const signature = await wallet.signMessage(toSign);\n\n    const authSig = {\n      sig: signature,\n      derivedVia: \"web3.eth.personal.sign\",\n      signedMessage: toSign,\n      address: wallet.address,\n    };\n\n    return authSig;\n  };\n\n  let sessionSigs = await litNodeClient.getSessionSigs({\n    resources: [\"litAction://*\"],\n    chain: \"ethereum\",\n    authNeededCallback,\n  });\n\n  // console.log(\"got sessionSigs: \", sessionSigs);\n\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    sessionSigs,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n      publicKey:\n        \"0x040f6ab2fff4d845e1e4bd4af84cb5fe61266593500058dbd3df3075624e97823ab44e552f82075c583634f1b9d40c91d4eb666cdfca74b1bd7a63b6b26b27be16\",\n      sigName: \"sig1\",\n    },\n  });\n  console.log(\"results: \", results);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Generating Lit Protocol Session Signatures\nDESCRIPTION: Implementation of session signature generation for authenticating with the Lit network, including SIWE message creation and signing.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/quick-start.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  createSiweMessage,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\n\nconst sessionSignatures = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n  resourceAbilityRequests: [\n    {\n      resource: new LitActionResource(\"*\"),\n      ability: LIT_ABILITY.LitActionExecution,\n    },\n  ],\n  authNeededCallback: async ({\n    uri,\n    expiration,\n    resourceAbilityRequests,\n  }) => {\n    const toSign = await createSiweMessage({\n      uri,\n      expiration,\n      resources: resourceAbilityRequests,\n      walletAddress: await ethersWallet.getAddress(),\n      nonce: await litNodeClient.getLatestBlockhash(),\n      litNodeClient,\n    });\n\n    return await generateAuthSig({\n      signer: ethersWallet,\n      toSign,\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Decrypting Encrypted String Data in Lit Protocol using JSX\nDESCRIPTION: This code snippet demonstrates how to decrypt previously encrypted string data using the Lit Protocol. It uses the decryptToString() function, passing in the necessary parameters including access control conditions, ciphertext, data hash, and session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nclass Lit {\n    ...\n\n    async decrypt(ciphertext, dataToEncryptHash) {\n      // Get the session signatures\n      const sessionSigs = await this.getSessionSignatures();\n\n      // Decrypt the message\n      const decryptedString = await LitJsSdk.decryptToString(\n        {\n          accessControlConditions,\n          chain: this.chain,\n          ciphertext,\n          dataToEncryptHash,\n          sessionSigs,\n        },\n        this.litNodeClient,\n      );\n\n      // Return the decrypted string\n      return { decryptedString };\n    }\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nested Lit Actions\nDESCRIPTION: Shows how to execute a nested Lit Action on Lit nodes with proper configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from '@lit-protocol/lit-node-client';\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"datil-dev\",\n    debug: true,\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    sessionSigs,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      functionToRun: \"signEcdsa\",\n    },\n  });\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Encryption Implementation\nDESCRIPTION: Implementation of string encryption using the Lit Protocol SDK.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { encryptString } from '@lit-protocol/encryption';\n\nclass Lit {\n    ...\n\n    async encrypt(message) {\n      // Encrypt the message\n      const { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n        {\n          accessControlConditions,\n          dataToEncrypt: message,\n        },\n        this.litNodeClient,\n      );\n\n      // Return the ciphertext and dataToEncryptHash\n      return {\n        ciphertext,\n        dataToEncryptHash,\n      };\n    }\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather-Based Conditional Signing in Lit Action\nDESCRIPTION: A Lit Action that fetches current temperature data from the National Weather Service API and conditionally signs a message if the temperature exceeds 60°F. Includes error handling and response setting functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/fetch.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst _litActionCode = async () => {\n  try {\n    const url = \"https://api.weather.gov/gridpoints/TOP/31,80/forecast\";\n    const resp = await fetch(url).then((response) => response.json());\n    const temp = resp.properties.periods[0].temperature;\n    console.log(\"Current temperature from the API:\", temp);\n\n    if (temp < 60) {\n      Lit.Actions.setResponse({ response: \"It's too cold to sign the message!\" });\n      return;\n    }\n\n    const sigShare = await LitActions.signEcdsa({ toSign, publicKey, sigName });\n    Lit.Actions.setResponse({ response: sigShare });\n  } catch (error) {\n    Lit.Actions.setResponse({ response: error.message });\n  }\n};\n\nexport const litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Signing with Lit Protocol\nDESCRIPTION: A complete example demonstrating how to implement conditional signing using Lit Protocol. The code checks if a user has at least 1 Wei on Ethereum before generating a signature. It includes both the Lit Action code that runs on nodes and the client-side implementation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/workingWithActions/conditionalSigning.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  // test an access control condition\n  const testResult = await Lit.Actions.checkConditions({conditions, authSig, chain})\n\n  console.log('testResult', testResult)\n\n  // only sign if the access condition is true\n  if (!testResult){\n    return;\n  }\n\n  // this is the string \"Hello World\" for testing\n  const toSign = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100];\n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  const sigShare = await LitActions.signEcdsa({ toSign, publicKey: \"0x02e5896d70c1bc4b4844458748fe0f936c7919d7968341e391fb6d82c258192e64\", sigName: \"sig1\" });\n};\n\n\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    litNetwork: \"serrano\",\n  });\n  await litNodeClient.connect();\n  const signatures = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    jsParams: {\n      conditions: [\n        {\n          conditionType: \"evmBasic\",\n          contractAddress: \"\",\n          standardContractType: \"\",\n          chain: \"ethereum\",\n          method: \"eth_getBalance\",\n          parameters: [\":userAddress\", \"latest\"],\n          returnValueTest: {\n            comparator: \">=\",\n            value: \"1\",\n          },\n        },\n      ],\n      authSig: {\n        sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n        derivedVia: \"web3.eth.personal.sign\",\n        signedMessage:\n          \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n        address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n      },\n      chain: \"ethereum\",\n    },\n  });\n  console.log(\"signatures: \", signatures);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Initializing Google Authentication with Lit Protocol\nDESCRIPTION: Sets up Google OAuth authentication using LitRelay and GoogleProvider classes. Includes connecting to Lit Node Client and implementing the basic sign-in flow.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/social-login.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { GoogleProvider } from '@lit-protocol/providers';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize Google provider\nconst googleProvider = new GoogleProvider({ relay, litNodeClient });\n\n// Begin login flow with Google\nasync function authWithGoogle() {\n  await googleProvider.signIn();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions for Lit Protocol\nDESCRIPTION: TypeScript code for setting up Access Control Conditions (ACCs) that specify who can decrypt the data based on Ethereum address ownership.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst accessControlConditions = [\n    {\n        contractAddress: \"\",\n        standardContractType: \"\",\n        chain: \"ethereum\",\n        method: \"\",\n        parameters: [\":userAddress\"],\n        returnValueTest: {\n        comparator: \"=\",\n        value: ethersWallet.address, // <--- The address of the wallet that can decrypt the data\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with Lit Protocol in JavaScript\nDESCRIPTION: This code demonstrates how to use the Lit SDK to generate session signatures. It includes setting up a LitNodeClient, implementing an authentication callback using SIWE (Sign-In with Ethereum), and making a request for specific resources and abilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/getSessionSigs.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client@serrano\";\nimport {\n  LitAccessControlConditionResource,\n  LitAbility,\n} from \"@lit-protocol/auth-helpers\";\n\n// Create a new ethers.js Wallet instance\nconst wallet = new Wallet(process.env.YOUR_PRIVATE_KEY);\n\n// Instantiate a LitNodeClient\nconst litNodeClient = new LitNodeClient({\n  litNetwork: \"serrano\",\n  debug: true,\n});\nawait litNodeClient.connect();\n\n/**\n * When the getSessionSigs function is called, it will generate a session key\n * and sign it using a callback function. The authNeededCallback parameter\n * in this function is optional. If you don't pass this callback,\n * then the user will be prompted to authenticate with their wallet.\n */\nconst authNeededCallback = async ({ chain, resources, expiration, uri }) => {\n  const domain = \"localhost:3000\";\n  const message = new SiweMessage({\n    domain,\n    address: wallet.address,\n    statement: \"Sign a session key to use with Lit Protocol\",\n    uri,\n    version: \"1\",\n    chainId: \"1\",\n    expirationTime: expiration,\n    resources,\n  });\n  const toSign = message.prepareMessage();\n  const signature = await wallet.signMessage(toSign);\n\n  const authSig = {\n    sig: signature,\n    derivedVia: \"web3.eth.personal.sign\",\n    signedMessage: toSign,\n    address: wallet.address,\n  };\n\n  return authSig;\n};\n\n// Create an access control condition resource\nconst litResource = new LitAccessControlConditionResource(\n  hashedEncryptedSymmetricKeyString\n);\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  resourceAbilityRequests: [\n    {\n      resource: litResource,\n      ability: LitAbility.AccessControlDescription,\n    },\n  ],\n  authNeededCallback,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Lit Action IPFS Execution\nDESCRIPTION: Simplified example showing how to execute a Lit Action stored on IPFS using the litNodeClient.executeJs method with session signatures and IPFS CID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/deploying.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait litNodeClient.executeJs({\n    sessionSigs,\n    ipfsId: process.env.LIT_ACTION_IPFS_CID,\n});\n```\n\n----------------------------------------\n\nTITLE: Complete Lit Action IPFS Deployment Implementation\nDESCRIPTION: Full implementation showing how to connect to a Lit network, generate session signatures, and execute a Lit Action from IPFS. Includes setting up the Lit Node Client and handling authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/deploying.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_RPC, LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  createSiweMessageWithRecaps,\n  generateAuthSig,\n  LitActionResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    resourceAbilityRequests: [\n        {\n            resource: new LitActionResource(\"*\"),\n            ability: LIT_ABILITY.LitActionExecution,\n        },\n    ],\n    authNeededCallback: async ({\n        resourceAbilityRequests,\n        expiration,\n        uri,\n    }) => {\n        const toSign = await createSiweMessageWithRecaps({\n            uri: uri!,\n            expiration: expiration!,\n            resources: resourceAbilityRequests!,\n            walletAddress: ethersSigner.address,\n            nonce: await litNodeClient.getLatestBlockhash(),\n            litNodeClient,\n        });\n\n        return await generateAuthSig({\n            signer: ethersSigner,\n            toSign,\n        });\n    },\n});\n\nawait litNodeClient.executeJs({\n    sessionSigs,\n    ipfsId: process.env.LIT_ACTION_IPFS_CID,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing EIP-191 Signing in Lit Actions using JavaScript\nDESCRIPTION: This code snippet demonstrates how to use the ethPersonalSignMessageEcdsa method to sign a message according to the EIP-191 standard within a Lit Action. It includes error handling and response setting.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/eip191.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst _litActionCode = async () => {\n  try {\n    const sigShare = await LitActions.ethPersonalSignMessageEcdsa({\n      message: dataToSign,\n      publicKey,\n      sigName,\n    });\n    LitActions.setResponse({ response: sigShare });\n  } catch (error) {\n    LitActions.setResponse({ response: error.message });\n  }\n};\n\nexport const litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: Instantiating Lit Node Client\nDESCRIPTION: Creation and connection of LitNodeClient instance configured for the Datil test network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/using-delegated-auth-sig.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlitNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilTest,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Contract Client\nDESCRIPTION: Setup for initializing a contract client with a wallet signer for the Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst walletWithCapacityCredit = new Wallet(\"<your private key or mnemonic>\");\n\nlet contractClient = new LitContracts({\n  signer: dAppOwnerWallet,\n  network: LIT_NETWORK.Datil,\n});\n\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signature from Capacity Credit Delegation in JavaScript\nDESCRIPTION: This code snippet demonstrates how to generate a session signature for a PKP using a capacity credit delegation. It includes creating an auth callback, getting session signatures, and executing a JavaScript function to sign data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nconst pkpAuthNeededCallback = async ({\n  expiration,\n  resources,\n  resourceAbilityRequests,\n}) => {\n  // -- validate\n  if (!expiration) {\n    throw new Error('expiration is required');\n  }\n\n  if (!resources) {\n    throw new Error('resources is required');\n  }\n\n  if (!resourceAbilityRequests) {\n    throw new Error('resourceAbilityRequests is required');\n  }\n\n  const response = await litNodeClient.signSessionKey({\n    statement: 'Some custom statement.',\n    authMethods: [secondWalletControllerAuthMethod],  // authMethods for signing the sessionSigs\n    pkpPublicKey: secondWalletPKPInfo.publicKey,  // public key of the wallet which is delegated\n    expiration: expiration,\n    resources: resources,\n    chainId: 1,\n\n    // optional (this would use normal siwe lib, without it, it would use lit-siwe)\n    resourceAbilityRequests: resourceAbilityRequests,\n  });\n\n  console.log('response:', response);\n\n  return response.authSig;\n};\n\nconst pkpSessionSigs = await litNodeClient.getSessionSigs({\n  pkpPublicKey: secondWalletPKPInfo.publicKey,   // public key of the wallet which is delegated\n  expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n  chain: 'ethereum',\n  resourceAbilityRequests: [\n    {\n      resource: new LitPKPResource('*'),\n      ability: LIT_ABILITY.PKPSigning,\n    },\n  ],\n  authNeededCallback: pkpAuthNeededCallback,\n  capacityDelegationAuthSig, // here is where we add the delegation to our session request\n});\n\nconsole.log(\"generated session with delegation \", pkpSessionSigs);\n\nconst res = await litNodeClient.executeJs({\n  sessionSigs: pkpSessionSigs,\n  code: `(async () => {\n      const sigShare = await LitActions.signEcdsa({\n        toSign: dataToSign,\n        publicKey,\n        sigName: \"sig\",\n      });\n    })();`,\n  authMethods: [],\n  jsParams: {     // parameters to js function above\n    dataToSign: ethers.utils.arrayify(\n      ethers.utils.keccak256([1, 2, 3, 4, 5])\n    ),\n    publicKey: secondWalletPKPInfo.publicKey,\n  },\n});\n\nconsole.log(\"signature result \", res);\n```\n\n----------------------------------------\n\nTITLE: Signing a Transaction with Lit Action in JavaScript\nDESCRIPTION: This code snippet demonstrates how to sign a transaction using a Lit Action. It sets up the Lit Action code to be run on Lit nodes and executes it using the litNodeClient.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nconst litActionCode = `\n    const go = async () => {\n    // The params toSign, publicKey, sigName are passed from the jsParams fields and are available here\n    const sigShare = await Lit.Actions.signEcdsa({ toSign, publicKey, sigName });\n    };\n\n    go();\n`;\n\nconst signatures = await litNodeClient.executeJs({\n  code: litActionCode,\n  authSig,\n  jsParams: {\n    toSign: [84, 104, 105, 115, 32, 109, 101, 115, 115, 97, 103, 101, 32, 105, 115, 32, 101, 120, 97, 99, 116, 108, 121, 32, 51, 50, 32, 98, 121, 116, 101, 115],\n    publicKey: mintInfo.pkp.publicKey,\n    sigName: \"sig1\",\n  },\n});\n\nconsole.log(\"signatures: \", signatures);\n```\n\n----------------------------------------\n\nTITLE: Implementing EIP191 Message Signing with Lit Protocol\nDESCRIPTION: A complete implementation showing how to sign messages using EIP191 standard with Lit Protocol. The code demonstrates connection to Lit nodes, message signing, signature verification, and public key/address recovery. Uses ethers.js utilities for signature manipulation and verification.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/additionalExamples/usingEIP.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\nimport fs from \"fs\";\nimport { serialize, recoverAddress } from \"@ethersproject/transactions\";\nimport {\n  hexlify,\n  splitSignature,\n  hexZeroPad,\n  joinSignature,\n} from \"@ethersproject/bytes\";\nimport { recoverPublicKey, computePublicKey } from \"@ethersproject/signing-key\";\nimport { verifyMessage } from \"@ethersproject/wallet\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await LitActions.ethPersonalSignMessageEcdsa({ message, publicKey , sigName });\n};\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst go = async () => {\n  const message = \"Hello World\";\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    litNetwork: \"custom\",\n    bootstrapUrls: [\n      \"http://localhost:7470\",\n      \"http://localhost:7471\",\n      \"http://localhost:7472\",\n      \"http://localhost:7473\",\n      \"http://localhost:7474\",\n      \"http://localhost:7475\",\n      \"http://localhost:7476\",\n      \"http://localhost:7477\",\n      \"http://localhost:7478\",\n      \"http://localhost:7479\",\n    ],\n  });\n  await litNodeClient.connect();\n  const signatures = await litNodeClient.executeJs({\n    code: litActionCode,\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      message,\n      publicKey:\n        \"0x02e5896d70c1bc4b4844458748fe0f936c7919d7968341e391fb6d82c258192e64\",\n      sigName: \"sig1\",\n    },\n    authSig,\n  });\n  console.log(\"signatures: \", signatures);\n  const sig = signatures.sig1;\n  const dataSigned = \"0x\" + sig.dataSigned;\n  const encodedSig = joinSignature({\n    r: \"0x\" + sig.r,\n    s: \"0x\" + sig.s,\n    v: sig.recid,\n  });\n\n  console.log(\"encodedSig\", encodedSig);\n  console.log(\"sig length in bytes: \", encodedSig.substring(2).length / 2);\n  console.log(\"dataSigned\", dataSigned);\n  const splitSig = splitSignature(encodedSig);\n  console.log(\"splitSig\", splitSig);\n\n  const recoveredPubkey = recoverPublicKey(dataSigned, encodedSig);\n  console.log(\"uncompressed recoveredPubkey\", recoveredPubkey);\n  const compressedRecoveredPubkey = computePublicKey(recoveredPubkey, true);\n  console.log(\"compressed recoveredPubkey\", compressedRecoveredPubkey);\n  const recoveredAddress = recoverAddress(dataSigned, encodedSig);\n  console.log(\"recoveredAddress\", recoveredAddress);\n\n  const recoveredAddressViaMessage = verifyMessage(message, encodedSig);\n  console.log(\"recoveredAddressViaMessage\", recoveredAddressViaMessage);\n};\n\ngo();\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Auth Method for Solana Public Key in TypeScript\nDESCRIPTION: This code demonstrates how to create a custom Auth Method Type and ID for a Solana public key using ethers.js. The Auth Method Type is a unique identifier for the application, and the Auth Method ID is generated based on the Solana public key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/siws-pkp-session-sigs.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst authMethodType = ethers.utils.keccak256(\n    // This can be anything, but should be unique to your app\n    ethers.utils.toUtf8Bytes(\"Lit Developer Guide Solana SIWS Example\")\n);\nconst authMethodId = ethers.utils.keccak256(\n    ethers.utils.toUtf8Bytes(`siws:${solanaPublicKey}`)\n);\n```\n\n----------------------------------------\n\nTITLE: Executing Lit Action with Session Signatures\nDESCRIPTION: Example of executing a simple Lit Action using the generated session signatures with delegation auth.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/using-delegated-auth-sig.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait litNodeClient.executeJs({\n    sessionSigs,\n    code: `(() => console.log(\"It works!\"))();`,\n});\n```\n\n----------------------------------------\n\nTITLE: Encrypting Text with Lit Protocol in JavaScript\nDESCRIPTION: This function encrypts the input text using Lit Protocol. It connects to Lit nodes, obtains an auth signature, encrypts the string, and saves the encryption key with access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/encryptDecrypt.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync encryptText(text) {\n  if (!this.litNodeClient) {\n    await this.connect();\n  }\n  const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });\n  const { encryptedString, symmetricKey } = await LitJsSdk.encryptString(text);\n\n  const encryptedSymmetricKey = await this.litNodeClient.saveEncryptionKey({\n    accessControlConditions: accessControlConditions,\n    symmetricKey,\n    authSig,\n    chain,\n  });\n\n  return {\n      encryptedString,\n      encryptedSymmetricKey: LitJsSdk.uint8arrayToString(encryptedSymmetricKey, \"base16\")\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Example SessionSig JSON Structure for Lit Protocol\nDESCRIPTION: This snippet demonstrates the structure of a SessionSig in Lit Protocol. It includes fields for the signature, signing method, signed message (containing session details and capabilities), the session public key, and the signing algorithm.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/intro.md#2025-04-18_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"sig\": \"0196a7e5b8271e287fc376af3ae35955cac1009149b9b9eab4c5f8c845ca20658f937a42b7c03a8884573b801de1c36f9fa8a6d2f3ba432dc4326443c114c40c\",\n    \"derivedVia\": \"litSessionSignViaNacl\",\n    \"signedMessage\": '{\\n        \"sessionKey\": \"6a1f1e8a00b61867b85eaf329d6fdf855220ac3e32f44ec13e4db0dd303dea6a\",\\n        \"resourceAbilityRequest\": [\\n            {\\n                \"resource\": \"lit-accesscontrolcondition://524a697a410a417fb95a9f52d57cba5fa7c87b3acd3b408cf14560fa52691251\",\\n                \"ability\": \"access-control-condition-decryption\"\\n            }\\n        ],\\n        \"capabilities\": [{\\n            \"sig\": \"0xef8f88fb285c0065946f7257034226923e3bbf7c6c69f8863be213e50a1c1d7f18124eefdc595b4f50a0e242e8e132c5078dc3c52bda55376ba314e08da862e21a\",\\n            \"derivedVia\": \"web3.eth.personal.sign\",\\n            \"signedMessage\": \"localhost:3000 wants you to sign in with your Ethereum account:\\n                0x5259E44670053491E7b4FE4A120C70be1eAD646b\\n                \\n                \\n                URI: lit:session:6a1f1e8a00b61867b85eaf329d6fdf855220ac3e32f44ec13e4db0dd303dea6a\\n                Version: 1\\n                Chain ID: 1\\n                Nonce: ZfYjGsNyaDDFlaftP\\n                Issued At: 2022-10-30T08:25:33.371Z\\n                Expiration Time: 2022-11-06T08:25:33.348Z\\n                Resources:\\n                - urn:recap:eyJhdHQiOnsibGl0LWFjY2Vzc2NvbnRyb2xjb25kaXRpb246Ly81MjRhNjk3YTQxMGE0MTdmYjk1YTlmNTJkNTdjYmE1ZmE3Yzg3YjNhY2QzYjQwOGNmMTQ1NjBmYTUyNjkxMjUxIjp7IiovKiI6W3t9XX19LCJwcmYiOltdfQo=\",\\n            \"address\":\"0x5259E44670053491E7b4FE4A120C70be1eAD646b\"\\n        }],\\n        \"issuedAt\": \"2022-10-30T08:27:01.667Z\",\\n        \"expiration\": \"2022-10-30T08:32:01.667Z\",\\n        \"nodeAddress\": \"https://node2.litgateway.com:7370\"\\n    }',\n    \"address\": \"6a1f1e8a00b61867b85eaf329d6fdf855220ac3e32f44ec13e4db0dd303dea6a\",\n    \"algo\": \"ed25519\"\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Lit Action\nDESCRIPTION: Code to execute a Lit Action using the litNodeClient, including session signatures and parameters.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/quick-start.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await litNodeClient.executeJs({\n  sessionSigs: sessionSignatures,\n  code: litActionCode,\n  jsParams: {\n    magicNumber: 43,\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying Lit Action Using Code String in TypeScript\nDESCRIPTION: This snippet demonstrates how to deploy a Lit Action by providing the code as a string and executing it using the Lit SDK. It includes setting up the Lit Node Client, generating session signatures, and calling the executeJs method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/deploying.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_RPC, LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  createSiweMessageWithRecaps,\n  generateAuthSig,\n  LitActionResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    resourceAbilityRequests: [\n        {\n            resource: new LitActionResource(\"*\"),\n            ability: LIT_ABILITY.LitActionExecution,\n        },\n    ],\n    authNeededCallback: async ({\n        resourceAbilityRequests,\n        expiration,\n        uri,\n    }) => {\n        const toSign = await createSiweMessageWithRecaps({\n            uri: uri!,\n            expiration: expiration!,\n            resources: resourceAbilityRequests!,\n            walletAddress: ethersSigner.address,\n            nonce: await litNodeClient.getLatestBlockhash(),\n            litNodeClient,\n        });\n\n        return await generateAuthSig({\n            signer: ethersSigner,\n            toSign,\n        });\n    },\n});\n\nconst litActionCode = `\n(async () => {\n  console.log(\"This is my Lit Action!\");\n})();\n`;\n\nawait litNodeClient.executeJs({\n    sessionSigs,\n    code: litActionCode,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Serializing Solana Transaction in TypeScript\nDESCRIPTION: This code creates a Solana transaction, adds a transfer instruction, and serializes it for use with the signTransactionWithEncryptedKey function. It uses the @solana/web3.js library.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Connection,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  clusterApiUrl,\n} from '@solana/web3.js';\n\nconst chain = 'devnet';\nconst fromPublicKey = new PublicKey(process.env.SOLANA_PUBLIC_KEY);\nconst toPublicKey = new PublicKey(process.env.SOLANA_TRANSACTION_RECIPIENT_PUBLIC_KEY);\n\nconst solanaTransaction = new Transaction();\n    solanaTransaction.add(\n    SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: LAMPORTS_PER_SOL / 100, // Transfer 0.01 SOL\n    })\n);\nsolanaTransaction.feePayer = fromPublicKey;\n\nconst solanaConnection = new Connection(clusterApiUrl(chain), 'confirmed');\nconst { blockhash } = await solanaConnection.getLatestBlockhash();\nsolanaTransaction.recentBlockhash = blockhash;\n\nconst serializedTransaction = solanaTransaction\n    .serialize({\n        requireAllSignatures: false, // should be false as the transaction is not yet being signed\n        verifySignatures: false, // should be false as the transaction is not yet being signed\n    })\n    .toString('base64');\n\nconst unsignedTransaction: SerializedTransaction = {\n    serializedTransaction,\n    chain,\n};\n```\n\n----------------------------------------\n\nTITLE: Delegating to PKP Wallet and Executing Signed Actions in Lit Protocol\nDESCRIPTION: This code snippet demonstrates the process of delegating to a PKP wallet, generating session signatures, and executing a signed action using the Lit Protocol. It includes setting up a Lit Node Client, handling PKP authentication callbacks, and using session signatures for ECDSA signing.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/capacity-credits.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\n\n  const litNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      checkNodeAttestation: true,\n  });\n  \n    const pkpAuthNeededCallback = async ({\n      expiration,\n      resources,\n      resourceAbilityRequests,\n    }) => {\n      // -- validate\n      if (!expiration) {\n        throw new Error('expiration is required');\n      }\n\n      if (!resources) {\n        throw new Error('resources is required');\n      }\n\n      if (!resourceAbilityRequests) {\n        throw new Error('resourceAbilityRequests is required');\n      }\n\n      const response = await litNodeClient.signSessionKey({\n        statement: 'Some custom statement.',\n        authMethods: [secondWalletControllerAuthMethod],  // authMethods for signing the sessionSigs\n        pkpPublicKey: secondWalletPKPInfo.publicKey,  // public key of the wallet which is delegated\n        expiration: expiration,\n        resources: resources,\n        chainId: 1,\n\n        // optional (this would use normal siwe lib, without it, it would use lit-siwe)\n        resourceAbilityRequests: resourceAbilityRequests,\n      });\n\n      console.log('response:', response);\n\n      return response.authSig;\n  };\n\n  const pkpSessionSigs = await litNodeClient.getSessionSigs({\n    pkpPublicKey: secondWalletPKPInfo.publicKey,   // public key of the wallet which is delegated\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    chain: 'ethereum',\n    resourceAbilityRequests: [\n      {\n        resource: new LitPKPResource('*'),\n        ability: LIT_ABILITY.PKPSigning,\n      },\n    ],\n    authNeededCallback: pkpAuthNeededCallback,\n    capacityDelegationAuthSig, // here is where we add the delegation to our session request\n  });\n  \n  console.log(\"generated session with delegation \", pkpSessionSigs);\n\n  const res = await litNodeClient.executeJs({\n    sessionSigs: pkpSessionSigs,\n    code: `(async () => {\n        const sigShare = await LitActions.signEcdsa({\n          toSign: dataToSign,\n          publicKey,\n          sigName: \"sig\",\n        });\n      })();`,\n    authMethods: [],\n    jsParams: {     // parameters to js function above\n      dataToSign: ethers.utils.arrayify(\n        ethers.utils.keccak256([1, 2, 3, 4, 5])\n      ),\n      publicKey: secondWalletPKPInfo.publicKey,\n    },\n  });\n\n  console.log(\"signature result \", res);\n```\n\n----------------------------------------\n\nTITLE: Authenticating to Fetch PKP Information\nDESCRIPTION: Example of fetching PKP (Programmable Key Pair) information using an authenticated session.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/email-sms.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { AUTH_METHOD_SCOPE } from \"@lit-protocol/constants\";\n\n// Using the session examples above you can call to fetch pkps by the auth method gotten from the provider examples\nconst txHash = await session.fetchPKPThroughRelayer(authMethod,  {\n    permittedAuthMethodScopes: [[AUTH_METHOD_SCOPE.SignAnything]]\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Single Node Transaction with Lit Action\nDESCRIPTION: Example demonstrating how to use runOnce to execute a transaction on a single Lit node. The code includes transaction creation, signing with ECDSA, and broadcasting using a node operator's RPC URL. The function must return a serializable value to avoid [ERROR] responses.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/run-once.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst code = `\n(async () => {\n    const sigName = \"sig1\";\n    // example transaction\n    let txn = {\n        to: \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        value: 1,\n        gasPrice: 20000000000,\n        nonce: 0,\n    };\n\n    // using ether's serializeTransaction\n    // https://docs.ethers.org/v5/api/utils/transactions/#transactions--functions\n    const serializedTx = ethers.utils.serializeTransaction(txn);\n    let hash = utils.keccak256(ethers.utils.toUtf8Bytes(serializedTx));\n    // encode the message into an uint8array for signing\n    const toSign = await new TextEncoder().encode(hash);\n    const signature = await Lit.Actions.signAndCombineEcdsa({\n        toSign,\n        publicKey,\n        sigName,\n    });\n\n    // the code in the function given to runOnce below will only be run by one node\n    let res = await Lit.Actions.runOnce({ waitForResponse: true, name: \"txnSender\" }, async () => {\n        // get the node operator's rpc url for the 'ethereum' chain\n        const rpcUrl = await Lit.Actions.getRpcUrl({ chain: \"ethereum\" });\n        const provider = new ethers.providers.JsonRpcProvider(rpcUrl);\n        const tx = await provider.sendTransaction(signature);\n        return tx.blockHash; // return the tx to be broadcast to all other nodes\n    });\n\n    // set the response from the action as the result of runOnce operation\n    // will be sent by all nodes, even though only a single node did the computation\n    Lit.Actions.setResponse(res);\n})()\n`;\nconst client = new LitNodeClient({\n    litNetwork: \"datil-dev\",\n});\n\nawait client.connect();\nconst res = await client.executeJs({\n    code,\n    sessionSigs: {} // your session\n    jsParams: {\n        publicKey: \"<your pkp public key>\",\n    }\n});\n\nconsole.log(\"transactions in latest block from all nodes: \", res);\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with LitNodeClient\nDESCRIPTION: Demonstrates session signature generation using LitNodeClient and auth callback functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/email-sms.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNodeClient: LitNodeClientNodeJs = new LitNodeClientNodeJs({\n  litNetwork: \"datil-dev\",\n  debug: true,\n});\nawait litNodeClient.connect();\n\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// The implementation below is wrapped by the above `provider.getSessionSigs`\nconst authNeededCallback = async (params: AuthCallbackParams) => {\n  console.log(\"params\", params);\n  const response = await litNodeClient.signSessionKey({\n    sessionKey: sessionKeyPair,\n    statement: params.statement,\n    authMethods: [authMethod], // auth method from one of the `lit-auth-client` authentication providers\n    pkpPublicKey: \"<YOUR PKP PUBLIC KEY>\", // pkp which has the auth method configured for authentication above\n    expiration: params.expiration,\n    resources: params.resources,\n    chainId: 1,\n  });\n  console.log(\"callback response\", response);\n  return response.authSig;\n};\n\nconst resourceAbilities = [\n  {\n    resource: new LitPkpResource(\"*\"),\n    ability: LIT_ABILITY.PKPSigning,\n  },\n];\nconst sessionSigs = await litNodeClient\n  .getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString(),\n    resourceAbilityRequests: resourceAbilities,\n    sessionKey: sessionKeyPair,\n    authNeededCallback,\n  })\n  .catch((err) => {\n    console.log(\"error while attempting to access session signatures: \", err);\n    throw err;\n  });\nconsole.log(\"session signatures: \", sessionSigs);\nconst authSig = sessionSigs[Object.keys(sessionSigs)[0]];\nconsole.log(\"authSig\", authSig);\n```\n\n----------------------------------------\n\nTITLE: Decrypting Text with Lit Protocol in JavaScript\nDESCRIPTION: This function decrypts the encrypted text using Lit Protocol. It connects to Lit nodes, obtains an auth signature, retrieves the symmetric key, and decrypts the string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/encryptDecrypt.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync decryptText(encryptedString, encryptedSymmetricKey) {\n  if (!this.litNodeClient) {\n    await this.connect();\n  }\n\n  const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });\n  const symmetricKey = await this.litNodeClient.getEncryptionKey({\n      accessControlConditions: accessControlConditions,\n      toDecrypt: encryptedSymmetricKey,\n      chain,\n      authSig\n  });\n\n  return await LitJsSdk.decryptString(\n      encryptedString,\n      symmetricKey\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Signing with PKP in Lit Action (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to use a PKP (Programmable Key Pair) to sign a message within a Lit Action. It uses the Lit.Actions.signEcdsa() function to perform the signing operation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/support/faq.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nLit.Actions.signEcdsa()\n```\n\n----------------------------------------\n\nTITLE: Installing Lit SDK Package\nDESCRIPTION: Command to install the @lit-protocol/lit-node-client package using yarn. This package can be used in both browser and Node environments.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Signing P2SH Bitcoin Transaction with PKP in TypeScript\nDESCRIPTION: This function demonstrates how to sign a P2SH Bitcoin transaction using a Programmable Key Pair (PKP). It includes UTXO retrieval, transaction creation, signature generation via Lit Action, and transaction broadcasting.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/single-sig.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport * as ecc from \"tiny-secp256k1\";\nimport mempoolJS from \"@mempool/mempool.js\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\n\nbitcoin.initEccLib(ecc);\n\nexport async function singleSig(litNodeClient: LitNodeClient, sessionSigs: any, pkpPublicKey: string, destinationAddress: string) {\n    const network = bitcoin.networks.bitcoin;\n    const pubKeyBuffer = Buffer.from(pkpPublicKey, \"hex\");\n\n    const redeemScript = bitcoin.script.compile([\n        pubKeyBuffer,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n\n    const p2shPayment = bitcoin.payments.p2sh({\n        redeem: { output: redeemScript },\n        network: network,\n    });\n\n    const { bitcoin: { addresses, transactions } } = mempoolJS({\n        hostname: \"mempool.space\",\n        network: \"mainnet\",\n    });\n\n    const addressUtxos = await addresses.getAddressTxsUtxo({\n        address: p2shPayment.address!,\n    });\n    console.log(\"P2SH Address:\", p2shPayment.address);\n\n    if (addressUtxos.length === 0) {\n        console.log(\"No UTXOs found for address:\", p2shPayment.address);\n        return;\n    }\n\n    const utxo = addressUtxos[0];\n    const psbt = new bitcoin.Psbt({ network });\n    const utxoRawTx = await transactions.getTxHex({ txid: utxo.txid });\n\n    psbt.addInput({\n        hash: utxo.txid,\n        index: utxo.vout,\n        nonWitnessUtxo: Buffer.from(utxoRawTx, \"hex\"),\n        redeemScript: redeemScript,\n    });\n\n    const fee = 1000;\n    const amountToSend = utxo.value - fee;\n\n    psbt.addOutput({\n        address: destinationAddress,\n        value: BigInt(amountToSend),\n    });\n\n    //@ts-ignore\n    const tx = psbt.__CACHE.__TX.clone();\n    const sighash = tx.hashForSignature(\n        0,\n        redeemScript,\n        bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const litActionResponse = await litNodeClient.executeJs({\n        code: litActionCode,\n        sessionSigs, \n        jsParams: {\n        publicKey: pkpPublicKey,\n        toSign: Buffer.from(sighash, \"hex\"),\n        },\n    });\n\n    const signatureWithHashType = await convertSignature(\n        litActionResponse.signatures.btcSignature\n    );\n\n    psbt.updateInput(0, {\n        finalScriptSig: bitcoin.script.compile([\n        signatureWithHashType,\n        redeemScript,\n        ]),\n    });\n\n    const txHex = psbt.extractTransaction().toHex();\n    return await broadcastTransaction(txHex);\n}\n```\n\n----------------------------------------\n\nTITLE: Signing and Submitting Transactions in Lit Action using JavaScript and ethers.js\nDESCRIPTION: This code snippet demonstrates how to use signAndCombineEcdsa to combine partial signatures, create a complete signature, and submit a signed transaction using ethers.js within a Lit Action. It includes error handling and transaction receipt logging.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/combining-signatures.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst _litActionCode = async () =>  {\n  const signature = await Lit.Actions.signAndCombineEcdsa({\n    toSign,\n    publicKey,\n    sigName,\n  });\n\n  const jsonSignature = JSON.parse(signature);\n  jsonSignature.r = \"0x\" + jsonSignature.r.substring(2);\n  jsonSignature.s = \"0x\" + jsonSignature.s;\n  const hexSignature = ethers.utils.joinSignature(jsonSignature);\n\n  const signedTx = ethers.utils.serializeTransaction(\n    unsignedTransaction,\n    hexSignature\n  );\n\n  const recoveredAddress = ethers.utils.recoverAddress(toSign, hexSignature);\n  console.log(\"Recovered Address:\", recoveredAddress);\n\n  const response = await Lit.Actions.runOnce(\n    { waitForResponse: true, name: \"txnSender\" },\n    async () => {\n      try {\n        const rpcUrl = await Lit.Actions.getRpcUrl({ chain });\n        const provider = new ethers.providers.JsonRpcProvider(rpcUrl);\n        const transactionReceipt = await provider.sendTransaction(signedTx);\n\n        return `Transaction Sent Successfully. Transaction Hash: ${transactionReceipt.hash}`;\n      } catch (error) {\n        return `Error: When sending transaction: ${error.message}`;\n      }\n    }\n  );\n\n  Lit.Actions.setResponse({ response });\n};\n\nconst litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: Implementing Unified Access Control with Multiple Blockchain Conditions\nDESCRIPTION: This example shows how to create unified access control conditions that combine different condition types (Solana RPC, EVM Basic, EVM Custom Contract, and Cosmos) with logical OR operators. It demonstrates condition setup for checking balances across multiple chains.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/condition-types/unified-access-control-conditions.md#2025-04-18_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"solRpc\",\n    method: \"getBalance\",\n    params: [\":userAddress\"],\n    chain: \"solana\",\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\", // equals 0.00001 ETH\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"evmContract\",\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \"8\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain: \"polygon\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"cosmos\",\n    path: \"/cosmos/bank/v1beta1/balances/:userAddress\",\n    chain: \"cosmos\",\n    returnValueTest: {\n      key: \"$.balances[0].amount\",\n      comparator: \">=\",\n      value: \"1000000\", // equals 1 ATOM\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies using Package Managers\nDESCRIPTION: Commands to install required dependencies including Lit Protocol packages and ethers using npm or yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-session-sigs.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Complete Encryption Function\nDESCRIPTION: Full implementation of the encryption process including connection, auth, and key management.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nasync encrypt(message: string) {\n    if (!this.litNodeClient) {\n      await this.connect()\n    }\n\n    const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain })\n    const { encryptedString, symmetricKey } = await LitJsSdk.encryptString(message)\n\n    const encryptedSymmetricKey = await window.litNodeClient.saveEncryptionKey({\n      accessControlConditions,\n      symmetricKey,\n      authSig,\n      chain,\n    })\n\n    return {\n      encryptedString,\n      encryptedSymmetricKey: LitJsSdk.uint8arrayToString(encryptedSymmetricKey, \"base16\")\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Lit Network using LitNodeClient in TypeScript\nDESCRIPTION: This code snippet demonstrates how to instantiate a LitNodeClient and connect it to a specified Lit network. It imports necessary modules, creates a LitNodeClient instance with a specified network, and connects to the network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/connecting.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    // Change this to the Lit SDK Network Identifier you want to connect to\n    litNetwork: LIT_NETWORK.DatilDev,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Signing a Transaction with Lit Action using IPFS in JavaScript\nDESCRIPTION: This code snippet shows how to sign a transaction using a Lit Action stored on IPFS. It uses the ipfsId parameter to reference the Lit Action code stored on IPFS.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nconst signatures = await litNodeClient.executeJs({\n  ipfsId: \"QmRwN9GKHvCn4Vk7biqtr6adjXMs7PzzYPCzNCRjPFiDjm\",\n  authSig,\n  jsParams: {\n    toSign: [84, 104, 105, 115, 32, 109, 101, 115, 115, 97, 103, 101, 32, 105, 115, 32, 101, 120, 97, 99, 116, 108, 121, 32, 51, 50, 32, 98, 121, 116, 101, 115],\n    publicKey: mintInfo.pkp.publicKey,\n    sigName: \"sig1\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Authentication Context with Lit Actions in JavaScript\nDESCRIPTION: This code snippet demonstrates how to check different auth methods for a PKP using a Lit Action. It sends an auth token from Google, which Lit resolves and puts into the Lit.Auth object. The example returns the Lit.Auth object as a response for inspection.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/custom-auth.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  Lit.Actions.setResponse({response: JSON.stringify({\"Lit.Auth\": Lit.Auth})})\n};\n\ngo();\n`;\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"localhost\",\n    debug: true,\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    sessionSigs,\n    authMethods: [\n      {\n        // google oauth JWT\n        accessToken:\n          \"eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc3Y2MwZWY0YzcxODFjZjRjMGRjZWY3YjYwYWUyOGNjOTAyMmM3NmIiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDg5OTYwNTQyNzMzNjA1NjgxMzIiLCJlbWFpbCI6ImdldmVuc3RlZUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXRfaGFzaCI6IlVYV1Z1eEJsdGswcEhKclllOEFXTUEiLCJpYXQiOjE2NjcxNjgyMTUsImV4cCI6MTY2NzE3MTgxNX0.ejZu5bADJ6cUsovV7otHAafy0mqWZBAtN860jvBdVe38XUi0v-eB5WWBPMD5zXcJxbXFvaPWCX8nTaE6S24cNNHJw0hq15irjRZeg9D2i7ToitR1LZSQ3rPCDQZPX4xYn7G-FH7C1DQ-7NEDMmr9ge4B6Qs4pT5Mj8ESVlA29yZjKCfk-zL7F5b6W0EOIA6G9rj6-3HgtazkHfIGHAtfBz4dqHjC4HJncHJzqIm9Y8eSBBnN-ZhYUr3cWxGCuFIw3yrGccv5_khfhbbk6TqdSeMO9YNWN3otiVB8Nwu2sb9VsllFoHIE0uGSzVZVbJgSK1GsGbJZe76ubLuObI5YFw\",\n        authMethodType: 6,\n      },\n    ],\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      toSign: ethers.utils.arrayify(\n        ethers.utils.keccak256([\n          72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100,\n        ])\n      ),\n      publicKey:\n        \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n      sigName: \"sig1\",\n    },\n  });\n  console.log(\"results: \", JSON.stringify(results.response, null, 2));\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures for Lit Actions\nDESCRIPTION: Code to generate session signatures that enable PKP signing and Lit Action execution. This implementation uses wildcard identifiers for resources, which should be replaced with specific identifiers in production environments.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-lit-action-session-sigs.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst sessionSignatures = await litNodeClient.getLitActionSessionSigs({\n    pkpPublicKey: pkp.publicKey,\n    capabilityAuthSigs: [capacityDelegationAuthSig],\n    chain: \"ethereum\",\n    resourceAbilityRequests: [\n    {\n        resource: new LitPKPResource(\"*\"),\n        ability: LIT_ABILITY.PKPSigning,\n    },\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    // With this setup you could use either the litActionIpfsId or the litActionCode property\n    //litActionIpfsId: litActionCodeIpfsCid,\n    litActionCode: Buffer.from(litActionCode).toString(\"base64\"),\n    jsParams: {\n    magicNumber: 42,\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom OAuth Project with Google Provider\nDESCRIPTION: Demonstrates how to customize the Google OAuth flow by modifying the authentication URL to use a custom OAuth project instead of Lit's default.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/social-login.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize Google provider\nconst googleProvider = new GoogleProvider({ relay, litNodeClient });\n\n// Begin login flow with Google but using your own OAuth project\nasync function authWithGoogle() {\n  await googleProvider.signIn((url) => {\n    const myURL = new URL(url);\n    \n    // Modify URL as needed\n    myURL.host = 'mycustomdomain.com';\n    myURL.pathname = '/myCustomOauthLoginFlow';\n    // myURL.searchParams.get('app_redirect') is your redirect URI for logged in users\n    \n    window.location.assign(url);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Ethers Signer for Lit Protocol in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create an Ethers Signer instance using a private key from an environment variable. This signer is used for PKP ownership verification in the Lit Protocol integration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Access Control Condition Configuration\nDESCRIPTION: Example of creating an access control condition that checks ETH balance.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"1000000000000\", // 0.000001 ETH\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures in TypeScript\nDESCRIPTION: This code snippet demonstrates how to generate PKP session signatures using the Lit Protocol. It uses the EthWalletProvider for authentication and requests permissions for Lit Action execution.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-Signature Bitcoin Transaction with PKPs in TypeScript\nDESCRIPTION: Implementation of a Bitcoin multi-signature transaction function that uses two PKPs to sign a P2SH transaction. The function handles UTXO management, transaction creation, signature generation through Lit Actions, and transaction broadcasting. Requires bitcoinjs-lib, tiny-secp256k1, and mempool.js dependencies.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/multi-sig.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport * as ecc from \"tiny-secp256k1\";\nimport mempoolJS from \"@mempool/mempool.js\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\n\nbitcoin.initEccLib(ecc);\n\nexport async function multiSig(litNodeClient: LitNodeClient, sessionSigs: any, pkpPublicKey1: string, pkpPublicKey2: string, destinationAddress: string) {\n    const network = bitcoin.networks.bitcoin;\n    const pubKeyBuffer_1 = Buffer.from(pkpPublicKey1, \"hex\");\n    const pubKeyBuffer_2 = Buffer.from(pkpPublicKey2, \"hex\");\n\n    const redeemScript = bitcoin.script.compile([\n        bitcoin.opcodes.OP_2,\n        pubKeyBuffer_1,\n        pubKeyBuffer_2,\n        bitcoin.opcodes.OP_2,\n        bitcoin.opcodes.OP_CHECKMULTISIG,\n    ]);\n\n    const p2shPayment = bitcoin.payments.p2sh({\n        redeem: { output: redeemScript },\n        network: network,\n    });\n    console.log(\"P2SH Address:\", p2shPayment.address);\n\n    const { bitcoin: { addresses, transactions } } = mempoolJS({\n        hostname: \"mempool.space\",\n        network: \"mainnet\",\n    });\n\n    const addressUtxos = await addresses.getAddressTxsUtxo({\n        address: p2shPayment.address!,\n    });\n\n    if (addressUtxos.length === 0) {\n        console.log(\"No UTXOs found for address:\", p2shPayment.address);\n        return;\n    }\n\n    const utxo = addressUtxos[0];\n    const psbt = new bitcoin.Psbt({ network });\n    const utxoRawTx = await transactions.getTxHex({ txid: utxo.txid });\n\n    psbt.addInput({\n        hash: utxo.txid,\n        index: utxo.vout,\n        nonWitnessUtxo: Buffer.from(utxoRawTx, \"hex\"),\n        redeemScript: redeemScript,\n    });\n\n    const fee = 1000;\n    const amountToSend = utxo.value - fee;\n\n    psbt.addOutput({\n        address: destinationAddress,\n        value: BigInt(amountToSend),\n    });\n\n    //@ts-ignore\n    const tx = psbt.__CACHE.__TX.clone();\n    const sighash = tx.hashForSignature(\n        0,\n        redeemScript,\n        bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const litActionResponse1 = await litNodeClient.executeJs({\n        code: litActionCode,\n        sessionSigs,\n        jsParams: {\n            publicKey: pkpPublicKey1,\n            toSign: Buffer.from(sighash, \"hex\"),\n        },\n    });\n\n    const litActionResponse2 = await litNodeClient.executeJs({\n        code: litActionCode,\n        sessionSigs,\n        jsParams: {\n            publicKey: pkpPublicKey2,\n            toSign: Buffer.from(sighash, \"hex\"),\n        },\n    });\n\n    const signatureWithHashType1 = await convertSignature(\n        litActionResponse1.signatures.btcSignature\n    );\n\n    const signatureWithHashType2 = await convertSignature(\n        litActionResponse2.signatures.btcSignature\n    );\n\n    psbt.updateInput(0, {\n        finalScriptSig: bitcoin.script.compile([\n        bitcoin.opcodes.OP_0,\n        signatureWithHashType1,\n        signatureWithHashType2,\n        redeemScript,\n        ]),\n    });\n\n    const txHex = psbt.extractTransaction().toHex();\n    return await broadcastTransaction(txHex);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Ethereum JSON RPC Requests\nDESCRIPTION: Shows how to handle Ethereum JSON RPC requests using the ethRequestHandler with a PKPEthersWallet instance for operations like signing messages and transactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ethRequestHandler } from \"@lit-protocol/pkp-ethers\";\n\nconst message = \"Free the web\";\nconst hexMsg = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(message));\n\nconst payload = {\n  method: \"personal_sign\",\n  params: [\n    hexMsg,\n    \"<Ethereum address to sign with (should match the Ethereum address of your PKP)>\",\n  ],\n};\n\nconst result = await ethRequestHandler({\n  signer: pkpWallet,\n  payload: payload,\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Specific ERC721 Token Ownership in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user owns a specific ERC721 token (NFT). It uses the ownerOf method of the ERC721 contract to verify ownership of a particular token id.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x89b597199dAc806Ceecfc091e56044D34E59985c',\n    standardContractType: 'ERC721',\n    chain,\n    method: 'ownerOf',\n    parameters: [\n      '3112'\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: ':userAddress'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitContracts for Lit Protocol\nDESCRIPTION: TypeScript code to initialize and connect a LitContracts instance, which allows interaction with smart contracts on the Lit network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-pkp-session-sigs.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litContracts = new LitContracts({\n    signer: ethersSigner,\n    network: LIT_NETWORK.DatilTest,\n    debug: false,\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Complete Decryption Function\nDESCRIPTION: Full implementation of the decryption process including symmetric key retrieval and content decryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nasync decrypt(encryptedString: string, encryptedSymmetricKey: string) {\n    if (!this.litNodeClient) {\n      await this.connect()\n    }\n\n    const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain })\n    const symmetricKey = await this.litNodeClient.getEncryptionKey({\n      accessControlConditions,\n      toDecrypt: encryptedSymmetricKey,\n      chain,\n      authSig\n    })\n\n    const decryptedString = await LitJsSdk.decryptString(\n      encryptedString,\n      symmetricKey\n    );\n\n  return { decryptedString }\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethers Signer for Lit Protocol\nDESCRIPTION: Setup of Ethers wallet signer using a private key and connecting to the Chronicle Yellowstone RPC endpoint.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/using-delegated-auth-sig.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport ethers from \"ethers\";\nimport { LIT_RPC, LIT_ABILITY } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Pairing PKPWalletConnect with dApp URI in JavaScript\nDESCRIPTION: This code snippet shows how to pair PKPWalletConnect with a dApp using a WalletConnect URI obtained from a compatible dApp.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Pair using the given URI\nawait pkpWalletConnect.pair({ uri: uri });\n```\n\n----------------------------------------\n\nTITLE: Implementing 1-of-1 Multi-Signature Bitcoin Transaction with PKPs in TypeScript\nDESCRIPTION: This function creates and signs a P2SH Bitcoin transaction using two PKPs, requiring only one signature. It includes UTXO retrieval, transaction creation, signing with a Lit Action, and broadcasting the transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/1of1-multi-sig.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport * as ecc from \"tiny-secp256k1\";\nimport mempoolJS from \"@mempool/mempool.js\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\n\nbitcoin.initEccLib(ecc);\n\nexport async function oneOfOneMultiSig(litNodeClient: LitNodeClient, sessionSigs: any, pkpPublicKey1: string, pkpPublicKey2: string, destinationAddress: string) {\n    const network = bitcoin.networks.bitcoin;\n    const pubKeyBuffer_1 = Buffer.from(pkpPublicKey1, \"hex\");\n    const pubKeyBuffer_2 = Buffer.from(pkpPublicKey2, \"hex\");\n\n    const redeemScript = bitcoin.script.compile([\n        bitcoin.opcodes.OP_1,\n        pubKeyBuffer_1,\n        pubKeyBuffer_2,\n        bitcoin.opcodes.OP_2,\n        bitcoin.opcodes.OP_CHECKMULTISIG,\n    ]);\n\n    const p2shPayment = bitcoin.payments.p2sh({\n        redeem: { output: redeemScript },\n        network: network,\n    });\n\n    const { bitcoin: { addresses, transactions } } = mempoolJS({\n        hostname: \"mempool.space\",\n        network: \"mainnet\",\n    });\n\n    const addressUtxos = await addresses.getAddressTxsUtxo({\n        address: p2shPayment.address!,\n    });\n    console.log(\"P2SH Address:\", p2shPayment.address);\n\n    if (addressUtxos.length === 0) {\n        console.log(\"No UTXOs found for address:\", p2shPayment.address);\n        return;\n    }\n\n    const utxo = addressUtxos[0];\n    const psbt = new bitcoin.Psbt({ network });\n    const utxoRawTx = await transactions.getTxHex({ txid: utxo.txid });\n\n    psbt.addInput({\n        hash: utxo.txid,\n        index: utxo.vout,\n        nonWitnessUtxo: Buffer.from(utxoRawTx, \"hex\"),\n        redeemScript: redeemScript,\n    });\n\n    const fee = 1000;\n    const amountToSend = utxo.value - fee;\n\n    psbt.addOutput({\n        address: destinationAddress,\n        value: BigInt(amountToSend),\n    });\n\n    //@ts-ignore\n    const tx = psbt.__CACHE.__TX.clone();\n    const sighash = tx.hashForSignature(\n        0,\n        redeemScript,\n        bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const litActionResponse = await litNodeClient.executeJs({\n    code: litActionCode,\n    sessionSigs,\n    jsParams: {\n        publicKey: pkpPublicKey1,\n        toSign: Buffer.from(sighash, \"hex\"),\n    },\n    });\n\n    const signatureWithHashType = await convertSignature(\n        litActionResponse.signatures.btcSignature\n    );\n\n    psbt.updateInput(0, {\n        finalScriptSig: bitcoin.script.compile([\n        bitcoin.opcodes.OP_0,\n        signatureWithHashType,\n        redeemScript,\n        ]),\n    });\n\n    const txHex = psbt.extractTransaction().toHex();\n    return await broadcastTransaction(txHex);\n}\n```\n\n----------------------------------------\n\nTITLE: SMS OTP Authentication Validation\nDESCRIPTION: Implementation of OTP code validation and authentication using Stytch JWT\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Get auth method object by validating Stytch JWT \nasync function authenticateWithStytch(code, methodId) {\n  // code: OTP code, methodId: method_id returned from sendPasscode\n  \n  // Authenticate the OTP code with Stytch\n  const response = await stytchClient.otps.authenticate(code, methodId, {\n    session_duration_minutes: 60,\n  });\n\n  // Get auth method object after authenticating Stytch JWT\n  const authMethodSMS = await stytchOtpProvider.authenticate({ response.session_jwt, response.user_id });\n  return authMethodSMS;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Session Requests in PKPWalletConnect\nDESCRIPTION: Sets up an event listener for session requests, logs the request details, and approves the request.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\npkpWalletConnect.on('session_request', async (requestEvent) => {\n  console.log('Received session request: ', requestEvent);\n\n  const { topic, params } = requestEvent;\n  const { request } = params;\n  const requestSession = signClient.session.get(topic);\n  const { name, url } = requestSession.peer.metadata;\n\n  // Accept session request\n  console.log(\n    `\\nApproving ${request.method} request for session ${name} (${url})...\\n`\n  );\n  await pkpWalletConnect.approveSessionRequest(requestEvent);\n  console.log(\n    `Check the ${name} dapp to confirm whether the request was approved`\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Encrypting and Storing Messages with LIT Protocol and OrbisDB\nDESCRIPTION: Implementation of message encryption using LIT Protocol's access control conditions and storing the encrypted message in OrbisDB. Includes access control condition setup, message encryption, and database insertion.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst accessControlConditions = [\n        {\n          contractAddress: \"\",\n          standardContractType: \"\",\n          chain,\n          method: \"\",\n          parameters: [\":userAddress\"],\n          returnValueTest: {\n            comparator: \"=\",\n            value: address,\n          },\n        },\n      ];\n\nconst { ciphertext, dataToEncryptHash } = await encryptWithLit(\nlit,\nnewMessage,\naccessControlConditions,\nchain\n);\n\nconst stringified = JSON.stringify(accessControlConditions);\nconst b64 = new TextEncoder().encode(stringified);\nconst encoded = await encodeb64(b64);\n\nawait orbis.getConnectedUser(); // Get the connected user\n\n\nconst createQuery = await orbis\n// insert into the posts table\n.insert(POST_ID)\n// using the encrypted payload and associated arguments\n.value({\n    body: dataToEncryptHash,\n    to: address,\n    created: new Date().toISOString(),\n    ciphertext,\n    chain,\n    accessControlConditions: encoded,\n    accessControlConditionType: \"accessControlConditions\",\n})\n// ensure that the stream is associated with our OrbisDB application context\n.context(CONTEXT_ID)\n// execute the query\n.run();\n```\n\n----------------------------------------\n\nTITLE: Making Signing Requests with SessionSigs in Lit Protocol\nDESCRIPTION: This snippet shows how to save signing conditions and retrieve a signature using SessionSigs. It sets up unified access control conditions and uses the litNodeClient to interact with the Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/usage.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n\n// Saving signing condition\nawait litNodeClient.saveSigningCondition({\n  unifiedAccessControlConditions,\n  sessionSigs,\n  resourceId,\n  chain: \"litSessionSign\",\n});\n\n// Retrieving a signature\nlet jwt = await litNodeClient.getSignedToken({\n  unifiedAccessControlConditions,\n  sessionSigs,\n  resourceId,\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network\nDESCRIPTION: Initializes a LitNodeClient instance and connects to the Lit network. Also sets up an Ethereum wallet using a private key for authentication and transactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-signing.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK, LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: false\n});\nawait litNodeClient.connect();\n\nconst ethersWallet = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY!, // Replace with your private key\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Executing Lit Action with Weather API Integration in JavaScript\nDESCRIPTION: This code demonstrates how to create and execute a Lit Action that fetches weather data from the National Weather Service API. It includes logic to sign a transaction only if the temperature is above 60 degrees Fahrenheit, showcasing external data integration and conditional execution in Lit Actions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/workingWithActions/usingFetch.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {  \n  const url = \"https://api.weather.gov/gridpoints/TOP/31,80/forecast\";\n  const resp = await fetch(url).then((response) => response.json());\n  const temp = resp.properties.periods[0].temperature;\n\n  // only sign if the temperature is above 60.  if it's below 60, exit.\n  if (temp < 60) {\n    return;\n  }\n  \n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await LitActions.signEcdsa({ toSign, publicKey , sigName });\n};\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"serrano\",\n    debug: true,\n  });\n  await litNodeClient.connect();\n  const signatures = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n      publicKey:\n        \"0x02e5896d70c1bc4b4844458748fe0f936c7919d7968341e391fb6d82c258192e64\",\n      sigName: \"sig1\",\n    },\n  });\n  console.log(\"signatures: \", signatures);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in server-side applications\nDESCRIPTION: Code example showing how to connect to the Habanero network in a server-side application using Express, including how to disconnect properly.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\napp.locals.litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\n  alertWhenUnauthorized: false,\n  litNetwork: \"habanero\",\n  checkNodeAttestation: true \n});\nawait app.locals.litNodeClient.connect();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nawait app.locals.litNodeClient.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Fetching and Aggregating Weather Data using Lit Protocol\nDESCRIPTION: Demonstrates how to use broadcastAndCollect to fetch temperature data from weather.gov API across multiple Lit nodes, collect the responses, and calculate the median temperature. The code includes both the Lit Action implementation and the client-side setup for execution.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/broadcast-and-collect.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst code = `(async () => {\n  const url = \"https://api.weather.gov/gridpoints/TOP/31,80/forecast\";\n  const resp = await fetch(url).then((response) => response.json());\n  const temp = resp.properties.periods[0].temperature;\n\n  const temperatures = await Lit.Actions.broadcastAndCollect({\n    name: \"temperature\",\n    value: temp,\n  });\n\n  // at this point, temperatures is an array of all the values that all the nodes got\n  const median = temperatures.sort()[Math.floor(temperatures.length / 2)];\n  Lit.Actions.setResponse({response: median});\n})();\n`;\n\nconst client = new LitNodeClient({\n    litNetwork: \"datil-dev\",\n});\nawait client.connect();\nconst res = await client.executeJs({\n    code,\n    sessionSigs: {} // your session\n    jsParams: {\n      publicKey: \"<your pkp public key>\",\n      sigName: 'fooSig',\n    }\n});\n\nconsole.log(\"response from broadcast and collecting within a lit action: \", res);\n```\n\n----------------------------------------\n\nTITLE: Defining and Executing Lit Action Code in TypeScript\nDESCRIPTION: This snippet shows how to define a Lit Action as an Immediately Invoked Function Expression (IIFE) and execute it using the Lit SDK's executeJs method. It demonstrates the core concept of deploying a Lit Action using a code string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/deploying.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst litActionCode = `\n(async () => {\n  console.log(\"This is my Lit Action!\");\n})();\n`;\n\nawait litNodeClient.executeJs({\n    sessionSigs,\n    code: litActionCode,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures with Lit Protocol in TypeScript\nDESCRIPTION: This code snippet demonstrates how to generate PKP session signatures using Lit Protocol. It authenticates with an Ethereum wallet provider and requests specific resource abilities for Lit Actions. The expiration time for both the auth method and session signatures is set to 10 minutes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Server-Side Lit Implementation\nDESCRIPTION: Setup for server-side usage of Lit Protocol, including connection initialization and management.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nclass Lit {\n   litNodeClient;\n   chain;\n\n   constructor(chain){\n     this.chain = chain;\n   }\n\n   async connect() {\n      app.locals.litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\n        alertWhenUnauthorized: false,\n        litNetwork: LIT_NETWORK.DatilDev,\n        debug: true,\n      });\n\n      this.litNodeClient = app.locals.litNodeClient;\n      await this.litNodeClient.connect();\n   }\n}\n\nconst chain = \"ethereum\";\n\nlet myLit = new Lit(chain);\nawait myLit.connect();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Transactions from Latest Ethereum Block Using All Nodes\nDESCRIPTION: This code snippet demonstrates how to use the getRpcUrl function to fetch the RPC URL for Ethereum, then use it to retrieve transactions from the latest block. This operation is performed by all nodes in parallel.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/get-rpc-url.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ncode = `(async () => {\n    const rpcUrl = await Lit.Actions.getRpcUrl({ chain: \"ethereum\" });\n    const blockByNumber = await provider.send(\"eth_getBlockByNumber\", [\"latest\", false]);\n    const transactions = blockByNumber.transactions;\n    Lit.Actions.setResponse(JSON.stringify(transactions));\n})();`;\n\nconst client = new LitNodeClient({\nlitNetwork: \"datil-dev\"\n});\nawait client.connect();\n\nconst res = await client.executeJs({\n    code,\n    sessionSigs: {} // your session\n    jsParams: {}\n});\nconsole.log(\"transactions in latest block from all nodes: \", res);\n```\n\n----------------------------------------\n\nTITLE: Registering WebAuthn Credential with Lit Protocol\nDESCRIPTION: Demonstrates how to register a new WebAuthn credential and mint a PKP (Programmable Key Pair) through the Lit Relay Server. This includes initializing the Lit Node Client, Relay service, and WebAuthn provider.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/web-authn.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { WebAuthnProvider } from '@lit-protocol/providers';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize WebAuthn provider\nconst webAuthnProvider = new WebAuthnProvider({ relay, litNodeClient });\n\nasync function registerWithWebAuthn() {\n  // Register new WebAuthn credential\n  const options = await webAuthnProvider.register();\n\n  // Verify registration and mint PKP through relay server\n  const txHash = await provider.verifyAndMintPKPThroughRelayer(options);\n  const response = await provider.relay.pollRequestUntilTerminalState(\n    txHash\n  );\n  // Return public key of newly minted PKP\n  return response.pkpPublicKey;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking ERC1155 Token Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses at least one ERC1155 token with a specific token id. It uses the balanceOf method of the ERC1155 contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x3110c39b428221012934A7F617913b095BC1078C',\n    standardContractType: 'ERC1155',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress',\n      '9541'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Private Key Generation and Encryption in Lit Action\nDESCRIPTION: Demonstrates how to generate and encrypt a private key within a Lit Action using runOnce and encrypt methods. The code ensures only one Lit node handles the clear text private key and returns the necessary encryption metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/custom-wrapped-keys.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n    const LIT_PREFIX = 'lit_';\n\n    const result = await Lit.Actions.runOnce(\n        { waitForResponse: true, name: 'encryptedPrivateKey' },\n        async () => {\n            // Your private key generation logic...\n\n            const generatedPrivateKey = \"your_private_key\";\n            const utf8Encode = new TextEncoder();\n            const encodedPrivateKey = utf8Encode.encode(\n                `${LIT_PREFIX}${generatedPrivateKey}` // For enhanced security, you should prepend all generated private keys with \"lit_\"\n            );\n\n            const { ciphertext, dataToEncryptHash } = await Lit.Actions.encrypt({\n                accessControlConditions, // This should be passed into the Lit Action\n                to_encrypt: encodedPrivateKey,\n            });\n            return JSON.stringify({\n                ciphertext,\n                dataToEncryptHash,\n                // The following is pseudo code, but you need to return\n                // the public key for the generated private key as a string.\n                publicKey: generatedPrivateKey.publicKey.toString(),\n            });\n        }\n    );\n\n    // Any other code you'd like to run...\n\n    Lit.Actions.setResponse({\n        response: result,\n    });\n})\n```\n\n----------------------------------------\n\nTITLE: Instantiating Ethers Signer for Lit Protocol\nDESCRIPTION: Code to create an Ethers signer using a private key from an environment variable. This signer is used for authenticating with Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Network and Google Provider\nDESCRIPTION: Setup of LitNodeClient, LitRelay, and GoogleProvider for authentication\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LitRelay } from \"@lit-protocol/lit-auth-client\";\nimport { GoogleProvider } from \"@lit-protocol/providers\";\nimport { PROVIDER_TYPE, LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst initalizeClientsAndProvider = async () => {\n  const litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\n  await litNodeClient.connect();\n\n  const litRelay = new LitRelay({\n    relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n    relayApiKey: 'test-api-key',\n  });\n  console.log(\"Connected to Lit Nodes and Lit Relay ✔️\");\n\n  const provider = new GoogleProvider({ relay: litRelay, litNodeClient });\n\n  return { litNodeClient, litRelay, provider };\n};\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions for EVM Networks with Wrapped Keys\nDESCRIPTION: Interface for the signTransactionWithEncryptedKey function when signing transactions for EVM-based networks. It includes parameters for PKP session signatures, Lit node client, network type, wrapped key ID, broadcast flag, and unsigned transaction details.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function signTransactionWithEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    network: 'evm';\n    id: string;\n    broadcast: boolean;\n    unsignedTransaction: EthereumLitTransaction;\n  }\n): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Configuring LitNodeClient for Jalapeno Mainnet in JavaScript\nDESCRIPTION: This code snippet shows how to specify the Jalapeno network when configuring the LitNodeClient. The Jalapeno network is the default, but can be explicitly set using the 'litNetwork' option.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/stateOfNetwork.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  litNetwork: \"jalapeno\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking MolochDAOv2.1 Membership with Custom Contract Call in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create an access control condition to check if a user has at least 1 share in a given MolochDAOv2.1 DAO. It uses a custom contract call to the 'members' function of the DAO contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/custom-contract-calls.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst evmContractConditions = [\n  {\n    contractAddress: \"0xb71a679cfff330591d556c4b9f21c7739ca9590c\",\n    functionName: \"members\",\n    functionParams: [\":userAddress\"],\n    functionAbi: {\n      constant: true,\n      inputs: [\n        {\n          name: \"\",\n          type: \"address\",\n        },\n      ],\n      name: \"members\",\n      outputs: [\n        {\n          name: \"delegateKey\",\n          type: \"address\",\n        },\n        {\n          name: \"shares\",\n          type: \"uint256\",\n        },\n        {\n          name: \"loot\",\n          type: \"uint256\",\n        },\n        {\n          name: \"exists\",\n          type: \"bool\",\n        },\n        {\n          name: \"highestIndexYesVote\",\n          type: \"uint256\",\n        },\n        {\n          name: \"jailed\",\n          type: \"uint256\",\n        },\n      ],\n      payable: false,\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    chain: \"xdai\",\n    returnValueTest: {\n      key: \"shares\",\n      comparator: \">=\",\n      value: \"1\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Encrypting Private Key with Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to encrypt a private key using the Lit Protocol SDK's encryptString method. It sets up access control conditions for the encryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\nimport { encryptString } from '@lit-protocol/encryption';\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { storeEncryptedKey } = api;\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n\nconst { ciphertext, dataToEncryptHash } = await encryptString(\n    {\n        accessControlConditions: [\n            {\n                contractAddress: '',\n                standardContractType: '',\n                chain: 'ethereum',\n                method: '',\n                parameters: [':userAddress'],\n                returnValueTest: {\n                comparator: '=',\n                value: process.env.PKP_ETH_ADDRESS,\n                },\n            },\n        ],\n        dataToEncrypt: process.env.CLEAR_TEXT_PRIVATE_KEY,\n    },\n    litNodeClient,\n)\n```\n\n----------------------------------------\n\nTITLE: Obtaining Multi-Chain Authentication Signatures in JavaScript\nDESCRIPTION: Demonstrates how to obtain and use authentication signatures from multiple blockchain networks (Solana, Ethereum, Cosmos, and Kyve) for use with the LitNodeClient API.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/unifiedAccessControlConditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// first, obtain auth sigs from both chains\nvar solAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"solana\",\n});\n\nvar ethAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"ethereum\",\n});\n\nvar cosmosAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"cosmos\",\n});\n\nvar kyveAuthSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain: \"kyve\",\n});\n\n// now, when you want to use the auth sigs, pass them as an object, with the key being the chain name.\nawait litNodeClient.saveSigningCondition({\n  unifiedAccessControlConditions,\n  authSig: {\n    cosmos: cosmosAuthSig,\n    kyve: kyveAuthSig,\n    solana: solAuthSig,\n    ethereum: ethAuthSig, // note that the key here is \"ethereum\" for any and all EVM chains.  If you're using Polygon, for example, you should still have \"ethereum\" here.\n  },\n  resourceId,\n});\n```\n\n----------------------------------------\n\nTITLE: Example AuthSig JSON Structure for Lit Protocol\nDESCRIPTION: This snippet shows the structure of an AuthSig used in Lit Protocol. It includes fields for the signature, signing method, signed message (including SIWE details), and the signer's address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/intro.md#2025-04-18_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"sig\": \"0xef8f88fb285f006594637257034226923e3bbf7c6c69f8863be213e50a1c1d7f18124eefdc595b4f50a0e242e8e132c5078dc3c52bda55376ba314e08da862e21a\",\n    \"derivedVia\": \"web3.eth.personal.sign\",\n    \"signedMessage\": \"localhost:3000 wants you to sign in with your Ethereum account:\\n        0x5259E44670053491E7b4FE4A120C70be1eAD646b\\n        \\n        \\n        URI: lit:session:6a1f1e8a00b61867b85eaf329d6fdf855220ac3e32f44ec13e4db0dd303dea6a\\n        Version: 1\\n        Chain ID: 1\\n        Nonce: ZfYjGsNyaDDFlaftP\\n        Issued At: 2022-10-30T08:25:33.371Z\\n        Expiration Time: 2022-11-06T08:25:33.348Z\\n        Resources:\\n        - urn:recap:eyJkZWYiOlsibGl0U2lnbmluZ0NvbmRpdGlvbiJdLCJ0YXIiOnsicmVzb3VyY2VJZCI6WyJsaXRFbmNyeXB0aW9uQ29uZGl0aW9uIl19fQ==\",\n    \"address\":\"0x5259E44670053491E7b4FE4A120C70be1eAD646b\"\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining SessionSigs in Browser\nDESCRIPTION: Code to obtain SessionSigs in the browser by creating a SIWE message and generating an auth signature using a browser wallet like MetaMask.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport {\n  LitAccessControlConditionResource,\n  createSiweMessage,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\nimport * as ethers from \"ethers\";\n\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\nawait provider.send(\"eth_requestAccounts\", []);\nconst ethersSigner = provider.getSigner();\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.Datil,\n  });\nawait litNodeClient.connect();\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n  resourceAbilityRequests: [\n    {\n      resource: new LitActionResource(\"*\"),\n      ability: LIT_ABILITY.LitActionExecution,\n    },\n  ],\n  authNeededCallback: async ({ resourceAbilityRequests, expiration, uri }) => {\n    const toSign = await createSiweMessageWithRecaps({\n      uri,\n      expiration,\n      resources: resourceAbilityRequests,\n      walletAddress: await ethersSigner.getAddress(),\n      nonce: await litNodeClient.getLatestBlockhash(),\n      litNodeClient,\n    });\n\n    return await generateAuthSig({\n      signer: ethersSigner,\n      toSign,\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Client-Side Browser Implementation\nDESCRIPTION: Browser-side code to execute Lit Action, collect signature shares and combine them\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {  \n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await Lit.Actions.signEcdsa({ toSign, publicKey , sigName });\n};\n\ngo();\n`;\n\nconst runLitAction = async () => {\n  // you need an AuthSig to auth with the nodes\n  // this will get it from MetaMask or any browser wallet\n  const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain: \"ethereum\" });\n\n  const litNodeClient = new LitJsSdk.LitNodeClient({ litNetwork: \"serrano\" });\n  await litNodeClient.connect();\n  const signatures = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n      toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n      publicKey:\n        \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n      sigName: \"sig1\",\n    },\n  });\n  console.log(\"signatures: \", signatures);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Storing Encrypted Ethereum Key with Lit Protocol\nDESCRIPTION: This snippet shows how to store an encrypted Ethereum key using the storeEncryptedKey method from the Lit Protocol SDK. It uses the previously generated PKP session signatures and encrypted key data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst successfullyStoredMetadata = await storeEncryptedKey({\n    pkpSessionSigs,\n    litNodeClient,\n    ciphertext,\n    dataToEncryptHash,\n    publicKey: process.env.ETHEREUM_PUBLIC_KEY,\n    keyType: 'K256',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient for Lit Protocol\nDESCRIPTION: TypeScript code to initialize and connect a LitNodeClient instance to the Lit Protocol test network (datil-test).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-pkp-session-sigs.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlet litNodeClient: LitNodeClient;\n\nlitNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      debug: false,\n    });\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data Using Crypto Package in Lit Protocol V3\nDESCRIPTION: Demonstrates decryption with the verifyAndDecryptWithSignatureShares method from the @lit-protocol/crypto package. This requires the ciphertext, signature shares, public key, and identity parameter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst ciphertext =\n  'l9a/01WDJB/euKxtbWcuQ8ez/c9eZ+jQryTHZVLN0kfd7XHoLs6FeWUVmk89ovQGkQJnnFDKjq6kgJxvIIrxXd9DaGuRBozLdA1G9Nk413YhTEqsENuHU0nSa4i6F912KltE15sbWKpDfPnZF6CA2UKBAw==';\nconst signatureShares = [\n  '01b2b44a0bf7184f19efacad98e213818edd3f8909dd798129ef169b877d68d77ba630005609f48b80203717d82092a45b06a9de0e61a97b2672b38b31f9ae43e64383d0375a51c75db8972613cc6b099b95c189fd8549ed973ee94b08749f4cac',\n  '02a8343d5602f523286c4c59356fdcfc51953290495d98cb91a56b59bd1a837ea969cc521382164e85787128ce7f944de303d8e0b5fc4becede0c894bec1adc490fdc133939cca70fb3f504b9bf7b156527b681d9f0619828cd8050c819e46fdb1',\n  '03b1594ab0cb56f47437b3720dc181661481ca0e36078b79c9a4acc50042f076bf66b68fbd12a1d55021a668555f0eed0a08dfe74455f557b30f1a9c32435a81479ca8843f5b74b176a8d10c5845a84213441eaaaf2ba57e32581584393541c5aa',\n];\n\nconst plaintext = verifyAndDecryptWithSignatureShares(\n  publicKey,\n  identityParam,\n  ciphertext,\n  signatureShares.map((s) => ({\n    ProofOfPossession: s,\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Checking SOL Balance in Wallet\nDESCRIPTION: Verifies if a user's wallet contains more than 0.1 SOL. Uses the getBalance RPC call with the user's wallet address as a parameter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"getBalance\",\n    params: [\":userAddress\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Connecting LitSigner to LightSmartContractAccount\nDESCRIPTION: Code that integrates the LitSigner with a LightSmartContractAccount from the aa-accounts package, setting up the AlchemyProvider to use Lit's PKP as the account owner.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { AlchemyProvider } from \"@alchemy/aa-alchemy\";\nimport {\n  LightSmartContractAccount,\n  getDefaultLightAccountFactoryAddress,\n} from \"@alchemy/aa-accounts\";\nimport { polygonMumbai } from \"viem/chains\";\nimport { createLitSigner } from \"./lit\";\nconst chain = polygonMumbai;\n\nconst provider = new AlchemyProvider({\n  apiKey: \"ALCHEMY_API_KEY\",\n  chain,\n}).connect(\n  (rpcClient) =>\n    new LightSmartContractAccount({\n      chain,\n      owner: litSigner,\n      factoryAddress: getDefaultLightAccountFactoryAddress(chain),\n      rpcClient,\n    })\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Access Control Condition with SIWE Domain in JavaScript\nDESCRIPTION: This snippet demonstrates how to create an access control condition that checks the domain of a Sign In With Ethereum message. It ensures the domain matches 'localhost:3050', which helps prevent signature reuse across domains.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/siwe.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"SIWE\",\n    chain: \"ethereum\",\n    method: \"\",\n    parameters: [\":domain\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"localhost:3050\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Checking ERC1155 Token Ownership with Custom Contract Call in JavaScript\nDESCRIPTION: This code snippet shows how to create an access control condition to verify if a user possesses at least one ERC1155 token with a specific token id. It uses the 'balanceOf' function of the ERC1155 contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/custom-contract-calls.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \"8\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Making Encryption Requests with SessionSigs in Lit Protocol\nDESCRIPTION: This snippet demonstrates the process of encrypting a message, storing decryption conditions, and then decrypting the message using SessionSigs. It utilizes various Lit SDK functions for encryption, key management, and access control.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/usage.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n\n// encrypt\nconst { encryptedZip, symmetricKey } =\n  await LitJsSdk.zipAndEncryptString(\"this is a secret message\");\n\n// store the decryption conditions\nconst encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({\n  unifiedAccessControlConditions,\n  symmetricKey,\n  sessionSigs,\n});\n\n// retrieving the key:\nconst hashOfKey = await LitJsSdk.hashEncryptionKey({\n  encryptedSymmetricKey,\n});\n\n// Create an access control condition resource\nvar litResource = new LitAccessControlConditionResource(hashOfKey);\n\nsessionSigs = await LitJsSdk.getSessionSigs({\n  chain: \"ethereum\",\n  litNodeClient,\n  resourceAbilityRequests: [\n    resource: litResource,\n    ability: LitAbility.AccessControlConditionDecryption\n  ]\n});\n\n const retrievedSymmKey = await litNodeClient.getEncryptionKey({\n  unifiedAccessControlConditions,\n  toDecrypt: LitJsSdk.uint8arrayToString(\n    encryptedSymmetricKey,\n    \"base16\"\n  ),\n  sessionSigs,\n});\n\nconst decryptedFiles = await LitJsSdk.decryptZip(\n  encryptedZip,\n  retrievedSymmKey\n);\nconst decryptedString = await decryptedFiles[\"string.txt\"].async(\n  \"text\"\n);\nconsole.log(\"decrypted string\", decryptedString);\n```\n\n----------------------------------------\n\nTITLE: Creating PKPClient and Initializing PKPWalletConnect in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create a PKPClient using Lit Protocol's libraries and initialize PKPWalletConnect. It includes setting up a LitNodeClient, generating session signatures, creating a PKPEthersWallet, and adding it to PKPWalletConnect.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK, LIT_ABILITY, LIT_RPC } from \"@lit-protocol/constants\";\nimport {\n  createSiweMessage,\n  generateAuthSig,\n  LitPKPResource\n} from \"@lit-protocol/auth-helpers\";\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport { PKPWalletConnect } from \"@lit-protocol/pkp-walletconnect\";\nimport * as ethers from \"ethers\";\n\nconst ETHEREUM_PRIVATE_KEY = \"<Your Ethereum private key>\";\nconst LIT_PKP_PUBLIC_KEY = \"<Your Lit PKP public key>\";\n\nconst ethersWallet = new ethers.Wallet(\n  ETHEREUM_PRIVATE_KEY,\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n\nconst litNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilDev,\n      debug: false,\n    });\n    await litNodeClient.connect();\n\nconst sessionSignatures = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n  resourceAbilityRequests: [\n    {\n      resource: new LitPKPResource(\"*\"),\n      ability: LIT_ABILITY.PKPSigning,\n    },\n  ],\n  authNeededCallback: async ({\n    uri,\n    expiration,\n    resourceAbilityRequests,\n  }) => {\n    const toSign = await createSiweMessage({\n      uri,\n      expiration,\n      resources: resourceAbilityRequests,\n      walletAddress: await ethersWallet.getAddress(),\n      nonce: await litNodeClient.getLatestBlockhash(),\n      litNodeClient,\n    });\n\n    return await generateAuthSig({\n      signer: ethersWallet,\n      toSign,\n    });\n  },\n});\n\nconst pkpEthersWallet = new PKPEthersWallet({\n  litNodeClient,\n  pkpPubKey: LIT_PKP_PUBLIC_KEY!,\n  controllerSessionSigs: sessionSignatures\n});\n\n\nconst pkpWalletConnect = new PKPWalletConnect();\npkpWalletConnect.addPKPEthersWallet(pkpEthersWallet);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network (Server-Side)\nDESCRIPTION: Code snippet to set up and connect a Lit client to the Datil network on the server side using Express.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\napp.locals.litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\n  alertWhenUnauthorized: false,\n  litNetwork: LIT_NETWORK.Datil,\n});\nawait app.locals.litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Getting Signed JWT Token\nDESCRIPTION: Example showing how to obtain a signed JWT token from the Lit network using access control conditions and session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/jwt-auth.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = await litNodeClient.getSignedToken({\n  accessControlConditions,\n  chain,\n  sessionSigs,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures from Delegation Signature\nDESCRIPTION: This code shows how to create session signatures using a delegation signature, enabling another wallet to use the Capacity Credit without possessing the NFT. It includes setting up authentication callbacks and verifying capabilities for resources.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/capacity-credits.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n  import { LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\n\n  const DELEGATEE_WALLET = new ethers.Wallet(your_private_key_string, provider);\n\n  const litNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      checkNodeAttestation: true,\n  });\n  await litNodeClient.connect();\n  \n  const authNeededCallback = async ({ resources, expiration, uri }) => {\n    // you can change this resource to anything you would like to specify\n    const litResource = new LitActionResource('*');\n\n    const recapObject =\n      await litNodeClient.generateSessionCapabilityObjectWithWildcards([\n        litResource,\n      ]);\n\n    recapObject.addCapabilityForResource(\n      litResource,\n      LIT_ABILITY.LitActionExecution\n    );\n\n    const verified = recapObject.verifyCapabilitiesForResource(\n      litResource,\n      LIT_ABILITY.LitActionExecution\n    );\n\n    if (!verified) {\n      throw new Error('Failed to verify capabilities for resource');\n    }\n\n    let nonce = await litNodeClient.getLatestBlockhash();\n    let siweMessage = new siwe.SiweMessage({\n      domain: 'localhost:3000', // change to your domain ex: example.app.com\n      address: DELEGATEE_WALLET.address,\n      statement: 'Some custom statement.', // configure to what ever you would like\n      uri,\n      version: '1',\n      chainId: '1',\n      expirationTime: expiration,\n      resources,\n      nonce,\n    });\n\n    siweMessage = recapObject.addToSiweMessage(siweMessage);\n\n    const messageToSign = siweMessage.prepareMessage();\n    const signature = await DELEGATEE_WALLET.signMessage(messageToSign);\n\n    const authSig = {\n      sig: signature,\n      derivedVia: 'web3.eth.personal.sign',\n      signedMessage: messageToSign,\n      address: DELEGATEE_WALLET.address,\n    };\n\n    return authSig;\n  };\n\n  let sessionSigs = await litNodeClient.getSessionSigs({\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    chain: 'ethereum',\n    resourceAbilityRequests: [\n      {\n        resource: new LitActionResource('*'),\n        ability: LIT_ABILITY.LitActionExecution,\n      },\n    ],\n    authNeededCallback,\n    capacityDelegationAuthSig,\n  });\n```\n\n----------------------------------------\n\nTITLE: Minting a Claim using Lit SDK and LitContracts in JavaScript\nDESCRIPTION: This code snippet shows how to mint a claim using the Lit SDK to execute a Lit Action and then use LitContracts to mint the claim on-chain. It includes executing JavaScript code and interacting with smart contracts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/key-claiming.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst res = await client.executeJs({\n    sessionSigs,\n    code: `(async () => {\n      Lit.Actions.claimKey({keyId: userId});\n    })();`,\n    authMethods: [],\n    jsParams: {\n        userId: 'foo'\n    },\n  });\n\n  let client = new LitContracts(signer: \"<your pkp wallet or other signer>\");\n  let tx = await contractClient.pkpNftContract.write.claimAndMint(2, res.claims['foo'].derivedKeyId, res.claims['foo'].signatures);\n```\n\n----------------------------------------\n\nTITLE: Calculating Key ID using ethers.js in JavaScript\nDESCRIPTION: This snippet demonstrates how to calculate a key ID by hashing the IPFS CID of a Lit Action and a user ID using ethers.js. The key ID is created by taking the keccak256 hash of the concatenated string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/key-claiming.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst keyId = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(\"theIPFSIdOfYourLitAction_yourUserId\"))\n```\n\n----------------------------------------\n\nTITLE: Getting Signed Chain Data Token\nDESCRIPTION: Requests a signed JWT from the Lit Network containing the smart contract call result.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = await litNodeClient.getSignedChainDataToken({\n  callRequests,\n  chain: 'ethereum',\n});\n```\n\n----------------------------------------\n\nTITLE: Converting UTF-8 String to Hexadecimal for EVM Transaction Data\nDESCRIPTION: This snippet demonstrates how to convert a UTF-8 string to a hexadecimal format for use in the dataHex field of an EVM transaction using ethers.js library.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ethers } from 'ethers';\n\nconst dataHex = ethers.utils.hexlify(\n    ethers.utils.toUtf8Bytes('The answer to the Universe is 42.')\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Contracts Client for Capacity Credits\nDESCRIPTION: This code snippet demonstrates how to initialize the LitContracts client with a signer wallet to interact with the Capacity Credits system on the Datil-Test network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/capacity-credits.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst walletWithCapacityCredit = new Wallet(\"<your private key or mnemonic>\");\nlet contractClient = new LitContracts({\n  signer: dAppOwnerWallet,\n  network: LIT_NETWORK.DatilTest,\n});\n\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Installing Hardhat for Smart Contract Development\nDESCRIPTION: This command installs Hardhat, a development environment for Ethereum smart contracts, using Yarn package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add hardhat\n```\n\n----------------------------------------\n\nTITLE: Converting Multihash to Bytes in LitContracts\nDESCRIPTION: Utility method to convert a multihash string into a bytes object representation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst bytes = LitContracts.utils.getBytesFromMultihash(multihash);\n```\n\n----------------------------------------\n\nTITLE: Checking ETH Balance in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user's ETH balance is at least 0.00001 ETH. It uses the eth_getBalance method to retrieve the user's balance in Wei and compares it to the specified threshold.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '',\n    standardContractType: '',\n    chain,\n    method: 'eth_getBalance',\n    parameters: [\n      ':userAddress',\n      'latest'\n    ],\n    returnValueTest: {\n      comparator: '>=',\n      value: '10000000000000'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Registering User with Email/SMS OTP\nDESCRIPTION: Initializes authentication client, sends OTP code, and mints PKP through relay server after successful verification.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst authClient = new LitAuthClient({\n    litRelayConfig: {\n        relayApiKey: '<Your Lit Relay Server API Key>',\n    }\n});\n\n// starting a validation session\nlet session = authClient.initProvider(ProviderType.Otp,{\n            userId: '<User email or phone number>'\n});\n\nlet status = await session.sendOtpCode();\nlet authMethod = await session.authenticate({\n    code: \"<User entered OTP code>\"\n});\nconst txHash = await session.mintPKPThroughRelayer(authMethod);\n```\n\n----------------------------------------\n\nTITLE: Sending Transactions with PKPEthersWallet\nDESCRIPTION: Demonstrates how to send a previously signed transaction using PKPEthersWallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nawait pkpWallet.sendTransaction(signedTransactionRequest);\n```\n\n----------------------------------------\n\nTITLE: Obtaining Session Signature Server-Side with SIWE\nDESCRIPTION: Demonstrates how to obtain a session signature on the server-side using ethers.Signer to sign a SIWE message. Includes session key generation and authentication callback setup.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nconst LitJsSdk = require('@lit-protocol/lit-node-client-nodejs');\nconst { ethers } = require(\"ethers\");\nconst siwe = require('siwe');\n\nlet nonce = await litNodeClient.getLatestBlockhash();\n\n// Initialize the signer\nconst wallet = new ethers.Wallet('<Your private key>');\nconst address = ethers.getAddress(await wallet.getAddress());\n\n// Craft the SIWE message\nconst domain = 'localhost';\nconst origin = 'https://localhost/login';\nconst statement =\n  'This is a test statement.  You can put anything you want here.';\n    \n// expiration time in ISO 8601 format.  This is 7 days in the future, calculated in milliseconds\nconst expirationTime = new Date(\n  Date.now() + 1000 * 60 * 60 * 24 * 7 * 10000\n).toISOString();\n\nconst siweMessage = new siwe.SiweMessage({\n  domain,\n  address: address,\n  statement,\n  uri: origin,\n  version: '1',\n  chainId: 1,\n  nonce,\n  expirationTime,\n});\nconst messageToSign = siweMessage.prepareMessage();\n  \n// Sign the message and format the authSig\nconst signature = await wallet.signMessage(messageToSign);\n\nconst authSig = {\n sig: signature,\n derivedVia: 'web3.eth.personal.sign',\n signedMessage: messageToSign,\n address: address,\n};\n\nconsole.log(authSig);\n\n// Form the authNeededCallback to create a session with\n// the wallet signature.\nconst authNeededCallback = async (params) => {\n const response = await client.signSessionKey({\n   statement: params.statement,\n   authMethods: [\n     {\n       authMethodType: 1,\n       // use the authSig created above to authenticate\n       // allowing the pkp to sign on behalf.\n       accessToken: JSON.stringify(authSig),\n     },\n   ],\n   pkpPublicKey: `<your pkp public key>`,\n   expiration: params.expiration,\n   resources: params.resources,\n   chainId: 1,\n });\n return response.authSig;\n};\n\n// Set resources to allow for signing of any message.\nconst resourceAbilities = [\n {\n   resource: new LitActionResource('*'),\n   ability: LIT_ABILITY.PKPSigning,\n },\n];\n// Get the session key for the session signing request\n// will be accessed from local storage or created just in time.\nconst sessionKeyPair = client.getSessionKey();\n\n// Request a session with the callback to sign\n// with an EOA wallet from the custom auth needed callback created above.\nconst sessionSigs = await client.getSessionSigs({\n   chain: \"ethereum\",\n   expiration:  new Date(Date.now() + 60_000 * 60).toISOString(),\n   resourceAbilityRequests: resourceAbilities,\n   authNeededCallback,\n});\n```\n\n----------------------------------------\n\nTITLE: Browser-based Session Signatures\nDESCRIPTION: Implementation of session signature generation in a browser environment using Web3Provider.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ethers } from \"ethers\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitAccessControlConditionResource,\n  createSiweMessageWithRecaps,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\n\nclass Lit {\n  ...\n\n  async getSessionSignatures(){\n     // Connect to the wallet\n     const provider = new ethers.providers.Web3Provider(window.ethereum);\n     await provider.send(\"eth_requestAccounts\", []);\n     const signer = provider.getSigner();\n     const walletAddress = await signer.getAddress();\n     console.log(\"Connected account:\", walletAddress);\n  \n     // Get the latest blockhash\n     const latestBlockhash = await this.litNodeClient.getLatestBlockhash();\n  \n     // Define the authNeededCallback function\n     const authNeededCallback = async(params) => {\n       if (!params.uri) {\n         throw new Error(\"uri is required\");\n       }\n       if (!params.expiration) {\n         throw new Error(\"expiration is required\");\n       }\n  \n       if (!params.resourceAbilityRequests) {\n         throw new Error(\"resourceAbilityRequests is required\");\n       }\n   \n       // Create the SIWE message\n       const toSign = await createSiweMessageWithRecaps({\n         uri: params.uri,\n         expiration: params.expiration,\n         resources: params.resourceAbilityRequests,\n         walletAddress: walletAddress,\n         nonce: latestBlockhash,\n         litNodeClient: this.litNodeClient,\n       });\n  \n       // Generate the authSig\n       const authSig = await generateAuthSig({\n         signer: signer,\n         toSign,\n       });\n  \n       return authSig;\n     }\n  \n     // Define the Lit resource\n     const litResource = new LitAccessControlConditionResource('*');\n\n     // Get the session signatures\n     const sessionSigs = await this.litNodeClient.getSessionSigs({\n         chain: this.chain,\n         resourceAbilityRequests: [\n             {\n                 resource: litResource,\n                 ability: LIT_ABILITY.AccessControlConditionDecryption,\n             },\n         ],\n         authNeededCallback,\n         capacityDelegationAuthSig,\n     });\n     return sessionSigs;\n  }\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Lit Action to Check PKP Permissions in JavaScript\nDESCRIPTION: This code snippet demonstrates how to set up a Lit Node Client, define a Lit Action to check various PKP permissions, and execute it. It includes checks for permitted actions, addresses, auth methods, and scopes. The code uses the @lit-protocol/lit-node-client package and requires an AuthSig for authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/workingWithActions/permissions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  const results = {}\n  const tokenId = Lit.Actions.pubkeyToTokenId({publicKey})\n  results.tokenId = tokenId\n\n  // let's lookup some permissions\n  const isPermittedAction = await Lit.Actions.isPermittedAction({tokenId, ipfsId: \"QmRwN9GKHvCn4Vk7biqtr6adjXMs7PzzYPCzNCRjPFiDjm\"})\n  results.isPermittedAction = isPermittedAction\n\n  const isPermittedAddress = await Lit.Actions.isPermittedAddress({tokenId, address: Lit.Auth.authSigAddress})\n  results.isPermittedAddress = isPermittedAddress\n\n  const userId = uint8arrayFromString(\"testing\", \"utf8\")\n  const isPermittedAuthMethod = await Lit.Actions.isPermittedAuthMethod({tokenId, authMethodType: \"2\", userId })\n  results.isPermittedAuthMethod = isPermittedAuthMethod\n\n  const permittedActions = await Lit.Actions.getPermittedActions({tokenId})\n  results.permittedActions = permittedActions\n\n  const permittedAddresses = await Lit.Actions.getPermittedAddresses({tokenId})\n  results.permittedAddresses = permittedAddresses\n\n  const permittedAuthMethods = await Lit.Actions.getPermittedAuthMethods({tokenId})\n  results.permittedAuthMethods = JSON.stringify(permittedAuthMethods)\n\n  const permittedAuthMethodScopes = await Lit.Actions.getPermittedAuthMethodScopes({\n    tokenId,\n    authMethodType: \"2\",\n    userId,\n    maxScopeId: 10\n  })\n\n  results.permittedAuthMethodScopes = JSON.stringify(permittedAuthMethodScopes)\n\n  Lit.Actions.setResponse({response: JSON.stringify(results)})\n};\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"custom\",\n    debug: true,\n    minNodeCount: 2,\n    bootstrapUrls: [\n      \"http://localhost:7470\",\n      \"http://localhost:7471\",\n      \"http://localhost:7472\",\n    ],\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      publicKey:\n        \"0x042f48db7024106148948a64a142656d0c0513ff60ebb614fc61c7451001dabd10f7cc52879b9a8feb0b00dad12cbd51df545ca2c30135f77b0c79775e426e562c\",\n    },\n  });\n  console.log(\"results: \", results);\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Minting PKP with Auth Scopes\nDESCRIPTION: Code to mint a PKP NFT with specific authentication method types and permission scopes. Demonstrates setting up auth methods and defining their capabilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-contracts.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE } from '@lit-protocol/constants';\n\nconst authMethod = {\n  authMethodType: AUTH_METHOD_TYPE.EthWallet,\n  accessToken: JSON.stringify(authSig),\n};\n\nconst mintInfo = await contractClient.mintWithAuth({\n  authMethod: authMethod,\n  scopes: [\n\t\t// AUTH_METHOD_SCOPE.NoPermissions,\n\t\tAUTH_METHOD_SCOPE.SignAnything, \n\t\tAUTH_METHOD_SCOPE.PersonalSign\n\t],\n});\n\n// output:\n{\n  pkp: {\n      tokenId: string;\n      publicKey: string;\n      ethAddress: string;\n  };\n  tx: ethers.ContractReceipt;\n}\n```\n\n----------------------------------------\n\nTITLE: Encrypting Content with LitNodeClient\nDESCRIPTION: Demonstrates how to encrypt data client-side using LitNodeClient with access control conditions. The code shows the process of creating access control conditions and encrypting a string, returning ciphertext and dataToEncryptHash.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/combining-decryption-shares.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n const chain = 'ethereum';\n const accessControlConditions = [\n    {\n      contractAddress: '',\n      standardContractType: '',\n      chain,\n      method: 'eth_getBalance',\n      parameters: [':userAddress', 'latest'],\n      returnValueTest: {\n        comparator: '>=',\n        value: '0',\n      },\n    },\n  ];\n  const message = 'Hello world';\n  const client = new LitNodeClient({\n    litNetwork: \"datil-dev\"\n  });\n  await client.connect();\n  const { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n    {\n      accessControlConditions,\n      sessionSigs: {}, // your session\n      chain,\n      dataToEncrypt: message,\n    },\n    client\n  );\n\n  console.log(\"cipher text:\", ciphertext, \"hash:\", dataToEncryptHash);\n```\n\n----------------------------------------\n\nTITLE: Registering WebAuthn Credential and Minting PKP with Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to set up LitAuthClient, initialize the WebAuthn provider, register a new WebAuthn credential, and mint a PKP (Programmable Key Pair) through the Lit Relay Server.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/webAuthn.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Set up LitAuthClient\nconst litAuthClient = new LitAuthClient({\n  litRelayConfig: {\n     // Request a Lit Relay Server API key here: https://forms.gle/RNZYtGYTY9BcD9MEA\n    relayApiKey: '<Your Lit Relay Server API Key>',\n  },\n});\n\n// Initialize WebAuthn provider\nlitAuthClient.initProvider(ProviderType.WebAuthn);\n\nasync function registerWithWebAuthn() {\n  const provider = litAuthClient.getProvider(ProviderType.WebAuthn);\n  // Register new WebAuthn credential\n  const options = await provider.register();\n\n  // Verify registration and mint PKP through relay server\n  const txHash = await provider.verifyAndMintPKPThroughRelayer(options);\n  const response = await provider.relay.pollRequestUntilTerminalState(\n    txHash\n  );\n  // Return public key of newly minted PKP\n  return response.pkpPublicKey;\n}\n```\n\n----------------------------------------\n\nTITLE: Delegating Capacity Credits Using SessionSigs in Lit Protocol\nDESCRIPTION: This code demonstrates how to delegate capacity credits to other users in Lit Protocol. It shows how to create session capability objects that specify authentication with a Capacity Credits NFT and execute Lit Actions. The example utilizes the LitNodeClient to connect to the Datil test network and generate session signatures with specific resource abilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/concepts/capacity-credits-concept.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\n\n  const litNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      checkNodeAttestation: true,\n  });\n  \n  await litNodeClient.connect();\n  const authNeededCallback = async ({ resources, expiration, uri }) => {\n    // you can change this resource to anything you would like to specify\n    const litResource = new LitActionResource('*');\n\n    const recapObject =\n      await litNodeClient.generateSessionCapabilityObjectWithWildcards([\n        litResource,\n      ]);\n\n    recapObject.addCapabilityForResource(\n      litResource,\n      LIT_ABILITY.LitActionExecution\n    );\n\n    const verified = recapObject.verifyCapabilitiesForResource(\n      litResource,\n      LIT_ABILITY.LitActionExecution\n    );\n\n    if (!verified) {\n      throw new Error('Failed to verify capabilities for resource');\n    }\n\n    let siweMessage = new siwe.SiweMessage({\n      domain: 'localhost:3000', // change to your domain ex: example.app.com\n      address: dAppOwnerWallet_address,\n      statement: 'Some custom statement.', // configure to what ever you would like\n      uri,\n      version: '1',\n      chainId: '1',\n      expirationTime: expiration,\n      resources,\n    });\n\n    siweMessage = recapObject.addToSiweMessage(siweMessage);\n\n    const messageToSign = siweMessage.prepareMessage();\n    const signature = await dAppOwnerWallet.signMessage(messageToSign);\n\n    const authSig = {\n      sig: signature,\n      derivedVia: 'web3.eth.personal.sign',\n      signedMessage: messageToSign,\n      address: dAppOwnerWallet_address,\n    };\n\n    return authSig;\n  };\n\n  let sessionSigs = await litNodeClient.getSessionSigs({\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    chain: 'ethereum',\n    resourceAbilityRequests: [\n      {\n        resource: new LitActionResource('*'),\n        ability: LIT_ABILITY.LitActionExecution,\n      },\n    ],\n    authNeededCallback,\n    capacityDelegationAuthSig,\n  });\n```\n\n----------------------------------------\n\nTITLE: Instantiating an Ethers Signer for Chronicle Yellowstone\nDESCRIPTION: TypeScript code to create an Ethers signer by connecting to the Chronicle Yellowstone blockchain using a private key and the Lit RPC URL. This signer will be used to sign transactions for minting Capacity Credits.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/minting-capacity-credit/via-contract.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport ethers from \"ethers\";\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Lit Action for ECDSA Signing\nDESCRIPTION: Simple Lit Action code that requests a signature share from a Lit Node.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst litActionCode = `\n\tconst go = async () => {\n\t\tconst sigShare = await LitActions.signEcdsa({ toSign, publicKey, sigName });\n\t};\n\t\n\tgo();\n`;\n```\n\n----------------------------------------\n\nTITLE: Updating Provider Methods in JavaScript\nDESCRIPTION: Replacement methods for the deprecated fetchPKPsThroughRelayer method in providers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Fetch PKPs directly from the blockchain\nconst pkps = await provider.fetchPKPs(...);\n\n// Or get PKPs for a specific auth method\nconst pkps = await provider.getPKPsForAuthMethod(authMethod);\n```\n\n----------------------------------------\n\nTITLE: Signing Messages with PKPEthersWallet\nDESCRIPTION: Demonstrates how to sign a simple message using PKPEthersWallet by converting the message to hex format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst message = \"Free the web\";\nconst hexMsg = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(message));\nawait pkpWallet.signMessage(hexMsg);\n```\n\n----------------------------------------\n\nTITLE: Installing GetLit CLI using npm or yarn\nDESCRIPTION: Commands to install the GetLit CLI globally using either npm or yarn package managers. This allows developers to use the 'getlit' command from any directory.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Tools/getlitCli.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g getlit\n\n// or\nyarn add global getlit\n```\n\n----------------------------------------\n\nTITLE: Checking Proof of Humanity Registration in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user is registered with Proof of Humanity. It uses the isRegistered method of the Proof of Humanity contract to verify the user's registration status.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"0xC5E9dDebb09Cd64DfaCab4011A0D5cEDaf7c9BDb\",\n    standardContractType: \"ProofOfHumanity\",\n    chain: \"ethereum\",\n    method: \"isRegistered\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Lit Protocol Client for Encryption with Habanero/Manzano Networks\nDESCRIPTION: This class creates a Lit Protocol client that connects to the Manzano network and provides methods for connecting, getting session signatures, and encrypting messages using access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ethers} from \"ethers\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitAccessControlConditionResource,\n  createSiweMessageWithRecaps,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\n\nclass LitV3 {  // or Class LitV4\n  private ethersWallet;\n  private litNodeClient;\n\n  constructor(yourPrivateKey) {\n    this.ethersWallet = new ethers.Wallet(\n      yourPrivateKey\n    );\n  }\n\n  async connect() {\n    const client = new LitJsSdk.LitNodeClient({\n         litNetwork: \"manzano\",\n    });\n    await client.connect();\n    this.litNodeClient = client;\n  }\n\n  async getSessionSignatures(){\n      // Get the latest blockhash\n      const latestBlockhash = await this.litNodeClient.getLatestBlockhash();\n\n      // Define the authNeededCallback function\n      const authNeededCallback = async(params) => {\n        if (!params.uri) {\n          throw new Error(\"uri is required\");\n        }\n        if (!params.expiration) {\n          throw new Error(\"expiration is required\");\n        }\n\n        if (!params.resourceAbilityRequests) {\n          throw new Error(\"resourceAbilityRequests is required\");\n        }\n\n        // Create the SIWE message\n        const toSign = await createSiweMessageWithRecaps({\n          uri: params.uri,\n          expiration: params.expiration,\n          resources: params.resourceAbilityRequests,\n          walletAddress: this.ethersWallet.address,\n          nonce: latestBlockhash,\n          litNodeClient: this.litNodeClient,\n        });\n\n        // Generate the authSig\n        const authSig = await generateAuthSig({\n          signer: this.ethersWallet,\n          toSign,\n        });\n\n        return authSig;\n      }\n\n      // Define the Lit resource\n      const litResource = new LitAccessControlConditionResource('*');\n\n      // Get the session signatures\n      const sessionSigs = await this.litNodeClient.getSessionSigs({\n          chain: 'ethereum',\n          resourceAbilityRequests: [\n              {\n                  resource: litResource,\n                  ability: LIT_ABILITY.AccessControlConditionDecryption,\n              },\n          ],\n          authNeededCallback,\n      });\n      return sessionSigs;\n  }\n\n  async encrypt(message) {\n    if (!this.litNodeClient) {\n      await this.connect();\n    }\n  \n    const sessionSigs = await this.getSessionSignatures();\n    const accessControlConditions = [\n      {\n        contractAddress: \"\",\n        standardContractType: \"\",\n        chain: \"ethereum\",\n        method: \"eth_getBalance\",\n        parameters: [\":userAddress\", \"latest\"],\n        returnValueTest: {\n          comparator: \">=\",\n          value: \"1000000000000\", // 0.000001 ETH\n        },\n      },\n    ];\n\n    const { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n      {\n        accessControlConditions,\n        sessionSigs,\n        chain: 'ethereum',\n        dataToEncrypt: message,\n      },\n      litNodeClient,\n    );\n  \n    return {\n      ciphertext,\n      dataToEncryptHash,\n    };\n  }\n}\n\nexport default new Lit();\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions for Lit Protocol\nDESCRIPTION: Set up access control conditions for Lit Protocol, specifying requirements for accessing a resource, such as holding a specific ERC1155 token.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"0x3110c39b428221012934A7F617913b095BC1078C\",\n    standardContractType: \"ERC1155\",\n    chain,\n    method: \"balanceOf\",\n    parameters: [\":userAddress\", \"9541\"],\n    returnValueTest: {\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with Access Control\nDESCRIPTION: Implements the getSessionSigs function to generate session signatures with specific capabilities for decrypting data. Includes SIWE message creation and authentication signature generation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-session-sigs.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitAccessControlConditionResource,\n  createSiweMessage,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\n\nconst sessionSignatures = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  expiration: new Date(Date.now() + 1000 * 60 * 10 ).toISOString(), // 10 minutes\n  capabilityAuthSigs: [capacityDelegationAuthSig], // Unnecessary on datil-dev\n  resourceAbilityRequests: [\n    {\n      resource: new LitAccessControlConditionResource(\"*\"),\n      ability: LIT_ABILITY.AccessControlConditionDecryption,\n    },\n  ],\n  authNeededCallback: async ({\n    uri,\n    expiration,\n    resourceAbilityRequests,\n  }) => {\n    const toSign = await createSiweMessage({\n      uri,\n      expiration,\n      resources: resourceAbilityRequests,\n      walletAddress: ethersSigner.address,\n      nonce: await litNodeClient.getLatestBlockhash(),\n      litNodeClient,\n    });\n\n    return await generateAuthSig({\n      signer: ethersSigner,\n      toSign,\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating PKPClient in JavaScript\nDESCRIPTION: Initializes a PKPClient instance representing a PKP and initializes signers for use across multiple blockchains (currently EVM-only).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PKPClient } from '@lit-protocol/pkp-client';\n\nconst pkpClient = new PKPClient({\n  controllerAuthSig: '<Your AuthSig>',\n  // Or you can also pass in controllerSessionSigs\n  pkpPubKey: '<Your PKP public key>',\n});\nawait pkpClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Implementing Domain-based Access Control with SIWE in JavaScript\nDESCRIPTION: This snippet demonstrates how to create an access control condition based on the Domain parameter of a Sign in with Ethereum message. It checks if the domain matches 'localhost:3050', which helps prevent signature reuse across domains.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/siwe.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"SIWE\",\n    chain: \"ethereum\",\n    method: \"\",\n    parameters: [\":domain\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"localhost:3050\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Server-side Session Signatures\nDESCRIPTION: Implementation of session signature generation in a server-side environment using ethers.Wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport {ethers} from \"ethers\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitAccessControlConditionResource,\n  createSiweMessageWithRecaps,\n  generateAuthSig,\n} from \"@lit-protocol/auth-helpers\";\n\nclass Lit {\n  ...\n\n  async getSessionSignatures(){\n      // Connect to the wallet\n      const ethWallet = new ethers.Wallet(\n        \"<your private key>\"\n      );\n\n      // Get the latest blockhash\n      const latestBlockhash = await this.litNodeClient.getLatestBlockhash();\n\n      // Define the authNeededCallback function\n      const authNeededCallback = async(params) => {\n        if (!params.uri) {\n          throw new Error(\"uri is required\");\n        }\n        if (!params.expiration) {\n          throw new Error(\"expiration is required\");\n        }\n\n        if (!params.resourceAbilityRequests) {\n          throw new Error(\"resourceAbilityRequests is required\");\n        }\n\n        // Create the SIWE message\n        const toSign = await createSiweMessageWithRecaps({\n          uri: params.uri,\n          expiration: params.expiration,\n          resources: params.resourceAbilityRequests,\n          walletAddress: ethWallet.address,\n          nonce: latestBlockhash,\n          litNodeClient: this.litNodeClient,\n        });\n\n        // Generate the authSig\n        const authSig = await generateAuthSig({\n          signer: ethWallet,\n          toSign,\n        });\n\n        return authSig;\n      }\n\n      // Define the Lit resource\n      const litResource = new LitAccessControlConditionResource('*');\n\n      // Get the session signatures\n      const sessionSigs = await this.litNodeClient.getSessionSigs({\n          chain: this.chain,\n          resourceAbilityRequests: [\n              {\n                  resource: litResource,\n                  ability: LIT_ABILITY.AccessControlConditionDecryption,\n              },\n          ],\n          authNeededCallback,\n          capacityDelegationAuthSig,\n      });\n      return sessionSigs;\n  }\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Signing Lit Action in JavaScript\nDESCRIPTION: This Lit Action checks if the user has at least 1 Wei on Ethereum before signing data. It uses the checkConditions function from the Lit Actions SDK to perform the balance check.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/conditional-signing.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst _litActionCode = async () =>  {\n  try {\n    // test an access control condition\n    const testResult = await Lit.Actions.checkConditions({\n      conditions,\n      authSig,\n      chain,\n    });\n\n    if (!testResult) {\n      LitActions.setResponse({ response: \"address does not have 1 or more Wei on Ethereum Mainnet\" });\n      return;\n    }\n\n    const sigShare = await LitActions.signEcdsa({\n      toSign: dataToSign,\n      publicKey,\n      sigName: \"sig\",\n    });\n  } catch (error) {\n    LitActions.setResponse({ response: error.message });\n  }\n};\n\nconst litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: Minting PKP with Multiple Auth Methods via ContractsSDK\nDESCRIPTION: Process of minting a PKP using multiple authentication methods through ContractsSDK, including cost calculation and transaction handling\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Get the mint cost\nconst mintCost = await contractClient.pkpNftContract.read.mintCost();\n\n// Mint PKP using both Auth Methods\nconst mintTx = await contractClient.pkpHelperContract.write.mintNextAndAddAuthMethods(\n  2, // key type\n  [AUTH_METHOD_TYPE.EthWallet, AUTH_METHOD_TYPE.LitAction], // Specify the auth method types\n  [authIdWallet, authIdAction],  // Specify the auth method IDs\n  ['0x', '0x'], // Specify the auth method public keys\n  [[1], [1]], // Specify the auth method scopes\n  true,  // Whether to add PKP eth address as permitted address or not\n  true, // Whether to send PKP to itself or not\n  { value: mintCost }\n);\n\n// Wait for the transaction to be mined\nconst mintTxReceipt = await mintTx.wait();\n// Get the tokenId of the minted PKP\nconst tokenId = mintTxReceipt.events[0].topics[1];\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in client-side applications\nDESCRIPTION: Code example for connecting to the Habanero network in a browser environment, showing the initialization and connection process.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient({\n  litNetwork: 'habanero',\n  checkNodeAttestation: true \n});\n\nawait client.connect();\n```\n\n----------------------------------------\n\nTITLE: Integrating Lit Protocol with Stytch Authentication\nDESCRIPTION: Sets up Lit Protocol integration including LitRelay, StytchOtpProvider, and LitNodeClient to calculate public keys from authenticated sessions. Requires Lit Protocol node client configuration and relay setup.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitRelay, getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\nimport { StytchOtpProvider } from '@lit-protocol/providers';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize StytchOtp provider\nconst stytchProvider = new StytchOtpProvider({ relay, litNodeClient });\n\nconst authMethod = await stytchProvider.authenticate({\n  accessToken: sessionStatus.session_jwt \n});\n\nconst keyId = await getAuthIdByAuthMethod(authMethod);\nconst pubkey = session.litNodeClient.computePubkey(keyId);\n\nconsole.log(\"pkp public key: \", pubkey);\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Logging for Lit Node Client\nDESCRIPTION: Example of how to configure the LitNodeClient by passing options like disabling debug logging. Additional configuration options are available in the API documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient({debug: false})\n```\n\n----------------------------------------\n\nTITLE: Storing Encrypted Key Metadata with Lit Protocol SDK\nDESCRIPTION: Interface definition for the storeEncryptedKey function, which stores an encrypted private key and its metadata to the wrapped keys backend service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function storeEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    ciphertext: string;\n    dataToEncryptHash: string;\n    publicKey: string;\n    keyType: string;\n    memo: string;\n  }\n): Promise<{\n    id: string;\n    pkpAddress: string;\n}>\n```\n\n----------------------------------------\n\nTITLE: Granting Decryption Capability to Access Control Condition in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a session capability object and grant decryption capability to a specific access control condition. It uses the newSessionCapabilityObject and LitAccessControlConditionResource classes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/capability-objects.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('someResource');\n\n// Add the capability to decrypt from the access control condition referred to by the \n// lit resource.\nsessionCapabilityObject.addCapabilityForResource(\n    litResource,\n    LitAbility.AccessControlConditionDecryption\n);\n```\n\n----------------------------------------\n\nTITLE: Making POST Request to Add Users Endpoint (Datil-test)\nDESCRIPTION: Sends a POST request to the Datil-test network's add-users endpoint to add payees to a payer wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await fetch(\n    \"https://datil-test-relayer.getlit.dev/add-users\", \n    {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(USERS_YOU_WANT_TO_ADD),\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data in Lit Action using SIWS and Access Control Conditions\nDESCRIPTION: This code snippet shows how to decrypt data within a Lit Action using the authenticated SIWS message and Access Control Conditions. It sends a decryption request to the Lit Network and combines the decryption shares.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/siws-encryption.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst decryptedData = await Lit.Actions.decryptAndCombine({\n    // solRpcConditions are the above Access Control Conditions\n    accessControlConditions: solRpcConditions,\n    ciphertext,\n    dataToEncryptHash,\n    authSig: {\n        sig: ethers.utils\n            .hexlify(ethers.utils.base58.decode(_siwsObject.signature))\n            .slice(2),\n        derivedVia: \"solana.signMessage\",\n        signedMessage: siwsMessage,\n        address: siwsInput.address,\n    },\n    chain: \"solana\",\n});\n\nreturn LitActions.setResponse({ response: decryptedData });\n```\n\n----------------------------------------\n\nTITLE: Checking POAP Access by Name\nDESCRIPTION: Implementation for verifying if a user possesses a POAP with a specific name. It checks both xDai and Ethereum chains using an OR operator. The example checks for 'Burning Man 2021' using a 'contains' comparator.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/poap.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"xdai\",\n    method: \"tokenURI\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"Burning Man 2021\",\n    },\n  },\n  {\"operator\": \"or\"},\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"ethereum\",\n    method: \"tokenURI\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"Burning Man 2021\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: JWT Verification with Lit Protocol\nDESCRIPTION: Example demonstrating JWT verification process including signature verification and access control condition validation. The code verifies both the JWT signature and matches the access control conditions against statically declared conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/jwt-auth.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt =\n  \"eyJhbGciOiJCTFMxMi0zODEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJMSVQiLCJzdWIiOiIweGRiZDM2MGYzMDA5N2ZiNmQ5MzhkY2M4YjdiNjI4NTRiMzYxNjBiNDUiLCJjaGFpbiI6ImZhbnRvbSIsImlhdCI6MTYyODAzMTM1OCwiZXhwIjoxNjI4MDc0NTU4LCJiYXNlVXJsIjoiaHR0cHM6Ly9teS1keW5hbWljLWNvbnRlbnQtc2VydmVyLmNvbSIsInBhdGgiOiIvYV9wYXRoLmh0bWwiLCJvcmdJZCI6IiJ9.lX_aBSgGVYWd2FL6elRHoPJ2nab0IkmmX600cwZPCyK_SazZ-pzBUGDDQ0clthPVAtoS7roHg14xpEJlcSJUZBA7VTlPiDCOrkie_Hmulj765qS44t3kxAYduLhNQ-VN\";\nconst { verified, header, payload } = LitJsSdk.verifyJwt({\n    jwt, \n    publicKey: litNodeClient.networkPubKey,\n});\n\n// Statically declare the access control conditions that gate this web page.\nconst accessControlConditionsForProtectedPath1: MultipleAccessControlConditions = {\n  accessControlConditions: [{\n    chain: 'polygon',\n    contractAddress: '',\n    method: '',\n    parameters: [':userAddress'],\n    returnValueTest: {\n      comparator: '=',\n      value: MY_OWN_WALLET_ADDRESS,\n    },\n    standardContractType: '',\n  }]\n};\n\n// Verify the access control conditions in the JWT claims are as expected.\nconst expectedAccessControlConditionsHash = (await litNodeClient.getHashedAccessControlConditions(accessControlConditionsForProtectedPath1))!.toString();\nconst actualAccessControlConditionsHash = (await litNodeClient.getHashedAccessControlConditions(payload))!.toString();\nif (expectedAccessControlConditionsHash !== actualAccessControlConditionsHash) {\n  // Reject this request!\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete LitContracts Usage Example\nDESCRIPTION: Comprehensive example showing initialization and various contract interactions including minting PKP tokens and managing permissions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Instantiate the LitContracts class\nconst litContracts = new LitContracts(\n    signer: \"<your - rpc signer>\" // can be an instance of `PkpEthersWallet` or a different signer of your choosing\n);\n\n// Connect to the blockchain\nawait litContracts.connect();\n\n// Mint a new PKP token\nconst mintResult = await litContracts.pkpNftContractUtils.write.mint();\n\n// Check if an address is permitted for a PKP token\nconst isPermitted = await litContracts.pkpPermissionsContractUtils.read.isPermittedAddress(tokenId, address);\n\n// Add a permitted action to a PKP token\nconst tx = await litContracts.pkpPermissionsContractUtils.write.addPermittedAction(pkpId, ipfsId);\n\n// mint a new pkp with specific auth methods, ipfsIds, and addresses.\nconst tx = await litContracts.pkpHelperContractUtils.write.mintNextAddAuthMethods({\n    keyType,\n    permittedAuthMethodTypes,\n    permittedAuthMethodIds,\n    permittedAuthMethodPubkeys,\n    permittedAuthMethodScopes,\n    addPkpEthAddressAsPermittedAddress,\n    sendPkpToItself\n});\n\nconst tx = await litContracts.pkpHelperContractUtils.write.claimAndmintNextAndAddAuthMethods({\n    keyType;\n    derivedKeyId;\n    signatures;\n},\n{\n    keyType,\n    permittedAuthMethodTypes,\n    permittedAuthMethodIds,\n    permittedAuthMethodPubkeys,\n    permittedAuthMethodScopes,\n    addPkpEthAddressAsPermittedAddress,\n    sendPkpToItself\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Metaplex Collection NFT Ownership in Solana\nDESCRIPTION: Validates if a user owns one or more NFTs in a specified Metaplex collection using a custom Lit Protocol RPC call balanceOfMetaplexCollection.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/sol-rpc-conditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"balanceOfMetaplexCollection\",\n    params: [\"FfyafED6kiJUFwEhogyTRQHiL6NguqNg9xcdeoyyJs33\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data\nDESCRIPTION: Process of reading and decrypting data from Ceramic using the stored streamID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = litCeramicIntegration.readAndDecrypt(streamID).then(\n  (value) =>\n    console.log(value)\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n(document.getElementById('decryption').innerText = value)\n```\n\n----------------------------------------\n\nTITLE: PKP Authentication with Web3 Provider\nDESCRIPTION: Implementation of PKP authentication using a Web3 provider (like MetaMask) for browser-based wallet authentication. Includes setup for Lit Protocol network connection and relay configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-contracts.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { EthWalletProvider } from '@lit-protocol/providers';\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE, PROVIDER_TYPE } from '@lit-protocol/constants';\nimport { Wallet } from 'ethers';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true\n})\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\nconst ethWalletProvider = new EthWalletProvider({ relay: litRelay, litNodeClient });\n\nconst authMethod = await authProvider.authenticate({chain: \"ethereum\"});\n\n// -- setting scope for the auth method\n// <https://developer.litprotocol.com/v3/sdk/wallets/auth-methods/#auth-method-scopes>\nconst options = {\n  permittedAuthMethodScopes: [[AUTH_METHOD_SCOPE.SignAnything]],\n};\n\nconst mintTx = await litRelay.mintPKPWithAuthMethods([authMethod], options);\n```\n\n----------------------------------------\n\nTITLE: PKP Bitcoin Transaction Signing with Lit Actions\nDESCRIPTION: Lit Action code that performs ECDSA signing of Bitcoin transaction data using a PKP. The action signs the data in toSign variable and returns an ECDSA signature named 'btcSignature'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// @ts-nocheck\n\nconst _litActionCode = async () => {\n  try {\n    const sigShare = await LitActions.signEcdsa({ toSign, publicKey, sigName: 'btcSignature' });\n    Lit.Actions.setResponse({ response: 'true' });\n  } catch (error) {\n    Lit.Actions.setResponse({ response: error.message });\n  }\n};\n\nexport const litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: Updating Conditions for Static Content in Lit Protocol\nDESCRIPTION: This code snippet shows how to update conditions for static content in Lit Protocol. It creates new access control conditions and uses the saveEncryptionKey method, passing the encryptedSymmetricKey instead of a symmetricKey to update the existing condition.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/updateableConditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst newAccessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain,\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n\nconst newEncryptedSymmetricKey = await litNodeClient.saveEncryptionKey({\n  accessControlConditions: newAccessControlConditions,\n  encryptedSymmetricKey,\n  authSig,\n  chain,\n  permanent: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Key Claiming with LitNodeClient\nDESCRIPTION: Demonstrates how to claim a key using the LitNodeClient with default ClaimProcessor implementation. Connects to the datil-dev network and claims a key ID mapped to a provided auth method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new LitNodeClient({\n\tlitNetwork: \"datil-dev\",\n\tdebug: false\n});\nawait client.connect();\n\nlet res = await client.claimKeyId({\n      authMethod, // provide an auth method to claim a key Identifier mapped to the given auth method\n});\n\nconsole.log(\"mint tx hash: \", res.mintTx);\nconsole.log(\"pkp public key: \", res.pubkey);\n```\n\n----------------------------------------\n\nTITLE: Checking ERC721 Collection Token Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses any token from an ERC721 collection. It uses the balanceOf method of the ERC721 contract to verify if the user's balance is greater than zero.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0xA80617371A5f511Bf4c1dDf822E6040acaa63e71',\n    standardContractType: 'ERC721',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Checking ERC1155 Token Batch Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses at least one ERC1155 token from a batch of token ids. It uses the balanceOfBatch method of the ERC1155 contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x10daa9f4c0f985430fde4959adb2c791ef2ccf83',\n    standardContractType: 'ERC1155',\n    chain,\n    method: 'balanceOfBatch',\n    parameters: [\n      ':userAddress,:userAddress,:userAddress,:userAddress',\n      '1,2,10003,10004'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Instantiating a LitNodeClient in TypeScript\nDESCRIPTION: This code snippet creates and connects a LitNodeClient instance to the 'datil-dev' Lit network. This client is used for communicating with the Lit network and Wrapped Keys service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethers Signer\nDESCRIPTION: TypeScript code for instantiating an Ethers.js signer using a private key from environment variables. Connects to the Lit Protocol RPC endpoint.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather-based Access Control with Lit Action in JavaScript\nDESCRIPTION: This Lit Action code fetches weather data from an API and returns true if the temperature is below a specified maximum. It's designed to be used as a condition for decrypting a document only when it's cold outside.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/lit-action-conditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst go = async (maxTemp) => {\n  const url = \"https://api.weather.gov/gridpoints/LWX/97,71/forecast\";\n  try {\n    const response = await fetch(url).then((res) => res.json());\n    const nearestForecast = response.properties.periods[0];\n    const temp = nearestForecast.temperature;\n    return temp < parseInt(maxTemp);\n  } catch (e) {\n    console.log(e);\n  }\n  return false;\n};\n```\n\n----------------------------------------\n\nTITLE: PKP Authentication Method Types\nDESCRIPTION: Enumeration of supported authentication method types in the PKPPermissions contract, including their type numbers and descriptions\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Auth Method Name | Auth Method Type Number | Description |\n| ---------------- | ----------------------- | ----------- |\n| NULLMETHOD | 0 | Don't use this one, it's just a placeholder |\n| ADDRESS | 1 | An Ethereum address. As long as the user presents an AuthSig with this address, they can sign using the PKP. |\n| ACTION | 2 | A Lit Action. This is the IPFS CID of the Javascript that is your Lit Action, base58 decoded. |\n| WEBAUTHN | 3 | A WebAuthn Public Key. |\n| DISCORD | 4 | Discord Oauth Login |\n| GOOGLE | 5 | Google Oauth Login. |\n| GOOGLE_JWT | 6 | Google Oauth Login with JWT. |\n| One Time Password (OTP) | 7 | Email / SMS Login with JWT verification. |\n```\n\n----------------------------------------\n\nTITLE: Generating Controller Session Signatures for Lit Protocol\nDESCRIPTION: Sets up the Lit Node Client, defines resource abilities, and generates controller session signatures for authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClientNodeJs } from \"@lit-protocol/lit-node-client-nodejs\";\nimport { LIT_ABILITY, LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClientNodeJs({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n})\nawait litNodeClient.connect();\n \nconst resourceAbilities = [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.PKPSigning,\n    },\n];\n \nconst sessionKeyPair = litNodeClient.getSessionKey();\n \nconst authNeededCallback = async (params: AuthCallbackParams) => {\n    const response = await litNodeClient.signSessionKey({\n        sessionKey: sessionKeyPair,\n        statement: params.statement,\n        authMethods: [authMethod],\n        pkpPublicKey: pkp[pkp.length - 1].publicKey,\n        expiration: params.expiration,\n        resources: params.resources,\n        chainId: 1,\n    });\n    return response.authSig;\n};\n \n// Not needed when passing authContext to PKPEthersWallet\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString(),\n    resourceAbilityRequests: resourceAbilities,\n    sessionKey: sessionKeyPair,\n    authNeededCallback\t\n}).catch((err) => {\n    console.log(\"error while attempting to access session signatures: \", err)\n    throw err;\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient for Lit Protocol\nDESCRIPTION: Code to instantiate and connect to a LitNodeClient on the Datil test network. This client will be used to create the capacity delegation authorization signature.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/delegating-credit.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlitNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilTest,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Generating Signed Ethereum Transaction with Lit Protocol in JavaScript\nDESCRIPTION: This code demonstrates the process of generating a signed Ethereum transaction using Lit Protocol's SDK. It connects to Lit nodes, executes a Lit Action to sign a transaction, and then processes the resulting signature. The code also includes steps for recovering the public key and address from the signature.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/workingWithActions/signingTx.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\nimport fs from \"fs\";\nimport { serialize, recoverAddress } from \"@ethersproject/transactions\";\nimport {\n  hexlify,\n  splitSignature,\n  hexZeroPad,\n  joinSignature,\n} from \"@ethersproject/bytes\";\nimport { recoverPublicKey, computePublicKey } from \"@ethersproject/signing-key\";\n\n// this code will be run on the node\nconst litActionCode = fs.readFileSync(\"./build/signTxnTest.js\");\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst go = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    minNodeCount: 6,\n    debug: true,\n    litNetwork: \"serrano\",\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    jsParams: {},\n  });\n  console.log(\"results\", results);\n  const { signatures, response } = results;\n  console.log(\"response\", response);\n  const sig = signatures.sig1;\n  const { dataSigned } = sig;\n  const encodedSig = joinSignature({\n    r: \"0x\" + sig.r,\n    s: \"0x\" + sig.s,\n    v: sig.recid,\n  });\n\n  const { txParams } = response;\n\n  console.log(\"encodedSig\", encodedSig);\n  console.log(\"sig length in bytes: \", encodedSig.substring(2).length / 2);\n  console.log(\"dataSigned\", dataSigned);\n  const splitSig = splitSignature(encodedSig);\n  console.log(\"splitSig\", splitSig);\n\n  const recoveredPubkey = recoverPublicKey(dataSigned, encodedSig);\n  console.log(\"uncompressed recoveredPubkey\", recoveredPubkey);\n  const compressedRecoveredPubkey = computePublicKey(recoveredPubkey, true);\n  console.log(\"compressed recoveredPubkey\", compressedRecoveredPubkey);\n  const recoveredAddress = recoverAddress(dataSigned, encodedSig);\n  console.log(\"recoveredAddress\", recoveredAddress);\n\n  // const txParams = {\n  //   nonce: \"0x0\",\n  //   gasPrice: \"0x2e90edd000\", // 200 gwei\n  //   gasLimit: \"0x\" + (30000).toString(16), // 30k gas limit should be enough.  only need 21k to send.\n  //   to: \"0x50e2dac5e78B5905CB09495547452cEE64426db2\",\n  //   value: \"0x\" + (10000).toString(16),\n  //   chainId,\n  // };\n\n  const txn = serialize(txParams, encodedSig);\n\n  console.log(\"txn\", txn);\n};\n\ngo();\n```\n\n----------------------------------------\n\nTITLE: Setting Auth Method Scopes for PKPs in JavaScript\nDESCRIPTION: This code snippet shows how to set the 'sign anything' scope for an auth method on a Programmable Key Pair (PKP) using the Lit Protocol SDK. It uses the PKP Permissions contract to add the permitted auth method scope.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/overview.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE } from '@lit-protocol/constants';\n\nconst authMethod = {\n  authMethodType: xx,\n  accessToken: xxx,\n};\n\nconst authId = await getAuthIdByAuthMethod(authMethod);\n\nconst setScopeTx =\n  await contractClient.pkpPermissionsContract.write.addPermittedAuthMethodScope(\n    tokenId,\n    AUTH_METHOD_TYPE.EthWallet,\n    authId,\n    AUTH_METHOD_SCOPE.SignAnything\n  );\n\nawait setScopeTx.wait();\n```\n\n----------------------------------------\n\nTITLE: Configuring LitNodeClient with LocalStorage in Node.js Environment\nDESCRIPTION: Example showing how to configure the LitNodeClient with a custom storage provider in a Node.js environment using the node-localstorage package. This ensures session data persistence across executions instead of generating new session keypairs each time.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/intro.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LocalStorage } from \"node-localstorage\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlitNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    // This storageProvider object can be omitted if executing in a browser\n    storageProvider: {\n        provider: new LocalStorage(\"./lit_storage.db\"),\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Private Key with Lit Protocol in TypeScript\nDESCRIPTION: This code snippet demonstrates how to generate a Solana private key using Lit Protocol's wrapped keys API. It uses the previously generated PKP session signatures and specifies the network as 'solana'. The function returns the PKP address and the generated public key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { generatePrivateKey } = api;\n\nconst { pkpAddress, generatedPublicKey } = await generatePrivateKey({\n    pkpSessionSigs,\n    network: 'solana',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n    litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network and Initializing Ethereum Wallet\nDESCRIPTION: TypeScript code for initializing a LitNodeClient instance to connect to the Lit network and setting up an Ethereum wallet for session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { encryptString, decryptToString } from \"lit-protocol/encryption\";\nimport { LIT_NETWORK, LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: false\n});\nawait litNodeClient.connect();\n\nconst ethersWallet = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY!, // Replace with your private key\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Authenticating WebAuthn Credential with Lit Protocol\nDESCRIPTION: Shows how to authenticate an existing WebAuthn credential to generate an AuthMethod object that can be used for subsequent PKP operations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/web-authn.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function authenticateWithWebAuthn() {\n  const authMethod = await webAuthnProvider.authenticate();\n  return authMethod;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Transactions from Latest Ethereum Block Using a Single Node\nDESCRIPTION: This code snippet shows how to use the runOnce function in combination with getRpcUrl to fetch transaction data from the latest Ethereum block using only a single node. The result is then broadcast to all clients.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/get-rpc-url.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ncode = `(async () => {\n    let res = await Lit.Actions.runOnce({ waitForResponse: true, name: \"txnSender\" }, async () => {\n        const rpcUrl = await Lit.Actions.getRpcUrl({ chain: \"ethereum\" });\n        const blockByNumber = await provider.send(\"eth_getBlockByNumber\", [\"latest\", false]);\n        const transactions = blockByNumber.transactions;\n        return res;\n    });\n    // get the broadcast result from the single node which executed the block query and return it from all clients.\n    Lit.Actions.setResponse(res);\n})();`;\nconst client = new LitNodeClient({\nlitNetwork: \"datil-dev\"\n});\nawait client.connect();\n\nconst res = await client.executeJs({\n    code,\n    sessionSigs: {} // your session\n    jsParams: {}\n});\nconsole.log(\"transactions in latest block from all nodes: \", res);\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data with Crypto Package in JavaScript\nDESCRIPTION: Shows how to decrypt data using the Crypto package in Lit Protocol V3. It uses the 'verifyAndDecryptWithSignatureShares' function, which takes the public key, identity parameter, ciphertext, and signature shares to decrypt the data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/changes.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst ciphertext =\n  'l9a/01WDJB/euKxtbWcuQ8ez/c9eZ+jQryTHZVLN0kfd7XHoLs6FeWUVmk89ovQGkQJnnFDKjq6kgJxvIIrxXd9DaGuRBozLdA1G9Nk413YhTEqsENuHU0nSa4i6F912KltE15sbWKpDfPnZF6CA2UKBAw==';\nconst signatureShares = [\n  '01b2b44a0bf7184f19efacad98e213818edd3f8909dd798129ef169b877d68d77ba630005609f48b80203717d82092a45b06a9de0e61a97b2672b38b31f9ae43e64383d0375a51c75db8972613cc6b099b95c189fd8549ed973ee94b08749f4cac',\n  '02a8343d5602f523286c4c59356fdcfc51953290495d98cb91a56b59bd1a837ea969cc521382164e85787128ce7f944de303d8e0b5fc4becede0c894bec1adc490fdc133939cca70fb3f504b9bf7b156527b681d9f0619828cd8050c819e46fdb1',\n  '03b1594ab0cb56f47437b3720dc181661481ca0e36078b79c9a4acc50042f076bf66b68fbd12a1d55021a668555f0eed0a08dfe74455f557b30f1a9c32435a81479ca8843f5b74b176a8d10c5845a84213441eaaaf2ba57e32581584393541c5aa',\n];\n\nconst plaintext = verifyAndDecryptWithSignatureShares(\n  publicKey,\n  identityParam,\n  ciphertext,\n  signatureShares.map((s) => ({\n    ProofOfPossession: s,\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Custom Key Claiming with Contracts SDK\nDESCRIPTION: Shows how to claim a key using a custom ClaimProcessor with the contracts-sdk. Uses ClientClaimProcessor to handle the claim registration through smart contracts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\nimport { ClaimRequest, ClaimResult, ClientClaimProcessor } from \"@lit-protocol/types\"\nimport { LIT_RPC, LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst client = new LitNodeClient({\n\tlitNetwork: LIT_NETWORK.DatilDev,\n\tdebug: false\n});\nawait client.connect();\nlet claimReq: ClaimRequest<ClientClaimProcessor> = {\n      authMethod, // provide an auth method to claim a key Identifier mapped to the given auth method\n      signer: new ethers.Wallet(\"<your private key>\", new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)),\n      mintCallback: async (claimRes: ClaimResult<ClientClaimProcessor>) => {\n          const litContracts = new LitContracts({ signer: claimRes.signer });\n          await litContracts.connect();\n          let tokenId = await litContracts.pkpNftContractUtils.write.claimAndMint(claimRes.derivedKeyId, claimRes.signatures);\n          return tokenId.tokenId\n      }\n};\nlet res = await client.claimKeyId(claimReq);\n\nconsole.log(\"mint tx hash: \", res.mintTx);\nconsole.log(\"pkp public key: \", res.pubkey);\n```\n\n----------------------------------------\n\nTITLE: Removing an Auth Method from PKP in Lit Protocol\nDESCRIPTION: This snippet demonstrates how to remove an authentication method from a Programmable Key Pair (PKP) using the PKPPermissions contract in Lit Protocol. It includes parameters for specifying the auth method to remove and gas settings.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.removePermittedAuthMethod(\n    \"<The token ID of your PKP>\",\n    \"<The auth method type\",\n    \"<The auth method ID>\",\n    { gasPrice: utils.parseUnits(\"0.001\", \"gwei\"), gasLimit: 400000 }\n  );\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Lit Action Code\nDESCRIPTION: Example of writing an inline Lit Action that checks a magic number and returns a response based on the comparison.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/quick-start.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst _litActionCode = async () => {\n  if (magicNumber >= 42) {\n      LitActions.setResponse({ response:\"The number is greater than or equal to 42!\" });\n  } else {\n      LitActions.setResponse({ response: \"The number is less than 42!\" });\n  }\n}\n\nconst litActionCode = `(${_litActionCode.toString()})();`;\n```\n\n----------------------------------------\n\nTITLE: PKP Minting Process\nDESCRIPTION: Minting a Programmable Key Pair (PKP) using Google authentication\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitRelay } from \"@lit-protocol/lit-auth-client\";\n\nconst mintWithGoogle = async (authMethod) => {\n  const litRelay = new LitRelay({\n    relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n    relayApiKey: 'test-api-key',\n  });\n  \n  const pkp = await litRelay.mintPKPWithAuthMethods([authMethod], {\n    addPkpEthAddressAsPermittedAddress: true\n  });\n  console.log(\"Fetched PKP\", pkp);\n  return pkp;\n};\n\nconst pkp = await mintWithGoogle(authMethod);\nconsole.log(\"Minted PKP ✔️\");\n```\n\n----------------------------------------\n\nTITLE: Importing Moved Functions in JavaScript\nDESCRIPTION: Updated import statements for functions and interfaces moved from @lit-protocol/encryption to @lit-protocol/misc.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  isTokenOperator,\n  isValidBooleanExpression,\n  safeParams,\n  AccessControlConditionsValidatorProps,\n  AuthMaterialValidatorProps,\n  ParamsValidatorsType,\n} from '@lit-protocol/misc';\n```\n\n----------------------------------------\n\nTITLE: Encrypting and Minting NFT with Lit SDK in JavaScript\nDESCRIPTION: This snippet demonstrates how to encrypt NFT description metadata using Lit SDK and mint an NFT with the encrypted data. It includes steps to convert the encrypted Blob to a base64 string for passing to the smart contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/frontend.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst mintLitNft = async (name, imageUrl, description) => {\n  const { encryptedString, encryptedSymmetricKey } = await lit.encryptText(\n    description\n  );\n\n  // Convert blob to base64 to pass as a string to Solidity\n  const blobToBase64 = (blob) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(blob);\n    return new Promise((resolve) => {\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n    });\n  };\n  const encryptedDescriptionString = await blobToBase64(encryptedString);\n\n  let transaction = await litNftContract.mintLitNft(\n    name,\n    imageUrl,\n    encryptedDescriptionString,\n    encryptedSymmetricKey\n  );\n  await transaction.wait();\n\n  // You may want to fetch & set all the NFTs after minting a new one\n  // const _nfts = await litNftContract.fetchNfts();\n  // setNFTs(_nfts);\n};\n```\n\n----------------------------------------\n\nTITLE: Server-side AuthSig Generation\nDESCRIPTION: Complete example of generating an AuthSig on the server-side using ethers.js and SIWE (Sign in with Ethereum).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/authSig.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst LitJsSdk = require(\"@lit-protocol/lit-node-client-nodejs\");\nconst { ethers } = require(\"ethers\");\nconst siwe = require(\"siwe\");\n\nasync function main() {\n  // Initialize LitNodeClient\n  const litNodeClient = new LitJsSdk.LitNodeClientNodeJs();\n  await litNodeClient.connect();\n\n  // Initialize the signer\n  const wallet = new ethers.Wallet(\"<Your private key>\");\n  const address = ethers.utils.getAddress(await wallet.getAddress());\n\n  // Craft the SIWE message\n  const domain = \"localhost\";\n  const origin = \"https://localhost/login\";\n  const statement = \"This is a test statement.  You can put anything you want here.\";\n  const siweMessage = new siwe.SiweMessage({\n    domain,\n    address: address,\n    statement,\n    uri: origin,\n    version: \"1\",\n    chainId: \"1\",\n  });\n  const messageToSign = siweMessage.prepareMessage();\n\n  // Sign the message and format the authSig\n  const signature = await wallet.signMessage(messageToSign);\n\n  const authSig = {\n    sig: signature,\n    derivedVia: \"web3.eth.personal.sign\",\n    signedMessage: messageToSign,\n    address: address,\n  };\n\n  console.log(authSig);\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Wrapped Key Metadata using listEncryptedKeyMetadata\nDESCRIPTION: This code snippet shows how to use the listEncryptedKeyMetadata function from the Wrapped Keys SDK to fetch metadata for all Wrapped Keys associated with a PKP. It uses the previously generated PKP Session Signatures for authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { listEncryptedKeyMetadata } = api;\n\nconst wrappedKeyMetadatas = await listEncryptedKeyMetadata({\n    pkpSessionSigs,\n    litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Checking POAP Possession by Name in Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to create access control conditions that check if a user holds a POAP with a specific name (\"Burning Man 2021\"). The conditions check both xDai and Ethereum chains using the \"contains\" comparator, as POAPs can exist on either chain. Both chains are connected with an \"or\" operator to grant access if the POAP exists on either chain.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/poap.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"xdai\",\n    method: \"tokenURI\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"Burning Man 2021\",\n    },\n  },\n  {\"operator\": \"or\"},\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"ethereum\",\n    method: \"tokenURI\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"Burning Man 2021\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Deriving Bitcoin Address from PKP Public Key using BitcoinJS\nDESCRIPTION: This code snippet shows how to derive a Bitcoin address from a PKP public key using the bitcoinjs-lib library. It handles the case where the public key starts with '0x' and creates a p2pkh (pay-to-pubkey-hash) address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/support/faq.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as bitcoinjs from \"bitcoinjs-lib\";\n\nif (publicKey.startsWith(\"0x\")) {\n  publicKey = publicKey.slice(2);\n}\npubkeyBuffer = Buffer.from(publicKey, \"hex\");\n\n// get the btc address from the public key\nconst pkpBTCAddress = bitcoinjs.payments.p2pkh({\n  pubkey: pubkeyBuffer,\n}).address;\n```\n\n----------------------------------------\n\nTITLE: Checking POAP Possession by Event ID in Lit Protocol\nDESCRIPTION: This code snippet shows how to create access control conditions that verify if a user holds a POAP with a specific event ID (\"37582\"). The conditions check both xDai and Ethereum chains using the \"=\" comparator for exact matching. Both chains are connected with an \"or\" operator to grant access if the POAP exists on either chain.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/poap.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"xdai\",\n    method: \"eventId\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"37582\",\n    },\n  },\n  {\n    operator: \"or\",\n  },\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"ethereum\",\n    method: \"eventId\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"37582\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Encrypting String Content\nDESCRIPTION: Encrypting a string and obtaining symmetric key for later decryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { encryptedString, symmetricKey } = await LitJsSdk.encryptString(\n  \"this is a secret message\"\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Capacity Credits NFT Delegation\nDESCRIPTION: This snippet demonstrates how to delegate access to your Capacity Credits NFT to other wallets. It specifies the number of uses, the owner wallet, the NFT token ID, and the addresses that will receive delegated access.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/capacity-credits.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilTest,\n    checkNodeAttestation: true,\n});\n\nawait litNodeClient.connect();\n\nconst { capacityDelegationAuthSig } =\n  await litNodeClient.createCapacityDelegationAuthSig({\n    uses: '1',\n    dAppOwnerWallet: walletWithCapacityCredit,\n    capacityTokenId: capacityTokenIdStr,\n    delegateeAddresses: [secondWalletPKPInfo.ethAddress],\n  });\n```\n\n----------------------------------------\n\nTITLE: Checking DAO Membership in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user is a member of a MolochDAOv2.1 or DAOHaus DAO. It verifies membership and ensures the user is not jailed using the members method of the DAO contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x50D8EB685a9F262B13F28958aBc9670F06F819d9',\n    standardContractType: 'MolochDAOv2.1',\n    chain,\n    method: 'members',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: 'true'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data Using BLS SDK in Lit Protocol V3\nDESCRIPTION: Demonstrates how to decrypt data using the decrypt_with_signature_shares method after obtaining BLS network signature shares. This replaces the previous multi-step process in V2.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst privateData = blsSdk.decrypt_with_signature_shares(\n  ciphertext,\n  sigShares\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPEthersWallet for Lit Protocol Authentication\nDESCRIPTION: This snippet demonstrates how to initialize a PKPEthersWallet instance with authentication properties for use with Lit Protocol. It sets up the necessary parameters and callbacks for session-based authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LitActionResource } from '@lit-protocol/auth-helpers';\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport { LIT_RPC, LIT_NETWORK, LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// If you haven't done before, create a LitNodeClient instance\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n});\nawait litNodeClient.connect();\n\n// Prepare needed params for authContext\nconst resourceAbilities = [\n  {\n    resource: new LitActionResource(\"*\"),\n    ability: LIT_ABILITY.PKPSigning,\n  },\n];\n\nconst authNeededCallback = async (params: AuthCallbackParams) => {\n  const response = await litNodeClient.signSessionKey({\n    statement: params.statement,\n    authMethods: [authMethod],\n    expiration: params.expiration,\n    resources: params.resources,\n    chainId: 1,\n  });\n  return response.authSig;\n};\n\nconst pkpWallet = new PKPEthersWallet({\n  litNodeClient,\n  authContext: {\n    getSessionSigsProps: {\n      chain: 'ethereum',\n      expiration: new Date(Date.now() + 60_000 * 60).toISOString(),\n      resourceAbilityRequests: resourceAbilities,\n      authNeededCallback,\n    },\n  },\n  // controllerAuthSig: authSig,\n  // controllerSessionSigs: sessionSigs, // (deprecated)\n  pkpPubKey: \"<Your PKP public key>\",\n  rpc: LIT_RPC.CHRONICLE_YELLOWSTONE,\n});\nawait pkpWallet.init();\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions for Solana-based Encryption\nDESCRIPTION: This code snippet defines the Access Control Conditions used to encrypt data. It specifies conditions for a Solana public key and verifies the Lit Action's IPFS CID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/siws-encryption.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n      method: \"\",\n      params: [\":userAddress\"],\n      pdaParams: [],\n      pdaInterface: { offset: 0, fields: {} },\n      pdaKey: \"\",\n      chain: \"solana\",\n      returnValueTest: {\n        key: \"\",\n        comparator: \"=\",\n        // This address would be the Solana public key that is authorized\n        // to access the app, and you would replace it with the actual\n        // public key that you want to be authorized to decrypt the data.\n        value: address,\n      },\n    },\n    { operator: \"and\" },\n    {\n      method: \"\",\n      params: [\":currentActionIpfsId\"],\n      pdaParams: [],\n      pdaInterface: { offset: 0, fields: {} },\n      pdaKey: \"\",\n      chain: \"solana\",\n      returnValueTest: {\n        key: \"\",\n        comparator: \"=\",\n        // litActionCode is the stringified code for the SIWS Decrypt Lit Action\n        value: await calculateLitActionCodeCID(litActionCode),\n      },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Nested Boolean Logic in Lit Protocol Access Control\nDESCRIPTION: Advanced example demonstrating nested boolean conditions to check if a user is a DAO member AND either holds more than 0.00001 ETH OR owns 10+ ERC20 tokens.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/condition-types/boolean-logic.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    \"contractAddress\":\"0x50D8EB685a9F262B13F28958aBc9670F06F819d9\",\n    \"standardContractType\":\"MolochDAOv2.1\",\n    \"chain\",\n    \"method\":\"members\",\n    \"parameters\":[\n      \":userAddress\"\n    ],\n    \"returnValueTest\":{\n      \"comparator\":\"=\",\n      \"value\":\"true\"\n    }\n  },\n  {\n    \"operator\":\"and\"\n  },\n  [\n    {\n      \"contractAddress\":\"\",\n      \"standardContractType\":\"\",\n      \"chain\",\n      \"method\":\"eth_getBalance\",\n      \"parameters\":[\n        \":userAddress\",\n        \"latest\"\n      ],\n      \"returnValueTest\":{\n        \"comparator\":\">=\",\n        \"value\":\"10000000000000\"\n      }\n    },\n    {\n      \"operator\":\"or\"\n    },\n    {\n      \"contractAddress\":\"0xc0ad7861fe8848002a3d9530999dd29f6b6cae75\",\n      \"standardContractType\":\"ERC20\",\n      \"chain\",\n      \"method\":\"balanceOf\",\n      \"parameters\":[\n        \":userAddress\"\n      ],\n      \"returnValueTest\":{\n        \"comparator\":\">\",\n        \"value\":\"10\"\n      }\n    }\n  ]\n];\n```\n\n----------------------------------------\n\nTITLE: Checking ERC721 Token Ownership in JavaScript\nDESCRIPTION: This snippet defines an access control condition to verify if a user owns a specific ERC721 token (NFT). It uses the ownerOf method to check the ownership of a particular token id.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x89b597199dAc806Ceecfc091e56044D34E59985c',\n    standardContractType: 'ERC721',\n    chain,\n    method: 'ownerOf',\n    parameters: [\n      '3112'\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: ':userAddress'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Instantiating an Ethers Signer in TypeScript\nDESCRIPTION: This code snippet creates an Ethers signer using a private key from an environment variable. The signer is connected to the Lit Protocol RPC endpoint.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Signing Messages with Wrapped Key for EVM Networks\nDESCRIPTION: Implementation for signing messages using a wrapped key on EVM-based networks with Lit Protocol. Utilizes PKP session signatures and wrapped key ID to generate signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { importPrivateKey } = api;\n\nconst signature = await signMessageWithEncryptedKey({\n  pkpSessionSigs,\n  litNodeClient,\n  network: 'evm',\n  id: process.env.WRAPPED_KEY_ID,\n  messageToSign: \"The answer to the Universe is 42.\",\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Conditions for Dynamic Content in Lit Protocol\nDESCRIPTION: This snippet illustrates how to update conditions for dynamic content in Lit Protocol. It creates new access control conditions and uses the saveSigningCondition method, ensuring to pass the identical resourceId as when the condition was initially stored.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/updateableConditions.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst newAccessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain,\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n\nconst saved = await litNodeClient.saveSigningCondition({\n  accessControlConditions: newAccessControlConditions,\n  chain,\n  authSig,\n  resourceId,\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining Signed JWT from Lit Network\nDESCRIPTION: Request a signed JWT from the Lit network using the previously saved signing conditions, allowing access to the protected resource.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt = await litNodeClient.getSignedToken({\n  accessControlConditions,\n  chain,\n  authSig,\n  resourceId,\n});\n```\n\n----------------------------------------\n\nTITLE: Minting PKP with Auth Method and Scopes\nDESCRIPTION: Shows how to mint a PKP (Programmable Key Pair) with specific authentication methods and permitted scopes using the contracts-sdk.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE } from '@lit-protocol/constants';\n\nconst authMethod = {\n  authMethodType: AUTH_METHOD_TYPE.EthWallet,\n  accessToken: JSON.stringify(authSig),\n};\n\nconst mintInfo = await contractClient.mintWithAuth({\n  authMethod: authMethod,\n  scopes: [\n        // AUTH_METHOD_SCOPE.NoPermissions,\n        AUTH_METHOD_SCOPE.SignAnything, \n        AUTH_METHOD_SCOPE.PersonalSign\n    ],\n});\n\n// output:\n{\n  pkp: {\n      tokenId: string;\n      publicKey: string;\n      ethAddress: string;\n  };\n  tx: ethers.ContractReceipt;\n}\n```\n\n----------------------------------------\n\nTITLE: Using SIWE Parameters in Custom Contract Calls with Lit Protocol in JavaScript\nDESCRIPTION: This example demonstrates how to use Sign-In with Ethereum (SIWE) resource parameters in access control conditions. It shows creating an AuthSig with a SIWE param and using it in a custom contract call for token balance checking.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/custom-contract-calls.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n let tokenId = \"8\";\n// base64url encode the param\nlet encodedSiweResource = LitJsSdk.uint8arrayToString(\n  LitJsSdk.uint8arrayFromString(tokenId, \"utf8\"),\n  \"base64url\"\n);\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain,\n  resources: [`litParam:tokenId:${encodedSiweResource}`],\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \":litParam:tokenId\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures for Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to generate PKP session signatures using the LitNodeClient. It authenticates with an Ethereum wallet provider, sets up resource ability requests, and specifies an expiration time for the session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContracts Client\nDESCRIPTION: Code snippet to initialize a LitContracts client using an Ethereum Signer and connect to the Datil network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst contractClient = new LitContracts({\n  signer: wallet,\n  network: LIT_NETWORK.Datil,\n});\n\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Simple OR Logic in Lit Protocol Access Control\nDESCRIPTION: Example showing how to check if a user is either a DAO member OR holds more than 0.00001 ETH using the OR operator in access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/condition-types/boolean-logic.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"0x50D8EB685a9F262B13F28958aBc9670F06F819d9\",\n    standardContractType: \"MolochDAOv2.1\",\n    chain,\n    method: \"members\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\",\n    },\n  },\n  { operator: \"or\" },\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain,\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Encoding Arrays in Function Parameters for Custom Contract Calls in JavaScript\nDESCRIPTION: This snippet illustrates how to encode arrays in function parameters for custom contract calls. It demonstrates passing an array of bytes32 objects to a 'sumBytes32' function, removing the '0x' prefix from hex strings.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/custom-contract-calls.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0xc7BA08FB2546cA2198F6C69e5c4B15252D90A347\",\n    functionName: \"sumBytes32\",\n    functionParams: [\n      \"[0000000000000000000000000000000000000000000000000000000000000002,0000000000000000000000000000000000000000000000000000000000000003]\",\n    ],\n    functionAbi: {\n      name: \"sumBytes32\",\n      inputs: [{ internalType: \"bytes32[]\", name: \"vals\", type: \"bytes32[]\" }],\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      constant: true,\n      stateMutability: \"view\",\n    },\n    chain: \"xdai\",\n    returnValueTest: { key: \"\", comparator: \"=\", value: \"5\" },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Updating PKPWalletConnect Implementation\nDESCRIPTION: Example demonstrating the migration from old PKPWalletConnect methods to the new implementation using PKPEthersWallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n// Old way\nconst pkpWalletConnect = new PKPWalletConnect();\npkpWalletConnect.addPKPClient(pkpClient);\n\n// New way\nconst pkpWalletConnect = new PKPWalletConnect();\npkpWalletConnect.addPKPEthersWallet(pkpEthersWallet);\n```\n\n----------------------------------------\n\nTITLE: Initializing PKP Wallet for Ethereum Transactions\nDESCRIPTION: Creates and initializes a PKP (Programmable Key Pair) Wallet that can be used like a regular Ethers.js wallet for signing Ethereum transactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst pkpWallet = new PKPEthersWallet({\n  pkpPubKey: pkp[pkp.length - 1].publicKey,\n  rpc: \"<standard RPC URL for the chain you are using>\", // e.g. https://rpc.ankr.com/eth_goerli\n  litNodeClient,\n  authContext: {\n    getSessionSigsProps: {\n      chain: 'ethereum',\n      expiration: new Date(Date.now() + 60_000 * 60).toISOString(),\n      resourceAbilityRequests: resourceAbilities,\n      authNeededCallback,\n    },\n  },\n  // controllerSessionSigs: sessionSigs, // (deprecated) If you will be passing sessionSigs directly, do not pass authContext\n});\n\nconst pkpWallet = new PKPEthersWallet({\n  pkpPubKey: pkp[pkp.length - 1].publicKey,\n  litNodeClient,\n  authContext: {\n    getSessionSigsProps: {\n      chain: 'ethereum',\n      expiration: new Date(Date.now() + 60_000 * 60).toISOString(),\n      resourceAbilityRequests: resourceAbilities,\n      authNeededCallback,\n    },\n  },\n  // controllerSessionSigs: sessionSigs, // (deprecated) If you will be passing sessionSigs directly, do not pass authContext\n});\n \nawait pkpWallet.init();\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data Using Lit v2 SDK\nDESCRIPTION: Implementation of data decryption using Lit Protocol v2 SDK, including authentication and access control conditions for ethereum chain\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync decrypt(encryptedString, encryptedSymmetricKey) {\n  if (!this.litNodeClient) {\n    await this.connect();\n  }\n\n  const authSig = await LitJsSdk.checkAndSignAuthMessage({ chain: \"ethereum\" });\n  const accessControlConditions = [\n    {\n      contractAddress: \"\",\n      standardContractType: \"\",\n      chain: \"ethereum\",\n      method: \"eth_getBalance\",\n      parameters: [\":userAddress\", \"latest\"],\n      returnValueTest: {\n        comparator: \">=\",\n        value: \"1000000000000\", // 0.000001 ETH\n      },\n    },\n  ];\n\n  const symmetricKey = await this.litNodeClient.getEncryptionKey({\n    accessControlConditions,\n    toDecrypt: encryptedSymmetricKey,\n    chain: \"ethereum\",\n    authSig\n  });\n  const decryptedString = await LitJsSdk.decryptString(\n    encryptedString,\n    symmetricKey\n  );\n\n  return { decryptedString };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions for Lit Protocol in JavaScript\nDESCRIPTION: This snippet defines the access control conditions for a user to decrypt the encrypted string. It checks if the user has at least 0.1 MATIC in their wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/encryptDecrypt.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain,\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"100000000000000000\", // 0.1 MATIC\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Exporting Private Key Interface Definition\nDESCRIPTION: TypeScript interface definition for the exportPrivateKey function that exports a previously persisted private key from the wrapped keys service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function exportPrivateKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    network: 'evm' | 'solana'\n    id: string,\n  }\n): Promise<{\n    pkpAddress: string;\n    decryptedPrivateKey: string;\n    publicKey: string;\n    litNetwork: LIT_NETWORKS_KEYS;\n    keyType: 'K256' | 'ed25519';\n    memo: string;\n    id: string;\n}>\n```\n\n----------------------------------------\n\nTITLE: Minting Capacity Credits NFT with Rate Limit Configuration\nDESCRIPTION: This code shows how to mint a Capacity Credits NFT with specific rate limit configurations. The requestsPerKilosecond parameter sets the rate limit, while daysUntilUTCMidnightExpiration determines when the NFT will expire.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/capacity-credits.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// this identifier will be used in delegation requests. \nconst { capacityTokenIdStr } = await contractClient.mintCapacityCreditsNFT({\n  requestsPerKilosecond: 80,\n  // requestsPerDay: 14400,\n  // requestsPerSecond: 10,\n  daysUntilUTCMidnightExpiration: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures for PKP in Lit Protocol\nDESCRIPTION: TypeScript code to generate session signatures for a PKP, enabling the session to use the PKP for signing. This example uses a wildcard identifier for LitPKPResource, granting signing abilities to any PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-pkp-session-sigs.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport { LitPKPResource } from \"@lit-protocol/auth-helpers\";\n\nconst sessionSignatures = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: pkp.publicKey!,\n    capabilityAuthSigs: [capacityDelegationAuthSig],\n    authMethods: [authMethod],\n    resourceAbilityRequests: [\n        {\n            resource: new LitPKPResource(\"*\"),\n            ability: LIT_ABILITY.PKPSigning,\n        },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Specific Token Account Balance in Solana\nDESCRIPTION: Checks the balance of a specific token account using getTokenAccountBalance RPC call. Useful when the token account address is known.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"getTokenAccountBalance\",\n    params: [\"E7aAccig7X3X4pSWjf1eqqUJkV3EbzG6DrtyM2gbuuhH\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"amount\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: PKP Mint/Grant/Burn Contract Reference\nDESCRIPTION: Reference to the MintGrantBurn function in the PKPNFT smart contract that handles the atomic minting, granting access, and burning of PKPs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/pkpsAndActions.md#2025-04-18_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// Reference: https://github.com/LIT-Protocol/LitNodeContracts/blob/main/contracts/PKPNFT.sol#L157\n```\n\n----------------------------------------\n\nTITLE: Implementing Google OAuth Login with LitRelay\nDESCRIPTION: Setup and initialization of LitRelay with Google OAuth provider for authentication. Includes configuration of LitNodeClient and LitRelay with API key setup.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { GoogleProvider } from '@lit-protocol/providers';\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE, PROVIDER_TYPE } from '@lit-protocol/constants';\nimport { Wallet } from 'ethers';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true\n})\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize Google provider\nconst googleProvider = new GoogleProvider({ relay: litRelay, litNodeClient });\n\nawait googleProvider.signIn();\n```\n\n----------------------------------------\n\nTITLE: Nested Boolean Logic in Lit Protocol Access Control\nDESCRIPTION: Advanced example demonstrating nested boolean conditions that combine DAO membership AND (ETH balance OR ERC20 token balance). Requires user to be a DAO member and either hold sufficient ETH or ERC20 tokens.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/booleanLogic.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    \"contractAddress\":\"0x50D8EB685a9F262B13F28958aBc9670F06F819d9\",\n    \"standardContractType\":\"MolochDAOv2.1\",\n    \"chain\",\n    \"method\":\"members\",\n    \"parameters\":[\n      \":userAddress\"\n    ],\n    \"returnValueTest\":{\n      \"comparator\":\"=\",\n      \"value\":\"true\"\n    }\n  },\n  {\n    \"operator\":\"and\"\n  },\n  [\n    {\n      \"contractAddress\":\"\",\n      \"standardContractType\":\"\",\n      \"chain\",\n      \"method\":\"eth_getBalance\",\n      \"parameters\":[\n        \":userAddress\",\n        \"latest\"\n      ],\n      \"returnValueTest\":{\n        \"comparator\":\">=\",\n        \"value\":\"10000000000000\"\n      }\n    },\n    {\n      \"operator\":\"or\"\n    },\n    {\n      \"contractAddress\":\"0xc0ad7861fe8848002a3d9530999dd29f6b6cae75\",\n      \"standardContractType\":\"ERC20\",\n      \"chain\",\n      \"method\":\"balanceOf\",\n      \"parameters\":[\n        \":userAddress\"\n      ],\n      \"returnValueTest\":{\n        \"comparator\":\">\",\n        \"value\":\"10\"\n      }\n    }\n  ]\n];\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Authentication with Lit Protocol\nDESCRIPTION: Demonstrates how to set up custom authentication using EthWalletProvider and execute custom Javascript code on Lit Action. The code includes setting up auth methods, resource ability requests, and getting PKP session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { EthWalletProvider } from '@lit-protocol/lit-auth-client';\n\n// -- preparing the parameters\nconst authMethod = await EthWalletProvider.authenticate({\n  signer: YOUR_WALLET_SIGNER,\n  litNodeClient,\n});\n\nconst authMethodOwnedPkpPublicKey = '0x..';\n\nconst resourceAbilityRequests = [\n  {\n    resource: new LitPKPResource('*'),\n    ability: LitAbility.PKPSigning,\n  },\n  {\n    resource: new LitActionResource('*'),\n    ability: LitAbility.LitActionExecution,\n  },\n];\n\nconst customAuthLitActionCode = Buffer.from(\n  `\n// Works with an AuthSig AuthMethod\nif (Lit.Auth.authMethodContexts.some(e => e.authMethodType === 1)) {\n  LitActions.setResponse({ response: \"true\" });\n} else {\n  LitActions.setResponse({ response: \"false\" });\n}\n`\n).toString('base64');\n\n// -- get pkp session sigs with custom authentication\nconst litActionSessionSigs = await litNodeClient.getPkpSessionSigs({\n  pkpPublicKey: authMethodOwnedPkpPublicKey,\n  authMethods: [authMethod],\n  resourceAbilityRequests: resourceAbilityRequests,\n  litActionCode: customAuthLitActionCode,\n  jsParams: {\n    publicKey: authMethodOwnedPkpPublicKey,\n    sigName: 'custom-auth',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting NFT with Encrypted Metadata\nDESCRIPTION: Function to mint new NFT tokens with encrypted description and symmetric key, setting token URI and storing metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/smartContract.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n    function mintLitNft(\n        string memory name,\n        string memory imageUrl,\n        string memory encryptedDescription,\n        string memory encryptedSymmetricKey\n    ) public nonReentrant {\n        _tokenIds.increment();\n        uint256 newNftTokenId = _tokenIds.current();\n        _safeMint(msg.sender, newNftTokenId);\n        _setTokenURI(newNftTokenId, getTokenURI(name, imageUrl, encryptedDescription, encryptedSymmetricKey));\n        tokenIdToNft[newNftTokenId] = nft(name, imageUrl, encryptedDescription, encryptedSymmetricKey);\n    }\n```\n\n----------------------------------------\n\nTITLE: Minting PKPs through Lit Protocol\nDESCRIPTION: Initializes Lit Relay, authenticates the session, and mints PKPs (Programmable Key Pairs) through Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\nimport { StytchOtpProvider } from \"@lit-protocol/providers\";\nimport { LitRelay } from \"@lit-protocol/lit-auth-client\";\n\nconst litRelay = new LitRelay({\n    relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n    relayApiKey: 'test-api-key',\n});\n\nconst session = new StytchOtpProvider({ relay: litRelay, litNodeClient,    \n    userId: sessionStatus.session.user_id,\n    appId: \"project-test-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\"\n});\n \nconst authMethod = await session.authenticate({ \n    accessToken: sessionStatus.session_jwt \n});\n \nawait litRelay.mintPKPWithAuthMethods([authMethod], {});\nconst pkps = await session.fetchPKPs(authMethod);\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data with Lit Protocol\nDESCRIPTION: Function to encrypt string data using Lit Protocol with specified access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nasync function encryptData(dataToEncrypt: string): Promise<[string, string]> {\n  const authSig = await getAuthSig();\n  const accessControlConditions = getAccessControlConditions();\n  const litNodeClient = await getLitNodeClient();\n\n  const { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n    { accessControlConditions, dataToEncrypt },\n    litNodeClient\n  );\n\n  return [ciphertext, dataToEncryptHash];\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PKP Wallets with LitNodeClient\nDESCRIPTION: Example showing the new initialization process for PKP wallets requiring litNodeClient parameter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n// Old Way\nconst pkpEthersWallet = new PKPEthersWallet({ pkpPublicKey, controllerAuthSig });\n\n// New Way\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\n\nconst litNodeClient = new LitNodeClient();\nawait litNodeClient.connect();\n\nconst pkpEthersWallet = new PKPEthersWallet({\n  pkpPublicKey,\n  controllerAuthSig,\n  litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures for Authentication\nDESCRIPTION: This code snippet demonstrates how to generate PKP Session Signatures using the LitNodeClient. It includes setting up authentication methods and resource ability requests for the session.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Decryption Capability to Specific Access Control Condition in JavaScript\nDESCRIPTION: This code demonstrates how to create a session capability object that grants decryption capability to a specific access control condition. It imports the LIT_ABILITY constant, creates a new session capability object, defines a Lit resource, and adds the decryption capability for that resource.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/capability-objects.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('someResource');\n\n// Add the capability to decrypt from the access control condition referred to by the \n// lit resource.\nsessionCapabilityObject.addCapabilityForResource(\n    litResource,\n    LIT_ABILITY.AccessControlConditionDecryption\n);\n```\n\n----------------------------------------\n\nTITLE: Default Access Control Conditions for Wrapped Keys\nDESCRIPTION: Defines the default access control conditions used when encrypting private keys for Wrapped Keys. These conditions link the access to a specific PKP address on the Ethereum chain.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/custom-wrapped-keys.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain: CHAIN_ETHEREUM,\n        method: '',\n        parameters: [':userAddress'],\n        returnValueTest: {\n        comparator: '=',\n        value: pkpAddress,\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Network Connection\nDESCRIPTION: Setup code for connecting to the Lit network using LitNodeClient and initializing an Ethereum wallet for authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/quick-start.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK, LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: false\n});\nawait litNodeClient.connect();\n\nconst ethersWallet = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY, // Replace with your private key\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions for Solana with Wrapped Keys\nDESCRIPTION: Interface for the signTransactionWithEncryptedKey function when signing transactions for Solana. It includes parameters for PKP session signatures, Lit node client, network type, wrapped key ID, broadcast flag, and a serialized unsigned transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function signTransactionWithEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    network: 'solana';\n    id: string;\n    broadcast: boolean;\n    unsignedTransaction: SerializedTransaction;\n  }\n): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Validating SIWS Message Signature in JavaScript\nDESCRIPTION: This async function verifies the SIWS signature by converting the message to bytes, decoding the signature and public key, importing the public key, and using the Web Crypto API to verify the signature. It returns a boolean indicating whether the signature is valid.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/authenticating-siws.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function verifySiwsSignature(\n  message,\n  signatureBase58,\n  publicKeyBase58\n) {\n  // Convert message to Uint8Array\n  const messageBytes = new TextEncoder().encode(message);\n\n  try {\n    const signatureBytes = ethers.utils.base58.decode(signatureBase58);\n    const publicKeyBytes = ethers.utils.base58.decode(publicKeyBase58);\n\n    // Import the public key\n    const publicKey = await crypto.subtle.importKey(\n      \"raw\",\n      publicKeyBytes,\n      {\n        name: \"Ed25519\",\n        namedCurve: \"Ed25519\",\n      },\n      false,\n      [\"verify\"]\n    );\n\n    // Verify the signature\n    const isValid = await crypto.subtle.verify(\n      \"Ed25519\",\n      publicKey,\n      signatureBytes,\n      messageBytes\n    );\n\n    return isValid;\n  } catch (error) {\n    console.error(\"Error in verifySiwsSignature:\", error);\n    throw error;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Auth Method ID using Discord Example\nDESCRIPTION: Demonstrates how to generate a unique auth method ID by hashing Discord user and client IDs using ethers utils.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { utils } from \"ethers\";\n\n// You can fetch the Discord user ID by calling the Discord API: https://discord.com/developers/docs/resources/user\nconst userId = \"<Discord user ID>\";\n// Upon creating a Discord application, you will be given a client ID: https://discord.com/developers/docs/topics/oauth2\nconst clientId = \"<Discord client ID>\";\n// The id can be a hash of the Discord user ID and the Discord client ID\nconst authMethodId = utils.keccak256(\n  utils.toUtf8Bytes(`${user.id}:${this.clientId}`)\n);\n```\n\n----------------------------------------\n\nTITLE: Instantiating an Ethers Signer for Lit Protocol\nDESCRIPTION: Code to create an Ethers signer instance using a private key, connecting to the Lit Protocol's Chronicle Yellowstone RPC. This signer must be the owner of the Capacity Credit.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/delegating-credit.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport ethers from \"ethers\";\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing SMS OTP Authentication\nDESCRIPTION: Setup of Stytch OTP provider for SMS-based authentication with LitRelay integration\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { StytchOtpProvider } from '@lit-protocol/providers';\nimport { AUTH_METHOD_SCOPE, PROVIDER_TYPE, LIT_NETWORK } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true\n})\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\nconst stytchOtpProvider = new StytchOtpProvider({ relay: litRelay, litNodeClient });\n\n// Send one-time passcodes via phone number through Stytch\nasync function sendPasscode(userId) {  \n  // userId: phone number\n  const response = await stytchClient.otps.sms.loginOrCreate(\n    !userId.startsWith('+') ? `+${userId}` : userId\n  );\n  return response.method_id;\n}\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data in Browser Environment\nDESCRIPTION: Function to decrypt data in browser context using connected wallet for authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport const decryptData = async (encryptedText: string, dataToEncryptHash: string): Promise<string> => {\n  await litClient.connect();\n\n  const provider = new ethers.BrowserProvider(window.ethereum);\n  const signer = await provider.getSigner();\n  const walletAddress = await signer.getAddress();\n\n  const latestBlockhash = await litClient.getLatestBlockhash();\n\n  const authNeededCallback = async (params: any) => {\n    if (!params.uri) throw new Error(\"uri is required\");\n    if (!params.expiration) throw new Error(\"expiration is required\");\n    if (!params.resourceAbilityRequests) throw new Error(\"resourceAbilityRequests is required\");\n\n    const toSign = await createSiweMessageWithRecaps({\n      uri: params.uri,\n      expiration: params.expiration,\n      resources: params.resourceAbilityRequests,\n      walletAddress: walletAddress,\n      nonce: latestBlockhash,\n      litNodeClient: litClient,\n    });\n\n    const authSig = await generateAuthSig({\n      signer: signer,\n      toSign,\n    });\n\n    return authSig;\n  };\n\n  const litResource = new LitAccessControlConditionResource(\"*\");\n\n  const sessionSigs = await litClient.getSessionSigs({\n    chain: \"ethereum\",\n    resourceAbilityRequests: [\n      {\n        resource: litResource,\n        ability: LIT_ABILITY.AccessControlConditionDecryption,\n      },\n    ],\n    authNeededCallback,\n  });\n\n  const decryptedString = await LitJsSdk.decryptToString(\n    {\n      accessControlConditions: getAccessControlConditions(),\n      chain: \"ethereum\",\n      ciphertext: encryptedText,\n      dataToEncryptHash,\n      sessionSigs,\n    },\n    litClient\n  );\n\n  return decryptedString;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a LitSigner for Account Abstraction\nDESCRIPTION: Code that sets up the LitSigner from Alchemy's AA signers package, configuring it with a PKP public key, RPC URL, and network settings for integration with Account Kit.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitSigner } from \"@alchemy/aa-signers\";\nimport { LitAuthMethod } from \"@alchemy/aa-signers/lit-protocol\";\nimport { createWalletClient, custom } from \"viem\";\nimport { polygonMumbai } from \"viem/chains\";\n\nconst API_KEY = \"<YOUR ALCHEMY API KEY>\";\nconst POLYGON_MUMBAI_RPC_URL = `${polygonMumbai.rpcUrls.alchemy.http[0]}/${API_KEY}`;\nconst PKP_PUBLIC_KEY = \"<YOUR PKP PUBLIC KEY>\";\n\nconst litSigner = new LitSigner<LitAuthMethod>({\n  pkpPublicKey: PKP_PUBLIC_KEY,\n  rpcUrl: POLYGON_MUMBAI_RPC_URL,\n  network: \"datil-dev\"\n});\n```\n\n----------------------------------------\n\nTITLE: Using getPkpSessionSigs in TypeScript\nDESCRIPTION: Demonstrates how to use the new getPkpSessionSigs function which simplifies session key signing process.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from '@lit-protocol/lit-auth-client';\n\n// -- preparing the parameters\nconst authMethod = await EthWalletProvider.authenticate({\n  signer: YOUR_WALLET_SIGNER,\n  litNodeClient,\n});\n\nconst authMethodOwnedPkpPublicKey = '0x..';\n\nconst resourceAbilityRequests = [\n  {\n    resource: new LitPKPResource('*'),\n    ability: LitAbility.PKPSigning,\n  },\n  {\n    resource: new LitActionResource('*'),\n    ability: LitAbility.LitActionExecution,\n  },\n];\n\n// -- get pkp session sigs\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n  pkpPublicKey: authMethodOwnedPkpPublicKey,\n  authMethods: [authMethod],\n  resourceAbilityRequests: resourceAbilityRequests,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining EthereumLitTransaction Interface for EVM Networks in TypeScript\nDESCRIPTION: This code snippet defines the EthereumLitTransaction interface used when the network parameter is set to 'evm'. It specifies the structure of the unsigned transaction object for Ethereum-based networks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EthereumLitTransaction {\n  chain: string;\n  toAddress: string;\n  value: string;\n  chainId: number;\n  gasPrice?: string;\n  gasLimit?: number;\n  dataHex?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Minting PKP and Adding Permitted Auth Methods in TypeScript\nDESCRIPTION: This code snippet shows how to mint a PKP and add permitted auth methods using the Lit Contracts SDK. It permits a Lit Action based on its IPFS CID and a custom Auth Method based on a Solana public key, with different permission scopes for each.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/siws-pkp-session-sigs.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst tx =\n    await litContractsClient.pkpHelperContract.write.mintNextAndAddAuthMethods(\n        AUTH_METHOD_TYPE.LitAction, // keyType\n        [AUTH_METHOD_TYPE.LitAction, authMethodType], // permittedAuthMethodTypes\n        [\n        `0x${Buffer.from(\n            ethers.utils.base58.decode(\n            await calculateLitActionCodeCID(litActionSessionSigs)\n            )\n        ).toString(\"hex\")}`,\n        authMethodId,\n        ], // permittedAuthMethodIds\n        [\"0x\", \"0x\"], // permittedAuthMethodPubkeys\n        [[AUTH_METHOD_SCOPE.SignAnything], [AUTH_METHOD_SCOPE.NoPermissions]], // permittedAuthMethodScopes\n        true, // addPkpEthAddressAsPermittedAddress\n        true, // sendPkpToItself\n        { value: await litContractsClient.pkpNftContract.read.mintCost() }\n);\nconst receipt = await tx.wait();\n```\n\n----------------------------------------\n\nTITLE: Uploading Encrypted Data to Irys\nDESCRIPTION: Function to upload encrypted data and access control conditions to Irys network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport const uploadToIrys = async (cipherText: string, dataToEncryptHash: string): Promise<string> => {\n  const irysUploader = await getIrysUploader();\n\n  const dataToUpload = {\n    cipherText: cipherText,\n    dataToEncryptHash: dataToEncryptHash,\n    accessControlConditions: getAccessControlConditions(),\n  };\n\n  try {\n    const tags = [{ name: \"Content-Type\", value: \"application/json\" }];\n    const receipt = await irysUploader.upload(JSON.stringify(dataToUpload), { tags });\n    return receipt?.id ? `${gatewayAddress}${receipt.id}` : \"\";\n  } catch (error) {\n    console.error(\"Error uploading data: \", error);\n    throw error;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Constructing AuthMethod Object for Lit Protocol\nDESCRIPTION: This snippet demonstrates how to construct an AuthMethod object for Lit Protocol, using Discord as an example. It shows how to create a unique identifier for the auth method using the Discord user ID and client ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { utils } from \"ethers\";\n\n// You can fetch the Discord user ID by calling the Discord API: https://discord.com/developers/docs/resources/user\nconst userId = \"<Discord user ID>\";\n// Upon creating a Discord application, you will be given a client ID: https://discord.com/developers/docs/topics/oauth2\nconst clientId = \"<Discord client ID>\";\n// The id can be a hash of the Discord user ID and the Discord client ID\nconst authMethodId = utils.keccak256(\n  utils.toUtf8Bytes(`${user.id}:${this.clientId}`)\n);\n```\n\n----------------------------------------\n\nTITLE: Handling Session Proposals in PKPWalletConnect\nDESCRIPTION: Sets up an event listener for session proposals, logs the proposal, approves it, and logs active sessions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\npkpWalletConnect.on('session_proposal', async (proposal) => {\n  console.log('Received session proposal: ', proposal);\n\n  // Accept session proposal\n  await pkpWalletConnect.approveSessionProposal(proposal);\n\n  // Log active sessions\n  const sessions = Object.values(pkpWalletConnect.getActiveSessions());\n  for (const session of sessions) {\n    const { name, url } = session.peer.metadata;\n    console.log(`Active Session: ${name} (${url})`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Decryption Capability to All Access Control Conditions in JavaScript\nDESCRIPTION: This code demonstrates how to grant decryption capability to all access control conditions using a wildcard. It creates a session capability object, defines a Lit resource with a wildcard key, and adds the decryption capability for that resource.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/capability-objects.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('*');\n\n// Add the capability to decrypt from the access control condition referred to by the \n// lit resource.\nsessionCapabilityObject.addCapabilityForResource(\n    litResource,\n    LIT_ABILITY.AccessControlConditionDecryption\n);\n```\n\n----------------------------------------\n\nTITLE: Lit Action Execution Using IPFS Parameter\nDESCRIPTION: Example demonstrating Lit Action execution by referencing code stored on IPFS\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst signatures = await litNodeClient.executeJs({\n  ipfsId: \"QmRwN9GKHvCn4Vk7biqtr6adjXMs7PzzYPCzNCRjPFiDjm\",\n  authSig,\n  // all jsParams can be used anywhere in your Lit Action Code\n  jsParams: {\n    // this is the string \"Hello World\" for testing\n    toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n    publicKey:\n      \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n    sigName: \"sig1\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Collaborative Multi-Signature Bitcoin Transaction with PKPs\nDESCRIPTION: This TypeScript function creates a P2SH Bitcoin transaction using two PKPs. It derives P2SH addresses from PKP public keys, retrieves UTXOs, constructs a PSBT, signs inputs using Lit Actions, and broadcasts the final transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/collaborative.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport * as ecc from \"tiny-secp256k1\";\nimport mempoolJS from \"@mempool/mempool.js\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\n\nbitcoin.initEccLib(ecc);\n\nexport async function collaborativeMultiSig(litNodeClient: LitNodeClient, sessionSigs: any, pkpPublicKey1: string, pkpPublicKey2: string, destinationAddress: string) {\n    const network = bitcoin.networks.bitcoin;\n    const pubKeyBuffer_1 = Buffer.from(pkpPublicKey1, \"hex\");\n    const pubKeyBuffer_2 = Buffer.from(pkpPublicKey2, \"hex\");\n\n    const redeemScript1 = bitcoin.script.compile([\n        pubKeyBuffer_1,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n\n    const redeemScript2 = bitcoin.script.compile([\n        pubKeyBuffer_2,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n\n    const p2shPayment1 = bitcoin.payments.p2sh({\n        redeem: { output: redeemScript1 },\n        network: network,\n    });\n    console.log(\"P2SH Address 1:\", p2shPayment1.address);\n\n    const p2shPayment2 = bitcoin.payments.p2sh({\n        redeem: { output: redeemScript2 },\n        network: network,\n    });\n    console.log(\"P2SH Address 2:\", p2shPayment2.address);\n\n    const {\n        bitcoin: { addresses, transactions },\n    } = mempoolJS({\n        hostname: \"mempool.space\",\n        network: \"mainnet\",\n    });\n\n    const address1Utxos = await addresses.getAddressTxsUtxo({\n        address: p2shPayment1.address!,\n    });\n\n    if (address1Utxos.length === 0) {\n        console.log(\"No UTXOs found for address:\", p2shPayment1.address);\n        return;\n    }\n\n    const utxo1 = address1Utxos[0];\n\n    const address2Utxos = await addresses.getAddressTxsUtxo({\n        address: p2shPayment2.address!,\n    });\n\n    if (address2Utxos.length === 0) {\n        console.log(\"No UTXOs found for address:\", p2shPayment2.address);\n        return;\n    }\n\n    const utxo2 = address2Utxos[0];\n\n    const fee = 1000; // Adjust the fee as needed\n\n    const utxoValue1 = utxo1.value;\n    const utxoValue2 = utxo2.value;\n    const totalInputValue = utxoValue1 + utxoValue2;\n    const amountToSend = totalInputValue - fee;\n\n    const psbt = new bitcoin.Psbt({ network });\n\n    const utxo1RawTx = await transactions.getTxHex({ txid: utxo1.txid });\n    const utxo2RawTx = await transactions.getTxHex({ txid: utxo2.txid });\n\n    psbt.addInput({\n        hash: utxo1.txid,\n        index: utxo1.vout,\n        nonWitnessUtxo: Buffer.from(utxo1RawTx, \"hex\"),\n        redeemScript: redeemScript1,\n    });\n\n    psbt.addInput({\n        hash: utxo2.txid,\n        index: utxo2.vout,\n        nonWitnessUtxo: Buffer.from(utxo2RawTx, \"hex\"),\n        redeemScript: redeemScript2,\n    });\n\n    psbt.addOutput({\n        address: destinationAddress,\n        value: BigInt(amountToSend),\n    });\n\n    //@ts-ignore\n    const tx = psbt.__CACHE.__TX.clone();\n    const sighash1 = tx.hashForSignature(\n        0,\n        redeemScript1,\n        bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const sighash2 = tx.hashForSignature(\n        1,\n        redeemScript2,\n        bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const litActionResponse1 = await litNodeClient.executeJs({\n        code: litActionCode,\n        sessionSigs,\n        jsParams: {\n        publicKey: pkpPublicKey1,\n        toSign: Buffer.from(sighash1, \"hex\"),\n        },\n    });\n\n    const litActionResponse2 = await litNodeClient.executeJs({\n        code: litActionCode,\n        sessionSigs,\n        jsParams: {\n        publicKey: pkpPublicKey2,\n        toSign: Buffer.from(sighash2, \"hex\"),\n        },\n    });\n\n    const signatureWithHashType1 = await convertSignature(\n        litActionResponse1.signatures.btcSignature\n    );\n\n    const signatureWithHashType2 = await convertSignature(\n        litActionResponse2.signatures.btcSignature\n    );\n\n    psbt.updateInput(0, {\n        finalScriptSig: bitcoin.script.compile([\n        signatureWithHashType1,\n        redeemScript1,\n        ]),\n    });\n\n    psbt.updateInput(1, {\n        finalScriptSig: bitcoin.script.compile([\n        signatureWithHashType2,\n        redeemScript2,\n        ]),\n    });\n\n    const txHex = psbt.extractTransaction().toHex();\n    return await broadcastTransaction(txHex);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Social Login with Google Provider\nDESCRIPTION: Setup code for initializing the Lit Node Client and configuring Google authentication provider for social login\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-social.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { StytchOtpProvider } from '@lit-protocol/providers';\nimport { PROVIDER_TYPE, LIT_NETWORK } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true,\n});\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\nconst googleProvider = new GoogleProvider({ relay: litRelay, litNodeClient });\n\n// Begin login flow with Google\nawait googleProvider.signIn();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Protocol Node\nDESCRIPTION: Initialize and connect to a Lit Protocol node on the DatilDev network. Sets up a singleton client instance for handling encryption operations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlet litNodeClientInstance: LitJsSdk.LitNodeClientNodeJs | null = null;\n\nasync function getLitNodeClient(): Promise<LitJsSdk.LitNodeClientNodeJs> {\n  if (litNodeClientInstance) return litNodeClientInstance;\n\n  litNodeClientInstance = new LitJsSdk.LitNodeClientNodeJs({\n    alertWhenUnauthorized: false,\n    litNetwork: LIT_NETWORK.DatilDev, // DatilDev network for free usage\n    debug: false,\n  });\n\n  await litNodeClientInstance.connect();\n  return litNodeClientInstance;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Cask Protocol Subscription in JavaScript\nDESCRIPTION: This snippet defines access control conditions to verify if a user is either the provider or an active subscriber to a Cask Protocol plan. It uses the getActiveSubscriptionCount method and checks for a specific provider address and plan ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"polygon\",\n    method: \"\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n        comparator: \"=\",\n        value: '0xCdcE8CD89e4B29193874Acc677D5ae6624524bFd',\n    },\n  },\n  {operator: \"or\"},\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"0x4A6f232552E0fd76787006Bb688bFBCB931cc3d0\",\n    standardContractType: \"CASK\",\n    chain: \"polygon\",\n    method: 'getActiveSubscriptionCount',\n    parameters: [\n        ':userAddress',\n        '0xCdcE8CD89e4B29193874Acc677D5ae6624524bFd',\n        '100'\n    ],\n    returnValueTest: {\n        comparator: '>',\n        value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Defining AddUserResponse Interface\nDESCRIPTION: Defines the structure of the response object returned by the add-users API endpoint.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AddUserResponse {\n  success: boolean;\n  error?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPEthersWallet with Authentication\nDESCRIPTION: Creates and initializes a PKPEthersWallet instance with required authentication credentials and RPC configuration. Requires an AuthSig or SessionSig for authorization and a PKP public key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst pkpWallet = new PKPEthersWallet({\n  controllerAuthSig: \"<Your AuthSig>\",\n  // Or you can also pass in controllerSessionSigs\n  pkpPubKey: \"<Your PKP public key>\",\n  rpc: LIT_RPC.CHROINCLE_YELLOWSTONE,\n});\nawait pkpWallet.init();\n```\n\n----------------------------------------\n\nTITLE: Implementing Stytch OTP Authentication Flow\nDESCRIPTION: Handles the complete OTP authentication flow including user login/creation, OTP verification, and session management. Uses email-based OTP authentication with session token generation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst email = \"\"; // email address of user\n\nconst stytchResponse = await client.otps.email.loginOrCreate({\n  email: email,\n  \n})\n\nconst authResponse = await client.otps.authenticate({\n  method_id: stytchResponse.email_id,\n  code: // code from email,\n  session_duration_minutes: 60, // session duration is required for session token creation\n})\n\nconst sessionResp = await client.sessions.get({\n  user_id: authResponse.user_id\n});\n\nconst sessionStatus = await client.sessions.authenticate({\n  session_token: authResponse.session_token,\n})\n```\n\n----------------------------------------\n\nTITLE: Estimating Gas for Auth Method Operations in Lit Protocol\nDESCRIPTION: This code snippet shows how to estimate the gas required for adding or removing authentication methods in Lit Protocol. It uses the populateTransaction method to create an unsigned transaction and then estimates the gas.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// First, mock the transaction to add an auth method\nconst mockTransaction =\n  await litContracts.pkpPermissionsContract.write.populateTransaction.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    []\n  );\n\n// Then, estimate gas on the unsigned transaction\nconst gas = await litContracts.signer.estimateGas(mockTransaction);\n\n// Now, you can use the gas value to set the gas limit\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    [],\n    { gasLimit: gas }\n  );\n```\n\n----------------------------------------\n\nTITLE: Browser AuthSig Generation using checkAndSignAuthMessage\nDESCRIPTION: Example of obtaining an AuthSig in a browser environment using the checkAndSignAuthMessage function from the Lit SDK.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/authSig.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { checkAndSignAuthMessage } from \"@lit-protocol/lit-node-client@serrano\";\n\nconst authSig = await checkAndSignAuthMessage({\n  chain: \"ethereum\",\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Key Claiming with Relay Server\nDESCRIPTION: Shows how to claim a key using a custom ClaimProcessor with the Lit relay server. Implements custom relay server communication and error handling.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new LitNodeClient({\n\tlitNetwork: \"datil-dev\",\n\tdebug: false\n});\nawait client.connect();\n\nlet res = await client.claimKeyId({\n\t authMethod, // provide an auth method to claim a key Identifier mapped to the given auth method\n\t mintCallback: (claimRes: ClaimResponse<RelayClaimProcessor>) => {\n\t    const response = await fetch(relayUrl, {\n\t      method: 'POST',\n\t      body: JSON.stringify(claimRes),\n\t      headers: {\n\t        'api-key': params.relayApiKey, \n\t        'Content-Type': 'application/json',\n      },\n    });\n\n    if (response.status < 200 || response.status >= 400) {\n      let errResp = await response.json() ?? \"\";\n      let errStmt = `An error occurred requesting \"/auth/claim\" endpoint ${JSON.stringify(\n        errResp\n      )}`;\n      console.warn(errStmt);\n      throw new Error(errStmt);\n    }\n\n    let body: any = await response.json();\n\t\t// the transaction hash of registering the claim on chain\n    return body.requestId;\n\t\t}\n});\n\nconsole.log(\"mint tx hash: \", res.mintTx);\nconsole.log(\"pkp public key: \", res.pubkey);\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Cosmos Wallet Address\nDESCRIPTION: Checks if the user owns a specific Cosmos wallet address. Performs direct address comparison with automatic user address substitution.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/other-chains/cosmos-conditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \":userAddress\",\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \"=\",\n      value: \"cosmos1vn6zl0924yj86jrp330wcwjclzdharljq03a8h\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Setting up Discord Authentication with Lit Protocol\nDESCRIPTION: Configures Discord OAuth authentication using DiscordProvider, including client ID and redirect URI setup, with support for custom OAuth flow.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/social-login.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { DiscordProvider } from '@lit-protocol/providers';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize Discord provider\nconst discordProvider = new DiscordProvider({ relay, litNodeClient, clientId: '<Your Discord Client ID>', redirectUri: '<Your redirect URI>' });\n\n// Begin login flow with Discord\nasync function authWithDiscord() {\n  await discordProvider.signIn((url) => {\n    const myURL = new URL(url);\n    \n    // Modify URL as needed\n    myURL.host = 'mycustomdomain.com';\n    myURL.pathname = '/myCustomOauthLoginFlow';\n    // myURL.searchParams.get('app_redirect') is your redirect URI for logged in users\n    \n    window.location.assign(url);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions with PKPEthersWallet\nDESCRIPTION: Example of creating and signing an Ethereum transaction request with basic parameters. The wallet automatically adds missing fields like nonce and chainId.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst from = address;\nconst to = address;\nconst gasLimit = BigNumber.from(\"21000\");\nconst value = BigNumber.from(\"10\");\nconst data = \"0x\";\n\n// @lit-protocol/pkp-ethers will automatically add missing fields (nonce, chainId, gasPrice, gasLimit)\nconst transactionRequest = {\n  from,\n  to,\n  gasLimit,\n  value,\n  data,\n};\n\nconst signedTransactionRequest = await pkpWallet.signTransaction(\n  transactionRequest\n);\n```\n\n----------------------------------------\n\nTITLE: Checking SOL Balance in Wallet\nDESCRIPTION: Verifies if a user's wallet contains more than 0.1 SOL using the getBalance RPC method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/sol-rpc-conditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"getBalance\",\n    params: [\":userAddress\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Storing Encrypted Data on Irys\nDESCRIPTION: Function to store encrypted data on Irys blockchain, including the ciphertext, hash, and access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nasync function storeOnIrys(cipherText: string, dataToEncryptHash: string): Promise<string> {\n  const irysUploader = await getIrysUploader();\n\n  const dataToUpload = {\n    cipherText,\n    dataToEncryptHash,\n    accessControlConditions: getAccessControlConditions(),\n  };\n\n  try {\n    const tags = [{ name: \"Content-Type\", value: \"application/json\" }];\n    const receipt = await irysUploader.upload(JSON.stringify(dataToUpload), { tags });\n    return receipt?.id || \"\";\n  } catch (error) {\n    console.error(\"Error uploading data: \", error);\n    return \"\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Providers Directly in JavaScript\nDESCRIPTION: New way of initializing providers without LitAuthClient, using LitRelay and specific provider classes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay, EthWalletProvider } from '@lit-protocol/lit-auth-client';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\n\nconst litNodeClient = new LitNodeClient();\nawait litNodeClient.connect();\nconst relay = new LitRelay({ litNetwork: LIT_NETWORK.MAINNET });\n\nconst ethWalletProvider = new EthWalletProvider({ relay, litNodeClient });\n```\n\n----------------------------------------\n\nTITLE: Signing Solana Transactions with Encrypted Keys in Lit Protocol\nDESCRIPTION: Code to sign a Solana transaction using an encrypted key in Lit Protocol. This implementation creates a Solana transaction, serializes it, and then uses Lit Protocol to sign and broadcast the transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Connection,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  clusterApiUrl,\n} from '@solana/web3.js';\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { signTransactionWithEncryptedKey } = api;\nconst chain = 'devnet';\nconst fromPublicKey = new PublicKey(process.env.SOLANA_PUBLIC_KEY);\nconst toPublicKey = new PublicKey(process.env.SOLANA_TRANSACTION_RECIPIENT_PUBLIC_KEY);\n\nconst solanaTransaction = new Transaction();\n    solanaTransaction.add(\n    SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: LAMPORTS_PER_SOL / 100, // Transfer 0.01 SOL\n    })\n);\nsolanaTransaction.feePayer = fromPublicKey;\n\nconst solanaConnection = new Connection(clusterApiUrl(chain), 'confirmed');\nconst { blockhash } = await solanaConnection.getLatestBlockhash();\nsolanaTransaction.recentBlockhash = blockhash;\n\nconst serializedTransaction = solanaTransaction\n    .serialize({\n        requireAllSignatures: false, // should be false as the transaction is not yet being signed\n        verifySignatures: false, // should be false as the transaction is not yet being signed\n    })\n    .toString('base64');\n\nconst unsignedTransaction: SerializedTransaction = {\n    serializedTransaction,\n    chain,\n};\n\nconst transactionSignature = await signTransactionWithEncryptedKey({\n  pkpSessionSigs,\n  network: 'solana',\n  id: process.env.WRAPPED_KEY_ID,\n  unsignedTransaction,\n  broadcast: true,\n  litNodeClient,\n});\n\n// Wait for confirmation and fetch the transaction details\nconst signatureBuffer = Buffer.from(transactionSignature, 'base64');\nconst confirmation = await solanaConnection.confirmTransaction(signatureBuffer);\nconsole.log('Transaction confirmation status:', confirmation.value);\n\nconst transactionReceipt = await solanaConnection.getTransaction(\n    signatureBuffer.toString('base64'),\n    { commitment: 'confirmed' },\n);\n```\n\n----------------------------------------\n\nTITLE: AuthSig Object Format in JSON\nDESCRIPTION: Example of the required format for an AuthSig object containing the signature, derivation method, signed message, and wallet address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/authSig.md#2025-04-18_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sig\": \"0x18720b54cf0d29d618a90793d5e76f4838f04b559b02f1f01568d8e81c26ae9536e11bb90ad311b79a5bc56149b14103038e5e03fee83931a146d93d150eb0f61c\",\n  \"derivedVia\": \"web3.eth.personal.sign\",\n  \"signedMessage\": \"localhost wants you to sign in with your Ethereum account:\\n0x1cD4147AF045AdCADe6eAC4883b9310FD286d95a\\n\\nThis is a test statement.  You can put anything you want here.\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: gzdlw7mR57zMcGFzz\\nIssued At: 2022-04-15T22:58:44.754Z\",\n  \"address\": \"0x1cD4147AF045AdCADe6eAC4883b9310FD286d95a\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPWalletConnect with Configuration in JavaScript\nDESCRIPTION: This code snippet shows how to initialize PKPWalletConnect with a configuration object that includes a WalletConnect project ID and metadata for the wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst config = {\n  projectId: \"<Your WalletConnect project ID>\",\n  metadata: {\n    name: \"Test Lit Wallet\",\n    description: \"Test Lit Wallet\",\n    url: \"https://litprotocol.com/\",\n    icons: [\"https://litprotocol.com/favicon.png\"],\n  },\n};\n\nawait pkpWalletConnect.initWalletConnect(config);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol Transaction Signing\nDESCRIPTION: Commands to install the required dependencies for implementing transaction signing with Lit Protocol using npm or yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Setting NFT Access Control Conditions\nDESCRIPTION: Function to create access control conditions based on NFT ownership requirements.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"0xABC123...XYZ\", // ERC721 contract address\n      standardContractType: \"ERC721\",\n      chain: \"ethereum\",\n      method: \"balanceOf\",\n      parameters: [\":userAddress\"],\n      returnValueTest: {\n        comparator: \">\",\n        value: \"0\",\n      },\n    },\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with LitNodeClient\nDESCRIPTION: Detailed implementation of session signature generation using LitNodeClient with authentication callback and resource abilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// The implementation below is wrapped by the above `provider.getSessionSigs`\nconst authNeededCallback = async (params: AuthCallbackParams) => {\n  console.log(\"params\", params)\n  const response = await litNodeClient.signSessionKey({\n    sessionKey: sessionKeyPair,\n    statement: params.statement,\n    authMethods: [authMethod], // auth method from one of the `lit-auth-client` authentication providers\n    pkpPublicKey: \"<YOUR PKP PUBLIC KEY>\", // pkp which has the auth method configured for authentication above\n    expiration: params.expiration,\n    resources: params.resources,\n    chainId: 1,\n  });\n  console.log(\"callback response\", response)\n  return response.authSig;\n};\n\nconst resourceAbilities = [\n    {\n      resource: new LitActionResource(\"*\"),\n      ability: LitAbility.PKPSigning,\n    },\n];\nconst sessionSigs = await litNodeClient.getSessionSigs({\n  chain: \"ethereum\",\n  expiration: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString(),\n  resourceAbilityRequests: resourceAbilities,\n  sessionKey: sessionKeyPair,\n  authNeededCallback\t\n}).catch((err) => {\n  console.log(\"error while attempting to access session signatures: \", err)\n  throw err;\n});\nconsole.log(\"session signatures: \", sessionSigs);\nconst authSig = sessionSigs[Object.keys(sessionSigs)[0]];\nconsole.log(\"authSig\", authSig);\n```\n\n----------------------------------------\n\nTITLE: Decrypting NFT Description with Lit SDK in JavaScript\nDESCRIPTION: This snippet shows how to decrypt an encrypted NFT description using the Lit SDK. It converts the encrypted description string back to a Blob and uses the Lit protocol to decrypt the text.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/frontend.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst decryptDescription = async (\n  encryptedDescriptionString,\n  encryptedSymmetricKeyString\n) => {\n  // Convert base64 to blob to pass in the litSDK decrypt function\n  const encryptedDescriptionBlob = await (\n    await fetch(encryptedDescriptionString)\n  ).blob();\n\n  let decryptedDescription;\n  try {\n    decryptedDescription = await lit.decryptText(\n      encryptedDescriptionBlob,\n      encryptedSymmetricKeyString\n    );\n    setShowButton(false);\n  } catch (error) {\n    console.log(error);\n  }\n\n  // Set decrypted string\n  // setDescription(decryptedDescription);\n};\n```\n\n----------------------------------------\n\nTITLE: Instantiating Ethers Signer for Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to create an Ethers signer using a private key from an environment variable. The signer is connected to the Lit Protocol RPC endpoint for the Chronicle Yellowstone network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Generating SessionSigs for Authenticated WebAuthn Credential\nDESCRIPTION: This code snippet demonstrates how to generate SessionSigs using the authenticated WebAuthn credential. It requires the AuthMethod object from authentication and the PKP public key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/webAuthn.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [\n      resource: litResource,\n      ability: LitAbility.AccessControlConditionDecryption\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContracts with PKP Wallet in JavaScript\nDESCRIPTION: This code snippet shows how to initialize LitContracts using a PKP wallet as the signer when the Programmable Key Pair owns itself through the sendPkpToIteself flag.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\n\nconst litContracts = new LitContracts({\n  signer: pkpWallet, // pkp wallet of the owner of the pkp NFT\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Calling Nested Lit Actions\nDESCRIPTION: Example of calling a Lit Action from within another Lit Action using IPFS ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nLit.Actions.call({ ipfsId: \"QmRwN9GKHvCn4Vk7biqtr6adjXMs7PzzYPCzNCRjPFiDjm\", params: {}}) \n```\n\n----------------------------------------\n\nTITLE: Demonstrating URI and Resource Format for Session Keys in Markdown\nDESCRIPTION: This snippet shows the format of the URI and resource array used in the SIWE (Sign-In with Ethereum) message for session keys. It includes the session public key and a ReCap-compatible session capability object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/security.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nlit:session:<actualSessionPubkeyHere>\nurn:recap:<base64EncodedCapabilityObject>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Permitted Auth Methods for PKP in Lit Action (JavaScript)\nDESCRIPTION: This code snippet shows how to use the Lit.Actions.getPermittedAuthMethods() function to retrieve all permitted authentication methods for a PKP. It's used in the authorization process to verify if a user is allowed to use a specific PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/custom-auth.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nLit.Actions.getPermittedAuthMethods()\n```\n\n----------------------------------------\n\nTITLE: Signing EVM Transactions with Encrypted Keys in Lit Protocol\nDESCRIPTION: Code to sign a transaction for an EVM-based network using an encrypted key in Lit Protocol. This function uses the previously generated PKP session signatures to authorize the signing process.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { signTransactionWithEncryptedKey } = api;\n\nconst transactionHash = await signTransactionWithEncryptedKey({\n  pkpSessionSigs,\n  network: 'evm',\n  id: process.env.WRAPPED_KEY_ID,\n  unsignedTransaction: {\n    chain: \"ethereum\",\n    toAddress: process.env.ETHEREUM_TRANSACTION_RECIPIENT\n    value: \"4.2\" // This will be 4.2 ether\n    chainId: 1,\n    dataHex: ethers.utils.hexlify(\n        ethers.utils.toUtf8Bytes('The answer to the Universe is 42.')\n    )\n  },\n  broadcast: true,\n  litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Confirming Solana Transaction and Fetching Details in TypeScript\nDESCRIPTION: This snippet shows how to confirm a Solana transaction and fetch its details after it has been signed and broadcasted using the signTransactionWithEncryptedKey function.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Connection,\n  clusterApiUrl,\n} from '@solana/web3.js';\n\nconst chain = 'devnet';\n\nconst transactionSignature = await signTransactionWithEncryptedKey({\n//   This parameter values are not included here for brevity,\n//   but follow the other code examples in this guide.\n//\n//   pkpSessionSigs,\n//   network: 'solana',\n//   unsignedTransaction,\n//   broadcast: true,\n//   litNodeClient,\n});\n\n// Wait for confirmation and fetch the transaction details\nconst signatureBuffer = Buffer.from(transactionSignature, 'base64');\nconst solanaConnection = new Connection(clusterApiUrl(chain), 'confirmed');\nconst confirmation = await solanaConnection.confirmTransaction(signatureBuffer);\nconsole.log('Transaction confirmation status:', confirmation.value);\n\nconst transactionReceipt = await solanaConnection.getTransaction(\n    signatureBuffer.toString('base64'),\n    { commitment: 'confirmed' },\n);\n```\n\n----------------------------------------\n\nTITLE: Checking Solana Access Control Conditions in Lit Action\nDESCRIPTION: Code snippet that validates a user's Solana public key against Access Control Conditions after authenticating a SIWS message. It uses LitActions.checkConditions to verify if the authenticated wallet is authorized.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/siws-access-control.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ntry {\n  const result = await LitActions.checkConditions({\n    conditions: solRpcConditions,\n    authSig: {\n      sig: ethers.utils\n        .hexlify(ethers.utils.base58.decode(_siwsObject.signature))\n        .slice(2),\n      derivedVia: \"solana.signMessage\",\n      signedMessage: siwsMessage,\n      address: siwsInput.address,\n    },\n    chain: \"solana\",\n  });\n\n  return LitActions.setResponse({ response: result });\n} catch (error) {\n  console.error(\"Error checking if authed sol pub key is permitted:\", error);\n  return LitActions.setResponse({\n    response: JSON.stringify({\n      success: false,\n      message: \"Error checking if authed sol pub key is permitted.\",\n      error: error.toString(),\n    }),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions for Wrapped Key Encryption in TypeScript\nDESCRIPTION: This code snippet demonstrates how the Access Control Conditions are defined for encrypting the Wrapped Key. It uses the PKP address derived from the pkpSessionSigs to restrict decryption to only those who can generate valid Authentication Signatures from the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain: CHAIN_ETHEREUM,\n        method: '',\n        parameters: [':userAddress'],\n        returnValueTest: {\n        comparator: '=',\n        value: pkpAddress,\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Creating SIWE Messages with Lit Protocol\nDESCRIPTION: Shows how to create a basic SIWE (Sign-In with Ethereum) message using the createSiweMessage helper function. This function allows generating any type of SIWE message with optional fields pre-filled with default values.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createSiweMessage } from '@lit-protocol/auth-helper';\n\n// return siweMessage.prepareMessage()\nconst toSign: string = await createSiweMessage({\n  walletAddress: '',\n  nonce: await litNodeClient.getLatestBlockhash(),\n});\n```\n\n----------------------------------------\n\nTITLE: Converting IPFS CID to Bytes Format\nDESCRIPTION: Utility function to convert an IPFS CID to bytes format for use with PKPPermissions contract interactions. Uses bs58 decoding and converts to hex format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/faq.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getBytesFromMultihash(ipfsId) {\n  const decoded = bs58.decode(ipfsId);\n\n  return `0x${Buffer.from(decoded).toString(\"hex\")}`;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining getEncryptedKey Function Interface in TypeScript\nDESCRIPTION: This code snippet defines the interface for the getEncryptedKey function, including its parameters and return type. It specifies the required inputs like pkpSessionSigs, litNodeClient, and id, and outlines the structure of the returned metadata object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_NETWORKS_KEYS } from '@lit-protocol/types';\n\n/** Get a previously encrypted and persisted private key and its metadata.\n * Note that this method does _not_ decrypt the private key; only the _encrypted_ key and its metadata will be returned to the caller.\n */\nexport async function getEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    id: string,\n  }\n): Promise<{\n  ciphertext: string;\n  dataToEncryptHash: string;\n  publicKey: string;\n  pkpAddress: string;\n  keyType: string;\n  litNetwork: LIT_NETWORKS_KEYS;\n  memo: string;\n  id: string;\n}> \n```\n\n----------------------------------------\n\nTITLE: Querying Encrypted Messages from OrbisDB\nDESCRIPTION: Implementation of querying encrypted messages from OrbisDB using raw SQL. The query retrieves all messages and orders them by creation date in descending order.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = await orbis.getConnectedUser();\nif (user) {\nconst query = await orbis\n    .select()\n    // using raw SQL\n    .raw(\n    `SELECT *\n        FROM ${env.NEXT_PUBLIC_POST_ID} as post\n        ORDER BY created DESC`\n    )\n    .run();\nconst queryResult = query.rows as Post[];\nif (queryResult.length) {\n    queryResult.forEach((el: any) => {\n    setChatMessages((prevMessages) => [\n        ...prevMessages,\n        {\n        text: el.body,\n        sentBy: el.controller.split(\":\")[4]!!,\n        sentAt: new Date(el.created),\n        isChatOwner: address === el.controller.split(\":\")[4]!!,\n        ...el,\n        },\n    ]);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures for Lit Protocol\nDESCRIPTION: TypeScript code for creating session signatures to authenticate decryption requests with the Lit network, using the LitAccessControlConditionResource.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  createSiweMessage,\n  generateAuthSig,\n  LitAccessControlConditionResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n    resourceAbilityRequests: [\n        {\n            resource: new LitAccessControlConditionResource(\n                await LitAccessControlConditionResource.generateResourceString(\n                    accessControlConditions,\n                    dataToEncryptHash\n                )\n            ),\n            ability: LIT_ABILITY.AccessControlConditionDecryption,\n        },\n    ],\n    authNeededCallback: async ({\n        uri,\n        expiration,\n        resourceAbilityRequests,\n        }) => {\n        const toSign = await createSiweMessage({\n            uri,\n            expiration,\n            resources: resourceAbilityRequests,\n            walletAddress: ethersWallet.address,\n            nonce: await litNodeClient.getLatestBlockhash(),\n            litNodeClient,\n        });\n\n        return await generateAuthSig({\n            signer: ethersWallet,\n            toSign,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures for Lit Protocol\nDESCRIPTION: Code to generate PKP (Programmable Key Pair) session signatures using Lit Protocol. These signatures are required for authenticating and authorizing actions within the Lit ecosystem.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data with Crypto Package in JavaScript\nDESCRIPTION: Demonstrates client-side encryption using the Crypto package in Lit Protocol V3. It uses the 'encrypt' function with a public key, secret message, and identity parameter to perform encryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/changes.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst publicKey =\n  '8e29447d7b0666fe41c357dbbdbdac0ac8ac973f88439a07f85fa31fa6fa3cea87c2eaa8b367e1c97764800fb5636892';\n\nconst secretMessage = new Uint8Array([\n  240, 23, 185, 6, 87, 33, 173, 216, 53, 84, 80, 135, 190, 16, 58, 85, 97, 75,\n  3, 192, 215, 82, 217, 5, 40, 65, 2, 214, 40, 177, 53, 150,\n]);\n\nconst identityParam = new Uint8Array([\n  101, 110, 99, 114, 121, 112, 116, 95, 100, 101, 99, 114, 121, 112, 116, 95,\n  119, 111, 114, 107, 115,\n]);\n\nconst ciphertext = encrypt(publicKey, secretMessage, identityParam);\n```\n\n----------------------------------------\n\nTITLE: Defining signMessageWithEncryptedKey Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for the signMessageWithEncryptedKey function that signs messages using wrapped keys. The function takes parameters including PKP session signatures, Lit Node Client instance, network type, ID, and message to sign.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function signMessageWithEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    network: 'evm' | 'solana';\n    id: string;\n    messageToSign: string | Uint8Array;\n  }\n): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Configuring Timelock Access Control Conditions in JavaScript\nDESCRIPTION: This code snippet sets up access control conditions for a timelock mechanism. It uses the latest block timestamp from the Ethereum blockchain and compares it to a specified unix timestamp (1651276942) to determine access rights. The condition allows access when the current time is greater than or equal to the specified timestamp.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/timelock.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"timestamp\",\n    chain: \"ethereum\",\n    method: \"eth_getBlockByNumber\",\n    parameters: [\"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"1651276942\"\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Creating SIWE Messages with Recaps\nDESCRIPTION: Demonstrates how to create SIWE messages with recaps using createSiweMessageWithRecaps function. This implementation requires specific parameters like uri, expiration, and resources.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createSiweMessageWithRecaps } from '@lit-protocol/auth-helper';\n\n// return siweMessage.prepareMessage()\nconst toSign = await createSiweMessageWithRecaps({\n  uri: callbackParams.uri,\n  expiration: callbackParams.expiration,\n  resources: callbackParams.resourceAbilityRequests,\n  walletAddress: person.wallet.address,\n  nonce: await litNodeClient.getLatestBlockhash(),\n  litNodeClient: devEnv.litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching User Identity in Lit Action for Custom Authentication (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use the fetch() function within a Lit Action to authenticate a user and resolve their identity material. It's part of the custom authentication process in Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/custom-auth.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfetch()\n```\n\n----------------------------------------\n\nTITLE: Granting All Valid Capabilities to Access Control Condition in JavaScript\nDESCRIPTION: This code shows how to grant all valid capabilities to a specific access control condition. It creates a session capability object, defines a Lit resource, and adds all valid capabilities for that resource. Note that the Authentication Lit Ability is not valid against an Access Control Condition.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/capability-objects.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('someResource');\n\n// Add all capabilities that are valid and relevant to the specified lit resource.\nsessionCapabilityObject.addAllCapabilitiesForResource(litResource);\n```\n\n----------------------------------------\n\nTITLE: Generating EVM Private Key with Lit Protocol in TypeScript\nDESCRIPTION: This code snippet shows how to generate an EVM private key using Lit Protocol's wrapped keys API. It uses the previously generated PKP session signatures and specifies the network as 'evm'. The function returns the PKP address and the generated public key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { generatePrivateKey } = api;\n\nconst { pkpAddress, generatedPublicKey } = await generatePrivateKey({\n    pkpSessionSigs,\n    network: 'evm',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n    litNodeClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying Proof of Humanity Registration in JavaScript\nDESCRIPTION: This code snippet sets up an access control condition to check if a user is registered with Proof Of Humanity. It uses the isRegistered method of the Proof of Humanity contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"0xC5E9dDebb09Cd64DfaCab4011A0D5cEDaf7c9BDb\",\n    standardContractType: \"ProofOfHumanity\",\n    chain: \"ethereum\",\n    method: \"isRegistered\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Wrapped Key Metadata with Lit Protocol\nDESCRIPTION: This code snippet shows how to use the getEncryptedKey function from the Wrapped Keys API to retrieve metadata for a specific Wrapped Key. It uses the previously generated PKP session signatures, LitNodeClient instance, and a Wrapped Key ID to fetch the metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { getEncryptedKey } = api;\n\nconst wrappedKeyMetadata = await getEncryptedKey({\n    pkpSessionSigs,\n    litNodeClient,\n    id: process.env.WRAPPED_KEY_ID\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Email/SMS OTP Authentication\nDESCRIPTION: Complete implementation of OTP-based authentication including sending passcodes and minting PKPs\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-social.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\nimport { StytchOtpProvider } from '@lit-protocol/providers';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true\n})\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Send one-time passcodes via email or phone number through Stytch\nasync function sendPasscode(method, userId) {  \n  // method: 'email' or 'sms', userId: email or phone number\n  let response;\n  if (method === 'email') {\n    response = await stytchClient.otps.email.loginOrCreate(userId);\n  } else {\n    response = await stytchClient.otps.sms.loginOrCreate(\n      !userId.startsWith('+') ? `+${userId}` : userId\n    );\n  }\n  return response.method_id;\n}\n\n// Get auth method object by validating Stytch JWT and mint PKP after authenticating it\nasync function authenticateWithStytch(method, code, methodId) {\n  // method: 'email' or 'sms', code: OTP code, methodId: method_id returned from sendPasscode\n  \n  // Authenticate the OTP code with Stytch\n  const response = await stytchClient.otps.authenticate(code, methodId, {\n    session_duration_minutes: 60,\n  });\n\n  // Initialize StytchEmailFactorOtp or StytchSmsFactorOtp provider\n  const stytchOtpProvider = new StytchOtpProvider({ relay: litRelay, litNodeClient });\n\n\n  // Get auth method object after authenticating Stytch JWT\n  const authMethod = await stytchOtpProvider.authenticate({ response.session_jwt, response.user_id });\n\n  // -- setting scope for the auth method\n  // <https://developer.litprotocol.com/v3/sdk/wallets/auth-methods/#auth-method-scopes>\n  const options = {\n      permittedAuthMethodScopes: [[AUTH_METHOD_SCOPE.SignAnything]],\n  };\n  // Mint PKP using the auth method\n  const mintTx = await stytchOtpProvider.mintPKPWithAuthMethods(\n      [authMethod],\n      options\n  );\n  // Fetch PKPs associated with the authenticated social account\n  const pkps = await stytchOtpProvider.getPKPsForAuthMethod(authMethod);\n  return pkps;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPEthersWallet with Auth Context in Lit Protocol 3.2.0\nDESCRIPTION: This code snippet shows how to initialize a PKPEthersWallet in Lit Protocol version 3.2.0. It demonstrates the new approach of using an auth context instead of directly passing session signatures, simplifying the wallet initialization process.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.2.0.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst AUTHSIG = {\n  \"sig\": \"0x...\",\n  \"derivedVia\": \"web3.eth.personal.sign\",\n  \"signedMessage\": \"localhost wants you to sign in with your Ethereum account:\\n0x...\\n\\nHello World\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: eoeo0dsvyLL2gcHsC\\nIssued At: 2023-11-17T15:04:20.324Z\\nExpiration Time: 2215-07-14T15:04:20.323Z\",\n  \"address\": \"0x...\"\n};\n\nconst PKP_PUBLIC_KEY = `0x...`;\n\nconst authNeededCallback = async (params) => {\n  const response = await client.signSessionKey({\n    statement: params.statement,\n    authMethods: [\n      {\n        authMethodType: 1,\n        accessToken: JSON.stringify(AUTHSIG),\n      },\n    ],\n    pkpPublicKey: PKP_PUBLIC_KEY,\n    expiration: params.expiration,\n    resources: params.resources,\n    chainId: 1,\n  });\n  return response.authSig;\n};\n\nconst resourceAbilities = [\n  {\n    resource: new LitActionResource('*'),\n    ability: LitAbility.PKPSigning,\n  },\n];\n\nconst pkpWallet = new PKPEthersWallet({\n  pkpPubKey: PKP_PUBLIC_KEY,\n  rpc: \"https://chain-rpc.litprotocol.com/http\",\n  litNetwork: globalThis.LitCI.network,\n  authContext: {\n    client: client,\n    getSessionSigsProps: {\n      chain: 'ethereum',\n      resourceAbilityRequests: resourceAbilities,\n      authNeededCallback,\n    },\n  },\n});\n\nawait pkpWallet.init();\n\nconst signature = await pkpWallet.signMessage(TO_SIGN);\n```\n\n----------------------------------------\n\nTITLE: Including Lit JS SDK V2 via Script Tag\nDESCRIPTION: This HTML snippet demonstrates how to include the Lit JS SDK V2 using a script tag for web applications.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"https://cdn.jsdelivr.net/npm/@lit-protocol/lit-node-client-vanilla@serrano/lit-node-client.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Checking KYVE Funders List Membership\nDESCRIPTION: Validates if a user is present in the KYVE funders list. Uses JSONPath to extract and check funder addresses.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/other-chains/cosmos-conditions.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \"/kyve/registry/v1beta1/funders_list/0\",\n    chain: \"kyve\",\n    returnValueTest: {\n      key: \"$.funders.*.account\",\n      comparator: \"contains\",\n      value: \":userAddress\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Granting All Valid Capabilities to Access Control Condition in JavaScript\nDESCRIPTION: This code shows how to grant all valid capabilities to an access control condition. It creates a session capability object and adds all relevant capabilities to the specified Lit resource.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/capability-objects.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('someResource');\n\n// Add all capabilities that are valid and relevant to the specified lit resource.\nsessionCapabilityObject.addAllCapabilitiesForResource(litResource);\n```\n\n----------------------------------------\n\nTITLE: Setting Auth Context with Lit Actions using different authentication methods\nDESCRIPTION: This example demonstrates how to connect to Lit nodes, execute a Lit Action that accesses the Lit.Auth object, and work with different authentication methods. It shows how to set up and run a Lit Action with a Google OAuth JWT as the authentication method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/overview.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n\n// this code will be run on the node\nconst litActionCode = `\nconst go = async () => {\n  Lit.Actions.setResponse({response: JSON.stringify({\"Lit.Auth\": Lit.Auth})})\n};\n\ngo();\n`;\n\n// you need an AuthSig to auth with the nodes\n// normally you would obtain an AuthSig by calling LitJsSdk.checkAndSignAuthMessage({chain})\nconst authSig = {\n  sig: \"0x2bdede6164f56a601fc17a8a78327d28b54e87cf3fa20373fca1d73b804566736d76efe2dd79a4627870a50e66e1a9050ca333b6f98d9415d8bca424980611ca1c\",\n  derivedVia: \"web3.eth.personal.sign\",\n  signedMessage:\n    \"localhost wants you to sign in with your Ethereum account:\\n0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\\n\\nThis is a key for Partiful\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: 1LF00rraLO4f7ZSIt\\nIssued At: 2022-06-03T05:59:09.959Z\",\n  address: \"0x9D1a5EC58232A894eBFcB5e466E3075b23101B89\",\n};\n\nconst runLitAction = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    litNetwork: \"localhost\",\n    debug: true,\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    authSig,\n    authMethods: [\n      // {\n      //   // discord oauth\n      //   accessToken: \"M1Y1WnYnavzmSaZ6p1LBLsNFn2iiu0\",\n      //   authMethodType: 4,\n      // },\n      // {\n      //   // google oauth\n      //   accessToken:\n      //     \"ya29.a0Aa4xrXMCyLStBQzLhC8il8YRPXIkEEgno9nB4PKvjCi6oIu-uIjeIoyfQoR99TcZf0IUMPfJfjRIJyIXtLk_kXLa5BmdUyJcJGP8SB4-UjlebOILidfItC8KR1sQR9LSFX55cw3_GTa5IqCOCTXME38z5ZMZaCgYKATASARASFQEjDvL9HinQH3Mk1UclCD011YbLfQ0163\",\n      //   authMethodType: 5,\n      // },\n      // {\n          // email / sms\n      //   accessToken: \"eyJhbGciOiJzZWNwMjU2azEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJMSVQtUHJvdG9jb2wiLCJzdWIiOiJMSVQtT1RQIiwiaWF0IjoxNjgzMjIzNjIyMDg5LCJleHAiOjE2ODMyMjU0MjIwODksIm9yZ0lkIjoiTElUIiwicm9sZSI6InVzZXIiLCJleHRyYURhdGEiOiIrMTIwMTQwNzIwNzN8MjAyMy0wNS0wNFQxODowNzowMi4wODkxODgrMDA6MDAifQ.eyJyIjoiOTRiOWE1ODkyODFlYzdlYmZlZTdjOGRjMjU0YTk1NGY5NjY1N2IzZmRkNmFlMWIwZThmMmY1OWIxMWYwNTU1YSIsInMiOiI0NWNlNTA0YTBkZjFlZWFkMWYxMGIyYTQ1MjU4ZjlhOTI5ZTY5ODYzYjIzNDdlZGViMmRkODMxM2Y4NDVhNDA1In0\"\n      //   authMethodType: 7,\n      // } \n      {\n        // google oauth JWT\n        accessToken:\n          \"eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc3Y2MwZWY0YzcxODFjZjRjMGRjZWY3YjYwYWUyOGNjOTAyMmM3NmIiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDg5OTYwNTQyNzMzNjA1NjgxMzIiLCJlbWFpbCI6ImdldmVuc3RlZUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXRfaGFzaCI6IlVYV1Z1eEJsdGswcEhKclllOEFXTUEiLCJpYXQiOjE2NjcxNjgyMTUsImV4cCI6MTY2NzE3MTgxNX0.ejZu5bADJ6cUsovV7otHAafy0mqWZBAtN860jvBdVe38XUi0v-eB5WWBPMD5zXcJxbXFvaPWCX8nTaE6S24cNNHJw0hq15irjRZeg9D2i7ToitR1LZSQ3rPCDQZPX4xYn7G-FH7C1DQ-7NEDMmr9ge4B6Qs4pT5Mj8ESVlA29yZjKCfk-zL7F5b6W0EOIA6G9rj6-3HgtazkHfIGHAtfBz4dqHjC4HJncHJzqIm9Y8eSBBnN-ZhYUr3cWxGCuFIw3yrGccv5_khfhbbk6TqdSeMO9YNWN3otiVB8Nwu2sb9VsllFoHIE0uGSzVZVbJgSK1GsGbJZe76ubLuObI5YFw\",\n        authMethodType: 6,\n      },\n    ],\n    // all jsParams can be used anywhere in your litActionCode\n    jsParams: {\n      // this is the string \"Hello World\" for testing\n    },\n  });\n  console.log(\"results: \", JSON.stringify(results.response, null, 2));\n};\n\nrunLitAction();\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data with Lit Protocol\nDESCRIPTION: TypeScript code demonstrating how to encrypt a string using the Lit SDK's encryptString method, which returns ciphertext and a data hash.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst dataToEncrypt = \"The answer to the universe is 42.\";\n\nconst { ciphertext, dataToEncryptHash } = await encryptString(\n    {\n        accessControlConditions,\n        dataToEncrypt,\n    },\n    litNodeClient\n);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Blockchain with LitContracts\nDESCRIPTION: Establishes connection to the blockchain using provided or default settings.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nawait LitContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather-based Lit Action in JavaScript\nDESCRIPTION: This Lit Action code checks if the forecast temperature is below a specified maximum. It fetches weather data from an API and returns true if the temperature condition is met.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/litActionConditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst go = async (maxTemp) => {\n  const url = \"https://api.weather.gov/gridpoints/LWX/97,71/forecast\";\n  try {\n    const response = await fetch(url).then((res) => res.json());\n    const nearestForecast = response.properties.periods[0];\n    const temp = nearestForecast.temperature;\n    return temp < parseInt(maxTemp);\n  } catch (e) {\n    console.log(e);\n  }\n  return false;\n};\n```\n\n----------------------------------------\n\nTITLE: Generating SessionSigs with Provider\nDESCRIPTION: Shows how to generate session signatures using an authenticated provider with specific chain and ability requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/email-sms.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  pkpPublicKey: '<YOUR PKP PUBLIC KEY>'\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [{\n        resource: litResource,\n        ability: LIT_ABILITY.AccessControlConditionDecryption\n      }\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Error Handling with VError in JavaScript\nDESCRIPTION: Updated error handling logic using VError instances for extended error information.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { VError } from '@openagenda/verror';\n\ntry {\n  // SDK operations\n} catch (error) {\n  if (error instanceof VError) {\n    // Extract extended error information\n    const info = VError.info(error);\n    console.error('Error message:', error.message);\n    console.error('Error info:', info);\n  } else {\n    // Handle other errors\n    console.error('An unexpected error occurred:', error);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Auth Method Scopes for PKPs in JavaScript\nDESCRIPTION: This code snippet demonstrates how to verify the scopes of an auth method for a Programmable Key Pair (PKP) using the Lit Protocol SDK. It checks if the 'sign anything' and 'personal sign' scopes are set to false.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE } from '@lit-protocol/constants';\n\nconst authMethod = {\n  authMethodType: AUTH_METHOD_TYPE.EthWallet,\n  accessToken: ...,\n};\n\nconst authId = await getAuthIdByAuthMethod(authMethod);\n\nconst scopes = await contractClient.pkpPermissionsContract.read.getPermittedAuthMethodScopes(\n  tokenId,\n  AUTH_METHOD_TYPE.EthWallet,\n  authId,\n  3 // there are only 2 scope numbers atm. and index 0 doesn't count\n);\n\n// -- validate both scopes should be false\nif (scopes[1] !== false) {\n  return fail('scope 1 (sign anything) should be false');\n}\n\nif (scopes[2] !== false) {\n  return fail('scope 2 (personal sign) should be false');\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Messages with Wrapped Key for Solana\nDESCRIPTION: Implementation for signing messages using a wrapped key on Solana network with Lit Protocol. Uses the same signature generation pattern but configured for Solana network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { importPrivateKey } = api;\n\nconst signature = await signMessageWithEncryptedKey({\n  pkpSessionSigs,\n  litNodeClient,\n  network: 'solana',\n  id: process.env.WRAPPED_KEY_ID,\n  messageToSign: \"The answer to the Universe is 42.\",\n});\n```\n\n----------------------------------------\n\nTITLE: Decrypting Content with Lit Protocol\nDESCRIPTION: Shows the process of fetching encrypted data from Arweave, obtaining the symmetric key, and decrypting the content using Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/bundlrxarweave.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst chain = \"ethereum\";\n\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });\n\nconst accessControlConditions = dataOnArweave.accessControlConditions;\n\nconst encryptedSymmetricKey = LitJsSdk.uint8arrayToString(\n  dataOnArweave.encryptedSymmetricKey,\n  \"base16\"\n);\n\nconst symmetricKey = await litNodeClient.getEncryptionKey({\n  accessControlConditions,\n  toDecrypt: encryptedSymmetricKey,\n  chain,\n  authSig,\n});\n\nconst decryptString = await LitJsSdk.decryptString(\n  dataURItoBlob(dataOnArweave.encryptedData),\n  symmetricKey\n);\n```\n\n----------------------------------------\n\nTITLE: Importing an Ethereum Private Key as Wrapped Key in TypeScript\nDESCRIPTION: This code snippet shows how to import an Ethereum private key as a wrapped key using the Lit Protocol. It uses the importPrivateKey function from the @lit-protocol/wrapped-keys package.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { importPrivateKey } from \"@lit-protocol/wrapped-keys\";\n\nconst { pkpAddress, id } = await importPrivateKey({\n    pkpSessionSigs,\n    litNodeClient,\n    privateKey: process.env.ETHEREUM_PRIVATE_KEY,\n    publicKey: process.env.ETHEREUM_PUBLIC_KEY,\n    keyType: 'K256',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Lit Action Access Control Conditions in JavaScript\nDESCRIPTION: This code snippet demonstrates how to set up access control conditions using a Lit Action stored on IPFS. It specifies the IPFS CID, the function to call, parameters to pass, and the expected return value for granting access.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/lit-action-conditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"ipfs://QmcgbVu2sJSPpTeFhBd174FnmYmoVYvUFJeDkS7eYtwoFY\",\n    standardContractType: \"LitAction\",\n    chain: \"ethereum\",\n    method: \"go\",\n    parameters: [\"40\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPEthersWallet with Session Signatures in Lit Protocol 3.1.x\nDESCRIPTION: This code snippet demonstrates how to initialize a PKPEthersWallet and obtain session signatures in Lit Protocol version 3.1.x or older. It includes creating an auth signature, setting up a session key, and initializing the wallet with controller session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.2.0.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst AUTHSIG = {\n  \"sig\": \"0x...\",\n  \"derivedVia\": \"web3.eth.personal.sign\",\n  \"signedMessage\": \"localhost wants you to sign in with your Ethereum account:\\n0x...\\n\\nHello World\\n\\nURI: https://localhost/login\\nVersion: 1\\nChain ID: 1\\nNonce: eoeo0dsvyLL2gcHsC\\nIssued At: 2023-11-17T15:04:20.324Z\\nExpiration Time: 2215-07-14T15:04:20.323Z\",\n  \"address\": \"0x...\"\n};\n\nconst PKP_PUBLIC_KEY = `0x...`;\n\nconst sessionKeyPair = client.getSessionKey();\n  const authNeededCallback = async (params) => {\n    const response = await client.signSessionKey({\n      statement: params.statement,\n      authMethods: [\n        {\n          authMethodType: 1,\n          accessToken: JSON.stringify(AUTHSIG),\n        },\n      ],\n      pkpPublicKey: PKP_PUBLIC_KEY,\n      expiration: params.expiration,\n      resources: params.resources,\n      chainId: 1,\n    });\n    return response.authSig;\n  };\n\n  const resourceAbilities = [\n    {\n      resource: new LitActionResource('*'),\n      ability: LitAbility.PKPSigning,\n    },\n  ];\n\n  const sessionSigs = await client.getSessionSigs({\n    chain: 'ethereum',\n    expiration: new Date(Date.now() + 60_000 * 60).toISOString(),\n    resourceAbilityRequests: resourceAbilities,\n    sessionKey: sessionKeyPair,\n    authNeededCallback,\n  });\n\n  const pkpWallet = new PKPEthersWallet({\n    pkpPubKey: PKP_PUBLIC_KEY,\n    controllerSessionSigs: sessionSigs,\n    controllerAuthMethods: [],\n  });\n\n  await pkpWallet.init();\n\n  const signature = await pkpWallet.signMessage(TO_SIGN);\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Node Client\nDESCRIPTION: Basic setup to instantiate the Lit Node client and define the blockchain network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient();\nconst chain = \"ethereum\";\n```\n\n----------------------------------------\n\nTITLE: Encrypting and Writing Data\nDESCRIPTION: Process of encrypting a string and writing it to Ceramic using the Lit integration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToEncrypt = 'This is what we want to encrypt on Lit and then store on ceramic'\nconst response = litCeramicIntegration\n   .encryptAndWrite(stringToEncrypt, accessControlConditions)\n   .then((streamID) => console.log(streamID))\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Ceramic using OrbisEVMAuth\nDESCRIPTION: TypeScript function to authenticate users with Ceramic using OrbisEVMAuth. This creates a session that lives in the browser's local storage.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst StartOrbisAuth = async (): Promise<OrbisConnectResult | undefined> => {\n    const auth = new OrbisEVMAuth(window.ethereum);\n    // Authenticate - this option persists the session in local storage\n    const authResult: OrbisConnectResult = await orbis.connectUser({\n        auth,\n    });\n    if (authResult.auth.session) {\n        return authResult;\n    }\n\n    return undefined;\n    };\n```\n\n----------------------------------------\n\nTITLE: Initializing LitAuthClient and Google Provider\nDESCRIPTION: Setup for LitAuthClient and configuration of Google authentication provider. Includes initialization of the client with relay config and provider setup with redirect URI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/socialLogin.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Set up LitAuthClient\nconst litAuthClient = new LitAuthClient({\n  litRelayConfig: {\n     // Request a Lit Relay Server API key here: https://forms.gle/RNZYtGYTY9BcD9MEA\n    relayApiKey: '<Your Lit Relay Server API Key>',\n  },\n});\n\n// Initialize Google provider\nlitAuthClient.initProvider(ProviderType.Google, {\n  // The URL of your web app where users will be redirected after authentication\n  redirectUri: '<Your redirect URI>',\n});\n\n// Begin login flow with Google\nasync function authWithGoogle() {\n  const provider = litAuthClient.getProvider(\n    ProviderType.Google\n  );\n  await provider.signIn();\n}\n```\n\n----------------------------------------\n\nTITLE: Generating AuthSig with Lit Protocol\nDESCRIPTION: Shows how to generate an authentication signature (authSig) using the generateAuthSig function, which ensures the correct structure of the authSig object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n\tgenerateAuthSig,\n\tcreateSiweMessageWithRecaps\n} from '@lit-protocol/auth-helper';\n\nconst wallet = new ethers.Wallet.createRandom();\nconst preparedSiweMessage = await createSiweMessageWithRecap({...})\n\nconst authSig = await generateAuthSig({\n  signer: wallet,\n  toSign: preparedSiweMessage,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContracts with Ethers Wallet in JavaScript\nDESCRIPTION: This code snippet demonstrates how to initialize LitContracts using an Ethers wallet when the NFT was not sent to the PKP. It uses the wallet that minted the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\nimport { ethers } from 'ethers';\nimport { LIT_RPC } \n\nconst provider = new ethers.providers.JsonRpcProvider(\n     LIT_RPC.CHRONICLE_YELLOWSTONE\n);\nconst wallet = new ethers.Wallet('<Your private key>', provider);\nconst litContracts = new LitContracts({\n  signer: wallet, // pkp wallet of the owner of the pkp NFT\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Checking Auth Method Permissions in Lit Action\nDESCRIPTION: This code snippet shows how to check if a Solana public key is authorized to use a specific PKP by querying the Lit PKP permissions smart contract. It uses the Lit Actions API to verify if the Auth Method Type and ID are permitted for the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/siws-pkp-session-sigs.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nreturn Lit.Actions.isPermittedAuthMethod({\n    tokenId: pkpTokenId,\n    authMethodType: SIWS_AUTH_METHOD_TYPE,\n    userId: ethers.utils.arrayify(usersAuthMethodId),\n});\n```\n\n----------------------------------------\n\nTITLE: Signing User Operations with PKP Wallet for Pimlico\nDESCRIPTION: Demonstrates how to use the PKP Wallet to sign user operations for submission through Pimlico's infrastructure.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst signature = await pkpWallet.signMessage(\n\tethers.utils.arrayify(await entryPoint.getUserOpHash(userOperation)),\n)\n \nuserOperation.signature = signature\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst initCode = ethers.utils.hexConcat([\n\tSIMPLE_ACCOUNT_FACTORY_ADDRESS,\n\tsimpleAccountFactory.interface.encodeFunctionData(\"createAccount\", [pkpWallet.address, 0]),\n])\n```\n\n----------------------------------------\n\nTITLE: Complex Nested Lit Action Example\nDESCRIPTION: Demonstrates a more complex nested Lit Action that handles ECDSA signing through a child action.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nconst litActionCode = `\nconst signEcdsa = async () => {\n  // this Lit Action simply requests an ECDSA signature share from the Lit Node\n  const message = new Uint8Array(\n    await crypto.subtle.digest('SHA-256', new TextEncoder().encode('Hello world'))\n  );\n  const resp = await Lit.Actions.call({\n    ipfsId: \"QmRwN9GKHvCn4Vk7biqtr6adjXMs7PzzYPCzNCRjPFiDjm\",\n    params: {\n      // this is the string \"Hello World\" for testing\n      toSign: message,\n      publicKey:\n        \"0x02e5896d70c1bc4b4844458748fe0f936c7919d7968341e391fb6d82c258192e64\",\n      sigName: \"childSig\",\n    },\n  });\n\n  console.log(\"results: \", resp);\n};\n\nif (functionToRun === \"signEcdsa\") {\n  signEcdsa();\n}\n`;\n```\n\n----------------------------------------\n\nTITLE: Configuring Timelock Access Control Conditions in JavaScript\nDESCRIPTION: This code snippet defines access control conditions for a timelock mechanism. It compares the latest block timestamp from the Ethereum blockchain with a specified unix timestamp (1651276942) to determine access. The user will be able to unlock after this timestamp.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/timelock.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"timestamp\",\n    chain: \"ethereum\",\n    method: \"eth_getBlockByNumber\",\n    parameters: [\"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"1651276942\"\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures for Lit Protocol\nDESCRIPTION: Demonstrates how to generate session signatures using an authenticated WebAuthn credential, which are required for various Lit Protocol operations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/web-authn.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  pkpPublicKey: '<YOUR PKP PUBLIC KEY>'\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [{\n        resource: litResource,\n        ability: LIT_ABILITY.AccessControlConditionDecryption\n      }\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing a Solana Private Key as Wrapped Key in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import a Solana private key as a wrapped key using the Lit Protocol. It uses the importPrivateKey function from the @lit-protocol/wrapped-keys package, specifying the key type as 'ed25519'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { importPrivateKey } from \"@lit-protocol/wrapped-keys\";\n\nconst { pkpAddress, id } = await importPrivateKey({\n    pkpSessionSigs,\n    litNodeClient,\n    privateKey: process.env.SOLANA_PRIVATE_KEY,\n    publicKey: process.env.SOLANA_PUBLIC_KEY,\n    keyType: 'ed25519',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Lit Protocol Integration\nDESCRIPTION: This bash snippet shows how to install the necessary npm packages for integrating with Lit Protocol, including auth helpers, constants, node client, wrapped keys, and ethers library.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Generating Custom Auth Method in Lit Action for SIWS Verification\nDESCRIPTION: This code creates the same custom Auth Method Type and ID within a Lit Action to verify a Solana public key. It uses ethers.js to generate consistent hash values matching those used during PKP minting.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/siws-pkp-session-sigs.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst SIWS_AUTH_METHOD_TYPE = ethers.utils.keccak256(\n    ethers.utils.toUtf8Bytes(\"Lit Developer Guide Solana SIWS Example\")\n);\nconst usersAuthMethodId = ethers.utils.keccak256(\n    ethers.utils.toUtf8Bytes(`siws:${solanaPublicKey}`)\n);\n```\n\n----------------------------------------\n\nTITLE: Pairing PKPWalletConnect with URI\nDESCRIPTION: Pairs the PKPWalletConnect instance with a dApp using the provided URI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Pair using the given URI\nawait pkpWalletConnect.pair({ uri: uri });\n```\n\n----------------------------------------\n\nTITLE: EthereumLitTransaction Interface for EVM Transaction Signing\nDESCRIPTION: Interface defining the structure of an unsigned Ethereum transaction for use with the signTransactionWithEncryptedKey function. It includes properties for the recipient address, transaction value, chain ID, gas price, gas limit, and optional data in hex format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EthereumLitTransaction {\n  chain: string;\n  toAddress: string;\n  value: string;\n  chainId: number;\n  gasPrice?: string;\n  gasLimit?: number;\n  dataHex?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing PKP Helper Contract in Solidity\nDESCRIPTION: This code snippet references the PKP Helper contract used for minting PKPs on the Chronicle network. It provides a link to the contract's source code on GitHub.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/minting.md#2025-04-18_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// PKP Helper contract on Chronicle\n// https://github.com/LIT-Protocol/LitNodeContracts/blob/main/contracts/PKPHelper.sol\n```\n\n----------------------------------------\n\nTITLE: LitRelay with Stytch Integration\nDESCRIPTION: Demonstrates integration between LitRelay and Stytch authentication, including provider setup and key claiming.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { StytchOtpProvider } from '@lit-protocol/providers';\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: true,\n  });\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\n// Initialize StytchOtp provider\nconst stytchProvider = new StytchOtpProvider({ relay, litNodeClient });\n\nconst authMethod = await stytchProvider.authenticate({\n  accessToken: sessionStatus.session_jwt \n});\n\nconst claimResp = session.claimKeyId({\n\tauthMethod\n});\n\nconsole.log(\"mint tx hash: \", res.mintTx);\nconsole.log(\"pkp public key: \", res.pubkey);\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethers Signer with Private Key\nDESCRIPTION: Creates an Ethers wallet instance using a private key from environment variables and connects it to the Lit RPC endpoint.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-session-sigs.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst ethersSigner = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY,\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Access Control Using IPFS ID in JavaScript\nDESCRIPTION: This snippet demonstrates how to set up access control conditions using the IPFS ID of the current action. It's used to restrict decryption to a specific Lit Action implementation, ensuring sensitive data like API keys remain secure within the TEE.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/encryption.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  contractAddress: '',\n  standardContractType: '',\n  chain,\n  method: 'eth_getBalance',\n  parameters: [':currentActionIpfsId', 'latest'],\n  returnValueTest: {\n    comparator: '==',\n    value: '<your ipfs cid>',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing decryptAndCombine in Lit Action\nDESCRIPTION: Demonstrates how to use the decryptAndCombine function within a Lit Action to decrypt previously encrypted content. Shows execution of the decryption process using session signatures and handling the response.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/combining-decryption-shares.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst code = `(async () => {\n  const resp = await Lit.Actions.decryptAndCombine({\n    accessControlConditions,\n    ciphertext,\n    dataToEncryptHash,\n    authSig: null,\n    chain: 'ethereum',\n  });\n\n  Lit.Actions.setResponse({ response: resp });\n})();`\n\nconst res = await client.executeJs({\n    code,\n    sessionSigs: {} // your session\n    jsParams: {\n        accessControlConditions,\n        ciphertext,\n        dataToEncryptHash\n    }\n});\n\nconsole.log(\"decrypted content sent from lit action:\", res);\n```\n\n----------------------------------------\n\nTITLE: Verifying PKP Permissions\nDESCRIPTION: Demonstrates how to verify the permissions of a minted PKP by checking its permitted auth method scopes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\n\nconst authId = await getAuthIdByAuthMethod(authMethod);\nawait contractClient.pkpPermissionsContract.read.getPermittedAuthMethodScopes(\n  mintInfo.pkp.tokenId,\n  AUTH_METHOD_TYPE.EthWallet,\n  authId,\n  3\n);\n\nconst signAnythingScope = scopes[1];\nconst personalSignScope = scopes[2];\n```\n\n----------------------------------------\n\nTITLE: Delegating Capacity Credits to PKP\nDESCRIPTION: Shows how to delegate usage of Capacity Credits to a PKP, allowing it to make requests to the Lit network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nconst { capacityDelegationAuthSig } =\n  await litNodeClient.createCapacityDelegationAuthSig({\n    uses: '1',\n    dAppOwnerWallet: wallet,\n    capacityTokenId: capacityTokenIdStr,\n    delegateeAddresses: [secondWalletPKPInfo.ethAddress],\n  });\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK V2 in Node.js\nDESCRIPTION: This code snippet shows how to import the Lit JS SDK V2 in a Node.js environment after installation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n```\n\n----------------------------------------\n\nTITLE: Installing Lit JS SDK V2 for Browser and Node Environments\nDESCRIPTION: Command to install the Lit JS SDK V2 package for both browser and Node environments using npm.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client@serrano\n```\n\n----------------------------------------\n\nTITLE: Checking ERC20 Token Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses at least one ERC20 token. It uses the balanceOf method of the ERC20 contract to verify if the user's balance is greater than zero.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2',\n    standardContractType: 'ERC20',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Migrating from PKPClient to PKPEthersWallet\nDESCRIPTION: Example showing how to replace PKPClient usage with the new PKPEthersWallet implementation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n// Old\nconst pkpClient = new PKPClient(...);\n\n// New\nconst pkpEthersWallet = new PKPEthersWallet(...);\n```\n\n----------------------------------------\n\nTITLE: Checking Token Balance in Solana\nDESCRIPTION: Verifies if a user owns at least one token of a specific type. Uses a custom 'balanceOfToken' RPC call to check token balance.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"balanceOfToken\",\n    params: [\"FrYwrqLcGfmXrgJKcZfrzoWsZ3pqQB9pjjUC9PxSq3xT\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain,\n    returnValueTest: {\n      key: \"$.amount\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Exporting Wrapped Key Private Key in TypeScript\nDESCRIPTION: This snippet demonstrates how to export the private key of a wrapped key using Lit Protocol. It uses the previously generated PKP session signatures and the LitNodeClient. The function returns the unencrypted private key, so caution is advised when handling the result.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { api } from \"@lit-protocol/wrapped-keys\";\n\nconst { exportPrivateKey } = api;\n\nconst exportedPrivateKeyResult = await exportPrivateKey({\n    pkpSessionSigs,\n    litNodeClient,\n    id: process.env.WRAPPED_KEY_ID\n    network: process.env.EVM_OR_SOLANA\n});\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data with Lit Protocol in Node.js\nDESCRIPTION: Function to decrypt data using Lit Protocol node client. Handles session signature generation and decryption process using provided ciphertext, hash, and access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nasync function decryptData(\n  ciphertext: string,\n  dataToEncryptHash: string,\n  accessControlConditions: object[]\n): Promise<string> {\n  const litNodeClient = await getLitNodeClient();\n\n  const sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    resourceAbilityRequests: [\n      {\n        resource: new LitAccessControlConditionResource(\"*\"),\n        ability: LIT_ABILITY.AccessControlConditionDecryption,\n      },\n    ],\n    authNeededCallback: async (params: any) => {\n      const toSign = await createSiweMessageWithRecaps({\n        uri: params.uri,\n        expiration: params.expiration,\n        resources: params.resourceAbilityRequests,\n        walletAddress: await (await new ethers.Wallet(process.env.PRIVATE_KEY!)).getAddress(),\n        nonce: await litNodeClient.getLatestBlockhash(),\n        litNodeClient,\n      });\n\n      return await generateAuthSig({\n        signer: new ethers.Wallet(process.env.PRIVATE_KEY!),\n        toSign,\n      });\n    },\n  });\n\n  const decryptedString = await LitJsSdk.decryptToString(\n    {\n      accessControlConditions,\n      chain: \"ethereum\",\n      ciphertext,\n      dataToEncryptHash,\n      sessionSigs,\n    },\n    litNodeClient\n  );\n\n  return decryptedString;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Session Proposal Events in JavaScript\nDESCRIPTION: This code snippet demonstrates how to subscribe to and handle session proposal events in PKPWalletConnect. It logs the proposal, approves it, and then logs active sessions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\npkpWalletConnect.on(\"session_proposal\", async (proposal) => {\n  console.log(\"Received session proposal: \", proposal);\n\n  // Accept session proposal\n  await pkpWalletConnect.approveSessionProposal(proposal);\n\n  // Log active sessions\n  const sessions = Object.values(pkpWalletConnect.getActiveSessions());\n  for (const session of sessions) {\n    const { name, url } = session.peer.metadata;\n    console.log(`Active Session: ${name} (${url})`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing and Connecting LitNodeClient\nDESCRIPTION: Code to create and connect a LitNodeClient instance to the datil-test Lit network. This client is necessary for interacting with the Lit Protocol network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-lit-action-session-sigs.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlet litNodeClient: LitNodeClient;\n\nlitNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      debug: false,\n    });\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Rendering SupportedChainCard Component for EVM Chains\nDESCRIPTION: Renders the SupportedChainCard component with specific props to display information about supported EVM-based chains. The component is given a title and className to control its appearance.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/resources/supported-chains.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<SupportedChainCard\n  title=\"EVM Based Chains\"\n  className=\"supported-chains\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Verifying Minimum ETH Balance in JavaScript\nDESCRIPTION: This code snippet sets up an access control condition to check if a user's ETH balance is at least 0.00001 ETH. It uses the eth_getBalance method and compares the result in Wei.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '',\n    standardContractType: '',\n    chain,\n    method: 'eth_getBalance',\n    parameters: [\n      ':userAddress',\n      'latest'\n    ],\n    returnValueTest: {\n      comparator: '>=',\n      value: '10000000000000'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Instantiating Ethers Signer for Lit Protocol\nDESCRIPTION: This snippet demonstrates how to create an Ethers signer using a private key from an environment variable. The signer is connected to the Lit Protocol RPC.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitNodeClient for Lit Protocol in TypeScript\nDESCRIPTION: This snippet shows how to create and connect a LitNodeClient instance to the Lit network. It uses the datil-dev network for development purposes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Wallet Address in Solana\nDESCRIPTION: Validates if the user owns a specific wallet address. Compares the user's verified wallet address against a specified address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"\",\n    params: [\":userAddress\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \"=\",\n      value: \"88PoAjLoSqrTjH2cdRWq4JEezhSdDBw3g7Qa6qKQurxA\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures in Lit Action\nDESCRIPTION: This code shows how to signal the Lit network to generate Session Signatures using a PKP. By returning a specific response format, the Lit network will generate and return Session Signatures to the client.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/siws-pkp-session-sigs.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nreturn Lit.Actions.setResponse({ response: \"true\" });\n```\n\n----------------------------------------\n\nTITLE: Initializing Irys Uploader\nDESCRIPTION: Setup Irys uploader instance with Ethereum wallet integration for storing encrypted data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Uploader } from \"@irys/upload\";\nimport { Ethereum } from \"@irys/upload-ethereum\";\n \nconst getIrysUploader = async () => {\n  const irysUploader = await Uploader(Ethereum).withWallet(process.env.PRIVATE_KEY);\n  return irysUploader;\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK for Browser and Node\nDESCRIPTION: Command to install the Lit Protocol SDK package that works in both browser and Node environments using yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Checking Specific Wallet Address in JavaScript\nDESCRIPTION: This snippet defines an access control condition to verify if a user possesses a specific wallet address. It directly compares the user's address with the specified address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '',\n    standardContractType: '',\n    chain,\n    method: '',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: '0x50e2dac5e78B5905CB09495547452cEE64426db2'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Protocol Connection\nDESCRIPTION: Code to establish connection with Lit Protocol nodes, which is required before performing JWT operations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/jwt-auth.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNodeClient = new LitJsSdk.LitNodeClient();\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Conditional Signing with Lit Actions in React\nDESCRIPTION: A React project demonstrating conditional signing using Lit Actions. It checks Ether balance and transaction timing before returning a signed JSON response.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/toolsAndExamples.md#2025-04-18_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Full code available at: https://replit.com/@lit/Lit-Actions-Conditional-Signing#lit-actions_sign_api_response/src/App.js\n```\n\n----------------------------------------\n\nTITLE: Using Program Derived Address (PDA) in RPC Call\nDESCRIPTION: Demonstrates how to derive and use a PDA as a parameter in a getBalance RPC call.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/sol-rpc-conditions.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  {\n    method: \"getBalance(getPDA)\",\n    params: [],\n    pdaParams: [\n      \"chatGL6yNgZT2Z3BeMYGcgdMpcBKdmxko4C5UhEX4To\",\n      \"delegate-wallet\",\n      \":userAddress\",\n    ],\n    pdaInterface: { offset: 8, fields: { owner_wallet: 32 } },\n    pdaKey: \"owner_wallet\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit v2 Network Connection\nDESCRIPTION: Class implementation for connecting to the old Lit network using SDK v2, establishing connection to LitNodeClient\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass LitV2 {\n  private litNodeClient;\n\n  async connect() {\n    const client = new LitJsSdk.LitNodeClient();\n    await client.connect();\n    this.litNodeClient = client;\n  }\n}\n\nexport default new Lit();\n```\n\n----------------------------------------\n\nTITLE: Creating AuthSig with SIWE Parameters\nDESCRIPTION: Demonstrates how to create an AuthSig with Sign-In with Ethereum (SIWE) parameters for use in contract conditions. Includes base64url encoding of parameters.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/customContractCalls.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nlet tokenId = \"8\";\n// base64url encode the param\nlet encodedSiweResource = LitJsSdk.uint8arrayToString(\n  LitJsSdk.uint8arrayFromString(tokenId, \"utf8\"),\n  \"base64url\"\n);\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({\n  chain,\n  resources: [`litParam:tokenId:${encodedSiweResource}`],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Documentation Page Layout in JSX\nDESCRIPTION: Imports various React components used to structure the documentation page, including announcement, feedback, ecosystem, quick start, core concepts, and learning sections.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/overview.mdx#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport VincentAnnouncement from \"@site/src/pages/vincent-announcement.md\";\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\nimport EcosystemSection from \"@site/src/components/CardSectionsV3/Ecosystem\";\nimport QuickStartSection from \"@site/src/components/CardSectionsV3/QuickStart\";\nimport CoreConceptsSection from \"@site/src/components/CardSectionsV3/CoreConcepts\";\nimport LearnCodeSection from \"@site/src/components/CardSectionsV3/LearnCode\";\n```\n\n----------------------------------------\n\nTITLE: Testing Docusaurus Production Build Locally\nDESCRIPTION: Serves the production build locally at http://localhost:3000/ for testing purposes using the files from the build folder.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/deploy-your-site.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run serve\n```\n\n----------------------------------------\n\nTITLE: Using SIWE Parameters in EVM Contract Conditions\nDESCRIPTION: Shows how to incorporate SIWE parameters into EVM contract conditions for dynamic parameter substitution. Uses litParam syntax for parameter reference.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/customContractCalls.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \":litParam:tokenId\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Creating a new Lit Action with GetLit CLI\nDESCRIPTION: Example of using the 'getlit new' command to create a new Lit Action in an existing project.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngetlit new newAction\n```\n\n----------------------------------------\n\nTITLE: Verifying ERC721 Collection Ownership in JavaScript\nDESCRIPTION: This code snippet sets up an access control condition to check if a user owns any token from an ERC721 collection. It uses the balanceOf method to verify if the user's balance is greater than zero.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0xA80617371A5f511Bf4c1dDf822E6040acaa63e71',\n    standardContractType: 'ERC721',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in a Server Environment\nDESCRIPTION: Example of initializing and connecting to the Lit Network in a Node.js server application using Express. The client is stored in app.locals for access throughout the server.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\napp.locals.litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\n  alertWhenUnauthorized: false,\n  litNetwork: LIT_NETWORK.Datil,\n});\nawait app.locals.litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Retrieving SignClient from PKPWalletConnect\nDESCRIPTION: Demonstrates how to access the underlying WalletConnect SignClient for extended functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst signClient = pkpWalletConnect.getSignClient();\n```\n\n----------------------------------------\n\nTITLE: Checking Creaton.io Subscription in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user is a subscriber to a creator on creaton.io. It uses the subscribers method of the Creator contract to verify the subscription status.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x77c0612bb672a52c60c7a71b898853570bd2bbbb',\n    standardContractType: 'Creaton',\n    chain,\n    method: 'subscribers',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: 'true'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Stytch Client Initialization\nDESCRIPTION: Initializes a Stytch client for authentication using project credentials.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new stytch.Client({\n  project_id: \"<your project id>\",\n  secret: \"<your project secret>\",\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK V2 in JavaScript\nDESCRIPTION: Example of how to import the Lit JS SDK V2 in a JavaScript file after installation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from '@lit-protocol/lit-node-client@serrano';\n```\n\n----------------------------------------\n\nTITLE: Complete NFT Contract Implementation\nDESCRIPTION: Full implementation of the LitNFT contract including all imports, constructor, metadata handling, minting, and NFT fetching functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/smartContract.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract LitNft is ERC721URIStorage, ReentrancyGuard {\n    using Strings for uint256;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    constructor() ERC721 (\"Lit NFT\", \"LITNFT\"){}\n\n    mapping(uint256 => nft) private tokenIdToNft;\n\n    struct nft {\n        string name;\n        string imageUrl;\n        string encryptedDescription;\n        string encryptedSymmetricKey;\n    }\n\n    function getTokenURI(\n        string memory name,\n        string memory imageUrl,\n        string memory encryptedDescription,\n        string memory encryptedSymmetricKey\n    ) private pure returns (string memory) {\n        bytes memory dataURI = abi.encodePacked(\n            '{\\'',\n                '\"name\": \"', name, '\",',\n                '\"image\": \"', imageUrl, '\",',\n                '\"description\": \"', encryptedDescription, '\",',\n                '\"symmetricKey\": \"', encryptedSymmetricKey, '\"',\n            '}'\n        );\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(dataURI)\n            )\n        );\n    }\n\n    function mintLitNft(\n        string memory name,\n        string memory imageUrl,\n        string memory encryptedDescription,\n        string memory encryptedSymmetricKey\n    ) public nonReentrant {\n        _tokenIds.increment();\n        uint256 newNftTokenId = _tokenIds.current();\n        _safeMint(msg.sender, newNftTokenId);\n        _setTokenURI(newNftTokenId, getTokenURI(name, imageUrl, encryptedDescription, encryptedSymmetricKey));\n        tokenIdToNft[newNftTokenId] = nft(name, imageUrl, encryptedDescription, encryptedSymmetricKey);\n    }\n\n    // Fetch all the NFTs to display\n    function fetchNfts() public view returns (nft[] memory) {\n        nft[] memory nfts = new nft[](_tokenIds.current());\n        for (uint256 idx = 1; idx < _tokenIds.current() + 1; idx++) {\n            nft memory currNft = tokenIdToNft[idx];\n            nfts[idx - 1] = currNft;\n        }\n\n        return nfts;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying JWT Signed by Lit Network\nDESCRIPTION: Verify a JWT signed by the Lit network and check its payload against expected values. This is typically done on the server-side but can also work in the browser.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst jwt =\n  \"eyJhbGciOiJCTFMxMi0zODEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJMSVQiLCJzdWIiOiIweGRiZDM2MGYzMDA5N2ZiNmQ5MzhkY2M4YjdiNjI4NTRiMzYxNjBiNDUiLCJjaGFpbiI6ImZhbnRvbSIsImlhdCI6MTYyODAzMTM1OCwiZXhwIjoxNjI4MDc0NTU4LCJiYXNlVXJsIjoiaHR0cHM6Ly9teS1keW5hbWljLWNvbnRlbnQtc2VydmVyLmNvbSIsInBhdGgiOiIvYV9wYXRoLmh0bWwiLCJvcmdJZCI6IiJ9.lX_aBSgGVYWd2FL6elRHoPJ2nab0IkmmX600cwZPCyK_SazZ-pzBUGDDQ0clthPVAtoS7roHg14xpEJlcSJUZBA7VTlPiDCOrkie_Hmulj765qS44t3kxAYduLhNQ-VN\";\nconst { verified, header, payload } = LitJsSdk.verifyJwt({ jwt });\nif (\n  payload.baseUrl !== \"this-website.com\" ||\n  payload.path !== \"/path-you-expected\" ||\n  payload.orgId !== \"\" ||\n  payload.role !== \"\" ||\n  payload.extraData !== \"\"\n) {\n  // Reject this request!\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Encryption Functions in JavaScript\nDESCRIPTION: Updated import statements for encryption and decryption functions from @lit-protocol/encryption package.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { encryptUint8Array, decryptToUint8Array } from '@lit-protocol/encryption';\n```\n\n----------------------------------------\n\nTITLE: Checking Cask Protocol Subscription in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user is either the provider or an active subscriber to a Cask Protocol plan. It uses the getActiveSubscriptionCount method of the CaskSubscriptions contract to verify the subscription status.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"polygon\",\n    method: \"\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n        comparator: \"=\",\n        value: '0xCdcE8CD89e4B29193874Acc677D5ae6624524bFd',\n    },\n  },\n  {operator: \"or\"},\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"0x4A6f232552E0fd76787006Bb688bFBCB931cc3d0\",\n    standardContractType: \"CASK\",\n    chain: \"polygon\",\n    method: 'getActiveSubscriptionCount',\n    parameters: [\n        ':userAddress',\n        '0xCdcE8CD89e4B29193874Acc677D5ae6624524bFd',\n        '100'\n    ],\n    returnValueTest: {\n        comparator: '>',\n        value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Contract Client for Capacity Credits\nDESCRIPTION: Shows how to initialize a contract client for minting and managing capacity credits using a wallet signer.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst walletWithCapacityCredit = new Wallet(\"<your private key or mnemonic>\");\n\nlet contractClient = new LitContracts({\n  signer: dAppOwnerWallet,\n  network: LIT_NETWORK.Datil,\n});\n\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Deriving Key ID and Public Key\nDESCRIPTION: Demonstrates how to derive a key ID and its corresponding public key without persisting it on the Lit network. Useful for previewing what a key will be once registered.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new LitNodeClient({\n\tlitNetwork: \"datil-dev\",\n\tdebug: false\n});\n\nconst keyId = client.computeHdKeyId(\"<your user id>\", \"<your project id>\");\n// the key id can now be given to the public key calculation method\nconst publicKey = client.computeHDPubKey(keyId);\nconsole.log(\"user public key will be: \", publicKey);\n```\n\n----------------------------------------\n\nTITLE: Adding an Auth Method to PKP in Lit Protocol\nDESCRIPTION: This code snippet shows how to add an authentication method to a Programmable Key Pair (PKP) using the PKPPermissions contract in Lit Protocol. It includes setting gas parameters for the transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    [],\n    { gasPrice: utils.parseUnits(\"0.001\", \"gwei\"), gasLimit: 400000 }\n  );\nconst result = await transaction.wait();\n```\n\n----------------------------------------\n\nTITLE: Returning Authenticated Solana Address in Lit Action\nDESCRIPTION: This code snippet demonstrates how to return the authenticated Solana public key (address) from the SIWS message to the frontend using Lit Actions. It sets the response using the Lit.Actions.setResponse method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/authenticating-siws.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nLit.Actions.setResponse({ response: siwsInput.address });\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures\nDESCRIPTION: Example of generating session signatures using the authenticated provider. Shows how to request specific chain and resource abilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/socialLogin.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [\n      resource: litResource,\n      ability: LitAbility.AccessControlConditionDecryption\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chainlink Price Oracle ABI Interface in JavaScript\nDESCRIPTION: ABI interface definition for the Chainlink price oracle smart contract, including functions for fetching price data and contract metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst aggregatorV3InterfaceABI = [\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"description\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint80\", name: \"_roundId\", type: \"uint80\" },\n    ],\n    name: \"getRoundData\",\n    outputs: [\n      { internalType: \"uint80\", name: \"roundId\", type: \"uint80\" },\n      { internalType: \"int256\", name: \"answer\", type: \"int256\" },\n      { internalType: \"uint256\", name: \"startedAt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"updatedAt\", type: \"uint256\" },\n      {\n        internalType: \"uint80\",\n        name: \"answeredInRound\",\n        type: \"uint80\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"latestRoundData\",\n    outputs: [\n      { internalType: \"uint80\", name: \"roundId\", type: \"uint80\" },\n      { internalType: \"int256\", name: \"answer\", type: \"int256\" },\n      { internalType: \"uint256\", name: \"startedAt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"updatedAt\", type: \"uint256\" },\n      {\n        internalType: \"uint80\",\n        name: \"answeredInRound\",\n        type: \"uint80\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Handling OAuth Redirect and PKP Minting\nDESCRIPTION: Code for handling the OAuth redirect callback, authenticating the token, and minting PKPs\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-social.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay, isSignInRedirect } from '@lit-protocol/lit-auth-client';\nimport { AUTH_METHOD_SCOPE, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nasync function handleRedirect() {\n  // Check if app has been redirected from Lit login server\n  if (isSignInRedirect(redirectUri)) {\n    // Get auth method object that has the OAuth token from redirect callback\n    const authMethod: AuthMethod = await googleProvider.authenticate();\n    // -- setting scope for the auth method\n    // <https://developer.litprotocol.com/v3/sdk/wallets/auth-methods/#auth-method-scopes>\n    const options = {\n        permittedAuthMethodScopes: [[AUTH_METHOD_SCOPE.SignAnything]],\n    };\n    // Mint PKP using the auth method\n    const mintTx = await googleProvider.mintPKPWithAuthMethods(\n        [authMethod],\n        options\n    );\n    // Fetch PKPs associated with the authenticated social account\n    const pkps = await googleProvider.getPKPsForAuthMethod(authMethod);\n    return pkps;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol Session Signatures\nDESCRIPTION: Command to install the required npm packages for working with Lit Protocol session signatures, including auth-helpers, constants, lit-node-client, contracts-sdk, and other dependencies.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-lit-action-session-sigs.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/contracts-sdk \\\nipfs-only-hash \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/contracts-sdk \\\nipfs-only-hash \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Add Function in Lit Action\nDESCRIPTION: Demonstrates loading and executing a WebAssembly module that performs addition within a Lit Action. The example initializes a WASM module with binary code that implements an add function, then calls it with arguments 123 and 456, and sets the response using Lit.Actions.setResponse.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/web-assembly.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst wasmCode = new Uint8Array([\n  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02,\n  0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03, 0x61,\n  0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,\n  0x6a, 0x0b,\n]);\nconst wasmModule = new WebAssembly.Module(wasmCode);\nconst wasmInstance = new WebAssembly.Instance(wasmModule);\nconst { add } = wasmInstance.exports;\nconst sum = add(123, 456);\nLit.Actions.setResponse({ response: JSON.stringify({ sum }) });\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network (Client-Side)\nDESCRIPTION: Code snippet to set up and connect a Lit client to the Datil network on the client side.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst client = new LitJsSdk.LitNodeClient({\n  litNetwork: LIT_NETWORK.Datil,\n});\n\nawait client.connect();\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with Delegation Auth\nDESCRIPTION: Implementation of session signature generation including capacity delegation authentication for paid requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/using-delegated-auth-sig.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(), // 24 hours\n    capabilityAuthSigs: [capacityDelegationAuthSig],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    authNeededCallback: async ({\n        resourceAbilityRequests,\n        expiration,\n        uri,\n    }) => {\n    const toSign = await createSiweMessageWithRecaps({\n        uri: uri!,\n        expiration: expiration!,\n        resources: resourceAbilityRequests!,\n        walletAddress: ethersSigner.address,\n        nonce: await litNodeClient.getLatestBlockhash(),\n        litNodeClient,\n    });\n\n    return await generateAuthSig({\n        signer: ethersSigner,\n        toSign,\n    });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Lit SDK Dependencies\nDESCRIPTION: Commands to install required Lit Protocol packages and dependencies using npm or yarn package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/quick-start.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-Chain Access Control Conditions\nDESCRIPTION: Example showing how to combine access control conditions from Solana, Ethereum, Polygon, and Cosmos chains using OR operators. Demonstrates balance checks and token possession verification across different networks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/unifiedAccessControlConditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"solRpc\",\n    method: \"getBalance\",\n    params: [\":userAddress\"],\n    chain: \"solana\",\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"evmBasic\",\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\", // equals 0.00001 ETH\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"evmContract\",\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \"8\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain: \"polygon\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n  { operator: \"or\" },\n  {\n    conditionType: \"cosmos\",\n    path: \"/cosmos/bank/v1beta1/balances/:userAddress\",\n    chain: \"cosmos\",\n    returnValueTest: {\n      key: \"$.balances[0].amount\",\n      comparator: \">=\",\n      value: \"1000000\", // equals 1 ATOM\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Creating Access Control Condition with SIWE Resources in JavaScript\nDESCRIPTION: This snippet shows how to create an access control condition that checks the resources field of a Sign In With Ethereum message. It verifies if the resources array contains the specified IPFS URI 'ipfs://someTestId'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/siwe.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"SIWE\",\n    chain: \"ethereum\",\n    method: \"\",\n    parameters: [\":resources\"],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"ipfs://someTestId\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Weather API Signing with Lit Actions in React\nDESCRIPTION: A React project that calls a Weather API within a Lit Action and signs the weather response. It demonstrates how to integrate external API calls with Lit Protocol's signing capabilities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/toolsAndExamples.md#2025-04-18_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Full code available at: https://replit.com/@lit/Lit-Actions-Return-signed-API-reponse#lit-actions_sign_api_response/src/App.js\n```\n\n----------------------------------------\n\nTITLE: Creating Lit Class with Connection Logic\nDESCRIPTION: TypeScript class implementation for managing Lit Node client connection.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass Lit {\n  private litNodeClient\n\n  async connect() {\n    await client.connect()\n    this.litNodeClient = client\n  }\n}\n\nexport default new Lit()\n```\n\n----------------------------------------\n\nTITLE: Building SIWS Message in JavaScript\nDESCRIPTION: This function parses raw SIWS message values and builds the SIWS message according to the Sign-In Input Fields specification. It constructs a formatted string that includes domain, address, statement, and various optional fields.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/authenticating-siws.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getSiwsMessage(siwsInput) {\n  let message = `${siwsInput.domain} wants you to sign in with your Solana account:\\n${siwsInput.address}`;\n\n  if (siwsInput.statement) {\n    message += `\\n\\n${siwsInput.statement}`;\n  }\n\n  const fields = [];\n\n  if (siwsInput.uri !== undefined) fields.push(`URI: ${siwsInput.uri}`);\n  if (siwsInput.version !== undefined)\n    fields.push(`Version: ${siwsInput.version}`);\n  if (siwsInput.chainId !== undefined)\n    fields.push(`Chain ID: ${siwsInput.chainId}`);\n  if (siwsInput.nonce !== undefined) fields.push(`Nonce: ${siwsInput.nonce}`);\n  if (siwsInput.issuedAt !== undefined)\n    fields.push(`Issued At: ${siwsInput.issuedAt}`);\n  if (siwsInput.expirationTime !== undefined)\n    fields.push(`Expiration Time: ${siwsInput.expirationTime}`);\n  if (siwsInput.notBefore !== undefined)\n    fields.push(`Not Before: ${siwsInput.notBefore}`);\n  if (siwsInput.requestId !== undefined)\n    fields.push(`Request ID: ${siwsInput.requestId}`);\n  if (siwsInput.resources !== undefined && siwsInput.resources.length > 0) {\n    fields.push(\"Resources:\");\n    for (const resource of siwsInput.resources) {\n      fields.push(`- ${resource}`);\n    }\n  }\n\n  if (fields.length > 0) {\n    message += `\\n\\n${fields.join(\"\\n\")}`;\n  }\n\n  return message;\n}\n```\n\n----------------------------------------\n\nTITLE: Authenticating with the Lit Signer\nDESCRIPTION: Code snippet that demonstrates how to authenticate with the LitSigner by providing authentication context, which is required before the AlchemyProvider can use the signer for transactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nlitSigner.authenticate({\n  context: \"<your auth method or session signatures>\"\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Response in Lit Actions\nDESCRIPTION: Shows how to return a JSON response from a Lit Action.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst results = await litNodeClient.executeJs({\n  code: \"LitActions.setResponse({response: JSON.stringify({hello: 'world'})})\",\n  sessionSigs,\n});\nconsole.log(\"response: \", results.response);\n```\n\n----------------------------------------\n\nTITLE: Checking ERC1155 Token Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses at least one ERC1155 token with a specific token id. It uses the balanceOf method to verify the token balance.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x3110c39b428221012934A7F617913b095BC1078C',\n    standardContractType: 'ERC1155',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress',\n      '9541'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Signing Typed Data with PKPEthersWallet\nDESCRIPTION: Shows how to sign typed data following EIP-712 standard, including domain, types, and message structure definition.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/usage.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst example = {\n  domain: {\n    chainId: 80001,\n    name: \"Ether Mail\",\n    verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n    version: \"1\",\n  },\n  message: {\n    contents: \"Hello, Bob!\",\n    from: {\n      name: \"Cow\",\n      wallets: [\n        \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n        \"0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF\",\n      ],\n    },\n    to: [\n      {\n        name: \"Bob\",\n        wallets: [\n          \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n          \"0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57\",\n          \"0xB0B0b0b0b0b0B000000000000000000000000000\",\n        ],\n      },\n    ],\n  },\n  primaryType: \"Mail\",\n  types: {\n    EIP712Domain: [\n      { name: \"name\", type: \"string\" },\n      { name: \"version\", type: \"string\" },\n      { name: \"chainId\", type: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\" },\n    ],\n    Mail: [\n      { name: \"from\", type: \"Person\" },\n      { name: \"to\", type: \"Person[]\" },\n      { name: \"contents\", type: \"string\" },\n    ],\n    Person: [\n      { name: \"name\", type: \"string\" },\n      { name: \"wallets\", type: \"address[]\" },\n    ],\n  },\n};\n\nconst { types, domain, primaryType, message } = example;\n\nif (types[\"EIP712Domain\"]) {\n  delete types[\"EIP712Domain\"];\n}\n\nawait pkpWallet._signTypedData(domain, types, message);\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Dependencies\nDESCRIPTION: Commands for installing the required packages for encrypting with the Lit SDK using npm or yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures\nDESCRIPTION: Shows how to generate session signatures using the provider's getSessionSigs method with authentication and resource requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [{\n      resource: litResource,\n      ability: LitAbility.AccessControlConditionDecryption\n    }],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Session Request Events in JavaScript\nDESCRIPTION: This code snippet demonstrates how to subscribe to and handle session request events in PKPWalletConnect. It logs the request details and approves the request.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\npkpWalletConnect.on(\"session_request\", async (requestEvent) => {\n  console.log(\"Received session request: \", requestEvent);\n\n  const { topic, params } = requestEvent;\n  const { request } = params;\n  const requestSession = signClient.session.get(topic);\n  const { name, url } = requestSession.peer.metadata;\n\n  // Accept session request\n  console.log(\n    `\\nApproving ${request.method} request for session ${name} (${url})...\\n`\n  );\n  await pkpWalletConnect.approveSessionRequest(requestEvent);\n  console.log(\n    `Check the ${name} dapp to confirm whether the request was approved`\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Cosmos Wallet Address\nDESCRIPTION: Validates that the user owns a specific Cosmos wallet address. Compares the :userAddress parameter against a hardcoded wallet address value.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/cosmosConditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \":userAddress\",\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \"=\",\n      value: \"cosmos1vn6zl0924yj86jrp330wcwjclzdharljq03a8h\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data with BLS SDK in JavaScript\nDESCRIPTION: Shows how to decrypt data using the BLS SDK in Lit Protocol V3. It uses the 'decrypt_with_signature_shares' method, which takes the ciphertext and signature shares obtained from the BLS network to decrypt the data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/changes.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst privateData = blsSdk.decrypt_with_signature_shares(\n  ciphertext,\n  sigShares\n);\n```\n\n----------------------------------------\n\nTITLE: Checking DAO Membership in JavaScript\nDESCRIPTION: This snippet defines an access control condition to verify if a user is a member of a MolochDAOv2.1 or DAOHaus DAO. It checks the membership status and ensures the user is not jailed.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x50D8EB685a9F262B13F28958aBc9670F06F819d9',\n    standardContractType: 'MolochDAOv2.1',\n    chain,\n    method: 'members',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: 'true'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Setting up LitContracts Client\nDESCRIPTION: Initialization and configuration of LitContracts client with Ethereum provider setup\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst ethersWallet = new ethers.Wallet(\n  'Your Ethereum Private Key', // Replace with your private key\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n\nconst contractClient = new LitContracts({\n  signer: ethersWallet,\n  network: LIT_NETWORK.DatilTest,\n});\n\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Protocol Network\nDESCRIPTION: Code to initialize and connect to a Lit Protocol node on the specified network (Datil, Datil-test, or Datil-dev).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n});\n\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures in TypeScript\nDESCRIPTION: This code demonstrates how to generate PKP session signatures using Lit Protocol. It uses EthWalletProvider for authentication and sets up resource ability requests. The expiration time for the auth method and session signatures is set to 10 minutes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Encrypting Private Key with Lit Protocol SDK\nDESCRIPTION: Example of using the encryptString function from the Lit SDK to encrypt a private key and obtain the ciphertext and dataToEncryptHash required for storeEncryptedKey.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\nimport { encryptString } from '@lit-protocol/encryption';\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n\nconst { ciphertext, dataToEncryptHash } = await encryptString(\n    {\n        accessControlConditions: [\n            {\n                contractAddress: '',\n                standardContractType: '',\n                chain: 'ethereum',\n                method: '',\n                parameters: [':userAddress'],\n                returnValueTest: {\n                comparator: '=',\n                value: process.env.PKP_ETH_ADDRESS,\n                },\n            },\n        ],\n        // For enhanced security, \"lit_\" should be prepended to all stored private keys.\n        dataToEncrypt: `lit_${process.env.CLEAR_TEXT_PRIVATE_KEY}`,\n    },\n    litNodeClient,\n)\n```\n\n----------------------------------------\n\nTITLE: Logging Example with Lit Actions\nDESCRIPTION: Demonstrates how to use logging in Lit Actions and retrieve logs from the results.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst results = await litNodeClient.executeJs({\n  code: \"console.log('hello')\",\n  sessionSigs,\n});\nconsole.log(\"logs: \", results.logs);\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures with Lit Protocol\nDESCRIPTION: Shows how to generate session signatures using the provider's getSessionSigs method, including setting up chain and resource ability requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/social-login.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  pkpPublicKey: '<YOUR PKP PUBLIC KEY>'\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [{\n        resource: litResource,\n        ability: LIT_ABILITY.AccessControlConditionDecryption\n      }\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting Capacity Credits NFT\nDESCRIPTION: Process of minting a capacity credits NFT with specified request limits and expiration time.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n// this identifier will be used in delegation requests. \nconst { capacityTokenIdStr } = await contractClient.mintCapacityCreditsNFT({\n  requestsPerKilosecond: 80,\n  // requestsPerDay: 14400,\n  // requestsPerSecond: 10,\n  daysUntilUTCMidnightExpiration: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Lit Network in Browser Environment\nDESCRIPTION: Code to properly disconnect from the Lit Network in a browser environment to allow the browser to exit gracefully.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nawait client.disconnect();\n```\n\n----------------------------------------\n\nTITLE: Starting Python HTTP Server for Manual Tests\nDESCRIPTION: Command to start a Python SimpleHTTPServer for running manual browser tests on port 8000\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/tests.md#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npython2 -m SimpleHTTPServer\n```\n\n----------------------------------------\n\nTITLE: Retrieving WalletConnect SignClient in JavaScript\nDESCRIPTION: This code snippet shows how to retrieve the WalletConnect SignClient from the PKPWalletConnect instance for extended functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/walletconnect.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst signClient = pkpWalletConnect.getSignClient();\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions\nDESCRIPTION: Setting up access control conditions for encryption based on ETH balance requirement.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain: \"ethereum\",\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"1000000000000\", // 0.000001 ETH\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Verifying Creaton.io Subscription in JavaScript\nDESCRIPTION: This code snippet sets up an access control condition to check if a user is a subscriber to a creator on creaton.io. It uses the subscribers method of the Creator contract to verify the subscription status.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x77c0612bb672a52c60c7a71b898853570bd2bbbb',\n    standardContractType: 'Creaton',\n    chain,\n    method: 'subscribers',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: 'true'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Stytch Client\nDESCRIPTION: Creates a new instance of the Stytch client using project credentials. Requires project ID and secret from Stytch dashboard.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new stytch.Client({\n  project_id: \"<your project id>\",\n  secret: \"<your project secret>\",\n});\n```\n\n----------------------------------------\n\nTITLE: Bitcoin Transaction Broadcasting\nDESCRIPTION: Helper function that broadcasts a signed Bitcoin transaction to the network using the Mempool API. Handles HTTP request/response and error handling for transaction submission.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/overview.md#2025-04-18_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport fetch from \"node-fetch\";\n\nexport const broadcastTransaction = async (txHex: string) => {\n    try {\n    const response = await fetch(\"https://mempool.space/api/tx\", {\n        method: \"POST\",\n        headers: {\n        \"Content-Type\": \"text/plain\",\n        },\n        body: txHex,\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Error broadcasting transaction: ${errorText}`);\n    }\n\n    const txid = await response.text();\n    console.log(`Transaction broadcasted successfully. TXID: ${txid}`);\n    return txid;\n    } catch (error) {\n      console.error(\"Error during DER encoding:\", error);\n      throw error;\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Managing LitNodeClient Connection with Error Handling\nDESCRIPTION: Shows how to initialize a LitNodeClient with error handling, disconnect from the network, and clear browser storage using disconnectWeb3.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/connecting-to-lit.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LIT_NETWORK } from '@lit-protocol/constants';\nimport { disconnectWeb3 } from \"@lit-protocol/auth-browser\";\n\nlet litNodeClient;\ntry {\n  litNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilDev,\n      debug: false,\n  });\n\n  await litNodeClient.connect();\n} catch (error) {\n  // handle errors\n} finally {\n  disconnectWeb3(); // <--- When this function call is executed,\n                    // the Session Keypair will be deleted from the browser's local storage\n  litNodeClient.disconnect(); // <--- Here we disconnect from the Lit network\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Lit Protocol Client\nDESCRIPTION: TypeScript function to connect to the Lit Protocol network. This is called within a useEffect hook after initializing the application.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst startLitClient = (window: Window): ILitNodeClient => {\n    // connect to lit\n    console.log(\"Starting Lit Client...\");\n    const client = new LitJsSdk.LitNodeClient({\n      url: window.location.origin,\n    });\n    client.connect();\n    return client as ILitNodeClient;\n  };\n```\n\n----------------------------------------\n\nTITLE: Minting a Capacity Credit NFT with Specified Parameters\nDESCRIPTION: TypeScript code to mint a new Capacity Credit NFT with specific capacity parameters. This example configures a credit for 80 requests per kilosecond with a one-day expiration. The function returns transaction details and the new token ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/minting-capacity-credit/via-contract.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst capacityCreditInfo = await litContractClient.mintCapacityCreditsNFT({\n    requestsPerKilosecond: 80,\n    // requestsPerDay: 14400,\n    // requestsPerSecond: 10,\n    daysUntilUTCMidnightExpiration: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethers Signer for Lit Protocol\nDESCRIPTION: Code to initialize an Ethers signer using a private key from environment variables. This signer connects to the Chronicle Yellowstone RPC endpoint provided by Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-lit-action-session-sigs.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst ethersSigner = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY,\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Local Node Configuration\nDESCRIPTION: Command to generate Ceramic node credentials and ComposeDB server configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/ceramic-example.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run generate\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures with Lit Protocol in TypeScript\nDESCRIPTION: Demonstrates how to generate PKP session signatures using Lit Protocol with Ethereum wallet authentication. Includes setting up auth methods and resource ability requests with a 10-minute expiration window.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Node Execution in Lit Protocol\nDESCRIPTION: Demonstrates how to configure a Lit Action to execute on a single node using the targetNodeRange parameter. This allows for executing actions on 1-10 nodes instead of the entire network, though signing still requires responses from the full network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/workingWithActions/singleExecution.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexecuteJs({ targetNodeRange: 1 })\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in Browser (Yarn/NPM)\nDESCRIPTION: This code establishes a connection to the Lit Network in a browser environment when using Yarn or NPM installation method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient();\nawait client.connect();\nwindow.litNodeClient = client;\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures\nDESCRIPTION: Example of generating session signatures using an authenticated provider and PKP public key\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-social.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\n\n// Get session signatures for the given PKP public key and auth method\nconst sessionSigs = await provider.getSessionSigs({\n  authMethod: '<AuthMethod object returned from authenticate()>',\n  pkpPublicKey: pkps[0].publicKey, // Note, an AuthMethod can own more than one PKP\n  sessionSigsParams: {\n    chain: 'ethereum',\n    resourceAbilityRequests: [{\n        resource: litResource,\n        ability: LIT_ABILITY.AccessControlConditionDecryption\n      }\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Stytch OTP Authentication Flow\nDESCRIPTION: Implements the Stytch OTP (One-Time Password) authentication flow including user login/creation and session management.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/usage.md#2025-04-18_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst email = \"\"; // email address of user\n\nconst stytchResponse = await client.otps.email.loginOrCreate({\n  email: email,\n})\n\nconst authResponse = await client.otps.authenticate({\n  method_id: stytchResponse.email_id,\n  code: // code from email,\n  session_duration_minutes: 60, // session duration is required for session token creation\n})\n\nconst sessionResp = await client.sessions.get({\n  user_id: authResponse.user_id\n});\n\nconst sessionStatus = await client.sessions.authenticate({\n  session_token: authResponse.session_token,\n})\n```\n\n----------------------------------------\n\nTITLE: Saving Encryption Key\nDESCRIPTION: Saving the encryption key with access control conditions to Lit nodes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst encryptedSymmetricKey = await window.litNodeClient.saveEncryptionKey({\n  accessControlConditions,\n  symmetricKey,\n  authSig,\n  chain,\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Specific Token Account Balance\nDESCRIPTION: Verifies the balance of a specific token account using getTokenAccountBalance RPC method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/sol-rpc-conditions.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"getTokenAccountBalance\",\n    params: [\"E7aAccig7X3X4pSWjf1eqqUJkV3EbzG6DrtyM2gbuuhH\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"amount\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Authenticating to Fetch PKP Information\nDESCRIPTION: Demonstrates how to authenticate a user and fetch their PKP information using the Lit Relay Server.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst authClient = new LitAuthClient({\n    litRelayConfig: {\n        relayApiKey: '<Your Lit Relay Server API Key>',\n    }\n});\n\n// starting a validation session\nlet session = authClient.initProvider(ProviderType.Otp,{\n            userId: '<User email or phone number>'\n});\n\nlet status = await session.sendOtpCode();\nlet authMethod = await session.authenticate({\n    code: \"<User entered OTP code>\"\n});\nconst txHash = await session.fetchPKPThroughRelayer(authMethod);\n```\n\n----------------------------------------\n\nTITLE: Defining Access Control Conditions\nDESCRIPTION: Multiple examples of access control conditions for data decryption, including ETH balance, DAI token balance, and NFT ownership checks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"\",\n      standardContractType: \"\",\n      chain: \"ethereum\",\n      method: \"eth_getBalance\",\n      parameters: [\":userAddress\", \"latest\"],\n      returnValueTest: {\n        comparator: \">=\",\n        value: \"000000000000000000\", // 0 ETH in wei\n      },\n    },\n  ];\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\", // DAI contract\n      standardContractType: \"ERC20\",\n      chain: \"ethereum\",\n      method: \"balanceOf\",\n      parameters: [\":userAddress\"],\n      returnValueTest: {\n        comparator: \">=\",\n        value: \"100000000000000000000\", // 100 DAI in wei\n      },\n    },\n  ];\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"0xABC123...XYZ\", // ERC721 contract address\n      standardContractType: \"ERC721\",\n      chain: \"ethereum\",\n      method: \"balanceOf\",\n      parameters: [\":userAddress\"],\n      returnValueTest: {\n        comparator: \">\",\n        value: \"0\",\n      },\n    },\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring LitNodeClient for Serrano Testnet in JavaScript\nDESCRIPTION: This code snippet demonstrates how to configure the LitNodeClient to use the Serrano Testnet. It requires the latest @lit-protocol/lit-node-client package and specifies the 'serrano' network in the configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/stateOfNetwork.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  litNetwork: \"serrano\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Capacity Delegation Auth Signature in Lit Protocol\nDESCRIPTION: Code to create a capacity delegation authorization signature that allows specified addresses to use a Capacity Credit for Lit network operations. This includes setting usage limits and expiration time.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/delegating-credit.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { capacityDelegationAuthSig } =\n    await litNodeClient.createCapacityDelegationAuthSig({\n        dAppOwnerWallet: ethersSigner,\n        capacityTokenId,\n        delegateeAddresses: [delegateeAddress],\n        uses: \"1\",\n        expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n    });\n```\n\n----------------------------------------\n\nTITLE: Instantiating Ethers Signer for PKP Authentication\nDESCRIPTION: This code snippet demonstrates how to create an Ethers signer using a private key from an environment variable. This signer is used for authenticating with the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Stytch Client for OTP Authentication\nDESCRIPTION: Creates and initializes a Stytch client using the project ID and secret for OTP authentication.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst stytchClient = new stytch.Client({\n    project_id: \"project-test-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\",\n    secret: \"secret-test-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n});\n```\n\n----------------------------------------\n\nTITLE: Handling OAuth Redirect\nDESCRIPTION: Implementation of redirect handling after OAuth authentication, including validation and retrieval of auth method object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay, isSignInRedirect } from '@lit-protocol/lit-auth-client';\nimport { AUTH_METHOD_SCOPE, PROVIDER_TYPE } from '@lit-protocol/constants';\n\nasync function handleRedirect() {\n  // Check if app has been redirected from Lit login server\n  if (isSignInRedirect(redirectUri)) {\n    // Get auth method object that has the OAuth token from redirect callback\n    const authMethodGoogle: AuthMethod = await googleProvider.authenticate();\n    return authMethodGoogle;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Authenticating WebAuthn Credential with Lit Protocol\nDESCRIPTION: This code snippet shows how to authenticate an existing WebAuthn credential using the LitAuthClient. It returns an AuthMethod object containing the authentication data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/webAuthn.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function authenticateWithWebAuthn() {\n  const provider = litAuthClient.getProvider(ProviderType.WebAuthn);\n  const authMethod = await provider.authenticate();\n  return authMethod;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Lit Client\nDESCRIPTION: Initialization of the Lit Client during DOM load or early lifecycle.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nlitCeramicIntegration.startLitClient(window)\n```\n\n----------------------------------------\n\nTITLE: Access Control Conditions for Wrapped Keys\nDESCRIPTION: TypeScript code defining the access control conditions used when encrypting wrapped keys. The conditions restrict decryption to only those who can generate valid authentication signatures from the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain: CHAIN_ETHEREUM,\n        method: '',\n        parameters: [':userAddress'],\n        returnValueTest: {\n        comparator: '=',\n        value: pkpAddress,\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: PKP Authentication with SignMessage Callback\nDESCRIPTION: Implementation of PKP authentication using a signMessage callback for SIWE message signing. Uses ethers wallet for signing and connects to Lit Protocol network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-contracts.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitNodeClient } from '@lit-protocol/lit-node-client';\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { AUTH_METHOD_SCOPE, AUTH_METHOD_TYPE, PROVIDER_TYPE, LIT_RPC, LIT_NETWORK } from '@lit-protocol/constants';\nimport { EthWalletProvider } from '@lit-protocol/providers';\nimport * as ethers from 'ethers';\n\nconst litNodeClient = new LitNodeClient({\n  litNetwork: LIT_NETWORK.DatilDev,\n  debug: true\n})\nawait litNodeClient.connect();\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\nconst ethWalletProvider = new EthWalletProvider({ relay: litRelay, litNodeClient });\n\nconst ethersWallet = new ethers.Wallet(\n  'Your Ethereum Private Key', // Replace with your private key\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n\nconst authMethod = await ethWalletProvider.authenticate({\n  signMessage: (message: string) => {\n    return await ethersWallet.signMessage(message);\n  }\n});\n\nconst options = {\n  permittedAuthMethodScopes: [[AUTH_METHOD_SCOPE.SignAnything]],\n};\n\nconst mintTx = await litRelay.mintPKPWithAuthMethods([authMethod], options);\n```\n\n----------------------------------------\n\nTITLE: Authenticating User with OTP and Getting Session Token\nDESCRIPTION: Authenticates the user with the provided OTP and retrieves a session token using the Stytch client.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst authResponse = await stytchClient.otps.authenticate({\n    method_id: stytchResponse.email_id,\n    code: otpResponse.code,\n    session_duration_minutes: 60 * 24 * 7,\n})\n \nconst sessionStatus = await stytchClient.sessions.authenticate({\n    session_token: authResponse.session_token,\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst authResponse = await stytchClient.otps.authenticate({\n    method_id: stytchResponse.phone_id,\n    code: otpResponse.code,\n    session_duration_minutes: 60 * 24 * 7,\n})\n \nconst sessionStatus = await stytchClient.sessions.authenticate({\n    session_token: authResponse.session_token,\n})\n```\n\n----------------------------------------\n\nTITLE: Error Codes Table for Serrano/Datil-dev Version\nDESCRIPTION: A table of error codes and their explanations for the Serrano and Datil-dev versions of the Lit Protocol SDK. Includes system faults, authentication errors, and access control issues.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/tests.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| error code                                 | reason                                                                                                                                                                                                                                                                           |\n| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| NodeSystemFault                            | An internal node error occurred. Please try again. If this error persists contact us on Discord.                                                                                                                                                                                  |\n| NodeAccessControlConditionsCheckFailed     | The provided Authsig doesn't meet the access conditions.                                                                                                                                                                                                                         |\n| NodeEncryptedSymmetricKeyNotFound          | The provided encryptedSymmetricKey doesn't exist.                                                                                                                                                                                                                                |\n| NodeExpWrongOrTooLarge                     | The provided exp param is either expired or is too much in the future.                                                                                                                                                                                                           |\n```\n\n----------------------------------------\n\nTITLE: Checking ATOM Balance in Cosmos\nDESCRIPTION: Validates if a user's wallet contains at least 1 ATOM token. Uses the cosmos bank module to check balances, with automatic user address substitution.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/other-chains/cosmos-conditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \"/cosmos/bank/v1beta1/balances/:userAddress\",\n    chain,\n    returnValueTest: {\n      key: \"$.balances[0].amount\",\n      comparator: \">=\",\n      value: \"1000000\", // equals 1 ATOM\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Estimating Gas for Auth Method Operations\nDESCRIPTION: Shows how to estimate gas costs for adding auth methods using populateTransaction and estimateGas functions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// First, mock the transaction to add an auth method\nconst mockTransaction =\n  await litContracts.pkpPermissionsContract.write.populateTransaction.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    []\n  );\n\n// Then, estimate gas on the unsigned transaction\nconst gas = await litContracts.signer.estimateGas(mockTransaction);\n\n// Now, you can use the gas value to set the gas limit\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    [],\n    { gasLimit: gas }\n  );\n```\n\n----------------------------------------\n\nTITLE: Connecting to Irys Network\nDESCRIPTION: Function to initialize connection to Irys network using Ethereum wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Uploader } from \"@irys/upload\";\nimport { Ethereum } from \"@irys/upload-ethereum\";\n \nconst getIrysUploader = async () => {\n  const irysUploader = await Uploader(Ethereum).withWallet(process.env.PRIVATE_KEY);\n  return irysUploader;\n};\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication Signature\nDESCRIPTION: Obtaining authentication signature from MetaMask for proving wallet ownership.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/encryption.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({ chain: \"ethereum\" });\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource-based Access Control with SIWE in JavaScript\nDESCRIPTION: This snippet shows how to create an access control condition based on the Resources parameter of a Sign in with Ethereum message. It checks if the resources array contains the specified IPFS resource 'ipfs://someTestId'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/siwe.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"\",\n    standardContractType: \"SIWE\",\n    chain: \"ethereum\",\n    method: \"\",\n    parameters: [\":resources\"],\n    returnValueTest: {\n      comparator: \"contains\",\n      value: \"ipfs://someTestId\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Signing Data with PKP\nDESCRIPTION: Signs a message using the PKP and verifies the signature by recovering the public key and address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-signing.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst signingResult = await litNodeClient.pkpSign({\n  pubKey: pkpInfo.publicKey,\n  sessionSigs,\n  toSign: ethers.utils.arrayify(\n    ethers.utils.keccak256(\n      ethers.utils.toUtf8Bytes(\"The answer to the universe is 42.\")\n    )\n  ),\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst encodedSig = ethers.utils.joinSignature({\n  v: signingResult.recid,\n  r: `0x${signingResult.r}`,\n  s: `0x${signingResult.s}`,\n});\n\nconst recoveredPubkey = ethers.utils.recoverPublicKey(\n  `0x${signingResult.dataSigned}`,\n  encodedSig\n);\nconst recoveredAddress = ethers.utils.recoverAddress(\n  `0x${signingResult.dataSigned}`,\n  encodedSig\n);\n\n// adjust for ethers.utils.recoverPublicKey prefixing the public key with 0x\nconsole.log(recoveredPubkey === `0x${pkp.publicKey}`); // true\nconsole.log(recoveredAddress === pkpInfo.ethAddress); // true\n```\n\n----------------------------------------\n\nTITLE: Generating Token URI with Metadata\nDESCRIPTION: Function to generate token URI by encoding NFT metadata including encrypted fields into base64 JSON format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/smartContract.md#2025-04-18_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n    function getTokenURI(\n        string memory name,\n        string memory imageUrl,\n        string memory encryptedDescription,\n        string memory encryptedSymmetricKey\n    ) private pure returns (string memory) {\n        bytes memory dataURI = abi.encodePacked(\n            '{\\'',\n                '\"name\": \"', name, '\",',\n                '\"image\": \"', imageUrl, '\",',\n                '\"description\": \"', encryptedDescription, '\",',\n                '\"symmetricKey\": \"', encryptedSymmetricKey, '\"',\n            '}'\n        );\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(dataURI)\n            )\n        );\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Updateable Conditions in Lit Protocol\nDESCRIPTION: This snippet demonstrates how to create an updateable condition by passing 'permanent: false' when storing conditions in Lit. It uses the saveEncryptionKey method of the litNodeClient.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/updateableConditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({\n  accessControlConditions,\n  symmetricKey,\n  authSig,\n  chain,\n  permanent: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Authentication Redirect\nDESCRIPTION: Implementation of redirect handling after social login authentication. Validates the redirect callback and retrieves the authentication method object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/socialLogin.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function handleRedirect() {\n  // Check if app has been redirected from Lit login server\n  if (isSignInRedirect(redirectUri)) {\n    // Get the provider that was used to sign in\n    const provider = provider = litAuthClient.getProvider(\n      ProviderType.Google,\n    );\n    // Get auth method object that has the OAuth token from redirect callback\n    const authMethod: AuthMethod = await provider.authenticate();\n    return authMethod;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Protocol Nodes\nDESCRIPTION: Establish a connection to the Lit Protocol nodes, which is required for using functions like saveSigningCondition and getSignedToken.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNodeClient = new LitJsSdk.LitNodeClient();\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data with Lit Protocol\nDESCRIPTION: TypeScript code showing how to decrypt data using the Lit SDK's decryptToString method, which requires the ciphertext, data hash, access control conditions, and session signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-decryption.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst decryptionResult = await decryptToString(\n  {\n      chain: \"ethereum\",\n      ciphertext,\n      dataToEncryptHash,\n      accessControlConditions,\n      sessionSigs,\n  },\n  litNodeClient\n);\n```\n\n----------------------------------------\n\nTITLE: Obtaining Stytch Session with Email OTP\nDESCRIPTION: Demonstrates how to create a Stytch client, send an email OTP, authenticate the code, and obtain a session token.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/email-sms.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as stytch from \"stytch\";\n\nconst client = new stytch.Client({\n  project_id: STYTCH_PROJECT_ID,\n  secret: STYTCH_SECRET,\n});\n\nconst emailResponse = await prompts({\n  type: \"text\",\n  name: \"email\",\n  message: \"Enter your email address\",\n});\n\nconst stytchResponse = await client.otps.email.loginOrCreate({\n  email: emailResponse.email,\n});\n\nconst otpResponse = await prompts({\n  type: \"text\",\n  name: \"code\",\n  message: \"Enter the code sent to your email:\",\n});\n\nconst authResponse = await client.otps.authenticate({\n  method_id: stytchResponse.email_id,\n  code: otpResponse.code,\n  session_duration_minutes: 60 * 24 * 7,\n});\n\nlet sessionResp = await client.sessions.get({\n  user_id: authResponse.user_id,\n});\n\n// the sessionStatus contains the relevant session token\nconst sessionStatus = await client.sessions.authenticate({\n  session_token: authResponse.session_token,\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining AuthSig for Lit Protocol\nDESCRIPTION: Get an authentication signature (AuthSig) from the user's wallet, which proves ownership of their crypto address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({ chain: \"polygon\" });\n```\n\n----------------------------------------\n\nTITLE: Importing Lit Protocol SDK for Node.js\nDESCRIPTION: Import statement for the Lit Protocol SDK Node.js package required for JWT verification.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/jwt-auth.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPEthersWallet in JavaScript\nDESCRIPTION: Creates and initializes a PKPEthersWallet instance with authentication signatures for signing blockchain transactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst pkpWallet = new PKPEthersWallet({\n  controllerAuthSig: \"<Your AuthSig>\",\n  // Or you can also pass in controllerSessionSigs\n  pkpPubKey: \"<Your PKP public key>\",\n  rpc: LIT_RPC.CHRONICLE_YELLOWSTONE,\n});\nawait pkpWallet.init();\n```\n\n----------------------------------------\n\nTITLE: Setting up Lit Node Client\nDESCRIPTION: TypeScript code showing how to instantiate and connect a Lit Node Client to the datil-dev network for interacting with the Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK\nDESCRIPTION: Commands to install the Lit Protocol SDK using either yarn or npm package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\nLANGUAGE: jsx\nCODE:\n```\nnpm i @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Encrypting String Data with Lit Protocol\nDESCRIPTION: Function to encrypt a string using Lit Protocol with specified access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport const encryptString = async (text: string): Promise<{ ciphertext: string; dataToEncryptHash: string }> => {\n  await litClient.connect();\n\n  const accessControlConditions = getAccessControlConditions();\n\n  const { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n    {\n      accessControlConditions,\n      dataToEncrypt: text,\n    },\n    litClient\n  );\n\n  console.log({ ciphertext, dataToEncryptHash });\n  return { ciphertext, dataToEncryptHash };\n};\n```\n\n----------------------------------------\n\nTITLE: Granting Decryption Capability to All Access Control Conditions in JavaScript\nDESCRIPTION: This snippet illustrates how to grant decryption capability to all access control conditions using a wildcard. It creates a session capability object with a wildcard Lit resource and adds the decryption capability.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/capability-objects.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Create the session capability object\nconst sessionCapabilityObject = new newSessionCapabilityObject();\n\n// Create the Lit Resource keyed by `someResource`\nconst litResource = new LitAccessControlConditionResource('*');\n\n// Add the capability to decrypt from the access control condition referred to by the \n// lit resource.\nsessionCapabilityObject.addCapabilityForResource(\n    litResource,\n    LitAbility.AccessControlConditionDecryption\n);\n```\n\n----------------------------------------\n\nTITLE: Importing Lit Protocol SDK for General Use\nDESCRIPTION: Code snippet demonstrating how to import the Lit Protocol SDK for use in browser or Node environments after installation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContracts with PKPEthersWallet\nDESCRIPTION: Sets up a LitContracts instance using the previously created PKPEthersWallet for blockchain interactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\n\nconst litContracts = new LitContracts({\n  signer: pkpWallet,\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Initializing PKPWalletConnect with PKPClient in JavaScript\nDESCRIPTION: Sets up PKPWalletConnect to manage WalletConnect session proposals and requests using the given PKPClient.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/walletconnect.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PKPWalletConnect } from '@lit-protocol/pkp-walletconnect';\n\nconst config = {\n  projectId: '<Your WalletConnect project ID>',\n  metadata: {\n    name: 'Test Lit Wallet',\n    description: 'Test Lit Wallet',\n    url: 'https://litprotocol.com/',\n    icons: ['https://litprotocol.com/favicon.png'],\n  },\n};\nconst wcClient = new PKPWalletConnect();\nawait wcClient.initWalletConnect(config);\nwcClient.addPKPClient(pkpWallet)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Google Guardian Signer\nDESCRIPTION: Configuration of PKPEthersWallet for signing operations with Google authentication\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport { LIT_ABILITY, LitPKPResource } from \"@lit-protocol/auth-helpers\";\nimport { AuthCallbackParams } from \"@lit-protocol/types\";\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst authNeededCallback = async (params: AuthCallbackParams) => {\nconsole.log(`auth needed callback params`, JSON.stringify(params, null, 2));\nconst response = await litNodeClient.signSessionKey({\n  statement: params.statement,\n  authMethods: [authMethod],\n  resourceAbilityRequests: [\n    {\n      resource: new LitPKPResource(\"*\"),\n      ability: LIT_ABILITY.PKPSigning,\n    },\n  ],\n  expiration: params.expiration,\n  resources: params.resources,\n  chainId: 1,\n  pkpPublicKey: pkp.pkpPublicKey,\n});\nreturn response.authSig;\n};\n\nconst guardianSigner = new PKPEthersWallet({\n  litNodeClient,\n  authContext: {\n    getSessionSigsProps: {\n      chain: \"ethereum\",\n      expiration: new Date(Date.now() + 60_000 * 60).toISOString(),\n      resourceAbilityRequests: [\n        {\n          resource: new LitPKPResource(\"*\"),\n          ability: LIT_ABILITY.PKPSigning,\n        },\n      ],\n      authNeededCallback: authNeededCallback,\n    },\n  },\n  pkpPubKey: pkp.pkpPublicKey,\n  rpc: LIT_RPC.CHRONICLE_YELLOWSTONE,\n});\nconsole.log(\"Created PKPEthersWallet using the PKP ✔️\");\n```\n\n----------------------------------------\n\nTITLE: Setting Access Control Conditions\nDESCRIPTION: Configuration of access control conditions for encryption, requiring a minimum ETH balance.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '',\n    standardContractType: '',\n    chain: 'ethereum',\n    method: 'eth_getBalance',\n    parameters: [':userAddress', 'latest'],\n    returnValueTest: {\n      comparator: '>=',\n      value: '1000000000000',  // 0.000001 ETH\n    },\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Generating Session Signatures\nDESCRIPTION: Creates session signatures for authenticating PKP signing operations and Lit Action execution with specific resource permissions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-signing.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  createSiweMessage,\n  generateAuthSig,\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst sessionSigs = await litNodeClient.getSessionSigs({\n    chain: \"ethereum\",\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n    resourceAbilityRequests: [\n        {\n            resource: new LitPKPResource(pkpInfo.tokenId),\n            ability: LIT_ABILITY.PKPSigning,\n        },\n        {\n          resource: new LitActionResource(\"*\"),\n          ability: LIT_ABILITY.LitActionExecution,\n        },\n    ],\n    authNeededCallback: async ({\n        uri,\n        expiration,\n        resourceAbilityRequests,\n        }) => {\n        const toSign = await createSiweMessage({\n            uri,\n            expiration,\n            resources: resourceAbilityRequests,\n            walletAddress: ethersWallet.address,\n            nonce: await litNodeClient.getLatestBlockhash(),\n            litNodeClient,\n        });\n\n        return await generateAuthSig({\n            signer: ethersWallet,\n            toSign,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Watching and testing Lit Actions with GetLit CLI\nDESCRIPTION: Command to simultaneously build and test Lit Actions using the GetLit CLI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngetlit watch\n```\n\n----------------------------------------\n\nTITLE: Checking MolochDAOv2.1 Share Ownership with EVM Contract Condition\nDESCRIPTION: Defines an access control condition that verifies if a user has at least 1 share in a specific MolochDAOv2.1 DAO contract on the xDai chain. The condition checks the 'members' function output.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/customContractCalls.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst evmContractConditions = [\n  {\n    contractAddress: \"0xb71a679cfff330591d556c4b9f21c7739ca9590c\",\n    functionName: \"members\",\n    functionParams: [\":userAddress\"],\n    functionAbi: {\n      constant: true,\n      inputs: [\n        {\n          name: \"\",\n          type: \"address\",\n        },\n      ],\n      name: \"members\",\n      outputs: [\n        {\n          name: \"delegateKey\",\n          type: \"address\",\n        },\n        {\n          name: \"shares\",\n          type: \"uint256\",\n        },\n        {\n          name: \"loot\",\n          type: \"uint256\",\n        },\n        {\n          name: \"exists\",\n          type: \"bool\",\n        },\n        {\n          name: \"highestIndexYesVote\",\n          type: \"uint256\",\n        },\n        {\n          name: \"jailed\",\n          type: \"uint256\",\n        },\n      ],\n      payable: false,\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    chain: \"xdai\",\n    returnValueTest: {\n      key: \"shares\",\n      comparator: \">=\",\n      value: \"1\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining listEncryptedKeyMetadata Function Interface in TypeScript\nDESCRIPTION: This code snippet defines the interface for the listEncryptedKeyMetadata function, including its parameters and return type. It uses TypeScript to specify the expected input and output structures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_NETWORKS_KEYS } from '@lit-protocol/types';\n\n/** Get a previously encrypted and persisted private key and its metadata.\n * Note that this method does _not_ decrypt the private key; only the _encrypted_ key and its metadata will be returned to the caller.\n */\nexport async function getEncryptedKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n  }\n): Promise<{\n  publicKey: string;\n  pkpAddress: string;\n  keyType: string;\n  litNetwork: LIT_NETWORKS_KEYS;\n  memo: string;\n  id: string;\n}[]> \n```\n\n----------------------------------------\n\nTITLE: Checking Specific Wallet Address in JavaScript\nDESCRIPTION: This snippet defines an access control condition to check if a user possesses a specific wallet address. It compares the user's address directly with the specified address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/evm/basic-examples.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '',\n    standardContractType: '',\n    chain,\n    method: '',\n    parameters: [\n      ':userAddress',\n    ],\n    returnValueTest: {\n      comparator: '=',\n      value: '0x50e2dac5e78B5905CB09495547452cEE64426db2'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitContracts Client for the Datil Test Network\nDESCRIPTION: TypeScript code to initialize the LitContracts client using the previously created Ethers signer and configuring it for the Datil test network. This client provides methods for interacting with Lit Protocol smart contracts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/minting-capacity-credit/via-contract.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litContractClient = new LitContracts({\n    signer: ethersSigner,\n    network: LIT_NETWORK.DatilTest,\n});\nawait litContractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Client-side Encryption Using Lit Protocol Crypto Package\nDESCRIPTION: Shows how to use the encrypt method from the @lit-protocol/crypto package to perform client-side encryption. This example requires a public key, secret message, and identity parameter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst publicKey =\n  '8e29447d7b0666fe41c357dbbdbdac0ac8ac973f88439a07f85fa31fa6fa3cea87c2eaa8b367e1c97764800fb5636892';\n\nconst secretMessage = new Uint8Array([\n  240, 23, 185, 6, 87, 33, 173, 216, 53, 84, 80, 135, 190, 16, 58, 85, 97, 75,\n  3, 192, 215, 82, 217, 5, 40, 65, 2, 214, 40, 177, 53, 150,\n]);\n\nconst identityParam = new Uint8Array([\n  101, 110, 99, 114, 121, 112, 116, 95, 100, 101, 99, 114, 121, 112, 116, 95,\n  119, 111, 114, 107, 115,\n]);\n\nconst ciphertext = encrypt(publicKey, secretMessage, identityParam);\n```\n\n----------------------------------------\n\nTITLE: Fetching Auth Methods for PKP\nDESCRIPTION: Shows how to retrieve the list of permitted authentication methods for a PKP using the PKPPermissions contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst authMethods =\n  await litContracts.pkpPermissionsContract.read.getPermittedAuthMethods(\n    \"<The token ID of your PKP>\"\n  );\n```\n\n----------------------------------------\n\nTITLE: Setting up Lit Object for Client-side Usage\nDESCRIPTION: This code creates a Lit object with a connect method for client-side usage of the Lit JS SDK V2.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient()\n\nclass Lit {\n  private litNodeClient\n  async connect() {\n    await client.connect()\n    this.litNodeClient = client\n  }\n}\nexport default new Lit()\n```\n\n----------------------------------------\n\nTITLE: Importing Lit Protocol SDK for Node.js\nDESCRIPTION: Code snippet showing how to import the Node.js-specific version of the Lit Protocol SDK.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n```\n\n----------------------------------------\n\nTITLE: Migrating from WalletFactory to Direct Instantiation\nDESCRIPTION: Example showing the migration from WalletFactory to direct PKP wallet instantiation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n// Old way\nconst pkpWallet = WalletFactory.createWallet(...);\n\n// New way\nconst pkpWallet = new PKPEthersWallet({ ... });\n```\n\n----------------------------------------\n\nTITLE: Retrieving PKP Tokens by Address\nDESCRIPTION: Gets all PKP tokens owned by a specific address using the PKPNFT contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst tokens = await LitContracts.pkpNftContractUtils.read.getTokensByAddress(ownerAddress);\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration\nDESCRIPTION: Required environment variables for Lit Protocol, Candide integration, wallet addresses and network information\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// Lit\nLIT_API_KEY= // Request Relay Server API Key from Lit at https://forms.gle/RNZYtGYTY9BcD9MEA\n\n// Candide\nBUNDLER_URL=\"https://sepolia.voltaire.candidewallet.com/rpc\" // Other networks are found here: https://docs.candide.dev/wallet/bundler/rpc-endpoints\nPAYMASTER_URL= // Request an API key from Candide on Discord\n    \n// Generate a Public/Private Key\nOWNER_PUBLIC_ADDRESS=\nOWNER_PRIVATE_KEY=\nNEW_OWNER_PUBLIC_ADDRESS=\n\n// Network Info\nVITE_CHAIN_ID=\nJSON_RPC_NODE_PROVIDER= // Get an RPC from a Node provider\n```\n\n----------------------------------------\n\nTITLE: Converting Blob to Base64 for Solidity Function Parameters\nDESCRIPTION: This snippet shows how to convert the Blob result from LitJsSdk.encryptString() to a base64 string so it can be passed as a parameter to a Solidity function. It creates a FileReader to read the blob as a data URL and returns a Promise that resolves with the base64 representation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/faq.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Convert blob to base64 to pass as a string to Solidity\nconst blobToBase64 = (blob) => {\n const reader = new FileReader();\n reader.readAsDataURL(blob);\n return new Promise((resolve) => {\n   reader.onloadend = () => {\n     resolve(reader.result);\n   };\n });\n};\nconst encryptedStringBase64 = await blobToBase64(encryptedStringBlob);\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data with BLS SDK in JavaScript\nDESCRIPTION: Demonstrates how to encrypt data using the BLS SDK in Lit Protocol V3. It uses the 'encrypt' method, which takes a public key, secret message, and identity parameter to perform client-side encryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/changes.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst publicKey =\n  '8e29447d7b0666fe41c357dbbdbdac0ac8ac973f88439a07f85fa31fa6fa3cea87c2eaa8b367e1c97764800fb5636892';\n\nconst secretMessage = new Uint8Array([\n  240, 23, 185, 6, 87, 33, 173, 216, 53, 84, 80, 135, 190, 16, 58, 85, 97, 75,\n  3, 192, 215, 82, 217, 5, 40, 65, 2, 214, 40, 177, 53, 150,\n]);\n\nconst identityParam = new Uint8Array([\n  101, 110, 99, 114, 121, 112, 116, 95, 100, 101, 99, 114, 121, 112, 116, 95,\n  119, 111, 114, 107, 115,\n]);\n\nconst ciphertext = blsSdk.encrypt(\n  publicKey,\n  uint8arrayToString(secretMessage, 'base64'),\n  uint8arrayToString(identityParam, 'base64')\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient for Lit Protocol\nDESCRIPTION: Code to create and connect a LitNodeClient instance to the Lit network. This client is essential for interacting with Lit Protocol services.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Installing PKP Ethers Package for Alchemy Account Kit Integration\nDESCRIPTION: Commands to install the pkp-ethers package which enables using Programmable Key Pairs with Ethereum-compatible networks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @lit-protocol/pkp-ethers\n```\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add @lit-protocol/pkp-ethers\n```\n\n----------------------------------------\n\nTITLE: Converting PKP Public Key to Bitcoin Address using bitcoinjs-lib\nDESCRIPTION: Code snippet showing how to derive a Bitcoin address from a PKP public key using the bitcoinjs-lib library. Handles hex public key formatting and conversion to BTC address format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/faq.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as bitcoinjs from \"bitcoinjs-lib\";\n\nif (publicKey.startsWith(\"0x\")) {\n  publicKey = publicKey.slice(2);\n}\npubkeyBuffer = Buffer.from(publicKey, \"hex\");\n\n// get the btc address from the public key\nconst pkpBTCAddress = bitcoinjs.payments.p2pkh({\n  pubkey: pubkeyBuffer,\n}).address;\n```\n\n----------------------------------------\n\nTITLE: Implementing ERC1155 Token-Based Access Control with Lit Protocol\nDESCRIPTION: Example showing how to create access control conditions that check for possession of a specific ERC1155 token. The condition verifies if a user's balance of token ID 9541 is greater than 0 on the specified contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/learningLab/intro-to-lit/acc.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x3110c39b428221012934A7F617913b095BC1078C',\n    standardContractType: 'ERC1155',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress',\n      '9541'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol and Irys Integration\nDESCRIPTION: Install required npm packages for integrating Lit Protocol with Irys, including node client, constants, upload utilities, and ethereum dependencies.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n  @lit-protocol/lit-node-client-nodejs \\\n  @lit-protocol/constants \\\n  @irys/upload \\\n  @irys/upload-ethereum \\\n  ethers \\\n  siwe \\\n  dotenv\n```\n\n----------------------------------------\n\nTITLE: Verifying ERC1155 Token Balance with Contract Call\nDESCRIPTION: Creates a condition to check if a user owns at least one ERC1155 token with a specific token ID. Uses the balanceOf function to verify token ownership.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/customContractCalls.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88\",\n    functionName: \"balanceOf\",\n    functionParams: [\":userAddress\", \"8\"],\n    functionAbi: {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"balanceOf\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"account\",\n          internalType: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"id\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Converting Base64 to Blob for Lit SDK Decryption\nDESCRIPTION: This code demonstrates how to convert a base64 string stored in a contract back to a Blob format required by the LitJsSdk.decryptString() function. It uses the fetch API to convert the base64 string to a Blob object.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/support/faq.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Convert base64 to blob to pass in the litSDK decrypt function\nconst encryptedStringBlob = await (await fetch(encryptedStringBase64)).blob();\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol Integration\nDESCRIPTION: Commands to install required NPM packages including Lit Protocol client libraries and Ethers v5.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/using-delegated-auth-sig.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/auth-helpers \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Registering Payer Wallet with Lit Relayer API (Datil-Test Network)\nDESCRIPTION: Makes a POST request to the Lit Relayer API to register a new payer wallet on the Datil-Test network. This creates a new Capacity Credit for the payer.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await fetch(\n    \"https://datil-test-relayer.getlit.dev/register-payer\", \n    {\n        method: \"POST\",\n        headers,\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Encoding Arrays for Contract Function Parameters\nDESCRIPTION: Example of encoding array parameters for contract function calls, specifically for bytes32 arrays. Shows proper hex string formatting without 0x prefix.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/customContractCalls.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nvar evmContractConditions = [\n  {\n    contractAddress: \"0xc7BA08FB2546cA2198F6C69e5c4B15252D90A347\",\n    functionName: \"sumBytes32\",\n    functionParams: [\n      \"[0000000000000000000000000000000000000000000000000000000000000002,0000000000000000000000000000000000000000000000000000000000000003]\",\n    ],\n    functionAbi: {\n      name: \"sumBytes32\",\n      inputs: [{ internalType: \"bytes32[]\", name: \"vals\", type: \"bytes32[]\" }],\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      constant: true,\n      stateMutability: \"view\",\n    },\n    chain: \"xdai\",\n    returnValueTest: { key: \"\", comparator: \"=\", value: \"5\" },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining importPrivateKey Function Interface in TypeScript\nDESCRIPTION: This code snippet defines the interface for the importPrivateKey function, including its parameters and return type. It outlines the necessary inputs such as PKP session signatures, Lit Node Client, private key, public key, key type, and memo.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function importPrivateKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    privateKey: string;\n    publicKey: string;\n    keyType: string;\n    memo: string;\n  }\n): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Packaging and Creating Bundlr Transaction\nDESCRIPTION: Shows how to package encrypted data with symmetric key and access control conditions, create a Bundlr instance, and prepare a transaction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/bundlrxarweave.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst packagedData = JSON.stringify({\n  encryptedData,\n  encryptedSymmetricKey,\n  accessControlConditions,\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport Bundlr from \"@bundlr-network/client\";\nconst bundlr = new Bundlr(\n  \"<http://node1.bundlr.network>\",\n  \"currencyName\",\n  \"privateKey\"\n);\n```\n\n----------------------------------------\n\nTITLE: Storing Encrypted Solana Key with Lit Protocol\nDESCRIPTION: This code snippet demonstrates how to store an encrypted Solana key using the storeEncryptedKey method from the Lit Protocol SDK. It uses the previously generated PKP session signatures and encrypted key data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst successfullyStoredMetadata = await storeEncryptedKey({\n    pkpSessionSigs,\n    litNodeClient,\n    ciphertext,\n    dataToEncryptHash,\n    publicKey: process.env.SOLANA_PUBLIC_KEY,\n    keyType: 'ed25519',\n    memo: \"This is an arbitrary string you can replace with whatever you'd like\",\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in a Browser Environment\nDESCRIPTION: Example of initializing and connecting to the Lit Network in a browser application. This establishes the connection that's required for most SDK functions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst client = new LitJsSdk.LitNodeClient({\n  litNetwork: LIT_NETWORK.Datil,\n});\n\nawait client.connect();\n```\n\n----------------------------------------\n\nTITLE: Implementing Wrapped Key Decryption with Lit Actions\nDESCRIPTION: Implementation of decryptToSingleNode method to decrypt private keys stored with Lit Protocol. Includes prefix handling and error management for decryption operations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/custom-wrapped-keys.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n    const LIT_PREFIX = 'lit_';\n\n    let decryptedPrivateKey;\n    try {\n        decryptedPrivateKey = await Lit.Actions.decryptToSingleNode({\n        accessControlConditions,\n        chain: 'ethereum',\n        ciphertext,\n        dataToEncryptHash,\n        authSig: null,\n        });\n    } catch (error) {\n        Lit.Actions.setResponse({\n            response: `Error: When decrypting data to private key: ${error.message}`,\n        });\n        return;\n    }\n\n    if (!decryptedPrivateKey) {\n        // Exit the nodes which don't have the decryptedData\n        return;\n    }\n\n    // Here we're checking if LIT_PREFIX was prepended to the private key,\n    // and removing it if it exists before using the key.\n    const privateKey = decryptedPrivateKey.startsWith(LIT_PREFIX)\n        ? decryptedPrivateKey.slice(LIT_PREFIX.length)\n        : decryptedPrivateKey;\n\n    // The rest of your Lit Action code...\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Create React App with Fallbacks\nDESCRIPTION: This JavaScript code configures webpack for Create React App to provide fallbacks for various modules like crypto, stream, buffer, etc. It also modifies module rules and adds a ProvidePlugin for Buffer.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst webpack = require('webpack'); // Import webpack\n\nmodule.exports = {\n\twebpack: function(config, env) {\n\t\t// Add a fallback for 'crypto' in the resolve object\n        config.resolve = {\n            ...config.resolve, // Spread existing resolve configurations\n            fallback: {\n                ...config.resolve.fallback, // Spread existing fallbacks, if any\n                'crypto': require.resolve('crypto-browserify'), // Fallback for 'crypto'\n                'stream': require.resolve('stream-browserify'), // Fallback for 'stream'\n                'buffer': require.resolve('buffer/'), // Add this line\n                'http': require.resolve('stream-http'), // Add this line\n                'https': require.resolve('https-browserify'), // Add this line\n                'url': require.resolve('url/'), // Add this line\n                'zlib': require.resolve('browserify-zlib'), // Add this line\n                'jszip': require.resolve('jszip/'), // Add this line\n                'assert': require.resolve('assert/'), // Add this line\n            },\n        };\n\n        // Provide plugin to define Buffer globally\n        config.plugins = [\n            ...config.plugins,\n            new webpack.ProvidePlugin({\n                Buffer: ['buffer', 'Buffer'],\n            }),\n        ];\n\n\t\tconfig.module.rules = config.module.rules.map(rule => {\n\t\t\tif (rule.oneOf instanceof Array) {\n\t\t\t\trule.oneOf[rule.oneOf.length - 1].exclude = [\n\t\t\t\t\t/\\.(js|mjs|jsx|cjs|ts|tsx)$/,\n\t\t\t\t\t/\\.html$/,\n\t\t\t\t\t/\\.json$/,\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn rule;\n\t\t});\n\t\treturn config;\n\t},\n}; \n```\n\n----------------------------------------\n\nTITLE: Basic Lit Action Signature Request\nDESCRIPTION: JavaScript code that runs on Lit nodes to sign the 'Hello World' string using ECDSA\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst go = async () => {\n  // this is the string \"Hello World\" for testing\n  const toSign = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100];\n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  const sigShare = await Lit.Actions.signEcdsa({\n    toSign,\n    publicKey:\n      \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n    sigName: \"sig1\",\n  });\n};\n\ngo();\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Auth Client Dependencies\nDESCRIPTION: Commands to install the required Lit Protocol authentication client packages via yarn\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-social.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-auth-client\nyarn add @lit-protocol/providers\n```\n\n----------------------------------------\n\nTITLE: Reading Lit Action Code\nDESCRIPTION: Reads the Lit Action code from a file for transaction signing.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst litActionCode = fs.readFileSync(\"./build/signTxnTest.js\");\n```\n\n----------------------------------------\n\nTITLE: Adding Auth Method to PKP\nDESCRIPTION: Shows how to add an authentication method to a PKP using the PKPPermissions contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    [],\n    { gasPrice: utils.parseUnits(\"0.001\", \"gwei\"), gasLimit: 400000 }\n  );\nconst result = await transaction.wait();\n```\n\n----------------------------------------\n\nTITLE: Signing and Uploading Bundlr Transaction\nDESCRIPTION: Demonstrates how to create, sign, and upload a transaction to Bundlr network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/bundlrxarweave.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// create a Bundlr Transaction\nconst tx = bundlr.createTransaction(packagedData)\n\nconst transactionId = tx.id;\n\n// sign the transaction\nawait tx.sign();\n\n// upload the transaction\nconst result = await tx.upload();\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing Dependencies for Lit Protocol Sample\nDESCRIPTION: These commands clone the Openfort samples repository, navigate to the Lit Protocol directory, and install the necessary dependencies using npm.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/openfort.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/openfort-xyz/samples/\n\ncd lit-protocol\n\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Downloading Encrypted Data from Irys\nDESCRIPTION: Function to retrieve encrypted data and associated metadata from Irys network using transaction ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport const downloadFromIrys = async (id: string): Promise<[string, string, object[]]> => {\n  const url = `${gatewayAddress}${id}`;\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`Failed to retrieve data for ID: ${id}`);\n    const data = await response.json();\n\n    const ciphertext = data.cipherText;\n    const dataToEncryptHash = data.dataToEncryptHash;\n\n    return [ciphertext, dataToEncryptHash, data.accessControlConditions];\n  } catch (error) {\n    console.error(\"Error retrieving data: \", error);\n    return [\"\", \"\", []];\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Setting ETH Balance Access Control Conditions\nDESCRIPTION: Function to create access control conditions based on Ethereum balance requirements.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"\",\n      standardContractType: \"\",\n      chain: \"ethereum\",\n      method: \"eth_getBalance\",\n      parameters: [\":userAddress\", \"latest\"],\n      returnValueTest: {\n        comparator: \">=\",\n        value: \"000000000000000000\", // 0 ETH in wei\n      },\n    },\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Timestamp to Date in LitContracts\nDESCRIPTION: Utility method to convert a timestamp to a formatted date string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst formattedDate = LitContracts.utils.timestamp2Date(timestamp);\n```\n\n----------------------------------------\n\nTITLE: Minting PKPs with LitRelay in JavaScript\nDESCRIPTION: Updated method for minting PKPs using LitRelay instead of LitAuthClient.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\n\nconst relay = new LitRelay({ litNetwork: LIT_NETWORK.MAINNET });\n\nrelay.mintPKPWithAuthMethods(authMethods, options);\n```\n\n----------------------------------------\n\nTITLE: Monitoring UserOperation Receipt for Account Recovery in JSX\nDESCRIPTION: Code snippet that shows how to retrieve and log the receipt of a user operation after account recovery. It waits for the operation to be included in the blockchain and logs the result.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst userOperationReceiptResultRecovery = await sendUserOperationResponseRecovery.included();\n\nconsole.log(userOperationReceiptResultRecovery);\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient for Lit Protocol\nDESCRIPTION: This code snippet shows how to instantiate a LitNodeClient and connect it to the datil-dev Lit network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Minting Capacity Credits NFT\nDESCRIPTION: Demonstrates how to mint a Capacity Credits NFT with specified request limits and expiration period.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n// this identifier will be used in delegation requests. \nconst { capacityTokenIdStr } = await contractClient.mintCapacityCreditsNFT({\n  requestsPerKilosecond: 80,\n  // requestsPerDay: 14400,\n  // requestsPerSecond: 10,\n  daysUntilUTCMidnightExpiration: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Encrypted Data from Irys\nDESCRIPTION: Function to retrieve stored encrypted data from Irys gateway using transaction ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nasync function retrieveFromIrys(id: string): Promise<[string, string, object[]]> {\n  const gatewayAddress = \"https://gateway.irys.xyz/\";\n  const url = `${gatewayAddress}${id}`;\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`Failed to retrieve data for ID: ${id}`);\n    const data = await response.json();\n\n    return [data.cipherText, data.dataToEncryptHash, data.accessControlConditions];\n  } catch (error) {\n    console.error(\"Error retrieving data: \", error);\n    return [\"\", \"\", []];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in Node.js\nDESCRIPTION: This code establishes a connection to the Lit Network in a Node.js environment and stores the client in app.locals for server-wide access.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\napp.locals.litNodeClient = new LitJsSdk.LitNodeClient({\n  alertWhenUnauthorized: false,\n});\nawait app.locals.litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages\nDESCRIPTION: Commands to install additional required packages for the Lit Protocol setup.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nyarn add @lit-protocol/contracts-sdk\nyarn add @lit-protocol/lit-auth-client\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Juno Wallet Address\nDESCRIPTION: Checks if the user owns a specific Juno network wallet address. Performs direct address comparison with automatic user address substitution.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/other-chains/cosmos-conditions.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \":userAddress\",\n    chain: \"juno\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \"=\",\n      value: \"juno1vn6zl0924yj86jrp330wcwjclzdharljkajxqt\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Connecting to Lit Network in Browser (Script Tag)\nDESCRIPTION: This function establishes a connection to the Lit Network in a browser environment when using the script tag installation method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction litJsSdkLoaded() {\n  var litNodeClient = new LitJsSdk_litNodeClient();\n  litNodeClient.connect();\n  window.litNodeClient = litNodeClient;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: NPM command to install AbstractionKit, Lit Protocol client libraries and constants\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i abstractionkit@0.1.12 @lit-protocol/lit-node-client @lit-protocol/lit-auth-client @lit-protocol/constants\n```\n\n----------------------------------------\n\nTITLE: Data Signing Example in TypeScript\nDESCRIPTION: This snippet demonstrates how to prepare data for signing in a Lit Action. It uses ethers.js utilities to convert an array of numbers into the required format.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/conditional-signing.md#2025-04-18_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ndataToSign: ethers.utils.arrayify(ethers.utils.keccak256([1, 2, 3, 4, 5])),\n```\n\n----------------------------------------\n\nTITLE: Setting DAI Token Access Control Conditions\nDESCRIPTION: Function to create access control conditions based on DAI token balance requirements.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getAccessControlConditions(): object[] {\n  return [\n    {\n      contractAddress: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\", // DAI contract\n      standardContractType: \"ERC20\",\n      chain: \"ethereum\",\n      method: \"balanceOf\",\n      parameters: [\":userAddress\"],\n      returnValueTest: {\n        comparator: \">=\",\n        value: \"100000000000000000000\", // 100 DAI in wei\n      },\n    },\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Bitcoin Signature Conversion to DER Format\nDESCRIPTION: Helper function that converts an ECDSA signature to Bitcoin's DER format, implementing low-S normalization and BIP66 encoding standards. Includes handling for signature positivity and hash type appending.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/bitcoin/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport elliptic from \"elliptic\";\nimport * as bip66 from \"bip66\";\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport BN from \"bn.js\";\n\nexport const convertSignature = async (litSignature: any) => {\n    const EC = elliptic.ec;\n    let r = Buffer.from(litSignature.r, \"hex\");\n    let s = Buffer.from(litSignature.s, \"hex\");\n    let rBN = new BN(r);\n    let sBN = new BN(s);\n\n    const secp256k1 = new EC(\"secp256k1\");\n    const n = secp256k1.curve.n;\n\n    if (sBN.cmp(n.divn(2)) === 1) {\n      sBN = n.sub(sBN);\n    }\n\n    r = rBN.toArrayLike(Buffer, \"be\", 32);\n    s = sBN.toArrayLike(Buffer, \"be\", 32);\n\n    function ensurePositive(buffer: any) {\n    if (buffer[0] & 0x80) {\n        const newBuffer = Buffer.alloc(buffer.length + 1);\n        newBuffer[0] = 0x00;\n        buffer.copy(newBuffer, 1);\n        return newBuffer;\n    }\n    return buffer;\n    }\n\n    r = ensurePositive(r);\n    s = ensurePositive(s);\n\n    let derSignature;\n    try {\n      derSignature = bip66.encode(r, s);\n    } catch (error) {\n      console.error(\"Error during DER encoding:\", error);\n      throw error;\n    }\n\n    const signatureWithHashType = Buffer.concat([\n      derSignature,\n      Buffer.from([bitcoin.Transaction.SIGHASH_ALL]),\n    ]);\n\n    return signatureWithHashType;\n}\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Lit Network (Server-Side)\nDESCRIPTION: Code to disconnect the server-side client from the Lit network, allowing Node.js to exit gracefully.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nawait app.locals.litNodeClient.disconnect();\n```\n\n----------------------------------------\n\nTITLE: Migrating executeJs Function in TypeScript\nDESCRIPTION: Shows how to migrate the executeJs function from v5 to v6, where sessionSigs becomes strictly required instead of optional authSig or sessionSigs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nimport { AuthSig, SessionSigsMap } from '@lit-protocol/types';\n\nconst authSig: AuthSig = {} // Your Auth Sig;\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst res = await litNodeClient.executeJs({\n\tauthSig: authSig,\n\tsessionSigs: sessionSigs;\n\t// the rest of your code...\n});\n\n// v6\nimport { SessionSigsMap } from '@lit-protocol/types';\n\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst res = await litNodeClient.executeJs({\n\tsessionSigs,\n\t// the rest of your code...\n});\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitNodeClient in TypeScript\nDESCRIPTION: This snippet shows how to create an instance of LitNodeClient and connect it to the 'datil-dev' Lit network. It imports necessary modules and initializes the client with specific network settings.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Adding an Auth Method to PKP in JavaScript\nDESCRIPTION: This code snippet shows how to add an authentication method to an existing PKP using the PKPPermissions Contract. It adds an auth method with a scope of 1 for arbitrary signing.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.addPermittedAuthMethod(\n    \"<The token ID of the PKP you want to add an auth method to>\",\n    \"<The auth method object you want to add>\",\n    [BigNumber.from(1)], // 1 is the permission for arbitrary signing\n    { gasPrice: utils.parseUnits(\"0.001\", \"gwei\"), gasLimit: 400000 }\n  );\nconst result = await transaction.wait();\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitNodeClient for Lit Protocol\nDESCRIPTION: This code snippet shows how to create and connect a LitNodeClient instance to the Datil Dev network. It sets up the client with debug mode disabled and connects to the specified Lit network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Installing Wrapped Keys SDK with Yarn\nDESCRIPTION: Command to install the Lit Protocol Wrapped Keys SDK using Yarn package manager. Requires minimum SDK version 6.4.0.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/wrapped-keys\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Contracts SDK\nDESCRIPTION: Commands to install the @lit-protocol/contracts-sdk package using yarn or npm package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nyarn add @lit-protocol/contracts-sdk\n```\n\nLANGUAGE: jsx\nCODE:\n```\nnpm i @lit-protocol/contracts-sdk\n```\n\n----------------------------------------\n\nTITLE: Disconnecting Lit Client\nDESCRIPTION: Code to disconnect from the Lit network and clean up resources.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nawait this.litNodeClient.disconnect();\n```\n\nLANGUAGE: jsx\nCODE:\n```\nLitJsSdk.disconnectWeb3();\n```\n\n----------------------------------------\n\nTITLE: Access Control Conditions for Wrapped Key Encryption\nDESCRIPTION: TypeScript code snippet showing the Access Control Conditions used to encrypt a Wrapped Key. These conditions restrict decryption to only those who can generate valid Authentication Signatures from the PKP that generated the Wrapped Key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain: CHAIN_ETHEREUM,\n        method: '',\n        parameters: [':userAddress'],\n        returnValueTest: {\n        comparator: '=',\n        value: pkpAddress,\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Listening for Lit Network Ready Event\nDESCRIPTION: This code adds an event listener for the 'lit-ready' event, which is fired when the Lit Network is fully connected.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.addEventListener(\n  \"lit-ready\",\n  function (e) {\n    console.log(\"LIT network is ready\");\n    setNetworkLoading(false); // replace this line with your own code that tells your app the network is ready\n  },\n  false\n);\n```\n\n----------------------------------------\n\nTITLE: Defining generatePrivateKey Function Interface in TypeScript\nDESCRIPTION: This snippet shows the TypeScript interface for the generatePrivateKey function, including its parameters and return type. It generates a random private key inside a Lit Action and persists the key and its metadata to the wrapped keys service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function generatePrivateKey(\n  params: {\n    pkpSessionSigs: SessionSigsMap;\n    litNodeClient: ILitNodeClient;\n    network: 'evm' | 'solana';\n    memo: string;\n  }\n): Promise<{\n    pkpAddress: string;\n    generatedPublicKey: string;\n    id: string;\n}>\n```\n\n----------------------------------------\n\nTITLE: Basic Boolean OR Logic in Lit Protocol Access Control\nDESCRIPTION: Example showing how to combine DAO membership check with ETH balance check using OR operator. Allows access if user is either a DAO member or holds more than 0.00001 ETH.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/booleanLogic.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: \"0x50D8EB685a9F262B13F28958aBc9670F06F819d9\",\n    standardContractType: \"MolochDAOv2.1\",\n    chain,\n    method: \"members\",\n    parameters: [\":userAddress\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\",\n    },\n  },\n  { operator: \"or\" },\n  {\n    contractAddress: \"\",\n    standardContractType: \"\",\n    chain,\n    method: \"eth_getBalance\",\n    parameters: [\":userAddress\", \"latest\"],\n    returnValueTest: {\n      comparator: \">=\",\n      value: \"10000000000000\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Methods\nDESCRIPTION: Setup of authentication methods for PKP minting, including wallet authentication configuration\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\n\nconst authMethodWallet = {\n  authMethodType: 1, // Adjust based on the auth method\n  accessToken: JSON.stringify(authSig),  // Use authSig obtained from the controller wallet\n};\n\nconst authIdWallet = await getAuthIdByAuthMethod(authMethodWallet);\n\nconst authIdAction = contractClient.utils.getBytesFromMultihash('<IPFS-hash-of-Lit-Action>');\n```\n\n----------------------------------------\n\nTITLE: Browser AuthSig Generation using signAndSaveAuthMessage\nDESCRIPTION: Example of obtaining an AuthSig using signAndSaveAuthMessage for custom wallet selection implementations.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/authSig.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ethConnect } from \"@lit-protocol/auth-browser\";\n\nconst authSig = await ethConnect.signAndSaveAuthMessage({\n  web3: web3Provider,\n  account: walletAddress,\n  chainId: 1,\n  expiration: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContract Instance\nDESCRIPTION: Setup code to initialize a LitContract instance with an optional signer. If no signer is provided, it defaults to window.ethereum.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-contracts.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitContracts } from '@lit-protocol/contracts-sdk';\n\n// if no signer is provided, it will attempt to use window.ethereum\nconst contractClient = new LitContracts({ signer });\nawait contractClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Migrating Session Key Signing in TypeScript\nDESCRIPTION: Shows the migration of signSessionKey function with added support for custom authentication and conditional signing.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nconst response = await this.signSessionKey({\n  sessionKey: props.sessionKey,\n  statement: props.statement || 'Some custom statement.',\n  authMethods: [...params.authMethods],\n  pkpPublicKey: params.pkpPublicKey,\n  expiration: props.expiration,\n  resources: props.resources,\n  chainId: 1,\n  resourceAbilityRequests: props.resourceAbilityRequests,\n});\n\n// v6\nconst response = await this.signSessionKey({\n  sessionKey: props.sessionKey,\n  statement: props.statement || 'Some custom statement.',\n  authMethods: [...params.authMethods],\n  pkpPublicKey: params.pkpPublicKey,\n  expiration: props.expiration,\n  resources: props.resources,\n  chainId: 1,\n  resourceAbilityRequests: props.resourceAbilityRequests,\n\n  // -- optional fields\n  ...(props.litActionCode && { litActionCode: props.litActionCode }),\n  ...(props.ipfsId && { ipfsId: props.ipfsId }),\n  ...(props.jsParams && { jsParams: props.jsParams }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing Lit Ceramic Integration\nDESCRIPTION: Import statements and initialization of the Lit Ceramic integration with Ceramic RPC URL and chain selection.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Integration } from 'lit-ceramic-sdk'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nlet litCeramicIntegration = new Integration(\"https://ceramic-clay.3boxlabs.com\", \"ethereum\")\n```\n\n----------------------------------------\n\nTITLE: Minting a PKP Token\nDESCRIPTION: Mints a new Programmable Key Pair (PKP) token using LitContracts on the Chronicle Yellowstone blockchain.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-signing.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\n\nconst litContracts = new LitContracts({\n    signer: ethersWallet,\n    network: LIT_NETWORK.DatilDev,\n    debug: false\n});\nawait litContracts.connect();\n\nconst pkpInfo = (await litContracts.pkpNftContractUtils.write.mint()).pkp;\n```\n\n----------------------------------------\n\nTITLE: Setting Session Signatures Expiration in TypeScript/React\nDESCRIPTION: This code snippet demonstrates how to set an expiration time for Session Signatures using the ISO 8601 date format. The example sets the expiration to 10 minutes from the current time by calculating the timestamp and converting it to an ISO string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/generating-session-sigs.md#2025-04-18_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nexpiration: new Date(Date.now() + 1000 * 60 * 10).toISOString()\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Lit Contracts SDK\nDESCRIPTION: Command to install the necessary NPM packages for interacting with the Lit Contracts SDK and Ethereum blockchain, including @lit-protocol/constants, @lit-protocol/contracts-sdk, and ethers v5.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/minting-capacity-credit/via-contract.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/constants \\\n@lit-protocol/contracts-sdk \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/constants \\\n@lit-protocol/contracts-sdk \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Displaying SDK Error Codes and Reasons for Serrano Version (Markdown)\nDESCRIPTION: A markdown table listing error codes and their corresponding reasons for the 'serrano' version of the Lit Protocol SDK. It includes a wide range of error scenarios such as node system faults, authentication failures, and blockchain-related issues.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/tests.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n|error code    |reason    |\n|-|----|\\nNodeSystemFault|An internal node error occured. Please try again. If this error persists contact us on Discord.|\\nNodeAccessControlConditionsCheckFailed|The provided Authsig doesn't meet the access conditions.|\\nNodeEncryptedSymmetricKeyNotFound|The provided encryptedSymmetricKey doesn't exist.|\\nNodeExpWrongOrTooLarge|The provided exp param is either expired or is too much in the future.|\\nNodeIatOutsideGracePeriod|The provided iat param is either outside the grace_period or the issue time is in the future.|\\nNodeAuthFailed|The authMethod isn't allowed for the provided PKP.|\\nNodeInvalidAuthSig|The provided Authsig is invalid. Please ensure that the Authsig is in the required format as provided [here](https://js-sdk.litprotocol.com/interfaces/types_src.AuthSig.html)|\\nNodeAuthSigNotSupported|Multiple Authsigs not supported for the function.|\\nNodeInvalidEthereumSolanaAuthSig|Either the Authsig isn't provided or all the provided Authsigs are invalid.|\\nNodeInvalidED25519AuthSig|The provided Authsig isn't Ed25519 compliant. Please ensure that the Authsig is in the required format as provided [here](https://js-sdk.litprotocol.com/interfaces/types_src.AuthSig.html)|\\nNodeInvalidAuthSigSigningAlgo|The provided algo param in the sessionSigs isn't supported. The ONLY supported algo is \\\"ed25519\\\".|\\nNodeInvalidUnifiedAuthSig|Either no Authsig is provided in the unified conditions or all the provided Authsigs in the are invalid.|\\nNodeInvalidEthereumAuthSig|Either no Ethereum Authsig isn't provided or is invalid.|\\nNodeInvalidCosmosAuthSig|Either no Cosmos Authsig isn't provided or is invalid.|\\nNodeInvalidCosmosSDKSignature|Invalid chain for the provided Cosmos signature. The ONLY supported chains are \\\"cosmos\\\" & \\\"kyve\\\".|\\nNodeInvalidKyveAuthSig|Either no Kyve Authsig isn't provided or is invalid.|\\nNodeInvalidSolanaAuthSig|Either no Solana Authsig isn't provided or is invalid.|\\nNodeAuthSigAddressConversionError|Couldn't convert the Authsig address to Ethereum address. Please ensure that the Authsig address is Ethereum compliant.|\\nNodeConditionAddressConversionError|Couldn't convert the provided accessControlCondition param from hex string to bytes.|\\nNodeConditionTokenIdParsingError|Couldn't parse the provided accessControlCondition's tokenId. Please look at the returned error for more info.|\\nNodeInvalidIPFSID|Invalid IPFS CID.|\\nNodeAuthSigSignatureConversionError|Invalid Authsig.sig param. Please look at the returned error for more info & ensure it's compatible as given [here](https://js-sdk.litprotocol.com/interfaces/types_src.AuthSig.html)|\\nNodeAuthSigSessionKeyConversionError|Invalid Authsig.address param. Please look at the returned error for more info  ensure it's compatible as given [here](https://js-sdk.litprotocol.com/interfaces/types_src.AuthSig.html)|\\nNodeAuthSigSignedMessageConversionError|Invalid Authsig.signedMessage param. Please look at the returned error for more info  ensure it's compatible as given [here](https://js-sdk.litprotocol.com/interfaces/types_src.AuthSig.html)|\\nNodeInvalidAuthSigSessionKeySignature|The provided sessionSig is invalid. Please look at the error for more info.|\\nNodeMissingAccessControlConditions|No Access Control Condition provided. You have to provide at least one of the accessControlCondition, evmContractConditions, solRpConditions|\\nNodeNotAuthorized|The Lit node requested isn't a validator in the current epoch. Please try again. If this error persists contact us on Discord.|\\nNodeResourceIdNotFound|Invalid resourceId param.|\\nNodeRpcError|Error making the call to RPC url for the passed chain param. Please ensure that the contract call that you're making is correct including the contract address & it's passed params. Especially ensure the correctness of the functionAbi if you're using Custom Contract calls.|\\nNodeStorageError|An error occured while storing the encryption condition. Please look at the returned error for more info.|\\nNodeWrongNetwork|Either you didn't pass a chain param or it's invalid/not supported yet. Please see all the supported chain [here](../../resources/supportedchains/)|\\nNodeHTTPConversionError|Internal error with the RPC url for the provided chain param. Please try again. If this error persists contact us on Discord.|\\nNodeUnknownError|An unknow error occured. Please try again. If this error persists contact us on Discord.|\\nNodeParserError|Error parsing a provided param. Please look at the returned error for more info.|\\nNodeSIWECapabilityInvalid|Either the SIWE capability param isn't provided or is invalid. Please look at the returned error for more info.|\\nNodeSIWECapabilityActionInvalid|Invalid SIWE capability's permittedAction param. Please look at the returned error for more info.|\\nNodeSIWESigConversionError|Invalid SIWE capability's sig param. Please look at the returned error for more info.|\\nNodeSIWESessionKeySignatureInvalid|session.pubkey isn't signed in the wallet-signed SIWE message.|\\nNodeBlockchainError|Error making an on-chain call. Please look at the returned error for more info.|\\nNodeBlockchainChainUnknown|Invalid chain value for the provided Authsig.sig param. Please see all the supported chain [here](../../resources/supportedchains/)]|\\nNodeWalletSignatureJSONError|Error parsing Authsig. Please look at the returned error for more info.|\\nNodePOAPJSONError|Internal error parsing POAP as a JSON. Please try again. If this error persists contact us on Discord.|\\nNodeCosmosJSONError|Error parsing Cosmos result. Please ensure that the Cosmos condition passed is correct.|\\nNodeSIWEMessageError|Invalid SIWE message. Please look at the returned error for more info.|\\nNodeInvalidSIWEResource|Invalid SIWE resource params. Please look at the returned error for more info.|\\nNodeInvalidSIWESpecialParam|Invalid SIWE special resource params. Please look at the returned error for more info.|\\nNodeSIWESpecialParamAddressConversionError|The passed SIWE special param \\\":userAddress\\\" is invalid. Ensure that the passed address is Ethereum compatible.|\\nNodeInvalidACCReturnValueTest|Invalid returnValueTest. Please look at the returned error for more info.|\\nNodeRecoveryIdError|Invalid \\\"recovery id\\\" for Cosmos. Please ensure the correctness of the Cosmos Authsig.|\\nNodeCosmosResponseBodyError|Invalid Cosmos access control conditions.|\\nNodeMismatchParameters|Number of function params doesn't match the number of the condition params.|\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Node Client with Yarn\nDESCRIPTION: Command to install the Lit Protocol node client package via Yarn. This is required to interact with the Datil mainnet, with minimum SDK version 6.4.0.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/mainnets.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient\nDESCRIPTION: Demonstrates how to initialize and connect a LitNodeClient instance to the network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNodeClient: LitNodeClientNodeJs = new LitNodeClientNodeJs({\n    litNetwork: \"datil-dev\",\n    debug: true\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Access Control Conditions TypeScript Definition\nDESCRIPTION: TypeScript definition of access control conditions used when generating a wrapped key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain: CHAIN_ETHEREUM,\n        method: '',\n        parameters: [':userAddress'],\n        returnValueTest: {\n        comparator: '=',\n        value: pkpAddress,\n        },\n    },\n];\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Lit Network in Server Environment\nDESCRIPTION: Code to disconnect from the Lit Network to allow a Node.js process to exit gracefully by stopping the litNodeClient listeners.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nawait app.locals.litNodeClient.disconnect();\n```\n\n----------------------------------------\n\nTITLE: Creating Lit Class for Encryption and Decryption\nDESCRIPTION: This code snippet creates a Lit class that initializes the Lit Node Client and provides a connection method. It's used to set up the environment for encryption and decryption functions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n\nconst client = new LitJsSdk.LitNodeClient();\n\nclass Lit {\n  litNodeClient;\n\n  async connect() {\n    await client.connect();\n    this.litNodeClient = client;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking ERC20 Token Possession in JavaScript\nDESCRIPTION: This snippet defines an access control condition to verify if a user possesses at least one ERC20 token. It uses the balanceOf method to check the token balance for a specific contract address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2',\n    standardContractType: 'ERC20',\n    chain,\n    method: 'balanceOf',\n    parameters: [\n      ':userAddress'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing LitContracts with PKPEthersWallet\nDESCRIPTION: This code snippet shows how to create an instance of LitContracts using a PKPEthersWallet as the signer. This setup is necessary for interacting with Lit Protocol contracts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\n\nconst litContracts = new LitContracts({\n  signer: pkpWallet,\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Ethers Signer Initialization\nDESCRIPTION: TypeScript code to initialize an Ethers signer using a private key and RPC provider.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ethers from 'ethers';\nimport { LIT_RPC } from \"@lit-protocol/constants\";\n\nconst ethersSigner = new ethers.Wallet(\n    process.env.ETHEREUM_PRIVATE_KEY,\n    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Dependencies\nDESCRIPTION: Installation commands for required Lit Protocol packages including node client, auth client, contracts SDK, constants, and providers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-contracts.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\nyarn add @lit-protocol/lit-auth-client\nyarn add @lit-protocol/contracts-sdk\nyarn add @lit-protocol/constants\nyarn add @lit-protocol/providers\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Lit Protocol and Pimlico Integration\nDESCRIPTION: This command installs the necessary npm packages for integrating Lit Protocol's OTP sign-in with Pimlico smart accounts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install stytch @lit-protocol/pkp-ethers @lit-protocol/lit-auth-client @lit-protocol/auth-helpers @lit-protocol/types @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: Encoding Smart Contract Call Data\nDESCRIPTION: Uses the Lit SDK to encode function call data for the latestRoundData function using the contract ABI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst callData = LitJsSdk.encodeCallData({\n  abi: aggregatorV3InterfaceABI,\n  functionName: \"latestRoundData\",\n  functionParams: [],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing OpenZeppelin Contracts\nDESCRIPTION: This command installs the OpenZeppelin contracts library, which provides secure, standard implementations of common smart contract patterns.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add @openzeppelin/contracts\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server\nDESCRIPTION: This command starts the Next.js development server, allowing you to run and test the application locally on http://localhost:3000.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/openfort.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Lit Network (Client-Side)\nDESCRIPTION: Code to disconnect the client from the Lit network, allowing the browser to disconnect gracefully.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nawait client.disconnect();\n```\n\n----------------------------------------\n\nTITLE: Registering Payer Wallet with Lit Relayer API (Datil Network)\nDESCRIPTION: Makes a POST request to the Lit Relayer API to register a new payer wallet on the Datil network. This creates a new Capacity Credit for the payer.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await fetch(\n    \"https://datil-relayer.getlit.dev/register-payer\", \n    {\n        method: \"POST\",\n        headers,\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Building a Lit project with GetLit CLI\nDESCRIPTION: Command to build a Lit project using the GetLit CLI after coding the Lit Action and creating the PKP.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngetlit build\n```\n\n----------------------------------------\n\nTITLE: Checking Token Balance for Fungible/NFT Tokens\nDESCRIPTION: Checks if a user owns at least 1 token of a specific address using the custom balanceOfToken RPC method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/sol-rpc-conditions.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"balanceOfToken\",\n    params: [\"FrYwrqLcGfmXrgJKcZfrzoWsZ3pqQB9pjjUC9PxSq3xT\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain,\n    returnValueTest: {\n      key: \"$.amount\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Using signAndSaveAuthMessage in Lit JS SDK V2\nDESCRIPTION: Example of how to use the signAndSaveAuthMessage method in the new Lit JS SDK V2, showing the updated import and method call.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ethConnect } from \"@lit-protocol/auth-browser\";\nconst authSig = await ethConnect.signAndSaveAuthMessage({..});\n```\n\n----------------------------------------\n\nTITLE: Using LitRelay.getRelayUrl in JavaScript\nDESCRIPTION: New static method to get the relay URL for a specific Lit network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LitRelay } from '@lit-protocol/lit-auth-client';\nimport { LIT_NETWORK } from '@lit-protocol/constants';\n\nconst relayUrl = LitRelay.getRelayUrl(LIT_NETWORK.MAINNET);\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient for Lit Network Connection\nDESCRIPTION: This code snippet shows how to create and connect a LitNodeClient instance to the Lit network. It configures the client to use the 'datil-dev' network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litNodeClient = new LitNodeClient({\n    litNetwork: LIT_NETWORK.DatilDev,\n    debug: false,\n});\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Instantiating LitContracts for Smart Contract Interaction\nDESCRIPTION: Code to initialize and connect a LitContracts instance that allows interaction with smart contracts on the Lit network. It uses the previously created Ethers signer.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-lit-action-session-sigs.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitContracts } from \"@lit-protocol/contracts-sdk\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nconst litContracts = new LitContracts({\n    signer: ethersSigner,\n    network: LIT_NETWORK.DatilTest,\n    debug: false,\n});\nawait litContracts.connect();\n```\n\n----------------------------------------\n\nTITLE: Implementing Compression and Encryption with Lit Protocol\nDESCRIPTION: Example showing how to handle compression separately from encryption using a compression library alongside Lit Protocol's encryption functions. Demonstrates the process of compressing data before encryption and decompressing after decryption.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { zip, unzip } from 'your-preferred-compression-library';\nimport { encryptUint8Array, decryptToUint8Array } from '@lit-protocol/encryption';\n\n// Compress data\nconst compressedData = zip(data);\n\n// Encrypt compressed data\nconst encryptedData = await encryptUint8Array({\n  uint8Array: compressedData,\n  // ...other parameters\n});\n\n// Decrypt data\nconst decryptedData = await decryptToUint8Array({\n  // ...parameters\n});\n\n// Decompress data\nconst originalData = unzip(decryptedData);\n```\n\n----------------------------------------\n\nTITLE: Fetching Auth Methods for PKP in Lit Protocol\nDESCRIPTION: This snippet demonstrates how to retrieve the list of permitted authentication methods for a specific Programmable Key Pair (PKP) using the PKPPermissions contract in Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/add-remove-auth-methods.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst authMethods =\n  await litContracts.pkpPermissionsContract.read.getPermittedAuthMethods(\n    \"<The token ID of your PKP>\"\n  );\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Node Client with NPM\nDESCRIPTION: Command to install the Lit Node Client SDK using NPM package manager. Requires minimum version 6.4.0 for Datil network compatibility.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/testnets.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Share Modal with NPM\nDESCRIPTION: Command to install the lit-share-modal-v3 package using NPM package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Tools/shareModal.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpm install --save lit-share-modal-v3\n```\n\n----------------------------------------\n\nTITLE: Example Authentication Method Response\nDESCRIPTION: Shows the structure of a successful authentication response containing the JWT access token.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/authentication/sessionSigs/authMethods/email-sms.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    \"accessToken\": \"eyJhbGciOiJzZWNwMjU2azEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJMSVQtUHJvdG9jb2wiLCJzdWIiOiJMSVQtT1RQIiwiaWF0IjoxNjg0ODc1NTE0NDkxLCJleHAiOjE2ODQ4NzczMTQ0OTEsIm9yZ0lkIjoiTElUIiwicm9sZSI6InVzZXIiLCJleHRyYURhdGEiOiIrMTIwMTQwNzIwNzN8MjAyMy0wNS0yM1QyMDo1ODozNC40OTE3ODU5NDUrMDA6MDAifQ.eyJyIjoiZTA0ZDAyNjhjN2ExMzhiNmZiNDJjYTk4NmIxY2I4MWM0N2QyMTc0MzZlOWNlYzc4NGUzNWEyOTZkZmY2YjA4NSIsInMiOiI0NTE5MTVkMDY5YTZhZGE5M2U0OGY3ODUwMGM0MWUzNmMwYzQ4Y2FlODYwMmYxYWM0Njc0MTQ1YTNiMmMyNDU4In0\",\n    \"authMethodType\": 7\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Lit Action with GetLit CLI\nDESCRIPTION: Example of using the 'getlit test' command to test a specific Lit Action named 'foo'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngetlit test foo\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK with yarn\nDESCRIPTION: Command to install the @lit-protocol/lit-node-client package using yarn package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/installing-sdk.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Defining Lit Action Condition in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create an access control condition using a Lit Action stored on IPFS. It specifies the IPFS CID, method to call, parameters, and the expected return value.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/conditionTypes/litActionConditions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"ipfs://QmcgbVu2sJSPpTeFhBd174FnmYmoVYvUFJeDkS7eYtwoFY\",\n    standardContractType: \"LitAction\",\n    chain: \"ethereum\",\n    method: \"go\",\n    parameters: [\"40\"],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"true\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Converting Bytes to Multihash in LitContracts\nDESCRIPTION: Utility method to convert bytes32 format to IPFS ID.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst multihash = LitContracts.utils.getMultihashFromBytes(byte32);\n```\n\n----------------------------------------\n\nTITLE: Using signAndSaveAuthMessage in Lit JS SDK V1\nDESCRIPTION: Example of how to use the signAndSaveAuthMessage method in the old Lit JS SDK (V1).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"lit-js-sdk\"; \nconst authSig = await LitJsSdk.signAndSaveAuthMessage({..});\n```\n\n----------------------------------------\n\nTITLE: IPFS CID Access Control Configuration\nDESCRIPTION: Shows how to configure access control parameters using IPFS CID to restrict decryption to specific Lit Actions. This ensures that only designated Lit Actions can decrypt sensitive data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/combining-decryption-shares.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  contractAddress: '',\n  standardContractType: '',\n  chain: 'ethereum',\n  method: '',\n  parameters: [':currentActionIpfsId'],\n  returnValueTest: {\n    comparator: '=',\n    value: '<YOUR_LIT_ACTION_IPFS_CID>',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Lit SDK packages for client and server environments\nDESCRIPTION: Commands for installing the Lit Protocol SDK packages depending on whether you're using it in a browser or Node.js environment.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: Defining GeneratePrivateKeyResult Interface in TypeScript\nDESCRIPTION: This snippet shows the TypeScript interface for the GeneratePrivateKeyResult object, which is returned by the generatePrivateKey function after successfully generating, encrypting, and storing the private key metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/generating-wrapped-key.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GeneratePrivateKeyResult {\n  pkpAddress: string;\n  generatedPublicKey: string;\n  id: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NFT Struct and Mapping\nDESCRIPTION: Struct definition for NFT metadata including encrypted fields and mapping from token ID to NFT struct.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/smartContract.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n    mapping(uint256 => nft) private tokenIdToNft;\n\n    struct nft {\n        string name;\n        string imageUrl;\n        string encryptedDescription;\n        string encryptedSymmetricKey;\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol PKP Session Signatures\nDESCRIPTION: Commands to install the required npm packages for working with Lit Protocol PKP Session Signatures using npm or yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-pkp-session-sigs.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/contracts-sdk \\\n@lit-protocol/lit-auth-client \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/contracts-sdk \\\n@lit-protocol/lit-auth-client \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK in JavaScript\nDESCRIPTION: Code snippet demonstrating how to import the Lit JS SDK in a JavaScript file. This allows access to all the SDK functionalities.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/4.0.0.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n```\n\n----------------------------------------\n\nTITLE: Using getAuthIdByAuthMethod Function in JavaScript\nDESCRIPTION: Replacement for the static method LitAuthClient.getAuthIdByAuthMethod with a standalone function.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\n\nconst authId = getAuthIdByAuthMethod(authMethod);\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethers Signer for Lit Protocol\nDESCRIPTION: TypeScript code to initialize an Ethers signer using a private key from an environment variable. This signer is used for interacting with the Lit Protocol network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-pkp-session-sigs.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LIT_RPC } from \"@lit-protocol/constants\";\nimport * as ethers from \"ethers\";\n\nconst ethersSigner = new ethers.Wallet(\n  process.env.ETHEREUM_PRIVATE_KEY,\n  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)\n);\n```\n\n----------------------------------------\n\nTITLE: Deploying Lit Actions with GetLit CLI\nDESCRIPTION: Command to deploy built Lit Actions using the GetLit CLI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngetlit deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring LitNodeClient with Debug Logging\nDESCRIPTION: This code snippet demonstrates how to configure the LitNodeClient object, specifically turning off debug logging.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new LitJsSdk.LitNodeClient({debug: false})\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies using yarn\nDESCRIPTION: This bash command installs the necessary yarn packages for implementing the importPrivateKey function, including Lit Protocol libraries and ethers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Cloning and installing the example repository\nDESCRIPTION: Commands to clone the OrbisDB-Lit example repository and install dependencies. This is the initial setup needed to follow the tutorial.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ceramicstudio/orbisdb-lit-example && cd orbisdb-lit-example\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Converting IPFS CID to Bytes for PKPPermissions Contract in JavaScript\nDESCRIPTION: This snippet demonstrates how to convert an IPFS CID to bytes format for use with the PKPPermissions contract. It uses the bs58 library to decode the CID and convert it to a hexadecimal string.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/support/faq.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getBytesFromMultihash(ipfsId) {\n  const decoded = bs58.decode(ipfsId);\n\n  return `0x${Buffer.from(decoded).toString(\"hex\")}`;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies using npm\nDESCRIPTION: This bash command installs the necessary npm packages for implementing the importPrivateKey function, including Lit Protocol libraries and ethers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Defining Solana Access Control Conditions\nDESCRIPTION: Example of Lit Access Control Conditions for Solana that checks if the authenticated wallet address matches an authorized address. The condition uses a simple equality comparison.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/siws-access-control.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n[\n    {\n        method: \"\",\n        params: [\":userAddress\"],\n        pdaParams: [],\n        pdaInterface: { offset: 0, fields: {} },\n        pdaKey: \"\",\n        chain: \"solana\",\n        returnValueTest: {\n            key: \"\",\n            comparator: \"=\",\n            // This address would be the Solana public key that is authorized to access the app,\n            // and you would replace it with the actual public key that you want to authorize.\n            value: address,\n        },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK\nDESCRIPTION: Commands for installing the Lit Protocol SDK in browser and NodeJS environments\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: Debug Log Example for LitNodeClient\nDESCRIPTION: Example of debug log output from LitNodeClient showing the request ID format used for support purposes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/connecting-to-lit.md#2025-04-18_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[Lit-JS-SDK v6.8.1] [2024-10-12T02:45:37.100Z] [DEBUG] [core] [id: a1eefc564ff6b] executeJs responseData from node\n```\n\n----------------------------------------\n\nTITLE: Defining ComposeDB Posts Schema\nDESCRIPTION: GraphQL schema definition for the Posts model that stores encrypted message data with Lit Protocol metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/ceramic-example.md#2025-04-18_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Posts @createModel(accountRelation: LIST, description: \"A simple Post\") {\n  author: DID! @documentAccount\n  body: String! @string(maxLength: 100000)\n  to: String! @string(minLength: 42, maxLength: 42)\n  edited: DateTime\n  created: DateTime!\n  ciphertext: String @string(maxLength: 100000)\n  chain: String @string(maxLength: 100000)\n  accessControlConditions: String @string(maxLength: 100000)\n  accessControlConditionType: String @string(maxLength: 100000)\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Encryption/Decryption Functions in TypeScript\nDESCRIPTION: Shows migration for various encryption and decryption functions including decryptToString, encryptToJson, decryptFromJson, and related methods.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nimport * as LitJsSdk from '@lit-protocol/lit-node-client';\nimport { AuthSig, SessionSigsMap } from '@lit-protocol/types';\n\nconst authSig: AuthSig = {} // Your Auth Sig;\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst decryptedString = await LitJsSdk.decryptToString({\n  authSig: authSig,\n\tsessionSigs: sessionSigs;\n\t// the rest of your code...\n});\n\n// v6\nimport * as LitJsSdk from '@lit-protocol/lit-node-client';\nimport { SessionSigsMap } from '@lit-protocol/types';\n\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst decryptedString = await LitJsSdk.decryptToString({\n  sessionSigs,\n\t// the rest of your code...\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying and Testing Hardhat Smart Contract\nDESCRIPTION: These commands start a local Hardhat network and deploy the sample smart contract to it for testing purposes.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nnpx hardhat node\nnpx hardhat run scripts/deploy.js --network localhost\n```\n\n----------------------------------------\n\nTITLE: Chronicle Network Configuration Parameters\nDESCRIPTION: Network configuration parameters required for connecting to the Chronicle rollup testnet, including chain ID, RPC URL, and currency details\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/intro/rollup.mdx#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Parameter Name     | Value                                  |\n| ------------------ | -------------------------------------- |\n| Chain ID           | 175177                                 |\n| Name               | Chronicle - Lit Protocol Testnet       |\n| RPC URL            | https://chain-rpc.litprotocol.com/http |\n| Block Explorer URL | https://chain.litprotocol.com/         |\n| Currency Symbol    | LIT                                    |\n| Currency Decimals  | 18                                     |\n```\n\n----------------------------------------\n\nTITLE: Running the application in developer mode\nDESCRIPTION: Commands to ensure the correct Node.js version is used and to start the application in development mode.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnvm use 20\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Checking Ceramic Node Health\nDESCRIPTION: cURL command to verify that the local Ceramic node is running properly.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/ceramic-example.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:7007/api/v0/node/healthcheck\n```\n\n----------------------------------------\n\nTITLE: Defining ImportPrivateKeyResult Interface in TypeScript\nDESCRIPTION: This code snippet defines the ImportPrivateKeyResult interface, which represents the structure of the object returned by the importPrivateKey function. It includes the PKP address and a unique identifier for the encrypted private key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/importing-key.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ImportPrivateKeyResult {\n  pkpAddress: string;\n  id: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying foo.action.ts in a Lit project\nDESCRIPTION: Example of how to modify the 'foo.action.ts' file to pass schema validation in a newly initialized Lit project.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * NA_E: foo\n *\n * ⬆️ Replace \"_\" with \"M\" to pass the schema validation\n *\n */\n \nconst foo = () => {\n  return \"bar\";\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Polygon Mumbai Contract Parameters in JavaScript\nDESCRIPTION: Code snippet demonstrating how to set up contract address and network parameters for Polygon Mumbai testnet. Includes configuration for contract address, chain ID, network name, native currency details, RPC URLs, and block explorer URLs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/polygonMumbai.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst litNFTContractAddress = \"0xBb6fd36bf6E45FBd29321c8f915E456ED42fDc13\"; // this is our contract, replace it with yours\nconst mumbaiTestnet = {\n  chainId: \"0x13881\",\n  chainName: \"Matic Mumbai\",\n  nativeCurrency: {\n    name: \"MATIC\",\n    symbol: \"MATIC\",\n    decimals: 18,\n  },\n  rpcUrls: [\"https://rpc-mumbai.maticvigil.com/\"],\n  blockExplorerUrls: [\"https://mumbai.polygonscan.com/\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol SDK\nDESCRIPTION: This snippet shows how to install the required dependencies for the Lit Protocol SDK using npm or yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Displaying Testnet Networks Table in Markdown\nDESCRIPTION: This code block defines a table in Markdown format that lists various test networks, their descriptions, supported features, and other relevant information for Lit Protocol developers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/networks/testnet.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Name | Description | Supported Algorithms | Supported Features | Status | SDK Version | Development status  | Contracts |\n| ---- | ----------- | -------------------- | ------------------ | ------ | ----------- | -------------------- | --------- |\n| Serrano | Centralized test network. Keys are persistent. | BLS, ECDSA | Encryption, User Wallets (PKPs), Serverless Signing (Lit Actions) | [Live](https://serrano-status.litprotocol.com/) | V1, V2 | Deprecated.  Do not build new apps that use this network. | [serrano](https://github.com/LIT-Protocol/networks/tree/main/serrano) |\n| Cayenne | Centralized test network. Keys are not persistent and will be deleted.  This network does not enforce payment and can be used for free, for testing. | BLS, ECDSA | Encryption, User Wallets (PKPs), Serverless Signing (Lit Actions) | Live | V4+ | Deprecated. Do not build new apps that use this network.| [cayenne](https://github.com/LIT-Protocol/networks/tree/main/cayenne) |\n| Manzano | Decentralized test network. No persistency guarantees.  Mirrors Habanero code and configuration.  Payment is enforced. | BLS, ECDSA | Encryption, User Wallets (PKPs), Serverless Signing (Lit Actions) | Live | V4+ | Deprecated. Do not build new apps that use this network | [manzano](https://github.com/LIT-Protocol/networks/tree/main/manzano) \n| Datil-dev | Centralized test network. Keys are not persistent and will be deleted. This network does not enforce payment and can be used for free, for testing. | BLS, ECDSA | Encryption, User Wallets (PKPs), Serverless Signing (Lit Actions), Wrapped Keys | Live | V6+ | Good to use | [datil-dev](https://github.com/LIT-Protocol/networks/tree/main/datil-dev) \n| Datil-test | Decentralized test network. No persistency guarantees. Mirrors Datil code and configuration. Payment is enforced. | BLS, ECDSA | Encryption, User Wallets (PKPs), Serverless Signing (Lit Actions), Wrapped Keys | Live | V6+ | Good to use | [datil-test](https://github.com/LIT-Protocol/networks/tree/main/datil-test) |\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK for Node.js\nDESCRIPTION: Import the Lit JS SDK V2 Node.js package for JWT verification and Lit Protocol interactions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n```\n\n----------------------------------------\n\nTITLE: Checking ATOM Balance in Cosmos Network\nDESCRIPTION: Verifies if a user's wallet contains at least 1 ATOM token by checking their balance through the Cosmos bank API. Uses the :userAddress parameter which is automatically populated with the user's verified wallet address.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/cosmosConditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \"/cosmos/bank/v1beta1/balances/:userAddress\",\n    chain,\n    returnValueTest: {\n      key: \"$.balances[0].amount\",\n      comparator: \">=\",\n      value: \"1000000\", // equals 1 ATOM\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Installing Lit JS SDK V2\nDESCRIPTION: This command installs the Lit JS SDK V2, which is used for encrypting and decrypting content in the Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add @lit-protocol/lit-node-client@serrano\n```\n\n----------------------------------------\n\nTITLE: Parsing API Response Data\nDESCRIPTION: Parses the JSON response from the API and checks for success, throwing an error if unsuccessful.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = (await response.json()) as AddUserResponse;\n    if (data.success !== true) {\n      throw new Error(`Error: ${data.error}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an environment file from template\nDESCRIPTION: Command to create a copy of the example environment file for configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK with npm\nDESCRIPTION: Command to install the @lit-protocol/lit-node-client package using npm package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/installing-sdk.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: SerializedTransaction Interface for Solana Transaction Signing\nDESCRIPTION: Interface defining the structure of a serialized unsigned Solana transaction for use with the signTransactionWithEncryptedKey function. It includes properties for the chain and the serialized transaction data.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-transaction.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SerializedTransaction {\n  chain: string;\n  serializedTransaction: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Encrypting Content Within a Lit Action in JavaScript\nDESCRIPTION: This code snippet illustrates the process of encrypting content within a Lit Action. It sets up access control conditions, initializes a Lit Node Client, and executes a JavaScript function to perform the encryption. The encrypted content is then available for further processing within the action.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/encryption.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n    {\n        contractAddress: '',\n        standardContractType: '',\n        chain,\n        method: 'eth_getBalance',\n        parameters: [':userAddress', 'latest'],\n        returnValueTest: {\n        comparator: '>=',\n        value: '0',\n        },\n    },\n];\nconst message = 'Hello world';\nconst client = new LitNodeClient({\n    litNetwork: \"datil-dev\"\n});\n\nawait client.connect();\n\nconst code =`(async () => {\n    let { ciphertext, dataToEncryptHash } = Lit.Actions.encrypt({\n        accessControlConditions,\n        to_encrypt: dataToEncrypt\n    });\n    // your logic for processing the ciphertext\n}))();`;\nconst res = await LitJsSdk.executeJs({\n    sessionSigs: {}, // your session\n    code,\n    jsParams: {\n        accessControlConditions,\n        dataToEncrypt: message,\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Wrapped Keys SDK\nDESCRIPTION: This code snippet shows how to install the necessary dependencies for using the Wrapped Keys SDK, including various Lit Protocol packages and ethers.js. It provides commands for both npm and yarn package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/listing-wrapped-keys.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Adding a Subcategory to Sidebar in JavaScript\nDESCRIPTION: JavaScript configuration for adding a nested subcategory to an existing sidebar category. Demonstrates the hierarchical structure of sidebar items.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\ndocs: [\n  // ...\n  {\n    type: 'category',\n    label: 'Tea Drinks',\n    collapsible: false,\n    className: 'category-not-collapsible',\n    items: [\n      'tea-drinks/intro',\n      // Add your new subcategory here\n      {\n        type: 'category',\n        label: 'Hot Drinks',\n        collapsed: true,\n        items: [\n          // Add the IDs of your new subcategory's pages here\n          'tea-drinks/hot-drinks/intro',\n        ],\n      },\n    ],\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing LitNodeClient Required Packages\nDESCRIPTION: Installation commands for the core Lit Protocol packages needed to interact with Lit nodes, including the client, crypto utilities, and authentication helpers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @lit-protocol/lit-node-client\nnpm i @lit-protocol/crypto\nnpm i @lit-protocol/auth-helpers\n```\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\nyarn add @lit-protocol/crypto\nyarn add @lit-protocol/auth-helpers\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Lit Protocol\nDESCRIPTION: This code snippet shows how to install the necessary dependencies for working with Lit Protocol and Wrapped Keys using npm or yarn. It includes packages for authentication, constants, node client, and wrapped keys functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/getting-wrapped-key-metadata.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Installing GetLit CLI using npm or yarn\nDESCRIPTION: Commands to install the GetLit CLI globally using either npm or yarn package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g getlit\n\n// or\nyarn add global getlit\n```\n\n----------------------------------------\n\nTITLE: Parsing Lit Relayer API Response for Payer Registration\nDESCRIPTION: Extracts the payer wallet address and secret key from the successful API response.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { payerWalletAddress, payerSecretKey } = (await response.json()) as RegisterPayerResponse;\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol with NPM\nDESCRIPTION: Command to install required dependencies from NPM for delegating capacity credits in Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/delegating-credit.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK\nDESCRIPTION: Import statement to use the Lit JS SDK in your project.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/quick-start.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n```\n\n----------------------------------------\n\nTITLE: Verifying ERC1155 Token Batch Possession in JavaScript\nDESCRIPTION: This code snippet sets up an access control condition to check if a user owns at least one ERC1155 token from a batch of specified token ids. It utilizes the balanceOfBatch method to check multiple token balances simultaneously.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/basicExamples.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst accessControlConditions = [\n  {\n    contractAddress: '0x10daa9f4c0f985430fde4959adb2c791ef2ccf83',\n    standardContractType: 'ERC1155',\n    chain,\n    method: 'balanceOfBatch',\n    parameters: [\n      ':userAddress,:userAddress,:userAddress,:userAddress',\n      '1,2,10003,10004'\n    ],\n    returnValueTest: {\n      comparator: '>',\n      value: '0'\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol SDK for Node.js Only\nDESCRIPTION: Command to install the Node.js-specific version of the Lit Protocol SDK using yarn.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/installation.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn\nDESCRIPTION: Command to install all required dependencies for the Lit Protocol documentation website using Yarn package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Displaying Custom Components in Markdown\nDESCRIPTION: This snippet demonstrates how to include custom React components within a Markdown file. It's using JSX syntax to render the StateOfTheNetwork and FeedbackComponent.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<StateOfTheNetwork/>\n\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Importing Required Packages for Transaction Signing\nDESCRIPTION: Imports necessary packages for handling Ethereum transactions and cryptographic operations with Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as LitJsSdk from '@lit-protocol/lit-node-client';\nimport fs from \"fs\";\nimport { serialize, recoverAddress } from \"@ethersproject/transactions\";\nimport {\n  hexlify,\n  splitSignature,\n  hexZeroPad,\n  joinSignature,\n} from \"@ethersproject/bytes\";\nimport { recoverPublicKey, computePublicKey } from \"@ethersproject/signing-key\";\n```\n\n----------------------------------------\n\nTITLE: Running Development Environment\nDESCRIPTION: Commands to set Node.js version and start the development server.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/ceramic-example.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnvm use 16\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing GetLit CLI using npm or yarn\nDESCRIPTION: Instructions for installing the GetLit CLI globally using either npm or yarn package managers.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/getlitCli.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g getlit\n\n// or\nyarn add global getlit\n```\n\n----------------------------------------\n\nTITLE: Importing SupportedChainCard Component in JSX\nDESCRIPTION: Imports the SupportedChainCard component from the site components directory. This component is used later in the document to display supported EVM-based chains.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/resources/supported-chains.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport SupportedChainCard from '@site/src/components/SupportedChainCard';\n```\n\n----------------------------------------\n\nTITLE: Deriving PKP with GetLit CLI\nDESCRIPTION: Command to derive a PKP (Programmable Key Pair) using user and project IDs with the GetLit CLI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngetlit derive-pkp --userId --projectId --format\n```\n\n----------------------------------------\n\nTITLE: Encrypting Static Content with Lit Protocol\nDESCRIPTION: Demonstrates how to encrypt static content using Lit Protocol by converting content to string format, encrypting it, and saving the encryption key with access control conditions.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/bundlrxarweave.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst chain = \"ethereum\";\n\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });\n\n// Visit here to understand how to encrypt static content\n// <https://developer.litprotocol.com/docs/LitTools/JSSDK/staticContent>\nconst { encryptedString, symmetricKey } = await LitJsSdk.encryptString(\n  fileInString\n);\n\nconst encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({\n  accessControlConditions: accessControlConditions.accessControlConditions,\n  symmetricKey,\n  authSig,\n  chain,\n});\n\nconsole.log(\"encryptedString:\", encryptedString);\n```\n\n----------------------------------------\n\nTITLE: Modifying package.json Scripts for react-app-rewired\nDESCRIPTION: This JSON snippet shows how to modify the start script in package.json to use react-app-rewired for overriding webpack configuration in Create React App.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n\"scripts: {\n  ...\n  \"start\": \"react-app-rewired start\",\n}\"\n```\n\n----------------------------------------\n\nTITLE: Installing Lit JS SDK V2 for Node Environment\nDESCRIPTION: Command to install the Lit JS SDK V2 package specifically for Node environment using npm.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: React Component Import for Documentation\nDESCRIPTION: Import statements for Docusaurus tab components used in documentation formatting.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n```\n\n----------------------------------------\n\nTITLE: Copying Environment Variables Template\nDESCRIPTION: This command creates a new .env.local file by copying the example file, which will be used to store configuration variables for the application.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/openfort.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp .env.local.example .env.local\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing required dependencies using npm or yarn package managers. Includes core Lit Protocol packages and ethers.js.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/sign-message.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Initializing Hardhat Project\nDESCRIPTION: This command initializes a basic Hardhat project with JavaScript, creating the necessary boilerplate files and structure.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/setup.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpx hardhat init\n```\n\n----------------------------------------\n\nTITLE: Setting Smart Contract Address\nDESCRIPTION: Defines the Ethereum address for the Chainlink price oracle smart contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst addr = \"0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\";\n```\n\n----------------------------------------\n\nTITLE: React Import Statements\nDESCRIPTION: Import statements for Docusaurus tab components used in the documentation\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/overview.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n```\n\n----------------------------------------\n\nTITLE: Initializing a new Lit project with GetLit CLI\nDESCRIPTION: Example of using the 'getlit action' command to initialize a new Lit project, showing the resulting directory structure.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngetlit action\n```\n\n----------------------------------------\n\nTITLE: Configuring Openfort API Keys in Environment File\nDESCRIPTION: This snippet shows the format for adding Openfort API keys to the .env.local file. These keys are essential for authenticating with the Openfort service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/openfort.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nNEXT_PUBLIC_OPENFORT_PUBLIC_KEY=\"<replace with your publishable key>\"\nNEXTAUTH_OPENFORT_SECRET_KEY=\"<replace with your secret key>\"\n```\n\n----------------------------------------\n\nTITLE: Adding a Version Dropdown to Docusaurus Navigation\nDESCRIPTION: This code snippet modifies the 'docusaurus.config.js' file to add a version dropdown to the navigation bar. It allows users to easily switch between different versions of the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/manage-docs-versions.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'docsVersionDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in JSX/React\nDESCRIPTION: This code imports a feedback component from a Markdown file in the site's pages directory. The component is then used in the document to allow users to provide feedback.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/additional-examples/intro.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Docusaurus Blog Post Frontmatter in YAML\nDESCRIPTION: YAML configuration block that defines metadata for a Docusaurus blog post, including slug, title, author information, and tags.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/blog/2019-05-28-first-blog-post.md#2025-04-18_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nslug: first-blog-post\ntitle: First Blog Post\nauthors:\n  name: Gao Wei\n  title: Docusaurus Core Team\n  url: https://github.com/wgao19\n  image_url: https://github.com/wgao19.png\ntags: [hola, docusaurus]\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Ceramic SDK with Yarn\nDESCRIPTION: Commands to create a new yarn project and install the Lit Ceramic SDK package.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Integrations/Ceramic/installation.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn init\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add lit-ceramic-sdk\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data Using BLS SDK in Lit Protocol V3\nDESCRIPTION: Example of using the encrypt method in the BLS SDK to perform client-side encryption. This requires a public key, secret message converted to a string, and an identity parameter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst publicKey =\n  '8e29447d7b0666fe41c357dbbdbdac0ac8ac973f88439a07f85fa31fa6fa3cea87c2eaa8b367e1c97764800fb5636892';\n\nconst secretMessage = new Uint8Array([\n  240, 23, 185, 6, 87, 33, 173, 216, 53, 84, 80, 135, 190, 16, 58, 85, 97, 75,\n  3, 192, 215, 82, 217, 5, 40, 65, 2, 214, 40, 177, 53, 150,\n]);\n\nconst identityParam = new Uint8Array([\n  101, 110, 99, 114, 121, 112, 116, 95, 100, 101, 99, 114, 121, 112, 116, 95,\n  119, 111, 114, 107, 115,\n]);\n\nconst ciphertext = blsSdk.encrypt(\n  publicKey,\n  uint8arrayToString(secretMessage, 'base64'),\n  uint8arrayToString(identityParam, 'base64')\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Wrapped Keys SDK with NPM\nDESCRIPTION: Command to install the Lit Protocol Wrapped Keys SDK using NPM package manager. Requires minimum SDK version 6.4.0.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @lit-protocol/wrapped-keys\n```\n\n----------------------------------------\n\nTITLE: Initializing ERC721 Contract with Counter\nDESCRIPTION: Basic contract setup inheriting from ERC721URIStorage and implementing token ID counter.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/OnchainMetadata/smartContract.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract LitNft is ERC721URIStorage, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds; // for NFT ids\n}\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Lit SDK Documentation\nDESCRIPTION: This code snippet imports custom React components used to structure the documentation for different sections of the Lit SDK. These components likely contain specific content and styling for each section of the SDK documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/intro.mdx#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport LitActionsSection from '@site/src/components/SDKCardSectionsV2/Actions';\nimport AccessControlSection from '@site/src/components/SDKCardSectionsV2/AccessControl';\nimport ResourcesSection from '@site/src/components/SDKCardSectionsV2/Resources';\nimport QuickStartSection from '@site/src/components/SDKCardSectionsV2/QuickStart';\n```\n\n----------------------------------------\n\nTITLE: Rendering Lit SDK Documentation Sections\nDESCRIPTION: This code snippet renders the imported React components to create the structure of the Lit SDK documentation. Each component represents a different section of the documentation, including Quick Start, Access Control, Lit Actions, and Resources.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/intro.mdx#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<QuickStartSection title=\"Quick Start\"></QuickStartSection>\n\n<AccessControlSection title=\"Access Control\"></AccessControlSection>\n\n<LitActionsSection title=\"Working with Lit Actions\"></LitActionsSection>\n\n<ResourcesSection title=\"Resources\"></ResourcesSection>\n```\n\n----------------------------------------\n\nTITLE: Handling Lit Relayer API Response Errors\nDESCRIPTION: Checks if the API response is successful and throws an error with the response text if not.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nif (!response.ok) {\n    throw new Error(`Error: ${await response.text()}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Docusaurus Sidebar Configuration\nDESCRIPTION: Shows how to explicitly configure the sidebar in sidebars.js by modifying the items array in the tutorial category.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-document.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  tutorialSidebar: [\n    {\n      type: 'category',\n      label: 'Tutorial',\n-     items: [...],\n+     items: ['hello'],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Embedding Replit Project in NextJS for Token Gating\nDESCRIPTION: This code snippet shows how to embed a Replit project demonstrating NextJS integration with Lit Protocol for token gating. The iframe is set to display none, likely for dynamic showing/hiding.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/examples.md#2025-04-18_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<iframe frameborder=\"0\" width=\"100%\" height=\"500px\" className=\"repls\" style={{display: \"none\"}} src=\"https://replit.com/@lit/NextJS-x-Lit-Token-Gating#pages/index.js\"></iframe>\n```\n\n----------------------------------------\n\nTITLE: Building Docusaurus Site for Production\nDESCRIPTION: Builds the Docusaurus site for production by generating static files in the build folder.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/deploy-your-site.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Installing Lit JS SDK V2 for Node.js\nDESCRIPTION: This command installs the @lit-protocol/lit-node-client-nodejs package using Yarn for Node.js environments only.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @lit-protocol/lit-node-client-nodejs\n```\n\n----------------------------------------\n\nTITLE: Installing Alchemy AA Signers Package\nDESCRIPTION: Commands to install the Alchemy Account Abstraction signers package which provides integration between various signers and Alchemy's Account Kit.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/alchemy-account-kit.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @alchemy/aa-signers\n```\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add @alchemy/aa-signers\n```\n\n----------------------------------------\n\nTITLE: OrbisDB post table schema definition\nDESCRIPTION: SQL schema definition for the post table in OrbisDB that will store user data including encrypted content and access control parameters.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/orbis-example.md#2025-04-18_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- LIST accountRelation\ntable post {\n  to text \n  body text \n  chain text\n  edited DateTime\n  created DateTime\n  ciphertext text\n  accessControlConditions text\n  accessControlConditionType text\n}\n```\n\n----------------------------------------\n\nTITLE: Export Private Key Result Interface\nDESCRIPTION: TypeScript interface definition for the result object returned by exportPrivateKey including the decrypted key and metadata.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ExportPrivateKeyResult {\n  pkpAddress: string;\n  decryptedPrivateKey: string;\n  publicKey: string;\n  litNetwork: LIT_NETWORKS_KEYS;\n  keyType: 'K256' | 'ed25519';\n  memo: string;\n  id: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Commands to clone the example repository and install required Node.js dependencies.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/ceramic-example.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ceramicstudio/lit-composedb && cd lit-composedb\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Importing FeedbackComponent in JSX\nDESCRIPTION: This code snippet imports a FeedbackComponent from a Markdown file. It's likely used to include a feedback section at the bottom of the documentation page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/api-reference/v1-sdk.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Error Codes Table for Jalapeno Version\nDESCRIPTION: A table of error codes and their explanations for the Jalapeno version of the Lit Protocol SDK. Includes common errors like authentication failures, access control issues, and system-level problems.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/tests.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| error code                             | reason                                                                                                                                                                                                                                                                                                                    |\n| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| access_control_conditions_check_failed | The Lit nodes failed to check the condition. This means that the Lit nodes could not talk to the chain to check the condition. This could be because the RPC servers are down, or because the condition is making an incorrect smart contract call that reverts.                                                          |\n| encrypted_symmetric_key_not_found      | Could not find the encrypted symmetric key you passed in. You should have already called saveEncryptionKey which returned the encrypted symmetric key.                                                                                                                                                                    |\n| exp_wrong_or_too_large                 | When signing a JWT, the EXP is too large or wrong. This usually means that your system clock is wrong. Please check it and make sure it is set accurately for your timezone.                                                                                                                                              |\n| iat_outside_grace_period               | When signing a JWT, the IAT is outside the grace period. This usually means that your system clock is wrong. Please check it and make sure it is set accurately for your timezone.                                                                                                                                        |\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Documentation\nDESCRIPTION: Imports required for the documentation page including a feedback component and tab components from the theme.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Components in JSX/Markdown\nDESCRIPTION: Renders the imported components to create the documentation page structure, including announcement, quick start guides, core concepts, documentation sections, ecosystem explorer, and feedback component.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/overview.mdx#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<VincentAnnouncement/>\n<QuickStartSection title=\"Quick Start\"></QuickStartSection>\n<CoreConceptsSection title=\"Core Concepts\"></CoreConceptsSection>\n<LearnCodeSection title=\"Documentation\"></LearnCodeSection>\n<EcosystemSection title=\"Explore the Lit Ecosystem\"></EcosystemSection>\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Docusaurus Document in Markdown\nDESCRIPTION: Shows how to create a basic Docusaurus document using markdown syntax. Creates a simple page with a header and formatted text.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-document.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Hello\n\nThis is my **first Docusaurus document**!\n```\n\n----------------------------------------\n\nTITLE: Migrating PKP Ethers Wallet Integration in TypeScript\nDESCRIPTION: Shows how to migrate PKP Ethers wallet integration from v5 to v6, updating the constructor parameters.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nimport { PKPEthersWallet } from '@lit-protocol/pkp-ethers';\n\nconst pkpEthersWallet = new PKPEthersWallet({\n  controllerAuthMethods,\n  controllerAuthSig,\n  pkpPubKey,\n  rpc,\n  litNetwork: globalThis.LitCI.network,\n});\n\n// v6\nimport { PKPEthersWallet } from '@lit-protocol/pkp-ethers';\n\nconst pkpEthersWallet = new PKPEthersWallet({\n  controllerSessionSigs,\n  litNodeClient,\n  pkpPubKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating pkpSign Function in TypeScript\nDESCRIPTION: Demonstrates the migration of pkpSign function from v5 to v6, removing authSig support and requiring sessionSigs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nimport { AuthSig, SessionSigsMap } from '@lit-protocol/types';\n\nconst authSig: AuthSig = {} // Your Auth Sig;\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst res = await litNodeClient.pkpSign({\n\tauthSig: authSig,\n\tsessionSigs: sessionSigs;\n\t// the rest of your code...\n});\n\n// v6\nimport { SessionSigsMap } from '@lit-protocol/types';\n\nconst sessionSigs: SessionSigsMap = {} // Your Session Sig;\n\nconst res = await litNodeClient.pkpSign({\n\tsessionSigs,\n\t// the rest of your code...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Array of User Addresses\nDESCRIPTION: Creates an array of Ethereum addresses representing the users to be added as payees.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = [\n    \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\n    \"0x6c6ee5e31d828de241282b9606c8e98ea48526e2\",\n    \"0x53d284357ec70ce289d6d64134dfac8e511c8a3d\",\n];\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Sections for Lit Protocol\nDESCRIPTION: This code snippet renders the imported React components to create structured sections in the Lit Protocol documentation. Each component represents a different category of information about the protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/intro/overview.mdx#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<QuickStartSection title=\"Quick Start\"></QuickStartSection>\n<CoreConceptsSection title=\"Core Concepts\"></CoreConceptsSection>\n<LearnCodeSection title=\"Learn through Code\"></LearnCodeSection>\n<EcosystemSection title=\"Explore the Lit Ecosystem\"></EcosystemSection>\n```\n\n----------------------------------------\n\nTITLE: Importing FeedbackComponent in JavaScript\nDESCRIPTION: This code imports a FeedbackComponent from a Markdown file, likely used in a documentation website setup.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/api-reference/v3-sdk.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing Components in React/JavaScript\nDESCRIPTION: This code snippet imports two custom components: StateOfTheNetwork and FeedbackComponent. These are likely used to display network status information and a feedback form respectively.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport StateOfTheNetwork from \"@site/src/pages/state-of-the-network.md\";\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component with JavaScript/React\nDESCRIPTION: Imports a feedback component from a Markdown file in the site's source pages directory.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/api-reference/v2-sdk.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Creating Directory for Translated Content\nDESCRIPTION: Creates a directory structure for the French translation of the 'intro.md' file and copies the original file to the new location for translation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/translate-your-site.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p i18n/fr/docusaurus-plugin-content-docs/current/\n\ncp docs/intro.md i18n/fr/docusaurus-plugin-content-docs/current/intro.md\n```\n\n----------------------------------------\n\nTITLE: Using disconnectWeb3 in Lit JS SDK V1\nDESCRIPTION: Example of how to use the disconnectWeb3 method in the old Lit JS SDK (V1).\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"lit-js-sdk\"; \nLitJsSdk.disconnectWeb3();\n```\n\n----------------------------------------\n\nTITLE: Building Localized Docusaurus Site\nDESCRIPTION: Provides commands to build the Docusaurus site for a specific locale (French) or for all configured locales. These commands generate static files for deployment.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/translate-your-site.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build -- --locale fr\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Importing Lit SDK in client-side applications\nDESCRIPTION: Code for importing the Lit SDK in browser environments for connecting to Habanero or Manzano networks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client\";\n```\n\n----------------------------------------\n\nTITLE: Displaying SDK Error Codes and Reasons (Markdown)\nDESCRIPTION: A markdown table listing error codes and their corresponding reasons for the 'jalapeno' version of the Lit Protocol SDK. It includes various error scenarios such as access control failures, encryption key issues, and authorization problems.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/tests.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|error code    |reason    |\n|-|----|\\nacc ess_control_conditions_check_failed|The Lit nodes failed to check the condition. This means that the Lit nodes could not talk to the chain to check the condition. This could be because the RPC servers are down, or because the condition is making an incorrect smart contract call that reverts.|\\nencrypted_symmetric_key_not_found|Could not find the encrypted symmetric key you passed in. You should have already called saveEncryptionKey which returned the encrypted symmetric key.|\\nexp_wrong_or_too_large|When signing a JWT, the EXP is too large or wrong. This usually means that your system clock is wrong. Please check it and make sure it is set accurately for your timezone.\\niat_outside_grace_period|When signing a JWT, the IAT is outside the grace period. This usually means that your system clock is wrong. Please check it and make sure it is set accurately for your timezone.\\nincorrect_access_control_conditions|The access control conditions you passed in do not match the ones that were set by the condition creator for this resourceId or encryptedSymmetricKey.\\ninvalid_auth_sig|The auth_sig passed to the nodes is invalid or could not be verified. Make sure that you are passing the correct auth_sig.\\ninvalid_unified_condition_type|In a unified access control condition, you passed an invalid `conditionType`. Check the docs to see what valid types [here](https://developer.litprotocol.com/docs/accesscontrolconditions/unifiedaccesscontrolconditions/).\\nlit_node_client_not_ready|The Lit node client is not ready. This means that the Lit node client is not connected to the Lit network. You should run `await litNodeClient.connect()` before calling any other methods that use the Lit Node Client.\\nmissing_access_control_conditions|You must pass either access_control_conditions or evm_contract_conditions or sol_rpc_conditions, and you did not pass these things to the nodes.\\nnot_authorized|Thrown when the user does not have access to decrypt or is unauthorized to receive a JWT for an item.\\nresource_id_not_found|Could not find the resource ID you passed in. You should have already called saveSigningCondition with the exact same resource ID.\\nrpc_error|The Lit Node(s) could not complete the RPC call. This could be because the RPC servers are down, or because the RPC call is making an incorrect smart contract call that reverts.\\nstorage_error|An error occurred storing the condition. This usually means that you tried to update a permanent condition, or you tried to update a non-permanent condition from the wrong account. Only the creator of a condition can update it, and only if \\\"permanent\\\": false was originally passed in when storing the condition.\\nwrong_network|The user is on the wrong network. For example, this may mean the user has ethereum selected in their wallet but they were trying to use polygon for the current operation.\\nunknown_error|An unknown error has occurred. Please contact us on Discord to report this error.|\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Markdown Documentation Page\nDESCRIPTION: Shows the frontmatter and basic structure of a simple Markdown documentation page. Demonstrates how to define the title and create a heading without requiring React components.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/src/pages/markdown-page.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Markdown page example\n---\n\n# Markdown page example\n\nYou don't need React to write simple standalone pages.\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive Button with React in MDX\nDESCRIPTION: This snippet demonstrates how to include an interactive React button component within a Docusaurus blog post using MDX. The code creates a simple button that displays an alert message when clicked.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/blog/2021-08-01-mdx-blog-post.mdx#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in Markdown\nDESCRIPTION: This code snippet imports a FeedbackComponent from a specific path, likely used to add a feedback section at the end of the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/intro.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in Markdown\nDESCRIPTION: This code snippet imports a FeedbackComponent from a local Markdown file. It's likely used to include a feedback section at the end of the documentation page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/dependencies.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Using Feedback Component in JSX/React\nDESCRIPTION: This code snippet demonstrates how to use the imported feedback component in a JSX/React document. The component is included as a JSX element at the bottom of the page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/additional-examples/intro.md#2025-04-18_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Configuring i18n in Docusaurus\nDESCRIPTION: Modifies the docusaurus.config.js file to add support for the French locale. This configuration sets English as the default locale and includes both English and French as available locales.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/translate-your-site.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'fr'],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing FeedbackComponent in Markdown\nDESCRIPTION: This code snippet imports a FeedbackComponent from a specific file path. It's likely used to include a feedback section at the end of the document.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/use-cases.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Building Static Content\nDESCRIPTION: Command to generate static website content into the 'build' directory, which can then be deployed to any static content hosting service.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Saving Signing Condition with Lit Protocol\nDESCRIPTION: Save the access control conditions, chain, authentication signature, and resource ID to the Lit nodes, enabling users to request access JWTs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nawait litNodeClient.saveSigningCondition({\n  accessControlConditions,\n  chain,\n  authSig,\n  resourceId,\n});\n```\n\n----------------------------------------\n\nTITLE: Gmail Authentication Flow\nDESCRIPTION: Implementation of Google authentication flow with redirect handling\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/candide.md#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { AuthMethod } from \"@lit-protocol/types\";\n\nconst generateAuthMethod = async () => {\n  const url = new URL(window.location.href);\n  if (!url.searchParams.get(\"provider\")) {\n    console.log(\"Signing in with Google...\");\n    provider.signIn((url) => {\n      window.location.href = url;\n    });\n  } else if (url.searchParams.get(\"provider\") === \"google\") {\n    const authMethod = await provider.authenticate();\n    return authMethod;\n  }\n};\n\nconst authMethod = await generateAuthMethod();\nif (!authMethod) {\n  return;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Locale Dropdown to Navbar\nDESCRIPTION: Modifies the docusaurus.config.js file to add a locale dropdown to the navbar. This allows users to switch between available languages easily.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/translate-your-site.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'localeDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using disconnectWeb3 in Lit JS SDK V2\nDESCRIPTION: Example of how to use the disconnectWeb3 method in the new Lit JS SDK V2, showing the updated import and method call.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/migration.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ethConnect } from \"@lit-protocol/auth-browser\";\nethConnect.disconnectWeb3();\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-collapsible Sidebar Category in JavaScript\nDESCRIPTION: JavaScript configuration for adding a top-level, non-collapsible category to the documentation sidebar. Each category contains items that reference document IDs.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ndocs: [\n  // ...\n  {\n    type: 'category',\n    label: 'Tea Drinks',\n    collapsible: false,\n    className: 'category-not-collapsible',\n    items: [\n      // Add the IDs of your new category's pages here\n      'tea-drinks/intro',\n    ],\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Including FeedbackComponent in Markdown\nDESCRIPTION: This code snippet includes the previously imported FeedbackComponent at the end of the document, likely to provide a feedback mechanism for users.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/networks/testnet.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in Markdown\nDESCRIPTION: Imports a feedback component from a markdown file for use in the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/security.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing Lit JS SDK V2 in Browser\nDESCRIPTION: This code snippet shows how to import the Lit JS SDK V2 in a browser environment after installation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client@serrano\";\n```\n\n----------------------------------------\n\nTITLE: Deploying to GitHub Pages\nDESCRIPTION: Command to build the website and deploy it to GitHub Pages by pushing to the 'gh-pages' branch. Requires GitHub username and SSH configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Creating a Markdown File for a Docusaurus Blog Post\nDESCRIPTION: This snippet demonstrates the structure of a Docusaurus blog post markdown file. It includes front matter with metadata such as slug, title, authors, and tags, followed by the post content.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-blog-post.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nslug: greetings\ntitle: Greetings!\nauthors:\n  - name: Joel Marcey\n    title: Co-creator of Docusaurus 1\n    url: https://github.com/JoelMarcey\n    image_url: https://github.com/JoelMarcey.png\n  - name: Sébastien Lorber\n    title: Docusaurus maintainer\n    url: https://sebastienlorber.com\n    image_url: https://github.com/slorber.png\ntags: [greetings]\n---\n\nCongratulations, you have made your first post!\n\nFeel free to play around and edit this post as much you like.\n```\n\n----------------------------------------\n\nTITLE: Setting up AuthSig and PKP with GetLit CLI\nDESCRIPTION: Command to set up the configuration for AuthSig and PKP using the GetLit CLI.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngetlit setup\n```\n\n----------------------------------------\n\nTITLE: Using Stytch Session with LitRelay\nDESCRIPTION: Shows how to configure LitRelay with a StytchOtpProvider using an authenticated Stytch session.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/email-sms.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\nimport { StytchOtpProvider } from \"@lit-protocol/providers\";\nimport { LitRelay } from \"@lit-protocol/lit-auth-client\";\n\nconst litRelay = new LitRelay({\n  relayUrl: LitRelay.getRelayUrl(LIT_NETWORK.DatilDev),\n  relayApiKey: 'test-api-key',\n});\n\nconst session = new StytchOtpProvider({ relay: litRelay, litNodeClient, options: {    \n    userId: sessionStatus.session.user_id,\n    appId: \"project-test-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\"} \n    });\n\n// from the above example of using the Stytch client to get an authenticated session\nconst authMethod = await session.authenticate({\n  accessToken: sessionStatus.session_jwt,\n});\n```\n\n----------------------------------------\n\nTITLE: React Component Import - Rollup Button\nDESCRIPTION: Imports a React component for adding the Chronicle rollup network to a user's wallet\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/intro/rollup.mdx#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport AddRollupButton from \"@site/src/components/AddRollupButton\";\n```\n\n----------------------------------------\n\nTITLE: Updating Enum Imports in JavaScript\nDESCRIPTION: Example of updating imports for enums that have been replaced with constants in @lit-protocol/constants.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Old import\nimport { LitNetwork } from '@lit-protocol/constants';\n\n// New import\nimport { LIT_NETWORK, LIT_NETWORK_TYPE, LIT_NETWORK_VALUE } from '@lit-protocol/constants';\n```\n\n----------------------------------------\n\nTITLE: Installing Lit JS SDK V2 using Yarn\nDESCRIPTION: This command installs the @lit-protocol/lit-node-client@serrano package using Yarn package manager for browser and Node environments.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/installation.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn install @lit-protocol/lit-node-client@serrano\n```\n\n----------------------------------------\n\nTITLE: Starting Localized Docusaurus Site\nDESCRIPTION: Starts the Docusaurus site in development mode with the French locale. This command allows viewing the site in French at http://localhost:3000/fr/.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/translate-your-site.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start -- --locale fr\n```\n\n----------------------------------------\n\nTITLE: Executing Async ForEach Operation in LitContracts\nDESCRIPTION: Executes an asynchronous callback function for each item in an array and returns the results.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/sdk/explanation/contracts.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst result = await LitContracts.asyncForEachReturn(array, asyncCallback);\n```\n\n----------------------------------------\n\nTITLE: Updating Protected RequestId Method Usage\nDESCRIPTION: Example showing the migration from public getRequestId to protected _getNewRequestId method.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/7.0.0.md#2025-04-18_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n// Old Method\nconst requestId = this.getRequestId();\n\n// New Method\nconst requestId = this._getNewRequestId();\n```\n\n----------------------------------------\n\nTITLE: Handling OAuth Redirect and Authentication\nDESCRIPTION: Implements the redirect handling logic for OAuth authentication flow, including verification of sign-in redirect and authentication token retrieval.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/advanced-topics/auth-methods/social-login.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { isSignInRedirect } from '@lit-protocol/lit-auth-client';\n\nasync function handleRedirect() {\n  // Check if app has been redirected from Lit login server\n  if (isSignInRedirect(redirectUri)) {\n    // Get auth method object that has the OAuth token from redirect callback\n    const authMethod: AuthMethod = await discordProvider.authenticate();\n    return authMethod;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Node Client Package\nDESCRIPTION: Command to install the @lit-protocol/lit-node-client package using Yarn. This package can be used in both browser and Node environments.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/4.0.0.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol with Yarn\nDESCRIPTION: Command to install required dependencies using Yarn for delegating capacity credits in Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/delegating-credit.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add \\\n@lit-protocol/constants \\\n@lit-protocol/lit-node-client \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Decoding Contract Call Response\nDESCRIPTION: Decodes the smart contract function call response data from the JWT payload.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst decoded = LitJsSdk.decodeCallResult({\n  abi: aggregatorV3InterfaceABI,\n  functionName: \"latestRoundData\",\n  data: payload.callResponses[0],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lit Protocol and Irys\nDESCRIPTION: NPM installation command for required dependencies including Lit Protocol client, Irys upload utilities, and Ethers.js.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/storage/irys.md#2025-04-18_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n  @lit-protocol/lit-node-client \\\n  @irys/web-upload \\\n  @irys/web-upload-ethereum \\\n  @irys/web-upload-ethereum-ethers-v6 \\\n  ethers\n```\n\n----------------------------------------\n\nTITLE: Searching for PKP-related data with GetLit CLI\nDESCRIPTION: Example of using the 'getlit search' command to retrieve PKP-related data by providing various parameters.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/getlit-cli.md#2025-04-18_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngetlit search --get --format --publicKey --authMethodId --userId --appId\n```\n\n----------------------------------------\n\nTITLE: Returning Lit Action Response\nDESCRIPTION: Simple code snippet that returns the result of the access control check to the frontend application. It uses the LitActions.setResponse function to format the response.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/solana/siws-access-control.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nreturn LitActions.setResponse({ response: result });\n```\n\n----------------------------------------\n\nTITLE: Executing Transaction Signing with Lit Nodes\nDESCRIPTION: Demonstrates the complete flow of connecting to Lit nodes, executing transaction signing, and processing the signatures.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/processing-validation.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst go = async () => {\n  const litNodeClient = new LitJsSdk.LitNodeClient({\n    alertWhenUnauthorized: false,\n    minNodeCount: 6,\n    debug: true,\n    litNetwork: \"datil-dev\",\n  });\n  await litNodeClient.connect();\n  const results = await litNodeClient.executeJs({\n    code: litActionCode,\n    sessionSigs,\n    jsParams: {},\n  });\n  const { signatures, response } = results;\n  console.log(\"response\", response);\n\n  const sig = signatures.sig1;\n  const { dataSigned } = sig;\n  const encodedSig = joinSignature({\n    r: \"0x\" + sig.r,\n    s: \"0x\" + sig.s,\n    v: sig.recid,\n  });\n\n  const { txParams } = response;\n\n  console.log(\"encodedSig\", encodedSig);\n  console.log(\"sig length in bytes: \", encodedSig.substring(2).length / 2);\n  console.log(\"dataSigned\", dataSigned);\n  const splitSig = splitSignature(encodedSig);\n  console.log(\"splitSig\", splitSig);\n\n  const recoveredPubkey = recoverPublicKey(dataSigned, encodedSig);\n  console.log(\"uncompressed recoveredPubkey\", recoveredPubkey);\n  const compressedRecoveredPubkey = computePublicKey(recoveredPubkey, true);\n  console.log(\"compressed recoveredPubkey\", compressedRecoveredPubkey);\n  const recoveredAddress = recoverAddress(dataSigned, encodedSig);\n  console.log(\"recoveredAddress\", recoveredAddress);\n\n  const txn = serialize(txParams, encodedSig);\n\n  console.log(\"txn\", txn);\n};\n\ngo();\n```\n\n----------------------------------------\n\nTITLE: Installing LitAuthClient Package\nDESCRIPTION: Command to install the lit-auth-client package using yarn package manager\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-auth-client\n```\n\n----------------------------------------\n\nTITLE: Installing ContractsSDK Dependencies\nDESCRIPTION: Commands to install required packages for using ContractsSDK\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-multiple-auth-methods.md#2025-04-18_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-auth-client \nyarn add @lit-protocol/contracts-sdk\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Node Client with NPM\nDESCRIPTION: Command to install the Lit Protocol node client package via NPM. This is required to interact with the Datil mainnet, with minimum SDK version 6.4.0.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/mainnets.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Adding Stytch Configuration for Social Onboarding\nDESCRIPTION: This code snippet demonstrates how to add Stytch project credentials to the .env.local file for enabling social onboarding features in the application.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/openfort.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nNEXT_PUBLIC_STYTCH_PROJECT_ID=\"<Your Stytch Project ID>\"\nNEXT_PUBLIC_STYTCH_PUBLIC_TOKEN=\"<Your Stytch Public Token>\"\n```\n\n----------------------------------------\n\nTITLE: Handling Module Build Error in Next.js\nDESCRIPTION: This code snippet shows an error message that may occur when using Next.js ^12 with Lit Protocol. It relates to unhandled node:buffer scheme.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nModule build failed: UnhandledSchemeError: Reading from \"node:buffer\" is not handled by plugins (Unhandled scheme).\n```\n\n----------------------------------------\n\nTITLE: Creating React Component Page\nDESCRIPTION: Example of creating a basic React component page using Layout from theme. Creates a simple page with a heading and paragraph that will be available at /my-react-page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-page.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport Layout from '@theme/Layout';\n\nexport default function MyReactPage() {\n  return (\n    <Layout>\n      <h1>My React page</h1>\n      <p>This is a React page</p>\n    </Layout>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Node Client with Yarn\nDESCRIPTION: Command to install the Lit Node Client SDK using Yarn package manager. Requires minimum version 6.4.0 for Datil network compatibility.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/testnets.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client\n```\n\n----------------------------------------\n\nTITLE: Configuring Document Metadata in Markdown\nDESCRIPTION: Demonstrates how to add metadata to a Docusaurus document to customize sidebar label and position using frontmatter configuration.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-document.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n---\nsidebar_label: 'Hi!'\nsidebar_position: 3\n---\n\n# Hello\n\nThis is my **first Docusaurus document**!\n```\n\n----------------------------------------\n\nTITLE: Generating PKP Session Signatures for Lit Protocol\nDESCRIPTION: This snippet demonstrates how to generate PKP session signatures using the Lit Protocol SDK. It uses an Ethereum wallet provider for authentication and sets up resource ability requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/storing-wrapped-key-metadata.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EthWalletProvider } from \"@lit-protocol/lit-auth-client\";\nimport { LIT_ABILITY } from \"@lit-protocol/constants\";\nimport {\n  LitActionResource,\n  LitPKPResource,\n} from \"@lit-protocol/auth-helpers\";\n\nconst pkpSessionSigs = await litNodeClient.getPkpSessionSigs({\n    pkpPublicKey: process.env.LIT_PKP_PUBLIC_KEY,\n    authMethods: [\n        await EthWalletProvider.authenticate({\n            signer: ethersSigner,\n            litNodeClient,\n            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n        }),\n    ],\n    resourceAbilityRequests: [\n    {\n        resource: new LitActionResource(\"*\"),\n        ability: LIT_ABILITY.LitActionExecution,\n    },\n    ],\n    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Checking POAP Access by Event ID\nDESCRIPTION: Implementation for verifying if a user possesses a POAP with a specific event ID. It checks both xDai and Ethereum chains using an OR operator. The example checks for POAP ID '37582' using an exact match comparator.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/EVM/poap.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar accessControlConditions = [\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"xdai\",\n    method: \"eventId\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"37582\",\n    },\n  },\n  {\n    operator: \"or\",\n  },\n  {\n    contractAddress: \"0x22C1f6050E56d2876009903609a2cC3fEf83B415\",\n    standardContractType: \"POAP\",\n    chain: \"ethereum\",\n    method: \"eventId\",\n    parameters: [],\n    returnValueTest: {\n      comparator: \"=\",\n      value: \"37582\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Setting Request Headers for Lit Relayer API\nDESCRIPTION: Defines the headers required for making requests to the Lit Relayer API, including the API key and payer secret key.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst headers = {\n    \"api-key\": YOUR_LIT_RELAYER_API_KEY,\n    \"payer-secret-key\": YOUR_LIT_PAYER_SECRET_KEY,\n    \"Content-Type\": \"application/json\",\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Request Headers for Lit Relayer API\nDESCRIPTION: Defines the headers for making API requests to the Lit Relayer server, including the API key and content type.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst headers = {\n    \"api-key\": YOUR_LIT_RELAYER_API_KEY,\n    \"Content-Type\": \"application/json\",\n};\n```\n\n----------------------------------------\n\nTITLE: Checking for API Response Errors\nDESCRIPTION: Checks if the API response indicates an error and throws an exception if one is found.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nif (!response.ok) {\n    throw new Error(`Error: ${await response.text()}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking KYVE Funders List Membership\nDESCRIPTION: Verifies if a user is on the KYVE funders list by checking their address against the registry. Uses JSONPath to extract and compare funder addresses.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/cosmosConditions.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \"/kyve/registry/v1beta1/funders_list/0\",\n    chain: \"kyve\",\n    returnValueTest: {\n      key: \"$.funders.*.account\",\n      comparator: \"contains\",\n      value: \":userAddress\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Share Modal with Yarn\nDESCRIPTION: Command to install the lit-share-modal-v3 package using Yarn package manager.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/Tools/shareModal.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nyarn add lit-share-modal-v3\n```\n\n----------------------------------------\n\nTITLE: Rendering Feedback Component in Markdown\nDESCRIPTION: This code snippet renders the imported FeedbackComponent at the end of the documentation page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/claimable-keys/intro.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Juno Wallet Address\nDESCRIPTION: Validates that the user owns a specific Juno network wallet address. Compares the :userAddress parameter against a hardcoded Juno wallet address value.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/cosmosConditions.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar unifiedAccessControlConditions = [\n  {\n    conditionType: \"cosmos\",\n    path: \":userAddress\",\n    chain: \"juno\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \"=\",\n      value: \"juno1vn6zl0924yj86jrp330wcwjclzdharljkajxqt\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Including FeedbackComponent in Markdown\nDESCRIPTION: This code snippet includes the previously imported FeedbackComponent at the end of the document. It's used to add a feedback section to the page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/use-cases.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Checking Metaplex Collection NFT Ownership in Solana\nDESCRIPTION: Validates if a user owns one or more NFTs in a specific Metaplex collection. Uses a custom RPC call 'balanceOfMetaplexCollection' specific to Lit Protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar solRpcConditions = [\n  {\n    method: \"balanceOfMetaplexCollection\",\n    params: [\"FfyafED6kiJUFwEhogyTRQHiL6NguqNg9xcdeoyyJs33\"],\n    pdaParams: [],\n    pdaInterface: { offset: 0, fields: {} },\n    pdaKey: \"\",\n    chain,\n    returnValueTest: {\n      key: \"\",\n      comparator: \">\",\n      value: \"0\",\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Interactive React Component with MDX\nDESCRIPTION: Demonstrates an interactive React component using MDX, featuring a clickable highlighted text element with custom styling and event handling.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/markdown-features.mdx#2025-04-18_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Highlight = ({children, color}) => (\n  <span\n    style={{\n      backgroundColor: color,\n      borderRadius: '20px',\n      color: '#fff',\n      padding: '10px',\n      cursor: 'pointer',\n    }}\n    onClick={() => {\n      alert(`You clicked the color ${color} with label ${children}`)\n    }}>\n    {children}\n  </span>\n);\n\nThis is <Highlight color=\"#25c2a0\">Docusaurus green</Highlight> !\n\nThis is <Highlight color=\"#1877F2\">Facebook blue</Highlight> !\n```\n\n----------------------------------------\n\nTITLE: Configuring URL Redirects in Netlify\nDESCRIPTION: TOML configuration for Netlify to set up redirects when page paths change. This example redirects from an old URL to a new URL with a 301 status code.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[[redirects]]\n  from = \"/docs/tea-drinks/intro\"\n  to = \"/docs/tea-drinks/tea-drinks-intro\"\n  status = 301\n  force = false\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Lit Protocol Documentation\nDESCRIPTION: This snippet imports custom React components used to structure the documentation page for Lit Protocol. These components likely contain organized information about different aspects of the protocol.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/intro/overview.mdx#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport EcosystemSection from '@site/src/components/CardSectionsV2/Ecosystem';\nimport QuickStartSection from '@site/src/components/CardSectionsV2/QuickStart';\nimport CoreConceptsSection from '@site/src/components/CardSectionsV2/CoreConcepts';\nimport LearnCodeSection from '@site/src/components/CardSectionsV2/LearnCode';\n```\n\n----------------------------------------\n\nTITLE: Using PDA for Solana RPC Calls\nDESCRIPTION: Demonstrates deriving a Program Derived Address (PDA) and using it as a parameter in a getBalance RPC call.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/accessControl/otherChains/solRpcConditions.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  {\n    method: \"getBalance(getPDA)\",\n    params: [],\n    pdaParams: [\n      \"chatGL6yNgZT2Z3BeMYGcgdMpcBKdmxko4C5UhEX4To\",\n      \"delegate-wallet\",\n      \":userAddress\"\n    ],\n    pdaInterface: { offset: 8, fields: { owner_wallet: 32 } },\n    pdaKey: \"owner_wallet\",\n    chain: \"solana\",\n    returnValueTest: {\n      key: \"\",\n      comparator: \">=\",\n      value: \"100000000\", // equals 0.1 SOL\n    },\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Server for Manual Tests in Python\nDESCRIPTION: This command starts a simple HTTP server using Python's built-in SimpleHTTPServer module. It's used to serve the manual test files in the browser for the Lit Protocol project.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/tests.md#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npython2 -m SimpleHTTPServer\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video in Markdown\nDESCRIPTION: This code snippet demonstrates how to embed a YouTube video within a Markdown document using an iframe. The video explains how Lit transforms public key cryptography.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/learningLab/intro-to-lit/intro.mdx#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n <iframe width=\"640\" \n         height=\"480\" \n         src=\"https://www.youtube.com/embed/qFfPd5_65Mo\" \n         title=\"YouTube video player\" \n         frameborder=\"0\" \n         allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" \n         allowfullscreen>\n </iframe>\n```\n\n----------------------------------------\n\nTITLE: Sending OTP via Email, SMS, or WhatsApp using Stytch\nDESCRIPTION: Demonstrates how to send a one-time password to a user's email, SMS, or WhatsApp using the Stytch client.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/integrations/aa/pimlico.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst stytchResponse = await stytchClient.otps.email.loginOrCreate({\n    email: \"<Your Email Address>\",\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst stytchResponse = await stytchClient.otps.sms.loginOrCreate({\n    phone_number: \"<Your Phone Number>\",\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst stytchResponse = await stytchClient.otps.whatsapp.loginOrCreate({\n    phone_number: \"<Your Phone Number>\",\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Next.js to Resolve Node Modules\nDESCRIPTION: This JavaScript code configures webpack in Next.js to handle node: prefixed modules. It uses NormalModuleReplacementPlugin to replace node: prefixes in module requests.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/3.0.0/overview.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  // Your Next.js config\n  // ...\n  webpack: (config, options) => {\n    config.plugins.push(\n      new webpack.NormalModuleReplacementPlugin(/^node:/, (resource) => {\n        resource.request = resource.request.replace(/^node:/, \"\");\n      })\n    );\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Docusaurus Tab Components in JSX\nDESCRIPTION: Imports Tab components from Docusaurus theme to create tabbed content sections in the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/connecting-to-a-lit-network/migrating-to-datil.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n```\n\n----------------------------------------\n\nTITLE: React Component Example in JSX\nDESCRIPTION: Shows a basic React functional component example with JSX syntax highlighting.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/markdown-features.mdx#2025-04-18_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nfunction HelloDocusaurus() {\n  return <h1>Hello, Docusaurus!</h1>;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in React/MDX\nDESCRIPTION: Imports a feedback component from a markdown file to be used in the documentation page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/support/bug-bounty.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Initializing LitNodeClient Connection\nDESCRIPTION: Sets up and connects a LitNodeClient instance to the Datil test network.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/authentication/session-sigs/get-session-sigs.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { LIT_NETWORK } from \"@lit-protocol/constants\";\n\nlet litNodeClient: LitNodeClient;\n\nlitNodeClient = new LitNodeClient({\n      litNetwork: LIT_NETWORK.DatilTest,\n      debug: false,\n    });\nawait litNodeClient.connect();\n```\n\n----------------------------------------\n\nTITLE: Making POST Request to Add Users Endpoint (Datil)\nDESCRIPTION: Sends a POST request to the Datil network's add-users endpoint to add payees to a payer wallet.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/paying-for-lit/payment-delegation-db.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await fetch(\n    \"https://datil-relayer.getlit.dev/add-users\", \n    {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(USERS_YOU_WANT_TO_ADD),\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Network Feature Matrix in JSX\nDESCRIPTION: This code snippet imports a Network component from an external Markdown file and renders it. The component likely contains a feature matrix for network-related functionality.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/resources/networkMatrix.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Network from '/docs/network/feature-matrix.md'; \n\n<Network />\n```\n\n----------------------------------------\n\nTITLE: Migrating Lit Supported Curves Enum in TypeScript\nDESCRIPTION: Shows the migration from SIGTYPE to LIT_CURVE enum in the constants package.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/migrations/6.0.0.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// v5\nimport { SIGTYPE } from '@lit-protocol/constants';\n\nexport enum SIGTYPE {\n  BLS = 'BLS',\n  EcdsaK256 = 'K256',\n  EcdsaCaitSith = 'ECDSA_CAIT_SITH',\n  EcdsaCAITSITHP256 = 'EcdsaCaitSithP256',\n}\n\n// v6\nimport { LIT_CURVE } from '@lit-protocol/constants';\n\nexport enum LIT_CURVE {\n  BLS = 'BLS',\n  EcdsaK256 = 'K256',\n  EcdsaCaitSith = 'ECDSA_CAIT_SITH',\n  EcdsaCAITSITHP256 = 'EcdsaCaitSithP256',\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in React/JSX\nDESCRIPTION: Imports a feedback component from a markdown file in the site's pages directory.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/via-web-authn.md#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing FeedbackComponent in Markdown\nDESCRIPTION: This code snippet imports a FeedbackComponent from a specific file path. It's likely used to include a feedback section at the end of the document.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/networks/testnet.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Creating a New Documentation Version in Docusaurus\nDESCRIPTION: This command creates a new version of the documentation. It copies the 'docs' folder into 'versioned_docs/version-1.0' and creates a 'versions.json' file.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-extras/manage-docs-versions.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run docusaurus docs:version 1.0\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Command to start a local development server that opens a browser window and provides live updates without requiring server restarts.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Including FeedbackComponent in Markdown\nDESCRIPTION: This code snippet includes the previously imported FeedbackComponent at the end of the documentation page, likely to allow users to provide feedback on the content.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/event-listener.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Removing Auth Method from PKP\nDESCRIPTION: Demonstrates how to remove an authentication method from a PKP using the PKPPermissions contract.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/pkp/authHelpers/addRemoveAuthMethods.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst transaction =\n  await litContracts.pkpPermissionsContract.write.removePermittedAuthMethod(\n    \"<The token ID of your PKP>\",\n    \"<The auth method type\",\n    \"<The auth method ID>\",\n    { gasPrice: utils.parseUnits(\"0.001\", \"gwei\"), gasLimit: 400000 }\n  );\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in React\nDESCRIPTION: Imports a feedback component from a markdown file in the site's pages directory for use in the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/api-reference/latest.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Importing Lit SDK in server-side Node.js applications\nDESCRIPTION: Code for importing the Lit SDK in Node.js environments for connecting to Habanero or Manzano networks.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/network/migration-guide.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as LitJsSdk from \"@lit-protocol/lit-node-client-nodejs\";\n```\n\n----------------------------------------\n\nTITLE: Verifying JWT Signature\nDESCRIPTION: Verifies the JWT signature and extracts its components using the Lit SDK.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/signedChainData.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { verified, header, payload, signature } = LitJsSdk.verifyJwt({\n  jwt,\n});\n```\n\n----------------------------------------\n\nTITLE: NPM Dependencies Installation\nDESCRIPTION: Command to install required npm packages for the implementation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/wrapped-keys/exporting-wrapped-key.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/constants \\\n@lit-protocol/lit-auth-client \\\n@lit-protocol/lit-node-client \\\n@lit-protocol/wrapped-keys \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Lit Action Execution Using Code Parameter\nDESCRIPTION: Example showing how to execute a Lit Action by passing raw JavaScript code directly\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/LitActions/helloWorld.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst litActionCode = `\nconst go = async () => {\n  // this requests a signature share from the Lit Node\n  // the signature share will be automatically returned in the HTTP response from the node\n  // all the params (toSign, publicKey, sigName) are passed in from the LitJsSdk.executeJs() function\n  const sigShare = await LitActions.signEcdsa({ toSign, publicKey, sigName });\n};\n\ngo();\n`;\n\nconst signatures = await litNodeClient.executeJs({\n  code: litActionCode,\n  authSig,\n  // all jsParams can be used anywhere in your litActionCode\n  jsParams: {\n    // this is the string \"Hello World\" for testing\n    toSign: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],\n    publicKey:\n      \"0x0404e12210c57f81617918a5b783e51b6133790eb28a79f141df22519fb97977d2a681cc047f9f1a9b533df480eb2d816fb36606bd7c716e71a179efd53d2a55d1\",\n    sigName: \"sig1\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Inline Code Block in Markdown\nDESCRIPTION: This code block shows the use of inline code formatting in Markdown to highlight the term 'testLPX'.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/overview.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n`testLPX`\n```\n\n----------------------------------------\n\nTITLE: Delegating NFT Usage\nDESCRIPTION: Creating a capacity delegation authorization signature for delegating NFT usage to specific addresses.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/access-control/quick-start.md#2025-04-18_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nconst { capacityDelegationAuthSig } =\n  await litNodeClient.createCapacityDelegationAuthSig({\n    uses: '1',\n    signer: wallet,\n    capacityTokenId: capacityTokenIdStr,\n    delegateeAddresses: [walletAddress],\n  });\n```\n\n----------------------------------------\n\nTITLE: Installing Lit Protocol Dependencies\nDESCRIPTION: Commands for installing required npm packages including lit-node-client, constants, auth-helpers, contracts-sdk and ethers v5.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/intro/first-request/making-first-signing.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/contracts-sdk \\\nethers@v5\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @lit-protocol/lit-node-client \\\n@lit-protocol/constants \\\n@lit-protocol/auth-helpers \\\n@lit-protocol/contracts-sdk \\\nethers@v5\n```\n\n----------------------------------------\n\nTITLE: Creating a Collapsible Sidebar Category in JavaScript\nDESCRIPTION: JavaScript configuration for adding a top-level, collapsible category to the documentation sidebar, with the collapsed property set to true by default.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\ndocs: [\n  // ...\n  {\n    type: 'category',\n    label: 'Coffee Drinks',\n    collapsed: true,\n    items: [\n      // Add the IDs of your new category's pages here\n      'coffee-drinks/intro',\n    ],\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video in Markdown\nDESCRIPTION: This code snippet embeds a YouTube video about the Event Listener with Lit Protocol. It sets the video dimensions, source, and various attributes for the iframe.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/event-listener.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n <iframe width=\"640\" \n         height=\"480\" \n         src=\"https://www.youtube.com/embed/gcT8Bp5oepo\" \n         title=\"Event Listener with Lit Protocol - Automate Web3 Signing\" \n         frameborder=\"0\" \n         allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" \n         allowfullscreen>\n </iframe>\n```\n\n----------------------------------------\n\nTITLE: Adding Auth Method when Minting a Claim using Lit SDK in JavaScript\nDESCRIPTION: This snippet demonstrates how to add an authentication method when minting a claim. It uses the Lit SDK to execute a Lit Action, calculates an auth method ID, and then uses LitContracts to mint the claim and add the auth method on-chain.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/key-claiming.md#2025-04-18_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { getAuthIdByAuthMethod } from '@lit-protocol/lit-auth-client';\n\n  const authMethod = {\n    authMethodType: AUTH_METHOD_TYPE.EthWallet,\n    accessToken: JSON.stringify(authSig),\n  };\n\n  const authMethodId = getAuthIdByAuthMethod(authMethod);\n\n  const keyId = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(\"theIPFSIdOfYourLitAction_yourUserId\"))\n\n  const res = await client.executeJs({\n    sessionSigs,\n    code: `(async () => {\n      Lit.Actions.claimKey({keyId: userId});\n    })();`,\n    jsParams: {\n        userId: 'foo'\n    },\n  });\n\n  let client = new LitContracts(signer: \"<your pkp wallet or other signer>\");\n  let tx = await client.pkpHelperContract.write.claimAndMintNextAndAddAuthMethods(\n    res.claims['foo'],\n   {\n    keyType: 2,\n    permittedIpfsCIDs: [],\n    permittedIpfsCIDScopes: [],\n    permittedAddresses: [],\n    permittedAddressScopes: [],\n    permittedAuthMethodTypes: [AUTH_METHOD_TYPE.EthWallet],\n    permittedAuthMethodIds: [`0x${authMethodId}`],\n    permittedAuthMethodPubkeys: [`0x`],\n    permittedAuthMethodScopes: [[BigNumber.from(\"1\")]],\n    addPkpEthAddressAsPermittedAddress: true,\n    sendPkpToItself: true\n   });\n```\n\n----------------------------------------\n\nTITLE: Markdown Link Examples\nDESCRIPTION: Shows two different approaches to creating links in Markdown - using URL paths and relative file paths.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/markdown-features.mdx#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nLet's see how to [Create a page](/create-a-page).\n```\n\nLANGUAGE: markdown\nCODE:\n```\nLet's see how to [Create a page](./create-a-page.md).\n```\n\n----------------------------------------\n\nTITLE: Creating Markdown Documentation Page\nDESCRIPTION: Example of creating a simple Markdown page with a heading and text content that will be available at /my-markdown-page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/create-a-page.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n# My Markdown page\n\nThis is a Markdown page\n```\n\n----------------------------------------\n\nTITLE: Defining Resource ID for Lit Protocol\nDESCRIPTION: Specify the Resource ID for the content being protected, typically including a base URL and path.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/versioned_docs/version-2.0/ToolsAndExamples/SDKExamples/dynamicContent.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst resourceId = {\n  baseUrl: \"my-dynamic-content-server.com\",\n  path: \"/a_path.html\",\n  orgId: \"\",\n  role: \"\",\n  extraData: \"\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using Truncate Comment in Docusaurus Blog\nDESCRIPTION: Demonstrates the usage of the truncate HTML comment tag to limit blog post preview length in Docusaurus list views\nSOURCE: https://github.com/lit-protocol/docs/blob/main/blog/2019-05-29-long-blog-post.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<!--truncate-->\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Custom React Components in JSX\nDESCRIPTION: This snippet imports custom React components from specific paths and renders them within the page. These components likely contain structured content for different sections of the Learning Lab introduction.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/learningLab/intro.mdx#2025-04-18_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport IntroSection from '@site/src/components/LLCardSections/Intro';\nimport CodebreakerSection from '@site/src/components/LLCardSections/Codebreaker';\nimport EcosystemSection from '@site/src/components/CardSectionsV3/Ecosystem';\n\n<IntroSection title=\"Intro\"></IntroSection>\n\n<CodebreakerSection title=\"Codebreaker Challenges\"></CodebreakerSection>\n\n<EcosystemSection title=\"Join the Lit Ecosystem\"></EcosystemSection>\n```\n\n----------------------------------------\n\nTITLE: Importing FeedbackComponent in Markdown\nDESCRIPTION: This code snippet imports a FeedbackComponent from a local file path. It's likely used to include a feedback section at the end of the documentation page.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/tools/event-listener.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```\n\n----------------------------------------\n\nTITLE: Front Matter Example in Markdown\nDESCRIPTION: Demonstrates the structure of front matter metadata at the top of a Markdown document, including document ID, title, description, and custom URL slug.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/markdown-features.mdx#2025-04-18_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n---\nid: my-doc-id\ntitle: My document title\ndescription: My document description\nslug: /my-custom-url\n---\n\n## Markdown heading\n\nMarkdown text with [links](./hello.md)\n```\n\n----------------------------------------\n\nTITLE: Including Feedback Component in Markdown\nDESCRIPTION: This code snippet includes the imported FeedbackComponent at the end of the document. It's used to render a feedback section for users.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/sdk/serverless-signing/dependencies.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<FeedbackComponent/>\n```\n\n----------------------------------------\n\nTITLE: Markdown Image Example\nDESCRIPTION: Demonstrates how to embed an image in Markdown using the standard image syntax.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/not-docs/tutorial-basics/markdown-features.mdx#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n![Docusaurus logo](/img/docusaurus.png)\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Documentation Page in JavaScript\nDESCRIPTION: This code imports necessary components for the documentation page, including a feedback component and tab components from the site's theme.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/resources/contracts.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n```\n\n----------------------------------------\n\nTITLE: Importing Feedback Component in MDX\nDESCRIPTION: Imports a feedback component from a markdown file to be used in the documentation.\nSOURCE: https://github.com/lit-protocol/docs/blob/main/docs/user-wallets/pkps/minting/overview.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FeedbackComponent from \"@site/src/pages/feedback.md\";\n```"
  }
]