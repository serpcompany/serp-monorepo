[
  {
    "owner": "get-convex",
    "repo": "convex-helpers",
    "content": "TITLE: Creating Custom Query Functions with Authentication and Context Customization\nDESCRIPTION: This snippet demonstrates how to build customized query functions with custom behavior, such as running authentication logic and enhancing the context with user data. It allows wrapping the standard Convex query functions with additional functionality.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { customQuery } from \"convex-helpers/server/customFunctions.js\";\n\nconst myQueryBuilder = customQuery(query, {\n  args: { apiToken: v.id(\"api_tokens\") },\n  input: async (ctx, args) => {\n    const apiUser = await getApiUser(args.apiToken);\n    const db = wrapDatabaseReader({ apiUser }, ctx.db, rlsRules);\n    return { ctx: { db, apiUser }, args: {} };\n  },\n});\n\n// Use the custom builder everywhere you would have used `query`\nexport const getSomeData = myQueryBuilder({\n  args: { someArg: v.string() },\n  handler: async (ctx, args) => {\n    const { db, apiUser, scheduler } = ctx;\n    const { someArg } = args;\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Convex Mutation in React Component\nDESCRIPTION: Demonstrates how to use a Convex mutation function in a React component using the useMutation hook, including both fire-and-forget and promise-based approaches.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/convex/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst mutation = useMutation(api.functions.myMutationFunction);\nfunction handleButtonPress() {\n  // fire and forget, the most common way to use mutations\n  mutation({ first: \"Hello!\", second: \"me\" });\n  // OR\n  // use the result once the mutation has completed\n  mutation({ first: \"Hello!\", second: \"me\" }).then((result) =>\n    console.log(result),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Convex Query in React Component\nDESCRIPTION: Shows how to use a Convex query function within a React component using the useQuery hook.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/convex/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = useQuery(api.functions.myQueryFunction, {\n  first: 10,\n  second: \"hello\",\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Enhanced useQuery Hook with Status Information\nDESCRIPTION: This snippet demonstrates how to create an enhanced version of useQuery that provides more detailed status information, including loading state and error handling.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeUseQueryWithStatus } from \"convex-helpers/react\";\nimport { useQueries } from \"convex/react\";\n// Do this once somewhere, name it whatever you want.\nexport const useQueryWithStatus = makeUseQueryWithStatus(useQueries);\n\nconst { status, data, error, isSuccess, isPending, isError } =\n  useQueryWithStatus(api.foo.bar, { myArg: 123 });\n```\n\n----------------------------------------\n\nTITLE: Using Cached Queries in React Components\nDESCRIPTION: This snippet demonstrates how to use the cached version of useQuery from convex-helpers in a React component. The API is identical to the standard convex/react useQuery hook but provides caching benefits.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useQuery } from \"convex-helpers/react/cache\";\n// For Next.js, import from \"convex-helpers/react/cache/hooks\"; instead\n\n// ...\n\nconst users = useQuery(api.todos.getAll);\n```\n\n----------------------------------------\n\nTITLE: Setting Up ConvexQueryCacheProvider in React\nDESCRIPTION: This snippet shows how to set up the ConvexQueryCacheProvider in a React application to enable persistent query caching. The provider needs to be placed inside the ConvexProvider in the component tree.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ConvexQueryCacheProvider } from \"convex-helpers/react/cache\";\n// For Next.js, import from \"convex-helpers/react/cache/provider\"; instead\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <ConvexClientProvider>\n          <ConvexQueryCacheProvider>{children}</ConvexQueryCacheProvider>\n        </ConvexClientProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Convex Query Function in TypeScript\nDESCRIPTION: Demonstrates how to create a query function that accepts numeric and string arguments. The function includes argument validation and shows how to query the database.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/convex/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { query } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport const myQueryFunction = query({\n  // Validators for arguments.\n  args: {\n    first: v.number(),\n    second: v.string(),\n  },\n\n  // Function implementation.\n  handler: async (ctx, args) => {\n    // Read the database as many times as you need here.\n    // See https://docs.convex.dev/database/reading-data.\n    const documents = await ctx.db.query(\"tablename\").collect();\n\n    // Arguments passed from the client are properties of the args object.\n    console.log(args.first, args.second);\n\n    // Write arbitrary JavaScript here: filter, aggregate, build derived data,\n    // remove non-public properties, or create new objects.\n    return documents;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Convex Mutation Function in TypeScript\nDESCRIPTION: Shows how to create a mutation function that accepts string arguments and performs database operations. Includes argument validation and database insertion.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/convex/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport const myMutationFunction = mutation({\n  // Validators for arguments.\n  args: {\n    first: v.string(),\n    second: v.string(),\n  },\n\n  // Function implementation.\n  handler: async (ctx, args) => {\n    // Insert or modify documents in the database here.\n    // Mutations can also read from the database like queries.\n    // See https://docs.convex.dev/database/writing-data.\n    const message = { body: args.first, author: args.second };\n    const id = await ctx.db.insert(\"messages\", message);\n\n    // Optionally, return a value from your mutation.\n    return await ctx.db.get(id);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Trigger Functions in Convex\nDESCRIPTION: This snippet demonstrates how to use triggers to enhance Convex mutations with automatic behaviors like computed fields, denormalized counts, post-mutation actions, and cascading deletes. Triggers run atomically with data changes and can be used to enforce data consistency.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mutation as rawMutation } from \"./_generated/server\";\nimport { DataModel } from \"./_generated/dataModel\";\nimport { Triggers } from \"convex-helpers/server/triggers\";\nimport {\n  customCtx,\n  customMutation,\n} from \"convex-helpers/server/customFunctions\";\n\nconst triggers = new Triggers<DataModel>();\n\n// 1. Attach a computed `fullName` field to every user.\ntriggers.register(\"users\", async (ctx, change) => {\n  if (change.newDoc) {\n    const fullName = `${change.newDoc.firstName} ${change.newDoc.lastName}`;\n    // Abort the mutation if document is invalid.\n    if (fullName === \"The Balrog\") {\n      throw new Error(\"you shall not pass\");\n    }\n    // Update denormalized field. Check first to avoid recursion\n    if (change.newDoc.fullName !== fullName) {\n      await ctx.db.patch(change.id, { fullName });\n    }\n  }\n});\n\n// 2. Keep a denormalized count of all users.\ntriggers.register(\"users\", async (ctx, change) => {\n  // Note writing the count to a single document increases write contention.\n  // There are more scalable methods if you need high write throughput.\n  const countDoc = (await ctx.db.query(\"userCount\").unique())!;\n  if (change.operation === \"insert\") {\n    await ctx.db.patch(countDoc._id, { count: countDoc.count + 1 });\n  } else if (change.operation === \"delete\") {\n    await ctx.db.patch(countDoc._id, { count: countDoc.count - 1 });\n  }\n});\n\n// 3. After the mutation, send the new user info to Clerk.\n// Even if a user is modified multiple times in a single mutation,\n// `internal.users.updateClerkUser` runs once.\nconst scheduled: Record<Id<\"users\">, Id<\"_scheduled_functions\">> = {};\ntriggers.register(\"users\", async (ctx, change) => {\n  if (scheduled[change.id]) {\n    await ctx.scheduler.cancel(scheduled[change.id]);\n  }\n  scheduled[change.id] = await ctx.scheduler.runAfter(\n    0,\n    internal.users.updateClerkUser,\n    { user: change.newDoc },\n  );\n});\n\n// 4. When a user is deleted, delete their messages (cascading deletes).\ntriggers.register(\"users\", async (ctx, change) => {\n  // Using relationships.ts helpers for succinctness.\n  await asyncMap(\n    await getManyFrom(ctx.db, \"messages\", \"owner\", change.id),\n    (message) => ctx.db.delete(message._id),\n  );\n});\n\n// Use `mutation` to define all mutations, and the triggers will get called.\nexport const mutation = customMutation(rawMutation, customCtx(triggers.wrapDB));\n```\n\n----------------------------------------\n\nTITLE: Traversing Database Relationships with Helper Functions\nDESCRIPTION: This snippet shows how to use relationship helpers to navigate between related database tables without repetitive query boilerplate. It demonstrates one-to-many and many-to-many relationship traversal using helper functions.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  getOneFromOrThrow,\n  getManyFrom,\n  getManyViaOrThrow,\n} from \"convex-helpers/server/relationships.js\";\nimport { asyncMap } from \"convex-helpers\";\n\nconst author = await getOneFromOrThrow(db, \"authors\", \"userId\", user._id);\nconst posts = await asyncMap(\n  // one-to-many\n  await getManyFrom(db, \"posts\", \"authorId\", author._id),\n  async (post) => {\n    // one-to-many\n    const comments = await getManyFrom(db, \"comments\", \"postId\", post._id);\n    // many-to-many via join table\n    const categories = await getManyViaOrThrow(\n      db,\n      \"postCategories\",\n      \"categoryId\",\n      \"postId\",\n      post._id,\n    );\n    return { ...post, comments, categories };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: CRUD Operations Implementation\nDESCRIPTION: Example of implementing basic CRUD operations (Create, Read, Update, Delete) for Convex tables using helper utilities.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// in convex/users.ts\nimport { crud } from \"convex-helpers/server/crud\";\nimport schema from \"./schema.js\";\n\nexport const { create, read, update, destroy } = crud(schema, \"users\");\n\n// in some file, in an action:\nconst user = await ctx.runQuery(internal.users.read, { id: userId });\n\nawait ctx.runMutation(internal.users.update, {\n  id: userId,\n  patch: {\n    status: \"inactive\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Row-Level Security in Convex\nDESCRIPTION: Demonstrates how to implement row-level security checks for database operations using custom wrappers. Includes rules for read, insert, and modify operations with authentication checks.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  customCtx,\n  customMutation,\n  customQuery,\n} from \"convex-helpers/server/customFunctions\";\nimport {\n  Rules,\n  wrapDatabaseReader,\n  wrapDatabaseWriter,\n} from \"convex-helpers/server/rowLevelSecurity\";\nimport { DataModel } from \"./_generated/dataModel\";\nimport { mutation, query, QueryCtx } from \"./_generated/server\";\n\nasync function rlsRules(ctx: QueryCtx) {\n  const identity = await ctx.auth.getUserIdentity();\n  return {\n    users: {\n      read: async (_, user) => {\n        // Unauthenticated users can only read users over 18\n        if (!identity && user.age < 18) return false;\n        return true;\n      },\n      insert: async (_, user) => {\n        return true;\n      },\n      modify: async (_, user) => {\n        if (!identity)\n          throw new Error(\"Must be authenticated to modify a user\");\n        // Users can only modify their own user\n        return user.tokenIdentifier === identity.tokenIdentifier;\n      },\n    },\n  } satisfies Rules<QueryCtx, DataModel>;\n}\n\nconst queryWithRLS = customQuery(\n  query,\n  customCtx(async (ctx) => ({\n    db: wrapDatabaseReader(ctx, ctx.db, await rlsRules(ctx)),\n  })),\n);\n\nconst mutationWithRLS = customMutation(\n  mutation,\n  customCtx(async (ctx) => ({\n    db: wrapDatabaseWriter(ctx, ctx.db, await rlsRules(ctx)),\n  })),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Retries for Idempotent Operations\nDESCRIPTION: This helper allows you to retry Convex actions until they succeed, which is useful for operations that are idempotent or don't have unsafe side effects. The snippet shows how to set up and use action retries.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n // in convex/utils.ts\n import { makeActionRetrier } from \"convex-helpers/server/retries\";\n\n export const { runWithRetries, retry } = makeActionRetrier(\"utils:retry\");\n\n // in a mutation or action\n export const myMutation = mutation({\n   args: {...},\n   handler: async (ctx, args) => {\n     //...\n     await runWithRetries(ctx, internal.myModule.myAction, { arg1: 123 });\n   }\n });\n```\n\n----------------------------------------\n\nTITLE: Creating Stateful Data Migrations\nDESCRIPTION: This snippet demonstrates how to define and run migrations with state persistence. It provides a pattern for updating documents in your database in a controlled and trackable way.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const myMigration = migration({\n  table: \"users\",\n  migrateOne: async (ctx, doc) => {\n    await ctx.db.patch(doc._id, { newField: \"value\" });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Server Query Functions with Session Support\nDESCRIPTION: This snippet demonstrates how to define a server query function that accepts a session ID and uses it to look up the anonymous user. It uses customQuery to extend the standard query function.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport const mySessionQuery = queryWithSession({\n  args: { arg1: v.number() },\n  handler: async (ctx, args) => {\n    // ctx.anonymousUser\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Query Function with Session Support\nDESCRIPTION: This snippet shows how to create a custom query function that handles sessions by using the customQuery helper and integrating with the session system.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { customQuery } from \"convex-helpers/server/customFunctions\";\nimport { SessionIdArg } from \"convex-helpers/server/sessions\";\n\nexport const queryWithSession = customQuery(query, {\n  args: SessionIdArg,\n  input: async (ctx, { sessionId }) => {\n    const anonymousUser = await getAnonUser(ctx, sessionId);\n    return { ctx: { ...ctx, anonymousUser }, args: {} };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Database Query Filtering\nDESCRIPTION: Examples of using the filter helper to apply complex filters to database queries in Convex.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport { filter } from \"convex-helpers/server/filter\";\n\nexport const evens = query({\n  args: {},\n  handler: async (ctx) => {\n    return await filter(\n      ctx.db.query(\"counter_table\"),\n      (c) => c.counter % 2 === 0,\n    ).collect();\n  },\n});\n\nexport const lastCountLongerThanName = query({\n  args: {},\n  handler: async (ctx) => {\n    return await filter(\n      ctx.db.query(\"counter_table\"),\n      (c) => c.counter > c.name.length,\n    )\n      .order(\"desc\")\n      .first();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Zod Validation Integration in Convex\nDESCRIPTION: Shows how to use Zod for argument validation in Convex functions. Includes examples of various Zod schemas and their usage with custom queries.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { z } from \"zod\";\nimport { zCustomQuery, zid } from \"convex-helpers/server/zod\";\nimport { NoOp } from \"convex-helpers/server/customFunctions\";\n\n// Define this once - and customize like you would customQuery\nconst zodQuery = zCustomQuery(query, NoOp);\n\nexport const myComplexQuery = zodQuery({\n  args: {\n    userId: zid(\"users\"),\n    email: z.string().email(),\n    num: z.number().min(0),\n    nullableBigint: z.nullable(z.bigint()),\n    boolWithDefault: z.boolean().default(true),\n    null: z.null(),\n    array: z.array(z.string()),\n    optionalObject: z.object({ a: z.string(), b: z.number() }).optional(),\n    union: z.union([z.string(), z.number()]),\n    discriminatedUnion: z.discriminatedUnion(\"kind\", [\n      z.object({ kind: z.literal(\"a\"), a: z.string() }),\n      z.object({ kind: z.literal(\"b\"), b: z.number() }),\n    ]),\n    literal: z.literal(\"hi\"),\n    enum: z.enum([\"a\", \"b\"]),\n    readonly: z.object({ a: z.string(), b: z.number() }).readonly(),\n    pipeline: z.number().pipe(z.coerce.string()),\n  },\n  handler: async (ctx, args) => {\n    //... args at this point has been validated and has the types of what\n    // zod parses the values into.\n    // e.g. boolWithDefault is `bool` but has an input type `bool | undefined`.\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Paginator for Manual Pagination in TypeScript\nDESCRIPTION: This example shows how to use the paginator function as an alternative to the built-in db.query.paginate method in Convex queries.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { paginator } from \"convex-helpers/server/pagination\";\nimport schema from \"./schema\";\n\nexport const list = query({\n  args: { opts: paginationOptsValidator },\n  handler: async (ctx, { opts }) => {\n    // BEFORE:\n    return await ctx.db.query(\"messages\").paginate(opts);\n    // AFTER:\n    return await paginator(ctx.db, schema).query(\"messages\").paginate(opts);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Advanced Pagination with Index and Order in TypeScript\nDESCRIPTION: This snippet demonstrates how to use paginator with a specific index, order, and additional query conditions for more complex pagination scenarios.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { paginator } from \"convex-helpers/server/pagination\";\nimport schema from \"./schema\";\n\nexport const list = query({\n  args: { opts: paginationOptsValidator, author: v.id(\"users\") },\n  handler: async (ctx, { opts, author }) => {\n    return await paginator(ctx.db, schema)\n      .query(\"messages\")\n      .withIndex(\"by_author\", (q) => q.eq(\"author\", author))\n      .order(\"desc\")\n      .paginate(opts);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Paginating Messages by Multiple Authors using QueryStreams in TypeScript\nDESCRIPTION: This example demonstrates how to use QueryStreams to paginate messages from multiple authors, merging and ordering the results.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stream, mergedStream } from \"convex-helpers/server/stream\";\nimport schema from \"./schema\";\n// schema has messages: defineTable(...).withIndex(\"by_author\", [\"author\"])\n\nexport const listForAuthors = query({\n  args: {\n    authors: v.array(v.id(\"users\")),\n    paginationOpts: paginationOptsValidator,\n  },\n  handler: async (ctx, { authors, paginationOpts }) => {\n    // This is an array of streams, where each stream consists of messages by a\n    // single author.\n    const authorStreams = authors.map((author) =>\n      stream(ctx.db, schema)\n        .query(\"messages\")\n        .withIndex(\"by_author\", (q) => q.eq(\"author\", author)),\n    );\n    // Create a new stream of all messages authored by users in `args.authors`,\n    // ordered by the \"by_author\" index (i.e. [\"author\", \"_creationTime\"]).\n    const allAuthorsStream = mergedStream(authorStreams, [\n      \"author\",\n      \"_creationTime\",\n    ]);\n    // Paginate the result.\n    return await allAuthorsStream.paginate(paginationOpts);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Pre-filter Pagination with Complex Predicate using QueryStreams in TypeScript\nDESCRIPTION: This snippet shows how to use QueryStreams for pre-filter pagination, where messages are filtered based on a complex predicate before pagination is applied.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stream } from \"convex-helpers/server/stream\";\nimport schema from \"./schema\";\n\nexport const list = query({\n  args: { paginationOpts: paginationOptsValidator },\n  handler: async (ctx, { paginationOpts }) => {\n    const allMessagesStream = stream(ctx.db, schema)\n      .query(\"messages\")\n      .order(\"desc\")\n      .filterWith(async (message) => {\n        const author = await ctx.db.get(message.author);\n        return author !== null && author.verified;\n      });\n    // The pagination happens after the filtering, so the page should have size\n    // `paginationOpts.numItems`.\n    // To avoid reading too much data unexpectedly, you can optionally set maximumRowsRead.\n    return await messagesByVerifiedAuthors.paginate({\n      ...paginationOpts,\n      maximumRowsRead: 100,\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Stream API to Order by Index Suffix in Convex\nDESCRIPTION: This snippet demonstrates how to use the Stream API to efficiently query messages by author while merging read and unread messages, ordered by creation time. It eliminates the need for additional indexes or multiple requests by using MergedStream to combine query results.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stream, MergedStream } from \"convex-helpers/server/stream\";\nimport schema from \"./schema\";\n// schema has messages: defineTable(...).index(\"by_author\", [\"author\", \"unread\"])\n\nexport const latestMessages = query({\n  args: { author: v.id(\"users\") },\n  handler: async (ctx, { author }) => {\n    // These are two streams of messages, each ordered by _creationTime descending.\n    // The first has read messages, the second has unread messages.\n    const readMessages = stream(ctx.db, schema)\n      .query(\"messages\")\n      .withIndex(\"by_author\", (q) => q.eq(\"author\", author).eq(\"unread\", false))\n      .order(\"desc\");\n    const unreadMessages = stream(ctx.db, schema)\n      .query(\"messages\")\n      .withIndex(\"by_author\", (q) => q.eq(\"author\", author).eq(\"unread\", true))\n      .order(\"desc\");\n    // Since each stream is ordered by [\"_creationTime\"], we can merge them and\n    // maintain that ordering.\n\n    // Aside: We could instead choose to merge the streams ordered by [\"unread\", \"_creationTime\"]\n    // or ordered by [\"author\", \"unread\", \"_creationTime\"].\n\n    // `allMessagesByCreationTime` is a single stream of all messages authored by\n    // `args.author`, ordered by _creationTime descending.\n    const allMessagesByCreationTime = new MergedStream(\n      [readMessages, unreadMessages],\n      [\"_creationTime\"],\n    );\n    return await allMessagesByCreationTime.take(10);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Joining Tables with Stream API in Convex\nDESCRIPTION: This example demonstrates how to join multiple tables using the Stream API to paginate messages across all channels a user is a member of. It flattens channel memberships into messages and includes channel data in each message record.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stream } from \"convex-helpers/server/stream\";\nimport schema from \"./schema\";\n// schema has:\n//   channelMemberships: defineTable(...).index(\"userId\", [\"userId\", \"channelId\"])\n//   channels: defineTable(...)\n//   messages: defineTable(...).index(\"channelId\", [\"channelId\"])\n\n// Return a paginated stream of { ...channel, ...message }\n// ordered by\n// [channelMembership.channelId, channelMembership._creationTime, message.channelId, message._creationTime],\n// i.e. ordered by [channel._id, message._creationTime]\n// if we assume the channelMemberships.userId index is unique\nexport const latestMessages = query({\n  args: { paginationOpts: paginationOptsValidator },\n  handler: async (ctx, { paginationOpts }) => {\n    // Get the channels the user is a member of\n    const channelMemberships = stream(ctx.db, schema)\n      .query(\"channelMemberships\")\n      .withIndex(\"userId\", q => q.eq(\"userId\", await getAuthedUserId(ctx)));\n    // Map membership to the channel info (including channel name, etc.)\n    const channels = channelMemberships.map(async (membership) => {\n      return (await ctx.db.get(membership.channelId))!;\n    });\n    // For each channel, expand it into the messages in that channel,\n    // with the channel's fields also included.\n    const messages = channels.flatMap(async (channel) =>\n      stream(ctx.db, stream)\n        .query(\"messages\")\n        .withIndex(\"channelId\", q => q.eq(\"channelId\", channel._id))\n        .map(async (message) => { ...channel, ...message }),\n      [\"channelId\", \"_creationTime\"]\n    );\n    return await messages.paginate(paginationOpts);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Session Tracking with Client-Side SessionID Storage\nDESCRIPTION: This snippet shows how to implement session tracking without cookies by using client-side storage. It demonstrates both the client-side setup with a SessionProvider and the server-side implementation to receive and use the session ID.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { SessionProvider } from \"convex-helpers/react/sessions\";\n//...\n<ConvexProvider client={convex}>\n  <SessionProvider>\n    <App />\n  </SessionProvider>\n</ConvexProvider>;\n```\n\n----------------------------------------\n\nTITLE: Using Session ID in Client Components with useSessionQuery\nDESCRIPTION: This snippet shows how to use the useSessionQuery hook to automatically pass the session ID from client to server when making queries.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useSessionQuery } from \"convex-helpers/react/sessions\";\n\nconst results = useSessionQuery(api.myModule.mySessionQuery, { arg1: 1 });\n```\n\n----------------------------------------\n\nTITLE: Fetching First Page by Creation Time in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch the first page of messages using the getPage function, ordered by creation time.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nconst { page, indexKeys, hasMore } = await getPage(ctx, {\n  table: \"messages\",\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Next Page in JavaScript\nDESCRIPTION: This code shows how to fetch the next page of messages using the getPage function, utilizing the indexKeys from the previous page.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst {\n  page: page2,\n  indexKeys: indexKeys2,\n  hasMore: hasMore2,\n} = await getPage(ctx, {\n  table: \"messages\",\n  startIndexKey: indexKeys[indexKeys.length - 1],\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Page Size and Index in JavaScript\nDESCRIPTION: This example demonstrates how to change the page size and order by a specific index when fetching a page of users.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport schema from \"./schema\";\nconst { page, indexKeys, hasMore } = await getPage(ctx, {\n  table: \"users\",\n  index: \"by_name\",\n  schema,\n  targetMaxRows: 1000,\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Page Between Fixed Index Points in JavaScript\nDESCRIPTION: This snippet shows how to fetch a page of messages between two fixed places in the index, allowing for continuous page display even as documents change.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst { page } = await getPage(ctx, {\n  table: \"messages\",\n  startIndexKey,\n  endIndexKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Recent Messages with Custom Start Point in JavaScript\nDESCRIPTION: This code demonstrates how to fetch yesterday's messages, starting from a specific index key and ordering them in descending order.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nconst { page, indexKeys, hasMore } = await getPage(ctx, {\n  table: \"messages\",\n  startIndexKey: [Date.now() - 24 * 60 * 60 * 1000],\n  startInclusive: true,\n  order: \"desc\",\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Support with corsHttpRouter\nDESCRIPTION: This snippet shows how to add CORS (Cross-Origin Resource Sharing) support to Convex HTTP actions using the corsRouter utility. It demonstrates setting up routes with CORS headers and configuring route-specific CORS options.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { corsRouter } from \"convex-helpers/server/cors\";\nimport { httpRouter } from \"convex/server\";\nimport { httpAction } from \"./_generated/api\";\n\n// Your standard Convex http router:\nconst http = httpRouter();\n\n// Your CORS router:\nconst cors = corsRouter(http);\n\ncors.route({\n  path: \"/foo\",\n  method: \"GET\",\n  handler: httpAction(async () => {\n    return new Response(\"ok\");\n  }),\n});\n\ncors.route({\n  path: \"/foo\",\n  // You can register multiple methods for the same path\n  method: \"POST\",\n  handler: httpAction(async () => {\n    return new Response(\"ok\");\n  }),\n  // You can provide configuration per route\n  allowedOrigins: [\"http://localhost:8080\"],\n});\n\n// Non-CORS routes still work, provided they're on different paths.\nhttp.route({\n  path: \"/notcors\",\n  method: \"GET\",\n  handler: httpAction(async () => {\n    return new Response(\"ok\");\n  }),\n});\n// Export http (or cors.http)\nexport default http;\n```\n\n----------------------------------------\n\nTITLE: Hono HTTP Router Configuration\nDESCRIPTION: Configuration for using Hono web framework with Convex for HTTP endpoint definitions. Shows basic setup and route handling.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Hono } from \"hono\";\nimport { HonoWithConvex, HttpRouterWithHono } from \"convex-helpers/server/hono\";\nimport { ActionCtx } from \"./_generated/server\";\n\nconst app: HonoWithConvex<ActionCtx> = new Hono();\n\n// See the [guide on Stack](https://stack.convex.dev/hono-with-convex)\n// for tips on using Hono for HTTP endpoints.\napp.get(\"/\", async (c) => {\n  return c.json(\"Hello world!\");\n});\n\nexport default new HttpRouterWithHono(app);\n```\n\n----------------------------------------\n\nTITLE: Validator Utilities Implementation\nDESCRIPTION: Demonstrates the use of validator utilities for database schema and function arguments, including branded strings and document validation.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// convex/schema.ts\nimport { literals, deprecated, brandedString } from \"convex-helpers/validators\";\nimport { Infer } from \"convex/values\";\n\n// Define a validator that requires an Email string type.\nexport const emailValidator = brandedString(\"email\");\n// Define the Email type based on the branded string.\nexport type Email = Infer<typeof emailValidator>;\n\nexport default defineSchema({\n  accounts: defineTable({\n    balance: nullable(v.bigint()),\n    status: literals(\"active\", \"inactive\"),\n    email: emailValidator,\n    oldField: deprecated,\n  }).index(\"status\", [\"status\"]),\n  //...\n});\n\n// some module\nimport { doc, typedV, partial } from \"convex-helpers/validators\";\nimport { omit, pick } from \"convex-helpers\";\nimport schema from \"./schema\";\n\n// You could export this from your schema file, or define it where you need it.\nconst vv = typedV(schema);\n\nexport const replaceUser = internalMutation({\n  args: {\n    id: vv.id(\"accounts\"),\n    replace: object({\n      // You can provide the document with or without system fields.\n      ...schema.tables.accounts.validator.fields,\n      ...partial(systemFields(\"accounts\")),\n    }),\n  },\n  returns: doc(schema, \"accounts\"), // See below for vv.doc\n  handler: async (ctx, args) => {\n    await ctx.db.replace(args.id, args.replace);\n    return await ctx.db.get(args.id);\n  },\n});\n\n// A validator just for balance & email: { balance: v.union(...), email: ..}\nconst balanceAndEmail = pick(vv.doc(\"accounts\").fields, [\"balance\", \"email\"]);\n\n// A validator for all the fields except balance.\nconst accountWithoutBalance = omit(vv.doc(\"accounts\").fields, [\"balance\"]);\n\n// Validate against a validator. Can optionally throw on error.\nconst value = { balance: 123n, email: \"test@example.com\" };\nvalidate(balanceAndEmail, value);\n\n// This will throw a ValidationError if the value is not valid.\nvalidate(balanceAndEmail, value, { throw: true });\n\n// Warning: this only validates that `accountId` is a string.\nvalidate(vv.id(\"accounts\"), accountId);\n// Whereas this validates that `accountId` is an id for the accounts table.\nvalidate(vv.id(\"accounts\"), accountId, { db: ctx.db });\n```\n\n----------------------------------------\n\nTITLE: Generating TypeScript API Specifications for Convex\nDESCRIPTION: Command-line usage example for generating TypeScript API specifications from Convex functions. This utility creates type-safe API objects for use in separate repositories.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nnpx convex-helpers ts-api-spec\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Specifications for Convex\nDESCRIPTION: Command-line usage example for generating OpenAPI specifications from Convex functions. This utility creates YAML specifications that can be used with third-party tools or clients in languages not directly supported by Convex.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#2025-04-23_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nnpx convex-helpers open-api-spec\n```\n\n----------------------------------------\n\nTITLE: Installing convex-helpers NPM Package\nDESCRIPTION: Command to install the convex-helpers package in your project. This allows you to use all the utilities provided by the package in your Convex application.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n npm install convex-helpers@latest\n```\n\n----------------------------------------\n\nTITLE: Publishing convex-helpers packages\nDESCRIPTION: Instructions for running the publish script to release new versions of convex-helpers, including handling alpha releases and version bumping.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./publish.sh\n```\n\n----------------------------------------\n\nTITLE: Publishing alpha version of convex-helpers\nDESCRIPTION: Command to publish an alpha release of the convex-helpers package, with options to bump the version beforehand.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./publish.sh alpha\n```\n\n----------------------------------------\n\nTITLE: Bumping version for alpha release\nDESCRIPTION: Command to increment the package version for a prerelease with the alpha tag and stage the changes to package files.\nSOURCE: https://github.com/get-convex/convex-helpers/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm version prerelease --preid alpha && git add package*\n```"
  }
]