[
  {
    "owner": "davidfowl",
    "repo": "aspnetcorediagnosticscenarios",
    "content": "TITLE: Using async/await with Task Returns\nDESCRIPTION: This example demonstrates the recommended approach of using async/await when working with Tasks, which normalizes exception handling, improves debugging, and properly manages async context flow.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<int> DoSomethingAsync()\n{\n    return await CallDependencyAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Sync-over-Async in C# Methods\nDESCRIPTION: Demonstrates the correct way to implement asynchronous methods using async/await instead of blocking with Task.Result.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic int DoSomethingAsync()\n{\n    var result = CallDependencyAsync().Result;\n    return result + 1;\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<int> DoSomethingAsync()\n{\n    var result = await CallDependencyAsync();\n    return result + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Async Void in ASP.NET Core Controllers\nDESCRIPTION: Shows how to properly implement background operations in ASP.NET Core controllers without using async void, which can lead to unhandled exceptions and application crashes.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpPost(\"/start\")]\n    public IActionResult Post()\n    {\n        BackgroundOperationAsync();\n        return Accepted();\n    }\n    \n    public async void BackgroundOperationAsync()\n    {\n        var result = await CallDependencyAsync();\n        DoSomething(result);\n    }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpPost(\"/start\")]\n    public IActionResult Post()\n    {\n        Task.Run(BackgroundOperationAsync);\n        return Accepted();\n    }\n    \n    public async Task BackgroundOperationAsync()\n    {\n        var result = await CallDependencyAsync();\n        DoSomething(result);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Async/Await Implementation\nDESCRIPTION: Example showing proper implementation using async/await pattern instead of ContinueWith.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<int> DoSomethingAsync()\n{\n    var result = await CallDependencyAsync();\n    return result + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct CancellationToken Propagation in C#\nDESCRIPTION: This example demonstrates proper propagation of CancellationToken to child operations (Stream.ReadAsync), ensuring that cancellation works throughout the call chain.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<string> DoAsyncThing(CancellationToken cancellationToken = default)\n{\n   byte[] buffer = new byte[1024];\n   // This properly flows cancellationToken to ReadAsync\n   int read = await _stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken);\n   return Encoding.UTF8.GetString(buffer, 0, read);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Task.FromResult for Pre-computed Values in C#\nDESCRIPTION: Illustrates the efficient way to return pre-computed or trivially computed values in async methods using Task.FromResult instead of Task.Run, which unnecessarily uses a thread-pool thread.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyLibrary\n{\n   public Task<int> AddAsync(int a, int b)\n   {\n       return Task.Run(() => a + b);\n   }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyLibrary\n{\n   public Task<int> AddAsync(int a, int b)\n   {\n       return Task.FromResult(a + b);\n   }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyLibrary\n{\n   public ValueTask<int> AddAsync(int a, int b)\n   {\n       return new ValueTask<int>(a + b);\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of HttpClient for Asynchronous HTTP Requests in C#\nDESCRIPTION: This example shows the recommended approach of using a static HttpClient instance to make asynchronous HTTP requests. It properly utilizes async/await pattern and reuses the HttpClient instance to avoid socket exhaustion.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/HttpClientGuidance.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly HttpClient client = new HttpClient();\n\npublic async Task<string> DoSomethingAsync()\n{\n    return await client.GetStringAsync(\"http://www.google.com\");\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Stream Disposal with await using in ASP.NET Core\nDESCRIPTION: This example shows the recommended approach of using await with using to asynchronously flush any buffered data while disposing the StreamWriter, preventing blocking operations.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\napp.Run(async context =>\n{\n    // The implicit AsyncDispose call will flush asynchronously\n    await using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Operations with PeriodicTimer in .NET 6 (Recommended Pattern)\nDESCRIPTION: This example uses the .NET 6 PeriodicTimer class for implementing recurring operations. This approach provides a cleaner asynchronous model with better exception handling capabilities.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pinger : IDisposable\n{\n    private readonly PeriodicTimer _timer;\n    private readonly HttpClient _client;\n\n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new PeriodicTimer(TimeSpan.FromSeconds(1));\n        _ = Task.Run(DoAsyncPings);\n    }\n\n    public void Dispose()\n    {\n        _timer.Dispose();\n    }\n\n    private async Task DoAsyncPings()\n    {\n        while (await _timer.WaitForNextTickAsync())\n        {\n            // TODO: Handle exceptions\n            await _client.GetAsync(\"http://mybackend/api/ping\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary.GetOrAdd with AsyncLazy Pattern (Recommended Pattern)\nDESCRIPTION: This implementation uses the async lazy pattern to prevent redundant execution of expensive operations. It ensures the delegate will only be called once even if the dictionary entry is constructed multiple times under concurrent access.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, AsyncLazy<Person>> _cache = new ConcurrentDictionary<int, AsyncLazy<Person>>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public async Task<IActionResult> Get(int id)\n   {\n       var person = await _cache.GetOrAdd(id, (key) => new AsyncLazy<Person>(() => _db.People.FindAsync(key))).Value;\n       return Ok(person);\n   }\n   \n   private class AsyncLazy<T> : Lazy<Task<T>>\n   {\n      public AsyncLazy(Func<Task<T>> valueFactory) : base(valueFactory)\n      {\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Background Queue with Proper Async Support (Recommended Pattern)\nDESCRIPTION: This BackgroundQueue implementation provides overloads for both synchronous and asynchronous callbacks, allowing clients to properly handle async operations without resorting to async void.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic class BackgroundQueue\n{\n    public static void FireAndForget(Action action) { }\n    public static void FireAndForget(Func<Task> action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Cancellation Implementation of Uncancellable Operations in C#\nDESCRIPTION: This example demonstrates a proper implementation for cancelling uncancellable operations by using a TaskCompletionSource with a disposable CancellationTokenRegistration, which prevents memory leaks.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task<T> WithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)\n{\n    var tcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);\n\n    // This disposes the registration as soon as one of the tasks trigger\n    using (cancellationToken.Register(state =>\n    {\n        ((TaskCompletionSource<object>)state).TrySetResult(null);\n    },\n    tcs))\n    {\n        var resultTask = await Task.WhenAny(task, tcs.Task);\n        if (resultTask == tcs.Task)\n        {\n            // Operation cancelled\n            throw new OperationCanceledException(cancellationToken);\n        }\n\n        return await task;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct TaskCompletionSource Initialization in C#\nDESCRIPTION: This example shows the proper way to initialize TaskCompletionSource<T> with TaskCreationOptions.RunContinuationsAsynchronously, ensuring that continuations run on thread-pool threads rather than inline on the callback thread.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic Task<int> DoSomethingAsync()\n{\n    var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);\n    \n    var operation = new LegacyAsyncOperation();\n    operation.Completed += result =>\n    {\n        // Code awaiting on this task will resume on a different thread-pool thread\n        tcs.SetResult(result);\n    };\n    \n    return tcs.Task;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Timeout Implementation in C#\nDESCRIPTION: This example demonstrates a proper timeout implementation that uses a CancellationTokenSource to cancel the timer task when the main operation completes successfully, preventing timer queue flooding.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task<T> TimeoutAfter<T>(this Task<T> task, TimeSpan timeout)\n{\n    using (var cts = new CancellationTokenSource())\n    {\n        var delayTask = Task.Delay(timeout, cts.Token);\n\n        var resultTask = await Task.WhenAny(task, delayTask);\n        if (resultTask == delayTask)\n        {\n            // Operation cancelled\n            throw new OperationCanceledException();\n        }\n        else\n        {\n            // Cancel the timer task so that it does not fire\n            cts.Cancel();\n        }\n\n        return await task;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of RunImpersonated with Asynchronous Operations in C#\nDESCRIPTION: This example demonstrates the recommended approach for pre-.NET 5.0 frameworks, where the asynchronous operation is returned from within the impersonated context and awaited properly. This ensures the impersonation context is maintained throughout the operation.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return await WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle, \n        context => _db.QueryAsync(\"SELECT Name from Products\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Dedicated Thread Implementation\nDESCRIPTION: Example showing proper implementation using a dedicated background thread for long-running work instead of consuming a thread pool thread.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n    \n    public void StartProcessing()\n    {\n        var thread = new Thread(ProcessQueue) \n        {\n            // This is important as it allows the process to exit while this thread is running\n            IsBackground = true\n        };\n        thread.Start();\n    }\n    \n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n    \n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n             ProcessItem(item);\n        }\n    }\n    \n    private void ProcessItem(Message message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Factory Method Pattern (Recommended Pattern)\nDESCRIPTION: This implementation uses a static factory pattern to allow asynchronous initialization of a service. This approach avoids blocking and potential deadlocks while still ensuring proper initialization.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class Service : IService\n{\n    private readonly IRemoteConnection _connection;\n\n    private Service(IRemoteConnection connection)\n    {\n        _connection = connection;\n    }\n\n    public static async Task<Service> CreateAsync(IRemoteConnectionFactory connectionFactory)\n    {\n        return new Service(await connectionFactory.ConnectAsync());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct CancellationTokenSource Usage with Disposal in C#\nDESCRIPTION: This example demonstrates proper disposal of CancellationTokenSource using a using statement, which ensures the timer is properly removed from the queue after the operation completes.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<Stream> HttpClientAsyncWithCancellationGood()\n{\n    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))\n    {\n        using (var client = _httpClientFactory.CreateClient())\n        {\n            var response = await client.GetAsync(\"http://backend/api/1\", cts.Token);\n            return await response.Content.ReadAsStreamAsync();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Asynchronous Read on HttpRequest.Body in ASP.NET Core\nDESCRIPTION: This example shows the correct approach of using asynchronous reading from the request body. It uses StreamReader.ReadToEndAsync() to asynchronously read the entire HTTP request body, avoiding thread blocking.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpGet(\"/pokemon\")]\n    public async Task<ActionResult<PokemonData>> Get()\n    {\n        // This asynchronously reads the entire http request body into memory.\n        var json = await new StreamReader(Request.Body).ReadToEndAsync();\n\n        return JsonConvert.DeserializeObject<PokemonData>(json);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using RunImpersonatedAsync in .NET 5.0+ for Asynchronous Operations in C#\nDESCRIPTION: This example shows the preferred approach in .NET 5.0 and newer versions, using the dedicated RunImpersonatedAsync method which provides built-in support for asynchronous operations under impersonation contexts.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return await WindowsIdentity.RunImpersonatedAsync(\n        safeAccessTokenHandle, \n        context => _db.QueryAsync(\"SELECT Name from Products\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of HttpRequest.ReadFormAsync() in ASP.NET Core\nDESCRIPTION: This example shows the correct approach of using HttpRequest.ReadFormAsync() to read the form body asynchronously. It avoids potential thread pool starvation by using asynchronous operations.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpPost(\"/form-body\")]\n    public async Task<IActionResult> Post()\n    {\n        var form = await HttpRequest.ReadFormAsync();\n        \n        Process(form[\"id\"], form[\"name\"]);\n\n        return Accepted();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Header Addition Using OnStarting in ASP.NET Core\nDESCRIPTION: This example demonstrates using HttpResponse.OnStarting to reliably set headers before they're sent to the client. This callback approach ensures headers can be set regardless of when the response body begins writing, providing a clean solution for header management.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\napp.Use(async (next, context) =>\n{\n    // Wire up the callback that will fire just before the response headers are sent to the client.\n    context.Response.OnStarting(() => \n    {       \n        context.Response.Headers[\"someheader\"] = \"somevalue\"; \n        return Task.CompletedTask;\n    });\n    \n    await next();\n});\n```\n\n----------------------------------------\n\nTITLE: Correct AsyncLocal Usage in Async Methods in C#\nDESCRIPTION: Shows the proper way to use AsyncLocal within async methods, ensuring correct value scoping and restoration of the execution context.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nvar local = new AsyncLocal<int>();\nawait MethodA();\nConsole.WriteLine(local.Value);\n\nasync Task MethodA()\n{\n    local.Value = 1;\n    await MethodB();\n    Console.WriteLine(local.Value);\n}\n\nasync Task MethodB()\n{\n    local.Value = 2;\n    Console.WriteLine(local.Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Data Extraction for Background Tasks in ASP.NET Core\nDESCRIPTION: This example demonstrates the proper way to handle background tasks by explicitly copying needed data from HttpContext during the request. By capturing just the required information upfront, the background task doesn't reference HttpContext directly.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[HttpGet(\"/fire-and-forget-3\")]\npublic IActionResult FireAndForget3()\n{\n    string path = HttpContext.Request.Path;\n    _ = Task.Run(async () =>\n    {\n        await Task.Delay(1000);\n\n        // This captures just the path\n        Log(path);\n    });\n\n    return Accepted();\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Service Scope Creation for Background Tasks in ASP.NET Core\nDESCRIPTION: This example shows the proper way to handle services in background tasks by injecting IServiceScopeFactory and creating a new scope. This approach ensures the background task has its own properly scoped dependencies that aren't tied to the original request.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[HttpGet(\"/fire-and-forget-3\")]\npublic IActionResult FireAndForget3([FromServices]IServiceScopeFactory serviceScopeFactory)\n{\n    // This version of fire and forget adds some exception handling. We're also no longer capturing the PokemonDbContext from the incoming request.\n    // Instead, we're injecting an IServiceScopeFactory (which is a singleton) in order to create a scope in the background work item.\n    _ = Task.Run(async () =>\n    {\n        await Task.Delay(1000);\n\n        // Create a scope for the lifetime of the background operation and resolve services from it\n        using (var scope = serviceScopeFactory.CreateScope())\n        {\n            // This will resolve a PokemonDbContext from the correct scope and the operation will succeed\n            var context = scope.ServiceProvider.GetRequiredService<PokemonDbContext>();\n\n            context.Pokemon.Add(new Pokemon());\n            await context.SaveChangesAsync();\n        }\n    });\n\n    return Accepted();\n}\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe AsyncLocal ConcurrentDictionary Implementation\nDESCRIPTION: Shows the correct implementation using ConcurrentDictionary for thread-safe operations with AsyncLocal.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nclass AmbientValues\n{\n    private static readonly AsyncLocal<ConcurrentDictionary<int, string>> _current = new();\n\n    public static ConcurrentDictionary<int, string> Current\n    {\n        get => _current.Value!;\n        set => _current.Value = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct HttpContext Access with Pre-captured Values in ASP.NET Core\nDESCRIPTION: This example shows the proper way to handle HttpContext values when working with parallel tasks by capturing necessary data upfront. By passing the path as a parameter to SearchAsync, the code avoids accessing HttpContext from multiple threads simultaneously.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/search\")]\n    public async Task<SearchResults> Get(string query)\n    {\n        string path = HttpContext.Request.Path;\n        var query1 = SearchAsync(SearchEngine.Google, query, path);\n        var query2 = SearchAsync(SearchEngine.Bing, query, path);\n        var query3 = SearchAsync(SearchEngine.DuckDuckGo, query, path);\n\n        await Task.WhenAll(query1, query2, query3);\n        \n        var results1 = await query1;\n        var results2 = await query2;\n        var results3 = await query3;\n\n        return SearchResults.Combine(results1, results2, results3);\n    }\n\n    private async Task<SearchResults> SearchAsync(SearchEngine engine, string query, string path)\n    {\n        var searchResults = SearchResults.Empty;\n        try\n        {\n            _logger.LogInformation(\"Starting search query from {path}.\", path);\n            searchResults = await _searchService.SearchAsync(engine, query);\n            _logger.LogInformation(\"Finishing search query from {path}.\", path);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed query from {path}\", path);\n        }\n\n        return searchResults;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Header Addition with Response Status Check in ASP.NET Core\nDESCRIPTION: This example shows a safe way to add headers by checking if the response has already started. By using the HasStarted property, the code can determine if it's still possible to modify headers before attempting to do so.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\napp.Use(async (next, context) =>\n{\n    await context.Response.WriteAsync(\"Hello \");\n    \n    await next();\n    \n    // Check if the response has already started before adding header and writing\n    if (!context.Response.HasStarted)\n    {\n        context.Response.Headers[\"test\"] = \"value\";\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized NumberCache Implementation Using UnsafeRegister in C#\nDESCRIPTION: Shows the correct implementation using CancellationToken.UnsafeRegister to avoid capturing ExecutionContext, preventing memory leaks in the cache implementation.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic class NumberCache\n{\n    private readonly ConcurrentDictionary<int, CancellationTokenSource> _cache = new ConcurrentDictionary<int, CancellationTokenSource>();\n    private TimeSpan _timeSpan;\n\n    public NumberCache(TimeSpan timeSpan)\n    {\n        _timeSpan = timeSpan;\n    }\n\n    public void Add(int key)\n    {\n        var cts = _cache.GetOrAdd(key, _ => new CancellationTokenSource());\n        // Delete entry on expiration\n        cts.Token.UnsafeRegister((_, _) => _cache.TryRemove(key, out _), null);\n\n        // Start count down\n        cts.CancelAfter(_timeSpan);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Task-based Controller Action in ASP.NET Core\nDESCRIPTION: This example demonstrates the proper way to implement asynchronous controller actions by returning Task instead of using async void. This ensures the HttpContext remains valid until the operation completes.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/async\")]\n    public async Task Get()\n    {\n        await Task.Delay(1000);\n        \n        await Response.WriteAsync(\"Hello World\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of IHttpContextAccessor in ASP.NET Core\nDESCRIPTION: This example shows the correct approach of using IHttpContextAccessor. It stores the accessor itself and retrieves the HttpContext when needed, checking for null to ensure thread-safety and correctness.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyType\n{\n    private readonly IHttpContextAccessor _accessor;\n    public MyType(IHttpContextAccessor accessor)\n    {\n        _accessor = accessor;\n    }\n    \n    public void CheckAdmin()\n    {\n        var context = _accessor.HttpContext;\n        if (context != null && !context.User.IsInRole(\"admin\"))\n        {\n            throw new UnauthorizedAccessException(\"The current user isn't an admin\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncLocal Execution Context Demonstration\nDESCRIPTION: Shows how execution context changes when setting AsyncLocal values, demonstrating the copy-on-write behavior.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nDisposableThing.Current = new DisposableThing();\n\nConsole.WriteLine(\"After setting thing \" + ExecutionContext.Capture().GetHashCode());\n\nDisposableThing.Current = null;\n\nConsole.WriteLine(\"After setting Current to null \" + ExecutionContext.Capture().GetHashCode());\n```\n\n----------------------------------------\n\nTITLE: Implementing Timer Callbacks with Task Discarding (Recommended Pattern)\nDESCRIPTION: This example demonstrates a recommended approach for Timer callbacks by using a void method that discards a Task. This prevents process crashes while still maintaining the asynchronous execution model.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public void Heartbeat(object state)\n    {\n        // Discard the result\n        _ = DoAsyncPing();\n    }\n\n    private async Task DoAsyncPing()\n    {\n        await _client.GetAsync(\"http://mybackend/api/ping\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary.GetOrAdd with Task Caching (Better Pattern)\nDESCRIPTION: This implementation improves on the previous example by caching Task<Person> instead of Person objects directly. This avoids thread-pool starvation but may still execute the value-constructing delegate multiple times under concurrent access.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, Task<Person>> _cache = new ConcurrentDictionary<int, Task<Person>>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public async Task<IActionResult> Get(int id)\n   {\n       var person = await _cache.GetOrAdd(id, (key) => _db.People.FindAsync(key));\n       return Ok(person);\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: TaskFactory LongRunning Implementation\nDESCRIPTION: Example demonstrating the use of TaskFactory with TaskCreationOptions.LongRunning for handling long-running operations with better exception handling and TPL integration.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n\n    public Task StartProcessing() => Task.Factory.StartNew(ProcessQueue, TaskCreationOptions.LongRunning);\n\n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n\n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n            ProcessItem(item);\n        }\n    }\n\n    private void ProcessItem(Message message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Asynchronous Flush Before Stream Disposal in ASP.NET Core\nDESCRIPTION: This example shows an alternative approach where FlushAsync is explicitly called before disposing the StreamWriter, ensuring any buffered data is written asynchronously.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\napp.Run(async context =>\n{\n    using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n\n        // Force an asynchronous flush\n        await streamWriter.FlushAsync();\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Connection Interface Definitions\nDESCRIPTION: Interface definitions for a remote connection system requiring asynchronous initialization. These interfaces define the contract for connecting to and communicating with a remote service.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRemoteConnectionFactory\n{\n   Task<IRemoteConnection> ConnectAsync();\n}\n\npublic interface IRemoteConnection\n{\n    Task PublishAsync(string channel, string message);\n    Task DisposeAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Disposable AsyncLocal Implementation\nDESCRIPTION: Demonstrates an incorrect implementation where a disposable object is stored in AsyncLocal, leading to ObjectDisposedException due to execution context behavior.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nusing (var thing = new DisposableThing())\n{\n    DisposableThing.Current = thing;\n    Dispatch();\n    DisposableThing.Current = null;\n}\n\nvoid Dispatch()\n{\n    _ = Task.Run(async () =>\n    {\n        await Task.Delay(1000);\n        Log();\n    });\n}\n\nvoid Log()\n{\n    try\n    {\n        var thing = DisposableThing.Current;\n        if (thing is not null)\n        {\n            Console.WriteLine($\"Logging ambient value {thing.Value}\");\n        }\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine(ex);\n    }\n}\n\nclass DisposableThing : IDisposable\n{\n    private static readonly AsyncLocal<DisposableThing?> _current = new();\n    private bool _disposed;\n\n    public static DisposableThing? Current\n    {\n        get => _current.Value;\n        set\n        {\n            _current.Value = value;\n        }\n    }\n\n    public int Value\n    {\n        get\n        {\n            if (_disposed) throw new ObjectDisposedException(GetType().FullName);\n            return 1;\n        }\n    }\n\n    public void Dispose()\n    {\n        _disposed = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect HttpContext Capture in Background Thread\nDESCRIPTION: This example shows the problematic pattern of capturing HttpContext in a background task. Since the background task may execute after the request completes, accessing HttpContext properties could lead to invalid data or exceptions.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[HttpGet(\"/fire-and-forget-1\")]\npublic IActionResult FireAndForget1()\n{\n    _ = Task.Run(() =>\n    {\n        await Task.Delay(1000);\n\n        // This closure is capturing the context from the Controller property. This is bad because this work item could run\n        // outside of the http request leading to reading of bogus data.\n        var path = HttpContext.Request.Path;\n        Log(path);\n    });\n\n    return Accepted();\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect HttpContext Access from Multiple Threads in ASP.NET Core\nDESCRIPTION: This example demonstrates the incorrect way of accessing HttpContext from multiple threads in parallel when making concurrent API requests. This approach is problematic because HttpContext is not thread-safe, potentially causing corruption and undefined behavior.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/search\")]\n    public async Task<SearchResults> Get(string query)\n    {\n        var query1 = SearchAsync(SearchEngine.Google, query);\n        var query2 = SearchAsync(SearchEngine.Bing, query);\n        var query3 = SearchAsync(SearchEngine.DuckDuckGo, query);\n\n        await Task.WhenAll(query1, query2, query3);\n        \n        var results1 = await query1;\n        var results2 = await query2;\n        var results3 = await query3;\n\n        return SearchResults.Combine(results1, results2, results3);\n    }\n\n    private async Task<SearchResults> SearchAsync(SearchEngine engine, string query)\n    {\n        var searchResults = SearchResults.Empty;\n        try\n        {\n            _logger.LogInformation(\"Starting search query from {path}.\", HttpContext.Request.Path);\n            searchResults = await _searchService.SearchAsync(engine, query);\n            _logger.LogInformation(\"Finishing search query from {path}.\", HttpContext.Request.Path);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed query from {path}\", HttpContext.Request.Path);\n        }\n\n        return searchResults;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Directly Returning Task in Asynchronous Methods\nDESCRIPTION: This example shows a problematic pattern of directly returning a Task without using async/await, which can cause issues with exception handling, debugging, and async context flow.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic Task<int> DoSomethingAsync()\n{\n    return CallDependencyAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect CancellationToken Propagation in C#\nDESCRIPTION: This example shows incorrect handling of CancellationToken where it is not properly propagated to child operations (Stream.ReadAsync), making the operation effectively uncancellable.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<string> DoAsyncThing(CancellationToken cancellationToken = default)\n{\n   byte[] buffer = new byte[1024];\n   // We forgot to pass flow cancellationToken to ReadAsync\n   int read = await _stream.ReadAsync(buffer, 0, buffer.Length);\n   return Encoding.UTF8.GetString(buffer, 0, read);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Cancellation Implementation of Uncancellable Operations in C#\nDESCRIPTION: This example shows an incorrect approach to cancelling uncancellable operations using Task.Delay(-1, token), which can lead to memory leaks because the CancellationTokenRegistration cannot be disposed.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task<T> WithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)\n{\n    // There's no way to dispose of the registration\n    var delayTask = Task.Delay(-1, cancellationToken);\n\n    var resultTask = await Task.WhenAny(task, delayTask);\n    if (resultTask == delayTask)\n    {\n        // Operation cancelled\n        throw new OperationCanceledException();\n    }\n\n    return await task;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of RunImpersonated with Task.Result in C#\nDESCRIPTION: This example shows a problematic implementation that uses Task.Result to synchronously wait for an asynchronous operation. This pattern can lead to thread-pool starvation and deadlocks.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic IEnumerable<Product> GetDataImpersonated(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle,\n        context => _db.QueryAsync(\"SELECT Name from Products\").Result);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect CancellationTokenSource Usage without Disposal in C#\nDESCRIPTION: This example shows incorrect usage of CancellationTokenSource for timeouts without proper disposal, which can lead to pressure on the timer queue as the timer stays in the queue until it expires.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<Stream> HttpClientAsyncWithCancellationBad()\n{\n    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));\n\n    using (var client = _httpClientFactory.CreateClient())\n    {\n        var response = await client.GetAsync(\"http://backend/api/1\", cts.Token);\n        return await response.Content.ReadAsStreamAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect ContinueWith Usage\nDESCRIPTION: Example showing incorrect usage of ContinueWith instead of async/await pattern.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic Task<int> DoSomethingAsync()\n{\n    return CallDependencyAsync().ContinueWith(task =>\n    {\n        return task.Result + 1;\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect TaskCompletionSource Initialization in C#\nDESCRIPTION: This example demonstrates incorrect usage of TaskCompletionSource<T> without the RunContinuationsAsynchronously option, which can lead to continuations executing on the callback thread and potentially causing deadlocks or thread-pool starvation.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic Task<int> DoSomethingAsync()\n{\n    var tcs = new TaskCompletionSource<int>();\n    \n    var operation = new LegacyAsyncOperation();\n    operation.Completed += result =>\n    {\n        // Code awaiting on this task will resume on this thread!\n        tcs.SetResult(result);\n    };\n    \n    return tcs.Task;\n}\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary.GetOrAdd with Blocking Call (Problematic Pattern)\nDESCRIPTION: This example shows a problematic pattern using ConcurrentDictionary.GetOrAdd with Task.Result. This can cause thread-pool starvation as it blocks the request thread while waiting for database operations to complete.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, Person> _cache = new ConcurrentDictionary<int, Person>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public IActionResult Get(int id)\n   {\n       var person = _cache.GetOrAdd(id, (key) => _db.People.FindAsync(key).Result);\n       return Ok(person);\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Task.Result Usage Examples\nDESCRIPTION: Various incorrect implementations showing problematic ways of blocking on async operations that can lead to deadlocks and thread pool starvation.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic string DoOperationBlocking()\n{\n    return Task.Run(() => DoAsyncOperation()).Result;\n}\n\npublic string DoOperationBlocking2()\n{\n    return Task.Run(() => DoAsyncOperation()).GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking3()\n{\n    return Task.Run(() => DoAsyncOperation().Result).Result;\n}\n\npublic string DoOperationBlocking4()\n{\n    return Task.Run(() => DoAsyncOperation().GetAwaiter().GetResult()).GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking5()\n{\n    return DoAsyncOperation().Result;\n}\n\npublic string DoOperationBlocking6()\n{\n    return DoAsyncOperation().GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking7()\n{\n    var task = DoAsyncOperation();\n    task.Wait();\n    return task.GetAwaiter().GetResult();\n}\n```\n\n----------------------------------------\n\nTITLE: Background Queue with Problematic Action Callback\nDESCRIPTION: This implementation of a BackgroundQueue forces callers to either block in the callback or use an async void delegate, which can lead to unhandled exceptions and application instability.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class BackgroundQueue\n{\n    public static void FireAndForget(Action action) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Timer Callbacks with Blocking Calls (Problematic Pattern)\nDESCRIPTION: This example shows a Timer callback that blocks by using GetAwaiter().GetResult(). This synchronous over asynchronous approach can lead to thread-pool starvation and application performance issues.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public void Heartbeat(object state)\n    {\n        _client.GetAsync(\"http://mybackend/api/ping\").GetAwaiter().GetResult();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect AsyncLocal Usage Outside Async Methods in C#\nDESCRIPTION: Demonstrates incorrect usage of AsyncLocal outside of async methods, which leads to unexpected value propagation and potential bugs.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nvar local = new AsyncLocal<int>();\nMethodA();\nConsole.WriteLine(local.Value);\n\nvoid MethodA()\n{\n    local.Value = 1;\n    MethodB();\n    Console.WriteLine(local.Value);\n}\n\nvoid MethodB()\n{\n    local.Value = 2;\n    Console.WriteLine(local.Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Thread Pool Usage with Task.Run\nDESCRIPTION: Example showing incorrect usage of Task.Run for long-running work that blocks a thread pool thread indefinitely while processing a BlockingCollection<T>.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n    \n    public void StartProcessing()\n    {\n        Task.Run(ProcessQueue);\n    }\n    \n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n    \n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n             ProcessItem(item);\n        }\n    }\n    \n    private void ProcessItem(Message message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Header Addition After Response Start in ASP.NET Core\nDESCRIPTION: This example demonstrates the problematic pattern of attempting to add response headers after potentially writing to the response body. Since ASP.NET Core doesn't buffer responses, once writing begins, headers can no longer be modified.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\napp.Use(async (next, context) =>\n{\n    await context.Response.WriteAsync(\"Hello \");\n    \n    await next();\n    \n    // This may fail if next() already wrote to the response\n    context.Response.Headers[\"test\"] = \"value\";    \n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect Capture of Scoped Services in Background Threads\nDESCRIPTION: This example demonstrates the incorrect practice of capturing scoped services (like DbContext) in background tasks. Since these services are tied to the request lifecycle, accessing them after the request completes can result in ObjectDisposedException.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[HttpGet(\"/fire-and-forget-1\")]\npublic IActionResult FireAndForget1([FromServices]PokemonDbContext context)\n{\n    _ = Task.Run(() =>\n    {\n        await Task.Delay(1000);\n\n        // This closure is capturing the context from the Controller action parameter. This is bad because this work item could run\n        // outside of the request scope and the PokemonDbContext is scoped to the request. As a result, this throws an ObjectDisposedException\n        context.Pokemon.Add(new Pokemon());\n        await context.SaveChangesAsync();\n    });\n\n    return Accepted();\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of async void with HttpContext in ASP.NET Core\nDESCRIPTION: This example shows an incorrect implementation using async void in an ASP.NET Core controller action. This pattern is problematic because it will cause the HttpContext to be used after the request completes, resulting in application crashes.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncVoidController : Controller\n{\n    [HttpGet(\"/async\")]\n    public async void Get()\n    {\n        await Task.Delay(1000);\n\n        // THIS will crash the process since we're writing after the response has completed on a background thread\n        await Response.WriteAsync(\"Hello World\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Constructor with Blocking Call (Problematic Pattern)\nDESCRIPTION: This example shows a service implementation that blocks in the constructor to get a connection. This approach can lead to thread-pool starvation and potential deadlocks.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class Service : IService\n{\n    private readonly IRemoteConnection _connection;\n    \n    public Service(IRemoteConnectionFactory connectionFactory)\n    {\n        _connection = connectionFactory.ConnectAsync().Result;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Storage of HttpContext in ASP.NET Core\nDESCRIPTION: This example demonstrates the incorrect practice of storing HttpContext in a field. It captures the HttpContext at construction time, which may lead to using a null or incorrect context later.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyType\n{\n    private readonly HttpContext _context;\n    public MyType(IHttpContextAccessor accessor)\n    {\n        _context = accessor.HttpContext;\n    }\n    \n    public void CheckAdmin()\n    {\n        if (!_context.User.IsInRole(\"admin\"))\n        {\n            throw new UnauthorizedAccessException(\"The current user isn't an admin\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of HttpRequest.Form in ASP.NET Core\nDESCRIPTION: This example demonstrates the incorrect use of HttpRequest.Form, which can lead to thread pool starvation due to synchronous operations. It directly accesses the Form property of HttpRequest.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpPost(\"/form-body\")]\n    public IActionResult Post()\n    {\n        var form = HttpRequest.Form;\n        \n        Process(form[\"id\"], form[\"name\"]);\n\n        return Accepted();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Blocking Stream Disposal in ASP.NET Core\nDESCRIPTION: This example demonstrates the problematic pattern of not properly flushing a StreamWriter before disposal, which can block threads by writing synchronously to the HTTP-response body, potentially leading to thread-pool starvation.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\napp.Run(async context =>\n{\n    // The implicit Dispose call will synchronously write to the response body\n    using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Avoiding Synchronous Read on HttpRequest.Body in ASP.NET Core\nDESCRIPTION: This example demonstrates the incorrect use of synchronous reading from the request body, which can lead to thread pool starvation. It uses StreamReader.ReadToEnd() to synchronously read the entire HTTP request body into memory.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AspNetCoreGuidance.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyController : Controller\n{\n    [HttpGet(\"/pokemon\")]\n    public ActionResult<PokemonData> Get()\n    {\n        // This synchronously reads the entire http request body into memory.\n        // If the client is slowly uploading, we're doing sync over async because Kestrel does *NOT* support synchronous reads.\n        var json = new StreamReader(Request.Body).ReadToEnd();\n\n        return JsonConvert.DeserializeObject<PokemonData>(json);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of WebClient for Synchronous HTTP Requests in C#\nDESCRIPTION: This example demonstrates the deprecated pattern of using WebClient to make a synchronous HTTP request. This approach is not recommended as it blocks the thread and uses a legacy API that has been superseded by HttpClient.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/HttpClientGuidance.md#2025-04-16_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic string DoSomethingAsync()\n{\n    var client = new WebClient();\n    return client.DownloadString(\"http://www.google.com\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Timer Callbacks with async void (Problematic Pattern)\nDESCRIPTION: This example demonstrates a problematic implementation where a Timer callback uses async void to handle asynchronous work. This approach can crash the process if an exception occurs in the async void method.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public async void Heartbeat(object state)\n    {\n        await _client.GetAsync(\"http://mybackend/api/ping\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Code Creating Implicit async void Delegates (Problematic Pattern)\nDESCRIPTION: This example shows code that implicitly creates an async void delegate when calling a method that accepts Action. This can lead to unhandled exceptions if async operations fail.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic class Program\n{\n    public void Main(string[] args)\n    {\n        var httpClient = new HttpClient();\n        BackgroundQueue.FireAndForget(async () =>\n        {\n            await httpClient.GetAsync(\"http://pinger/api/1\");\n        });\n        \n        Console.ReadLine();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Timeout Implementation in C#\nDESCRIPTION: This example shows an incorrect timeout implementation that does not cancel the timer task when the main operation completes successfully, which can flood the timer queue with unnecessary timers.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task<T> TimeoutAfter<T>(this Task<T> task, TimeSpan timeout)\n{\n    var delayTask = Task.Delay(timeout);\n\n    var resultTask = await Task.WhenAny(task, delayTask);\n    if (resultTask == delayTask)\n    {\n        // Operation cancelled\n        throw new OperationCanceledException();\n    }\n\n    return await task;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of RunImpersonated with Asynchronous Operations in C#\nDESCRIPTION: This example demonstrates an anti-pattern where a query is executed asynchronously but awaited outside the impersonation context. This will throw an exception because the query might execute after the impersonation context has ended.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    Task<IEnumerable<Product>> products = null;\n    WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle,\n        context =>\n        {\n            products = _db.QueryAsync(\"SELECT Name from Products\");\n        });\n    return await products;\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Thread-Safe AsyncLocal Dictionary Implementation\nDESCRIPTION: Demonstrates incorrect usage of a non-thread-safe Dictionary in AsyncLocal, which can lead to race conditions in parallel execution.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nAmbientValues.Current = new Dictionary<int, string>();\n\nParallel.For(0, 10, i =>\n{\n    AmbientValues.Current[i] = \"processing\";\n    LogCurrentValues();\n    AmbientValues.Current[i] = \"done\";\n});\n\nvoid LogCurrentValues()\n{\n    foreach (var pair in AmbientValues.Current)\n    {\n        Console.WriteLine(pair);\n    }\n}\n\nclass AmbientValues\n{\n    private static readonly AsyncLocal<Dictionary<int, string>> _current = new();\n\n    public static Dictionary<int, string> Current\n    {\n        get => _current.Value!;\n        set => _current.Value = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Leak Example with ExecutionContext Capture in C#\nDESCRIPTION: Demonstrates a problematic implementation that causes memory leaks due to ExecutionContext capture in CancellationToken.Register. The code shows how async locals can be inadvertently stored longer than intended when using singleton caches.\nSOURCE: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#2025-04-16_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections.Concurrent;\n\n// Singleton cache\nvar cache = new NumberCache(TimeSpan.FromHours(1));\n\nvar executionContext = ExecutionContext.Capture();\n\n// Simulate 10000 concurrent requests\nParallel.For(0, 10000, i =>\n{\n    // Restore the initial ExecutionContext per \"request\"\n    ExecutionContext.Restore(executionContext!);\n\n    ChunkyObject.Current = new ChunkyObject();\n\n    cache.Add(i);\n});\n```"
  }
]