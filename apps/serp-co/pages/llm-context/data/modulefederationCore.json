[
  {
    "owner": "module-federation",
    "repo": "core",
    "content": "TITLE: TypeScript Type Definition for Remote Module\nDESCRIPTION: This snippet defines a TypeScript type definition for the virtual path used to reference the remote module. This declaration helps the TypeScript compiler understand the module path (`mfe1/Module`) and avoids compilation errors when referencing the remote module in the Shell application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// decl.d.ts\ndeclare module 'mfe1/Module';\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Federation Remotes - JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to configure remotes within a Module Federation plugin. It defines two remotes, `manifest-provider` and `js-entry-provider`, pointing to different remote applications. `manifest-provider` uses `mf-manifest.json` for dynamic module type hints, resource preloading, and Chrome devtool debugging, while `js-entry-provider` uses `remoteEntry.js`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/remotes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'host',\n      // The `remotes` below defines two remotes, named `manifest-provider` for the project started on port 3011 and `js-entry-provider` for the project started on port 3012\n      remotes: {\n        'manifest-provider':\n          'manifest_provider@http://localhost:3011/mf-manifest.json',\n        'js-entry-provider':\n          'js_entry_provider@http://localhost:3012/remoteEntry.js',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Module Federation Shared Configuration Example\nDESCRIPTION: Demonstrates how to configure the `shared` property within the `ModuleFederationPlugin` in Webpack. It shares `react` and `react-dom` as singleton dependencies, ensuring only one instance of each is loaded.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/shared.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/host',\n  shared: {\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Shared Object Configuration Example\nDESCRIPTION: Illustrates the use of object format for configuring shared dependencies in the `ModuleFederationPlugin`.  This example configures 'react' as a shared dependency with specific settings: `singleton` set to true, `requiredVersion` set to '~18.2.0', and `fixedDependencies` set to true.  This is suitable for complex customization needs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/shared.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/button',\n  shared: {\n    react: {\n      singleton: true,\n      requiredVersion: '~18.2.0',\n      fixedDependencies: true,\n    },\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin with Experiments in TypeScript\nDESCRIPTION: This code snippet demonstrates how to configure the ModuleFederationPlugin with the `experiments` option. It shows how to enable asynchronous startup (`asyncStartup`), use an external runtime (`externalRuntime`), and provide an external runtime (`provideExternalRuntime`). These options control the behavior of module federation in terms of initialization and runtime handling.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/experiments.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/host',\n  experiments: {\n    asyncStartup: true,\n    externalRuntime: false,\n    provideExternalRuntime: false\n  },\n  shared: {\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Webpack Configuration (JavaScript)\nDESCRIPTION: This snippet configures Webpack for the Remote application to enable Module Federation. It uses the `@angular-architects/module-federation/webpack` plugin to define the module's name, exposed modules, and shared dependencies. The `name` property identifies the micro-frontend as `mfe1`. The `exposes` property exposes the `FlightsModule` under the public name `./Module`. The `shared` property uses `shareAll` to share dependencies from the `package.json` file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst { shareAll, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n   name: 'mfe1',\n   exposes: {\n     './Module': './projects/mfe1/src/app/flights/flights.module.ts',\n   },\n   shared: {\n     ...shareAll({ singleton: true, strictVersion: true, requiredVersion: 'auto' }),\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Exposes Configuration (JavaScript)\nDESCRIPTION: Demonstrates how to use the 'exposes' option to define exposed modules within a Module Federation configuration.  It shows mapping expose keys to file paths, which allows other applications to import these modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/exposes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'provider',\n      exposes: {\n        // Note: \"./\" is not supported. Exporting as `.` indicates a default export\n        '.': './src/index.tsx',\n        './add': './src/utils/add.ts',\n        './Button': './src/components/Button.tsx',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Revalidating Server for Hot Reloading in Production\nDESCRIPTION: This code demonstrates how to use the `revalidate` utility from `@module-federation/nextjs-mf/utils` to enable hot reloading of the Node.js server in a production environment. It integrates with the `getInitialProps` lifecycle in `_document.js` to trigger revalidation after the response is sent.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// __document.js\n\nimport { revalidate } from '@module-federation/nextjs-mf/utils';\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    const initialProps = await Document.getInitialProps(ctx);\n\n    // can be any lifecycle or implementation you want\n    ctx?.res?.on('finish', () => {\n      revalidate().then((shouldUpdate) => {\n        console.log('finished sending response', shouldUpdate);\n      });\n    });\n\n    return initialProps;\n  }\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Hook for Orchestrating Language Switching Across Micro-Frontends\nDESCRIPTION: This hook in App A orchestrates language switching across all integrated micro-frontends. It imports the useSwitchAppBLanguage hook from remoteAppB and the appAInstance.  It defines functions to switch languages in App A and App B individually, and a function to switch languages in both applications simultaneously.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport useSwitchAppBLanguage from 'remoteAppB/hooks/useSwitchAppBLanguage';\nimport appAInstance from '../i18n';\n\nconst useSwitchLanguage = () => {\n  const switchAppBLanguageHook = useSwitchAppBLanguage();\n  //Application A\n  const switchAppALanguage = (languageCode) => appAInstance.changeLanguage(languageCode);\n  //Application B\n  const switchAppBLanguage = (languageCode) => switchAppBLanguageHook(languageCode);\n  //Both Applications\n  const switchAllLanguages = (languageCode) => {\n    switchAppALanguage(languageCode);\n    switchAppBLanguage(languageCode);\n  };\n\n  return { switchAppALanguage, switchAppBLanguage, switchAllLanguages };\n};\n\nexport default useSwitchLanguage;\n```\n\n----------------------------------------\n\nTITLE: Register Remote Modules at Runtime (TypeScript)\nDESCRIPTION: This code snippet defines the `registerRemotes` function and related types used for registering remote modules after initialization. It includes the function signature and interface definitions for `Remote`, `RemoteInfoCommon`, `RemoteWithEntry`, and `RemoteWithVersion`. The `force` option allows merging and overriding existing remotes, but using `force: true` is cautioned as it can be risky.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nfunction registerRemotes(remotes: Remote[], options?: { force?: boolean }) {}\n\ntype Remote = (RemoteWithEntry | RemoteWithVersion) & RemoteInfoCommon;\n\ninterface RemoteInfoCommon {\n  alias?: string;\n  shareScope?: string;\n  type?: RemoteEntryType;\n  entryGlobalName?: string;\n}\n\ninterface RemoteWithEntry {\n  name: string;\n  entry: string;\n}\n\ninterface RemoteWithVersion {\n  name: string;\n  version: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration in MFE1\nDESCRIPTION: This code defines the Module Federation configuration for `MFE1` in `module-federation.config.ts`.  It specifies the module name, the remote module (including the URL of the remote entry), and the shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';\n\nexport default createModuleFederationConfig({\n  name: 'host',\n  remotes: {\n    remote: 'remote@http://localhost:3002/remoteEntry.js',\n  },\n  shared: {\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Register ModuleFederationPlugin in Webpack (TS)\nDESCRIPTION: Registers the ModuleFederationPlugin in the webpack.config.js file to enable module federation. This example demonstrates how to configure the plugin with options for `name`, `filename`, `exposes`, and `shared` dependencies. The `publicPath` is set to 'http://localhost:2000/' and the dev server port is configured to 2000.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/webpack.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ModuleFederationPlugin } from '@module-federation/enhanced/webpack';\nmodule.exports = {\n  devServer: {\n    port: 2000,\n  },\n  output: {\n    publicPath: 'http://localhost:2000/', // or auto\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'webpack_provider',\n      filename: 'remoteEntry.js',\n      exposes: {\n        // Set the modules to be exported, default export as '.'\n        './button': './src/components/button',\n      },\n      shared: {\n        react: {\n          singleton: true,\n        },\n        'react-dom': {\n          singleton: true,\n        },\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initialize and Load Remote Modules with Runtime\nDESCRIPTION: This code demonstrates how to initialize the Module Federation runtime and load remote modules without relying on the build plugin.  It uses the `init` function to configure remote modules and the `loadRemote` function to dynamically load them.  It shows how to use aliases and different types of entry points (JavaScript and MJS).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// You can use the runtime to load modules without depending on the build plugin\n// When not using the build plugin, shared dependencies cannot be automatically configured\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: \"@demo/app1\",\n      // mf-manifest.json is a file type generated in the new version of Module Federation build tools, providing richer functionality compared to remoteEntry\n      // Preloading depends on the use of the mf-manifest.json file type\n      entry: \"http://localhost:3005/mf-manifest.json\",\n      alias: \"app1\"\n    },\n    {\n      name: \"@demo/app2\",\n      entry: \"http://localhost:3006/remoteEntry.js\",\n      alias: \"app2\"\n    },\n{\n      name: \"@demo/app4\",\n      entry: \"http://localhost:3006/remoteEntry.mjs\",\n      alias: \"app2\",\n      type: 'module' // tell federation its a certain format, like ESM module\n    },\n  ],\n});\n\n// Load using alias\nloadRemote<{add: (...args: Array<number>)=> number }>(\"app2/util\").then((md)=>{\n  md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: ModuleFederationOptions Type Definition\nDESCRIPTION: This TypeScript code defines the type `ModuleFederationOptions` which is used to configure the Module Federation plugin. It includes properties for `name`, `filename`, `remotes`, and `shared`. These options control various aspects of module federation, such as the module's name, output filename, remote module locations, and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions = {\n  name: string;\n  filename?: string;\n  remotes?: Array<RemoteInfo>;\n  shared?: ShareInfos;\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation for Auth0 Sharing\nDESCRIPTION: This code snippet shows how to configure Module Federation to share the @auth0/auth0-angular package across the shell and micro frontends. This ensures that a single instance of the AuthService is used across the application, facilitating a shared authentication state. The singleton option ensures only one instance is created.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// In webpack.config.js of both shell and micro frontends\n\nmodule.exports = {\n  // existing configuration...\n  shared: share({\n    \"@auth0/auth0-angular\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n    // other shared packages...\n  })\n};\n```\n\n----------------------------------------\n\nTITLE: Exposing Pages via NextFederationPlugin (JS)\nDESCRIPTION: This code snippet demonstrates how to configure the `NextFederationPlugin` to automatically expose all pages in a Next.js application for remote import. By setting `exposePages` to `true` within the `extraOptions`, pages become available to other federated modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/presets.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnew NextFederationPlugin({\n  name: 'remoteApp',\n  filename: '',\n  remotes: {},\n  exposes: {},\n  shared: {},\n  extraOptions: {\n    exposePages: true\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Webpack Configuration with Module Federation\nDESCRIPTION: Configures the Webpack build process for the remote application to expose the `FlightsModule` for consumption by the shell application. The `name` property identifies the microfrontend as `mfe1`. The `exposes` property maps the public name `./Module` to the path of the `FlightsModule`. The `shared` property configures dependency sharing using `shareAll`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst { shareAll, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n   name: 'mfe1',\n   exposes: {\n     './Module': './projects/mfe1/src/app/flights/flights.module.ts',\n   },\n   shared: {\n     ...shareAll({ singleton: true, strictVersion: true, requiredVersion: 'auto' }),\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Remote AppModule Routing Configuration (TypeScript)\nDESCRIPTION: This snippet defines the routing configuration for the `AppModule` in the Remote application. It defines a single route that navigates to the `HomeComponent` when the application is accessed. This is the base routing configuration before the `FlightsModule` is loaded.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const APP_ROUTES: Routes = [\n     { path: '', component: HomeComponent, pathMatch: 'full'}\n ];\n```\n\n----------------------------------------\n\nTITLE: Shell Webpack Configuration (JavaScript)\nDESCRIPTION: This snippet configures Webpack for the Shell application to enable Module Federation.  It uses the `@angular-architects/module-federation/webpack` plugin to define remote modules and shared dependencies. The `remotes` property maps the virtual path `mfe1` to the remote micro-frontend's entry point. The `shared` property uses `shareAll` to share all dependencies from the `package.json` file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { shareAll, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n\n   remotes: {\n     \"mfe1\": \"http://localhost:4201/remoteEntry.js\",\n   },\n\n   shared: {\n     ...shareAll({ singleton: true, strictVersion: true, requiredVersion: 'auto' }),\n   },\n\n});\n```\n\n----------------------------------------\n\nTITLE: Error Handling with errorLoadRemote Hook (Pure Runtime)\nDESCRIPTION: This snippet demonstrates the use of the `errorLoadRemote` hook provided by Module Federation Runtime to handle errors during remote module loading with pure runtime registration.  It defines a fallback plugin that returns a default component when a remote module fails to load.  The `errorLoadRemote` hook is triggered upon loading failures, providing a mechanism to return fallback components or resources, maintaining application stability. This requires `@module-federation/runtime` version 0.8.10 or above.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_2\n\nLANGUAGE: Diff\nCODE:\n```\nimport React from 'react';\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\n+ const fallbackPlugin: () => FederationRuntimePlugin = function () {\n+  return {\n+    name: 'fallback-plugin',\n+    errorLoadRemote(args) {\n+      return { default: () => <div> fallback component </div> };\n+    },\n+  };\n+ };\n\n// Module registration\ninit({\n    name: 'host',\n    remotes: [\n        {\n            name: \"remote1\",\n            alias: \"remote1\"\n            entry: \"http://localhost:2001/mf-manifest.json\",\n        }\n    ],\n    plugins: [\n      RetryPlugin({\n        fetch: {},\n        script: {},\n      }),\n+     fallbackPlugin()\n    ]\n});\n\n// Module loading\nconst Remote1Button = React.lazy(() => loadRemote('remote1/button'));\n\nexport default () => {\n  return (\n    <React.Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1Button />\n    </React.Suspense>\n  );\n}\n\n// Method/function loading\nloadRemote<{add: (...args: Array<number>)=> number }>(\"remote1/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation Implementation in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to configure the `implementation` option within the ModuleFederation plugin.  It sets the implementation to a specific version of `@module-federation/runtime-tools`. This allows the developer to use a custom runtime implementation for module loading and sharing within a federated application. The `require.resolve` function ensures the correct path to the runtime tools is used.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/implementation.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  // ...other configurations\n  plugins: [\n    new ModuleFederation({\n      // ...other Module Federation options\n      implementation: require.resolve('@module-federation/runtime-tools'),\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring withModuleFederation\nDESCRIPTION: This Javascript code snippet demonstrates how to use `withModuleFederation` helper to configure `ModuleFederationConfig` with additional properties such as `dts` and `runtimePlugins`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nwithModuleFederation(config, {\n  dts: false,\n  runtimePlugins: []\n});\n```\n\n----------------------------------------\n\nTITLE: Dynamically Register and Override Remote Modules (TypeScript)\nDESCRIPTION: This example demonstrates how to use `registerRemotes` to add and override remote modules at runtime. It initializes a module with one remote, then adds a new remote and overrides the existing one using the `force` option. Using the `force` option will remove loaded remote cache and can lead to unexpected behaviour.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, registerRemotes } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/register-new-remotes',\n  remotes: [\n    {\n      name: '@demo/sub1',\n      entry: 'http://localhost:2001/mf-manifest.json',\n    },\n  ],\n});\n\n// Add new remote @demo/sub2\nregisterRemotes([\n  {\n    name: '@demo/sub2',\n    entry: 'http://localhost:2002/mf-manifest.json',\n  },\n]);\n\n// Override the previous remote @demo/sub1\nregisterRemotes([\n  {\n    name: '@demo/sub1',\n    entry: 'http://localhost:2003/mf-manifest.json',\n  },\n], { force: true });\n```\n\n----------------------------------------\n\nTITLE: Module Federation Shared Array Configuration Example\nDESCRIPTION: Shows how to configure shared dependencies using an array format within the `ModuleFederationPlugin`.  This example shares the 'react' and 'react-dom' dependencies. This approach is suitable for simple sharing scenarios.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/shared.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/button',\n  shared: ['react', 'react-dom'],\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Include @mf-types for Federation Runtime API type hints\nDESCRIPTION: This snippet configures the TypeScript compiler to include the `@mf-types` directory in the compilation process. This enables type hints and hot reloading for the Federation Runtime API's `loadRemote` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/type-prompt.mdx#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"include\": [\"./@mf-types/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Default Shared Scope in Next.js (TypeScript)\nDESCRIPTION: This TypeScript code defines the default shared scope for Next.js Module Federation.  It specifies which modules (e.g., next/dynamic, react, react-dom) are automatically shared between federated modules, along with their required versions, singleton status, and import settings. This ensures consistent versions and reduces bundle size. The SharedObject type is assumed to be defined elsewhere.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/presets.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const DEFAULT_SHARE_SCOPE: SharedObject = {\n  'next/dynamic': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/head': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/link': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/router': {\n    requiredVersion: false,\n    singleton: true,\n    import: undefined,\n  },\n  'next/image': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/script': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  react: {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/jsx-dev-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'react/jsx-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'styled-jsx': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/style': {\n    singleton: true,\n    import: false,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/css': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: ModuleFederationOptions Type Definition\nDESCRIPTION: TypeScript type definition for the ModuleFederationOptions used in the ModuleFederationPlugin.  It shows the structure of the options object, including name, filename, remotes, and shared properties.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/rspack.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions {\n    name: string;\n    filename?: string,\n    remotes?: Array<RemoteInfo>;\n    shared?: ShareInfos;\n};\n```\n\n----------------------------------------\n\nTITLE: Update bootstrap.tsx\nDESCRIPTION: This code updates the content of `bootstrap.tsx` to render the main App component inside a React StrictMode. It uses `ReactDOM.createRoot` for the new React 18 root API.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n);\n```\n\n----------------------------------------\n\nTITLE: Add Server Lifecycle Method to Next.js Page (JavaScript)\nDESCRIPTION: This snippet demonstrates how to add a server lifecycle method (getServerSideProps or getInitialProps) to a Next.js page. This is necessary to prevent Next.js from attempting to SSG pages that do not have some data lifecycle.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getServerSideProps = async () => {\n  return {\n    props: {}\n  }\n}\n// or\nIndex.getInitialProps = async ()=> {\n  return {}\n}\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Initialize main app\nDESCRIPTION: This command configures the main project for Module Federation, updates Angular CLI configurations, creates a manifest file for loading remote entries, and reorganizes the bootstrap process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project app-micro --type dynamic-host --port 4200\n```\n\n----------------------------------------\n\nTITLE: Configure Next.js MFE1 with NextFederationPlugin (Consume Remote)\nDESCRIPTION: This snippet configures a Next.js application (mfe1) to consume a remote module (mfe2) using the NextFederationPlugin. It defines the module name, filename for the remote entry, and specifies the remotes configuration, mapping 'mfe2' to the URL of the remote entry file. It also configures extra options to expose pages and enable image and URL loader fixes. The webpack configuration is modified to include the NextFederationPlugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { NextFederationPlugin } from '@module-federation/nextjs-mf';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config,options ){\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe1',\n        filename: 'static/chunks/remoteEntry.js',\n        remotes: {\n          mfe2: `http://localhost:3001/static/${options.isServer ? 'ssr' : 'chunks'}/remoteEntry.js`,\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n\nexport default nextConfig;\n```\n\n----------------------------------------\n\nTITLE: NextFederationPlugin Configuration with Extra Options\nDESCRIPTION: This code demonstrates how to configure the NextFederationPlugin with extra options, such as `debug`, `exposePages`, `enableImageLoaderFix`, `enableUrlLoaderFix`, and `skipSharingNextInternals`. These options allow for additional control over the plugin's behavior, like debugging output, automatic page exposure, and asset handling.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nnew NextFederationPlugin({\n  name: '',\n  filename: '',\n  remotes: {},\n  exposes: {},\n  shared: {},\n  extraOptions: {\n    debug: boolean, // `false` by default\n    exposePages: boolean, // `false` by default\n    enableImageLoaderFix: boolean, // `false` by default\n    enableUrlLoaderFix: boolean, // `false` by default\n    skipSharingNextInternals: boolean, // `false` by default\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Caching Strategies Configuration\nDESCRIPTION: Configures caching strategies in `ngsw-config.json` to optimize app performance by defining how assets are cached and updated.  It specifies the files to be cached (including lazy-loaded modules), install modes, and update modes. The example includes configuration for main assets and additional assets.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"main-assets\",\n      \"installMode\": \"prefetch\",\n      \"updateMode\": \"lazy\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/*.css\",\n          \"/main.js\",\n          \"/polyfills.js\",\n          \"/styles.css\",\n          \"/lazy-module-1.js\",\n          \"/lazy-module-2.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"additional-assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(png|jpg|jpeg|svg|gif|webp|woff2|woff|ttf|otf)\"\n        ]\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Remove useless schemas\nDESCRIPTION: This snippet indicates the removal of \"useless schemas\". This change likely cleans up the codebase by removing unnecessary or redundant schema definitions.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Preload Remote Modules with Dependencies and Filters (TypeScript)\nDESCRIPTION: This example demonstrates how to use `preloadRemote` to preload specific remote modules and their dependencies. It showcases filtering resources based on their URL and preloading synchronous and asynchronous resources.  It also shows preloading specific exposes of a remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, preloadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/preload-remote',\n  remotes: [\n    {\n      name: '@demo/sub1',\n      entry: 'http://localhost:2001/mf-manifest.json',\n    },\n    {\n      name: '@demo/sub2',\n      entry: 'http://localhost:2002/mf-manifest.json',\n    },\n    {\n      name: '@demo/sub3',\n      entry: 'http://localhost:2003/mf-manifest.json',\n    },\n  ],\n});\n\n// Preload the @demo/sub1 module\n// Filter out resource information with 'ignore' in the resource name\n// Only preload the sub-dependency @demo/sub1-button module\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub1',\n    filter(assetUrl) {\n      return assetUrl.indexOf('ignore') === -1;\n    },\n    depsRemote: [{ nameOrAlias: '@demo/sub1-button' }],\n  },\n]);\n\n// Preload the @demo/sub2 module\n// Preload all exposes of @demo/sub2\n// Preload synchronous and asynchronous resources of @demo/sub2\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub2',\n    resourceCategory: 'all',\n  },\n]);\n\n// Preload the 'add' expose of the @demo/sub3 module\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub3',\n    resourceCategory: 'all',\n    exposes: ['add'],\n  },\n]);\n```\n\n----------------------------------------\n\nTITLE: Rspack Configuration with Module Federation Plugin and Retry Plugin in Javascript\nDESCRIPTION: This code snippet shows how to integrate the RetryPlugin with the ModuleFederationPlugin in an Rspack configuration using Javascript. It demonstrates how to append the RetryPlugin to the `runtimePlugins` array within the ModuleFederationPlugin options.  The path to the retry plugin is specified, allowing the module federation runtime to utilize the retry logic.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/retry-plugin/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      appendPlugins([\n        new ModuleFederationPlugin({\n          ...,\n+         runtimePlugins: [\n+            path.join(__dirname, './src/runtime-plugin/retry.ts'),\n+         ],\n        }),\n      ]);\n    },\n  },\n  plugins: [pluginReact()],\n});\n```\n\n----------------------------------------\n\nTITLE: Consumer Module Federation config (TS)\nDESCRIPTION: This configuration file (`module-federation.config.ts`) defines the Module Federation settings for the consumer application. It specifies the name of the module, the remotes (mapping `remote` to the provider's manifest URL), and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'consumer',\n  remotes: {\n    remote: 'provider@http://localhost:3006/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin exposes in [modern|rspack|rsbuild|webpack].config.[js,ts] (TS)\nDESCRIPTION: This snippet shows how to configure the `exposes` field in the `ModuleFederationPlugin`. This ensures that federated modules are correctly exposed with keys and values starting with './'. It is necessary to expose module for correct type compilation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/other.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nnew ModuleFederationPlugin({\n    ...\n    // Make sure both key and value start with \"./\"\n    exposes: { './Foo': './src/<path-to-file>/Foo.tsx' },\n    ...\n  })\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Routing configuration update\nDESCRIPTION: This TypeScript snippet demonstrates how to update the application routing (`app-routing.module.ts`) to use `loadRemoteModule` for loading a remote module based on the manifest configuration. It specifies the type, remoteName, and exposedModule.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  ...\n  {\n    path: '',\n    canMatch: [isNotLogged],\n    loadChildren: () =>\n      loadRemoteModule({ type: 'manifest', remoteName: 'login', exposedModule: './Module' }).then(\n        (m) => m.LoginModule,\n      ),\n  },\n  ...\n];\n```\n\n----------------------------------------\n\nTITLE: Module Federation Exposes Configuration (JavaScript)\nDESCRIPTION: Illustrates how to configure the `exposes` option within the Module Federation plugin configuration.  It shows how to map expose keys to specific file paths, making these modules available for consumption by other federated modules. Note that './' indicates a default export.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/exposes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'provider',\n      exposes: {\n        // 注意： 不支持 \"./\"，为 . 导出是表示为 default 默认导出\n        '.': './src/index.tsx',\n        './add': './src/utils/add.ts',\n        './Button': './src/components/Button.tsx',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Next.js next.config.js Configuration for Remote Exposure\nDESCRIPTION: This code snippet shows a `next.config.js` file configured to expose modules from a Next.js application (named 'next2') using the NextFederationPlugin. It defines the name, remotes, filename, exposes, and shared dependencies for the module federation setup. The isServer variable is checked to adjust the remote entry URL.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// next.config.js\n// either from default\nconst NextFederationPlugin = require('@module-federation/nextjs-mf');\n\nmodule.exports = {\n  webpack(config, options) {\n    const { isServer } = options;\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'next2',\n        remotes: {\n          next1: `next1@http://localhost:3001/_next/static/${\n            isServer ? 'ssr' : 'chunks'\n          }/remoteEntry.js`,\n        },\n        filename: 'static/chunks/remoteEntry.js',\n        exposes: {\n          './title': './components/exposedTitle.js',\n          './checkout': './pages/checkout',\n        },\n        shared: {\n          // whatever else\n        },\n      }),\n    );\n\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Remote Component Renderer Directive (Angular)\nDESCRIPTION: This TypeScript snippet defines an Angular structural directive (`RemoteComponentRenderer`) that dynamically creates components within its own view container. It uses the `RemoteModuleLoader` service to load the remote module and obtain the component factory. The directive takes `componentName` and `moduleName` as input to determine which component to render. It uses `ViewContainerRef` to create the component and injects dependencies using the `Injector`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@Directive({\n  selector: '[remoteComponentRenderer]'\n})\nexport class RemoteComponentRenderer implements OnInit {\n  @Input() set remoteComponentRenderer(componentName: string) { /* ... */ }\n  @Input() set remoteComponentRendererModule(moduleName: RemoteModule) { /* ... */ }\n\n  // ... other code\n\n  private async renderComponent() {\n    const module = await this.remoteModuleLoaderService.loadRemoteModule(this._moduleName);\n    const componentFactory = this.remoteModuleLoaderService.getComponentFactory(module[this._componentName]);\n    this.viewContainerRef.createComponent(componentFactory, undefined, this.injector);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy/Async Import with Default Export (React)\nDESCRIPTION: This snippet demonstrates how to import a remote component using `React.lazy` for lazy loading.  It uses `React.Suspense` to handle the loading state.  `next2/sampleComponent` is the remote module being imported. It expects a default export.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-components.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { lazy } from 'react';\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n\nconst FormComponent = ()=>{\n  return (\n    <Suspense fallback=\"loading\">\n      <SampleComponent/>\n    </Suspense>\n  )\n}\n\nexport default FormComponent\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration\nDESCRIPTION: Configures the `rsbuild.config.ts` file to export `export-app.tsx` as an application type module. This uses the `pluginModuleFederation` plugin to define the module name, exposes, and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'remote1',\n      exposes: {\n        './export-app': './src/export-app.tsx',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Lazy-Loading Remote Modules in Routes (Angular)\nDESCRIPTION: This TypeScript snippet demonstrates how to lazy-load remote modules in Angular routing configuration.  The `import()` function is used to dynamically load the remote module, and the `then()` method extracts the module to use in the route's `loadChildren` property.  This allows for loading the remote module only when the associated route is activated.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  {\n    path: '',\n    loadChildren: () => HomeModule\n  },\n  {\n    path: 'contact',\n    loadChildren: () => import('mf1/Contact').then(m => m.ContactModule)\n  },\n  // ... other routes\n];\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration (Typescript)\nDESCRIPTION: Configures module federation using `@module-federation/modern-js`. Defines the module's name, filename for the remote entry, exposed components, and shared dependencies like React and ReactDOM as singletons. This configuration is essential for defining how the module will be exposed and consumed by other applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'dynamic_provider',\n  filename: 'remoteEntry.js',\n  exposes: {\n    './Image': './src/components/Image.tsx',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation Plugin in Webpack\nDESCRIPTION: This snippet demonstrates how to configure the Module Federation plugin in a Webpack configuration file.  It includes the `@module-federation/node/runtimePlugin` within the `runtimePlugins` array of the `ModuleFederationPlugin`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst {ModuleFederationPlugin} = require('@module-federation/enhanced/webpack');\n\nnew ModuleFederationPlugin({\n  // other options\n  runtimePlugins: [\n    require.resolve('@module-federation/node/runtimePlugin')\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationConfig with withModuleFederation\nDESCRIPTION: This Javascript code snippet shows how to use the `withModuleFederation` helper function to configure other properties of the `ModuleFederationConfig`, such as `dts` and `runtimePlugins`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nwithModuleFederation(config, {\n  dts: false,\n  runtimePlugins: []\n});\n```\n\n----------------------------------------\n\nTITLE: Configure next.config.mjs (JavaScript)\nDESCRIPTION: This JavaScript code configures the `next.config.mjs` file to enable Module Federation using the `NextFederationPlugin`. It defines the remote module 'mfe2' and specifies the filename for the remote entry point. It also configures shared modules and enables features like exposing pages, image loader fix, and URL loader fix.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { NextFederationPlugin } from '@module-federation/nextjs-mf';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config,options ){\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe1',\n        filename: 'static/chunks/remoteEntry.js',\n        remotes: {\n          mfe2: `http://localhost:3001/static/${options.isServer ? 'ssr' : 'chunks'}/remoteEntry.js`,\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n\nexport default nextConfig;\n```\n\n----------------------------------------\n\nTITLE: Updating rsbuild.config.ts in MFE1\nDESCRIPTION: This code snippet modifies the `rsbuild.config.ts` file in `MFE1` to include the Module Federation plugin. It imports the `pluginModuleFederation` and the module federation configuration, then adds the plugin to the Rsbuild configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_11\n\nLANGUAGE: diff\nCODE:\n```\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n+ import { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n+ import mfConfig from './module-federation.config';\n\nexport default defineConfig({\n  server: {\n    port: 3001\n  },\n  plugins: [\n    pluginReact(),\n+   pluginModuleFederation(mfConfig)\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Revalidating Module Federation\nDESCRIPTION: This code shows how to use the `revalidate` utility to hot reload a federated application. It imports the function, calls it, and then performs an action (e.g., reloading the server) based on whether a reload is necessary. This helps to refresh the modules from remotes without restarting the server.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { revalidate } from '@module-federation/node/utils';\n\n// we automatically reset require cache, so the reload callback is only if you need to do something else\nrevalidate().then((shouldReload) => {\n  // do something extra after revalidation\n  if (shouldReload) {\n    // reload the server\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Module Loader Service (Angular)\nDESCRIPTION: This TypeScript snippet defines an Angular service (`RemoteModuleLoader`) responsible for dynamically loading remote modules and resolving component factories. It uses the `window` object to access the remote module's scope and retrieves the module factory.  It also uses `ComponentFactoryResolver` to get the component factory for a given component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable({\n  providedIn: 'root'\n})\nexport class RemoteModuleLoader {\n  constructor(private _componentFactoryResolver: ComponentFactoryResolver) {}\n\n  async loadRemoteModule(name: string) {\n    const [scope, moduleName] = name.split('/');\n    const moduleFactory = await window[scope].get('./' + moduleName);\n    return moduleFactory();\n  }\n\n  getComponentFactory(component: Type<unknown>): ComponentFactory<unknown> {\n    return this._componentFactoryResolver.resolveComponentFactory(component);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Remote React Component with Options\nDESCRIPTION: This snippet demonstrates the signature and interface for creating a remote React component using the `createRemoteComponent` function. It defines the `RemoteComponentParams` interface for configuration, including loading the remote module, specifying loading and fallback components, and defining the export name.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n/**\n * Create remote React component\n * @param options - Remote component configuration options\n * @returns Returns a React component that can receive props and render remote component\n */\nfunction createRemoteComponent<T, E extends keyof T = 'default'>(\n  options: RemoteComponentParams<T, E>\n): React.ForwardRefExoticComponent<\n  React.PropsWithoutRef<RemoteComponentProps> & React.RefAttributes<HTMLDivElement>\n>;\n\n/**\n * Remote component configuration parameters\n */\ninterface RemoteComponentParams<\n  T = Record<string, unknown>,\n  E extends keyof T = keyof T\n> {\n  /** \n   * Function to load remote module\n   * Example: () => loadRemote('remote1/export-app') or () => import('remote1/export-app')\n   */\n  loader: () => Promise<T>;\n  \n  /** Component displayed when loading remote module */\n  loading: React.ReactNode;\n  \n  /** Error component displayed when loading or rendering remote module fails */\n  fallback: React.ComponentType<{ error: Error }>;\n  \n  /** \n   * Specify module export name\n   * Default is 'default'\n   */\n  export?: E;\n}\n\n/**\n * Remote component properties\n */\ninterface RemoteComponentProps<T = Record<string, unknown>> {\n  /** Properties passed to remote component */\n  props?: T;\n\n  /** \n   * Memory route configuration, used to control child application routing as memoryRouter\n   * Will not directly display URL in browser address bar\n   */\n  memoryRoute?: { entryPath: string };\n  \n  /** Base path name */\n  basename?: string;\n  \n  /** Style */\n  style?: React.CSSProperties;\n  \n  /** Class name */\n  className?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Coordinating Language Switch - App A\nDESCRIPTION: This code defines a custom hook `useSwitchLanguage` in App A that coordinates language switching across all integrated microfrontends. It imports the `useSwitchAppBLanguage` hook from App B and creates functions to switch languages in both App A and App B. The `switchAllLanguages` function calls both individual language switchers.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport useSwitchAppBLanguage from 'remoteAppB/hooks/useSwitchAppBLanguage';\nimport appAInstance from '../i18n';\n\nconst useSwitchLanguage = () => {\n  const switchAppBLanguageHook = useSwitchAppBLanguage();\n  //Application A\n  const switchAppALanguage = (languageCode) => appAInstance.changeLanguage(languageCode);\n  //Application B\n  const switchAppBLanguage = (languageCode) => switchAppBLanguageHook(languageCode);\n  //Both Applications\n  const switchAllLanguages = (languageCode) => {\n    switchAppALanguage(languageCode);\n    switchAppBLanguage(languageCode);\n  };\n\n  return { switchAppALanguage, switchAppBLanguage, switchAllLanguages };\n};\n\nexport default useSwitchLanguage;\n```\n\n----------------------------------------\n\nTITLE: Load Shared Dependencies with Resolver\nDESCRIPTION: This code demonstrates how to use the `resolver` option with `loadShare` to control which shared dependency version is loaded.  The resolver function allows you to customize the selection logic based on the available shared options. In this example, it prioritizes version '17.0.0' of React if it exists, otherwise it selects the first available shared version.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { init, loadRemote, loadShare } from '@module-federation/runtime';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [],\n  shared: {\n    react: [\n      {\n        version: '17.0.0',\n        scope: 'default',\n        get: async ()=>() => ({ version: '17.0.0' }),\n        shareConfig: {\n          singleton: true,\n          requiredVersion: '^17.0.0',\n        },\n      },\n      {\n        version: '18.0.0',\n        scope: 'default',\n        // pass lib means the shared has loaded\n        lib: () => ({ version: '18.0.0' }),\n        shareConfig: {\n          singleton: true,\n          requiredVersion: '^18.0.0',\n        },\n      },\n    ],\n  },\n});\n\nloadShare('react', {\n   resolver: (sharedOptions) => {\n      return (\n        sharedOptions.find((i) => i.version === '17.0.0') ?? sharedOptions[0]\n      );\n  },\n }).then((reactFactory) => {\n  console.log(reactFactory()); // { version: '17.0.0' }\n});\n```\n\n----------------------------------------\n\nTITLE: Shared Object Interface Definition\nDESCRIPTION: This code snippet defines the interfaces `SharedObject` and `SharedConfig` used to configure shared dependencies in Module Federation. `SharedObject` is a map of shared dependency names to their configuration objects. `SharedConfig` allows fine-grained control over the shared dependency, including singleton behavior, required version, and eager loading.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/shared.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SharedObject {\n  [sharedName: string]: SharedConfig;\n}\n\ninterface SharedConfig {\n  singleton?: boolean;\n  requiredVersion?: string;\n  eager?: boolean;\n  shareScope?: string;\n  import?: string | false;\n}\n```\n\n----------------------------------------\n\nTITLE: Add Module Federation Plugin to Shell (Webpack)\nDESCRIPTION: This TypeScript snippet adds the `ModuleFederationPlugin` to the Webpack configuration for the shell application.  It configures remotes (mapping remote module names to their URLs) and shared dependencies to avoid version conflicts and reduce bundle size. It imports necessary types from `@angular-builders/custom-webpack` and `webpack`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomWebpackBrowserSchema, TargetOptions } from '@angular-builders/custom-webpack';\nimport { Configuration, container } from 'webpack';\n\nexport default (config: Configuration, options: CustomWebpackBrowserSchema, targetOptions: TargetOptions) => {\n  // ... existing configuration\n  config.plugins.push(\n    new container.ModuleFederationPlugin({\n      remotes: {\n        'mf1': 'mf1@http://localhost:4300/mf1.js'\n      },\n      shared: {\n        '@angular/animations': {singleton: true, strictVersion: true},\n        '@angular/core': {singleton: true, strictVersion: true},\n        // ... other shared modules\n      }\n    })\n  );\n\n  return config;\n};\n```\n\n----------------------------------------\n\nTITLE: Revalidate Render Blocking (_document.js)\nDESCRIPTION: This JavaScript code snippet demonstrates how to implement revalidation with render blocking to ensure that remote modules are updated before rendering the page. It uses the `revalidate` function from `@module-federation/nextjs-mf/utils` in `getInitialProps` to check for updates before rendering, preventing hydration errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { revalidate } from '@module-federation/nextjs-mf/utils';\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx?.pathname && !ctx?.pathname?.endsWith('_error')) {\n      await revalidate().then((shouldUpdate) => {\n        if (shouldUpdate) {\n          console.log('Hot Module Replacement (HMR) activated', shouldUpdate);\n        }\n      });\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React ErrorBoundary for Remote Modules (TSX)\nDESCRIPTION: This snippet demonstrates how to use React ErrorBoundary to handle rendering errors in dynamically loaded remote modules. It defines a component that wraps the remote module in a Suspense and ErrorBoundary, providing a fallback UI in case of errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// App.tsx\nimport React, {\n  useRef,\n  useEffect,\n  ForwardRefExoticComponent,\n  Suspense,\n} from 'react';\n\nconst Remote1AppWithLoadRemote = React.lazy(() => loadRemote('remote1/app'));\nconst Remote1AppWithErrorBoundary = React.forwardRef<any, any>((props, ref) => (\n  <ErrorBoundary fallback={<div>Error loading Remote1App...</div>}>\n    <Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1AppWithLoadRemote {...props} ref={ref} />\n      </Suspense>\n    </ErrorBoundary>\n));\n\nexport default function App() {\n  return (\n    <>\n      <div className=\"flex flex-row\">\n        <h2>Remote1</h2>\n        <Remote1AppWithErrorBoundary />\n      </div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Register ModuleFederationPlugin in Rspack config\nDESCRIPTION: This snippet demonstrates how to register the ModuleFederationPlugin in the `rspack.config.js` file. It configures the plugin with a name, exposes a module, and defines shared dependencies.  It also sets the `uniqueName` and `publicPath` options in the output configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { ModuleFederationPlugin } = require('@module-federation/enhanced/rspack');\n\nmodule.exports = {\n  devServer: {\n    port: 2000,\n  },\n  output: {\n    // You need to set a unique value that is not equal to other applications\n    uniqueName: 'federation_provider',\n    // publicPath must be configured if using manifest\n    publicPath: 'http://localhost:2000/',\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'federation_provider',\n      exposes: {\n        './button': './src/button.tsx',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Applying a Runtime Plugin in rspack Configuration (TypeScript)\nDESCRIPTION: This code snippet shows how to apply a custom runtime plugin within an rspack configuration file. It uses the `ModuleFederation` plugin and specifies the path to the custom runtime plugin using `path.resolve`. The `runtimePlugins` array takes an array of paths to the plugin files.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/runtimeplugins.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'host',\n      remotes: {\n        'manifest-provider':\n          'manifest_provider@http://localhost:3011/mf-manifest.json',\n      },\n      runtimePlugins: [path.resolve(__dirname, './custom-runtime-plugin.ts')],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Next.js MFE2 with NextFederationPlugin (Expose Module)\nDESCRIPTION: This snippet configures a Next.js application (mfe2) to expose a module using the NextFederationPlugin. It defines the module name, filename for the remote entry, and specifies which components to expose.  It also configures extra options to expose pages and enable image and URL loader fixes. The webpack configuration is modified to include the NextFederationPlugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config, options) {\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe2',\n        filename: 'static/chunks/remoteEntry.js',\n        exposes: {\n          \"./Button\": './component/Button.js',\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Configure MFE2 Webpack (JavaScript)\nDESCRIPTION: This webpack config exposes the Button component. It defines the module's name, filename, exposes, shared modules, and extra options.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config, options) {\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe2',\n        filename: 'static/chunks/remoteEntry.js',\n        exposes: {\n          \"./Button\": './component/Button.js',\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Setting default options when creating a bridge component (TSX)\nDESCRIPTION: Shows how to configure default `createRoot` options when creating a bridge component for React 18 and 19.  These options are applied to all instances of the component unless overridden during rendering.  This allows for setting consistent root-level configurations like `identifierPrefix` and `onRecoverableError`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  // 为使用此组件的所有实例设置默认 createRoot 选项\n  defaultRootOptions: {\n    identifierPrefix: 'my-app-',\n    onRecoverableError: (error) => {\n      console.error('可恢复的渲染错误:', error);\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Lazy/Async Import with Named Export (React)\nDESCRIPTION: This snippet shows how to import a named export from a remote module using `React.lazy`.  It requires a mocked `default` export to be returned because `React.lazy` expects only default exports. It relies on `next2/sampleComponent` for the remote module and expects a `NamedComponent` export.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-components.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { lazy } from 'react';\n\nconst SampleComponent = lazy(() => import('next2/sampleComponent').then((mod) => {\n  return { default: mod.NamedComponent };\n}));\n\nconst FormComponent = () => {\n  return (\n    <Suspense fallback=\"loading\">\n      <SampleComponent />\n    </Suspense>\n  );\n};\n\nexport default FormComponent;\n```\n\n----------------------------------------\n\nTITLE: Lazy Load Remote Modules in Angular Routing\nDESCRIPTION: This TypeScript snippet demonstrates how to lazy load remote modules in the Angular routing configuration. The `loadChildren` property is used with the `import()` function to load the remote module 'mf1/Contact' when the 'contact' route is navigated to.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  {\n    path: '',\n    loadChildren: () => HomeModule\n  },\n  {\n    path: 'contact',\n    loadChildren: () => import('mf1/Contact').then(m => m.ContactModule)\n  },\n  // ... other routes\n];\n```\n\n----------------------------------------\n\nTITLE: Exposes Configuration Example (ModuleFederationPlugin, JSX)\nDESCRIPTION: This code snippet demonstrates how to configure the `exposes` option within the `ModuleFederationPlugin` to expose modules and entry points.  The `exposes` property defines a mapping of expose keys to module paths. It includes an example using JSX.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'mfButton',\n      exposes: {\n        // Note: \\\"./\\\" is not supported\n        '.': './src/index.tsx',\n        './add': './src/utils/add.ts',\n        './Button': './src/components/Button.tsx',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Loading Remote Module After Initialization (JavaScript)\nDESCRIPTION: This snippet demonstrates loading a remote module using `loadRemote` after the Module Federation runtime has been initialized, potentially with custom remotes.  It retrieves the module specified by 'home/exposedModule' from the configured remotes. Requires that the 'home' remote and 'exposedModule' are properly configured in the `remotes` array during initialization or are pre-existing in the federation setup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/dynamic-remotes.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nloadRemote('home/exposedModule')\n```\n\n----------------------------------------\n\nTITLE: Custom Shared Module Plugin Example in TypeScript\nDESCRIPTION: This code snippet demonstrates a plugin using the `resolveShare` hook to customize shared module resolution. The plugin intercepts requests for the 'react' shared module and manually replaces the local share scope with a reference to the global `window.React` object, ensuring that a specific version of React is used.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst customSharedPlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'custom-shared-plugin',\n    resolveShare(args) {\n      const { shareScopeMap, scope, pkgName, version, GlobalFederation } = args;\n\n      if (pkgName !== 'react') {\n        return args;\n      }\n\n      // set lib\n      args.resolver = function () {\n        shareScopeMap[scope][pkgName][version] = {\n          lib: ()=>window.React,\n          loaded:true,\n          loading: Promise.resolve(()=>window.React)\n        }; // Manually replace the local share scope with the desired module\n        return shareScopeMap[scope][pkgName][version];\n      };\n\n      // set get\n      args.resolver = function () {\n        shareScopeMap[scope][pkgName][version] = {\n          get: async ()=>()=>window.React,\n        }; // Manually replace the local share scope with the desired module\n        return shareScopeMap[scope][pkgName][version];\n      };\n      return args;\n    },\n  };\n};\n\ninit({\n  name: '@demo/app-main',\n  shared: {\n    react: {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => React,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n  },\n  plugins: [customSharedPlugin()],\n});\n\nwindow.React = () => 'Desired Shared';\n\nloadShare('react').then((reactFactory) => {\n  expect(reactFactory()).toEqual(window.React());\n});\n```\n\n----------------------------------------\n\nTITLE: Modify Script Attributes with createScript Hook (TypeScript)\nDESCRIPTION: Demonstrates how to use the `createScript` hook to modify attributes of script elements before they are added to the DOM. It shows how to add custom attributes and set crossorigin attribute, allowing for customization of the script loading process for remote modules. It imports the necessary types from `@module-federation/enhanced/runtime`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'change-script-attribute',\n    createScript({ url, attrs }) {\n      if (url === testRemoteEntry) {\n        let script = document.createElement('script');\n        script.src = testRemoteEntry;\n        // can modify the attrs object\n        attrs['loader-hooks'] = 'isTrue';\n        // or add them to the script\n        script.setAttribute('crossorigin', 'anonymous');\n        return script;\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation Package\nDESCRIPTION: This command installs the `@module-federation/enhanced` package, which provides the runtime APIs for Module Federation.  This package is required to use the runtime features for dynamic module loading and shared dependency management.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm add @module-federation/enhanced --save\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add @module-federation/enhanced --save\n```\n\nLANGUAGE: Shell\nCODE:\n```\npnpm add @module-federation/enhanced --save\n```\n\nLANGUAGE: Shell\nCODE:\n```\nbun add @module-federation/enhanced --save\n```\n\n----------------------------------------\n\nTITLE: Updating rsbuild.config.ts in MFE2\nDESCRIPTION: This code snippet modifies the `rsbuild.config.ts` file in `MFE2` to include the Module Federation plugin. It imports the `pluginModuleFederation` and the module federation configuration, then adds the plugin to the Rsbuild configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n+ import { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n+ import mfConfig from './module-federation.config';\n\nexport default defineConfig({\n  server: {\n    port: 3002\n  },\n  plugins: [\n    pluginReact()\n+   pluginModuleFederation(mfConfig)\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Workbox as Shared Module with Module Federation\nDESCRIPTION: This snippet demonstrates how to configure Workbox as a shared module within the Module Federation plugin in Webpack. This allows federated modules to access and utilize the Workbox service worker. The `singleton: true` option ensures only one instance is used, and `requiredVersion` specifies the expected Workbox version.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      // Other Module Federation settings\n      shared: {\n        // Share Workbox configuration as a module\n        'workbox-webpack-plugin': {\n          singleton: true,\n          requiredVersion: 'your-workbox-version'\n        }\n      }\n    })\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: createBridgeComponent Type Definition - TSX\nDESCRIPTION: Defines the type signature for the `createBridgeComponent` function from `@module-federation/bridge-vue3`. This function creates a bridge that allows a Vue V3 application to be exposed as a module in a module federation setup. It takes an object with a `rootComponent` and an optional `appOptions` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction createBridgeComponent(bridgeInfo: {\n  rootComponent: VueComponent;\n  appOptions?: (params: {\n    app: Vue.App<VueComponent>;\n    basename?: string;\n    memoryRoute?: { entryPath: string };\n    [key: string]: any;\n  }) => { router?: Router } | void;\n}): () => {\n  render(info: {\n    name?: string;\n    basename?: string;\n    memoryRoute?: {\n      entryPath: string;\n    };\n    dom?: HTMLElement;\n  }): void;\n  destroy(info: {\n    dom: HTMLElement;\n  }): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the Host Application with Development Remotes for Live Updates\nDESCRIPTION: This command enhances the `npx nx serve-ssr dashboard` command by adding the `--devRemotes=login` flag. This flag ensures that the server rebuilds the 'login' application whenever changes are detected, allowing for real-time updates during development.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve-ssr dashboard --devRemotes=login\n```\n\n----------------------------------------\n\nTITLE: Client-Side Only Remote Module Loading (React)\nDESCRIPTION: This snippet demonstrates how to load a remote module only on the client-side. It uses a conditional check for `typeof window === 'undefined'` to prevent server-side rendering errors. It also utilizes `useState` and `useEffect` to ensure the component is only rendered after the component is mounted.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-components.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport {lazy, Suspense, useEffect, useState} from 'react';\n\nconst RemoteModule = typeof window === 'undefined' ? ()=>{} : lazy(() => import('app3/sampleComponent'));\n\nconst ClientOnly = ({Component}) => {\n  const [mounted, setMount] = useState(false);\n  useEffect(() => {\n    setMount(true);\n  }, []);\n  if (!mounted) return null;\n  return (\n    <Suspense fallback=\"loading\">\n      <Component />\n    </Suspense>\n  );\n};\n\nconst App = ()=>{\n  return <ClientOnly Component={RemoteModule} />\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Hook to Determine Remote Execution\nDESCRIPTION: This custom hook, `useIsRemote`, determines if the current application is running in standalone mode or embedded within another application. It checks for URL parameters or DOM presence to differentiate between the two environments. This allows conditional rendering of components based on the application's context.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useEffect, useState } from 'react';\n\n/**\n * Determines if the current application is running as a remote (embedded)\n * or as a standalone application.\n *\n * You should adapt the logic based on the specific criteria that apply to your application's\n * architecture, such as checking for specific URL parameters or the presence\n * of a particular DOM element that would only exist when embedded.\n */\nconst useIsRemote = () => {\n  const [isRemote, setIsRemote] = useState(false);\n\n  useEffect(() => {\n    // Check for a URL parameter that indicates embedding\n    const searchParams = new URLSearchParams(window.location.search);\n    setIsRemote(searchParams.has('embedded'));\n\n    // Alternatively, check for a global variable or a specific DOM element\n    // setIsRemote(window.parent !== window || document.getElementById('embed-flag') !== null);\n  }, []);\n\n  return isRemote;\n};\n\nexport default useIsRemote;\n```\n\n----------------------------------------\n\nTITLE: Angular Routing Module Configuration\nDESCRIPTION: This TypeScript code defines the routing configuration for an Angular application. It uses lazy loading and route guards to manage access to different modules based on the user's authentication status, enhancing performance and security.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { isLogged } from './shared/auth/is-logged.guard';\nimport { isNotLogged } from './shared/auth/is-not-logged.guard';\n\nconst routes: Routes = [\n  {\n    path: '',\n    canMatch: [isLogged],\n    loadChildren: () =>\n      import('./features/dashboard/dashboard.module').then((m) => m.DashboardModule),\n  },\n  {\n    path: '',\n    canMatch: [isNotLogged],\n    loadChildren: () => import('./features/login/login.module').then((m) => m.LoginModule),\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n----------------------------------------\n\nTITLE: Generating a host application with remotes\nDESCRIPTION: This command generates a host (shell) application named 'shop' in the 'apps/' directory and also generates three remote applications: 'products', 'cart', and 'checkout'. It uses the `@nx/react:host` generator with the `--remotes` option.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g @nx/react:host apps/shop --remotes=products,cart,checkout\n```\n\n----------------------------------------\n\nTITLE: Defining ModuleFederationOptions Type with TypeScript\nDESCRIPTION: This code defines the `ModuleFederationOptions` type using TypeScript, which is the central configuration object for Module Federation. It specifies various options such as the name of the module federation, the filename for the remote entry, remotes, exposes, shared dependencies, and other plugin-related configurations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions = {\n  // Name for module federation\n  name: string;\n  // Name for the remoteEntry file\n  filename?: string;\n  // Configuration for remote modules and entry information in module federation\n  remotes?: Array<RemoteInfo>;\n  // module federation expose module information\n  exposes?: PluginExposesOptions;\n  // Shared dependency configuration\n  shared?: ShareInfos;\n  // Dynamic publicPath\n  getPublicPath?: string;\n  // Runtime plugins\n  runtimePlugins?: Array<string>;\n  // The runtime implementation to use\n  implementation?: string;\n  // manifest configuration\n  manifest?: boolean | PluginManifestOptions;\n  // control page liveReload and types hot reload\n  dev?: boolean | PluginDevOptions;\n  // control types\n  dts?: boolean | PluginDtsOptions;\n  // Use a virtual runtime entrypoint instead of writing a temporary file to disk\n  virtualRuntimeEntry?: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Okta in Angular Module\nDESCRIPTION: This code snippet configures the `OktaAuthModule` with the necessary Okta settings, including the issuer, client ID, redirect URI, and scopes. Replace `{yourOktaDomain}` and `{yourClientID}` with your actual Okta domain and client ID. This configuration allows the Angular application to communicate with the Okta authentication server.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { OKTA_CONFIG, OktaAuthModule } from '@okta/okta-angular';\nimport { OktaAuth } from '@okta/okta-auth-js';\n\nconst oktaAuth = new OktaAuth({\n  issuer: 'https://{yourOktaDomain}/oauth2/default',\n  clientId: '{yourClientID}',\n  redirectUri: window.location.origin + '/login/callback',\n  scopes: ['openid', 'profile', 'email']\n});\n\n@NgModule({\n  imports: [\n    OktaAuthModule,\n    // other imports\n  ],\n  providers: [\n    { provide: OKTA_CONFIG, useValue: { oktaAuth } }\n  ],\n  // other module properties\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Public Path in Rspack\nDESCRIPTION: This snippet demonstrates how to configure a dynamic `publicPath` in a Module Federation setup using the `getPublicPath` option within the `ModuleFederation` plugin configuration in `rspack.config.ts`. The `getPublicPath` option allows setting a dynamic public path for remote module resources based on the return value of a function executed using `new Function`. The function's return value is used as the `publicPath` prefix for the module's static resources. The function must be represented as a string.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/getpublicpath.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'provider',\n      exposes: {\n        './Button': './src/components/Button.tsx',\n      },\n      // ...\n      getPublicPath: `function() {return \\\"https:\" + window.navigator.cdn_host + \\\"/resource/app/\\\"}`,      \n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Paths for Module Federation Types\nDESCRIPTION: JSON snippet for configuring the `paths` compiler option in `tsconfig.json`.  This allows TypeScript to resolve types from the producers, using the `@mf-types` directory.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Shared Dependencies in Module Federation\nDESCRIPTION: This TypeScript code defines the default shared dependencies for Module Federation in Next.js. It includes packages like `next/dynamic`, `next/head`, `next/link`, `next/router`, `next/image`, `next/script`, `react`, `react-dom`, and `styled-jsx`, configuring them as singletons and specifying required versions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport const DEFAULT_SHARE_SCOPE: SharedObject = {\n  'next/dynamic': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/head': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/link': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/router': {\n    requiredVersion: false,\n    singleton: true,\n    import: undefined,\n  },\n  'next/image': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/script': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  react: {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/jsx-dev-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'react/jsx-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'styled-jsx': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/style': {\n    singleton: true,\n    import: false,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/css': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Rsbuild Library for Module Federation\nDESCRIPTION: Configures an Rsbuild library to expose modules using Module Federation. It sets the output format to 'mf', configures the output path and asset prefix, defines exposes ('.' pointing to './src/index.tsx'), and declares shared dependencies (react, react-dom) as singletons. The module federation name is set to 'rslib_provider'.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/rsbuild-plugin/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rslib/core';\n\nexport default defineConfig({\n  lib: [\n    // ...\n    {\n      format: 'mf',\n      output: {\n        distPath: {\n          root: './dist/mf',\n        },\n        assetPrefix: 'http://localhost:3001/mf',\n      },\n      plugins: [\n        // ...\n        pluginModuleFederation({\n          name: 'rslib_provider',\n          exposes: {\n            '.': './src/index.tsx',\n          },\n          shared: {\n            react: {\n              singleton: true,\n            },\n            'react-dom': {\n              singleton: true,\n            },\n          },\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Angular Library Build (models)\nDESCRIPTION: This command uses the Angular CLI to build the 'models' library. Building the library resolves TypeScript errors that occur because the library hasn't been compiled, allowing correct referencing of the '@@models' path alias.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nng build models\n```\n\n----------------------------------------\n\nTITLE: Register Rsbuild Plugin in Rslib Module (TypeScript)\nDESCRIPTION: This code snippet illustrates how to register the `@module-federation/rsbuild-plugin` within an Rslib Module configuration file.  It configures Module Federation with a specified name, exposes, and shared dependencies, specifically marking 'react' and 'react-dom' as singletons. The output path is set to `./dist/mf`, and an asset prefix is defined.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/rsbuild.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rslib/core';\n\nexport default defineConfig({\n  lib: [\n    // ...\n    {\n      format: 'mf',\n      output: {\n        distPath: {\n          root: './dist/mf',\n        },\n        assetPrefix: 'xxx',\n      },\n      plugins: [\n        // ...\n        pluginModuleFederation({\n          name: 'rslib_provider',\n          exposes: {\n            '.': './src/index.tsx',\n          },\n          shared: {\n            react: {\n              singleton: true,\n            },\n            'react-dom': {\n              singleton: true,\n            },\n          },\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Integrate Federation Runtime with Webpack\nDESCRIPTION: This code snippet demonstrates how to integrate the module federation runtime with webpack.  It imports the federation object and mounts it to the webpack require function and its function 'f' property for remotes and consumes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/webpack-bundler-runtime/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport federation from '@module-federation/webpack-bundler-runtime';\n\n__webpack_require__.federation = federation;\n\n__webpack_require__.f.remotes = __webpack_require__.federation.remotes(options);\n__webpack_require__.f.consumes = __webpack_require__.federation.remotes(options);\n```\n\n----------------------------------------\n\nTITLE: Clearing Express Routes for Hot Reloading\nDESCRIPTION: This JavaScript code demonstrates how to clear Express.js routes during hot reloading. It defines a global function `clearRoutes` that filters the Express router stack to remove routes with defined paths. This is used in conjunction with revalidate to update the application with new routes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n//express.js\nconst app = express();\n\nglobal.clearRoutes = () => {\n  app._router.stack = app._router.stack.filter((k) => !(k && k.route && k.route.path));\n};\n\n// in some other file (within the scope of webpack build)\n// wherever you have your revalidation logic\nrevalidate().then((shouldReload) => {\n  if (shouldReload) {\n    global.clearRoutes();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: UniversalFederationPlugin Usage Example\nDESCRIPTION: This example demonstrates a webpack configuration utilizing the UniversalFederationPlugin. It conditionally sets the target based on whether it's for a server or web environment. It configures the plugin with a name, library type, server status, remotes, filename, runtime plugins, and exposed modules.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { UniversalFederationPlugin } = require('@module-federation/node');\n\nconst config = {\n  target: isServer ? false : 'web',\n  plugins: [\n    new UniversalFederationPlugin({\n      name: 'website2',\n      library: { type: 'commonjs-module' },\n      isServer: true, // or false\n      remotes: {},\n      filename: 'remoteEntry.js',\n      useRuntimePlugin: true, // uses the module-federation/enhanced runtime plugins\n      exposes: {\n        './SharedComponent': './remoteServer/SharedComponent',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Load Remote Modules with Alias or Name\nDESCRIPTION: This JavaScript code demonstrates how to load remote modules using either the remote name or its alias after initializing the Module Federation runtime.  It calls `loadRemote` with either the remote name or alias combined with the exposed module path.  It loads and then executes the function `add` that is exposed from the remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [\n    {\n      name: '@demo/app2',\n      alias: 'app2',\n      entry: 'http://localhost:3006/remoteEntry.js',\n    },\n  ],\n});\n\n// remoteName + expose\nloadRemote('@demo/app2/util').then((m) => m.add(1, 2, 3));\n\n// alias + expose\nloadRemote('app2/util').then((m) => m.add(1, 2, 3));\n```\n\n----------------------------------------\n\nTITLE: PluginExposesOptions Interface (TypeScript)\nDESCRIPTION: Defines the structure for configuring exposed modules in Module Federation. It specifies that exposeKey can be mapped to a string (file path) or an ExposesConfig object.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/exposes.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginExposesOptions {\n  [exposeKey: string]: string | ExposesConfig;\n}\n\ninterface ExposesConfig {\n  // File entry\n  import: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Shared Object Type Definition\nDESCRIPTION: Defines the types for the `shared` configuration object. `PluginSharedOptions` can be either an array of strings or a `SharedObject`. `SharedObject` is a map of shared module names to `SharedConfig` objects. `SharedConfig` allows configuration of properties like `singleton`, `requiredVersion`, `eager`, `shareScope`, and `import`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/shared.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype PluginSharedOptions = string[] | SharedObject;\n\ninterface SharedObject {\n  [sharedName: string]: SharedConfig;\n}\n\ninterface SharedConfig {\n  singleton?: boolean;\n  requiredVersion?: string;\n  eager?: boolean;\n  shareScope?: string;\n  import?: string | false;\n}\n```\n\n----------------------------------------\n\nTITLE: NativeFederationTypeScriptHost Configuration\nDESCRIPTION: This configuration object shows the available options for the `NativeFederationTypeScriptHost` plugin. It requires `moduleFederationConfig`, the same configuration provided to the module federation plugin. It also accepts optional configurations such as `typesFolder`, `deleteTypesFolder`, and `maxRetries`.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    moduleFederationConfig: any; // the configuration same configuration provided to the module federation plugin, it is MANDATORY\n    typesFolder?: string; // folder where all the files will be stored, default is '@mf-types',\n    deleteTypesFolder?: boolean; // indicate if the types folder will be deleted before the job starts, default is 'true'\n    maxRetries?: number; // The number of times the plugin will try to download the types before failing, default is 3\n}\n```\n\n----------------------------------------\n\nTITLE: Defining remotes in ModuleFederationConfig\nDESCRIPTION: This Javascript code snippet shows how to define remote applications used by the shell (host) using the `remotes` option in the `ModuleFederationConfig`.  You can provide an array of Nx project names, or a tuple, defining the Nx project name, and the entry location for the remote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nremotes: [\"products\", [\"cart\", \"http://my-live-cart.myapp.com/mf-manifest.json\"]] \n```\n\n----------------------------------------\n\nTITLE: Vite Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Vite.  It shows how to add the plugins to the Vite configuration, set up a proxy to serve the zip file correctly and configure the file system access to allow access to the dist folder.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.ts\nimport { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } from '@module-federation/native-federation-typescript/vite';\n\nexport default defineConfig({\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n  /* ... */\n  server: {\n    // This is needed to emulate the devServer.static.directory of WebPack and correctly serve the zip file\n    /* ... */\n    proxy: {\n      '/@mf-types.zip': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,\n        rewrite: () => `/@fs/${process.cwd()}/dist/@mf-types.zip`,\n      },\n    },\n    fs: {\n      /* ... */\n      allow: ['./dist'],\n      /* ... */\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin in rspack.config.js\nDESCRIPTION: Example of configuring the ModuleFederationPlugin in the rspack.config.js file. This involves setting the name, exposes, and shared properties to define the module federation configuration.  It also configures the devServer and output options, including uniqueName and publicPath.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/rspack.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { ModuleFederationPlugin } = require('@module-federation/enhanced/rspack');\n\nmodule.exports = {\n  devServer: {\n    port: 2000,\n  },\n  output: {\n    // 需要设置一个唯一值，不能和其他应用相等\n    uniqueName: 'federation_provider',\n    // 使用 manifest 必须要配置 publicPath\n    publicPath: 'http://localhost:2000/',\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'federation_provider',\n      exposes: {\n        './button': './src/button.tsx',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Triggering Express.js Route Cache Clear During Revalidation (JSX)\nDESCRIPTION: This code snippet shows how to trigger the `clearRoutes` global callback within the `_document.js` file of a Next.js application.  This clears the Express route cache during the `getInitialProps` lifecycle method if `revalidate()` returns `true`, indicating that the routes should be updated. This ensures that after revalidation, the Express server serves the latest routes without requiring a full server restart. It requires the `Document`, `Html`, `Head`, `Main`, and `NextScript` components from `next/document`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/express.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx?.pathname && !ctx?.pathname?.endsWith('_error')) {\n      await revalidate().then((shouldUpdate) => {\n        if (shouldUpdate) {\n          global.clearRoutes();\n        }\n      });\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Options Type Definition (TS)\nDESCRIPTION: Defines the TypeScript type `ModuleFederationOptions`, which outlines the structure for configuring the Module Federation plugin. It includes properties such as `name` (a string), `filename` (an optional string), `remotes` (an optional array of `RemoteInfo`), and `shared` (an optional `ShareInfos`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/webpack.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions = {\n  name: string;\n  filename?: string;\n  remotes?: Array<RemoteInfo>;\n  shared?: ShareInfos;\n};\n```\n\n----------------------------------------\n\nTITLE: Registering Remote Modules Dynamically\nDESCRIPTION: Example illustrating how to register remote modules dynamically after initialization using the `registerRemotes` function.  It demonstrates adding a new remote and overriding an existing remote. Note the warning about using `force: true` as it can lead to unexpected behavior.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, registerRemotes } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/register-new-remotes',\n  remotes: [\n    {\n      name: '@demo/sub1',\n      entry: 'http://localhost:2001/mf-manifest.json',\n    },\n  ],\n});\n\n// 添加新的远程 @demo/sub2\nregisterRemotes([\n  {\n    name: '@demo/sub2',\n    entry: 'http://localhost:2002/mf-manifest.json',\n  },\n]);\n\n// 覆盖以前的远程 @demo/sub1\nregisterRemotes([\n  {\n    name: '@demo/sub1',\n    entry: 'http://localhost:2003/mf-manifest.json',\n  },\n], { force: true });\n```\n\n----------------------------------------\n\nTITLE: Dynamic Remote Loading (Typescript JSX)\nDESCRIPTION: Consumes the data loaded by the Data Loader and dynamically loads module federation remotes. It uses `createRemoteSSRComponent`, `loadRemote`, and `registerRemotes` from `@modern-js/runtime/mf` to achieve this. The `registerRemotes` function registers the remotes before they are loaded. It also includes fallback components to handle loading errors and cases where the remote does not exist.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_5\n\nLANGUAGE: typescript jsx\nCODE:\n```\nimport { createRemoteSSRComponent, loadRemote, registerRemotes } from '@modern-js/runtime/mf';\n// Use import type to get data loader types\nimport type { DataLoaderRes } from './page.data';\nimport { useLoaderData } from '@modern-js/runtime/router';\n\nimport './index.css';\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  loader: () => import('remote/Image'),\n  loading: 'loading...',\n  export: 'default',\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Index = () => {\n  // get data loader response\n  const dataLoader = useLoaderData() as DataLoaderRes;\n  // register dynamic remotes before loading them\n  registerRemotes(dataLoader.providerList);\n\n  const DynamicRemoteSSRComponents = dataLoader.providerList.map(item => {\n    const { id } = item;\n    const Com = createRemoteSSRComponent({\n      loader: () => loadRemote(id),\n      loading: 'loading...',\n      fallback: ({ error }) => {\n        if (error instanceof Error && error.message.includes('not exist')) {\n          return <div>fallback - not existed id</div>;\n        }\n        return <div>fallback</div>;\n      },\n    });\n    return <Com />\n  })\n  return (\n    <div className=\"container-box\">\n      <RemoteSSRComponent />\n      {DynamicRemoteSSRComponents}\n    </div>\n  );\n}\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Registering RetryPlugin in Rsbuild Build Plugin (diff)\nDESCRIPTION: This code snippet demonstrates how to register the RetryPlugin within the Rsbuild build plugin configuration. The plugin is added to the `runtimePlugins` array within the `pluginModuleFederation` configuration. This ensures the retry mechanism is available as early as possible during application startup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/retry-plugin.mdx#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      ...,\n+     runtimePlugins: [\n+       path.join(__dirname, './src/runtime-plugin/retry.ts'),\n+     ],\n    }),\n  ],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Adjusting Webpack Configuration for Module Exposure\nDESCRIPTION: This JavaScript snippet configures the `exposes` property in the `webpack.config.js` file for the remote application. It specifies which modules should be exposed for remote loading. The `./Module` key maps to the path of the module in the remote application (e.g., `login.module.ts`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexposes: {\n  './Module': './projects/login/src/app/feature/login/login.module.ts',\n},\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Configuration (Runtime Plugin)\nDESCRIPTION: This snippet showcases the configuration of the ModuleFederationPlugin with runtime plugins for an async-node target. It specifies the chunk filename, exposes nothing, defines a remote, and utilizes the @module-federation/node runtime plugin. This configuration uses the enhanced module federation API.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { ModuleFederationPlugin } = require('@module-federation/enhanced');\n\nconst options = {\n  target: 'async-node',\n  output: {\n    chunkFilename: '[id]-[chunkhash].js', // important to hash chunks\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      exposes: {},\n      remotes: {\n        app2: 'app2@http://',\n      },\n      runtimePlugins: [require.resolve('@module-federation/node/runtimePlugin')],\n      remoteType: 'script',\n      library: { type: 'commonjs-module', name: 'app1' },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Federation in module-federation.config.ts (TypeScript)\nDESCRIPTION: Example configuration for Module Federation in `module-federation.config.ts`.  It defines the `name`, `remotes`, and `shared` dependencies.  `createModuleFederationConfig` is used to generate a compatible config object. The `remotes` property specifies the location of the remote's manifest file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\nexport default createModuleFederationConfig({\n  name: 'host',\n  remotes: {\n    remote: 'remote@http://localhost:3006/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Module Federation with Custom Remotes (JavaScript)\nDESCRIPTION: This snippet shows how to initialize the Module Federation runtime with a custom remote not known at build time, using the `init` function from `@module-federation/runtime`. It defines a remote named 'home' with a specified entry point.  The `force: true` option may be necessary when sideloading remotes after the initial setup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/dynamic-remotes.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\ninit({\n  name: 'hostname',\n  remotes: [\n    {\n      name: 'home',\n      entry: 'http://somthing.com/remoteEntry.js'\n    }\n  ],\n  force: true // may be needed to sideload remotes after the fact.\n})\n```\n\n----------------------------------------\n\nTITLE: RetryPlugin Configuration with Custom Script Creation in Typescript\nDESCRIPTION: This code snippet demonstrates how to configure the RetryPlugin in Typescript with fallback URLs for failed fetches and a custom function for creating script elements. The `customCreateScript` function is used to modify the script element before it is added to the DOM, allowing for the addition of custom attributes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/retry-plugin/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RetryPlugin } from '@module-federation/retry-plugin';\nconst retryPlugin = () => RetryPlugin({\n    fetch: {\n        url: 'http://localhost:2008/not-exist-mf-manifest.json',\n        fallback: () => 'http://localhost:2001/mf-manifest.json',\n    },\n    script: {\n        // url: 'http://localhost:2008/not-exist-mf-manifest.json',\n        url: 'http://localhost:2001/static/js/async/src_App_tsx.js',\n        customCreateScript: (url: string, attrs: Record<string, string>) => {\n            let script = document.createElement('script');\n            script.src = `http://localhost:2011/static/js/async/src_App_tsx.js`;\n            script.setAttribute('loader-hoos', 'isTrue');\n            script.setAttribute('crossorigin', 'anonymous');\n            return script;\n        },\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin experiments in TypeScript\nDESCRIPTION: This code snippet demonstrates how to configure the `experiments` option in the `ModuleFederationPlugin`. It shows how to enable experimental features like `asyncStartup`, `externalRuntime`, and `provideExternalRuntime`. The snippet also includes a basic shared modules configuration for `react` and `react-dom`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/experiments.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/host',\n  experiments: {\n    asyncStartup: true,\n    externalRuntime: false,\n    provideExternalRuntime: false\n  },\n  shared: {\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Using ErrorBoundary with Dynamic Module Import\nDESCRIPTION: This snippet demonstrates how to use React's ErrorBoundary with dynamic module imports (lazy loading) to handle component-level errors. It wraps the dynamically loaded remote module within ErrorBoundary and Suspense components to provide a graceful fallback in case of errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// App.tsx\nimport React, {\n  useRef,\n  useEffect,\n  ForwardRefExoticComponent,\n  Suspense,\n} from 'react';\n\nconst Remote1AppWithLoadRemote = React.lazy(() => loadRemote('remote1/app'));\nconst Remote1AppWithErrorBoundary = React.forwardRef<any, any>((props, ref) => (\n  <ErrorBoundary fallback={<div>Error loading Remote1App...</div>}>\n    <Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1AppWithLoadRemote {...props} ref={ref} />\n      </Suspense>\n    </ErrorBoundary>\n));\n\nexport default function App() {\n  return (\n    <>\n      <div className=\"flex flex-row\">\n        <h2>Remote1</h2>\n        <Remote1AppWithErrorBoundary />\n      </div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: UniversalFederationPlugin Configuration\nDESCRIPTION: This code shows how to use the UniversalFederationPlugin with settings for server-side rendering. It defines the plugin's name, library type, indicates it's for the server, specifies remotes, filename, enables the runtime plugin, and exposes a shared component.  It simplifies configuration for both browser and server builds.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew UniversalFederationPlugin({\n  name: 'website2',\n  library: { type: 'commonjs-module' },\n  isServer: true, // or false\n  remotes: {},\n  filename: 'remoteEntry.js',\n  useRuntimePlugin: true, // uses the module-federation/enhanced runtime plugin api\n  exposes: {\n    './SharedComponent': './remoteServer/SharedComponent',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Retry Plugin at Runtime - Javascript\nDESCRIPTION: This snippet demonstrates how to register the RetryPlugin in a Module Federation runtime environment to automatically retry failed resource requests. It includes the necessary imports, plugin registration within the init function, and dynamic module loading using React.lazy and loadRemote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nimport React from 'react';\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n+ import { RetryPlugin } from '@module-federation/retry-plugin';\n\n// 模块注册\ninit({\n    name: 'host',\n    remotes: [\n        {\n            name: \"remote1\",\n            alias: \"remote1\"\n            entry: \"http://localhost:2001/mf-manifest.json\",\n        }\n    ],\n+   plugins: [\n+     RetryPlugin({\n+       fetch: {},\n+       script: {},\n+     }),\n    ]\n});\n\n// 模块加载\nconst Remote1Button = React.lazy(() => loadRemote('remote1/button'));\n\nexport default () => {\n  return (\n    <React.Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1Button />\n    </React.Suspense>\n  );\n}\n\n// 方法/函数加载\nloadRemote<{add: (...args: Array<number>)=> number }>(\"remote1/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: Exposing Next.js Pages with Module Federation (JavaScript)\nDESCRIPTION: This JavaScript code demonstrates how to automatically expose all pages in a Next.js application using the NextFederationPlugin. By setting `exposePages` to `true` within the `extraOptions`, the plugin configures the application to allow importing pages from the remote application, such as 'remoteApp/pages/index'. Requires NextFederationPlugin to be installed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/presets.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnew NextFederationPlugin({\n  name: 'remoteApp',\n  filename: '',\n  remotes: {},\n  exposes: {},\n  shared: {},\n  extraOptions: {\n    exposePages: true\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Configuration with exposes\nDESCRIPTION: This code snippet shows the configuration of the ModuleFederationPlugin with two exposes: '.' and './Button'. The exposes define the modules that are available for remote consumption. The file paths associated with each expose indicate the entry point for that module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  exposes: {\n    '.': './src/index.tsx',\n    './Button': './src/Button.tsx',\n  },\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Optimizing Dependency Sharing with Webpack Share (JavaScript)\nDESCRIPTION: This snippet demonstrates how to optimize dependency sharing by explicitly specifying shared packages using the `share` helper instead of `shareAll`. This allows for finer control over which dependencies are shared between the Shell and Remote applications, potentially reducing bundle sizes.  The `singleton`, `strictVersion` and `requiredVersion` options are used to manage shared dependency versions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n// Replace shareAll with share:\nconst { share, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n    // Specify the packages to share:\n    shared: share({\n        \"@angular/core\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/common\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/common/http\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/router\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n    })\n});\n```\n\n----------------------------------------\n\nTITLE: Loading Remote Module with Module Federation Runtime (JavaScript)\nDESCRIPTION: This snippet demonstrates loading a remote module using the `loadRemote` function from the `@module-federation/runtime` library.  It assumes the remote 'home/exposedModule' is already configured within the module federation setup. The function asynchronously fetches and initializes the specified module, making its exports available.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/dynamic-remotes.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { loadRemote, init } from '@module-federation/runtime';\n// if i have remotes in my federation plugin, i can pass the name of the remote\nloadRemote('home/exposedModule')\n```\n\n----------------------------------------\n\nTITLE: Configure Okta Authentication in Angular Module (TypeScript)\nDESCRIPTION: Configures Okta authentication within an Angular module using `OktaAuthModule` and `OktaAuth`. This involves setting up the `OKTA_CONFIG` provider with the issuer, client ID, redirect URI, and scopes. Replace `{yourOktaDomain}` and `{yourClientID}` with your actual Okta application details.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { OKTA_CONFIG, OktaAuthModule } from '@okta/okta-angular';\nimport { OktaAuth } from '@okta/okta-auth-js';\n\nconst oktaAuth = new OktaAuth({\n  issuer: 'https://{yourOktaDomain}/oauth2/default',\n  clientId: '{yourClientID}',\n  redirectUri: window.location.origin + '/login/callback',\n  scopes: ['openid', 'profile', 'email']\n});\n\n@NgModule({\n  imports: [\n    OktaAuthModule,\n    // other imports\n  ],\n  providers: [\n    { provide: OKTA_CONFIG, useValue: { oktaAuth } }\n  ],\n  // other module properties\n})\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Exposes Configuration TS\nDESCRIPTION: This TypeScript snippet shows how to configure the `exposes` property in the ModuleFederationPlugin. It defines which modules from the producer application will be available for consumption by other applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  exposes: {\n    '.': './src/index.tsx',\n    './Button': './src/Button.tsx',\n  },\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Register Runtime Plugins for Module Federation (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to register runtime plugins after initialization using the `registerPlugins` function. It imports the `registerPlugins` function and a custom runtime plugin, then registers the plugin.  Refer to the documentation for more information on developing Module Federation plugins.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerPlugins } from '@module-federation/enhanced/runtime'\nimport runtimePlugin from 'custom-runtime-plugin.ts';\n\nregisterPlugins([runtimePlugin()]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Module Federation Project with npx\nDESCRIPTION: Demonstrates using `npx` to run the `create-module-federation` tool for creating Module Federation projects with npm, yarn, and pnpm package managers. The command prompts the user to select project type, role type, and other configuration options interactively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/quick-start.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm create module-federation@latest\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn create module-federation\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm create module-federation@latest\n```\n\n----------------------------------------\n\nTITLE: Register Rsbuild Plugin in Rsbuild App (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to register the `@module-federation/rsbuild-plugin` within an Rsbuild App configuration file. It configures Module Federation with a specified name, remotes, and shared dependencies like 'react' and 'react-dom'. The server port is set to 2000, and a remote is defined.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/rsbuild.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n\nexport default defineConfig({\n  server: {\n    port: 2000,\n  },\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'federation_consumer',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized Dependency Sharing with share\nDESCRIPTION: Demonstrates how to use the `share` helper function to explicitly share specific dependencies instead of using `shareAll`. This allows for more granular control over dependency sharing and can lead to smaller bundle sizes.  The listed packages are Angular core, common, common/http, and router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n// Replace shareAll with share:\nconst { share, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n    // Specify the packages to share:\n    shared: share({\n        \"@angular/core\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/common\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/common/http\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n        \"@angular/router\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n    })\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Asset Caching Configuration\nDESCRIPTION: Configures caching for remote assets in `ngsw-config.json` using a wildcard pattern to cache all JavaScript files from a remote container's URL.  This helps avoid issues with file name changes in new builds.  The configuration specifies the name of the asset group, the install mode, the update mode, and the URLs to cache.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"name\": \"RemoteAssets\",\n  \"installMode\": \"lazy\",\n  \"updateMode\": \"prefetch\",\n  \"resources\": {\n    \"urls\": [\n      \"https://your-remote-container-url/*.js\" // Using a wildcard to cache all JS files\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom shared dependency logic in ModuleFederationConfig\nDESCRIPTION: This Javascript code snippet shows how to customize the sharing of dependencies using the `shared` option in the `ModuleFederationConfig`. It allows writing custom logic to determine how a dependency should be shared, here to prevent lodash from being shared.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// do not share lodash to allow better tree-shaking\nshared: function(libraryName, shareConfig) {\n  if(libraryName === 'lodash') {\n    return false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Dependencies\nDESCRIPTION: These commands install the necessary dependencies for Module Federation: `@module-federation/enhanced` and `@module-federation/rsbuild-plugin`.  The `--save-dev` flag ensures that the `rsbuild-plugin` is saved as a development dependency.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/enhanced\npnpm add @module-federation/rsbuild-plugin --save-dev\n```\n\n----------------------------------------\n\nTITLE: InitOptions Type Definition\nDESCRIPTION: This TypeScript code defines the `InitOptions` type, which is used to configure the Module Federation runtime. It specifies the structure for defining the consumer name, remote modules, shared dependencies, and sharing strategy. It outlines the types and interfaces used for configuring the runtime environment for dynamic module loading and dependency sharing.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype InitOptions = {\n  // The name of the current consumer\n  name: string;\n  // The list of remote modules to depend on\n  // When using the version content, it needs to be used with snapshot, which is still under construction\n  remotes: Array<Remote>;\n  // The list of dependencies that the current consumer needs to share\n  // When using the build plugin, users can configure the dependencies to be shared in the build plugin, and the build plugin will inject the shared dependencies into the runtime sharing configuration\n  // Shared must be manually passed in the version instance when passed at runtime because it cannot be directly passed at runtime.\n  shared?: {\n    [pkgName: string]: ShareArgs | ShareArgs[];\n  };\n  // Sharing strategy, which strategy will be used to decide whether to reuse the dependency\n  shareStrategy?: 'version-first' | 'loaded-first';\n};\n\ntype ShareArgs =\n  | (SharedBaseArgs & { get: SharedGetter })\n  | (SharedBaseArgs & { lib: () => Module });\n\ntype SharedBaseArgs = {\n  version?: string;\n  shareConfig?: SharedConfig;\n  scope?: string | Array<string>;\n  deps?: Array<string>;\n  loaded?: boolean;\n};\n\ntype SharedGetter = (() => () => Module) | (() => Promise<() => Module>);\n\ntype Remote = (RemotesWithEntry | RemotesWithVersion) & RemoteInfoCommon;\n\ninterface RemotesWithVersion {\n  name: string;\n  version: string;\n};\n\ninterface RemotesWithEntry {\n  name: string;\n  entry: string;\n};\n\ninterface RemoteInfoCommon {\n  alias?: string;\n  shareScope?: string;\n  type?: RemoteEntryType;\n  entryGlobalName?: string;\n}\n\ntype RemoteEntryType =|'var'|'module'|'assign'|'assign-properties'|'this'|'window'|'self'|'global'|'commonjs'|'commonjs2'|'commonjs-module'| 'commonjs-static'|'amd'|'amd-require'|'umd'|'umd2'|'jsonp'|'system'| string;\n```\n\n----------------------------------------\n\nTITLE: Configure Custom Webpack Builder\nDESCRIPTION: This snippet updates the `angular.json` file to use a custom Webpack builder, `@angular-builders/custom-webpack`. This allows for adding custom Webpack configurations for Module Federation without ejecting the Angular CLI configuration. The `build` and `serve` properties are updated to use the custom builder.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"projects\": {\n    \"your-project-name\": {\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-builders/custom-webpack:browser\",\n          \"options\": {\n            \"customWebpackConfig\": {\n              \"path\": \"webpack.config.ts\"\n            }\n          }\n        },\n        \"serve\": {\n          \"builder\": \"@angular-builders/custom-webpack:dev-server\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default generateTypes Configuration in JSON\nDESCRIPTION: Shows the default configuration generated when `generateTypes` is set to `true`. This configuration includes settings for generate Federation Runtime API types (`generateAPITypes`), handling errors during type generation (`abortOnError`), extracting third party types (`extractThirdParty`), extracting remote types (`extractRemoteTypes`) and generate types in child process (`compileInChildProcess`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"generateAPITypes\": true,\n  \"abortOnError\": false,\n  \"extractThirdParty\": false,\n  \"extractRemoteTypes\": false,\n  \"compileInChildProcess\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Next.js Configuration with FederatedTypesPlugin (Typescript)\nDESCRIPTION: This code snippet shows how to integrate the `FederatedTypesPlugin` into a Next.js application's `next.config.js` file.  It demonstrates manually passing the `federationConfig` object to the plugin, ensuring that remotes use absolute paths.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// next.config.js\nconst FederatedTypesPlugin = require('@module-federation/typescript');\n\nmodule.exports = {\n  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {\n    config.plugins.push(\n      new FederatedTypesPlugin({\n        federationConfig: {\n          ...federationConfig,\n          remotes: { app2: 'app2@http://localhost:3000/remoteEntry.js' },\n        },\n        // ...\n      }),\n    );\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Remote Flights Routes Configuration (TypeScript)\nDESCRIPTION: This snippet defines the routes for the `FlightsModule` in the Remote application.  It defines a route for `flights-search` that maps to the `FlightsSearchComponent`. This component is responsible for handling flight search functionality.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const FLIGHTS_ROUTES: Routes = [\n     {\n       path: 'flights-search',\n       component: FlightsSearchComponent\n     }\n ];\n```\n\n----------------------------------------\n\nTITLE: Remote Component Renderer Directive (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a structural directive for dynamically rendering components from remote modules.  It uses the `RemoteModuleLoader` service to load the module and the `ViewContainerRef` to create the component in its view. The directive takes the component name and module name as inputs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@Directive({\n  selector: '[remoteComponentRenderer]'\n})\nexport class RemoteComponentRenderer implements OnInit {\n  @Input() set remoteComponentRenderer(componentName: string) { /* ... */ }\n  @Input() set remoteComponentRendererModule(moduleName: RemoteModule) { /* ... */ }\n\n  // ... other code\n\n  private async renderComponent() {\n    const module = await this.remoteModuleLoaderService.loadRemoteModule(this._moduleName);\n    const componentFactory = this.remoteModuleLoaderService.getComponentFactory(module[this._componentName]);\n    this.viewContainerRef.createComponent(componentFactory, undefined, this.injector);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Hook for Language Switching in App B\nDESCRIPTION: This snippet defines a custom hook to facilitate language switching in App B. It imports the appBInstance and returns a function that uses appBInstance.changeLanguage to change the language. This hook is then exposed via Module Federation for consumption by other applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport appBInstance from '../i18n';\n\nconst useSwitchLanguage = () => {\n  return (languageId) => appBInstance.changeLanguage(languageId);\n};\n\nexport default useSwitchLanguage;\n```\n\n----------------------------------------\n\nTITLE: Configure module-federation.config.ts for MFE2\nDESCRIPTION: This code configures Module Federation for MFE2 using the `@module-federation/rsbuild-plugin`. It defines the name of the remote, exposes the `Button` component, sets the filename for the remote entry, and configures shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';\n\nexport default createModuleFederationConfig({\n  name: 'remote',\n  exposes: {\n    './Button': './src/Button',\n  },\n  filename: 'remoteEntry.js',\n  shared: {\n    ...dependencies,\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Install Custom Webpack Builder\nDESCRIPTION: This command installs the `@angular-builders/custom-webpack` package as a development dependency.  This package allows for customizing the Webpack configuration used by the Angular CLI. The `-D` flag indicates that it's a development dependency.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @angular-builders/custom-webpack -D\n# or\nnpm i -D @angular-builders/custom-webpack\n```\n\n----------------------------------------\n\nTITLE: Custom logic for dependency sharing\nDESCRIPTION: This Javascript code snippet demonstrates how to use the shared option to implement custom logic for controlling dependency sharing, specifically excluding lodash to improve tree-shaking.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// do not share lodash to allow better tree-shaking\n  shared: function(libraryName, shareConfig) {\n    if(libraryName === 'lodash') {\n      return false\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin with Shared Dependencies (Object)\nDESCRIPTION: This example demonstrates how to configure the `shared` option in the `ModuleFederationPlugin` to share `react` and `react-dom` as singleton dependencies.  The `singleton: true` option ensures that only one instance of these libraries is loaded, preventing version conflicts and reducing bundle size.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/shared.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/host',\n  shared: {\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Add new entry or enable optional features using pnpm\nDESCRIPTION: This command is likely a custom script provided by Modern.js that allows developers to quickly add new entry points to the application or enable pre-configured optional features.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/modern-common/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm new\n```\n\n----------------------------------------\n\nTITLE: RemoteTypeUrls Configuration Example in module-federation.config.ts\nDESCRIPTION: Demonstrates how to configure `remoteTypeUrls` to specify the address of the remote type file when the default type file location does not match the actual uploaded location. This is useful when the `remoteEntry.js` is replaced with `@mf-types.zip`, but the actual location is different.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/enhanced';\n\nexport default createModuleFederationConfig({\n  // ...\n  remotes: {\n    'remote1-alias': 'remote1@http://localhost:80801/remoteEntry.js'\n  },\n  dts:{\n    consumeTypes:{\n      remoteTypeUrls: {\n        // remote name\n        remote1:{\n          alias: 'remote1-alias',\n          api:'http://localhost:8081/custom-dir/@mf-types.d.ts',\n          zip:'http://localhost:8081/custom-dir/@mf-types.zip'\n        }\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Configuration with dataPrefetch: true (Consumer)\nDESCRIPTION: This code snippet demonstrates setting the `dataPrefetch` flag to `true` in the ModuleFederationPlugin configuration for the consumer application. This allows the consumer to initiate data prefetching for the remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  // ...\n  dataPrefetch: true\n}),\n```\n\n----------------------------------------\n\nTITLE: Load Remote Module Asynchronously in TypeScript\nDESCRIPTION: This code snippet demonstrates how to load a remote module asynchronously using the `loadRemote` function from `@module-federation/enhanced/runtime`. It is used to optimize performance, especially for secondary screen modules. This function initiates the loading of a module identified by its scope and module name, enabling lazy loading of components from remote applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loadRemote } from '@module-federation/enhanced/runtime';\n\nloadRemote('app2/Button');\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Webpack configuration - exposes\nDESCRIPTION: This JavaScript snippet shows the `exposes` property within the `webpack.config.js` file, which dictates the modules to be exposed to the loader. The key `./Module` corresponds to the `exposedModule` property used in the route configuration of the main application. The path should point to the correct module in the remote application, e.g., the LoginModule.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexposes: {\n  './Module': './projects/login/src/app/feature/login/login.module.ts',\n},\n```\n\n----------------------------------------\n\nTITLE: Using FederationBoundary Component in React\nDESCRIPTION: The FederationBoundary component is a React wrapper that provides a fallback mechanism for handling errors when importing modules from remote hosts in a Module Federation setup. It accepts dynamicImporter and fallback props, both of which should be functions that return a Promise that resolves to a React component. It can also accept a custom error boundary component via the customBoundary prop.  Any additional props passed will be forwarded to the imported module.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/utilities/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { FederationBoundary } from '@module-federation/utilities/src/utils/react';\n\n// defining dynamicImport and fallback outside the Component to keep the component identity\n// another alternative would be to use useMemo\nconst dynamicImport = () => import('some_remote_host_name').then((m) => m.Component);\nconst fallback = () => import('@npm/backup').then((m) => m.Component);\n\nconst MyPage = () => {\n  return <FederationBoundary dynamicImporter={dynamicImport} fallback={fallback} customBoundary={CustomErrorBoundary} />;\n};\n```\n\n----------------------------------------\n\nTITLE: Add paths to tsconfig.json (JSON)\nDESCRIPTION: This configuration in `tsconfig.json` adds a `paths` mapping to allow TypeScript to resolve types from the producer's application, enabling type checking for remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the Host Application with SSR\nDESCRIPTION: This command builds the browser and server bundles for the 'dashboard' application and runs it using Node.js with SSR enabled. It also starts the 'login' application but without file watchers.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve-ssr dashboard\n```\n\n----------------------------------------\n\nTITLE: React 18 Import\nDESCRIPTION: Explicitly specifies React 18 version for `createBridgeComponent`. This is recommended for React 18 projects. It utilizes the `createRoot` and `hydrateRoot` APIs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Explicitly specify React 18 version (recommended for React 18)\nimport { createBridgeComponent } from '@module-federation/bridge-react/v18';\n```\n\n----------------------------------------\n\nTITLE: Customize Workbox Caching Strategies in Service Worker\nDESCRIPTION: This JavaScript snippet demonstrates how to customize Workbox caching strategies in a `service-worker.js` file. It uses `precacheAndRoute` for initial resource caching and defines runtime caching strategies for API requests (network-first) and other resources (stale-while-revalidate). Requires `workbox-precaching` and `workbox-strategies` modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';\n\n// Precaching for fast load of initial resources\nprecacheAndRoute(self.__WB_MANIFEST);\n\n// Example runtime caching strategies\nself.addEventListener('fetch', event => {\n  if (event.request.url.includes('/api/')) {\n    // Network-first strategy for API requests\n    event.respondWith(new NetworkFirst().handle({ event }));\n  } else {\n    // Stale-while-revalidate for other resources\n    event.respondWith(new StaleWhileRevalidate().handle({ event }));\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin shared dependencies in modern.config.js (TS)\nDESCRIPTION: This code snippet demonstrates how to configure shared dependencies in the ModuleFederationPlugin within a modern.config.js file.  It addresses the React multi-instance problem by setting `singleton: true` for shared React dependencies. This ensures that only one instance of React is used across the federated modules. It accepts react, react-dom, and other custom modules as shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/other.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n{\n    ...\n    new ModuleFederationPlugin({\n            ...,\n         // Default basic configuration\n         // shared: [\n         //   'react',\n         //   'react-dom',\n         //   'my-custom-module'\n         // ]\n\n         // Configuration with more specificity\n            shared: {\n                react: { singleton: true, },\n                'react-dom': { singleton: true, },\n                'my-custom-module': { singleton: true, },\n                ...\n            },\n        })\n      ]\n```\n\n----------------------------------------\n\nTITLE: Error Handling Plugin Example in TypeScript\nDESCRIPTION: This code snippet shows an example of a plugin implementing the `errorLoadRemote` hook to handle errors during module loading. The plugin checks the `lifecycle` stage of the error and returns a fallback value if the error occurred during the `onLoad` stage.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst fallbackPlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'fallback-plugin',\n    errorLoadRemote(args) {\n      if(args.lifecycle === 'onLoad') {\n        const fallback = 'fallback';\n        return fallback;\n      } else if (args.lifecycle === 'beforeRequest') {\n        return args\n      }\n    }\n  };\n};\n\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: '@demo/app2',\n      entry: 'http://localhost:3006/remoteEntry.js',\n      alias: 'app2'\n    }\n  ],\n  plugins: [fallbackPlugin()]\n});\n\nloadRemote('app2/un-existed-module').then((mod) => {\n  expect(mod).toEqual('fallback');\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Retry Mechanism with Pure Runtime Registration\nDESCRIPTION: This snippet demonstrates how to integrate the `@module-federation/retry-plugin` directly into the runtime configuration to automatically retry failed resource requests in a Module Federation setup.  It uses `init` to register the plugin with fetch and script retry configurations. The `RetryPlugin` enhances network resilience by automatically retrying failed resource requests, which is especially useful in unreliable network environments. This requires `@module-federation/runtime` version 0.8.10 or above.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_0\n\nLANGUAGE: Diff\nCODE:\n```\nimport React from 'react';\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n+ import { RetryPlugin } from '@module-federation/retry-plugin';\n\n// Module registration\ninit({\n    name: 'host',\n    remotes: [\n        {\n            name: \"remote1\",\n            alias: \"remote1\"\n            entry: \"http://localhost:2001/mf-manifest.json\",\n        }\n    ],\n+   plugins: [\n+     RetryPlugin({\n+       fetch: {},\n+       script: {},\n+     }),\n    ]\n});\n\n// Module loading\nconst Remote1Button = React.lazy(() => loadRemote('remote1/button'));\n\nexport default () => {\n  return (\n    <React.Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1Button />\n    </React.Suspense>\n  );\n}\n\n// Method/function loading\nloadRemote<{add: (...args: Array<number>)=> number }>(\"remote1/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: Enable Data Prefetch in Module Federation Plugin (Producer) TS\nDESCRIPTION: This TypeScript snippet shows how to enable data prefetching in the producer application's ModuleFederationPlugin configuration.  Setting `dataPrefetch: true` enables the prefetch functionality for exposed modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n    // ...\n    dataPrefetch: true\n  }),\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration in MFE2\nDESCRIPTION: This code defines the Module Federation configuration for `MFE2` in `module-federation.config.ts`.  It specifies the module name, the exposed modules (in this case, `./Button`), the filename for the remote entry, and the shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';\n\nexport default createModuleFederationConfig({\n  name: 'remote',\n  exposes: {\n    './Button': './src/Button',\n  },\n  filename: 'remoteEntry.js',\n  shared: {\n    ...dependencies,\n    react: {\n      singleton: true,\n    },\n    'react-dom': {\n      singleton: true,\n    },\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Module Federation Options Type Definition (TS)\nDESCRIPTION: This TypeScript code defines the structure of the ModuleFederationOptions object.  It includes properties such as 'name' (string), 'filename' (optional string), 'remotes' (optional array of RemoteInfo), and 'shared' (optional ShareInfos).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/webpack.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions {\n    name: string;\n    filename?: string,\n    remotes?: Array<RemoteInfo>;\n    shared?: ShareInfos;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Remote Components and Hooks in Next.js\nDESCRIPTION: This snippet showcases importing a component and a hook from a remote Next.js application. It uses `require` for the hook and a standard `import` statement for the component, assuming the remote application 'next2' exposes these modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst SomeHook = require('next2/someHook');\nimport SomeComponent from 'next2/someComponent';\n```\n\n----------------------------------------\n\nTITLE: Access User Information in Micro Frontend Component\nDESCRIPTION: This code snippet illustrates how to use AuthService in a micro frontend component to access the current user's information. It subscribes to the auth.user$ observable and uses the user information to pre-fill a form. It takes the first emitted value using `take(1)` and unsubscribes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AuthService } from '@auth0/auth0-angular';\nimport { FormBuilder } from '@angular/forms';\nimport { take } from 'rxjs/operators';\n\n@Component({\n  // component metadata...\n})\nexport class AddressComponent {\n  // component properties...\n  constructor(\n    private auth: AuthService,\n    private fb: FormBuilder) {\n    this.auth.user$.pipe(take(1)).subscribe(user => {\n      if (!user) return;\n      // Use user information to pre-fill form, etc.\n    });\n  }\n  // other component methods...\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript DtsRemoteOptions Interface\nDESCRIPTION: This TypeScript interface defines the options for configuring the generation of TypeScript definition files in a Module Federation remote application. It includes settings for specifying the tsconfig path, types folder, whether to delete the types folder, additional files to compile, the compiler instance to use, whether to compile in a child process, whether to generate API types, and whether to abort on error.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DtsRemoteOptions {\n  tsConfigPath?: string;\n  typesFolder?: string;\n  deleteTypesFolder?: boolean;\n  additionalFilesToCompile?: string[];\n  compilerInstance?: 'tsc' | 'vue-tsc';\n  compileInChildProcess?: boolean;\n  generateAPITypes?: boolean;\n  extractThirdParty?: boolean;\n  extractRemoteTypes?: boolean;\n  abortOnError?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Config for Module Delegation in TS\nDESCRIPTION: This snippet shows the module federation configuration for module delegation.  The `remotes` object defines `delegateModulesA`, pointing to `https://delegateModulesA.js`. This config is used with the module delegation plugin to dynamically load modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// module-federation-config\n{\n  remotes: {\n    delegateModulesA: \"delegateModulesA@https://delegateModulesA.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation Configuration\nDESCRIPTION: Illustrates the creation of a `module-federation.config.ts` file with necessary configurations such as name, remotes, and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\nexport default createModuleFederationConfig({\n  name: 'host',\n  remotes: {\n    remote: 'remote@http://localhost:3006/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configure ContainerManager Exposes in Module Federation\nDESCRIPTION: Demonstrates how to replace expose options with container.options.exposes using the ContainerManager to automatically set the expose name.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ContainerManager } from '@module-federation/managers';\nconst containerManager = new ContainerManager();\ncontainerManager.init(options);\n// it will set expose name automatically\noptions.exposes = containerManager.containerPluginExposesOptions;\n```\n\n----------------------------------------\n\nTITLE: Shell Routing Configuration (JavaScript)\nDESCRIPTION: Defines the routes for the shell application, including a route for lazy-loading a module from a remote application (mfe1). The `loadChildren` property dynamically imports the `FlightsModule` from the `mfe1/Module` path.  `'mfe1/Module'` is a virtual path representing the remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const APP_ROUTES: Routes = [\n  {\n    path: '',\n    component: HomeComponent,\n    pathMatch: 'full'\n  },\n  {\n    path: 'flights',\n    loadChildren: () => import('mfe1/Module').then(m => m.FlightsModule)\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Federated Components in Next.js\nDESCRIPTION: This code demonstrates how to use React.lazy to lazy load federated components in a Next.js application, which helps to avoid hydration errors. It imports a component from a remote application ('next2') using React's lazy function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { lazy } from 'react';\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n```\n\n----------------------------------------\n\nTITLE: Remote Page with getInitialProps in Next.js\nDESCRIPTION: This code snippet represents a remote page component in a Next.js application. It defines a `Shop` component that fetches data using `getInitialProps` and renders it. The component imports React and Head from next.js.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport Head from 'next/head';\n\nconst Shop = (props) => {\n  return (\n    <div>\n      <Head>\n        <title>Shop</title>\n      </Head>\n      <pre>{JSON.stringify(props)}</pre>\n    </div>\n  );\n};\nShop.getInitialProps = async () => {\n  const fallback = {\n    name: 'Luke Skywalker',\n    height: '172',\n    mass: '77',\n    hair_color: 'blond'\n  };\n  return Promise.resolve(fallback);\n};\n\nexport default Shop;\n```\n\n----------------------------------------\n\nTITLE: Generating Host and Remote Applications with SSR\nDESCRIPTION: This command scaffolds a Module Federation architecture with SSR enabled. It generates two Angular Universal (SSR) applications named 'dashboard' (host) and 'login' (remote), and configures Webpack for both browser and server builds.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g host dashboard --remotes=login --ssr\n```\n\n----------------------------------------\n\nTITLE: Module Federation Exposes Configuration\nDESCRIPTION: This snippet demonstrates how to expose the custom hook for language switching via Module Federation. It defines an exposes configuration that maps the hook's module path to its file path, making it available for consumption by other federated modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Module Federation exposes configuration\nexposes: {\n  './hooks/useSwitchAppBLanguage': './src/hooks/useSwitchLanguage',\n},\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration with Implementation Option JavaScript\nDESCRIPTION: This code snippet demonstrates how to configure Module Federation with a custom implementation. The `implementation` option is used to specify the path to `@module-federation/runtime-tools`, allowing for modification of the bundler runtime version. It is used within the `plugins` array of a webpack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/implementation.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  // ...other configurations\n  plugins: [\n    new ModuleFederation({\n      // ...other Module Federation options\n      implementation: require.resolve('@module-federation/runtime-tools'),\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Alias in Rsbuild\nDESCRIPTION: This configuration sets up an alias in `rsbuild.config.ts` to point `react-router-dom` to the bridged router implementation provided by `@module-federation/bridge-react`. It also configures the rspack bundler with Module Federation Plugin for remote module exposure.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react-webpack-plugin/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n//rsbuild.config.ts\nexport default defineConfig({\n  source: {\n    alias: {\n      'react-router-dom$': path.resolve(\n        __dirname,\n        'node_modules/@module-federation/bridge-react/dist/router.es.js',\n      ),\n    },\n  },\n  server: {\n    port: 2001,\n    host: 'localhost',\n  },\n  dev: {\n    assetPrefix: 'http://localhost:2001',\n  },\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      delete config.optimization?.splitChunks;\n      config.output!.uniqueName = 'remote1';\n      appendPlugins([\n        new ModuleFederationPlugin({\n          name: 'remote1',\n          exposes: {\n            './export-app': './src/index.tsx',\n          }\n        }),\n      ]);\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration (TS)\nDESCRIPTION: Shows how to configure module federation in `rsbuild.config.ts` to expose the application module. It sets up the `pluginModuleFederation` with the application entry point and shared dependencies (react and react-dom).  This configuration exposes 'export-app.tsx' as a module named './export-app'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'remote1',\n      exposes: {\n        './export-app': './src/export-app.tsx',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Load and Use the Remote Module\nDESCRIPTION: This code demonstrates how to load and use the remote module 'remote1/export-app' within the host application using `createBridgeComponent`. The `Remote1` component is created dynamically and integrated into the host's routing configuration using `BrowserRouter`, `Routes`, and `Route` components.  ReactDOM.createRoot is used to render the App component. It depends on react-router-dom Link to create the routes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react-webpack-plugin/README.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n// ./src/index.tsx\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nconst Remote1 = createBridgeComponent(()=> import('remote1/export-app'));\n\nfunction App() {\n  return ( <BrowserRouter basename=\"/\">\n    <ul>\n      <li>\n        <Link to=\"/\">\n          Home\n        </Link>\n      </li>\n      <li>\n        <Link to=\"/remote1\">\n          Remote1\n        </Link>\n      </li>\n    </ul>\n    <Routes>\n      <Route path=\"/\" Component={()=> <div>Home page</div>}>\n      <Route path=\"/remote1\" Component={()=> <Remote1 />}>\n    </Routes>\n  </BrowserRouter>)\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n    <App />\n);\n```\n\n----------------------------------------\n\nTITLE: Lazy Load Remote Component (Default Export) - JavaScript\nDESCRIPTION: This code snippet demonstrates how to lazy load a remote component using `React.lazy` and `React.Suspense`. It imports a component from a remote module (`next2/sampleComponent`) and renders it within a `Suspense` boundary to handle loading states. This is suitable for asynchronously loading default exports from remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-components.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React, { lazy } from 'react';\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n\nconst FormComponent = ()=>{\n  return (\n    <Suspense fallback=\"loading\">\n      <SampleComponent/>\n    </Suspense>\n  )\n}\n\nexport default FormComponent\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Public Path in Module Federation (Rspack)\nDESCRIPTION: This code snippet demonstrates how to configure a dynamic publicPath in Rspack's ModuleFederation plugin using the `getPublicPath` option. The `getPublicPath` function is evaluated at runtime to determine the correct publicPath for the remote module. The returned value will be used as the prefix for static assets.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/getpublicpath.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'provider',\n      exposes: {\n        './Button': './src/components/Button.tsx',\n      },\n      // ...\n      getPublicPath: `return \\\"https:\\\" + window.navigator.cdn_host + \\\"/resource/app/\\\"`,\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Federated Components in React\nDESCRIPTION: This JavaScript code snippet demonstrates how to lazy load a federated component in a Next.js application using React's `lazy` function.  Instead of `next/dynamic`, `React.lazy` should be used to avoid hydration errors when consuming federated modules.  The federated component `SampleComponent` is imported from the `next2` remote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React, { lazy } from 'react';\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n```\n\n----------------------------------------\n\nTITLE: Shell Webpack Configuration with Module Federation\nDESCRIPTION: Configures the Webpack build process to use the Module Federation plugin, enabling the shell application to consume remote modules. The `remotes` property maps the virtual path ('mfe1') to the URL of the remote entry point. The `shared` property configures dependency sharing using `shareAll` to share all dependencies listed in the `package.json`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { shareAll, withModuleFederationPlugin } = require('@angular-architects/module-federation/webpack');\n\nmodule.exports = withModuleFederationPlugin({\n\n   remotes: {\n     \"mfe1\": \"http://localhost:4201/remoteEntry.js\",\n   },\n\n   shared: {\n     ...shareAll({ singleton: true, strictVersion: true, requiredVersion: 'auto' }),\n   },\n\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig.json for Type Definitions (JSON)\nDESCRIPTION: This code snippet configures the `tsconfig.json` file to automatically find type definitions for imports.  It adds a `paths` configuration that maps imports to the `@mf-types` directory, where remote types are stored. The `baseUrl` setting is required for `paths` to function correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Load and Use Remote Module with Routing\nDESCRIPTION: This code shows how to load a remote module using `createBridgeComponent` and then render it within a React application using `BrowserRouter`, `Routes`, and `Route`.  It defines routes for both the home page and the remote module.  It also configures React DOM to render the App component.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// ./src/index.tsx\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nconst Remote1 = createBridgeComponent(()=> import('remote1/export-app'));\n\nfunction App() {\n  return ( <BrowserRouter basename=\"/\">\n    <ul>\n      <li>\n        <Link to=\"/\">\n          Home\n        </Link>\n      </li>\n      <li>\n        <Link to=\"/remote1\">\n          Remote1\n        </Link>\n      </li>\n    </ul>\n    <Routes>\n      <Route path=\"/\" Component={()=> <div>Home page</div>}>\n      <Route path=\"/remote1\" Component={()=> <Remote1 />}>\n    </Routes>\n  </BrowserRouter>)\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n    <App />\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Routing for Remote Module Loading\nDESCRIPTION: This TypeScript snippet demonstrates how to configure routes for loading remote modules using `loadRemoteModule`. It imports the function from `@angular-architects/module-federation` and defines a route that loads the 'login' module from the manifest.  The `remoteName` refers to the module's name in the manifest, and `exposedModule` specifies the path to the module in the remote application. The route also includes `canMatch` guard to protect the route.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  ...\n  {\n    path: '',\n    canMatch: [isNotLogged],\n    loadChildren: () =>\n      loadRemoteModule({ type: 'manifest', remoteName: 'login', exposedModule: './Module' }).then(\n        (m) => m.LoginModule,\n      ),\n  },\n  ...\n];\n```\n\n----------------------------------------\n\nTITLE: Configure Alias for React Router DOM\nDESCRIPTION: This snippet shows how to configure an alias in the rsbuild configuration file for `react-router-dom` to point to the bridged router provided by `@module-federation/bridge-react`. This ensures that the remote module uses the correct router implementation when federated. The rsbuild config also sets the port, host and assetPrefix for development.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n//rsbuild.config.ts\nexport default defineConfig({\n  source: {\n    alias: {\n      'react-router-dom$': path.resolve(\n        __dirname,\n        'node_modules/@module-federation/bridge-react/dist/router.es.js',\n      ),\n    },\n  },\n  server: {\n    port: 2001,\n    host: 'localhost',\n  },\n  dev: {\n    assetPrefix: 'http://localhost:2001',\n  },\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      delete config.optimization?.splitChunks;\n      config.output!.uniqueName = 'remote1';\n      appendPlugins([\n        new ModuleFederationPlugin({\n          name: 'remote1',\n          exposes: {\n            './export-app': './src/index.tsx',\n          }\n        }),\n      ]);\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: usePrefetch Hook Usage Example\nDESCRIPTION: This code provides an example of how to use the `usePrefetch` hook within a React component. It demonstrates how to pass options, handle the prefetch result with `Suspense` and `Await`, and trigger a re-fetch with new parameters.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Suspense } from 'react';\nimport { usePrefetch } from '@module-federation/enhanced/prefetch';\nimport { Await } from 'react-router-dom';\n\nexport const Button = () => {\n  const [userInfoPrefetch, reFetchUserInfo] = usePrefetch<UserInfo>({\n    // Corresponds to (name + expose) in the producer MF configuration, for example, `app2/Button` is used to consume `Button.prefetch.ts`\n    id: 'app2/Button',\n    // Optional parameter, required after using defer\n    deferId: 'userInfo'\n    // default export does not need to pass functionId by default, here is an example, if it is not default export, you need to fill in the function name,\n    // functionId: 'default',\n  });\n\nreturn (\n  <>\n    <button onClick={() => reFetchUserInfo(reFetchParams)}>Resend request with parameters</button>\n    <Suspense fallback={<p>Loading...</p>}>\n      <Await\n        resolve={prefetchResult}\n        children={userInfo => (\n          <div>\n            <div>{userInfo.data.id}</div>\n            <div>{userInfo.data.title}</div>\n          </div>\n      )}\n    ></Await>\n    </Suspense>\n  <>\n )\n}\n```\n\n----------------------------------------\n\nTITLE: Configure React Bridge Component\nDESCRIPTION: This code demonstrates how to use `createBridgeComponent` from `@module-federation/bridge-react` to wrap a React component (App) containing routing configuration with `BrowserRouter`, `Routes`, and `Route` components. The `rootComponent` prop specifies the main component to be bridged.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react-webpack-plugin/README.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// ./src/index.tsx\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nfunction App() {\n  return ( <BrowserRouter basename=\"/\">\n    <Routes>\n      <Route path=\"/\" Component={()=> <div>Home page</div>}>\n      <Route path=\"/detail\" Component={()=> <div>Detail page</div>}>\n    </Routes>\n  </BrowserRouter>)\n}\n\nexport default createBridgeComponent({\n  rootComponent: App\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Bridge Component\nDESCRIPTION: Creates a bridge component using `createBridgeComponent` to wrap the root component of an application for exporting as an application type module. This enables cross-framework rendering, automatic basename injection, and ErrorBoundary wrapping.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.tsx\nimport App from './src/App.tsx';\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nexport default createBridgeComponent({\n  rootComponent: App\n});\n```\n\n----------------------------------------\n\nTITLE: Loading Shared Dependencies with Resolver\nDESCRIPTION: Illustrates how to use the `resolver` option in `loadShare` to customize the selection of shared dependency versions.  It initializes the runtime with multiple versions of React and uses a resolver function to specifically load version 17.0.0. This enables fine-grained control over shared dependency resolution.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { init, loadRemote, loadShare } from '@module-federation/runtime';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [],\n  shared: {\n    react: [\n      {\n        version: '17.0.0',\n        scope: 'default',\n        get: async ()=>() => ({ version: '17.0.0)' }),\n        shareConfig: {\n          singleton: true,\n          requiredVersion: '^17.0.0',\n        },\n      },\n      {\n        version: '18.0.0',\n        scope: 'default',\n        // pass lib means the shared has loaded\n        lib: () => ({ version: '18.0.0)' }),\n        shareConfig: {\n          singleton: true,\n          requiredVersion: '^18.0.0',\n        },\n      },\n    ],\n  },\n});\n\nloadShare('react', {\n   resolver: (sharedOptions) => {\n      return (\n        sharedOptions.find((i) => i.version === '17.0.0') ?? sharedOptions[0]\n      );\n  },\n }).then((reactFactory) => {\n  console.log(reactFactory()); // { version: '17.0.0' }\n});\n```\n\n----------------------------------------\n\nTITLE: NodeFederationPlugin and StreamingTargetPlugin Configuration\nDESCRIPTION: This code snippet illustrates a webpack configuration using both the NodeFederationPlugin and StreamingTargetPlugin for server-side module federation. It defines the plugin's name, library type, remotes, filename, and exposed modules. This configuration allows a website to expose and consume modules in a federated manner.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { NodeFederationPlugin, StreamingTargetPlugin } = require('@module-federation/node');\n\nconst config = {\n  target: isServer ? false : 'web',\n  plugins: [\n    new NodeFederationPlugin({\n      name: 'website2',\n      library: { type: 'commonjs-module' },\n      remotes: {},\n      filename: 'remoteEntry.js',\n      exposes: {\n        './SharedComponent': './remoteServer/SharedComponent',\n      },\n    }),\n    new StreamingTargetPlugin({\n      name: 'website2',\n      library: { type: 'commonjs-module' },\n      remotes: {},\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Chunk Fetch\nDESCRIPTION: This code snippet shows how to override the default HTTP chunk fetch function by setting the `globalThis.webpackChunkLoad` variable.  It demonstrates setting custom headers to the fetch request. This allows for customization of how chunks are loaded, enabling features like adding custom headers for authentication or other purposes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst chunkFetcher = globalThis.webpackChunkLoad || globalThis.fetch || fetchPolyfill;\n// then it will pass one argument to the function, the url to fetch\n\nchunkFetcher(url)\n  .then((res) => res.text())\n  .then((text) => {\n    // do something with the text\n  });\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nglobalThis.webpackChunkLoad = async (url) => {\n  const res = await fetch(url, {\n    headers: {\n      'x-custom-header': 'custom-header-value',\n    },\n  });\n  return res.text();\n};\n```\n\n----------------------------------------\n\nTITLE: Preload Remote Resources in Module Federation (TypeScript)\nDESCRIPTION: This code snippet defines the `preloadRemote` function and its related types, which are used to preload remote module resources such as the remote entry and expose resources. It includes parameters for specifying the module name, exposed resources, resource category (sync or all), and dependencies to be preloaded. A filter function can also be configured to exclude unnecessary resources.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nasync function preloadRemote(preloadOptions: Array<PreloadRemoteArgs>) {}\n\ntype depsPreloadArg = Omit<PreloadRemoteArgs, 'depsRemote'>;\ntype PreloadRemoteArgs = {\n  // The name and alias of the preloaded remote module\n  nameOrAlias: string;\n  // The specific expose of the preloaded remote module\n  // By default, all exposes are preloaded\n  // When provides exposes, only specific exposes are preloaded\n  exposes?: Array<string>; // Default request\n  // Default is sync, only preloads synchronous chunks referenced in expose\n  // Set to all to load both synchronous and asynchronous referenced chunks\n  resourceCategory?: 'all' | 'sync';\n  // By default, true, loads all sub-module dependencies of the current module\n  // After configuring dependencies, only the required resources are loaded\n  depsRemote?: boolean | Array<depsPreloadArg>;\n  // No filtering by default\n  // After configuration, unnecessary resources are filtered out\n  filter?: (assetUrl: string) => boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Workbox Caching Strategies (JavaScript)\nDESCRIPTION: This JavaScript code demonstrates Workbox caching strategies within a service worker file. It applies a network-first strategy for API requests and a stale-while-revalidate strategy for other resources, ensuring efficient data fetching and caching.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';\n\n// Precaching for fast load of initial resources\nprecacheAndRoute(self.__WB_MANIFEST);\n\n// Example runtime caching strategies\nself.addEventListener('fetch', event => {\n  if (event.request.url.includes('/api/')) {\n    // Network-first strategy for API requests\n    event.respondWith(new NetworkFirst().handle({ event }));\n  } else {\n    // Stale-while-revalidate for other resources\n    event.respondWith(new StaleWhileRevalidate().handle({ event }));\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using createRemoteSSRComponent in a React Component (TSX)\nDESCRIPTION: Example usage of `createRemoteSSRComponent` to load and render a remote component in a React component.  It uses `registerRemotes` to register the remote and provides `loading` and `fallback` components for different scenarios. It demonstrates how to handle errors and load components dynamically.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport React, { FC, memo, useEffect } from 'react';\nimport { registerRemotes, createRemoteSSRComponent } from '@modern-js/runtime/mf';\n// 在构建插件声明过的 remote 可以直接在顶层 import\nimport RemoteComp from 'remote/Image';\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  // 在构建插件声明过的 remote 也可以使用此函数加载：loader: () => import('remote/Image'),\n  loader: () => loadRemote('dynamic_remote/Image'),\n  loading: <div>loading...</div>,\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Product: FC = () => {\n  registerRemotes([\n    {\n      name: 'dynamic_remote',\n      entry: 'http://localhost:3008/mf-manifest.json',\n    },\n  ]);\n\n  const fallback = (err: Error) => {\n    if (err.message.includes('does not exist in container')) {\n      return <div>404</div>;\n    }\n    throw err;\n  };\n\n  return <>\n    <RemoteSSRComponent />\n    <RemoteComp />\n  </>;\n};\nexport default Product;\n```\n\n----------------------------------------\n\nTITLE: Force Webpack 5 Resolution (Yarn)\nDESCRIPTION: This snippet forces the resolution of Webpack to version 5 or higher using Yarn's resolutions feature.  This ensures that Module Federation is fully supported by the Angular CLI project.  It's added to the `package.json` file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"resolutions\": {\n    \"webpack\": \"^5.0.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declare Remote Module Types\nDESCRIPTION: This TypeScript snippet declares the remote module types 'mf1/Contact' and 'mf1/Clock' to inform TypeScript about their existence, since they will be dynamically loaded at runtime. This declaration helps avoid TypeScript compilation errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'mf1/Contact';\ndeclare module 'mf1/Clock';\n```\n\n----------------------------------------\n\nTITLE: React Component for Dynamic Loading\nDESCRIPTION: This React component, `Image.tsx`, is exposed as a module by the 'dynamic_provider'. It renders a simple image and a button, demonstrating basic interactivity with a client-side alert. The component includes styling and uses an external image source.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport styles from './Image.module.css';\n\nexport default (): JSX.Element => (\n  <div\n    id=\"remote-components\"\n    style={{\n      backgroundColor: '#c0e91e',\n      color: 'lightgrey',\n      padding: '1rem',\n    }}\n  >\n    <h2>\n      <strong>dynamic remote</strong>&nbsp;image\n    </h2>\n    <button\n      id=\"dynamic-remote-components-button\"\n      style={{ marginBottom: '1rem' }}\n      onClick={() => alert('[remote-components] Client side Javascript works!')}\n    >\n      Click me to test i'm interactive!\n    </button>\n    <img\n      id=\"dynamic-remote-components-image\"\n      src=\"https://module-federation.io/module-federation-logo.svg\"\n      style={{ width: '100px' }}\n      alt=\"serge\"\n    />\n    <button className={styles['button']}>Button from dynamic remote</button>\n  </div>\n);\n```\n\n----------------------------------------\n\nTITLE: Serving with Dev Remotes\nDESCRIPTION: This command serves the 'shop' application with 'products' specified as a dev remote. Dev remotes are served using webpack-dev-server allowing for HMR and file watching.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve shop --devRemotes=products\n```\n\n----------------------------------------\n\nTITLE: Configure tsconfig.json for Module Federation Types\nDESCRIPTION: This snippet configures the `tsconfig.json` file to include paths for Module Federation types, enabling type hinting for remote modules by mapping import paths to the `@mf-types` directory.  This allows the consumer application to resolve types from the producer's exposed modules.  It's a required step for enabling type hinting in the consumer application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/type-prompt.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: loadRemote Usage for Data Prefetch\nDESCRIPTION: This code snippet shows how to use the `loadRemote` function from `@module-federation/enhanced/runtime` to manually trigger data prefetching. Calling `loadRemote` will initiate the prefetch request in addition to loading the remote module's static resources.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loadRemote } from '@module-federation/enhanced/runtime';\n\nloadRemote('app2/Button');\n```\n\n----------------------------------------\n\nTITLE: Set uniqueName and disable Runtime Chunk (Producer)\nDESCRIPTION: This TypeScript snippet sets the unique name and disables the runtime chunk in the Webpack configuration for a producer module/application. Setting `uniqueName` to 'contact' and `optimization.runtimeChunk` to `false` are essential for enabling the module federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconfig.output.uniqueName = 'contact';\nconfig.optimization.runtimeChunk = false;\n```\n\n----------------------------------------\n\nTITLE: Shell Routing Configuration (JavaScript)\nDESCRIPTION: This snippet defines the routing configuration for the Shell application.  It includes a route to a `HomeComponent` and a lazy-loaded route to a `FlightsModule` located in the remote micro-frontend (`mfe1`). The `loadChildren` property uses a virtual path (`mfe1/Module`) to reference the remote module, which is resolved using Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const APP_ROUTES: Routes = [\n    {\n      path: '',\n      component: HomeComponent,\n      pathMatch: 'full'\n    },\n    {\n      path: 'flights',\n      loadChildren: () => import('mfe1/Module').then(m => m.FlightsModule)\n    },\n  ];\n```\n\n----------------------------------------\n\nTITLE: rsbuild Configuration for Host - TS\nDESCRIPTION: This example shows the rsbuild configuration for the host application. It uses the `pluginModuleFederation` plugin to configure the module federation settings, including the name of the host and the remotes it consumes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n//rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Host _app.js in Next.js\nDESCRIPTION: This code defines a custom `_app.js` component in a host Next.js application, similar to the remote one. It extends the default `App` component and overrides the `getInitialProps` method. It is used to maintain the application state and wrap pages.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport App  from 'next/app'\n\nexport default function MyApp({\n  Component,\n  pageProps,\n  example,\n}) {\n  return (\n    <>\n      <Component {...pageProps} />\n    </>\n  )\n}\n\nMyApp.getInitialProps = async (context) => {\n  const ctx = await App.getInitialProps(context)\n\n  return { ...ctx }\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Plugin Registration in TypeScript\nDESCRIPTION: This code snippet demonstrates how to register a runtime plugin dynamically using the `registerPlugins` function from `@module-federation/enhanced/runtime`. It shows how to import the plugin and then call `registerPlugins` with an array containing the instantiated plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerPlugins } from '@module-federation/enhanced/runtime'\nimport runtimePlugin from 'custom-runtime-plugin.ts';\n\nregisterPlugins([runtimePlugin()]);\n```\n\n----------------------------------------\n\nTITLE: Implement Login Functionality in Shell Component\nDESCRIPTION: This code snippet shows how to use the AuthService from @auth0/auth0-angular to implement login functionality in the shell application's home component. It defines a login method that calls auth.loginWithRedirect() to initiate the Auth0 login process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent {\n  user$ = this.auth.user$;\n\n  constructor(private auth: AuthService) {}\n\n  login(): void {\n    this.auth.loginWithRedirect();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using memoryRoute to control routing (TSX)\nDESCRIPTION: Demonstrates how to use the `memoryRoute` option to control routing within a remote application using a memory router. This allows the remote application's routing to be managed without directly affecting the browser's URL. The `entryPath` specifies the initial path for the memory router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  return (\n    <BrowserRouter basename=\"/\">\n      <Routes>\n        <Route\n          path=\"/remote1/*\"\n          Component={() => (\n            <Remote1App\n              className={styles.remote1}\n              style={{ color: 'red' }}\n              // 使用 memoryRoute 将子应用路由作为 memoryRouter 控制\n              // 不会直接在浏览器地址栏中显示 URL\n              memoryRoute={{ entryPath: '/detail' }}\n              // 其他属性将传递给远程组件\n              props1={'props_value'}\n              props2={'another_props_value'}\n              ref={ref}\n            />\n          )}\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Register RetryPlugin at Runtime (TypeScript)\nDESCRIPTION: This code shows how to register the RetryPlugin directly at runtime using the `init` function from `@module-federation/enhanced/runtime`. It configures the plugin with empty `fetch` and `script` retry options.  This approach allows dynamic configuration but may be less reliable than registering it during build.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/plugins/retry-plugin.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\ninit({\n  name: 'federation_consumer',\n  remotes: [],\n  plugins: [\n    RetryPlugin({\n      fetch: {},\n      script: {},\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a new Nx workspace\nDESCRIPTION: This command creates a new Nx workspace named 'myorg' and sets it up for application development using a preset configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y create-nx-workspace@latest myorg --preset=apps\ncd myorg\n```\n\n----------------------------------------\n\nTITLE: TypeScript Remote Type URLs Static Configuration\nDESCRIPTION: This TypeScript code snippet shows how to configure the `remoteTypeUrls` option to specify the location of the remote type files. This example demonstrates a static configuration where the URLs for the API and ZIP files are directly provided.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/enhanced';\n\nexport default createModuleFederationConfig({\n  // ...\n  remotes: {\n    'remote1-alias': 'remote1@http://localhost:80801/remoteEntry.js'\n  },\n  dts:{\n    consumeTypes:{\n      remoteTypeUrls: {\n        // remote name\n        remote1:{\n          alias: 'remote1-alias',\n          api:'http://localhost:8081/custom-dir/@mf-types.d.ts',\n          zip:'http://localhost:8081/custom-dir/@mf-types.zip'\n        }\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Runtime Plugin (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a custom runtime plugin in TypeScript. It defines a function that returns a FederationRuntimePlugin object. This plugin has hooks like beforeInit and beforeLoadShare that can be used to modify the runtime behavior. The plugin logs messages to the console before initialization and before loading shared modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/runtimeplugins.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nexport default function (): FederationRuntimePlugin {\n  return {\n    name: 'custom-plugin-build',\n    beforeInit(args) {\n      console.log('[build time inject] beforeInit: ', args);\n      return args;\n    },\n    beforeLoadShare(args) {\n      console.log('[build time inject] beforeLoadShare: ', args);\n\n      return args;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: PluginDtsOptions Interface Definition in TypeScript\nDESCRIPTION: Defines the structure for the `PluginDtsOptions` interface, which allows configuration of type generation and consumption for Module Federation. It includes options to control both `generateTypes` and `consumeTypes` through nested option objects or boolean flags. The `tsConfigPath` property allows specifying a custom TypeScript configuration file and `cwd` set the working directory for compiler\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginDtsOptions {\n  generateTypes?: boolean | DtsRemoteOptions;\n  consumeTypes?: boolean | DtsHostOptions;\n  tsConfigPath?: string;\n  cwd?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Storybook Addon\nDESCRIPTION: These commands install the `@module-federation/storybook-addon` package using either npm or yarn. This addon is required for consuming remote Module Federated apps/components in Storybook.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# with NPM\nnpm install @module-federation/storybook-addon\n\n# with Yarn\nyarn add @module-federation/storybook-addon\n```\n\n----------------------------------------\n\nTITLE: Chunk Flushing (_document.js)\nDESCRIPTION: This JavaScript code snippet demonstrates chunk flushing during SSR to ensure that `<script>` tags for chunks are sent to the browser. It uses `flushChunks` and `FlushedChunks` from `@module-federation/nextjs-mf/utils` to collect and render the required script tags in the document's `<Head>`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\nimport {\n  revalidate,\n  FlushedChunks,\n  flushChunks,\n} from '@module-federation/nextjs-mf/utils';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx.pathname) {\n      if (!ctx.pathname.endsWith('_error')) {\n        await revalidate().then((shouldUpdate) => {\n          if (shouldUpdate) {\n            console.log('should HMR', shouldUpdate);\n          }\n        });\n      }\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n\n    const chunks = await flushChunks();\n\n    return {\n      ...initialProps,\n      chunks,\n    };\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head>\n          <FlushedChunks chunks={this.props.chunks} />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Host App: Importing and Re-exporting Remote Shop Page\nDESCRIPTION: This code demonstrates how to import a remote 'Shop' page into a host Next.js application using module federation. It imports the 'Shop' component and its 'getInitialProps' function from the 'remote/pages/index' module, and re-exports them as the default export of the host page.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport Shop from 'remote/pages/index';\nconst Page = Shop;\nPage.getInitialProps = Shop.getInitialProps;\nexport default Page;\n```\n\n----------------------------------------\n\nTITLE: NextFederationPlugin Configuration with Runtime Plugins\nDESCRIPTION: This snippet shows how to configure the NextFederationPlugin to use runtime plugins, allowing for extensibility and middleware functionality in the module federation setup. It specifies an array of paths to runtime plugin modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// next.config.js\nnew NextFederationPlugin({\n  runtimePlugins: [require.resolve('./path/to/myRuntimePlugin.js')],\n});\n```\n\n----------------------------------------\n\nTITLE: Hard Refresh Implementation\nDESCRIPTION: Implements a hard refresh function in JavaScript to ensure the application serves the most current content to users by unregistering the service worker, clearing the cache, and reloading the webpage.  This function uses `navigator.serviceWorker.getRegistration()` to get the service worker registration and then unregisters it.  Finally, it reloads the window to fetch the latest content.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction hardRefresh() {\n  navigator.serviceWorker.getRegistration().then(async (registration) => {\n    if (!registration) return;\n    await registration.unregister();\n    window.location.reload();\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a remote application\nDESCRIPTION: This command generates a new remote application called 'login' and attaches it to the 'shop' shell. It uses the `@nx/react:remote` generator with the `--host` option. Nx updates the host to configure the new remote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g @nx/react:remote apps/login --host=shop\n```\n\n----------------------------------------\n\nTITLE: Serving the Module Federation setup with dev remotes\nDESCRIPTION: This command serves the 'shop' application, treating the 'products' application as a dev remote.  Nx uses `@rspack/dev-server` to serve the remote application, allowing for HMR and file watching.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve shop --devRemotes=products\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Plugin for Module Federation (TS)\nDESCRIPTION: This snippet shows the implementation of a fallback plugin for Module Federation. It uses the `errorLoadRemote` hook to handle errors, providing a fallback component when a module fails to load. It includes logic to handle both component loading errors and entry file errors, with options to load backup manifests.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// src/runtime-plugin/fallback.ts\nimport type { FederationRuntimePlugin, Manifest } from '@module-federation/runtime';\n\ninterface FallbackConfig {\n  // 备用服务地址\n  backupEntryUrl?: string;\n  // 自定义错误提示\n  errorMessage?: string;\n}\n\nconst fallbackPlugin = (config: FallbackConfig = {}): FederationRuntimePlugin => {\n  const {\n    backupEntryUrl = 'http://localhost:2002/mf-manifest.json',\n    errorMessage = '模块加载失败，请稍后重试'\n  } = config;\n\n  return {\n    name: 'fallback-plugin',\n    async errorLoadRemote(args) {\n      // 处理组件加载错误\n      if (args.lifecycle === 'onLoad') {\n        const React = await import('react');\n        \n        // 创建一个带有错误提示的兜底组件\n        const FallbackComponent = React.memo(() => {\n          return React.createElement(\n            'div',\n            {\n              style: {\n                padding: '16px',\n                border: '1px solid #ffa39e',\n                borderRadius: '4px',\n                backgroundColor: '#fff1f0',\n                color: '#cf1322'\n              }\n            },\n            errorMessage\n          );\n        });\n        \n        FallbackComponent.displayName = 'ErrorFallbackComponent';\n        \n        return () => ({\n          __esModule: true,\n          default: FallbackComponent\n        });\n      }\n      \n      // 处理入口文件加载错误\n      if (args.lifecycle === 'afterResolve') {\n        try {\n          // 尝试加载备用服务\n          const response = await fetch(backupEntryUrl);\n          if (!response.ok) {\n            throw new Error(`Failed to fetch backup entry: ${response.statusText}`);\n          }\n          const backupManifest = await response.json() as Manifest;\n          console.info('Successfully loaded backup manifest');\n          return backupManifest;\n        } catch (error) {\n          console.error('Failed to load backup manifest:', error);\n          // 如果备用服务也失败，返回原始错误\n          return args;\n        }\n      }\n\n      return args;\n    },\n  };\n};\n\nexport default fallbackPlugin;\n\n```\n\n----------------------------------------\n\nTITLE: Complete RetryPlugin Configuration Example (TypeScript)\nDESCRIPTION: This TypeScript code provides a comprehensive example of configuring the RetryPlugin with both fetch and script retry options.  It demonstrates how to specify a URL to retry, a fallback URL, retry times, delay, module names to retry, and a callback function for handling retry failures.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/plugins/retry-plugin.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\ninit({\n  name: 'federation_consumer',\n  remotes: [],\n  plugins: [\n    RetryPlugin({\n      fetch: {\n        // the retry resource url\n        url: 'http://localhost:2001/-mf-manifest.json',\n        // after all retried failed, set a fallback function to guarantee a fallback resource\n        fallback: () => 'http://localhost:2002/mf-manifest.json',\n      },\n      script: {\n        // the retry times\n        retryTimes: 3,\n        // the retry delay\n        retryDelay: 1000,\n        // the module name list that need to be retried, defualt behavior is to retry all modules\n        moduleName: ['remote1'],\n        // the callback function that will be called after all retried failed\n        cb: (resolve, error) => {\n          return setTimeout(() => {\n            resolve(error);\n          }, 2000);\n        },\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Consumer Button Component with usePrefetch\nDESCRIPTION: This code shows how to consume the prefetch data in the consumer application using the `usePrefetch` hook from `@module-federation/enhanced/prefetch`. It imports `Suspense` and `Await` from react and react-router-dom respectively to handle the asynchronous data loading. It also includes a button to re-initiate the prefetch request with new parameters.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Suspense } from 'react';\nimport { usePrefetch } from '@module-federation/enhanced/prefetch';\nimport { Await } from 'react-router-dom';\n\ninterface UserInfo {\n  id: number;\n  title: string;\n};\nconst reFetchParams = {\n  data: {\n    id: 2,\n    title: 'Another Prefetch Title',\n  }\n}\nexport default function Button () {\n  const [prefetchResult, reFetchUserInfo] = usePrefetch<UserInfo>({\n    // Corresponds to (name + expose) in producer ModuleFederationPlugin, for example, `app2/Button` is used for consumption `Button.prefetch.ts`\n    id: 'app2/Button',\n    // Optional parameter, required after using defer\n    deferId: 'userInfo',\n    // default export does not need to pass functionId by default, here is an example, if it is not default export, you need to fill in the function name,\n    // functionId: 'default',\n  });\n\n  return (\n    <>\n      <button onClick={() => reFetchUserInfo(reFetchParams)}>Resend request with parameters</button>\n      <Suspense fallback={<p>Loading...</p>}>\n        <Await\n          resolve={prefetchResult}\n          children={userInfo => (\n            <div>\n              <div>{userInfo.data.id}</div>\n              <div>{userInfo.data.title}</div>\n            </div>\n          )}\n        ></Await>\n      </Suspense>\n    </>\n  )\n};\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation plugin (Bash)\nDESCRIPTION: This command installs the `@module-federation/modern-js` plugin, which provides Module Federation support for Modern.js applications. This is required for both provider and consumer projects.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/modern-js\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Farm\nDESCRIPTION: This configuration snippet demonstrates how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `farm.config.ts` file. The plugins are added to the `plugins` array in the Farm configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// farm.config.ts\nimport { NativeFederationTestsHost, NativeFederationTestsRemote } from '@module-federation/native-federation-tests/farm';\n\nconst config: UserConfig = {\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: RetryPlugin Complete Configuration Example (TypeScript)\nDESCRIPTION: This snippet provides a complete example of configuring the `RetryPlugin` with both `fetch` and `script` retry options. It demonstrates how to specify a fallback URL for fetch retries, configure the number of retry attempts and delay for scripts, and use a callback function after all script retries fail.  This allows fine-grained control over the retry behavior for different resource types and specific modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/retry-plugin.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\ninit({\n  name: 'federation_consumer',\n  remotes: [],\n  plugins: [\n    RetryPlugin({\n      fetch: {\n        // the retry resource url\n        url: 'http://localhost:2001/-mf-manifest.json',\n        // after all retried failed, set a fallback function to guarantee a fallback resource\n        fallback: (url: string) => 'http://localhost:2002/mf-manifest.json',\n      },\n      script: {\n        // the retry times\n        retryTimes: 3,\n        // the retry delay\n        retryDelay: 1000,\n        // the module name list that need to be retried, default behavior is to retry all modules\n        moduleName: ['remote1'],\n        // the callback function that will be called after all retried failed\n        cb: (resolve, error) => {\n          return setTimeout(() => {\n            resolve(error);\n          }, 2000);\n        },\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Workbox Installation\nDESCRIPTION: Installs Workbox as a dev dependency using npm to enhance Progressive Web App capabilities beyond Angular's built-in service worker.  Workbox provides more control over caching strategies and integrates seamlessly with Webpack.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install workbox-webpack-plugin --save-dev\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies (Bash)\nDESCRIPTION: These commands install the `@module-federation/nextjs-mf` and `webpack` packages as development dependencies, and also install the regular dependencies. This is required for enabling Module Federation in the Next.js application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd mfe1\npnpm add @module-federation/nextjs-mf webpack -D\npnpm i\n```\n\n----------------------------------------\n\nTITLE: Consuming Remote Component in Router - TSX\nDESCRIPTION: This example demonstrates how to consume a remote component using `createRemoteComponent` within the host application's router. It loads the remote component using the specified loader and defines a route that renders the remote component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/router.ts\nimport * as bridge from '@module-federation/bridge-vue3';\n\nconst Remote2 = bridge.createRemoteComponent({ loader: () => loadRemote('remote1/export-app'), rootAttrs: {class: 'root-element-class'} });\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    // Define your routes here\n    { path: '/', component: Home },\n    { path: '/remote1/:pathMatch(.*)*', component: Remote2, props: { foo: 'bar' } },\n    // Other routes\n  ],\n});\nexport default router;\n```\n\n----------------------------------------\n\nTITLE: Blocking Component Rendering with Promise in TypeScript\nDESCRIPTION: This code snippet demonstrates how a Promise can block component rendering. The component waits for the setTimeout function to complete before rendering, even if the component content is already loaded.  It highlights the need for deferring data loading in certain cases. This code would need to be placed inside a React component definition to be effective.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport default (params) => (\n  new Promise(resolve => {\n    setTimeout(() => {\n      resolve(params);\n    }, 2000);\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Setting up remote app\nDESCRIPTION: This command configures the secondary (remote) project for Module Federation.  It uses `--type remote` instead of `--type dynamic-host` used for the main application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project login --type remote --port 4201\n```\n\n----------------------------------------\n\nTITLE: Add Server Lifecycle Method (JavaScript)\nDESCRIPTION: This code adds a server lifecycle method (`getServerSideProps` or `getInitialProps`) to the page component. This is necessary for Next.js to treat the page as an SSR page and to handle remote updates.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getServerSideProps = async () => {\n  return {\n    props: {}\n  }\n}\n// or\nIndex.getInitialProps = async ()=> {\n  return {}\n}\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Consume provider's component (TSX)\nDESCRIPTION: This code imports and renders the `Image` component exposed by the provider application.  It demonstrates how to use a remote component within the consumer application's entry page.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport ProviderImage from 'remote/Image';\nimport './index.css';\n\nconst Index = () => (\n  <div className=\"container-box\">\n    <ProviderImage />\n  </div>\n);\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Creating a Retry Plugin (TypeScript)\nDESCRIPTION: This snippet shows how to create a runtime plugin that uses `RetryPlugin`. It imports the `RetryPlugin` from `@module-federation/retry-plugin` and defines a simple plugin that initializes the retry mechanism with empty `fetch` and `script` configurations.  This plugin is then exported for use in the Rsbuild configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/retry-plugin.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/runtime-plugin/retry.ts\nimport { RetryPlugin } from '@module-federation/retry-plugin';\nconst retryPlugin = () => RetryPlugin({\n    fetch: {},\n    script: {}\n})\nexport default retryPlugin;\n```\n\n----------------------------------------\n\nTITLE: RemoteTypeUrls Configuration Example in module-federation.config.ts\nDESCRIPTION: Demonstrates how to configure `remoteTypeUrls` to provide the address of the remote type file when using only the runtime API for loading the producer.  This example simulates fetching the type file address and providing it to Module Federation. The function used to resolve remoteTypeUrls is asynchronous.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig, type moduleFederationPlugin } from '@module-federation/enhanced';\n\nexport default createModuleFederationConfig({\n  // ...\n  remotes: {\n    'remote1-alias': 'remote1@http://localhost:80801/remoteEntry.js'\n  },\n  dts:{\n    consumeTypes:{\n      remoteTypeUrls: async()=>{\n        // Simulate the request interface to obtain the type file address\n        const data = await new Promise<moduleFederationPlugin.RemoteTypeUrls>(resolve=>{\n          setTimeout(()=>{\n            resolve({\n              remote1:{\n                alias: 'remote1-alias',\n                api:'http://localhost:8081/custom-dir/@mf-types.d.ts',\n                zip:'http://localhost:8081/custom-dir/@mf-types.zip'\n              }\n            } )\n          },1000)\n        });\n\n        return data;\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Language Switch Hook - App B\nDESCRIPTION: This code creates a custom hook `useSwitchLanguage` for App B to facilitate language switching.  It exports a function that takes a language ID as input and calls the `changeLanguage` method of the `appBInstance` i18next instance. This hook is then exposed via Module Federation for use in other applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport appBInstance from '../i18n';\n\nconst useSwitchLanguage = () => {\n  return (languageId) => appBInstance.changeLanguage(languageId);\n};\n\nexport default useSwitchLanguage;\n```\n\n----------------------------------------\n\nTITLE: Configure Storybook with Module Federation for NX\nDESCRIPTION: This snippet shows how to configure the Storybook `main.js` file to include the Module Federation addon in NX projects. The `nxModuleFederationConfig` is a placeholder for the actual Module Federation configuration object specifically tailored for NX.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst nxModuleFederationConfig = {\n  // Module Federation config\n};\n\nconst storybookConfig = {\n  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],\n  addons: [\n    // other addons,\n    {\n      name: '@module-federation/storybook-addon',\n      options: {\n        nxModuleFederationConfig,\n      },\n    },\n  ],\n  framework: '@storybook/react',\n  core: {\n    builder: '@storybook/builder-webpack5', // is required webpack 5 builder\n  },\n};\n\nmodule.exports = storybookConfig;\n```\n\n----------------------------------------\n\nTITLE: Remote Module Registration\nDESCRIPTION: Registers remote modules in the `rsbuild.config.ts` file for the host application. This configures Module Federation to consume remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Install Auth0 Angular Package\nDESCRIPTION: This command installs the @auth0/auth0-angular package, which is used for integrating Auth0 authentication into Angular applications.  This is a prerequisite for using Auth0 for authentication in your Angular applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @auth0/auth0-angular\n```\n\n----------------------------------------\n\nTITLE: Load Entry - Module Delegation Plugin in TypeScript\nDESCRIPTION: This example showcases a `loadEntry` plugin for delegating modules. If `remoteInfo.name` is \"delegateModulesA\", it returns an object with `init` (empty function) and `get` functions.  The `get` function dynamically imports modules from `./delegateModulesA.js` based on the requested path.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// delegate-modules-plugin.ts\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'delegate-modules-plugin',\n    loadEntry({ remoteInfo }) {\n      if (remoteInfo.name === \"delegateModulesA\") {\n        return {\n          init(shareScope, initScope, remoteEntryInitOPtions) {},\n          async get(path) {\n            path = path.replace(\"./\", \"\")\n            const {[path]: factory} = await import(\"./delegateModulesA.js\")\n            const result = await factory()\n            return () => result\n          }\n        }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Running Modern.js SSR Demos with PNPM\nDESCRIPTION: This script outlines the steps to set up and run the Modern.js SSR demos. It first installs the necessary dependencies, then builds the modern-js-plugin using nx, and finally starts the development server using pnpm. The development server can be accessed at http://localhost:3050/.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs-ssr/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Root directory\npnpm i\n\nnx build modern-js-plugin\n\npnpm run app:modern:dev\n\nopen http://localhost:3050/\n```\n\n----------------------------------------\n\nTITLE: Implement Login Functionality\nDESCRIPTION: Implements the login functionality in a consumer application's component using the `AuthService` from `@auth0/auth0-angular`. The `loginWithRedirect()` method initiates the authentication process by redirecting the user to the Auth0 login page.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent {\n  user$ = this.auth.user$;\n\n  constructor(private auth: AuthService) {}\n\n  login(): void {\n    this.auth.loginWithRedirect();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration with Workbox (JavaScript)\nDESCRIPTION: This JavaScript code demonstrates how to configure Module Federation in Webpack to share Workbox as a module.  Sharing Workbox ensures it's accessible across all federated modules in the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      // Other Module Federation settings\n      shared: {\n        // Share Workbox configuration as a module\n        'workbox-webpack-plugin': {\n          singleton: true,\n          requiredVersion: 'your-workbox-version'\n        }\n      }\n    })\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Add Module Federation Plugin to Remote (Webpack)\nDESCRIPTION: This TypeScript snippet configures the `ModuleFederationPlugin` for the remote application. It defines the filename for the output JavaScript file, the name of the module, the modules to expose, and the shared dependencies.  It uses `path.resolve` to create absolute paths for the exposed modules.  It imports necessary types and modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomWebpackBrowserSchema, TargetOptions } from '@angular-builders/custom-webpack';\nimport { Configuration, container } from 'webpack';\nimport * as path from 'path';\n\nexport default (config: Configuration, options: CustomWebpackBrowserSchema, targetOptions: TargetOptions) => {\n  // ... existing configuration\n\n  config.plugins.push(\n    new container.ModuleFederationPlugin({\n      filename: \"mf1.js\",\n      name: \"mf1\",\n      exposes: {\n        './Contact': path.resolve(__dirname, './src/app/contact/contact.module.ts'),\n        './Clock': path.resolve(__dirname, './src/app/clock/index.ts'),\n      },\n      shared: {\n        '@angular/animations': {singleton: true, strictVersion: true},\n        // ... other shared modules\n      }\n    })\n  );\n\n  return config;\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Shared Plugin Example\nDESCRIPTION: Demonstrates a custom plugin for managing shared modules in Module Federation. This plugin, using the `resolveShare` hook, overrides the default resolution of the 'react' shared module, allowing to manually provide a factory function for it.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst customSharedPlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'custom-shared-plugin',\n    resolveShare(args) {\n      const { shareScopeMap, scope, pkgName, version, GlobalFederation } = args;\n\n      if (pkgName !== 'react') {\n        return args;\n      }\n\n      // set lib\n      args.resolver = function () {\n        shareScopeMap[scope][pkgName][version] = {\n          lib: ()=>window.React,\n          loaded:true,\n          loading: Promise.resolve(()=>window.React)\n        }; // Manually replace the local share scope with the desired module\n        return shareScopeMap[scope][pkgName][version];\n      };\n\n      // set get\n      args.resolver = function () {\n        shareScopeMap[scope][pkgName][version] = {\n          get: async ()=>()=>window.React,\n        }; // Manually replace the local share scope with the desired module\n        return shareScopeMap[scope][pkgName][version];\n      };\n      return args;\n    },\n  };\n};\n\ninit({\n  name: '@demo/app-main',\n  shared: {\n    react: {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => React,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n  },\n  plugins: [customSharedPlugin()],\n});\n\nwindow.React = () => 'Desired Shared';\n\nloadShare('react').then((reactFactory) => {\n  expect(reactFactory()).toEqual(window.React());\n});\n```\n\n----------------------------------------\n\nTITLE: Producer Prefetch File (Button.prefetch.ts)\nDESCRIPTION: This code defines a prefetch function for the 'Button' module in the producer application. It uses the react-router-dom's defer API to simulate an asynchronous data fetching operation. The function returns a promise that resolves after a 2-second delay. The function is exported as default and takes an optional parameter.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Here, the defer API provided by react-router-dom is used as an example. Whether to use this API can be determined according to needs. Refer to the question \"Why use defer, Suspense, and Await components\"\n// Users can install this package through npm install react-router-dom\nimport { defer } from 'react-router-dom';\n\nconst defaultVal = {\n  data: {\n    id: 1,\n    title: 'A Prefetch Title',\n  }\n};\n\n// Note that the exported function must end with default export or Prefetch to be recognized as a Prefetch function (case insensitive)\nexport default (params = defaultVal) => defer({\n  userInfo: new Promise(resolve => {\n    setTimeout(() => {\n      resolve(params);\n    }, 2000);\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Modify remotes config\nDESCRIPTION: This snippet shows how to modify the `remotes` configuration in the `module-federation.config.ts` file to replace the default published provider with a local provider running on `localhost:3000`. It uses the diff format to highlight the changes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';\n\nexport default createModuleFederationConfig({\n  name: 'mf_consumer',\n  remotes: {\n-   'provider': 'rslib_provider@https://unpkg.com/module-federation-rslib-provider@latest/dist/mf/mf-manifest.json',\n+   'provider': 'rslib_provider@http://localhost:3000/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Disable Runtime Chunk Optimization (Webpack)\nDESCRIPTION: This JavaScript snippet disables the runtime chunk optimization in Webpack. This is a necessary workaround for a known bug that can break the Module Federation setup if left enabled. The `config` object represents the Webpack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.optimization.runtimeChunk = false;\n```\n\n----------------------------------------\n\nTITLE: Loading Remote Module using loadRemote - Javascript\nDESCRIPTION: This code snippet demonstrates how to load a remote module using the `loadRemote` function from the `@module-federation/runtime` library. It assumes that the remote module 'home/exposedModule' is defined in the federation plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/dynamic-remotes.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { loadRemote, init } from '@module-federation/runtime';\n// if i have remotes in my federation plugin, i can pass the name of the remote\nloadRemote('home/exposedModule')\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration for Delegated Modules (TypeScript)\nDESCRIPTION: Module federation configuration to expose the delegateModulesA module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// module-federation-config\n{\n  remotes: {\n    delegateModulesA: \"delegateModulesA@https://delegateModulesA.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies (Bash)\nDESCRIPTION: These commands navigate to the project directory (mfe1 or mfe2), add `@module-federation/nextjs-mf` and `webpack` as development dependencies using pnpm, and then install all project dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd mfe1\npnpm add @module-federation/nextjs-mf webpack -D\npnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd mfe2\npnpm add @module-federation/nextjs-mf webpack -D\npnpm i\n```\n\n----------------------------------------\n\nTITLE: Importing Webpack Bundler Runtime\nDESCRIPTION: This code snippet imports the webpack bundler runtime from `@module-federation/runtime-tools`. This runtime provides webpack-specific functionality for module federation, enabling features like dynamic module loading and dependency management within the webpack environment.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport webpackBundlerRuntime from '@module-federation/runtime-tools/webpack-bundler-runtime';\n```\n\n----------------------------------------\n\nTITLE: Configure Routing for mfe-profile (TypeScript)\nDESCRIPTION: Updates the `app-routing.module.ts` file in the `mfe-profile` application to include a route for the `HomeComponent` and a lazy-loaded route for the `ProfileModule`. This configures the routing for the micro-frontend.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'profile', loadChildren: () => import('./profile/profile.module').then(m => m.ProfileModule) }\n];\n```\n\n----------------------------------------\n\nTITLE: Specifying Module Export for Remote Component\nDESCRIPTION: This snippet illustrates how to specify the exported component from a remote module using the `export` option in `createRemoteComponent`. It demonstrates a scenario where the remote module exports a component named `provider` and shows how to configure the host application to use this specific export.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// remote\nexport const provider = createBridgeComponent({\n  rootComponent: App\n});\n\n// host\nconst Remote1App = createRemoteComponent({\n  loader: () => loadRemote('remote1/export-app'),\n  export: 'provider', // Specify to use provider export\n  fallback: FallbackErrorComp,\n  loading: FallbackComp,\n});\n```\n\n----------------------------------------\n\nTITLE: tsconfig.json Configuration for Type Definitions\nDESCRIPTION: This JSON snippet shows how to configure the `tsconfig.json` file to automatically find type definitions for imports. It adds a `paths` property to the `compilerOptions` to map all imports to the `@mf-types` folder.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"paths\": {\n    \"*\": [\"./@mf-types/*\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Register Module Federation plugin in Rsbuild App\nDESCRIPTION: This code snippet demonstrates how to register the Module Federation plugin in a Rsbuild App project. It defines a configuration object with server settings, React plugin, and the Module Federation plugin with remote modules and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rsbuild.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n\nexport default defineConfig({\n  server: {\n    port: 2000,\n  },\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'federation_consumer',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Handle Sign-In and Sign-Out in the UI (HTML)\nDESCRIPTION: Adds UI logic for sign-in and sign-out buttons in the `app.component.html` template. It uses `*ngIf` to conditionally display the appropriate button based on the authentication state.  The sign-in and sign-out methods are triggered by button clicks.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<li>\n  <button *ngIf=\"(isAuthenticated$ | async) === false; else logout\" (click)=\"signIn()\">\n    Sign In\n  </button>\n\n  <ng-template #logout>\n    <button (click)=\"signOut()\">\n      Sign Out\n    </button>\n  </ng-template>\n</li>\n```\n\n----------------------------------------\n\nTITLE: Specify Package Manager in Angular CLI\nDESCRIPTION: This snippet configures the Angular CLI to use Yarn as the package manager. This configuration is placed in `angular.json` and ensures that the CLI uses the correct package manager for installing dependencies and running scripts.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cli\": {\n    \"packageManager\": \"yarn\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: createBridgeComponent Definition\nDESCRIPTION: Defines the type signature for the `createBridgeComponent` function. This includes the parameter `bridgeInfo` of type `ProviderFnParams<T>`, and the return type, which is a function providing `render` and `destroy` methods.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n/**\n * Create a bridge component for remote loading\n * @param bridgeInfo - Bridge component configuration information\n * @returns Returns a function that provides render and destroy methods\n */\nfunction createBridgeComponent<T>(\n  bridgeInfo: ProviderFnParams<T>\n): () => {\n  render(info: RenderFnParams): Promise<void>;\n  destroy(info: DestroyParams): Promise<void>;\n};\n```\n\n----------------------------------------\n\nTITLE: Integrate StatsPlugin in Webpack Configuration\nDESCRIPTION: Shows how to use the StatsPlugin from @module-federation/manifest in webpack.config.js. This plugin generates statistics for module federation.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { StatsPlugin } from '@module-federation/manifest';\n\nnew StatsPlugin(mfOptions, {\n  pluginVersion: pkg.version,\n  bundler: 'webpack',\n}).apply(compiler);\n```\n\n----------------------------------------\n\nTITLE: Next.js Webpack Configuration (JavaScript)\nDESCRIPTION: This code configures Next.js to use Module Federation via the NextFederationPlugin. It defines the module's name, filename, remotes, shared modules, and extra options. This enables the application to consume remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { NextFederationPlugin } from '@module-federation/nextjs-mf';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config,options ){\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe1',\n        filename: 'static/chunks/remoteEntry.js',\n        remotes: {\n          mfe2: `http://localhost:3001/static/${options.isServer ? 'ssr' : 'chunks'}/remoteEntry.js`,\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n\nexport default nextConfig;\n```\n\n----------------------------------------\n\nTITLE: Usage of mf dts command\nDESCRIPTION: This command is used to generate or fetch TypeScript type declaration files. The `mf dts` command automatically generates or fetches type declaration files based on the configuration in `module-federation.config.ts`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nUsage: mf dts [options]\n\ngenerate or fetch the mf types\n\nOptions:\n  --root <root>         specify the project root directory\n  --output <output>     specify the generated dts output directory\n  --fetch <boolean>     fetch types from remote, default is true (default: true)\n  --generate <boolean>  generate types, default is true (default: true)\n  -c --config <config>  specify the configuration file, can be a relative or absolute path\n  -m --mode <mode>      Specify the runtime environment. You can choose \"dev\" or \"prod\". The default value is \"dev\". After setting, the process.env.NODE_ENV environment variable will be\n                        automatically injected with \"development\" or \"production\" according to the value. (default: \"dev\")\n  -h, --help            display help for command\n```\n\n----------------------------------------\n\nTITLE: Apply Module Federation plugin (TS)\nDESCRIPTION: This configuration in `modern.config.ts` applies the `@module-federation/modern-js` plugin to the Modern.js build process. It also configures runtime, server settings (SSR mode, port), and includes the `appTools` plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3006,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Exposes Configuration in TypeScript\nDESCRIPTION: This code snippet demonstrates a correct configuration for the 'exposes' field within the ModuleFederationPlugin. It's crucial to ensure that all keys in the 'exposes' object start with './' to prevent TypeScript compilation errors during the build process. The code is applicable to modern, rspack, rsbuild, and webpack configurations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/type/TYPE-001.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n    ...\n    // Make sure all keys start with \"./\"\n    exposes: { './Foo': './src/<path-to-file>/Foo.tsx' },\n    ...\n  })\n```\n\n----------------------------------------\n\nTITLE: Create Script Type Definition (TypeScript)\nDESCRIPTION: Defines the types and return values for the `createScript` function, which allows customizing the creation of script elements for remote modules. It specifies the input options including the URL and attributes, and it defines the possible return types including HTMLScriptElement or an object containing the script and a timeout value.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createScript(args: CreateScriptOptions): HTMLScriptElement | {script?: HTMLScriptElement, timeout?: number } | void;\n\ntype CreateScriptOptions = {\n  url: string;\n  attrs?: Record<string, any>;\n};\n```\n\n----------------------------------------\n\nTITLE: Integrating i18next Provider for App A\nDESCRIPTION: This snippet wraps the application components in I18nextProvider, passing the appAInstance to ensure translation contexts are correctly applied. It imports the I18nextProvider and the appAInstance, and then creates a wrapper component that uses the provider to supply the i18n instance to the child components.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// App A Wrapper\nimport { I18nextProvider } from 'react-i18next';\nimport appAInstance from '../i18n';\n\nconst AppAI18nWrapper = ({ children }) => (\n  <I18nextProvider i18n={appAInstance}>{children}</I18nextProvider>\n);\n\nexport default AppAI18nWrapper;\n\n// Repeat similar setup for App B\n```\n\n----------------------------------------\n\nTITLE: Remote Page with getServerSideProps in Next.js\nDESCRIPTION: This code defines a remote page component in Next.js using `getServerSideProps` for data fetching.  It fetches data from an external API and passes it as props to the `Page` component.  This example illustrates how to use server-side data fetching in a federated module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nexport const getServerSideProps = async () => {\n  // Fetch data from external API\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\n  const repo = await res.json()\n  // Pass data to the page via props\n  return { props: { repo } }\n}\n\nexport default function Page({ repo }) {\n  return (\n    <main>\n      <p>{repo.stargazers_count}</p>\n    </main>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetch Data in a React Component using TypeScript\nDESCRIPTION: This code snippet illustrates how to prefetch data within a React component using the `usePrefetch` hook from `@module-federation/enhanced/prefetch`. It demonstrates sending an initial request and resending the request to update data using `reFetchUserInfo`. The fetched data is then used to update the component's state, triggering a re-render.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { usePrefetch } from '@module-federation/enhanced/prefetch';\n\nexport const Button = () => {\n  const [state, setState] = useState(defaultVal);\n  const [userInfoPrefetch, reFetchUserInfo] = usePrefetch<UserInfo>({\n    // Corresponds to (name + expose) in the producer MF configuration, for example, `app2/Button` is used to consume `Button.prefetch.ts`\n    id: 'app2/Button',\n    // Optional parameter, required after using defer\n    deferId: 'userInfo',\n    // default export does not need to pass functionId by default, here is an example, if it is not default export, you need to fill in the function name,\n    // functionId: 'default',\n  });\n\nuseEffect(() => {\n  // General scenario usually sends a request here\n  userInfoPrefetch\n    .then(data => (\n      // Update data\n      setState(data)\n    ));\n  }, []);\n\n  return (\n    <>{state.defaultVal}<>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Auth Library Public API Surface\nDESCRIPTION: This code defines the public API surface for the 'auth' library, exposing the AuthService, IsLoggedGuard, and IsNotLoggedGuard for use by other modules and applications. The `public-api.ts` file is essential for controlling what parts of the library are accessible externally. This approach promotes encapsulation and maintainability of the library.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n * Public API Surface of auth\n */\nexport * from './lib/auth.service';\nexport * from './lib/is-logged.guard';\nexport * from './lib/is-not-logged.guard';\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation Plugin in Rspack\nDESCRIPTION: This snippet demonstrates how to configure the Module Federation plugin in an Rspack configuration file. It shows how to include the `@module-federation/node/runtimePlugin` in the `runtimePlugins` array of the `ModuleFederationPlugin`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst {ModuleFederationPlugin} = require('@module-federation/enhanced/rspack');\n\nnew ModuleFederationPlugin({\n  // other options\n  runtimePlugins: [\n    require.resolve('@module-federation/node/runtimePlugin')\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Loading Module with React Bridge\nDESCRIPTION: This pseudocode demonstrates how to load a remote module using React.lazy and the Bridge utility. It dynamically loads the module, renders it into a div, and ensures proper cleanup on unmount.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/index.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst LazyComponent =  React.lazy(async () => {\n  const m = await loadRemote('remote1/export-app');\n  const providerInfo = m.default;\n  return {\n    default: () => {\n      const rootRef = useRef(null);\n      const providerInfoRef = useRef<any>(null);\n\n      useEffect(() => {\n        const providerReturn = providerInfo();\n        providerInfoRef.current = providerReturn;\n        providerReturn.render(renderProps);\n\n        return () => {\n          providerInfoRef.current?.destroy({\n            dom: renderDom.current,\n          });\n        };\n      }, []);\n      return <div ref={rootRef}></div>;\n    }\n  };\n});\n\nfunction Component () {\n  return (<React.Suspense fallback={<div>loading</div>}>\n  <LazyComponent />\n</React.Suspense>)\n}\n```\n\n----------------------------------------\n\nTITLE: Consume Remote Module in MFE1 (React/JSX)\nDESCRIPTION: This snippet demonstrates how to consume a remote module (Button) exposed by MFE2 in a React component within MFE1. It uses a federated import to import the Button component from 'mfe2/Button' and renders it within the MFE1 component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport Button from 'mfe2/Button'; // federated import\n\nconst Index = () => {\n  return (\n    <div>\n      <h1>MFE1</h1>\n      <Button />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Farm Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Farm. It shows how to import the plugins from `@module-federation/native-federation-typescript/farm` and add them to the `plugins` array in the Farm configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// farm.config.ts\nimport { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } from '@module-federation/native-federation-typescript/farm';\n\nconst config: UserConfig = {\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Module Federation SDK utilities in JavaScript\nDESCRIPTION: This code snippet demonstrates how to import and use various utility functions from the @module-federation/sdk. These functions include parsing entry strings, encoding and decoding module names, generating filenames, creating loggers, checking environment variables, and generating a snapshot from a manifest.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// The SDK can be used to parse entry strings, encode and decode module names, and generate filenames for exposed modules and shared packages.\n// It also includes a logger for debugging and environment detection utilities.\n// Additionally, it provides a function to generate a snapshot from a manifest and environment detection utilities.\nimport { parseEntry, encodeName, decodeName, generateExposeFilename, generateShareFilename, createLogger, isBrowserEnv, isDebugMode, getProcessEnv, generateSnapshotFromManifest } from '@module-federation/sdk';\n\n// Parse an entry string into a RemoteEntryInfo object\nparseEntry('entryString');\n\n// Encode a module name with a prefix and optional extension\nencodeName('moduleName', 'prefix');\n\n// Decode a module name with a prefix and optional extension\ndecodeName('encodedModuleName', 'prefix');\n\n// Generate a filename for an exposed module\ngenerateExposeFilename('exposeName', true);\n\n// Generate a filename for a shared package\ngenerateShareFilename('packageName', true);\n\n// Create a logger\nconst logger = createLogger('identifier');\n\n// Check if the current environment is a browser\nisBrowserEnv();\n\n// Check if the current environment is in debug mode\nisDebugMode();\n\n// Get the process environment\ngetProcessEnv();\n\n// Generate a snapshot from a manifest\ngenerateSnapshotFromManifest(manifest, options);\n```\n\n----------------------------------------\n\nTITLE: TypeScript DtsHostOptions Interface\nDESCRIPTION: This TypeScript interface defines the options for configuring the consumption of TypeScript definition files in a Module Federation host application. It includes settings for specifying the types folder, whether to abort on error, the remote types folder, whether to delete the types folder, the maximum number of retries, and whether to consume API types.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DtsHostOptions {\n  typesFolder?: string;\n  abortOnError?: boolean;\n  remoteTypesFolder?: string;\n  deleteTypesFolder?: boolean;\n  maxRetries?: number;\n  consumeAPITypes?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Producer: src/components/Image.tsx\nDESCRIPTION: This TypeScript file defines the Image component that will be exposed by the producer application. It includes basic styling and an interactive button.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport styles from './Image.module.css';\n\nexport default (): JSX.Element => (\n  <div\n    id=\"remote-components\"\n    style={{\n      backgroundColor: '#1ee9c1',\n      color: 'lightgrey',\n      padding: '1rem',\n    }}\n  >\n    <h2>\n      <strong>remote</strong>&nbsp;image\n    </h2>\n    <button\n      id=\"remote-components-button\"\n      style={{ marginBottom: '1rem' }}\n      onClick={() => alert('[remote-components] Client side Javascript works!')}\n    >\n      Click me to test i'm interactive!\n    </button>\n    <img\n      id=\"remote-components-image\"\n      src=\"https://module-federation.io/module-federation-logo.svg\"\n      style={{ width: '100px' }}\n      alt=\"serge\"\n    />\n    <button className={styles['button']}>Button from remote</button>\n  </div>\n);\n```\n\n----------------------------------------\n\nTITLE: Host Page Re-exporting Remote Page with getServerSideProps in Next.js\nDESCRIPTION: This code demonstrates how to import and re-export a remote page using `getServerSideProps` in a host Next.js application. It imports the remote page's module and then exports both the default component and the `getServerSideProps` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as OtherPage from 'remote/pages/other';\nconst Page = OtherPage.default;\nexport const getServerSideProps = OtherPage.getServerSideProps\nexport default Page;\n```\n\n----------------------------------------\n\nTITLE: Using Local Backup Manifest on Entry File Error\nDESCRIPTION: This snippet demonstrates how to use a predefined local backup manifest when an entry file error occurs. The backup manifest is returned, providing a fallback mechanism for module loading.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nif (args.lifecycle === 'afterResolve') {\n  // Use predefined backup manifest\n  const backupManifest =const backupManifest = {\n     id: 'fallback',\n     name: 'fallback',\n     metaData: {\n       name: 'fallback',\n       type: 'app',\n       buildInfo: {\n         buildVersion: 'local',\n         buildName: 'fallback',\n       },\n       remoteEntry: {\n         name: 'remoteEntry.js',\n         path: '',\n         type: 'global',\n       },\n       types: {\n         path: '',\n         name: '',\n         zip: '@mf-types.zip',\n         api: '@mf-types.d.ts',\n       },\n       globalName: 'fallback',\n       pluginVersion: '1',\n       prefetchInterface: false,\n       publicPath: 'https://example.com/',\n     },\n     shared: [],\n     remotes: [],\n     exposes: [],\n   };\n  return backupManifest;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting an App Module (TSX)\nDESCRIPTION: Illustrates how to export an application as a module using `createBridgeComponent` in a producer project.  The root component (`App.tsx`) is wrapped with `createBridgeComponent` to ensure it conforms to the application-type consumer loading protocol.  This includes automatic `basename` injection and wrapping with an `ErrorBoundary`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.tsx\nimport App from './src/App.tsx';\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nexport default createBridgeComponent({\n  rootComponent: App\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Runtime Plugin in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a custom runtime plugin in TypeScript. It exports a function that returns a `FederationRuntimePlugin` object, which defines lifecycle hooks like `beforeInit` and `beforeLoadShare`. These hooks allow you to inject custom logic into the Module Federation runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/runtimeplugins.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nexport default function (): FederationRuntimePlugin {\n  return {\n    name: 'custom-plugin-build',\n    beforeInit(args) {\n      console.log('[build time inject] beforeInit: ', args);\n      return args;\n    },\n    beforeLoadShare(args) {\n      console.log('[build time inject] beforeLoadShare: ', args);\n      return args;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration Example\nDESCRIPTION: This code provides an example of a `federation.config.js` file. It defines the name of the host, the filename of the remote entry, exposes components, and specifies shared dependencies, including versions and singleton settings.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/esbuild/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst { withFederation, shareAll } = require('@module-federation/esbuild/build');\n\nmodule.exports = withFederation({\n  name: 'host',\n  filename: 'remoteEntry.js',\n  exposes: {\n    './Component': './src/Component',\n  },\n  shared: {\n    react: {\n      singleton: true,\n      version: '^18.2.0',\n    },\n    'react-dom': {\n      singleton: true,\n      version: '^18.2.0',\n    },\n    rxjs: {\n      singleton: true,\n      version: '^7.8.1',\n    },\n    ...shareAll({\n      singleton: true,\n      strictVersion: true,\n      requiredVersion: 'auto',\n      includeSecondaries: false,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: createRemoteComponent Usage Example - TSX\nDESCRIPTION: This code snippet showcases the usage of `createRemoteComponent` to load a remote Vue component. It defines a component called `Remote1App` that loads the remote application exposed as `remote1/export-app`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst Remote1App = createRemoteComponent({ loader: () => loadRemote('remote1/export-app') });\n```\n\n----------------------------------------\n\nTITLE: Login Library Public API (public-api.ts)\nDESCRIPTION: This code defines the public API for the 'login' library, exposing only the LoginModule. This ensures that only the module is exposed and other internal components are encapsulated within the library. This is a different configuration from standard libraries, focusing on exposing modules rather than individual components or services.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// public-api.ts\nexport { LoginModule } from './app/feature/login/login.module';\n```\n\n----------------------------------------\n\nTITLE: Generate Angular Application\nDESCRIPTION: This command uses the Angular CLI to generate a new Angular application named 'login'. It sets the styling to SCSS and includes routing for navigation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nng generate application login --style=scss --routing\n```\n\n----------------------------------------\n\nTITLE: createRemoteComponent Type Definition - TSX\nDESCRIPTION: Defines the type signature for the `createRemoteComponent` function from `@module-federation/bridge-vue3`. This function creates a Vue component that can be loaded from a remote module federation application. It takes an options object with a `loader` function, an optional `export` string, `asyncComponentOptions`, and `rootAttrs`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction createRemoteComponent<T, E extends keyof T>(\n  options: {\n    // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')\n    loader: () => Promise<T>;\n    // Default is 'default', used to specify module export\n    export?: E;\n    // Parameters that will be passed to defineAsyncComponent\n    asyncComponentOptions?: Omit<AsyncComponentOptions, 'loader'>;\n    // Attributes that will be bound to the root container where the remote Vue application will be mounted\n    rootAttrs?: Record<string, unknown>;\n  }\n): (props: {\n    basename?: string;\n    memoryRoute?: { entryPath: string };\n}) => DefineComponent;\n```\n\n----------------------------------------\n\nTITLE: Remote Module Routing Configuration (TypeScript)\nDESCRIPTION: Defines the root route for the remote application's `AppModule`. This simple route navigates to the `HomeComponent` when the application is accessed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const APP_ROUTES: Routes = [\n     { path: '', component: HomeComponent, pathMatch: 'full'}\n ];\n```\n\n----------------------------------------\n\nTITLE: Handling Schema Conflicts with Module Federation\nDESCRIPTION: These commands temporarily switch the bootstrap process to handle conflicts with Angular schemas like `@angular/pwa` and `@angular/material`. They disable async bootstrapping, add the libraries, and then re-enable async bootstrapping.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nng g @angular-architects/module-federation:boot-async false --project [YOUR_MAIN_PROJECT]\nng add [YOUR_LIBRARIES_OF_CHOICE] --project yourProject\nng g @angular-architects/module-federation:boot-async true --project [YOUR_MAIN_PROJECT]\n```\n\n----------------------------------------\n\nTITLE: Register RetryPlugin in Rsbuild Configuration (diff)\nDESCRIPTION: This code snippet demonstrates how to register the RetryPlugin as a runtime plugin within the Rsbuild configuration for Module Federation.  It modifies the rsbuild configuration to include a path to the retry plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/plugins/retry-plugin.mdx#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      ...,\n+     runtimePlugins: [\n+       path.join(__dirname, './src/runtime-plugin/retry.ts'),\n+     ],\n    }),\n  ],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using Local Backup Manifest (TS)\nDESCRIPTION: This snippet illustrates how to use a locally defined backup manifest in case of failures when loading the primary manifest. It creates a hardcoded manifest object and returns it, enabling module federation to continue with fallback definitions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nif (args.lifecycle === 'afterResolve') {\n  // 使用预定义的备用清单\n  const backupManifest = {\n     id: 'fallback',\n     name: 'fallback',\n     metaData: {\n       name: 'fallback',\n       type: 'app',\n       buildInfo: {\n         buildVersion: 'local',\n         buildName: 'fallback',\n       },\n       remoteEntry: {\n         name: 'remoteEntry.js',\n         path: '',\n         type: 'global',\n       },\n       types: {\n         path: '',\n         name: '',\n         zip: '@mf-types.zip',\n         api: '@mf-types.d.ts',\n       },\n       globalName: 'fallback',\n       pluginVersion: '1',\n       prefetchInterface: false,\n       publicPath: 'https://example.com/',\n     },\n     shared: [],\n     remotes: [],\n     exposes: [],\n   };\n  return backupManifest;\n}\n```\n\n----------------------------------------\n\nTITLE: NPM Script to Run All Applications\nDESCRIPTION: Defines NPM script to serve shell and remote applications. The plugin installs an npm script `run:all`, which allows simultaneously serving all applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm run run:all\n# or\nnpm run run:all shell mfe1\n```\n\n----------------------------------------\n\nTITLE: Load JSON Data with loadEntry Hook (TypeScript)\nDESCRIPTION: Demonstrates how to use the `loadEntry` hook to load JSON data as a remote module. It fetches the JSON data from a specified URL and returns it as a module. This example showcases how to treat JSON data as a remotely accessible module within the Module Federation runtime. Imports necessary types from `@module-federation/enhanced/runtime`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// load-json-data-plugin.ts\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'load-json-data-plugin',\n    loadEntry({ remoteInfo }) {\n      if (remoteInfo.jsonA === \"jsonA\") {\n        return {\n          init(shareScope, initScope, remoteEntryInitOPtions) {},\n          async get(path) {\n            const json = await fetch(remoteInfo.entry + \".json\").then(res => res.json())\n            return () => ({\n              path,\n              json\n            })\n          }\n        }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Create Bridge Component in React\nDESCRIPTION: This code snippet demonstrates how to create a bridge component using `createBridgeComponent` from `@module-federation/bridge-react`. It wraps the main `App` component, which uses `BrowserRouter` and `Routes` for client-side routing. The resulting component can then be exposed as a module federation remote.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// ./src/index.tsx\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nfunction App() {\n  return ( <BrowserRouter basename=\"/\">\n    <Routes>\n      <Route path=\"/\" Component={()=> <div>Home page</div>}>\n      <Route path=\"/detail\" Component={()=> <div>Detail page</div>}>\n    </Routes>\n  </BrowserRouter>)\n}\n\nexport default createBridgeComponent({\n  rootComponent: App\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Component with rootAttrs and Props in Router (TypeScript/JSX)\nDESCRIPTION: This snippet demonstrates integrating a remote component using createRemoteComponent into the host application's Vue Router. It shows how to pass props to the remote component and add attributes to the root element of the remote component. Requires `@module-federation/bridge-vue3`, Vue Router, and a `loadRemote` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as bridge from '@module-federation/bridge-vue3';\n\nconst Remote2 = bridge.createRemoteComponent({ loader: () => loadRemote('remote1/export-app'), rootAttrs: {class: 'root-element-class'} });\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    // Define your routes here\n    { path: '/', component: Home },\n    { path: '/remote1/:pathMatch(.*)*', component: Remote2, props: { foo: 'bar' } },\n    // Other routes\n  ],\n});\nexport default router;\n```\n\n----------------------------------------\n\nTITLE: Configure Rsbuild App for Module Federation\nDESCRIPTION: Configures an Rsbuild application to consume remote modules using Module Federation. It defines remotes, shared dependencies (react, react-dom), and specifies the federation_consumer as the module federation name. This configuration also sets the server port to 2000.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/rsbuild-plugin/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n\nexport default defineConfig({\n  server: {\n    port: 2000,\n  },\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'federation_consumer',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Combining importRemote and FederationBoundary\nDESCRIPTION: This example shows how to use `importRemote` with a dynamic URL and `FederationBoundary` to provide a fallback mechanism in case of errors during remote module loading. The `dynamicImporter` uses `importRemote` with a static URL, and `FederationBoundary` provides the fallback component.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/utilities/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// You can also combine importRemote and FederationBoundary to have a dynamic remote URL and a fallback when there is an error on the remote\n\nconst dynamicImporter = () =>\n  importRemote({\n    url: 'http://localhost:3001',\n    scope: 'Foo',\n    module: 'Bar',\n  });\nconst fallback = () => import('@npm/backup').then((m) => m.Component);\n\nconst Bar = () => {\n  return <FederationBoundary dynamicImporter={dynamicImporter} fallback={fallback} />;\n};\n```\n\n----------------------------------------\n\nTITLE: Update Application Component for Authentication (TypeScript)\nDESCRIPTION: Modifies the `app.component.ts` to include sign-in and sign-out logic using Okta libraries. It utilizes `OktaAuthStateService` to manage the authentication state and provides methods for signing in and signing out.  The component also exposes observables for the authentication status and user's name.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component, Inject } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { filter, map, shareReplay } from 'rxjs/operators';\nimport { OKTA_AUTH, OktaAuthStateService } from '@okta/okta-angular';\nimport { OktaAuth } from '@okta/okta-auth-js';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  public isAuthenticated$: Observable<boolean>;\n  public name$: Observable<string>;\n\n  constructor(private oktaStateService: OktaAuthStateService, @Inject(OKTA_AUTH) private oktaAuth: OktaAuth) {\n    this.isAuthenticated$ = this.oktaStateService.authState$\n      .pipe(\n        filter(authState => !!authState),\n        map(authState => authState.isAuthenticated ?? false),\n        shareReplay()\n      );\n\n    this.name$ = this.oktaStateService.authState$\n      .pipe(\n        filter(authState => !!authState && !!authState.isAuthenticated),\n        map(authState => authState.idToken?.claims.name ?? '')\n      );\n  }\n\n  public async signIn(): Promise<void> {\n    await this.oktaAuth.signInWithRedirect();\n  }\n\n  public async signOut(): Promise<void> {\n    await this.oktaAuth.signOut();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Next.js next.config.js Configuration for Remote Consumption\nDESCRIPTION: This snippet illustrates a `next.config.js` file set up to consume remote modules from another Next.js application (named 'next2') using the NextFederationPlugin. It configures the plugin with the application's name ('next1') and the remote application's entry point.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// next.config.js\n\nconst NextFederationPlugin = require('@module-federation/nextjs-mf');\n\nmodule.exports = {\n  webpack(config, options) {\n    const { isServer } = options;\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'next1',\n        remotes: {\n          next2: `next2@http://localhost:3000/_next/static/${\n            isServer ? 'ssr' : 'chunks'\n          }/remoteEntry.js`,\n        },\n      }),\n    );\n\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Add Server Lifecycle (_document.js)\nDESCRIPTION: This JavaScript code defines a custom `_document.js` file that extends the default Next.js Document. It implements the `getInitialProps` method, which is required for SSR and to ensure that Next.js creates a server runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install @module-federation/enhanced using pnpm\nDESCRIPTION: This command installs the @module-federation/enhanced package, which is required for data prefetching, using pnpm. This package needs to be installed in both the producer and host applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Data Loader Implementation (Typescript)\nDESCRIPTION: Implements a Modern.js Data Loader to fetch a list of module federation providers.  It simulates fetching the provider list with a 1-second delay using `setTimeout`. The loader function is responsible for fetching this data and returning it to the component for dynamic remote loading.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LoaderFunctionArgs } from '@modern-js/runtime/router';\n\nexport type DataLoaderRes = {\n    providerList: Array<{\n        name: string,\n        entry: string,\n        id: string;\n    }>\n}\n\nconst fetchProviderList = async () => {\n    const res = await new Promise(resolve => {\n        setTimeout(() => {\n            resolve([\n                {\n                    name: 'dynamic_provider',\n                    entry: 'http://localhost:3008/mf-manifest.json',\n                    id: 'dynamic_provider/Image'\n                }\n            ])\n        }, 1000);\n    });\n\n    return res as DataLoaderRes['providerList']\n}\n\nexport const loader = async ({ request }: LoaderFunctionArgs): Promise<DataLoaderRes> => {\n    console.log('request params', request);\n    const providerList = await fetchProviderList();\n    return {\n        providerList\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Runtime Plugin\nDESCRIPTION: Defines a custom runtime plugin for Module Federation. This plugin logs messages at various stages of the Module Federation lifecycle, such as before initialization, before a request, after resolving a module, on load, and when loading shared modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst runtimePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'my-runtime-plugin',\n    beforeInit(args) {\n      console.log('beforeInit: ', args);\n      return args;\n    },\n    beforeRequest(args) {\n      console.log('beforeRequest: ', args);\n      return args;\n    },\n    afterResolve(args) {\n      console.log('afterResolve', args);\n      return args;\n    },\n    onLoad(args) {\n      console.log('onLoad: ', args);\n      return args;\n    },\n    async loadShare(args) {\n      console.log('loadShare:', args);\n    },\n    async beforeLoadShare(args) {\n      console.log('beforeloadShare:', args);\n      return args;\n    },\n  };\n};\nexport default runtimePlugin;\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration for JSON Data (TypeScript)\nDESCRIPTION: Module federation configuration to expose the json data module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// module-federation-config\n{\n  remotes: {\n    jsonA: \"jsonA@https://cdn.jsdelivr.net/npm/@module-federation/runtime/package\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Register Plugin at Runtime\nDESCRIPTION: Registers a custom runtime plugin dynamically during the application's runtime. This method allows for more flexible plugin management, enabling plugins to be added or removed without requiring a rebuild.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerPlugins } from '@module-federation/enhanced/runtime'\nimport runtimePlugin from 'custom-runtime-plugin.ts';\n\nregisterPlugins([runtimePlugin()]);\n```\n\n----------------------------------------\n\nTITLE: Host Page Re-exporting Remote Page with getInitialProps in Next.js\nDESCRIPTION: This code snippet shows how to re-export a remote page in a host Next.js application. It imports the `Shop` component from the remote module and re-assigns it to a local `Page` variable. The `getInitialProps` method is also re-exported.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport Shop from 'remote/pages/index';\nconst Page = Shop;\nPage.getInitialProps = Shop.getInitialProps;\nexport default Page;\n```\n\n----------------------------------------\n\nTITLE: SSR Document Configuration (JSX)\nDESCRIPTION: This code defines a custom `_document.js` file to ensure server-side rendering (SSR) is enabled. It implements the `getInitialProps` method to initialize the document props, which is necessary for SSR to function correctly in Next.js.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: RetryPlugin Runtime Plugin Implementation (TypeScript)\nDESCRIPTION: This TypeScript code defines a runtime plugin that utilizes the RetryPlugin from `@module-federation/retry-plugin`. It creates a retry plugin instance with empty fetch and script configurations, exporting it as the default export of the module. This plugin can then be registered in the Rsbuild configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/plugins/retry-plugin.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/runtime-plugin/retry.ts\nimport { RetryPlugin } from '@module-federation/retry-plugin';\nconst retryPlugin = () => RetryPlugin({\n    fetch: {},\n    script: {}\n})\nexport default retryPlugin;\n```\n\n----------------------------------------\n\nTITLE: Updating Import Paths to Use the New Library\nDESCRIPTION: This code snippet demonstrates how to update existing import paths to use the newly created 'models' library. This ensures that components and services correctly reference the shared models from the library. The tsconfig.json file should be updated with a path mapping to '@@models' to allow for this import syntax. It replaces the previous relative import path.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// from\nimport { User } from 'src/app/models/user';\n// to\nimport { User } from '@@models';\n```\n\n----------------------------------------\n\nTITLE: Assemble Release Plan Signature - Typescript\nDESCRIPTION: This code snippet shows the function signature of the `assembleReleasePlan` function. It highlights the input parameters, including an array of `NewChangeset`, `Packages` object, and a `Config` object, and specifies that the function returns a `ReleasePlan`.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NewChangeset, Config, ReleasePlan } from \"@changesets/types\";\nimport { Packages } from \"@manypkg/get-packages\";\n\nassembleReleasePlan = (\n  changesets: NewChangeset[],\n  packages: Packages,\n  config: Config\n) => ReleasePlan;\n```\n\n----------------------------------------\n\nTITLE: Assemble Release Plan Usage - Typescript\nDESCRIPTION: This code demonstrates how to use the `@changesets/assemble-release-plan` package to create a release plan. It imports necessary functions from `@changesets/*` and `@manypkg/get-packages`.  It reads changesets, configuration, and package information, then assembles the release plan.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport assembleReleasePlan from \"@changesets/assemble-release-plan\";\nimport readChangesets from \"@changesets/read\";\nimport { read } from \"@changesets/config\";\nimport { getPackages } from \"@manypkg/get-packages\";\nimport { readPreState } from \"@changesets/pre\";\n\nconst packages = await getPackages(cwd);\nconst preState = await readPreState(cwd);\nconst config = await read(cwd, packages);\nconst changesets = await readChangesets(cwd, sinceRef);\n\nconst releasePlan = assembleReleasePlan(changesets, packages, config, preState);\n```\n\n----------------------------------------\n\nTITLE: Loading Backup Manifest on Entry File Error\nDESCRIPTION: This snippet shows how to handle entry file errors by attempting to load a backup manifest from a specified URL. If the backup manifest is successfully loaded, it is returned; otherwise, the original error is returned.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nif (args.lifecycle === 'afterResolve') {\n  try {\n    const response = await fetch('http://localhost:2002/mf-manifest.json');\n    if (!response.ok) {\n      throw new Error(`Failed to fetch backup entry: ${response.statusText}`);\n    }\n    const backupManifest = await response.json();\n    console.info('Successfully loaded backup manifest');\n    return backupManifest;\n  } catch (error) {\n    console.error('Failed to load backup manifest:', error);\n    return args;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Angular Library Generation (models)\nDESCRIPTION: This command uses the Angular CLI to generate a new library named 'models'. It creates a 'projects' folder, installs ng-packagr, and updates angular.json and tsconfig.json to include the new library. The models library will hold independent model files.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng generate library models\n```\n\n----------------------------------------\n\nTITLE: PluginExposesOptions Interface Definition (TypeScript)\nDESCRIPTION: Defines the structure of the `PluginExposesOptions` interface, which is used to configure the exposed modules in Module Federation. It specifies that exposeKey can be a string with a string value or an ExposesConfig object. The ExposesConfig object contains the file entry point.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/exposes.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginExposesOptions {\n  [exposeKey: string]: string | ExposesConfig;\n}\n\ninterface ExposesConfig {\n  // 文件入口\n  import: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Packages with ShareKey in Module Federation\nDESCRIPTION: This code snippet demonstrates how to dangerously share a package using the `shareKey` option in module federation. It's important to note that this method is considered dangerous and should be used with caution, especially when sharing singleton packages, as it can lead to multiple bundling instances per page.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/webpack-bundler-runtime/CHANGELOG.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React 19 Import\nDESCRIPTION: Explicitly specifies React 19 version for `createBridgeComponent`. This is recommended for React 19 projects. It uses `createRoot` and `hydrateRoot` APIs, with legacy render methods completely removed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Explicitly specify React 19 version (recommended for React 19)\nimport { createBridgeComponent } from '@module-federation/bridge-react/v19';\n```\n\n----------------------------------------\n\nTITLE: Register Plugin in rspack Config\nDESCRIPTION: Registers a custom runtime plugin within the rspack configuration.  This approach integrates the plugin during the build process, making it available from the start of the application's runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      // ...\n      runtimePlugins: [path.resolve(__dirname, './custom-runtime-plugin.ts')],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Federation shared dependencies\nDESCRIPTION: This code snippet demonstrates how to configure shared dependencies within a Module Federation plugin.  It sets the `singleton` property to `true` for `react` and `react-dom` to ensure a single instance of these libraries is used across the application, resolving potential React multi-instance issues. This configuration is crucial for avoiding conflicts when different modules rely on the same React instance.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/other.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    ...\n    new ModuleFederationPlugin({\n            ...,\n         // Default basic configuration\n         // shared: [\n         //   'react',\n         //   'react-dom',\n         //   'my-custom-module'\n         // ]\n\n         // Configuration with more specificity\n            shared: {\n                react: { singleton: true, },\n                'react-dom': { singleton: true, },\n                'my-custom-module': { singleton: true, },\n                ...\n            },\n        })\n      ]\n```\n\n----------------------------------------\n\nTITLE: Using importRemote with Asynchronous URL\nDESCRIPTION: This example demonstrates how to use the importRemote function with an asynchronous function that returns the URL. The URL is dynamically retrieved using `MyAsyncMethod`. It showcases usage for both regular JavaScript modules and React components using lazy loading and Suspense.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/utilities/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { importRemote } from '@module-federation/utilities';\n\n// If it's a regular js module:\nimportRemote({\n  url: () => MyAsyncMethod('remote_name'),\n  scope: 'Foo',\n  module: 'Bar',\n}).then(\n  (\n    {\n      /* list of Bar exports */\n    },\n  ) => {\n    // Use Bar exports\n  },\n);\n\n// If Bar is a React component you can use it with lazy and Suspense just like a dynamic import:\nconst Bar = lazy(() =>\n  importRemote({\n    url: () => MyAsyncMethod('remote_name'),\n    scope: 'Foo',\n    module: 'Bar',\n  }),\n);\n\nreturn (\n  <Suspense fallback={<div>Loading Bar...</div>}>\n    <Bar />\n  </Suspense>\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Default Shared Scope for Next.js Modules (TS)\nDESCRIPTION: This code defines a `DEFAULT_SHARE_SCOPE` object, which specifies the default shared modules for a Next.js application using Module Federation. It includes configurations for modules like `next/dynamic`, `next/head`, `react`, and `styled-jsx`, defining their required versions, singleton status, and import behavior.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/presets.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const DEFAULT_SHARE_SCOPE: SharedObject = {\n  'next/dynamic': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/head': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/link': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/router': {\n    requiredVersion: false,\n    singleton: true,\n    import: undefined,\n  },\n  'next/image': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/script': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  react: {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/jsx-dev-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'react/jsx-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'styled-jsx': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/style': {\n    singleton: true,\n    import: false,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/css': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Remote Module Federation Configuration in TypeScript\nDESCRIPTION: This configuration uses the `@module-federation/rsbuild-plugin` to define a remote module federation setup.  It specifies the name of the remote module (`remote1`), exposes a module (`./export-app`), and lists shared dependencies (vue, vue-router). Requires @module-federation/rsbuild-plugin and rsbuild.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginModuleFederation({\n      name: 'remote1',\n      exposes: {\n        './export-app': './src/export-app.ts',\n      },\n      shared: ['vue', 'vue-router'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration with FederatedTypesPlugin (Typescript)\nDESCRIPTION: This code snippet demonstrates how to integrate the `FederatedTypesPlugin` into a webpack configuration file. It configures the plugin with federation options, including remote modules and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport webpack from 'webpack';\nconst { FederatedTypesPlugin } = require('@module-federation/typescript');\n\nconst federationConfig = {\n  name: 'my-app',\n  filename: 'remoteEntry.js',\n  exposes: {\n    //...exposed components\n    './Button': './src/Button',\n    './Input': './src/Input',\n  },\n  remotes: {\n    app2: 'app2@http://localhost:3002/remoteEntry.js', // or Just the URL 'http://localhost:3002'\n  },\n  shared: ['react', 'react-dom'],\n};\n\nmodule.exports = {\n  /* ... */\n  plugins: [\n    // ...\n    new FederatedTypesPlugin({\n      federationConfig,\n      // ...\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configure MFE1 Remotes (JavaScript)\nDESCRIPTION: This is the next.config.js file in MFE1, that configures module federation and maps the remote mfe2 to a URL. This enables MFE1 to consume modules exposed by MFE2.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport { NextFederationPlugin } from '@module-federation/nextjs-mf';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  webpack(config,options ){\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'mfe1',\n        filename: 'static/chunks/remoteEntry.js',\n        remotes: {\n          mfe2: `http://localhost:3001/static/${options.isServer ? 'ssr' : 'chunks'}/remoteEntry.js`,\n        },\n        shared: {},\n        extraOptions: {\n          exposePages: true,\n          enableImageLoaderFix: true,\n          enableUrlLoaderFix: true,\n        },\n      })\n    )\n    return config\n  }\n};\n\nexport default nextConfig;\n```\n\n----------------------------------------\n\nTITLE: Check Node.js Version (Bash)\nDESCRIPTION: This command checks the currently installed version of Node.js. It is used to verify that the Node.js version meets the minimum requirement (>= 16) for the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Federation Plugin with Rsbuild (TSX)\nDESCRIPTION: This snippet demonstrates how to configure the `pluginModuleFederation` with Rsbuild. It sets up remotes, and specifies runtime plugins for handling errors. It includes the necessary imports and configuration for the Rsbuild setup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n      runtimePlugins: [\n        path.join(__dirname, './src/runtime-plugin/retry.ts'),\n        path.join(__dirname, './src/runtime-plugin/fallback.ts'),\n      ],\n      ...\n    }),\n  ],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Configuration with dataPrefetch: true (Producer)\nDESCRIPTION: This code snippet demonstrates setting the `dataPrefetch` flag to `true` in the ModuleFederationPlugin configuration for the producer application. This enables data prefetching for the exposed modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  // ...\n  dataPrefetch: true\n}),\n```\n\n----------------------------------------\n\nTITLE: CSS Module for Styling React Component\nDESCRIPTION: This CSS module provides styling for the `Image.tsx` component, specifically defining the appearance of a button.  It uses CSS Modules to scope the styles locally to the component, preventing naming conflicts.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_3\n\nLANGUAGE: css\nCODE:\n```\n.button {\n  background: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Using importRemote with Static URL\nDESCRIPTION: The importRemote function enables dynamic imports of remotely exposed modules using Module Federation. This example demonstrates how to use it with a static URL, scope, and module name. It shows usage for regular JavaScript modules and ESM modules within a React component, utilizing lazy loading and Suspense for asynchronous handling.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/utilities/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { importRemote } from '@module-federation/utilities';\n\n// --\n// If it's a regular js module:\n// --\nimportRemote({\n  url: 'http://localhost:3001',\n  scope: 'Foo',\n  module: 'Bar',\n}).then(\n  (\n    {\n      /* list of Bar exports */\n    },\n  ) => {\n    // Use Bar exports\n  },\n);\n\n// --\n// If it's a ESM module (this is currently the default for NX):\n// --\nconst Bar = lazy(() => importRemote({ url: 'http://localhost:3001', scope: 'Foo', module: 'Bar', esm: true }));\n\nreturn (\n  <Suspense fallback={<div>Loading Bar...</div>}>\n    <Bar />\n  </Suspense>\n);\n\n// --\n// If Bar is a React component you can use it with lazy and Suspense just like a dynamic import:\n// --\nconst Bar = lazy(() => importRemote({ url: 'http://localhost:3001', scope: 'Foo', module: 'Bar' }));\n\nreturn (\n  <Suspense fallback={<div>Loading Bar...</div>}>\n    <Bar />\n  </Suspense>\n);\n```\n\n----------------------------------------\n\nTITLE: Using createRemoteSSRComponent in a React Component\nDESCRIPTION: Illustrates how to use `createRemoteSSRComponent` within a React component to load and render remote components in a server-side rendering context, including setting up remotes and handling loading and fallback states.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport React, { FC, memo, useEffect } from 'react';\nimport { registerRemotes, createRemoteSSRComponent } from '@modern-js/runtime/mf';\n// The remote declared in the build plug-in can be imported directly at the top level\nimport RemoteComp from 'remote/Image';\n\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  // The remote declared in the build plug-in can also be loaded using this function: loader: () => import('remote/Image'),\n  loader: () => loadRemote('dynamic_remote/Image'),\n  loading: <div>loading...</div>,\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Product: FC = () => {\n  registerRemotes([\n    {\n      name: 'dynamic_remote',\n      entry: 'http://localhost:3008/mf-manifest.json',\n    },\n  ]);\n\n  const fallback = (err: Error) => {\n    if (err.message.includes('does not exist in container')) {\n      return <div>404</div>;\n    }\n    throw err;\n  };\n\n  return <>\n    <RemoteSSRComponent />\n    <RemoteComp />\n  </>;\n};\nexport default Product;\n```\n\n----------------------------------------\n\nTITLE: Applying the Module Federation Plugin\nDESCRIPTION: Demonstrates how to apply the Module Federation plugin within the `modern.config.ts` file, configuring the development port, runtime router, and plugins array.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\nexport default defineConfig({\n  dev: {\n    port: 3005,\n  },\n  runtime: {\n    router: true,\n  },\n  // moduleFederationPlugin is a plug-in for modern.js, which can make certain modifications to the build/runtime\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Applying typescript-transform-paths in tsconfig.json\nDESCRIPTION: This code snippet demonstrates how to apply the `typescript-transform-paths` plugin in the `tsconfig.json` file. This is a solution for issues where the producer generates types containing aliases that cannot be processed by the consumer. It requires installing `typescript-transform-paths` and `ts-patch`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/type/overview.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n{\n  \"compilerOptions\": {\n+   \"plugins\": [\n+     { \"transform\": \"typescript-transform-paths\" },\n+     { \n+       \"transform\": \"typescript-transform-paths\",\n+       \"afterDeclarations\": true\n+     }\n+   ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Rsbuild Consumer Project\nDESCRIPTION: Demonstrates the interactive process of creating an rsbuild consumer project using `npm create module-federation@latest`. It shows the prompts and user inputs during the project creation process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/quick-start.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n➜  ~  ✗ npm create module-federation@latest\n\n> npx\n> create-module-federation\n\n◆  Create Module Federation Project\n│\n◇  Please input Module Federation name:\n│  mf_consumer\n│\n◇  Please select the type of project you want to create:\n│  Application\n│\n◇  Select template\n│  Rsbuild\n│\n◇  Please select the role of project you want to create:\n│  Consumer\n│\n◇  Next steps ─────╮\n│                  │\n│  cd mf_provider  │\n│  npm install     │\n│  npm run dev     │\n│                  │\n├──────────────────╯\n│\n└  Done.\n```\n\n----------------------------------------\n\nTITLE: Load Shared Dependencies with Runtime\nDESCRIPTION: This code demonstrates how to load shared dependencies using the `loadShare` function in the Module Federation runtime. It initializes the runtime with configurations for sharing React and ReactDOM.  It calls `loadShare` to load a specific version and scope of React.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/runtime.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { init, loadRemote, loadShare } from '@module-federation/enhanced/runtime';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [],\n  shared: {\n    react: {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => React,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n    'react-dom': {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => ReactDOM,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n  },\n});\n\nloadShare('react').then((reactFactory) => {\n  console.log(reactFactory());\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Remote Type URLs Configuration\nDESCRIPTION: This TypeScript code snippet shows how to configure the `remoteTypeUrls` option to specify the location of the remote type files. It demonstrates how to dynamically fetch the URLs using an asynchronous function, simulating an API call to retrieve the type file locations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig, type moduleFederationPlugin } from '@module-federation/enhanced';\n\nexport default createModuleFederationConfig({\n  // ...\n  remotes: {\n    'remote1-alias': 'remote1@http://localhost:80801/remoteEntry.js'\n  },\n  dts:{\n    consumeTypes:{\n      remoteTypeUrls: async()=>{\n        // 模拟请求接口获取类型文件地址\n        const data = await new Promise<moduleFederationPlugin.RemoteTypeUrls>(resolve=>{\n          setTimeout(()=>{\n            resolve({\n              remote1:{\n                alias: 'remote1-alias',\n                api:'http://localhost:8081/custom-dir/@mf-types.d.ts',\n                zip:'http://localhost:8081/custom-dir/@mf-types.zip'\n              }\n            } )\n          },1000)\n        });\n\n        return data;\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Custom Webpack Builder in angular.json\nDESCRIPTION: This snippet updates the `angular.json` file to use the `@angular-builders/custom-webpack` builder for both build and serve commands. This allows for specifying a custom Webpack configuration file (`webpack.config.ts`) that will be merged with Angular's default configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"projects\": {\n    \"your-project-name\": {\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-builders/custom-webpack:browser\",\n          \"options\": {\n            \"customWebpackConfig\": {\n              \"path\": \"webpack.config.ts\"\n            }\n          }\n        },\n        \"serve\": {\n          \"builder\": \"@angular-builders/custom-webpack:dev-server\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Entrypoint After Async Startup (JSX)\nDESCRIPTION: Illustrates the simplified entrypoint setup with asynchronous startup enabled in Module Federation. The direct import of the bootstrap file is no longer needed as entrypoints initialize asynchronously. Async initialization avoids eager errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/hoisted-runtime.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// entrypoint\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n<React.StrictMode>\n  <App />\n</React.StrictMode>,\n);\n\n```\n\n----------------------------------------\n\nTITLE: Exposed React Component (Typescript JSX)\nDESCRIPTION: Defines a React component that will be exposed by the module federation provider. This component renders a heading, a button, and an image. The button triggers a client-side alert when clicked, demonstrating client-side interactivity. It utilizes a CSS module for styling the button.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_2\n\nLANGUAGE: typescript jsx\nCODE:\n```\nimport React from 'react';\nimport styles from './Image.module.css';\n\nexport default (): JSX.Element => (\n  <div\n    id=\"remote-components\"\n    style={{\n      backgroundColor: '#c0e91e',\n      color: 'lightgrey',\n      padding: '1rem',\n    }}\n  >\n    <h2>\n      <strong>dynamic remote</strong>&nbsp;image\n    </h2>\n    <button\n      id=\"dynamic-remote-components-button\"\n      style={{ marginBottom: '1rem' }}\n      onClick={() => alert('[remote-components] Client side Javascript works!')}\n    >\n      Click me to test i'm interactive!\n    </button>\n    <img\n      id=\"dynamic-remote-components-image\"\n      src=\"https://module-federation.io/module-federation-logo.svg\"\n      style={{ width: '100px' }}\n      alt=\"serge\"\n    />\n    <button className={styles['button']}>Button from dynamic remote</button>\n  </div>\n);\n```\n\n----------------------------------------\n\nTITLE: Create Button Component in MFE2\nDESCRIPTION: This code defines a simple React component, `Button`, which renders a button with the text \"MFE2 Button\". This component is created in MFE2 and will be exposed for use in MFE1 through Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst Button = () => (\n  <button>MFE2 Button</button>\n);\n\nexport default Button;\n```\n\n----------------------------------------\n\nTITLE: Building Login App as a Library (login-lib)\nDESCRIPTION: This command utilizes the Angular CLI to build the 'login' application into a library format, specifically targeted for module federation. It compiles the application's code, including the LoginModule, into a distributable library that can be consumed by other applications. The library is built according to the settings specified in the angular.json and ng-package.json files.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nng build login-lib\n```\n\n----------------------------------------\n\nTITLE: Fallback Component Implementation (TS)\nDESCRIPTION: This snippet showcases the implementation of a fallback component when the lifecycle is 'onLoad'.  It uses React to create and return a styled div element with a custom error message as a fallback.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nif (args.lifecycle === 'onLoad') {\n  const React = await import('react');\n  const FallbackComponent = React.memo(() => {\n    return React.createElement(\n      'div',\n      {\n        style: {\n          padding: '16px',\n          border: '1px solid #ffa39e',\n          borderRadius: '4px',\n          backgroundColor: '#fff1f0',\n          color: '#cf1322'\n        }\n      },\n      'fallback component'\n    );\n  });\n  FallbackComponent.displayName = 'ErrorFallbackComponent';\n  return () => ({\n    __esModule: true,\n    default: FallbackComponent\n  });\n} \n```\n\n----------------------------------------\n\nTITLE: Start Storybook for Rslib Module\nDESCRIPTION: This command starts the Storybook development environment for the 'rslib-module' package using Nx storybook. Visit http://localhost:6006 to view the stories.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/rslib-module/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnx storybook rslib-module\n```\n\n----------------------------------------\n\nTITLE: Exposes Type Definition (Module Federation, Typescript)\nDESCRIPTION: This snippet defines the TypeScript types for the `exposes` configuration option in Module Federation. It specifies the structure for defining exposed modules and entry points using `ExposesItem` and `ExposesObject` types.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Exposes = (ExposesItem | ExposesObject)[] | ExposesObject;\n\ntype ExposesItem = string;\n\ntype ExposesItems = ExposesItem[];\n\ninterface ExposesObject {\n  [exposeKey: string]: ExposesConfig | ExposesItem | ExposesItems;\n}\n```\n\n----------------------------------------\n\nTITLE: Quick Creation of a Modern.js Provider Project\nDESCRIPTION: Illustrates creating a Modern.js provider project named `provider` in the `my-project` directory using `create-module-federation` with CLI options. This allows skipping the interactive selection process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/quick-start.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-module-federation --dir my-project --template provider-modern --name provider\n\n# Use abbreviations\nnpx create-module-federation -d my-project -t provider-modern -n provider\n```\n\n----------------------------------------\n\nTITLE: Remote Component Integration in Host Router (TypeScript/JSX)\nDESCRIPTION: This code snippet demonstrates integrating a remote component into the host application's Vue Router using `createRemoteComponent` from `@module-federation/bridge-vue3`. It imports the necessary modules, creates a remote component instance, and adds a route for it to the router. It requires `@module-federation/bridge-vue3`, Vue Router, and a `loadRemote` function (assumed to be globally available or imported elsewhere).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/router.ts\nimport * as bridge from '@module-federation/bridge-vue3';\n\nconst Remote1 = bridge.createRemoteComponent({\n  loader: () => loadRemote('remote1/export-app'),\n});\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    // 在这里定义你的路由\n    { path: '/', component: Home },\n    { path: '/remote1/:pathMatch(.*)*', component: Remote1 },\n    // 其他路由\n  ],\n});\nexport default router;\n```\n\n----------------------------------------\n\nTITLE: Enable Data Prefetch in Module Federation Plugin (Consumer) TS\nDESCRIPTION: This TypeScript snippet shows how to enable data prefetching in the consumer application's ModuleFederationPlugin configuration.  Setting `dataPrefetch: true` activates the data prefetch functionality for consuming remote modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n    // ...\n    dataPrefetch: true\n  }),\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin with Shared Dependencies (Array)\nDESCRIPTION: This example demonstrates how to configure the `shared` option in the `ModuleFederationPlugin` using an array. This format is simpler for common scenarios where you just want to share dependencies without specific configurations. It shares `react` and `react-dom` libraries.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/shared.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/button',\n  shared: ['react', 'react-dom'],\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: JSON Default consumeTypes Configuration\nDESCRIPTION: This JSON snippet shows the default configuration that will be generated when the 'consumeTypes' option is set to 'true'. It specifies default values for abortOnError and consumeAPITypes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"abortOnError\": false,\n  \"consumeAPITypes\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Remotes Type Definition (Module Federation, Typescript)\nDESCRIPTION: This snippet defines the TypeScript types for the `remotes` configuration option in Module Federation. It specifies the structure for configuring remote module consumption using `RemotesItem` and `RemotesObject` types.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype Remotes = (RemotesItem | RemotesObject)[] | RemotesObject;\n\ntype RemotesItem = string;\ntype RemotesItems = RemotesItem[];\n\ninterface RemotesObject {\n  [remoteAlias: string]: RemotesConfig | RemotesItem | RemotesItems;\n}\n```\n\n----------------------------------------\n\nTITLE: Import AuthModule in AppModule\nDESCRIPTION: Imports the `AuthModule` from `@auth0/auth0-angular` and configures it within the `AppModule` of an Angular application.  It sets the Auth0 domain and client ID to initialize the authentication service. Replace `YOUR_AUTH0_DOMAIN` and `YOUR_AUTH0_CLIENT_ID` with actual values.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AuthModule } from '@auth0/auth0-angular';\n\n@NgModule({\n  imports: [\n    AuthModule.forRoot({\n      domain: 'YOUR_AUTH0_DOMAIN',\n      clientId: 'YOUR_AUTH0_CLIENT_ID'\n    }),\n    // other imports...\n  ],\n  // other module properties...\n})\nexport class AppModule { }\n```\n\n----------------------------------------\n\nTITLE: Apply Module Federation plugin (Consumer) (TS)\nDESCRIPTION: This configuration in `modern.config.ts` applies the `@module-federation/modern-js` plugin to the Modern.js build process for the consumer application. It also configures runtime, server settings (SSR mode, port), and includes the `appTools` plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3007,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Marking Module Graph as Dirty and GlobalThis Reference\nDESCRIPTION: This snippet details two changes:  First, `globalThis.moduleGraphDirty = true` is added to mark the module graph as dirty when an error is detected.  Second, `new Function('return globalThis')()` is replaced with a direct reference to `globalThis` for improved efficiency and readability.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/nextjs-mf/CHANGELOG.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Remote FlightsModule Creation (TypeScript)\nDESCRIPTION: This snippet defines the `FlightsModule` in the Remote application. This module is responsible for handling flight-related operations. It imports `CommonModule` and configures routing using `RouterModule.forChild` with `FLIGHTS_ROUTES`. The `FlightsSearchComponent` is declared within this module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n   imports: [\n     CommonModule,\n     RouterModule.forChild(FLIGHTS_ROUTES)\n   ],\n   declarations: [\n     FlightsSearchComponent\n   ]\n })\n export class FlightsModule { }\n```\n\n----------------------------------------\n\nTITLE: Service Worker Configuration (ngsw-config.json)\nDESCRIPTION: This JSON configuration file (`ngsw-config.json`) defines caching strategies for an Angular application's service worker. It specifies how different asset groups should be cached and updated, including lazy-loaded modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"main-assets\",\n      \"installMode\": \"prefetch\",\n      \"updateMode\": \"lazy\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/*.css\",\n          \"/main.js\",\n          \"/polyfills.js\",\n          \"/styles.css\",\n          \"/lazy-module-1.js\",\n          \"/lazy-module-2.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"additional-assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(png|jpg|jpeg|svg|gif|webp|woff2|woff|ttf|otf)\"\n        ]\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Hot-Reload Error Handling and Cache Clearing\nDESCRIPTION: This snippet showcases improvements in error handling and cache clearing within the hot-reload utility. It utilizes a try-catch block to manage exceptions during path cache clearing and replaces direct 'module' usage with 'currentChunk' for cache path operations. It also ensures TypeScript compatibility with @ts-ignore annotations.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n- @module-federation/runtime@0.6.13\n- @module-federation/enhanced@0.6.13\n- @module-federation/sdk@0.6.13\n- @module-federation/utilities@3.1.19\n```\n\n----------------------------------------\n\nTITLE: InitOptions Type Definition (TypeScript)\nDESCRIPTION: TypeScript definition of the InitOptions interface used in the `init` function. This configuration defines the name of the consumer, the list of remote modules, and the shared dependencies.  The shared dependencies may require manual version instance injection if not using build plugins.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype InitOptions {\n    //当前消费者的名称\n    name: string;\n    // 依赖的远程模块列表\n    // 使用 version 内容的时候需要配合 snapshot 使用，该内容还在施工中\n    remotes: Array<Remote>;\n    // 当前消费者需要共享的依赖项列表\n    // 当使用构建插件时，用户可以在构建插件中配置需要共享的依赖项，而构建插件会将需要共享的依赖项注入到运行时共享配置中\n    // Shared 在运行时传入时必须在版本实例引用中手动传入，因为它不能在运行时直接传入。\n    shared?: {\n      [pkgName: string]: ShareArgs | ShareArgs[];\n    };\n  };\n\ntype ShareArgs =\n  | (SharedBaseArgs & { get: SharedGetter })\n  | (SharedBaseArgs & { lib: () => Module });\n\ntype SharedBaseArgs = {\n  version: string;\n  shareConfig?: SharedConfig;\n  scope?: string | Array<string>;\n  deps?: Array<string>;\n  strategy?: 'version-first' | 'loaded-first';\n};\n\ntype SharedGetter = (() => () => Module) | (() => Promise<() => Module>);\n\ntype Remote = (RemotesWithEntry | RemotesWithVersion) & RemoteInfoCommon\n\ninterface RemotesWithVersion {\n   name: string;\n   version: string;\n}\n\ninterface RemotesWithEntry {\n   name: string;\n   entry: string;\n}\n\ninterface RemoteInfoCommon {\n  alias?: string;\n  shareScope?: string;\n  type?: RemoteEntryType;\n  entryGlobalName?: string;\n}\n\ntype RemoteEntryType =|'var'|'module'|'assign'|'assign-properties'|'this'|'window'|'self'|'global'|'commonjs'|'commonjs2'|'commonjs-module'| 'commonjs-static'|'amd'|'amd-require'|'umd'|'umd2'|'jsonp'|'system'| string;\n\ntype ShareInfos = {\n   // 依赖的包名、依赖的基本信息和共享策略\n   [pkgName: string]: Share;\n};\n\ntype Share = {\n   // 共享依赖的版本\n   version: string;\n   // 当前依赖再被哪些模块消费\n   useIn?: Array<string>;\n   // 共享依赖来自哪个模块?\n   from?: string;\n   // 获取共享依赖实例的工厂函数。当没有其他已经存在的依赖，将加载它自己的共享依赖项。\n   lib: () => Module;\n   // 共享策略，将使用什么策略来决定依赖项是否复用\n   shareConfig?: SharedConfig;\n   // 共享依赖项所在的作用域下，默认值为 default\n   scope?: string | Array<string>;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Plugin with errorLoadRemote Hook\nDESCRIPTION: This snippet demonstrates the implementation of a fallback plugin using the `errorLoadRemote` hook. It handles both component loading errors (`onLoad` lifecycle) by rendering a fallback component and entry file loading errors (`afterResolve` lifecycle) by attempting to load a backup manifest.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// src/runtime-plugin/fallback.ts\nimport type { FederationRuntimePlugin, Manifest } from '@module-federation/runtime';\n\ninterface FallbackConfig {\n  // Backup service address\n  backupEntryUrl?: string;\n  // Custom error message\n  errorMessage?: string;\n}\n\nconst fallbackPlugin = (config: FallbackConfig = {}): FederationRuntimePlugin => {\n  const {\n    backupEntryUrl = 'http://localhost:2002/mf-manifest.json',\n    errorMessage = 'Module loading failed, please try again later'\n  } = config;\n\n  return {\n    name: 'fallback-plugin',\n    async errorLoadRemote(args) {\n      // Handle component loading errors\n      if (args.lifecycle === 'onLoad') {\n        const React = await import('react');\n        \n        // Create a fallback component with error message\n        const FallbackComponent = React.memo(() => {\n          return React.createElement(\n            'div',\n            {\n              style: {\n                padding: '16px',\n                border: '1px solid #ffa39e',\n                borderRadius: '4px',\n                backgroundColor: '#fff1f0',\n                color: '#cf1322'\n              }\n            },\n            errorMessage\n          );\n        });\n        \n        FallbackComponent.displayName = 'ErrorFallbackComponent';\n        \n        return () => ({\n          __esModule: true,\n          default: FallbackComponent\n        });\n      }\n      \n      // Handle entry file loading errors\n      if (args.lifecycle === 'afterResolve') {\n        try {\n          // Try loading backup service\n          const response = await fetch(backupEntryUrl);\n          if (!response.ok) {\n            throw new Error(`Failed to fetch backup entry: ${response.statusText}`);\n          }\n          const backupManifest = await response.json() as Manifest;\n          console.info('Successfully loaded backup manifest');\n          return backupManifest;\n        } catch (error) {\n          console.error('Failed to load backup manifest:', error);\n          // If backup service also fails, return original error\n          return args;\n        }\n      }\n\n      return args;\n    },\n  };\n};\n\nexport default fallbackPlugin;\n```\n\n----------------------------------------\n\nTITLE: Install Rsbuild Module Federation Plugin\nDESCRIPTION: Installs the @module-federation/rsbuild-plugin as a development dependency using npm. This plugin is required to enable Module Federation capabilities within an Rsbuild project.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/rsbuild-plugin/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @module-federation/rsbuild-plugin -D\n```\n\n----------------------------------------\n\nTITLE: Advanced createRemoteComponent Usage with Export (TypeScript/JSX)\nDESCRIPTION: This snippet demonstrates a more advanced usage of `createRemoteComponent` where a specific export ('provider') from the remote module is loaded.  The remote module provides the 'provider' using createBridgeComponent. Requires `@module-federation/bridge-vue3` and a global or imported `loadRemote` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// remote\nexport const provider = createBridgeComponent({\n  rootComponent: App\n});\n\n// host\nconst Remote1App = createRemoteComponent({\n  loader: () => loadRemote('remote1/export-app'),\n  export: 'provider'\n});\n```\n\n----------------------------------------\n\nTITLE: DtsRemoteOptions Interface Definition in TypeScript\nDESCRIPTION: Defines the structure for configuring type generation in the remote module. This interface allows fine-grained control over type generation, including paths to TypeScript configuration files (`tsConfigPath`), output folders (`typesFolder`), deleting the folder (`deleteTypesFolder`), additional files for compile (`additionalFilesToCompile`), which compiler instance to use (`compilerInstance`), compiling in a separate process (`compileInChildProcess`), generate Federation Runtime API types (`generateAPITypes`), extract third party types (`extractThirdParty`), extract remote types (`extractRemoteTypes`) and whether to throw on error (`abortOnError`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DtsRemoteOptions {\n  tsConfigPath?: string;\n  typesFolder?: string;\n  deleteTypesFolder?: boolean;\n  additionalFilesToCompile?: string[];\n  compilerInstance?: 'tsc' | 'vue-tsc';\n  compileInChildProcess?: boolean;\n  generateAPITypes?: boolean;\n  extractThirdParty?: boolean;\n  extractRemoteTypes?: boolean;\n  abortOnError?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Retry Mechanism with Plugin Registration\nDESCRIPTION: This snippet illustrates how to integrate the `@module-federation/retry-plugin` using plugin registration with Rsbuild. This allows for retry logic configuration within the build process.  It involves modifying the Rsbuild configuration to include a runtime plugin that configures the RetryPlugin.  It shows configuring retry times, delays, and custom callbacks for handling retry attempts.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_1\n\nLANGUAGE: Diff\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n+     runtimePlugins: [\n+       path.join(__dirname, './src/runtime-plugin/retry.ts'),\n+     ],\n      ...\n    }),\n  ],\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/runtime-plugin/retry.ts\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\nconst retryPlugin = () =>\n  RetryPlugin({\n    fetch: {},\n    script: {\n      retryTimes: 3,\n      retryDelay: 1000,\n      cb: (resolve, error) => {\n        return setTimeout(() => {\n          resolve(error);\n        }, 1000);\n      },\n    },\n  });\nexport default retryPlugin;\n```\n\n----------------------------------------\n\nTITLE: Configure Storybook with Module Federation\nDESCRIPTION: This snippet shows how to configure the Storybook `main.js` file to include the Module Federation addon. The `moduleFederationConfig` is a placeholder for the actual Module Federation configuration object.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst moduleFederationConfig = {\n  // Module Federation config\n};\n\nconst storybookConfig = {\n  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],\n  addons: [\n    // other addons,\n    {\n      name: '@module-federation/storybook-addon',\n      options: {\n        moduleFederationConfig,\n      },\n    },\n  ],\n  framework: '@storybook/react',\n  core: {\n    builder: '@storybook/builder-webpack5', // is required webpack 5 builder\n  },\n};\n\nmodule.exports = storybookConfig;\n```\n\n----------------------------------------\n\nTITLE: Import ErrorCodeTitle Component\nDESCRIPTION: This code snippet imports the `ErrorCodeTitle` component from the `@components/ErrorCodeTitle` module. This component is likely used to display the error code and title on the page.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-006.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n```\n\n----------------------------------------\n\nTITLE: Registering Retry Plugin - Rsbuild Configuration\nDESCRIPTION: This code snippet illustrates how to integrate the RetryPlugin with Rsbuild, a build tool. It shows how to modify the Rsbuild configuration to include the module federation plugin and specify a runtime plugin that registers the RetryPlugin.  This allows the retry mechanism to be applied during the build process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n+     runtimePlugins: [\n+       path.join(__dirname, './src/runtime-plugin/retry.ts'),\n+     ],\n      ...\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Data Loader for Fetching Producer Information\nDESCRIPTION: This TypeScript code defines a data loader function that fetches a list of producer configurations. It simulates an asynchronous data fetch using `setTimeout` and returns an array of objects, each containing the name, entry point, and ID of a producer.  The `DataLoaderRes` type defines the structure of the data returned by the loader.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LoaderFunctionArgs } from '@modern-js/runtime/router';\n\nexport type DataLoaderRes = {\n    providerList: Array<{\n        name: string,\n        entry: string,\n        id: string;\n    }>\n}\n\nconst fetchProviderList = async () => {\n    const res = await new Promise(resolve => {\n        setTimeout(() => {\n            resolve([\n                {\n                    name: 'dynamic_provider',\n                    entry: 'http://localhost:3008/mf-manifest.json',\n                    id: 'dynamic_provider/Image'\n                }\n            ])\n        }, 1000);\n    });\n\n    return res as DataLoaderRes['providerList']\n}\n\nexport const loader = async ({ request }: LoaderFunctionArgs): Promise<DataLoaderRes> => {\n    console.log('request params', request);\n    const providerList = await fetchProviderList();\n    return {\n        providerList\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Previewing the production build locally using pnpm\nDESCRIPTION: This command previews the production build of the Rsbuild application locally using pnpm. It allows developers to test the optimized build before deploying it to a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote1-2001/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Building all projects in the Module Federation system\nDESCRIPTION: This command builds all projects in the Module Federation system. Nx will restore cached build artifacts for projects that have not changed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run-many -t build\n```\n\n----------------------------------------\n\nTITLE: Serve SSR Host Application with Dev Remotes\nDESCRIPTION: This command serves the 'dashboard' (host) application with server-side rendering (SSR) enabled and includes the 'login' application as a development remote. This ensures that whenever changes are made to the 'login' application, it will be automatically rebuilt and reflected in the 'dashboard' application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve-ssr dashboard --devRemotes=login\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation Library\nDESCRIPTION: Installs the @module-federation/enhanced library. This dependency provides enhanced features and functionalities for Module Federation implementations.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/rsbuild-plugin/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Bootstrap - Importing and Using JSON Data in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the JSON data loaded from the remote entry `jsonA`. The `jsonA` import contains the JSON data fetched by the `loadEntry` plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// src/bootstrap.js\nimport jsonA from \"jsonA\"\njsonA // {...json data}\n```\n\n----------------------------------------\n\nTITLE: Configuring Retry Options and Type Serving (Typescript)\nDESCRIPTION: This snippet shows how to configure retry options and serve types from a separate HTTP host using `typeServeOptions`. It includes settings for download timeouts, retry attempts, retry delays, and conditions for retrying.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmodule.exports = {\n  /* ... */\n  plugins: [\n    // ...\n    new FederatedTypesPlugin({\n      federationConfig,\n      typeFetchOptions: {\n        /** The maximum time to wait for downloading remote types in milliseconds.\n         * @default 2000  */\n        downloadRemoteTypesTimeout?: number;\n        /** The maximum number of retry attempts.\n         * @default 3  */\n        maxRetryAttempts?: number;\n        /** The default number of milliseconds between retries.\n         * @default 1000  */\n        retryDelay?: number;\n        /** Should retry if no types are found in destination. This could be due to another instance still compiling.\n         * @default true  */\n        shouldRetryOnTypesNotFound?: boolean;\n        /** Should retry type fetching operations.\n         * @default true  */\n        shouldRetry?: boolean;\n      },\n      // Only enable if you need to serve types outside of webpack-dev-server\n      typeServeOptions: {\n        /** The port to serve type files on, this is separate from the webpack dev server port. */\n        port?: number;\n        /** The host to serve type files on. Example: 'localhost' */\n        host?: string;\n      }\n      // ...\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation project using npx with CLI flags\nDESCRIPTION: This command uses npx to execute create-module-federation with specific CLI flags. It allows customization of the project directory, template, and project name.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-module-federation --dir my-project --template provider-modern --name provider\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Plugin (npm)\nDESCRIPTION: This command installs the @module-federation/enhanced package using npm.  This package provides enhanced functionality for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Remote Assets Configuration (ngsw-config.json)\nDESCRIPTION: This JSON configuration defines a caching strategy for remote assets in an Angular service worker setup. It uses a wildcard to cache all JavaScript files from a specific remote URL, addressing potential file name changes in new builds.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"RemoteAssets\",\n  \"installMode\": \"lazy\",\n  \"updateMode\": \"prefetch\",\n  \"resources\": {\n    \"urls\": [\n      \"https://your-remote-container-url/*.js\" // Using a wildcard to cache all JS files\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Nx Workspace\nDESCRIPTION: This command creates a new Nx workspace with the specified organization name. It initializes the workspace with an integrated setup, apps content, and disables distributed caching. This provides a foundation for subsequent application development and module federation setup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-nx-workspace@latest myorganization\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation in Rsbuild (Host)\nDESCRIPTION: This configuration sets up the host application's `rsbuild.config.ts` to use Module Federation Plugin, defining 'remote1' as a remote module located at `http://localhost:2001/mf-manifest.json`. This allows the host to consume modules exposed by the remote application.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react-webpack-plugin/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n//rsbuild.config.ts\nexport default defineConfig({\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      config.output!.uniqueName = 'host';\n      appendPlugins([\n        new ModuleFederationPlugin({\n          name: 'host',\n          remotes: {\n            remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n          },\n        }),\n      ]);\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining PluginRemoteOptions Type - TypeScript\nDESCRIPTION: This code snippet defines the `PluginRemoteOptions` type using TypeScript. It shows the structure of the remote configuration object, where each key represents a remote alias, and its value specifies the location of the remote module federation entry point or manifest.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/remotes.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationInfo = string;\ninterface PluginRemoteOptions {\n  [remoteAlias: string]: ModuleFederationInfo;\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Next.js App Component\nDESCRIPTION: This code defines a custom Next.js App component. It wraps the page 'Component' with the provided 'pageProps'. It also defines a 'getInitialProps' method that extends the default 'App.getInitialProps' method. This allows custom data fetching or logic to be added at the App level.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport App  from 'next/app'\n\nexport default function MyApp({\n  Component,\n  pageProps,\n  example,\n}) {\n  return (\n    <>\n      <Component {...pageProps} />\n    </>\n  )\n}\n\nMyApp.getInitialProps = async (context) => {\n  const ctx = await App.getInitialProps(context)\n\n  return { ...ctx }\n}\n```\n\n----------------------------------------\n\nTITLE: Building the app for production using pnpm\nDESCRIPTION: This command builds the Rsbuild application for production using pnpm. It optimizes the code and assets for deployment, ensuring optimal performance in a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote1-2001/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation Project\nDESCRIPTION: This snippet shows how to use the `create-module-federation` tool with npm to create a new Module Federation project. It creates a new project interactively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm create module-federation@latest\n```\n\n----------------------------------------\n\nTITLE: Preloading Remote Modules\nDESCRIPTION: Demonstrates how to preload remote modules using the `preloadRemote` function to avoid waterfall requests. This example shows how to preload different modules, filter assets, and specify dependencies. Note that `preloadRemote` is effective only when using `mf-manifest.json` as the entry.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, preloadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/preload-remote',\n  remotes: [\n    {\n      name: '@demo/sub1',\n      entry: 'http://localhost:2001/mf-manifest.json',\n    },\n    {\n      name: '@demo/sub2',\n      entry: 'http://localhost:2002/mf-manifest.json',\n    },\n    {\n      name: '@demo/sub3',\n      entry: 'http://localhost:2003/mf-manifest.json',\n    },\n  ],\n});\n\n// Preload @demo/sub1 模块\n// 过滤资源名称中包含 ignore 的资源信息\n// 只预加载子依赖的 @demo/sub1-button 模块\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub1',\n    filter(assetUrl) {\n      return assetUrl.indexOf('ignore') === -1;\n    },\n    depsRemote: [{ nameOrAlias: '@demo/sub1-button' }],\n  },\n]);\n\n// Preload @demo/sub2 模块\n// 预加载 @demo/sub2 下的所有 expose\n// 预加载 @demo/sub2 的同步和异步资源\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub2',\n    resourceCategory: 'all',\n  },\n]);\n\n// 预加载 @demo/sub3 模块的 add expose\npreloadRemote([\n  {\n    nameOrAlias: '@demo/sub3',\n    resourceCategory: 'all',\n    exposes: ['add'],\n  },\n]);\n```\n\n----------------------------------------\n\nTITLE: Displaying available CLI commands\nDESCRIPTION: This command is used to display all available commands for the Module Federation CLI. It provides a list of commands that can be used with the CLI tool, along with a brief description of each.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx mf -h\n```\n\n----------------------------------------\n\nTITLE: Dynamically Load Workbox Service Worker in Angular\nDESCRIPTION: This TypeScript snippet shows how to dynamically import and register the Workbox service worker in an Angular application's `main.ts` file. It checks if the browser supports service workers and then uses `workbox-window` to simplify the registration process. The service worker file is assumed to be named `/service-worker.js`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Workbox } from 'workbox-window';\n\nif ('serviceWorker' in navigator) {\n  const wb = new Workbox('/service-worker.js');\n\n  wb.register();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining remotes in ModuleFederationConfig\nDESCRIPTION: This Javascript code snippet demonstrates how to define remote applications in the `remotes` option of the `ModuleFederationConfig`, including specifying the Nx project name and the entry location for the remote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nremotes: [\"products\", [\"cart\", \"http://my-live-cart.myapp.com/mf-manifest.json\"]] \n```\n\n----------------------------------------\n\nTITLE: Eager/Sync Import of Remote Components - JavaScript\nDESCRIPTION: This code snippet demonstrates how to eagerly/synchronously import components and hooks from a remote module.  It uses `require` and standard ES6 `import` statements. The `require` call also handles the case where the module may not have a `default` export, ensuring compatibility.  It's generally recommended to use dynamic imports when possible.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-components.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet SomeHook = require('next2/someHook');\nSomeHook = SomeHook.default || SomeHook;\n\nimport SomeComponent, {NamedExportComponent} from 'next2/sampleComponent';\n```\n\n----------------------------------------\n\nTITLE: Loading a Remote Application (TSX)\nDESCRIPTION: Illustrates how to load a remote application module using `createRemoteComponent` in a consumer project. It defines fallback and loading components, and uses `createRemoteComponent` to create a remote component instance.  The component is then used within a `BrowserRouter` and `Routes` to render the remote application at a specific route.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/App.tsx\nimport { createRemoteComponent } from '@module-federation/bridge-react';\nimport { loadRemote } from '@module-federation/runtime';\n\n// 定义错误回退组件\nconst FallbackErrorComp = ({ error }) => {\n  return (\n    <div>\n      <h1>加载远程组件时出错</h1>\n      <p>{error.message}</p>\n      <button onClick={() => window.location.reload()}>\n        重试\n      </button>\n    </div>\n  );\n};\n\n// 定义加载中组件\nconst FallbackComp = <div data-test-id=\"loading\">加载中...</div>;\n\n// 使用 createRemoteComponent 创建远程组件\nconst Remote1App = createRemoteComponent({\n  // loader 用于加载远程模块，例如：loadRemote('remote1/export-app')，import('remote1/export-app')\n  loader: () => loadRemote('remote1/export-app'),\n  // fallback 用于在远程模块加载失败时显示的组件\n  fallback: FallbackErrorComp,\n  // loading 用于在加载远程模块时显示的组件\n  loading: FallbackComp,\n});\n\nconst App = () => {\n  return (\n    <BrowserRouter basename=\"/\">\n      <Routes>\n        <Route path=\"/\" Component={Home} />\n        <Route\n          path=\"/remote1/*\"\n          // 使用 Remote1App 组件，将会被懒加载\n          Component={() => (\n            <Remote1App\n              // 设置远程应用的 basename\n              basename=\"/remote1\"\n              // 其他属性将传递给远程组件\n              props1={'props_value'}\n              props2={'another_props_value'}\n            />\n          )}\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This command installs the required dependencies for the Rsbuild project using the pnpm package manager. It ensures that all necessary packages are available for development, building, and running the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-vue3-2100/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing the Plugin\nDESCRIPTION: This command installs the `@module-federation/typescript` package from npm.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm i @module-federation/typescript\n```\n\n----------------------------------------\n\nTITLE: Importing Remote Component with React.lazy and window API\nDESCRIPTION: This code showcases different methods for importing remote components in a Next.js application.  It demonstrates using `React.lazy` with the `window` API to fetch and render a remote component, as well as using a simplified `import` statement.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/nextjs.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { lazy } from 'react';\n\nconst SampleComponent = lazy(() =>\n  window.next2.get('./sampleComponent').then((factory) => {\n    return { default: factory() };\n  }),\n);\n\n// or\n\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n\n//or\n\nimport Sample from 'next2/sampleComponent';\n```\n\n----------------------------------------\n\nTITLE: Registering RetryPlugin at Runtime (TypeScript)\nDESCRIPTION: This example shows how to register the `RetryPlugin` directly at runtime using the `init` function from `@module-federation/enhanced/runtime`. The `RetryPlugin` is added to the `plugins` array within the `init` configuration, providing a way to enable resource retry after the application has started. This approach requires the application to successfully initialize before retries can be enabled.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/retry-plugin.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\ninit({\n  name: 'federation_consumer',\n  remotes: [],\n  plugins: [\n    RetryPlugin({\n      fetch: {},\n      script: {},\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This command starts the development server for the Rsbuild project using pnpm. It's used for local development and provides features like hot module replacement for faster iteration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-v5-2200/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Running impacted tests using nx\nDESCRIPTION: This snippet runs tests only for the projects affected by recent changes using nx. This optimizes testing by focusing on relevant projects. Dependencies: nx.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx affected -t test --parallel=3 --exclude='*,!tag:type:pkg'\n```\n\n----------------------------------------\n\nTITLE: Preview production build using pnpm\nDESCRIPTION: This command starts a local server to preview the production build of the Modern.js application. It allows developers to test the application before deploying it to a live environment.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/modern-common/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm serve\n```\n\n----------------------------------------\n\nTITLE: NX Project Webpack Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the Module Federation Storybook addon within an NX project's `webpack.config.js`. It replaces NX's `withModuleFederation` utility with the one provided by the addon.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { composePlugins, withNx } = require('@nx/webpack');\nconst { withReact } = require('@nx/react');\nconst { withModuleFederation } = require('@module-federation/storybook-addon');\n\nconst baseConfig = require('./module-federation.config');\n\nconst config = {\n  ...baseConfig,\n};\n\nmodule.exports = composePlugins(withNx(), withReact(), withModuleFederation(config));\n```\n\n----------------------------------------\n\nTITLE: Create Bootstrap File\nDESCRIPTION: This code snippet shows the content of the bootstrap.js file.  It imports React, ReactDOM, and the App component, then renders the App component into the 'root' element in the DOM. This file will be used as the asynchronous entry point.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/src/components/en/EnableAsyncEntry.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n----------------------------------------\n\nTITLE: Workbox Webpack Configuration\nDESCRIPTION: Configures Workbox as a plugin in the Webpack configuration to align service worker strategies with the distributed nature of Module Federation.  This ensures efficient and precise service worker management within Webpack configurations by generating a service worker file using the `workbox-webpack-plugin`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/service-workers-mf.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { GenerateSW } = require('workbox-webpack-plugin');\n\nmodule.exports = {\n  // ... other webpack config relevant to Module Federation\n  plugins: [\n    new GenerateSW({\n      // Configurations specific to your Module Federation setup\n      // these options encourage the ServiceWorkers to get in there fast\n      // and not allow any straggling \"old\" SWs to hang around\n      clientsClaim: true,\n      skipWaiting: true,\n    })\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: usePrefetch Hook Type Definition\nDESCRIPTION: This code defines the type signature for the `usePrefetch` hook's options and return value. The options include the `id` (module name), `functionId` (prefetch function name), `deferId` (defer key), and `cacheStrategy` (cache update logic). The return value is a tuple containing the prefetch result (Promise) and a refetch function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntype Options: <T>{\n  id: string; // Required, corresponding to (name + expose) in the producer MF configuration, for example, `app2/Button` is used to consume `Button.prefetch.ts`.\n  functionId?: string; // Optional (default is default), used to get the name of the function exported in the .prefetch.ts file, the function needs to end with Prefetch (case insensitive)\n  deferId?: string; // Optional (required after using defer), after using defer, the function return value is an object (there can be multiple keys in the object corresponding to multiple requests), deferId is a key in the object, used to get the specific request\n  cacheStrategy?: () => boolean; // Optional, generally not manually managed, managed by the framework, used to control whether to update the request result cache, currently after the component is uninstalled or the reFetch function is manually executed, the cache will be refreshed\n} => [\n  Promise<T>,\n  reFetch: (refetchParams?: refetchParams) => void, // Used to re-initiate a request, often used in scenarios where the interface needs to re-request data after the internal state of the component is updated. Calling this function will re-initiate a request and update the request result cache\n];\n\ntype refetchParams: any; // Used to re-initiate requests with parameters in components\n```\n\n----------------------------------------\n\nTITLE: Add paths to tsconfig.json for type consumption\nDESCRIPTION: This snippet configures the TypeScript compiler to look for type definitions in the `@mf-types` directory. This is necessary for the consumer application to find and use the type definitions exposed by the remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/type-prompt.mdx#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project with CLI options\nDESCRIPTION: This bash snippet demonstrates how to create a Module Federation project using `create-module-federation` with CLI options. It creates a Modern.js provider project named 'provider' in the 'my-project' directory.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-module-federation --dir my-project --template provider-modern --name provider\n\n# 使用缩写\nnpx create-module-federation -d my-project -t provider-modern -n provider\n```\n\n----------------------------------------\n\nTITLE: Building for Production with pnpm\nDESCRIPTION: This command builds the Modern.js application for production, optimizing the code and assets for deployment.  It generates the final distributable files.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Installing @module-federation/esbuild\nDESCRIPTION: Installs the @module-federation/esbuild package using npm. This is a prerequisite for using the Module Federation plugin with esbuild.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/esbuild/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @module-federation/esbuild\n```\n\n----------------------------------------\n\nTITLE: Rspack Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Rspack. It shows how to import the plugins from `@module-federation/native-federation-typescript/rspack` using `require` and add them to the `plugins` array in the Rspack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// rspack.config.js\nconst { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } = require('@module-federation/native-federation-typescript/rspack');\nmodule.exports = {\n  /* ... */\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Consumer: tsconfig.json\nDESCRIPTION: This JSON file configures the TypeScript compiler to include the producer's type definitions by adding a path alias.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./@mf-types/*\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating useIsRemote Hook\nDESCRIPTION: This code defines a custom hook `useIsRemote` to determine if the current application is running as a remote (embedded) or standalone application. It checks for URL parameters and/or DOM elements to make the determination. The hook returns a boolean value indicating whether the application is running remotely.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useEffect, useState } from 'react';\n\n/**\n * Determines if the current application is running as a remote (embedded)\n * or as a standalone application.\n *\n * You should adapt the logic based on the specific criteria that apply to your application's\n * architecture, such as checking for specific URL parameters or the presence\n * of a particular DOM element that would only exist when embedded.\n */\nconst useIsRemote = () => {\n  const [isRemote, setIsRemote] = useState(false);\n\n  useEffect(() => {\n    // Check for a URL parameter that indicates embedding\n    const searchParams = new URLSearchParams(window.location.search);\n    setIsRemote(searchParams.has('embedded'));\n\n    // Alternatively, check for a global variable or a specific DOM element\n    // setIsRemote(window.parent !== window || document.getElementById('embed-flag') !== null);\n  }, []);\n\n  return isRemote;\n};\n\nexport default useIsRemote;\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with esbuild\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins with `esbuild`. The plugins are added within the `build` function's configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// esbuild.config.js\nimport { build } from 'esbuild';\nimport { NativeFederationTestsHost, NativeFederationTestsRemote } from '@module-federation/native-federation-tests/esbuild';\n\nbuild({\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Running all tests using nx\nDESCRIPTION: This snippet runs all test suites within the Module Federation project using the nx build system. The `--parallel=3` flag allows for parallel execution of up to 3 test suites, improving testing speed. Dependencies: nx.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run-many -t test --parallel=3\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation via Yarn\nDESCRIPTION: This command installs the `@module-federation/enhanced` package using Yarn. This package is necessary to enable data prefetching in Module Federation setups for both producer and consumer applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Initializing i18next Instance - App A\nDESCRIPTION: This code snippet initializes a separate `i18next` instance for App A using the `react-i18next` library. It imports translation resources and configures the instance with a default language, fallback language, and interpolation settings. It avoids translation overwrites.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// App A\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport enJSON from './translations/en';\nimport uaJSON from './translations/ua';\n\n// Translation resources\nconst resources = {\n  en: { translation: enJSON },\n  ua: { translation: uaJSON },\n};\n\n// Initialize i18next instance for App A\nconst appAInstance = i18n.createInstance();\nappAInstance.use(initReactI18next).init({\n  resources,\n  lng: 'en', // default language\n  fallbackLng: 'en',\n  interpolation: { escapeValue: false },\n  react: { useSuspense: true },\n});\n\nexport default appAInstance;\n\n// Repeat similar setup for App B with a separate instance\n```\n\n----------------------------------------\n\nTITLE: Modifying Original Entry File JavaScript\nDESCRIPTION: This code snippet modifies the original entry file ('index.js') to dynamically import the 'bootstrap.js' file. It removes the original React-related imports and rendering logic. This makes the entry point asynchronous.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/src/components/zh/EnableAsyncEntry.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n+ import('./bootstrap');\n- import React from 'react';\n- import ReactDOM from 'react-dom';\n- import App from './App';\n- ReactDOM.render(<App />, document.getElementById('root'));\n```\n\n----------------------------------------\n\nTITLE: Update TypeScript Import Path\nDESCRIPTION: This code snippet shows how to update import paths in TypeScript files to use the newly created 'models' library.  It replaces the old relative path with the new path specified in tsconfig.json, typically prefixed with '@@'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// from\nimport { User } from 'src/app/models/user';\n// to\nimport { User } from '@@models';\n```\n\n----------------------------------------\n\nTITLE: Updating App.tsx in MFE1 to consume remote module\nDESCRIPTION: This code updates the `App.tsx` file in `MFE1` to import and render the `Button` component from the remote module (`MFE2`).  It uses a federated import to access the exposed component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport Button from 'remote/Button'; // federated import\n\nfunction App() {\n  return (\n    <div>\n      <h1>MFE1</h1>\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Shared Type Definition (Module Federation, Typescript)\nDESCRIPTION: This snippet defines the TypeScript types for the `shared` configuration option in Module Federation. It specifies the structure for sharing common dependencies between consumers and producers using `SharedItem` and `SharedObject` types.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype Shared = (SharedItem | SharedObject)[] | SharedObject;\n\ntype SharedItem = string;\n\ninterface SharedObject {\n  [k: string]: SharedConfig | SharedItem;\n}\n```\n\n----------------------------------------\n\nTITLE: Consumer: modern-app-env.d.ts\nDESCRIPTION: This TypeScript declaration file adds a reference to the `@module-federation/modern-js/types` to provide runtime type support for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types='@module-federation/modern-js/types' />\n```\n\n----------------------------------------\n\nTITLE: Create Next.js App (Bash)\nDESCRIPTION: This command uses `create-next-app` to scaffold a new Next.js project. The user is prompted to name the project and choose whether to use the App Router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app@latest\n\n\"What is your project named?\":\n> mfe1\n\n\"Would you like to use App Router?\":\n> No\n```\n\n----------------------------------------\n\nTITLE: Start Development Server with pnpm\nDESCRIPTION: This command starts the development server for the Rsbuild project using pnpm. It enables hot module replacement and provides a development environment for making changes to the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote2-2002/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Exporting Module with React Bridge\nDESCRIPTION: This pseudocode demonstrates how to export a React module using the Bridge utility. It creates a root element for rendering the React application within a given DOM element and provides a destroy method for unmounting the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/index.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function () {\n  const rootMap = new Map<any, ReactDOM.Root>();\n  return {\n    render(info: { dom: HTMLElement; basename?: string; memoryRoute?: { entryPath: string; } }) {\n      const root = ReactDOM.createRoot(info.dom);\n      rootMap.set(info.dom, root);\n      root.render(\n        <App />,\n      );\n    },\n    destroy(info: { dom: HTMLElement }) {\n      const root = rootMap.get(info.dom);\n      root?.unmount();\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Modern.js consumer project (Bash)\nDESCRIPTION: This command uses `@modern-js/create` to initialize a new Modern.js consumer project named `modern-consumer`.  It creates a basic project structure with default settings.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modern-js/create@latest modern-consumer\n```\n\n----------------------------------------\n\nTITLE: Flights Module Definition (TypeScript)\nDESCRIPTION: Defines the `FlightsModule`, which handles flight-related functionalities. It imports `CommonModule` and configures routing using `RouterModule.forChild` with the `FLIGHTS_ROUTES`. The module declares the `FlightsSearchComponent`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n   imports: [\n     CommonModule,\n     RouterModule.forChild(FLIGHTS_ROUTES)\n   ],\n   declarations: [\n     FlightsSearchComponent\n   ]\n })\n export class FlightsModule { }\n```\n\n----------------------------------------\n\nTITLE: Install React Bridge library\nDESCRIPTION: This command installs the `@module-federation/bridge-react` package as a dependency using pnpm. This library facilitates routing between federated modules.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/bridge-react\n```\n\n----------------------------------------\n\nTITLE: Enable Debug Mode in Browser and Node.js (JavaScript)\nDESCRIPTION: This snippet demonstrates how to enable debug mode in both browser and Node.js environments. For browsers, it sets 'debug' and 'debug:stack' keys to 'true' in localStorage. For Node.js, it sets the DEBUG environment variable to 'true'. This allows for more detailed logging and debugging information during development.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-shared/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// browser\nlocalStorage.setItem('debug', 'true');\nlocalStorage.setItem('debug:stack', 'true');\n\n// node\nprocess.env.DEBUG = 'true';\n```\n\n----------------------------------------\n\nTITLE: Build-time Plugin Registration in rspack.config.ts\nDESCRIPTION: This code snippet illustrates how to register a custom runtime plugin during build time within the rspack configuration file. It demonstrates how to use the `ModuleFederation` plugin to include the custom plugin by specifying the path to the plugin file in the `runtimePlugins` array.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      // ...\n      runtimePlugins: [path.resolve(__dirname, './custom-runtime-plugin.ts')],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified Fallback Plugin with Generic Error Handling\nDESCRIPTION: This snippet shows a simplified version of the fallback plugin that provides generic error handling without distinguishing between error types. It renders a fallback component with a predefined error message when module loading fails.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/runtime';\n\nconst fallbackPlugin = (errorMessage = 'Module loading failed, please try again later'): FederationRuntimePlugin => {\n  return {\n    name: 'fallback-plugin',\n    async errorLoadRemote() {\n      const React = await import('react');\n      const FallbackComponent = React.memo(() => {\n        return React.createElement(\n          'div',\n          {\n            style: {\n              padding: '16px',\n              border: '1px solid #ffa39e',\n              borderRadius: '4px',\n              backgroundColor: '#fff1f0',\n              color: '#cf1322'\n            }\n          },\n          errorMessage\n        );\n      });\n      FallbackComponent.displayName = 'ErrorFallbackComponent';\n      return () => ({\n        __esModule: true,\n        default: FallbackComponent\n      });\n    },\n  };\n};\nexport default fallbackPlugin;\n```\n\n----------------------------------------\n\nTITLE: Fetch Manifest Type Definition (TypeScript)\nDESCRIPTION: Defines the type definition for the `fetch` hook function.  This function enables customization of the request used to fetch the manifest JSON. A valid JSON `Response` must be returned. It takes the manifest URL and request initialization options as arguments and should return a Promise that resolves to a Response or void or false.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nfunction fetch(manifestUrl: string, requestInit: RequestInit): Promise<Response> | void | false;\n```\n\n----------------------------------------\n\nTITLE: Building only affected projects\nDESCRIPTION: This command rebuilds only the projects that have actually been changed. Nx offers this command to reduce the time spent restoring cached build artifacts.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx affected -t build\n```\n\n----------------------------------------\n\nTITLE: React Bridge Module Loading Example\nDESCRIPTION: This code demonstrates how to load a remote React application module using React.lazy and the Bridge pattern.  It dynamically loads the remote module, gets the provider info, and then renders the application within a div.  It also handles unmounting the remote application when the component unmounts.  The `loadRemote` function is assumed to be a Module Federation function to load remote modules. The renderProps contains information that is passed to the remote component for proper rendering, such as the DOM element to render into.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/index.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst LazyComponent =  React.lazy(async () => {\n  const m = await loadRemote('remote1/export-app');\n  const providerInfo = m.default;\n  return {\n    default: () => {\n      const rootRef = useRef(null);\n      const providerInfoRef = useRef<any>(null);\n\n      useEffect(() => {\n        const providerReturn = providerInfo();\n        providerInfoRef.current = providerReturn;\n        providerReturn.render(renderProps);\n\n        return () => {\n          providerInfoRef.current?.destroy({\n            dom: renderDom.current,\n          });\n        };\n      }, []);\n      return <div ref={rootRef}></div>;\n    }\n  };\n});\n\nfunction Component () {\n  return (<React.Suspense fallback={<div>loading</div>}>\n  <LazyComponent />\n</React.Suspense>)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Loading Custom Remote - Javascript\nDESCRIPTION: This code snippet shows how to initialize the Module Federation runtime with a custom remote not known at build time, using the `init` function. It then proceeds to load a module from this dynamically defined remote using `loadRemote`. The `force: true` option may be necessary to sideload remotes after the fact.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/dynamic-remotes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ninit({\n  name: 'hostname',\n  remotes: [\n    {\n      name: 'home',\n      entry: 'http://somthing.com/remoteEntry.js'\n    }\n  ],\n  force: true // may be needed to sideload remotes after the fact.\n})\nloadRemote('home/exposedModule')\n```\n\n----------------------------------------\n\nTITLE: Generating a New Angular Library (models)\nDESCRIPTION: This command uses the Angular CLI to generate a new library named 'models'. This library will be used to house shared models that are used across multiple services and feature modules. The command handles the creation of the project folder, installs ng-packagr as a dependency, and updates the angular.json and tsconfig.json files to include the new library.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nng generate library models\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Webpack. It shows how to import the plugins from `@module-federation/native-federation-typescript/webpack` using `require` and add them to the `plugins` array in the Webpack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// webpack.config.js\nconst { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } = require('@module-federation/native-federation-typescript/webpack');\nmodule.exports = {\n  /* ... */\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Install pnpm globally (Bash)\nDESCRIPTION: This command installs the pnpm package manager globally. pnpm is recommended for managing dependencies in Modern.js projects.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g pnpm@8\n```\n\n----------------------------------------\n\nTITLE: Creating an Rsbuild Provider Project\nDESCRIPTION: Demonstrates the interactive process of creating an rsbuild provider project using `npm create module-federation@latest`. It shows the prompts and user inputs during the project creation process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/quick-start.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n➜  ~  ✗ npm create module-federation@latest\n\n> npx\n> create-module-federation\n\n◆  Create Module Federation Project\n│\n◇  Please input Module Federation name:\n│  mf_provider\n│\n◇  Please select the type of project you want to create:\n│  Application\n│\n◇  Select template\n│  Rsbuild\n│\n◇  Please select the role of project you want to create:\n│  Provider\n│\n◇  Next steps ─────╮\n│                  │\n│  cd mf_provider  │\n│  npm install     │\n│  npm run dev     │\n│                  │\n├──────────────────╯\n│\n└  Done.\n```\n\n----------------------------------------\n\nTITLE: Updating mf.manifest.json for Remote Entry Points\nDESCRIPTION: This JSON snippet defines the configuration for a remote entry point.  It specifies the URL where the remote module can be accessed.  The port number is set to 4201 to avoid conflicts with the main application running on port 4200. The URL points to the `remoteEntry.js` file of the remote application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"login\": \"http://localhost:4201/remoteEntry.js\"\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Available CLI Commands in Module Federation\nDESCRIPTION: This command displays all available CLI commands and options for the Module Federation tool. It's useful for discovering the functionality provided by the CLI. It requires `npx` to be available in the environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx mf -h\n```\n\n----------------------------------------\n\nTITLE: Enhance dependency management with FederationModulesPlugin\nDESCRIPTION: This snippet describes the introduction of the `FederationModulesPlugin` to improve dependency management. The plugin handles federation-related hooks and dependencies, and the `FederationRuntimeDependency` is conditionally included.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Consuming Loader Data and Dynamically Loading Producers\nDESCRIPTION: This React component consumes data from the data loader and dynamically loads remote components using Module Federation.  It uses `createRemoteSSRComponent`, `loadRemote`, and `registerRemotes` from `@modern-js/runtime/mf`. It maps over the list of producers, creates remote components, and renders them.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRemoteSSRComponent, loadRemote, registerRemotes } from '@modern-js/runtime/mf';\n// 使用 import type ，仅获取类型\nimport type { DataLoaderRes } from './page.data';\nimport { useLoaderData } from '@modern-js/runtime/router';\n\nimport './index.css';\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  loader: () => import('remote/Image'),\n  loading: 'loading...',\n  export: 'default',\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Index = () => {\n  // 获取 data loader 数据\n  const dataLoader = useLoaderData() as DataLoaderRes;\n  // 注册生产者信息\n  registerRemotes(dataLoader.providerList);\n\n  const DynamicRemoteSSRComponents = dataLoader.providerList.map(item => {\n    const { id } = item;\n    const Com = createRemoteSSRComponent({\n      loader: () => loadRemote(id),\n      loading: 'loading...',\n      fallback: ({ error }) => {\n        if (error instanceof Error && error.message.includes('not exist')) {\n          return <div>fallback - not existed id</div>;\n        }\n        return <div>fallback</div>;\n      },\n    });\n    return <Com />\n  })\n  return (\n    <div className=\"container-box\">\n      <RemoteSSRComponent />\n      {DynamicRemoteSSRComponents}\n    </div>\n  );\n}\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Loading Backup Manifest (TS)\nDESCRIPTION: This snippet demonstrates how to load a backup manifest file if loading the main manifest fails. It fetches a backup manifest from a predefined URL and returns the parsed JSON, handling potential errors during the process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nif (args.lifecycle === 'afterResolve') {\n  try {\n    const response = await fetch('http://localhost:2002/mf-manifest.json');\n    if (!response.ok) {\n      throw new Error(`Failed to fetch backup entry: ${response.statusText}`);\n    }\n    const backupManifest = await response.json();\n    console.info('Successfully loaded backup manifest');\n    return backupManifest;\n  } catch (error) {\n    console.error('Failed to load backup manifest:', error);\n    return args;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consumer: src/routes/page.tsx (Fixed CSS)\nDESCRIPTION: This TypeScript file updates the consumer application to use `createRemoteSSRComponent` from `@modern-js/runtime/mf` to properly inject the producer's CSS and resolve CSS flickering issues.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRemoteSSRComponent } from '@modern-js/runtime/mf'\nimport './index.css';\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  loader: () => import('remote/Image'),\n  loading: 'loading...',\n  export: 'default',\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Index = () => (\n  <div className=\"container-box\">\n    <RemoteSSRComponent />\n  </div>\n);\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Create Next.js App (Bash)\nDESCRIPTION: This command uses `create-next-app` to generate a new Next.js project. It prompts the user for the project name and whether to use the App Router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app@latest\n\n\"What is your project named?\":\n> mfe1\n\n\"Would you like to use App Router?\":\n> No\n```\n\n----------------------------------------\n\nTITLE: NativeFederationTypeScriptRemote Configuration\nDESCRIPTION: This configuration object shows the available options for the `NativeFederationTypeScriptRemote` plugin. It requires `moduleFederationConfig`, the same configuration provided to the module federation plugin. It also accepts optional configurations such as `tsConfigPath`, `typesFolder`, `compiledTypesFolder`, `deleteTypesFolder`, `additionalFilesToCompile` and `compilerInstance`.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    moduleFederationConfig: any; // the configuration same configuration provided to the module federation plugin, it is MANDATORY\n    tsConfigPath?: string; // path where the tsconfig file is located, default is ''./tsconfig.json'\n    typesFolder?: string; // folder where all the files will be stored, default is '@mf-types',\n    compiledTypesFolder?: string; // folder where the federated modules types will be stored, default is 'compiled-types'\n    deleteTypesFolder?: boolean; // indicate if the types folder will be deleted when the job completes, default is 'true'\n    additionalFilesToCompile?: string[] // The path of each additional file which should be emitted\n    compilerInstance?: 'tsc' | 'vue-tsc' // The compiler to use to emit files, default is 'tsc'\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Webpack\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `webpack.config.js` file. The plugins are added to the `plugins` array in the Webpack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// webpack.config.js\nconst { NativeFederationTestsHost, NativeFederationTestsRemote } = require('@module-federation/native-federation-tests/webpack');\nmodule.exports = {\n  /* ... */\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Building all projects in the Module Federation setup\nDESCRIPTION: This command builds all projects in the Nx workspace. Nx caching is employed to restore cached artifacts if a project hasn't changed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run-many -t build\n```\n\n----------------------------------------\n\nTITLE: Preview Production Build with pnpm\nDESCRIPTION: This command previews the production build of the Rsbuild project locally using pnpm. It allows developers to test the application as it would be deployed, ensuring that it functions correctly before release.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote2-2002/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This command uses pnpm to install all project dependencies listed in the package.json file. It ensures that all required libraries and tools are available for development and building the application.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/rsbuild-common/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Add Module Federation types reference (TS)\nDESCRIPTION: This adds a type reference to the `modern-app-env.d.ts` file to provide runtime type support for `@modern-js/runtime/mf`.  This allows for better type checking and autocompletion when working with Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types='@module-federation/modern-js/types' />\n```\n\n----------------------------------------\n\nTITLE: Serve Angular Application\nDESCRIPTION: This command starts the Angular development server for the 'login' application. It allows developers to test the application in a browser.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nng serve login\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Rolldown\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `rolldown.config.js` file. The plugins are added to the `plugins` array in the Rolldown configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// rolldown.config.js\nconst { NativeFederationTestsHost, NativeFederationTestsRemote } = require('@module-federation/native-federation-tests/rolldown');\n\nexport default {\n  /* ... */\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This command starts the development server for the Rsbuild project using pnpm. It typically enables hot module replacement and other development-friendly features, allowing for rapid iteration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-vue3-2100/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Building the Rslib Package with pnpm\nDESCRIPTION: This command uses pnpm to build the Rslib package. It compiles the source code and prepares the package for distribution or use in other projects.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/provider-rslib-ts/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Previewing Production Build with pnpm\nDESCRIPTION: This command previews the production build locally using pnpm. It allows developers to test the production build before deploying it to a live environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote3-2003/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Manifest Package\nDESCRIPTION: Installs the @module-federation/manifest package using npm. This package provides a webpack/rspack plugin for generating manifests.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @module-federation/manifest\n```\n\n----------------------------------------\n\nTITLE: Adding a new remote to the host\nDESCRIPTION: This command adds a new remote application named 'login' to the 'apps/' directory and configures it to be attached to the 'shop' host application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g @nx/angular:remote apps/login --host=shop\n```\n\n----------------------------------------\n\nTITLE: RetryPlugin Type Definition (TypeScript)\nDESCRIPTION: This TypeScript code defines the type signatures and interfaces for the RetryPlugin, including the main plugin function and its parameters. It also specifies the structure for FetchWithRetryOptions and ScriptWithRetryOptions, which define the retry behavior for fetch and script resources respectively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/plugins/retry-plugin.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst RetryPlugin: (params: RetryPluginParams) => FederationRuntimePlugin;\n\ntype RetryPluginParams = {\n  fetch?: FetchWithRetryOptions; // fetch retry options\n  script?: ScriptWithRetryOptions; // script retry options\n};\n\ntype FetchWithRetryOptions = {\n  url?: string;\n  options?: RequestInit;\n  retryTimes?: number;\n  retryDelay?: number;\n  fallback?: (url: string) => string;\n}\n\ntype ScriptWithRetryOptions = {\n  retryTimes?: number;\n  retryDelay?: number;\n  moduleName?: Array<string>;\n  cb?: (resolve: (value: unknown) => void, error: any) => void;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Create Script with Timeout in TypeScript\nDESCRIPTION: This example shows how to use the `createScript` hook with a timeout.  If the URL matches `testRemoteEntry`, it creates a script element with custom attributes and then returns an object containing the script element and a timeout value of 1000 milliseconds.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'change-script-attribute',\n    createScript({ url }) {\n      if (url === testRemoteEntry) {\n        let script = document.createElement('script');\n        script.src = testRemoteEntry;\n        script.setAttribute('loader-hooks', 'isTrue');\n        script.setAttribute('crossorigin', 'anonymous');\n        return { script, timeout: 1000 }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Serving the Angular Application (login)\nDESCRIPTION: This command uses the Angular CLI to serve the 'login' application locally.  Serving the application starts a development server that allows you to view and test the application in a web browser. This command is used for development and debugging purposes. You may need to use a different port if the main application is already running.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nng serve login\n```\n\n----------------------------------------\n\nTITLE: Auth Library Public API\nDESCRIPTION: This TypeScript code defines the public API for the 'auth' library, exporting the AuthService, IsLoggedGuard, and IsNotLoggedGuard. This allows other modules and applications to import and use these components.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n * Public API Surface of auth\n */\nexport * from './lib/auth.service';\nexport * from './lib/is-logged.guard';\nexport * from './lib/is-not-logged.guard';\n```\n\n----------------------------------------\n\nTITLE: Register Module Federation plugin in Rslib Module\nDESCRIPTION: This code snippet demonstrates how to register the Module Federation plugin in an Rslib module project. It configures the library with a module federation format, specifying the output path, asset prefix, and the Module Federation plugin with exposes and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rsbuild.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rslib/core';\n\nexport default defineConfig({\n  lib: [\n    // ...\n    {\n      format: 'mf',\n      output: {\n        distPath: {\n          root: './dist/mf',\n        },\n        assetPrefix: 'xxx',\n      },\n      plugins: [\n        // ...\n        pluginModuleFederation({\n          name: 'rslib_provider',\n          exposes: {\n            '.': './src/index.tsx',\n          },\n          shared: {\n            react: {\n              singleton: true,\n            },\n            'react-dom': {\n              singleton: true,\n            },\n          },\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Create index.tsx\nDESCRIPTION: This code creates a new `index.tsx` file that imports the `bootstrap.tsx` file. This ensures that the application is bootstrapped asynchronously, which is a requirement for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport('./bootstrap');\n```\n\n----------------------------------------\n\nTITLE: Integrating i18next Provider - App A\nDESCRIPTION: This snippet wraps the application component in the `I18nextProvider`, passing the corresponding `i18next` instance to ensure the correct translation context is applied. This allows React components to access the configured i18next instance and use the translations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// App A Wrapper\nimport { I18nextProvider } from 'react-i18next';\nimport appAInstance from '../i18n';\n\nconst AppAI18nWrapper = ({ children }) => (\n  <I18nextProvider i18n={appAInstance}>{children}</I18nextProvider>\n);\n\nexport default AppAI18nWrapper;\n\n// Repeat similar setup for App B\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js using nvm\nDESCRIPTION: This snippet demonstrates how to install and use Node.js version 18 LTS using the Node Version Manager (nvm). It ensures the correct Node.js version is used for development within the Module Federation project. Dependencies: nvm.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install Node.js 18 LTS\nnvm install 18 --lts\nnvm alias default 18\nnvm use 18\n```\n\n----------------------------------------\n\nTITLE: CLI Usage: Ignoring Packages for Versioning\nDESCRIPTION: This command-line example shows how to use the `--ignore` flag with the `changeset version` command to exclude specific packages from version bumping. Multiple `--ignore` flags can be used to specify multiple packages to ignore. This approach provides an alternative to configuring the ignore list within a configuration file.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/CHANGELOG.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn changeset version --ignore pkg-a --ignore --pkg-b\n```\n\n----------------------------------------\n\nTITLE: Add shareStrategy option\nDESCRIPTION: This snippet describes the addition of a `shareStrategy` option. The exact functionality of the option is not described, but it likely affects how shared modules are handled in the federation.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Using ErrorCodeTitle Component (HTML/JSX)\nDESCRIPTION: Renders the ErrorCodeTitle component with the error code 'RUNTIME-008' as a prop. This displays the specific error code within the user interface.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-008.mdx#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<ErrorCodeTitle code='RUNTIME-008'/>\n```\n\n----------------------------------------\n\nTITLE: Serving the Module Federation setup\nDESCRIPTION: This command serves the 'shop' application with all remotes treated as static remotes. Nx builds and serves the remotes statically via `http-server`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve shop\n```\n\n----------------------------------------\n\nTITLE: Remote App Export using createBridgeComponent in TypeScript\nDESCRIPTION: This example shows how to export a Vue application as a module using `createBridgeComponent`. It imports the root component (App.vue), router, and a custom plugin.  The `appOptions` parameter allows configuring the Vue app instance within the host application, such as adding plugins or configuring the router. Requires @module-federation/bridge-vue3, Vue, and Vue Router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.ts\nimport App from './App.vue';\nimport router from './router';\nimport customPlugin from './plugins/custom-vue-plugin';\nimport { createBridgeComponent } from '@module-federation/bridge-vue3';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  appOptions: ({ app }) => {\n    // Optional: adding a plugin to the new Vue instance on the host application side\n    app.use(customPlugin);\n    return { router };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: createRemoteSSRComponent Type Definitions (TypeScript)\nDESCRIPTION: Type definitions for `createRemoteSSRComponent` and related types.  This component enables server-side rendering of remote components within a Module Federation setup. It includes options for loading, fallback, and component type definitions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function createRemoteSSRComponent(\n  props: CreateRemoteSSRComponentOptions\n): (props: ComponentType) => React.JSX.Element;\n\ntype CreateRemoteSSRComponentOptions = {\n  loader: () => Promise<T>;\n  loading: React.ReactNode;\n  fallback: ErrorBoundaryPropsWithComponent['FallbackComponent'];\n  export?: E;\n};\n\ntype ComponentType = T[E] extends (...args: any) => any\n  ? Parameters<T[E]>[0] extends undefined\n    ? Record<string, never>\n    : Parameters<T[E]>[0]\n  : Record<string, never>;\n```\n\n----------------------------------------\n\nTITLE: Creating an Nx Workspace using create-nx-workspace\nDESCRIPTION: This command is used to create a new Nx workspace named 'myorganization'. During the process, you will be prompted to select workspace type, content, and whether to enable distributed caching.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-nx-workspace@latest myorganization\n```\n\n----------------------------------------\n\nTITLE: Refactoring Inverted Container Code\nDESCRIPTION: This commit refactors the code related to the inverted container. The purpose of this refactoring is likely to improve code readability, maintainability, and performance. It may involve simplifying the code structure, removing redundancies, and optimizing algorithms.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Installing Dependencies with PNPM\nDESCRIPTION: This command installs the necessary dependencies for the Next.js App Router Playground using the PNPM package manager. It ensures that all required packages are available for the application to run correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/next-app-router/next-app-router-4001/readme.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration for JSON Remote in TS\nDESCRIPTION: This snippet showcases the module federation configuration for loading a remote JSON file.  The `remotes` object defines `jsonA` which points to a JSON file located at the specified URL.  This config is used in conjunction with the JSON data loading plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// module-federation-config\n{\n  remotes: {\n    jsonA: \"jsonA@https://cdn.jsdelivr.net/npm/@module-federation/runtime/package\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 20 LTS with NVM (Bash)\nDESCRIPTION: These commands install the long-term support version of Node.js 20 using nvm, set it as the default version, and switch to it. This ensures that the correct Node.js version is used for the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 20\nnvm install 20 --lts\n\n# Make the newly installed Node.js 20 as the default version\nnvm alias default 20\n\n# Switch to the newly installed Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Generate HomeComponent and ProfileModule (Bash)\nDESCRIPTION: Generates a `HomeComponent` and a `ProfileModule` within the `mfe-profile` application using the Angular CLI.  The `ProfileModule` includes routing and will contain a default `ProfileComponent`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nng generate component home --project mfe-profile\nng generate module profile --project mfe-profile --module app --routing --route profile\n```\n\n----------------------------------------\n\nTITLE: Start Development Server with pnpm\nDESCRIPTION: This command starts the Rsbuild development server, enabling hot module replacement and other development-friendly features. It allows developers to preview and test changes in real-time.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-2000/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing @module-federation/enhanced\nDESCRIPTION: Commands to install the @module-federation/enhanced package using npm, yarn, pnpm, and bun. This package is required for using the Rspack Module Federation plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/rspack.mdx#_snippet_0\n\nLANGUAGE: npm\nCODE:\n```\nnpm add @module-federation/enhanced\n```\n\nLANGUAGE: yarn\nCODE:\n```\nyarn add @module-federation/enhanced\n```\n\nLANGUAGE: pnpm\nCODE:\n```\npnpm add @module-federation/enhanced\n```\n\nLANGUAGE: bun\nCODE:\n```\nbun add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Angular Routing Module Configuration (app-routing.module.ts)\nDESCRIPTION: This code snippet shows the routing configuration for the main Angular application, demonstrating the use of route guards (isLogged and isNotLogged) to manage access to different routes based on user authentication status. It also showcases dynamic imports for lazy loading of feature modules, improving initial load time and overall performance. The routes are defined using RouterModule and the loadChildren property is used for lazy loading.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { isLogged } from './shared/auth/is-logged.guard';\nimport { isNotLogged } from './shared/auth/is-not-logged.guard';\n\nconst routes: Routes = [\n  {\n    path: '',\n    canMatch: [isLogged],\n    loadChildren: () =>\n      import('./features/dashboard/dashboard.module').then((m) => m.DashboardModule),\n  },\n  {\n    path: '',\n    canMatch: [isNotLogged],\n    loadChildren: () => import('./features/login/login.module').then((m) => m.LoginModule),\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n----------------------------------------\n\nTITLE: Dangerous Shared Module Configuration (Deprecated)\nDESCRIPTION: This code snippet demonstrates the deprecated method for dangerously sharing a package by explicitly defining the `shareKey`. It's important to note that this method is no longer recommended due to potential issues with singleton packages being bundled multiple times. Use with caution.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/core/CHANGELOG.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Set Script Timeout with createScript Hook (TypeScript)\nDESCRIPTION: Demonstrates how to use the `createScript` hook to set a timeout for the loading of script elements. If the script fails to load within the specified timeout, an error will be triggered. Imports necessary types from `@module-federation/enhanced/runtime`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'change-script-attribute',\n    createScript({ url }) {\n      if (url === testRemoteEntry) {\n        let script = document.createElement('script');\n        script.src = testRemoteEntry;\n        script.setAttribute('loader-hooks', 'isTrue');\n        script.setAttribute('crossorigin', 'anonymous');\n        return { script, timeout: 1000 }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Define PluginDevOptions Interface TypeScript\nDESCRIPTION: Defines the `PluginDevOptions` interface in TypeScript. This interface contains boolean flags to control live reload, hot types reload, and dynamic remote type hints during development. These options provide fine-grained control over the Module Federation development experience.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dev.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginDevOptions {\n  disableLiveReload?: boolean;\n  disableHotTypesReload?: boolean;\n  disableDynamicRemoteTypeHints?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default CreateRoot Options in Bridge Component\nDESCRIPTION: This snippet shows how to configure default options for the `createRoot` method when creating a bridge component with `@module-federation/bridge-react`. These options, such as `identifierPrefix` and `onRecoverableError`, are applied to all instances of the component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  // Set default createRoot options for all instances using this component\n  defaultRootOptions: {\n    identifierPrefix: 'my-app-',\n    onRecoverableError: (error) => {\n      console.error('Recoverable rendering error:', error);\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Rolldown Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Rolldown. It shows how to import the plugins from `@module-federation/native-federation-typescript/rolldown` and add them to the `plugins` array in the Rolldown configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// rolldown.config.js\nimport { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } from '@module-federation/native-federation-typescript/rolldown';\n\nexport default {\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Create Button Component (JavaScript)\nDESCRIPTION: This JavaScript code creates a simple React component, `Button`, which renders a button with the text \"MFE2 Button\". This component is intended to be exposed from the MFE2 application and consumed by another application using Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n\nconst Button = () => (\n  <button>MFE2 Button</button>\n);\n\nexport default Button;\n```\n\n----------------------------------------\n\nTITLE: Start Rslib MF Development Server (Shell)\nDESCRIPTION: This command starts the development server specifically for Module Federation development using Rslib. It allows for rapid iteration and testing of the component.  Ensure that `pnpm` is installed and configured correctly to execute this command.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/provider-rslib-storybook-ts/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npnpm mf-dev\n```\n\n----------------------------------------\n\nTITLE: Disabling Live Bindings in CJS builds\nDESCRIPTION: This patch disables live bindings on CommonJS (CJS) builds of the runtime packages.  This change improves compatibility and reduces potential issues when using the module federation runtime in CJS environments.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_1\n\nLANGUAGE: none\nCODE:\n```\n38f324f: Disable live bindings on cjs builds of the runtime packages\n```\n\n----------------------------------------\n\nTITLE: Adding retry plugin for resource retry\nDESCRIPTION: Introduces the @module-federation/retry-plugin to handle resource retry when resource loading fails. This plugin enhances the module federation's resilience by automatically retrying failed resource loads.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/retry-plugin/CHANGELOG.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nfeat: add @module-federation/retry-plugin for resource retry when resource loading went wrong\n\nfeat: add @module-federation/retry-plugin for resource retry when resource loading went wrong\n```\n\n----------------------------------------\n\nTITLE: Check Node.js version (Bash)\nDESCRIPTION: This command checks the currently installed Node.js version.  It is a prerequisite to ensure that the version is higher than 16.2.0 for compatibility with Modern.js.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Dangerous shared package configuration in nextjs-mf\nDESCRIPTION: This snippet demonstrates the configuration for dangerously sharing a package using a specific shareKey.  It should be used with caution due to potential issues with singleton packages being bundled multiple times.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/CHANGELOG.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Start development server using pnpm\nDESCRIPTION: This command starts the development server for the Modern.js application.  It typically enables hot module replacement for faster development cycles.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/modern-common/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Building for Production with pnpm\nDESCRIPTION: This command builds the application for production using pnpm. It typically involves optimizing the code for performance and creating a deployable bundle.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote3-2003/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Loading Remote Component\nDESCRIPTION: Loads a remote application using `createRemoteComponent` in the host application.  Defines fallback components for error and loading states, and configures routing for the remote component.  Uses `loadRemote` to load the remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/App.tsx\nimport { createRemoteComponent } from '@module-federation/bridge-react';\nimport { loadRemote } from '@module-federation/runtime';\n\n// Define FallbackError component\nconst FallbackErrorComp = ({ error }: { error: Error }) => {\n  return (\n    <div>\n      <h1>Error loading remote component</h1>\n      <p>{error.message}</p>\n      <button onClick={() => window.location.reload()}>\n        resetErrorBoundary(try again)\n      </button>\n    </div>\n  );\n};\n\n// Define FallbackLoading component\nconst FallbackComp = <div data-test-id=\"loading\">loading...</div>;\n\n// Use createRemoteComponent to create remote component\nconst Remote1App = createRemoteComponent({\n  // loader is used to load remote modules, e.g.: loadRemote('remote1/export-app'), import('remote1/export-app')\n  loader: () => loadRemote('remote1/export-app'),\n  // fallback is used for displaying components when remote module loading fails\n  fallback: FallbackErrorComp,\n  // loading is used for displaying components when loading remote modules\n  loading: FallbackComp,\n});\n\nconst App = () => {\n  return (\n    <BrowserRouter basename=\"/\">\n      <Routes>\n        <Route path=\"/\" Component={Home} />\n        <Route\n          path=\"/remote1/*\"\n          // Use Remote1App component, will be lazy loaded\n          Component={() => (\n            <Remote1App\n              // Set basename for remote application\n              basename=\"/remote1\"\n              // Other properties will be passed to remote component\n              props1={'props_value'}\n              props2={'another_props_value'}\n            />\n          )}\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Type Support\nDESCRIPTION: Shows how to add a reference to the module federation types to the `modern-app-env.d.ts` file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types='@module-federation/modern-js/types' />\n```\n\n----------------------------------------\n\nTITLE: Previewing Production Build with pnpm\nDESCRIPTION: This command serves the production build locally, allowing you to preview the optimized application before deployment. It simulates the production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm serve\n```\n\n----------------------------------------\n\nTITLE: Generating host and remotes using Nx\nDESCRIPTION: This command generates a host application named 'shop' and associated remote applications ('products', 'cart', 'checkout') within the 'apps/' directory, configured for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g @nx/angular:host apps/shop --remotes=products,cart,checkout\n```\n\n----------------------------------------\n\nTITLE: Lazy Load Remote Component (Named Export) - JavaScript\nDESCRIPTION: This code snippet shows how to lazy load a named export from a remote module. Since `React.lazy` expects a default export, the `.then()` method is used to extract the named export (`NamedComponent`) from the module and return it as a default export within an object. This allows `React.lazy` to work correctly with named exports.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-components.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React, { lazy } from 'react';\n\nconst SampleComponent = lazy(() => import('next2/sampleComponent').then((mod) => {\n  return { default: mod.NamedComponent };\n}));\n\nconst FormComponent = () => {\n  return (\n    <Suspense fallback=\"loading\">\n      <SampleComponent />\n    </Suspense>\n  );\n};\n\nexport default FormComponent;\n```\n\n----------------------------------------\n\nTITLE: Running Changesets command\nDESCRIPTION: This snippet runs the `changeset` command to manage versioning and changelogs for the Module Federation project.  It prompts the user to select the changed packages and add changeset information. Requires the changesets package to be installed.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npnpm run changeset\n```\n\n----------------------------------------\n\nTITLE: Fix enhanced ModuleFederation types error\nDESCRIPTION: This snippet describes a fix for an error related to enhanced ModuleFederation types. The specific error is not detailed, but the fix likely improves type safety or resolves type-related issues.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Specify Yarn as Package Manager\nDESCRIPTION: This snippet configures the Angular CLI to use Yarn as the package manager by adding the `packageManager` property to the `cli` section of the `angular.json` file. This helps ensure consistency in dependency management.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cli\": {\n    \"packageManager\": \"yarn\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Support virtual runtime entrypoints\nDESCRIPTION: This snippet describes the addition of support for using Virtual Runtime Entrypoints, which avoids writing temporary files to disk. It likely optimizes the runtime initialization process.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: createBridgeComponent: provider and host Usage\nDESCRIPTION: Defines the provider (remote) with the rootComponent and the host which loads the remote and specifies the export.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// remote\nexport const provider = createBridgeComponent({\n  rootComponent: App\n});\n\n// host\nconst Remote1App = createRemoteComponent({\n  loader: () => loadRemote('remote1/export-app'),\n  export: 'provider'\n});\n```\n\n----------------------------------------\n\nTITLE: Previewing the Production Build with pnpm\nDESCRIPTION: This command starts a local server to preview the production build of the Rsbuild project using pnpm. It allows you to test the optimized build before deploying it to a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-v5-2200/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This command installs all project dependencies defined in the package.json file using the pnpm package manager. It ensures that all required packages are available for the project to run correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote3-2003/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Display User Information in Shell Component\nDESCRIPTION: This code snippet demonstrates how to display the logged-in user's name in the shell's home component using the user$ observable from AuthService. It uses the async pipe to subscribe to the observable and display the user's name if a user is logged in.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<h1>Welcome!</h1>\n\n<p *ngIf=\"user$ | async as user\">\n    User: {{user.name}}\n</p>\n\n<div>\n    <button (click)=\"login()\" mat-flat-button color=\"primary\">Login</button>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Disabling hoistTransitiveImports\nDESCRIPTION: This change disables hoistTransitiveImports for better tree shaking. This improvement optimizes bundle size by removing unused code during the tree shaking process.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_10\n\nLANGUAGE: none\nCODE:\n```\n206b56d: disable hoistTransitiveImports for better tree shake\n```\n\nLANGUAGE: none\nCODE:\n```\n024df60: disable hoistTransitiveImports for better tree shake\n```\n\n----------------------------------------\n\nTITLE: Previewing the Production Build with pnpm\nDESCRIPTION: This command previews the production build of the Rsbuild project locally using pnpm.  It simulates a production environment to verify that the build functions as expected before deployment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-vue3-2100/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Import Remote Module (JSX)\nDESCRIPTION: This code imports the Button component from MFE2 into MFE1. This imports and renders the federated Button component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport Button from 'mfe2/Button'; // federated import\n\nconst Index = () => {\n  return (\n    <div>\n      <h1>MFE1</h1>\n      <Button />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CreateRoot Options at Render Time\nDESCRIPTION: This snippet illustrates how to pass `createRoot` options directly when rendering a remote component. Options passed at render time take precedence over default options configured when creating the component, allowing for instance-specific customization.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n// In the consumer application\nconst RemoteApp = createRemoteComponent({\n  url: 'http://localhost:3001/remoteEntry.js',\n  scope: 'remote',\n  module: './App',\n});\n\n// Pass rootOptions when rendering\n<RemoteApp \n  props={{ message: 'Hello' }} \n  rootOptions={{\n    identifierPrefix: 'instance-',\n    onRecoverableError: (error) => {\n      console.error('Recoverable error for this instance:', error);\n    }\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Entrypoint Before Async Startup (JSX)\nDESCRIPTION: Demonstrates the entrypoint setup before the introduction of asynchronous startup in Module Federation.  It requires importing the bootstrap file, which handles the React component rendering. Eager loading can lead to errors before all dependencies are resolved.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/hoisted-runtime.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// entrypoint\nimport('./bootstrap.js')\n\n// bootstrap.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n<React.StrictMode>\n  <App />\n</React.StrictMode>,\n);\n\n```\n\n----------------------------------------\n\nTITLE: Manual Package Sharing in Nextjs-MF\nDESCRIPTION: This code snippet demonstrates how to manually share a package in Nextjs-MF using the 'shareKey' option. It shows the configuration for sharing the 'lodash' package with a specific share key.  This method is considered dangerous and should only be used with caution, as it can lead to multiple bundles of singleton packages.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ssr option in modern.config.ts (TypeScript)\nDESCRIPTION: Example showing how to configure the `ssr` option within the `moduleFederationPlugin` in `modern.config.ts`. Setting `ssr: false` disables SSR for module federation. It shows the interplay with the `server.ssr` config.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  dev: {\n    port: 3050,\n  },\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n  },\n  plugins: [\n    appTools(),\n    moduleFederationPlugin({ ssr: false })\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Set Local Webpack Environment in .env (Bash)\nDESCRIPTION: This code snippet shows setting the `NEXT_PRIVATE_LOCAL_WEBPACK` environment variable to `true` within a `.env` file. While possible, the documentation suggests this may not always be reliable.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nNEXT_PRIVATE_LOCAL_WEBPACK=true\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This command starts the development server using pnpm. The development server typically provides features like hot module replacement and automatic browser reloading to improve the development experience.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote3-2003/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Adding Prefix to zipName\nDESCRIPTION: This patch ensures the zipName adds a prefix if the remoteEntry has it. This resolves issues related to generating the correct path and filename for zipped remote entries when using the dts-plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_6\n\nLANGUAGE: none\nCODE:\n```\n35aead4: fix(dts-plugin): zipName should add prefix if remoteEntry has it\n```\n\n----------------------------------------\n\nTITLE: Build Production App with pnpm\nDESCRIPTION: This command builds the Rsbuild application for production, optimizing the code for deployment. It creates a distributable package suitable for production environments.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-2000/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Changeset: Versioning with Snapshot Tag\nDESCRIPTION: This example demonstrates how to generate snapshot versions using `changeset version --snapshot [tag]`.  The updated version will have a format like `0.0.0[-tag]-YYYYMMDDHHMMSS`. This command is often used with the `publish --tag` command to publish experimental versions of packages.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/CHANGELOG.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Version packages to snapshot version\nchangeset version --snapshot\n# Publish packages under experimental tag, keeping next and latest tag clean\nchangeset publish --tag experimental\n```\n\n----------------------------------------\n\nTITLE: Update App Component for Authentication\nDESCRIPTION: This code snippet modifies the `app.component.ts` file to incorporate the logic for logging in and logging out using the Okta libraries.  It also includes the implementation of observable properties to track authentication status. This allows the application to react to changes in the authentication state.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component, Inject } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { filter, map, shareReplay } from 'rxjs/operators';\nimport { OKTA_AUTH, OktaAuthStateService } from '@okta/okta-angular';\nimport { OktaAuth } from '@okta/okta-auth-js';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  public isAuthenticated$: Observable<boolean>;\n  public name$: Observable<string>;\n\n  constructor(private oktaStateService: OktaAuthStateService, @Inject(OKTA_AUTH) private oktaAuth: OktaAuth) {\n    this.isAuthenticated$ = this.oktaStateService.authState$\n      .pipe(\n        filter(authState => !!authState),\n        map(authState => authState.isAuthenticated ?? false),\n        shareReplay()\n      );\n\n    this.name$ = this.oktaStateService.authState$\n      .pipe(\n        filter(authState => !!authState && !!authState.isAuthenticated),\n        map(authState => authState.idToken?.claims.name ?? '')\n      );\n  }\n\n  public async signIn(): Promise<void> {\n    await this.oktaAuth.signInWithRedirect();\n  }\n\n  public async signOut(): Promise<void> {\n    await this.oktaAuth.signOut();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Host and Remote Apps with SSR\nDESCRIPTION: This command uses the Nx CLI to generate a host application named 'dashboard' and a remote application named 'login', both configured with Angular Universal (SSR) and module federation. It also configures Webpack for browser and server builds, enabling module federation capabilities.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx g host dashboard --remotes=login --ssr\n```\n\n----------------------------------------\n\nTITLE: Building for Production with pnpm\nDESCRIPTION: This command builds the Rsbuild project for production using pnpm. It optimizes the code for deployment, including minification, bundling, and other optimizations to reduce file size and improve performance.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-vue3-2100/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Adding TypeScript Support for Vue Compiler\nDESCRIPTION: This update adds support for the Vue TypeScript compiler within the module federation core. This enhancement likely enables using TypeScript within Vue-based federated modules, improving type safety and developer experience. It addresses issue #502.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/CHANGELOG.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Registering Runtime Plugins\nDESCRIPTION: Example showing how to register runtime plugins using the `registerPlugins` function. This allows extending the functionality of the Module Federation runtime with custom logic.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerPlugins } from '@module-federation/enhanced/runtime'\nimport runtimePlugin from 'custom-runtime-plugin.ts';\n\nregisterPlugins([runtimePlugin()]);\n```\n\n----------------------------------------\n\nTITLE: Module Federation CLI dts Help Command (Bash)\nDESCRIPTION: This snippet shows the output of the `mf dts --help` command, detailing the options for the `mf dts` command. It describes the options to configure the root directory, output directory, and generation/fetching of the remote types.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nUsage: mf dts [options]\n\ngenerate or fetch the mf types\n\nOptions:\n  --root <root>         specify the project root directory\n  --output <output>     specify the generated dts output directory\n  --fetch <boolean>     fetch types from remote, default is true (default: true)\n  --generate <boolean>  generate types, default is true (default: true)\n  -c --config <config>  specify the configuration file, can be a relative or absolute path\n  -h, --help            display help for command\n```\n\n----------------------------------------\n\nTITLE: Installing project dependencies with pnpm\nDESCRIPTION: This snippet installs all the necessary dependencies for the Module Federation project using pnpm. It also creates symlinks between packages within the monorepo. It requires pnpm to be enabled and configured. Dependencies: pnpm.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Adding Default Exposes Fields\nDESCRIPTION: This patch adds default exposes fields if disableAssetsAnalyze is set to true.  It ensures that necessary information is available for exposed modules even when full asset analysis is disabled, preventing potential runtime errors.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_3\n\nLANGUAGE: none\nCODE:\n```\n4a2cf82: fix(manifest): add default exposes fields if set disableAssetsAnalyze: true\n```\n\n----------------------------------------\n\nTITLE: Configuration: Ignoring Packages for Versioning\nDESCRIPTION: This configuration snippet demonstrates how to ignore specific packages during the `changeset version` command.  The `ignore` array specifies packages that should not have their versions bumped, but their dependencies will still be updated normally. This is useful for private or internal packages within a larger project.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/CHANGELOG.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"ignore\": [\"pkg-a\", \"pkg-b\"]\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Public API Definition (JavaScript)\nDESCRIPTION: This code snippet defines the public API of the Login module by exporting the LoginModule from the feature module. This allows other parts of the application to import and use the Login module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// public-api.ts\nexport { LoginModule } from './app/feature/login/login.module';\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies using pnpm\nDESCRIPTION: This code snippet demonstrates how to install project dependencies using the pnpm package manager. It is a prerequisite for running the Next.js App Router Playground locally.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/next-app-router/next-app-router-4000/readme.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Hard Refresh Implementation (JavaScript)\nDESCRIPTION: This JavaScript function implements a hard refresh by unregistering the service worker, clearing its cache, and reloading the webpage. This ensures the application provides the most up-to-date content to the user.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hardRefresh() {\n  navigator.serviceWorker.getRegistration().then(async (registration) => {\n    if (!registration) return;\n    await registration.unregister();\n    window.location.reload();\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: SSR Hot Updates (JSX)\nDESCRIPTION: This code implements hot module replacement (HMR) by flushing chunks and revalidating in `_document.js`.  It uses `revalidate`, `FlushedChunks`, and `flushChunks` from `@module-federation/nextjs-mf/utils` to ensure that `<script>` tags are sent to the browser. This keeps the client up to date with server side renders.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\nimport {\n  revalidate,\n  FlushedChunks,\n  flushChunks,\n} from '@module-federation/nextjs-mf/utils';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx.pathname) {\n      if (!ctx.pathname.endsWith('_error')) {\n        await revalidate().then((shouldUpdate) => {\n          if (shouldUpdate) {\n            console.log('should HMR', shouldUpdate);\n          }\n        });\n      }\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n\n    const chunks = await flushChunks();\n\n    return {\n      ...initialProps,\n      chunks,\n    };\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head>\n          <FlushedChunks chunks={this.props.chunks} />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Import and Render Error Code Title Component (JSX)\nDESCRIPTION: This snippet imports the `ErrorCodeTitle` component and renders it with the error code `RUNTIME-002`. It's used to display the error code within the documentation or user interface.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-002.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n\n<ErrorCodeTitle code='RUNTIME-002'/>\n```\n\n----------------------------------------\n\nTITLE: Developing the Rslib Package with pnpm\nDESCRIPTION: This command uses pnpm to start a development server for the Rslib package. It typically enables hot reloading and other development features for rapid iteration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/provider-rslib-ts/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm mf-dev\n```\n\n----------------------------------------\n\nTITLE: Adding the @nx/react plugin\nDESCRIPTION: This command adds the `@nx/react` plugin to the Nx workspace. This plugin provides React capabilities to the workspace, enabling the generation and management of React applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx add @nx/react\n```\n\n----------------------------------------\n\nTITLE: Serving the Module Federation setup\nDESCRIPTION: This command serves the 'shop' application with all remotes treated as static remotes.  Static remotes are built by Nx and served statically.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve shop\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to the Nx Workspace\nDESCRIPTION: This command changes the current directory to the newly created Nx workspace, 'myorganization', allowing subsequent commands to be executed within the workspace's context.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd myorganization\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Rollup\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `rollup.config.js` file. The plugins are added to the `plugins` array in the Rollup configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// rollup.config.js\nimport { NativeFederationTestsHost, NativeFederationTestsRemote } from '@module-federation/native-federation-tests/rollup';\n\nexport default {\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Running tests for specific projects using nx\nDESCRIPTION: This snippet runs tests for a specific project within the Module Federation project using nx. Replace `PROJECT-NAME` with the desired project name. The `--parallel=3` flag enables parallel execution. Dependencies: nx.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run-many -t test --parallel=3 --projects=PROJECT-NAME\n```\n\n----------------------------------------\n\nTITLE: Optimize HoistContainerReferencesPlugin\nDESCRIPTION: This snippet describes a refactoring of the `HoistContainerReferencesPlugin` to optimize module disconnection and cleanup logic. It mentions the removal of a redundant `moduleToDelete` set and ensures all referenced modules are disconnected directly.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Installing the Nx Angular Plugin\nDESCRIPTION: This command installs the official Nx Angular plugin. It is a prerequisite for generating Angular applications within the Nx workspace.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @nx/angular\n```\n\n----------------------------------------\n\nTITLE: Fixing Project Configuration\nDESCRIPTION: This commit addresses an issue with the project.json configuration file. It likely involves correcting syntax errors or ensuring that necessary dependencies and settings are properly defined for the project to build and run correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Default consumeTypes Configuration in JSON\nDESCRIPTION: Shows the default configuration generated when `consumeTypes` is set to `true`.  This configuration includes settings for handling errors during type loading (`abortOnError`) and generate Federation Runtime API types (`consumeAPITypes`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"abortOnError\": false,\n  \"consumeAPITypes\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamically Loading Remote Modules with Module Federation Runtime\nDESCRIPTION: This code snippet demonstrates how to dynamically initialize and load remote modules using the Module Federation runtime. It uses the `init` function to configure remote module locations and aliases, and the `loadRemote` function to fetch and use modules at runtime. The `init` function takes a configuration object specifying the name of the current application and an array of remote modules with their names, entry points (mf-manifest.json or remoteEntry.js), and aliases. The `loadRemote` function takes the remote module path and returns a promise that resolves with the loaded module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/announcement.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: \"@demo/app1\",\n      entry: \"http://localhost:3005/mf-manifest.json\",\n      alias: \"app1\"\n    },\n    {\n      name: \"@demo/app2\",\n      entry: \"http://localhost:3006/remoteEntry.js\",\n      alias: \"app2\"\n    },\n  ],\n});\n\nloadRemote(\"app2/util\").then((md)=>{\n  md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: Install dependencies using pnpm\nDESCRIPTION: This command installs all the necessary dependencies for the Modern.js application as defined in the package.json file. It utilizes the pnpm package manager.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/modern-common/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Initialize and Load Remote Modules with Runtime\nDESCRIPTION: Demonstrates how to initialize the Federation Runtime and load remote modules without relying on build plugins. It shows how to use `init` to configure remotes and `loadRemote` to load and use a module from a remote application. This example assumes the existence of `mf-manifest.json` and `remoteEntry.js` files in remote applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// 可以只使用运行时加载模块，而不依赖于构建插件\n// 当不使用构建插件时，共享的依赖项不能自动设置细节\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n    name: '@demo/app-main',\n    remotes: [\n        {\n            name: \"@demo/app1\",\n            // mf-manifest.json 是在 Module federation 新版构建工具中生成的文件类型，对比 remoteEntry 提供了更丰富的功能\n            // 预加载功能依赖于使用 mf-manifest.json 文件类型\n            entry: \"http://localhost:3005/mf-manifest.json\",\n            alias: \"app1\"\n        },\n        {\n            name: \"@demo/app2\",\n            entry: \"http://localhost:3006/remoteEntry.js\",\n            alias: \"app2\"\n        },\n    ],\n});\n\n// 使用别名加载\nloadRemote<{add: (...args: Array<number>)=> number }>(\"app2/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: PluginRemoteOptions Interface (TypeScript)\nDESCRIPTION: Defines the structure of the `PluginRemoteOptions` interface used to configure remote modules in Module Federation. `remoteAlias` is the name used when importing the module, and `ModuleFederationInfo` specifies the location of the remote module's entry point, consisting of ModuleFederation name and entry.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/remotes.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationInfo = string;\ninterface PluginRemoteOptions {\n  [remoteAlias: string]: ModuleFederationInfo;\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration Options in TypeScript\nDESCRIPTION: This TypeScript code snippet defines the `ModuleFederationOptions` type, which outlines the configuration options for Module Federation. It includes properties for defining the module's name, remote entry filename, remote module aliases and entry information, exposed modules, shared dependencies, dynamic public path, runtime plugins, implementation details, manifest configuration, and development options for controlling hot reloading and type generation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ModuleFederationOptions {\n    // module federation name\n    name: string;\n    // remoteEntry 名称\n    filename?: string,\n    // module federation remotes 远程模块别名和 entry 信息\n    remotes?: Array<RemoteInfo>;\n    // module federation expose 的模块信息\n    exposes?: PluginExposesOptions;\n    // 共享依赖配置\n    shared?: ShareInfos;\n    // 动态 publicPath\n    getPublicPath?: string;\n    // 运行时插件\n    runtimePlugins?: Array<string>;\n    // runtime pkg 依赖\n    implementation?: string;\n    // manifest 配置\n    manifest?: boolean | PluginManifestOptions\n    // 控制页面热重载和类型热重载\n    dev?: boolean | PluginDevOptions;\n    // 控制类型生成\n    dts?: boolean | PluginDtsOptions;\n};\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Plugin (Bash)\nDESCRIPTION: This command adds the `@module-federation/modern-js` plugin to the project using pnpm. This plugin is required for Module Federation functionality.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/modern-js\n```\n\n----------------------------------------\n\nTITLE: Consume Remote Component in Storybook (React)\nDESCRIPTION: This code snippet illustrates how to consume a remote component named `Button` from a remote module in a Storybook story. It utilizes React's `Suspense` component to handle the asynchronous loading of the remote component.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport React, { Suspense } from 'react';\n\nconst LazyButton = React.lazy(() => import('remote/Button'));\n\nconst Button = (props) => (\n  <Suspense fallback={<p>Please wait...</p>}>\n    <LazyButton {...props} />\n  </Suspense>\n);\n\nexport default {\n  title: 'ModuleFederation/Button',\n  component: Button,\n  argTypes: {\n    variant: {\n      control: 'select',\n      options: ['primary', 'secondary'],\n    },\n  },\n};\n\nconst Template = (args) => <Button {...args} />;\n\nexport const Primary = Template.bind({ variant: 'primary' });\nPrimary.args = {\n  variant: 'primary',\n  children: 'Button',\n};\n\nexport const Secondary = Template.bind({});\nSecondary.args = {\n  variant: 'secondary',\n  children: 'Button',\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation in Remote\nDESCRIPTION: This code configures the ModuleFederationPlugin in the remote application (remote1). It sets the unique name for the remote and exposes a module ('./export-app') that can be consumed by the host application.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n//rsbuild.config.ts\nexport default defineConfig({\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      delete config.optimization?.splitChunks;\n      config.output!.uniqueName = 'remote1';\n      appendPlugins([\n        new ModuleFederationPlugin({\n          name: 'remote1',\n          exposes: {\n            './export-app': './src/index.tsx',\n          }\n        }),\n      ]);\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Verbose Logging (Javascript)\nDESCRIPTION: This snippet demonstrates how to enable verbose logging in webpack by configuring the `infrastructureLogging` option. Setting the level to 'log' provides more detailed output during the build process.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/typescript/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ninfrastructureLogging: {\n  level: 'log';\n}\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies MFE2 (Bash)\nDESCRIPTION: These commands install the `@module-federation/nextjs-mf` and `webpack` packages as development dependencies, and also install the regular dependencies. This is required for enabling Module Federation in the Next.js application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd mfe2\npnpm add @module-federation/nextjs-mf webpack -D\npnpm i\n```\n\n----------------------------------------\n\nTITLE: ProviderFnParams Interface\nDESCRIPTION: Defines the `ProviderFnParams` interface for configuring the bridge component. It includes properties for the root component, custom render function, custom createRoot function, and default root options for React 18 and 19.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n/**\n * Bridge component configuration information\n */\ninterface ProviderFnParams<T> {\n  /** Root component to be remotely loaded */\n  rootComponent: React.ComponentType<T>;\n  \n  /** \n   * Custom render function for custom rendering logic\n   * @param App - React element\n   * @param id - DOM element or string ID\n   * @returns React root element or Promise\n   */\n  render?: (\n    App: React.ReactElement,\n    id?: HTMLElement | string,\n  ) => RootType | Promise<RootType>;\n  \n  /** \n   * Custom createRoot function for React 18 and above\n   * @param container - DOM container\n   * @param options - CreateRoot options\n   * @returns React root node\n   */\n  createRoot?: (\n    container: Element | DocumentFragment,\n    options?: CreateRootOptions,\n  ) => Root;\n  \n  /**\n   * Default options for createRoot in React 18 and 19\n   * These options will be used when creating a root unless overridden by rootOptions in render params\n   * @example\n   * {\n   *   identifierPrefix: 'app-',\n   *   onRecoverableError: (err) => console.error(err)\n   * }\n   */\n  defaultRootOptions?: CreateRootOptions;\n}\n```\n\n----------------------------------------\n\nTITLE: Build application for production using pnpm\nDESCRIPTION: This command builds the Modern.js application for production, optimizing the code and assets for deployment. The output is usually placed in a dedicated 'dist' directory.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/modern-common/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Eager/Sync Import (JavaScript)\nDESCRIPTION: This snippet demonstrates eager/synchronous import of a remote module and named export using `require` and standard import syntax.  It handles the case where the default export is accessed via `SomeHook.default`. `next2/someHook` and `next2/sampleComponent` are the remote modules being imported.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-components.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nlet SomeHook = require('next2/someHook');\nSomeHook = SomeHook.default || SomeHook;\n\nimport SomeComponent, {NamedExportComponent} from 'next2/sampleComponent';\n```\n\n----------------------------------------\n\nTITLE: Remote Module Loader Service (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a service for dynamically loading remote modules and resolving component factories. It uses the `ComponentFactoryResolver` to get the factory for a given component.  It assumes that the remote modules are available on the `window` object.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable({\n  providedIn: 'root'\n})\nexport class RemoteModuleLoader {\n  constructor(private _componentFactoryResolver: ComponentFactoryResolver) {}\n\n  async loadRemoteModule(name: string) {\n    const [scope, moduleName] = name.split('/');\n    const moduleFactory = await window[scope].get('./' + moduleName);\n    return moduleFactory();\n  }\n\n  getComponentFactory(component: Type<unknown>): ComponentFactory<unknown> {\n    return this._componentFactoryResolver.resolveComponentFactory(component);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This command installs all the required dependencies for the Rsbuild project using the pnpm package manager. It's a prerequisite for running the development server, building the app, or previewing the production build.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-v5-2200/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Correctly handle chunk entry modules\nDESCRIPTION: This snippet mentions a fix to handle chunk entry modules correctly in `MfStartupChunkDependenciesPlugin`. This ensures that chunk dependencies are managed correctly during the startup process.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Client-Side Only Remote Module Loading - JSX\nDESCRIPTION: This code snippet illustrates how to load a remote module only on the client-side. It uses `typeof window === 'undefined'` to check if the code is running on the server. If it's on the server, it uses an empty function as `RemoteModule`. On the client, it uses `React.lazy` to load the module. It leverages `useEffect` and `useState` to prevent server-side rendering and avoid errors if the remote module is incompatible with the server environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-components.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\nimport {lazy, Suspense, useEffect, useState} from 'react';\n\nconst RemoteModule = typeof window === 'undefined' ? ()=>{} : lazy(() => import('app3/sampleComponent'));\n\nconst ClientOnly = ({Component}) => {\n  const [mounted, setMount] = useState(false);\n  useEffect(() => {\n    setMount(true);\n  }, []);\n  if (mounted) return null;\n  return (\n    <Suspense fallback=\"loading\">\n      <Component />\n    </Suspense>\n  );\n};\n\nconst App = ()=>{\n  return <ClientOnly Component={RemoteModule} />\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server using pnpm\nDESCRIPTION: This code snippet shows how to start the development server for the Next.js App Router Playground using the pnpm package manager. This command initiates the local development environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/next-app-router/next-app-router-4000/readme.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Creating Rsbuild Consumer Project\nDESCRIPTION: This snippet shows an example of creating a rsbuild consumer project using `npm create module-federation@latest` with interactive prompts to configure the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n➜  ~  ✗ npm create module-federation@latest\n\n> npx\n> create-module-federation\n\n◆  Create Module Federation Project\n│\n◇  Please input Module Federation name:\n│  mf_consumer\n│\n◇  Please select the type of project you want to create:\n│  Application\n│\n◇  Select template\n│  Rsbuild\n│\n◇  Please select the role of project you want to create:\n│  Consumer\n│\n◇  Next steps ─────╮\n│                  │\n│  cd mf_provider  │\n│  npm install     │\n│  npm run dev     │\n│                  │\n├──────────────────╯\n│\n└  Done.\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Node Package\nDESCRIPTION: These commands demonstrate how to install the @module-federation/node package using npm and yarn, allowing you to use Module Federation in your NodeJS project. It installs the package as a dependency of your project.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @module-federation/node\n\n# yarn\nyarn add @module-federation/node\n```\n\n----------------------------------------\n\nTITLE: Generate HomeComponent and ProfileModule\nDESCRIPTION: These commands generate a `HomeComponent` and a `ProfileModule` within the `mfe-profile` application. The `HomeComponent` will be the default route, and the `ProfileModule` includes a default `ProfileComponent` configured as a lazy-loaded route.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nng generate component home --project mfe-profile\nng generate module profile --project mfe-profile --module app --routing --route profile\n```\n\n----------------------------------------\n\nTITLE: Create Modern.js provider project (Bash)\nDESCRIPTION: This command uses `@modern-js/create` to initialize a new Modern.js provider project named `modern-provider`. It creates a basic project structure with default settings.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modern-js/create@latest modern-provider\n```\n\n----------------------------------------\n\nTITLE: Delegated Modules in TypeScript\nDESCRIPTION: This snippet defines two asynchronous functions, `test1` and `test2`, which return promises that resolve after a 3-second delay.  These modules are dynamically imported and used by the module delegation plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/delegateModulesA.js\nexport async function test1() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"test1 value\")\n    }, 3000)\n  })\n}\nexport async function test2() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"test2 value\")\n    }, 3000)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming index.tsx to bootstrap.tsx\nDESCRIPTION: This command renames the `index.tsx` file to `bootstrap.tsx`. This allows `bootstrap.tsx` to load asynchronously, which is essential for Module Federation to function correctly between the two applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv src/index.tsx src/bootstrap.tsx\n```\n\n----------------------------------------\n\nTITLE: Serve Rslib Module\nDESCRIPTION: This command serves the 'rslib-module' package using Nx serve.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/rslib-module/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnx serve rslib-module\n```\n\n----------------------------------------\n\nTITLE: Producer: Image.module.css\nDESCRIPTION: This CSS file provides basic styling for the Image component in the producer application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_9\n\nLANGUAGE: css\nCODE:\n```\n.button {\n  background: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Create a Modern.js Provider Project (Bash)\nDESCRIPTION: This command uses the `@modern-js/create` tool to scaffold a new Modern.js project named 'modern-provider'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modern-js/create@latest modern-provider\n```\n\n----------------------------------------\n\nTITLE: Importing ErrorCodeTitle Component (JavaScript)\nDESCRIPTION: Imports the ErrorCodeTitle component from the '@components/ErrorCodeTitle' module. This component is likely used to display the error code title in a standardized way.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-008.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n```\n\n----------------------------------------\n\nTITLE: JSON Default generateTypes Configuration\nDESCRIPTION: This JSON snippet shows the default configuration that will be generated when the 'generateTypes' option is set to 'true'. It specifies default values for generateAPITypes, abortOnError, extractThirdParty, extractRemoteTypes, and compileInChildProcess.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dts.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"generateAPITypes\": true,\n  \"abortOnError\": false,\n  \"extractThirdParty\": false,\n  \"extractRemoteTypes\": false,\n  \"compileInChildProcess\": true\n}\n```\n\n----------------------------------------\n\nTITLE: NextFederationPlugin Configuration in next.config.js\nDESCRIPTION: This JavaScript code snippet demonstrates how to configure the NextFederationPlugin in the `next.config.js` file. It shows how to define remotes (pointing to other federated modules), exposes (modules exposed by the current application), and shared dependencies. It's crucial to configure webpack as a local dependency, using NEXT_PRIVATE_LOCAL_WEBPACK=true to expose webpack internals.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// either from default\nconst NextFederationPlugin = require('@module-federation/nextjs-mf');\n\nmodule.exports = {\n  webpack(config, options) {\n    const { isServer } = options;\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'next2',\n        remotes: {\n          next1: `next1@http://localhost:3001/_next/static/${\n            isServer ? 'ssr' : 'chunks'\n          }/remoteEntry.js`,\n        },\n        filename: 'static/chunks/remoteEntry.js',\n        exposes: {\n          './title': './components/exposedTitle.js',\n          './checkout': './pages/checkout',\n        },\n        shared: {\n          // whatever else\n        },\n      }),\n    );\n\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Clearing Express Route Cache with Global Callback (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to add a global callback (`global.clearRoutes`) in an Express.js server to clear its route cache. This is essential for enabling hot module replacement (HMR) when using Express.js with server-side rendering (SSR) as Express's routing stack doesn't automatically reload routes on code changes. The callback filters the router stack to remove routes with a path, effectively resetting the routing configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/express.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport express from 'express';\nimport next from 'next';\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst hostname = 'localhost';\nconst port = 3000;\nconst app = next({ dev, hostname, port });\nconst handle = app.getRequestHandler();\n\nglobal.clearRoutes = () => {\n  server._router.stack = server._router.stack.filter((k) => !(k && k.route && k.route.path));\n};\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.all('*', (req, res) => {\n    const parsedUrl = new URL(req.url, `http://${req.headers.host}`);\n    const { pathname, query } = parsedUrl;\n\n    handle(req, res, parsedUrl);\n  });\n\n  server.listen(port, () => {\n    console.log(`> Ready on http://${hostname}:${port}`);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: esbuild Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with esbuild. It shows how to import the plugins from `@module-federation/native-federation-typescript/esbuild` and add them to the `plugins` array in the esbuild configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// esbuild.config.js\nimport { build } from 'esbuild';\nimport { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } from '@module-federation/native-federation-typescript/esbuild';\n\nbuild({\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using useIsRemote Hook\nDESCRIPTION: This snippet shows how to use the `useIsRemote` hook in a React component to conditionally render elements based on whether the application is running as a remote or standalone application. It displays the `LanguageSwitcher` component only if the application is not running as a remote.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport useIsRemote from './hooks/useIsRemote';\nimport LanguageSwitcher from './components/LanguageSwitcher';\n\nconst App = () => {\n  const isRemote = useIsRemote();\n\n  return (\n    <div>\n      {/* Only display the LanguageSwitcher if not running as a remote */}\n      {!isRemote && <LanguageSwitcher />}\n    </div>\n  );\n};\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Setting up Express.js with Global Callback for Hot Reloading (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to set up an Express.js server integrated with Next.js and introduces a global callback function `clearRoutes` to clear the Express route cache. This allows for hot module reloading by removing existing routes before revalidation, ensuring the server uses the updated routes. It requires the `express` and `next` packages. The `clearRoutes` function modifies the server's internal route stack.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/express.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport express from 'express';\nimport next from 'next';\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst hostname = 'localhost';\nconst port = 3000;\nconst app = next({ dev, hostname, port });\nconst handle = app.getRequestHandler();\n\nglobal.clearRoutes = () => {\n  server._router.stack = server._router.stack.filter((k) => !(k && k.route && k.route.path));\n};\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.all('*', (req, res) => {\n    const parsedUrl = new URL(req.url, `http://${req.headers.host}`);\n    const { pathname, query } = parsedUrl;\n\n    handle(req, res, parsedUrl);\n  });\n\n  server.listen(port, () => {\n    console.log(`> Ready on http://${hostname}:${port}`);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Check Node.js Version (Bash)\nDESCRIPTION: This command checks the currently installed Node.js version. It is used to verify that the Node.js version meets the minimum requirement of 16.2.0.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Support rspack ssr\nDESCRIPTION: This snippet describes adding support for rspack server-side rendering (SSR). The feature enables the use of module federation in server-side rendering environments using rspack.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Removing isomorphic-rslog Dependency\nDESCRIPTION: This patch removes the isomorphic-rslog dependency. The removal of this dependency likely simplifies the project's dependency tree and reduces the overall bundle size.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_8\n\nLANGUAGE: none\nCODE:\n```\n8acd217: chore: remove isomorphic-rslog\n```\n\n----------------------------------------\n\nTITLE: Import ErrorCodeTitle Component (JavaScript)\nDESCRIPTION: Imports the ErrorCodeTitle component from the '@components/ErrorCodeTitle' module. This component is likely used to display error codes with their associated titles within the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/runtime/RUNTIME-003.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n```\n\n----------------------------------------\n\nTITLE: Language Switching Interface Component\nDESCRIPTION: This snippet implements a user interface component (LanguageSwitcher) to trigger language changes across all applications. It uses the useSwitchLanguage hook to access the switchAllLanguages function and creates a button that calls this function when clicked.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useSwitchLanguage } from 'src/hooks/useSwitchLanguage';\n\nconst LanguageSwitcher = () => {\n  const { switchAllLanguages } = useSwitchLanguage();\n  const handleLanguageSwitch = (lng) => () => switchAllLanguages(lng);\n\n  return <button onClick={handleLanguageSwitch(\"ua\")}>Change language to Ukrainian</button>;\n};\n\nexport default LanguageSwitcher;\n```\n\n----------------------------------------\n\nTITLE: Load Entry - JSON Data Loading Plugin in TypeScript\nDESCRIPTION: This example demonstrates how to implement a `loadEntry` plugin to load JSON data from a remote entry.  It checks if `remoteInfo.jsonA` is equal to \"jsonA\" and returns an object with `init` (empty function) and `get` functions. The `get` function fetches a JSON file based on `remoteInfo.entry` and returns the JSON data.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// load-json-data-plugin.ts\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'load-json-data-plugin',\n    loadEntry({ remoteInfo }) {\n      if (remoteInfo.jsonA === \"jsonA\") {\n        return {\n          init(shareScope, initScope, remoteEntryInitOPtions) {},\n          async get(path) {\n            const json = await fetch(remoteInfo.entry + \".json\").then(res => res.json())\n            return () => ({\n              path,\n              json\n            })\n          }\n        }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Button Component useEffect TSX\nDESCRIPTION: This TypeScript JSX snippet shows how to integrate `usePrefetch` with `useEffect` in a React component for fetching and updating data. This approach allows the component to load data once it mounts, utilizing the data pre-fetching benefits.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { usePrefetch } from '@module-federation/enhanced/prefetch';\n\nexport const Button = () => {\n  const [state, setState] = useState(defaultVal);\n  const [userInfoPrefetch, reFetchUserInfo] = usePrefetch<UserInfo>({\n    // 对应生产者 MF 配置中的 (name + expose)，例如 `app2/Button` 用于消费 `Button.prefetch.ts`\n    id: 'app2/Button',\n    // 可选参数，使用 defer 后必填\n    deferId: 'userInfo',\n    // default 导出默认可以不传 functionId，此处为举例说明，如果非 default 导出则需要填函数名,\n    // functionId: 'default',\n  });\n\n  useEffect(() => {\n    // 常规场景一般在这里发请求\n    userInfoPrefetch\n      .then(data => (\n        // 更新数据\n        setState(data)\n      ));\n  }, []);\n\n  return (\n    <>{state.defaultVal}<>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Node.js Version\nDESCRIPTION: This command checks the currently installed version of Node.js. It is used to verify that the Node.js version meets the minimum requirements for the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Set Local Webpack Env (Bash)\nDESCRIPTION: This command sets the `NEXT_PRIVATE_LOCAL_WEBPACK` environment variable to `true`. This forces Next.js to use a locally installed version of webpack instead of its bundled copy, which is necessary for Module Federation to function correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncross-env NEXT_PRIVATE_LOCAL_WEBPACK=true next dev\n# or\ncross-env NEXT_PRIVATE_LOCAL_WEBPACK=true next build\n```\n\n----------------------------------------\n\nTITLE: Add Module Federation to mfe-profile\nDESCRIPTION: This command adds the `@angular-architects/module-federation` package to the `mfe-profile` project and configures it to run on port 4202.  This setup is crucial for enabling the application to function as a micro frontend in a module federation architecture.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project mfe-profile --port 4202\n```\n\n----------------------------------------\n\nTITLE: Modern.js App Configuration (Typescript)\nDESCRIPTION: Configures the Modern.js application to use the module federation plugin. Defines runtime options for routing, server-side rendering with streaming mode, and the port the application listens on.  It also applies the `@modern-js/app-tools` and `@module-federation/modern-js` plugins to enable the specified features.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3008,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Generating React Consumer with Producers - Nx\nDESCRIPTION: This command uses the Nx CLI to generate a React consumer application named 'shell' and configures it to consume three producer applications: 'products', 'cart', and 'checkout'. It leverages the `@nx/react` plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/monorepos/nx-for-module-federation.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx g @nx/react:consumer shell --producers=products,cart,checkout\n```\n\n----------------------------------------\n\nTITLE: Image component styles (CSS)\nDESCRIPTION: This CSS file (`Image.module.css`) defines styles for the `Image` component, specifically setting the background color of a button to red.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_9\n\nLANGUAGE: css\nCODE:\n```\n.button {\n  background: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation CLI Help Command (Bash)\nDESCRIPTION: This shows the output of the `npx mf -h` command, which displays the available commands for the Module Federation CLI.  It lists the available options such as version and help, as well as the `dts` command for generating or fetching module federation types.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nUsage: mf <command> [options]\n\nOptions:\n  -V, --version   output the version number\n  -h, --help      display help for command\n\nCommands:\n  dts [options]   generate or fetch the mf types\n  help [command]  display help for command\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Runtime Plugin in TypeScript\nDESCRIPTION: This code snippet demonstrates the structure of a custom runtime plugin for Module Federation. It shows how to define a plugin with a name and various lifecycle hooks (beforeInit, beforeRequest, afterResolve, onLoad, loadShare, beforeLoadShare) that can be used to modify the behavior of Module Federation at different stages.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst runtimePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'my-runtime-plugin',\n    beforeInit(args) {\n      console.log('beforeInit: ', args);\n      return args;\n    },\n    beforeRequest(args) {\n      console.log('beforeRequest: ', args);\n      return args;\n    },\n    afterResolve(args) {\n      console.log('afterResolve', args);\n      return args;\n    },\n    onLoad(args) {\n      console.log('onLoad: ', args);\n      return args;\n    },\n    async loadShare(args) {\n      console.log('loadShare:', args);\n    },\n    async beforeLoadShare(args) {\n      console.log('beforeloadShare:', args);\n      return args;\n    },\n  };\n};\nexport default runtimePlugin;\n```\n\n----------------------------------------\n\nTITLE: Import ErrorCodeTitle React Component\nDESCRIPTION: Imports the ErrorCodeTitle component from the '@components/ErrorCodeTitle' module. This component is likely used to display error codes with their corresponding titles.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-003.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n```\n\n----------------------------------------\n\nTITLE: SSR Render Blocking Revalidation (JSX)\nDESCRIPTION: This code implements a render-blocking revalidation strategy in `_document.js` to handle updates from remote modules.  `revalidate()` checks for updates before rendering, ensuring the server and client are synchronized and helps avoid hydration errors. Requires  `@module-federation/nextjs-mf/utils`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { revalidate } from '@module-federation/nextjs-mf/utils';\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx?.pathname && !ctx?.pathname?.endsWith('_error')) {\n      await revalidate().then((shouldUpdate) => {\n        if (shouldUpdate) {\n          console.log('Hot Module Replacement (HMR) activated', shouldUpdate);\n        }\n      });\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Vite\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `vite.config.ts` file. It also demonstrates setting up a proxy to correctly serve the zip file and configuring the file system to allow access to the dist folder.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.ts\nimport { NativeFederationTestsHost, NativeFederationTestsRemote } from '@module-federation/native-federation-tests/vite';\n\nexport default defineConfig({\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n  /* ... */\n  server: {\n    // This is needed to emulate the devServer.static.directory of WebPack and correctly serve the zip file\n    /* ... */\n    proxy: {\n      '/@mf-types.zip': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,\n        rewrite: () => `/@fs/${process.cwd()}/dist/@mf-types.zip`,\n      },\n    },\n    fs: {\n      /* ... */\n      allow: ['./dist'],\n      /* ... */\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing the native-federation-typescript package\nDESCRIPTION: This command installs the `@module-federation/native-federation-typescript` package as a development dependency using npm. This package provides plugins for sharing federated types in a module federation setup.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @module-federation/native-federation-typescript\n```\n\n----------------------------------------\n\nTITLE: Improving Module Hooks for Eager Loading\nDESCRIPTION: This commit refactors the module hooks related to eager loading and module search. This likely optimizes the process of finding and loading modules, improving the performance of the module federation system.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: DtsHostOptions Interface Definition in TypeScript\nDESCRIPTION: Defines the structure for configuring type consumption in the host module. This interface includes options for setting the type storage directory (`typesFolder`), handling errors during type loading (`abortOnError`), configuring the remote types folder (`remoteTypesFolder`), deleting the type folder before loading (`deleteTypesFolder`), and specifying the maximum number of retries for failed loading (`maxRetries`), generate Federation Runtime API types (`consumeAPITypes`).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/dts.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DtsHostOptions {\n  typesFolder?: string;\n  abortOnError?: boolean;\n  remoteTypesFolder?: string;\n  deleteTypesFolder?: boolean;\n  maxRetries?: number;\n  consumeAPITypes?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Module Federation Plugin in modern.config.ts (TypeScript)\nDESCRIPTION: Example of applying the Module Federation plugin within the `modern.config.ts` file. It imports necessary modules and adds `moduleFederationPlugin()` to the `plugins` array. This integrates Module Federation into the Modern.js build process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\nexport default defineConfig({\n  dev: {\n    port: 3005,\n  },\n  runtime: {\n    router: true,\n  },\n  // moduleFederationPlugin 是 modern.js 的插件，可以对构建/运行时做一定的修改\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling pnpm with corepack\nDESCRIPTION: This snippet enables pnpm (a package manager) using corepack, which is available in Node.js versions >= v14.19.0. It's a prerequisite for installing the project dependencies with pnpm. Dependencies: corepack and Node.js version >= v14.19.0\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Enable pnpm with corepack, only available on Node.js >= `v14.19.0`\ncorepack enable\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Plugin with Nx CLI\nDESCRIPTION: This command installs the `@angular-architects/module-federation` plugin and configures Module Federation for a specified Angular project within an Nx workspace.  `npm i @angular-architects/module-federation -D` installs the plugin as a dev dependency. The `ng g` command generates the initial Module Federation configuration using the plugin's init schematic. The `--project` option defines the project, `--port` sets the port, and `--type` specifies the project type (host or remote).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @angular-architects/module-federation -D\nng g @angular-architects/module-federation:init --project shell --port 4200 --type host\nng g @angular-architects/module-federation:init --project mfe1 --port 4201 --type remote\n```\n\n----------------------------------------\n\nTITLE: Initializing Manifest Properties\nDESCRIPTION: This patch initializes the manifest with required properties from stats, enhancing the manifest's data consistency and completeness. It ensures necessary information is available for module federation during runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_0\n\nLANGUAGE: none\nCODE:\n```\n92882ec: feat: initialize manifest with required properties from stats\n```\n\n----------------------------------------\n\nTITLE: Install Okta Angular and Auth JS Libraries\nDESCRIPTION: Installs the necessary Okta Angular and Okta Auth JS libraries using npm. These libraries are essential for integrating Okta authentication into an Angular application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @okta/okta-angular@5.2 @okta/okta-auth-js@6.4\n```\n\n----------------------------------------\n\nTITLE: Enabling Eager Sharing in Module Federation\nDESCRIPTION: This commit introduces support for eager sharing in the module federation setup. Eager sharing improves performance by pre-loading shared modules, reducing latency and improving the overall user experience.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Generating Angular Consumer with Producers - Nx\nDESCRIPTION: This command uses the Nx CLI to generate an Angular consumer application named 'shell' and configures it to consume three producer applications: 'products', 'cart', and 'checkout'. It leverages the `@nx/angular` plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/monorepos/nx-for-module-federation.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx g @nx/angular:consumer shell --producers=products,cart,checkout\n```\n\n----------------------------------------\n\nTITLE: create-module-federation CLI Options\nDESCRIPTION: This text block describes the available command-line options for the `create-module-federation` tool. It lists options for specifying the directory, template, Module Federation name, role, and override behavior.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nUsage: create-module-federation [options]\n\nOptions:\n\n  -h, --help       display help for command\n  -d, --dir        create project in specified directory\n  -t, --template   specify the template to use\n  -n, --name       specify the mf name\n  -r, --role       specify the mf role type: provider or consumer\n  --override       override files in target directory\n\nTemplates:\n\n  provider-modern, provider-rsbuild, provider-rslib, provider-rslib-storybook, consumer-modern, consumer-rsbuild\n```\n\n----------------------------------------\n\nTITLE: Creating index.tsx to import bootstrap.tsx\nDESCRIPTION: This code snippet creates a new `index.tsx` file and imports `bootstrap.tsx`.  This facilitates asynchronous loading required for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport('./bootstrap');\n```\n\n----------------------------------------\n\nTITLE: Configure rsbuild.config.ts for MFE1\nDESCRIPTION: This code configures Module Federation for MFE1.  It defines the application as a host, specifies the remote module (MFE2) location, and configures shared dependencies to avoid duplication and ensure version compatibility.  The port is set to 3001, and the remote module is fetched from `http://localhost:3002/remoteEntry.js`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport { dependencies }  from './package.json';\n\nexport default defineConfig({\n  server: {\n    port: 3001\n  },\n  moduleFederation: {\n    options: {\n     name: 'host',\n     remotes: {\n       remote: 'remote@http://localhost:3002/remoteEntry.js',\n     },\n     shared: {\n       ...dependencies,\n       react: {\n         singleton: true,\n         requiredVersion: dependencies['react'],\n       },\n       'react-dom': {\n         singleton: true,\n         requiredVersion: dependencies['react-dom'],\n       },\n     },\n    }\n  },\n  plugins: [pluginReact()]\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Prefetch Interface to Stats\nDESCRIPTION: This patch ensures that the stats object includes a prefetchInterface when dataPrefetch is enabled. This feature allows for prefetching data required by federated modules, improving performance and user experience.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_4\n\nLANGUAGE: none\nCODE:\n```\n85ef6c4: fix(manifest): stats should add prefetchInterface if enable dataPrefetch\n```\n\n----------------------------------------\n\nTITLE: Updating Next.js Peer Dependency\nDESCRIPTION: This commit updates the `next` peer dependency in the `nextjs-mf` package. This ensures compatibility with newer versions of Next.js and may include necessary updates to the module federation plugin to function correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Load Entry Type Definition (TypeScript)\nDESCRIPTION: Defines the types and interfaces for the `loadEntry` function, which allows for full customization of remote entries. The `loadEntry` function enables extending and creating new remote types, providing flexibility in how remote modules are loaded and initialized. The type definition specifies the arguments and return type of the `loadEntry` function, along with the related types for remote information, remote entry exports, and share scopes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nfunction loadEntry(args: LoadEntryOptions): RemoteEntryExports | void;\n\ntype LoadEntryOptions = {\n  createScriptHook: SyncHook,\n  remoteEntryExports?: RemoteEntryExports,\n  remoteInfo: RemoteInfo\n};\ninterface RemoteInfo {\n  name: string;\n  version?: string;\n  buildVersion?: string;\n  entry: string;\n  type: RemoteEntryType;\n  entryGlobalName: string;\n  shareScope: string;\n}\nexport type RemoteEntryExports = {\n  get: (id: string) => () => Promise<Module>;\n  init: (\n    shareScope: ShareScopeMap[string],\n    initScope?: InitScope,\n    remoteEntryInitOPtions?: RemoteEntryInitOptions,\n  ) => void | Promise<void>;\n};\n```\n\n----------------------------------------\n\nTITLE: Rollup Configuration\nDESCRIPTION: This code snippet demonstrates how to integrate the `NativeFederationTypeScriptRemote` and `NativeFederationTypeScriptHost` plugins with Rollup. It shows how to import the plugins from `@module-federation/native-federation-typescript/rollup` and add them to the `plugins` array in the Rollup configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-typescript/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// rollup.config.js\nimport { NativeFederationTypeScriptHost, NativeFederationTypeScriptRemote } from '@module-federation/native-federation-typescript/rollup';\n\nexport default {\n  plugins: [\n    NativeFederationTypeScriptRemote({\n      /* options */\n    }),\n    NativeFederationTypeScriptHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Verify Node.js version using command line\nDESCRIPTION: This command checks the currently installed version of Node.js in the environment. It is used to ensure that the Node.js version meets the minimum requirements for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/setting-up-env.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Consume provider's component with SSR (TSX)\nDESCRIPTION: This code demonstrates how to consume the provider's component with SSR, addressing the CSS flickering issue using `createRemoteSSRComponent` from `@modern-js/runtime/mf`. This ensures that the provider's styles are correctly injected into the consumer's HTML during server-side rendering.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRemoteSSRComponent } from '@modern-js/runtime/mf'\nimport './index.css';\n\nconst RemoteSSRComponent = createRemoteSSRComponent({\n  loader: () => import('remote/Image'),\n  loading: 'loading...',\n  export: 'default',\n  fallback: ({ error }) => {\n    if (error instanceof Error && error.message.includes('not exist')) {\n      return <div>fallback - not existed id</div>;\n    }\n    return <div>fallback</div>;\n  },\n});\n\nconst Index = () => (\n  <div className=\"container-box\">\n    <RemoteSSRComponent />\n  </div>\n);\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleFederationPlugin in webpack.config.js (TS)\nDESCRIPTION: This code snippet demonstrates how to configure the ModuleFederationPlugin in a webpack.config.js file. It sets up the plugin to expose a module named './button' from './src/components/button', shares react and react-dom as singletons, and sets the publicPath. It requires the '@module-federation/enhanced/webpack' package as a dependency.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/webpack.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ModuleFederationPlugin } from '@module-federation/enhanced/webpack';\nmodule.exports = {\n  devServer: {\n    port: 2000,\n  },\n  output: {\n    // 使用 manifest 必须要配置 publicPath\n    publicPath: 'http://localhost:2000/', //or 'auto'\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'rspack_provider',\n      filename: 'remoteEntry.js',\n      exposes: {\n        // 设置需要导出的模块，default 导出为 .\n        './button': './src/components/button',\n      },\n      shared: {\n        react: {\n          singleton: true,\n        },\n        'react-dom': {\n          singleton: true,\n        },\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Delegate Modules with loadEntry Hook (TypeScript)\nDESCRIPTION: Demonstrates how to use the `loadEntry` hook to delegate modules to other modules.  It replaces the path and asynchronously imports the module delegateModulesA.js. This example shows how to delegate module loading to a different module within the Module Federation runtime. Imports necessary types from `@module-federation/enhanced/runtime`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// delegate-modules-plugin.ts\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'delegate-modules-plugin',\n    loadEntry({ remoteInfo }) {\n      if (remoteInfo.name === \"delegateModulesA\") {\n        return {\n          init(shareScope, initScope, remoteEntryInitOPtions) {},\n          async get(path) {\n            path = path.replace(\"./\", \"\")\n            const {[path]: factory} = await import(\"./delegateModulesA.js\")\n            const result = await factory()\n            return () => result\n          }\n        }\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring i18next Instance for App A\nDESCRIPTION: This snippet configures a separate i18next instance for App A.  It imports i18next, initReactI18next, and translation files, and initializes the i18next instance with translation resources, default language, fallback language, and interpolation settings.  This ensures App A maintains its translation terms independently.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// App A\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport enJSON from './translations/en';\nimport uaJSON from './translations/ua';\n\n// Translation resources\nconst resources = {\n  en: { translation: enJSON },\n  ua: { translation: uaJSON },\n};\n\n// Initialize i18next instance for App A\nconst appAInstance = i18n.createInstance();\nappAInstance.use(initReactI18next).init({\n  resources,\n  lng: 'en', // default language\n  fallbackLng: 'en',\n  interpolation: { escapeValue: false },\n  react: { useSuspense: true },\n});\n\nexport default appAInstance;\n\n// Repeat similar setup for App B with a separate instance\n```\n\n----------------------------------------\n\nTITLE: Building for Production with pnpm\nDESCRIPTION: This command builds the application for production using pnpm. It optimizes the code, bundles assets, and prepares the application for deployment to a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/rsbuild-common/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Start Storybook (Shell)\nDESCRIPTION: This command starts the Storybook environment, allowing for isolated component development and testing. It provides a visual interface to interact with the components. Ensure that `pnpm` is installed and configured correctly to execute this command. The Storybook will be available at http://localhost:6006.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/provider-rslib-storybook-ts/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\npnpm storybook\n```\n\n----------------------------------------\n\nTITLE: Refactoring Custom JSONP for ES5 Compatibility\nDESCRIPTION: This commit refactors the custom JSONP implementation to ensure compatibility with ES5. This is likely done to support older browsers and environments that do not fully support modern JavaScript features.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Add Module Federation to mfe-profile (Bash)\nDESCRIPTION: Uses the `@angular-architects/module-federation` schematic to prepare the `mfe-profile` application for Module Federation. This command configures the application to run as a remote module on port 4202.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project mfe-profile --port 4202\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Plugin (bun)\nDESCRIPTION: This command installs the @module-federation/enhanced package using bun.  This package provides enhanced functionality for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Configure ModuleFederationPlugin (Consumer)\nDESCRIPTION: This TypeScript snippet configures the `ModuleFederationPlugin` in the Webpack configuration for the consumer (shell) application. It defines remote modules ('mf1') and shared dependencies (e.g., '@angular/core').  The `remotes` object maps remote module names to their respective URLs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomWebpackBrowserSchema, TargetOptions } from '@angular-builders/custom-webpack';\nimport { Configuration, container } from 'webpack';\n\nexport default (config: Configuration, options: CustomWebpackBrowserSchema, targetOptions: TargetOptions) => {\n  // ... existing configuration\n  config.plugins.push(\n    new container.ModuleFederationPlugin({\n      remotes: {\n        'mf1': 'mf1@http://localhost:4300/mf1.js'\n      },\n      shared: {\n        '@angular/animations': {singleton: true, strictVersion: true},\n        '@angular/core': {singleton: true, strictVersion: true},\n        // ... other shared modules\n      }\n    })\n  );\n\n  return config;\n};\n```\n\n----------------------------------------\n\nTITLE: Preview Production Build with pnpm\nDESCRIPTION: This command previews the production build locally using a simple server. It allows developers to test the optimized application before deploying it to a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-2000/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Fixing Shared and Exposed Assets\nDESCRIPTION: This patch corrects shared assets and filters expose assets within the manifest. It resolves inaccuracies in asset handling, ensuring proper loading and utilization of shared and exposed modules in federated applications.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_2\n\nLANGUAGE: none\nCODE:\n```\n451b4f5: fix(manifest): correct shared assets and filter expose assets\n```\n\n----------------------------------------\n\nTITLE: Setting options at render time (TSX)\nDESCRIPTION: Demonstrates how to override default `createRoot` options at render time when using a remote component.  The `rootOptions` prop allows specifying instance-specific configurations like `identifierPrefix` and `onRecoverableError`. Options passed during rendering will take precedence over the default options defined when creating the bridge component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// 在消费者应用中\nconst RemoteApp = createRemoteComponent({\n  url: 'http://localhost:3001/remoteEntry.js',\n  scope: 'remote',\n  module: './App',\n});\n\n// 在渲染时传递 rootOptions\n<RemoteApp \n  props={{ message: 'Hello' }} \n  rootOptions={{\n    identifierPrefix: 'instance-',\n    onRecoverableError: (error) => {\n      console.error('此实例的可恢复错误:', error);\n    }\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Error Load Remote Plugin Example\nDESCRIPTION: Illustrates the usage of the `errorLoadRemote` hook within a Module Federation runtime plugin. This plugin handles errors that occur during remote module loading, providing fallback behavior based on the lifecycle stage when the error occurred.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst fallbackPlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'fallback-plugin',\n    errorLoadRemote(args) {\n      if(args.lifecycle === 'onLoad') {\n        const fallback = 'fallback';\n        return fallback;\n      } else if (args.lifecycle === 'beforeRequest') {\n        return args\n      }\n    }\n  };\n};\n\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: '@demo/app2',\n      entry: 'http://localhost:3006/remoteEntry.js',\n      alias: 'app2'\n    }\n  ],\n  plugins: [fallbackPlugin()]\n});\n\nloadRemote('app2/un-existed-module').then((mod) => {\n  expect(mod).toEqual('fallback');\n});\n```\n\n----------------------------------------\n\nTITLE: Configure ModuleFederationPlugin (Producer)\nDESCRIPTION: This TypeScript snippet configures the `ModuleFederationPlugin` for the producer module/application. It defines the filename, module name, exposed modules, and shared dependencies.  The `exposes` object maps module identifiers to their physical file paths.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomWebpackBrowserSchema, TargetOptions } from '@angular-builders/custom-webpack';\nimport { Configuration, container } from 'webpack';\nimport * as path from 'path';\n\nexport default (config: Configuration, options: CustomWebpackBrowserSchema, targetOptions: TargetOptions) => {\n  // ... existing configuration\n\n  config.plugins.push(\n    new container.ModuleFederationPlugin({\n      filename: \"mf1.js\",\n      name: \"mf1\",\n      exposes: {\n        './Contact': path.resolve(__dirname, './src/app/contact/contact.module.ts'),\n        './Clock': path.resolve(__dirname, './src/app/clock/index.ts'),\n      },\n      shared: {\n        '@angular/animations': {singleton: true, strictVersion: true},\n        // ... other shared modules\n      }\n    })\n  );\n\n  return config;\n};\n```\n\n----------------------------------------\n\nTITLE: Prefetch File Example TS\nDESCRIPTION: This TypeScript snippet demonstrates a prefetch file (Button.prefetch.ts) for a module. It exports a default function that uses `react-router-dom`'s `defer` API to simulate an asynchronous data fetch. The function returns a promise that resolves after a delay.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// 这里通过使用 react-router-dom 提供的 defer API 举例，是否要使用这个 API 可以根据需求决定，参考问题解答「为什么要使用 defer、Suspense、Await 组件」\n// 用户可以通过 npm install react-router-dom 来安装这个包\nimport { defer } from 'react-router-dom';\n\nconst defaultVal = {\n  data: {\n    id: 1,\n    title: 'A Prefetch Title',\n  }\n};\n\n// 注意 export 的函数必须以 default 导出或 Prefetch 结尾才会被识别成 Prefetch 函数（不区分大小写）\nexport default (params = defaultVal) => defer({\n  userInfo: new Promise(resolve => {\n    setTimeout(() => {\n      resolve(params);\n    }, 2000);\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Exposed Image component (TSX)\nDESCRIPTION: This component (`Image.tsx`) is exposed by the provider application via Module Federation.  It renders a simple image and a button that triggers an alert. This showcases a remotely exposed React component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport styles from './Image.module.css';\n\nexport default (): JSX.Element => (\n  <div\n    id=\"remote-components\"\n    style={{\n      backgroundColor: '#1ee9c1',\n      color: 'lightgrey',\n      padding: '1rem',\n    }}\n  >\n    <h2>\n      <strong>remote</strong>&nbsp;image\n    </h2>\n    <button\n      id=\"remote-components-button\"\n      style={{ marginBottom: '1rem' }}\n      onClick={() => alert('[remote-components] Client side Javascript works!')}\n    >\n      Click me to test i'm interactive!\n    </button>\n    <img\n      id=\"remote-components-image\"\n      src=\"https://module-federation.io/module-federation-logo.svg\"\n      style={{ width: '100px' }}\n      alt=\"serge\"\n    />\n    <button className={styles['button']}>Button from remote</button>\n  </div>\n);\n```\n\n----------------------------------------\n\nTITLE: Create Script with Custom Attributes in TypeScript\nDESCRIPTION: This example demonstrates how to use the `createScript` hook to customize the attributes of a script element before it is loaded.  It checks if the URL matches a specific `testRemoteEntry` and sets attributes like `loader-hooks` and `crossorigin` on the script. The function returns the modified script element.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from '@module-federation/enhanced/runtime';\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nconst changeScriptAttributePlugin: () => FederationRuntimePlugin = function () {\n  return {\n    name: 'change-script-attribute',\n    createScript({ url }) {\n      if (url === testRemoteEntry) {\n        let script = document.createElement('script');\n        script.src = testRemoteEntry;\n        script.setAttribute('loader-hooks', 'isTrue');\n        script.setAttribute('crossorigin', 'anonymous');\n        return script;\n      }\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Import Delegated Modules (TypeScript)\nDESCRIPTION: Importing test1 and test2 delegated modules within bootstrap.js\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// src/bootstrap.js\nimport test1 from \"delegateModulesA/test1\"\nimport test2 from \"delegateModulesA/test2\"\ntest1 // \"test1 value\"\ntest2 // \"test2 value\"\n```\n\n----------------------------------------\n\nTITLE: Example Plugin Naming Convention in TypeScript\nDESCRIPTION: This code snippet showcases the naming convention for Module Federation plugins.  The plugin function should be named `xxx-plugin` and the plugin's `name` property within the returned object should follow the same `xxx-plugin` format.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\nconst pluginFooBar = (): FederationRuntimePlugin => ({\n  name: 'xxx-plugin',\n  //...\n});\n\nexport default pluginFooBar;\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation for Auth0\nDESCRIPTION: Configures Module Federation to share the `@auth0/auth0-angular` package between the consumer application (shell) and micro frontends. This ensures a single instance of the `AuthService` is used across the application, maintaining a consistent authentication state. `singleton: true` enforces a single instance, `strictVersion: true` ensures version compatibility, and `requiredVersion: 'auto'` allows automatic version resolution.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// In webpack.config.js of both shell and micro frontends\n\nmodule.exports = {\n  // existing configuration...\n  shared: share({\n    \"@auth0/auth0-angular\": { singleton: true, strictVersion: true, requiredVersion: 'auto' },\n    // other shared packages...\n  })\n};\n```\n\n----------------------------------------\n\nTITLE: Host App: Next.js App Component\nDESCRIPTION: This code defines a custom Next.js App component in the host application, analogous to the remote app. It wraps the page 'Component' with the provided 'pageProps'. It also defines a 'getInitialProps' method that extends the default 'App.getInitialProps' method.  This example demonstrates that you might need to define the same code that exists in the remote in the host app.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport App  from 'next/app'\n\nexport default function MyApp({\n  Component,\n  pageProps,\n  example,\n}) {\n  return (\n    <>\n      <Component {...pageProps} />\n    </>\n  )\n}\n\nMyApp.getInitialProps = async (context) => {\n  const ctx = await App.getInitialProps(context)\n\n  return { ...ctx }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying typescript-transform-paths in tsconfig.json\nDESCRIPTION: This code snippet demonstrates how to configure typescript-transform-paths within the tsconfig.json file. It involves adding plugins to the compilerOptions section to transform and process paths, which is necessary for resolving type alias issues in module federation. The snippet shows the required changes to the tsconfig.json file, including adding transform plugins for both regular transforms and after declarations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/type/overview.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\"compilerOptions\": {\n+ \"plugins\": [\n+ { \"transform\": \"typescript-transform-paths\" },\n+ {\n+ \"transform\": \"typescript-transform-paths\",\n+ \"afterDeclarations\": true\n+ }\n+ ],\n},\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Packages (Deprecated Method)\nDESCRIPTION: This snippet shows a deprecated method for sharing packages in Next.js MF, using the `shareKey` option.  It's considered dangerous and should be used cautiously due to potential issues with singleton packages being bundled multiple times. It shows how to override the default sharing behavior.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/CHANGELOG.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin Manifest Options Interface - TypeScript\nDESCRIPTION: Defines the interface for configuring the manifest generation. It includes options for specifying the file path, disabling asset analysis, and setting the file name.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/manifest.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginManifestOptions {\n  filePath?: string;\n  disableAssetsAnalyze?: boolean;\n  fileName?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Install Okta Angular and Auth JS Libraries\nDESCRIPTION: This command installs the necessary Okta Angular and Okta Auth JS libraries for integrating Okta authentication into your Angular project. These libraries provide the functionality to handle authentication flows, manage user sessions, and interact with the Okta API.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @okta/okta-angular@5.2 @okta/okta-auth-js@6.4\n```\n\n----------------------------------------\n\nTITLE: Loading Shared Dependencies\nDESCRIPTION: Example showing how to load shared dependencies using the `loadShare` function. It initializes the runtime with shared React and ReactDOM dependencies and then loads the `react` dependency. This example demonstrates how to share dependencies between federated modules, preventing duplication and ensuring consistency.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { init, loadRemote, loadShare } from '@module-federation/enhanced/runtime';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [],\n  shared: {\n    react: {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => React,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n    'react-dom': {\n      version: '17.0.0',\n      scope: 'default',\n      lib: () => ReactDOM,\n      shareConfig: {\n        singleton: true,\n        requiredVersion: '^17.0.0',\n      },\n    },\n  },\n});\n\nloadShare('react').then((reactFactory) => {\n  console.log(reactFactory());\n});\n```\n\n----------------------------------------\n\nTITLE: Enhanced Hot-Reload Functionality with Module Decaching\nDESCRIPTION: This snippet highlights enhancements to the hot-reload functionality, including module decaching and improved type safety. It adds the `callsite` package for module path resolution and implements `decache` and `searchCache` functions for safely removing modules from the cache, ensuring proper handling of relative paths and avoiding issues with native modules. Type definitions and type safety are improved throughout `hot-reload.ts`.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This command starts the development server for the Modern.js application, enabling hot reloading and other development-time features. It provides a live-updating environment for making and testing changes.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Retry Plugin Implementation - Typescript\nDESCRIPTION: This TypeScript code snippet provides the implementation of the RetryPlugin as a runtime plugin for Rsbuild. It demonstrates how to configure the retry behavior, including the number of retry attempts, delay between retries, and a callback function for custom error handling. The plugin is designed to handle both fetch and script resource retries.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// src/runtime-plugin/retry.ts\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\nconst retryPlugin = () =>\n  RetryPlugin({\n    fetch: {},\n    script: {\n      retryTimes: 3,\n      retryDelay: 1000,\n      cb: (resolve, error) => {\n        return setTimeout(() => {\n          resolve(error);\n        }, 1000);\n      },\n    },\n  });\nexport default retryPlugin;\n```\n\n----------------------------------------\n\nTITLE: Basic createBridgeComponent Usage (TypeScript/JSX)\nDESCRIPTION: This snippet shows how to use `createBridgeComponent` to expose a Vue component for module federation. It takes the root component (App) and makes it available to other applications as a remote module.  It imports `createBridgeComponent` from `@module-federation/bridge-vue3`, the root Vue component (App), custom plugins, and the router.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.ts\nimport  { createBridgeComponent } from '@module-federation/bridge-vue3';\nimport App from './App.vue';\nimport customPlugin from './plugins/custom-vue-plugin';\nimport router from './router';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  appOptions: ({ app }) => {\n    // Optional: adding a plugin to the new Vue instance on the host application side\n    app.use(customPlugin);\n    return { router };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: createRemoteComponent Type Definition in TypeScript\nDESCRIPTION: Defines the type signature for the createRemoteComponent function. This function is used to load remote application modules in a module federation setup. It accepts an options object defining how to load and configure the remote component, and returns a Vue DefineComponent.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction createRemoteComponent<T, E extends keyof T>(\n  options: {\n    // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')\n    loader: () => Promise<T>;\n    // Default is 'default', used to specify module export\n    export?: E;\n    // Parameters that will be passed to defineAsyncComponent\n    asyncComponentOptions?: Omit<AsyncComponentOptions, 'loader'>;\n    // Attributes that will be bound to the root container where the remote Vue application will be mounted\n    rootAttrs?: Record<string, unknown>;\n  }\n): (props: {\n    basename?: string;\n    memoryRoute?: { entryPath: string };\n}) => DefineComponent;\n```\n\n----------------------------------------\n\nTITLE: Importing Remote Modules with React.lazy and Window API\nDESCRIPTION: This JavaScript code snippet illustrates different ways to import federated modules in a Next.js application. It showcases the use of `React.lazy` with the window API to dynamically load a module, standard `import` statement to directly import federated components. It also shows how to use low level API to import a federated module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React, { lazy } from 'react';\n\nconst SampleComponent = lazy(() =>\n  window.next2.get('./sampleComponent').then((factory) => {\n    return { default: factory() };\n  }),\n);\n\n// or\n\nconst SampleComponent = lazy(() => import('next2/sampleComponent'));\n\n//or\n\nimport Sample from 'next2/sampleComponent';\n```\n\n----------------------------------------\n\nTITLE: Install @module-federation/enhanced using yarn\nDESCRIPTION: This command installs the @module-federation/enhanced package, which is required for data prefetching, using yarn. This package needs to be installed in both the producer and host applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Add global flag for module graph revalidation - Javascript\nDESCRIPTION: Introduces a global flag `moduleGraphDirty` to control forced revalidation during hot-reload. The flag is initialized to `false`, and the `revalidate` function checks this flag to force revalidation if set to `true`. This impacts the runtime, enhanced, sdk, and utilities packages.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/node/CHANGELOG.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Initialized `moduleGraphDirty` to `false` in the global scope.\n// Forces revalidation if `moduleGraphDirty` is `true`.\n```\n\n----------------------------------------\n\nTITLE: Initializing and Loading Remote Modules with Module Federation Runtime\nDESCRIPTION: This code snippet demonstrates how to initialize the Module Federation runtime and load remote modules. It uses the `init` function to configure remote modules and the `loadRemote` function to dynamically load and use a module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/announcement.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: \"@demo/app1\",\n      entry: \"http://localhost:3005/mf-manifest.json\",\n      alias: \"app1\"\n    },\n    {\n      name: \"@demo/app2\",\n      entry: \"http://localhost:3006/remoteEntry.js\",\n      alias: \"app2\"\n    },\n  ],\n});\n\nloadRemote(\"app2/util\").then((md)=>{\n  md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: createBridgeComponent Type Definition in TypeScript\nDESCRIPTION: Defines the type signature for the createBridgeComponent function. This function is used to export an application-level module in a module federation setup. It accepts a bridgeInfo object containing the root Vue component and optional appOptions, and returns an object with render and destroy methods.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction createBridgeComponent(bridgeInfo: {\n  rootComponent: VueComponent;\n  appOptions?: (params: {\n    app: Vue.App<VueComponent>;\n    basename?: string;\n    memoryRoute?: { entryPath: string };\n    [key: string]: any;\n  }) => { router?: Router } | void;\n}): () => {\n  render(info: {\n    name?: string;\n    basename?: string;\n    memoryRoute?: {\n      entryPath: string;\n    };\n    dom?: HTMLElement;\n  }): void;\n  destroy(info: {\n    dom: HTMLElement;\n  }): void;\n}\n```\n\n----------------------------------------\n\nTITLE: React Bridge Module Export Example\nDESCRIPTION: This code demonstrates how to export a React application as a module using the Bridge pattern. It initializes a root map, renders the React application within a given DOM element, and provides a destroy function to unmount the application when needed. The code uses ReactDOM.createRoot for rendering in React 18+.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/index.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function () {\n  const rootMap = new Map<any, ReactDOM.Root>();\n  return {\n    render(info: { dom: HTMLElement; basename?: string; memoryRoute?: { entryPath: string; } }) {\n      const root = ReactDOM.createRoot(info.dom);\n      rootMap.set(info.dom, root);\n      root.render(\n        <App />,\n      );\n    },\n    destroy(info: { dom: HTMLElement }) {\n      const root = rootMap.get(info.dom);\n      root?.unmount();\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding New Features or Entries with pnpm\nDESCRIPTION: This command allows you to add new optional features or a new entry point to the Modern.js application.  It likely triggers a CLI tool that helps scaffold and configure these additions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm new\n```\n\n----------------------------------------\n\nTITLE: Fetch Manifest with Credentials (TypeScript)\nDESCRIPTION: Example of how to use the `fetch` hook to include credentials when fetching the manifest JSON. This allows the manifest to be fetched from a protected resource that requires authentication. Imports necessary types from `@module-federation/enhanced/runtime`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// fetch-manifest-with-credentials-plugin.ts\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\n\nexport default function (): FederationRuntimePlugin {\n  return {\n    name: 'fetch-manifest-with-credentials-plugin',\n    fetch(manifestUrl, requestInit) {\n      return fetch(manifestUrl, {\n        ...requestInit,\n        credentials: 'include'\n      });\n    },\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Consumer: modern.config.ts\nDESCRIPTION: This TypeScript file configures the Modern.js application settings for the consumer application, including enabling the Module Federation plugin and setting up SSR.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3007,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Remote Page with getServerSideProps in Next.js\nDESCRIPTION: This code defines a Next.js page component that fetches data using 'getServerSideProps'. It retrieves data from a remote API and passes it as props to the 'Page' component. The 'Page' component then displays the 'stargazers_count' property from the fetched repository data.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nexport const getServerSideProps = async () => {\n  // Fetch data from external API\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\n  const repo = await res.json()\n  // Pass data to the page via props\n  return { props: { repo } }\n}\n\nexport default function Page({ repo }) {\n  return (\n    <main>\n      <p>{repo.stargazers_count}</p>\n    </main>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation Remotes Configuration (JavaScript)\nDESCRIPTION: Demonstrates how to configure remotes within a Module Federation plugin setup. It defines two remote modules: `manifest-provider` which uses `mf-manifest.json` as the entry point, and `js-entry-provider` which uses `remoteEntry.js`. The `name` property identifies the current module as 'host'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/remotes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'host',\n      // 下面的 remotes 中定义了两个 remote，分别是名称为：manifest_provider 在 3011 端口启动的项目、js_entry_provider 在 3012 端口启动的项目\n      remotes: {\n        'manifest-provider':\n          'manifest_provider@http://localhost:3011/mf-manifest.json',\n        'js-entry-provider':\n          'js_entry_provider@http://localhost:3012/remoteEntry.js',\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Module Federation Runtime\nDESCRIPTION: This code demonstrates how to import the default runtime from `@module-federation/runtime-tools`.  It shows both importing the default export and importing the runtime directly from the `/runtime` subpath. This import provides functionality for managing module federation at runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport runtime from '@module-federation/runtime-tools';\nimport runtime from '@module-federation/runtime-tools/runtime';\n```\n\n----------------------------------------\n\nTITLE: Using export to specify module export (TSX)\nDESCRIPTION: Illustrates how to use the `export` option in `createRemoteComponent` to specify a non-default export from the remote module.  In the remote application, `createBridgeComponent` is used to export a named component `provider`.  In the host application, the `export: 'provider'` option is used in `createRemoteComponent` to load the specific exported component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// 远程应用\nexport const provider = createBridgeComponent({\n  rootComponent: App\n});\n\n// 宿主应用\nconst Remote1App = createRemoteComponent({\n  loader: () => loadRemote('remote1/export-app'),\n  export: 'provider', // 指定使用 provider 导出\n  fallback: FallbackErrorComp,\n  loading: FallbackComp,\n});\n```\n\n----------------------------------------\n\nTITLE: Loading a Remote Module\nDESCRIPTION: Example demonstrating how to load a remote module using the `loadRemote` function. It initializes the runtime and then loads the `util` module exposed by the remote application `@demo/app2`, using both the remote name and alias.  The remote application is expected to be running at `http://localhost:3006/remoteEntry.js`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\n\ninit({\n  name: '@demo/main-app',\n  remotes: [\n    {\n      name: '@demo/app2',\n      alias: 'app2',\n      entry: 'http://localhost:3006/remoteEntry.js',\n    },\n  ],\n});\n\n// remoteName + expose\nloadRemote('@demo/app2/util').then((m) => m.add(1, 2, 3));\n\n// alias + expose\nloadRemote('app2/util').then((m) => m.add(1, 2, 3));\n```\n\n----------------------------------------\n\nTITLE: SSR Stale While Revalidate (JSX)\nDESCRIPTION: This code implements a 'stale while revalidate' strategy in `_document.js` to handle updates from remote modules.  `revalidate()` checks for updates after the response is sent. Requires `@module-federation/nextjs-mf/utils`. This is not recommended due to potential hydration errors.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nstatic async getInitialProps(ctx) {\n  const initialProps = await Document.getInitialProps(ctx);\n  ctx?.res?.on('finish', () => {\n    revalidate().then((shouldUpdate) => {\n      console.log('Response sent, checking for updates:', shouldUpdate);\n    });\n  });\n  return initialProps;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Federation Plugin in Rsbuild\nDESCRIPTION: This snippet configures the Module Federation plugin within an Rsbuild project. It defines the plugin's name, remote modules, and runtime plugins, enabling synchronous module loading and custom error handling through specified hooks.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n      runtimePlugins: [\n        path.join(__dirname, './src/runtime-plugin/retry.ts'),\n        path.join(__dirname, './src/runtime-plugin/fallback.ts'),\n      ],\n      ...\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting Vue App with createBridgeComponent - TSX\nDESCRIPTION: This example demonstrates how to export a Vue V3 application as a module using `createBridgeComponent`. It imports the main App component, router, and a custom plugin, then calls `createBridgeComponent` with the root component and configuration options for the Vue app.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.ts\nimport App from './App.vue';\nimport router from './router';\nimport customPlugin from './plugins/custom-vue-plugin';\nimport { createBridgeComponent } from '@module-federation/bridge-vue3';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  appOptions: ({app}) => {\n    // Optional: adding a plugin to the new Vue instance on the host application side\n    app.use(customPlugin);\n    return { router };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Revalidate Stale While Revalidate (_document.js)\nDESCRIPTION: This JavaScript code snippet implements revalidation using the Stale While Revalidate strategy.  It listens for the 'finish' event on the response object and then checks for updates using the `revalidate` function, allowing the server to send the initial response before checking for updates in the background.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nstatic async getInitialProps(ctx) {\n  const initialProps = await Document.getInitialProps(ctx);\n  ctx?.res?.on('finish', () => {\n    revalidate().then((shouldUpdate) => {\n      console.log('Response sent, checking for updates:', shouldUpdate);\n    });\n  });\n  return initialProps;\n}\n```\n\n----------------------------------------\n\nTITLE: React Version Specific Imports (TSX)\nDESCRIPTION: Demonstrates how to import specific versions of `createBridgeComponent` from `@module-federation/bridge-react` to ensure compatibility with different React versions (16/17, 18, and 19). This allows teams to independently upgrade their React versions while maintaining module federation stability.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Explicitly specify React 16/17 version (recommended for React 16/17)\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n\n// Explicitly specify React 18 version (recommended for React 18)\nimport { createBridgeComponent } from '@module-federation/bridge-react/v18';\n\n// Explicitly specify React 19 version (recommended for React 19)\nimport { createBridgeComponent } from '@module-federation/bridge-react/v19';\n```\n\n----------------------------------------\n\nTITLE: Exporting Vue App with createBridgeComponent - TSX\nDESCRIPTION: This example demonstrates how to export a Vue V3 application as a module using `createBridgeComponent`. It imports the main App component, router, and a custom plugin, then calls `createBridgeComponent` with the root component and configuration options for the Vue app.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// ./src/export-app.ts\nimport  { createBridgeComponent } from '@module-federation/bridge-vue3';\nimport App from './App.vue';\nimport customPlugin from './plugins/custom-vue-plugin';\nimport router from './router';\n\nexport default createBridgeComponent({\n  rootComponent: App,\n  appOptions: ({app}) => {\n    // Optional: adding a plugin to the new Vue instance on the host application side\n    app.use(customPlugin)\n    return { router };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setup and Run Development Servers (Bash)\nDESCRIPTION: This snippet provides commands to install project dependencies and start development servers for the application router. It assumes pnpm is installed globally. It uses pnpm to install dependencies and then concurrently starts two development servers on ports 2000 and 2100 respectively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Root directory\npnpm install\npnpm run app:router:dev\n\nopen http://localhost:2000/\nopen http://localhost:2100/\n```\n\n----------------------------------------\n\nTITLE: Generate Preload Assets Type Definition (TypeScript)\nDESCRIPTION: Defines the types and interface for the `generatePreloadAssets` function, which is used to generate assets that should be preloaded based on the Module Federation configuration. It specifies the input options and the structure of the assets to be preloaded, including CSS assets, JS assets without an entry point, and entry assets.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nasync function generatePreloadAssets(\n  args: GeneratePreloadAssetsOptions,\n): Promise<PreloadAssets>;\n\ntype GeneratePreloadAssetsOptions = {\n  origin: FederationHost;\n  preloadOptions: PreloadOptions[number];\n  remote: Remote;\n  remoteInfo: RemoteInfo;\n  remoteSnapshot: ModuleInfo;\n  globalSnapshot: GlobalModuleInfo;\n};\n\ninterface PreloadAssets {\n  cssAssets: Array<string>;\n  jsAssetsWithoutEntry: Array<string>;\n  entryAssets: Array<EntryAssets>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Remote Component Renderer Directive (HTML)\nDESCRIPTION: This HTML snippet shows how to use the `remoteComponentRenderer` directive in an Angular view. It sets the `remoteComponentRenderer` input to the name of the component ('ClockComponent') and the `module` input to the module identifier ('mf1/Clock').\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_13\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *remoteComponentRenderer=\"'ClockComponent'; module:'mf1/Clock'\"></ng-container>\n```\n\n----------------------------------------\n\nTITLE: Webpack/Rspack watchOptions Configuration\nDESCRIPTION: This snippet configures webpack or rspack's `watchOptions` to ignore changes in the `@mf-types` directory, preventing circular compilation issues caused by the compiler re-compiling when type definition files are updated. Ignoring this directory ensures efficient type hot-reloading without triggering unnecessary rebuilds.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/type-prompt.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconfig.watchOptions = {\n  ignored: ['**/node_modules/**', '**/@mf-types/**'],\n};\n```\n\n----------------------------------------\n\nTITLE: Modern.js Configuration with Module Federation Plugin\nDESCRIPTION: This snippet shows how to configure a Modern.js application to use the Module Federation plugin. It defines runtime options, server-side rendering settings, and registers the Module Federation plugin using `moduleFederationPlugin()`. It depends on `@modern-js/app-tools` and `@module-federation/modern-js`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3008,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Host App: Importing and Re-exporting Remote Page with getServerSideProps\nDESCRIPTION: This code demonstrates importing a remote page component and its `getServerSideProps` function in a Next.js host application. It imports both the default export and the named `getServerSideProps` from the remote module and re-exports them, ensuring that the host application can access the remote page's data fetching logic.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as OtherPage from 'remote/pages/other';\nconst Page = OtherPage.default;\nexport const getServerSideProps = OtherPage.getServerSideProps\nexport default Page;\n```\n\n----------------------------------------\n\nTITLE: Module Federation Configuration in TypeScript\nDESCRIPTION: This code snippet defines the Module Federation configuration for a producer named 'dynamic_provider'. It specifies the remote entry file, exposed modules, and shared dependencies like React and ReactDOM. This configuration is crucial for enabling module sharing and dynamic loading in a federated architecture.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/dynamic-remote.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'dynamic_provider',\n  filename: 'remoteEntry.js',\n  exposes: {\n    './Image': './src/components/Image.tsx',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Angular CLI: Add Module Federation plugin\nDESCRIPTION: Uses the Angular CLI to add the `@angular-architects/module-federation` plugin to a project, configuring it as either a host (shell) or remote (microfrontend) application. The `--project` flag specifies the target project, `--port` sets the port for serving the application, and `--type` defines the application type (host or remote).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project shell --port 4200 --type host\nng add @angular-architects/module-federation --project mfe1 --port 4201 --type remote\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Login Module from Library\nDESCRIPTION: This code snippet updates the main application's routing module to lazy-load the LoginModule from the newly built 'login-lib' library.  It uses a dynamic import statement to load the module asynchronously. This integration allows the Login micro-frontend to be integrated without increasing the main application's initial bundle size, improving performance.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nloadChildren: () => import('@@login').then((m) => m.LoginModule),\n```\n\n----------------------------------------\n\nTITLE: Ignore @mf-types to prevent circular compilation\nDESCRIPTION: This snippet shows how to configure webpack or rspack to ignore the `@mf-types` directory during compilation. This is important to prevent circular compilation issues that can occur when type updates trigger new compilations.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/type-prompt.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconfig.watchOptions = {\n  ignored: ['**/node_modules/**', '**/@mf-types/**'],\n};\n```\n\n----------------------------------------\n\nTITLE: Usage of mf dts command\nDESCRIPTION: Displays the usage instructions for the `mf dts` command, including available options for generating or fetching remote types. It lists the flags for specifying the root directory, output directory, and enabling or disabling fetching and generation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/cli.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nUsage: mf dts [options]\n\ngenerate or fetch the mf types\n\nOptions:\n  --root <root>         specify the project root directory\n  --output <output>     specify the generated dts output directory\n  --fetch <boolean>     fetch types from remote, default is true (default: true)\n  --generate <boolean>  generate types, default is true (default: true)\n  -c --config <config>  specify the configuration file, can be a relative or absolute path\n  -m --mode <mode>      Specify the runtime environment. You can choose \"dev\" or \"prod\". The default value is \"dev\". After setting, the process.env.NODE_ENV environment variable will be\n                        automatically injected with \"development\" or \"production\" according to the value. (default: \"dev\")\n  -h, --help            display help for command\n```\n\n----------------------------------------\n\nTITLE: Import and Configure AuthModule in AppModule\nDESCRIPTION: This code snippet demonstrates how to import the AuthModule from @auth0/auth0-angular into the AppModule and configure it with the Auth0 domain and client ID. This step is essential for initializing Auth0 within the Angular application. Replace YOUR_AUTH0_DOMAIN and YOUR_AUTH0_CLIENT_ID with your actual Auth0 credentials.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/auth0.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AuthModule } from '@auth0/auth0-angular';\n\n@NgModule({\n  imports: [\n    AuthModule.forRoot({\n      domain: 'YOUR_AUTH0_DOMAIN',\n      clientId: 'YOUR_AUTH0_CLIENT_ID'\n    }),\n    // other imports...\n  ],\n  // other module properties...\n})\nexport class AppModule { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Language Switcher Component\nDESCRIPTION: This snippet implements a React component `LanguageSwitcher` that uses the `useSwitchLanguage` hook to trigger language changes across all applications.  It defines a button that, when clicked, calls the `switchAllLanguages` function with a specified language code.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useSwitchLanguage } from 'src/hooks/useSwitchLanguage';\n\nconst LanguageSwitcher = () => {\n  const { switchAllLanguages } = useSwitchLanguage();\n  const handleLanguageSwitch = (lng) => () => switchAllLanguages(lng);\n\n  return <button onClick={handleLanguageSwitch(\"ua\")}>Change language to Ukrainian</button>;\n};\n\nexport default LanguageSwitcher;\n```\n\n----------------------------------------\n\nTITLE: Building the Angular Library (models)\nDESCRIPTION: This command uses the Angular CLI to build the 'models' library. Building the library compiles the TypeScript code and generates the necessary files for distribution. This ensures that the library can be properly referenced and used by other modules and applications within the Angular project. It resolves errors that might occur due to the library not being built.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nng build models\n```\n\n----------------------------------------\n\nTITLE: Configure Login Callback Route\nDESCRIPTION: This code snippet updates the `app-routing.module.ts` file to include a route for the Okta callback component.  This route is essential for handling the redirect from Okta after a successful login attempt. The `OktaCallbackComponent` processes the authentication response and updates the application's authentication state.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Routes } from '@angular/router';\nimport { OktaCallbackComponent } from '@okta/okta-angular';\n\nconst routes: Routes = [\n  { path: '', component: ProductsComponent },\n  { path: 'basket', loadChildren: () => import('mfeBasket/Module').then(m => m.BasketModule) },\n  { path: 'login/callback', component: OktaCallbackComponent }\n];\n```\n\n----------------------------------------\n\nTITLE: Configure tsconfig.json for Federation Runtime API Type Hints\nDESCRIPTION: This snippet shows how to modify the `tsconfig.json` file to include the `./@mf-types/*` directory in the `include` field. This enables type hinting and hot reloading for the Federation Runtime's `loadRemote` function. This configuration is required to leverage type safety when using the Federation Runtime API.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/type-prompt.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"include\": [\"./@mf-types/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Plugin in rspack (TypeScript)\nDESCRIPTION: This snippet shows how to configure a runtime plugin within an rspack configuration file.  It demonstrates using the ModuleFederation plugin and specifying the path to the custom runtime plugin using `path.resolve`. The `runtimePlugins` array takes an array of paths to runtime plugin files.  The plugin is added to the rspack plugins array.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/runtimeplugins.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  plugins: [\n    new ModuleFederation({\n      name: 'host',\n      remotes: {\n        'manifest-provider':\n          'manifest_provider@http://localhost:3011/mf-manifest.json',\n      },\n      runtimePlugins: [path.resolve(__dirname, './custom-runtime-plugin.ts')],\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Building the Angular Library (auth)\nDESCRIPTION: This command uses the Angular CLI to build the 'auth' library. Building the library compiles the TypeScript code and generates the distributable package.  This step is necessary to make the 'auth' library available for import and usage in other parts of the application or in other applications within the micro-frontend architecture. The compiled output is used for creating distributable artifacts.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nng build auth\n```\n\n----------------------------------------\n\nTITLE: Handle Login and Logout in UI\nDESCRIPTION: This code snippet adds the user interface logic in `app.component.html` for the login and logout buttons. The template checks the authentication status and displays the appropriate button.  It uses the `isAuthenticated$` observable to dynamically update the UI based on the user's authentication state.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<li>\n  <button *ngIf=\"(isAuthenticated$ | async) === false; else logout\" (click)=\"signIn()\">\n    Sign In\n  </button>\n\n  <ng-template #logout>\n    <button (click)=\"signOut()\">\n      Sign Out\n    </button>\n  </ng-template>\n</li>\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Plugins with NextFederationPlugin\nDESCRIPTION: This JavaScript code snippet demonstrates how to configure runtime plugins within the NextFederationPlugin. Runtime plugins provide a mechanism for extending and customizing the behavior of Module Federation at runtime, enabling features like middleware and enhanced module loading. The `runtimePlugins` option accepts an array of module paths to the plugin files.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// next.config.js\nnew NextFederationPlugin({\n  runtimePlugins: [require.resolve('./path/to/myRuntimePlugin.js')],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Plugin with Angular CLI\nDESCRIPTION: This command installs the `@angular-architects/module-federation` plugin and configures Module Federation for a specified Angular project. The `--project` option defines the project to configure, `--port` sets the port for the application, and `--type` specifies whether the project is a `host` (shell) or `remote` (micro-frontend).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project shell --port 4200 --type host\nng add @angular-architects/module-federation --project mfe1 --port 4201 --type remote\n```\n\n----------------------------------------\n\nTITLE: Support modern.js ssr\nDESCRIPTION: This snippet details adding support for modern.js server-side rendering (SSR). It broadens compatibility by supporting Module Federation in modern.js-based SSR architectures.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Creating Button Component in MFE2\nDESCRIPTION: This code creates a simple React button component in MFE2. The component is then exported to be used in other modules.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst Button = () => (\n  <button>MFE2 Button</button>\n);\n\nexport default Button;\n```\n\n----------------------------------------\n\nTITLE: Nx CLI: Initialize Module Federation\nDESCRIPTION: Uses Nx CLI to initialize Module Federation in an Angular project. First installs the `@angular-architects/module-federation` plugin as a dev dependency, then uses the `ng g` command to generate the necessary configuration files. The `--project`, `--port`, and `--type` flags are used similarly to the Angular CLI version.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @angular-architects/module-federation -D\nng g @angular-architects/module-federation:init --project shell --port 4200 --type host\nng g @angular-architects/module-federation:init --project mfe1 --port 4201 --type remote\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin with Shared Dependencies (Object with Customization)\nDESCRIPTION: This example demonstrates how to configure the `shared` option in the `ModuleFederationPlugin` using an object to allow for more customized configurations. It configures the `react` dependency as a singleton with a specific `requiredVersion` and the `fixedDependencies` option set to true.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/shared.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n  name: '@demo/button',\n  shared: {\n    react: {\n      singleton: true,\n      requiredVersion: '~18.2.0',\n      fixedDependencies: true\n    }\n  },\n  //...\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Modules (TS)\nDESCRIPTION: Demonstrates how to configure remote modules in the consumer project's `rsbuild.config.ts`. This involves registering the remote module with the `pluginModuleFederation`, specifying the remote module's name and the URL of its manifest file. This enables the consumer to access the exposed modules from the remote application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/react-bridge.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Routing for Authentication (TypeScript)\nDESCRIPTION: Updates the `app-routing.module.ts` file to include a route for the Okta callback component. This route is used to handle the authentication redirect from Okta after a successful login. It also sets up lazy loading for a basket module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Routes } from '@angular/router';\nimport { OktaCallbackComponent } from '@okta/okta-angular';\n\nconst routes: Routes = [\n  { path: '', component: ProductsComponent },\n  { path: 'basket', loadChildren: () => import('mfeBasket/Module').then(m => m.BasketModule) },\n  { path: 'login/callback', component: OktaCallbackComponent }\n];\n```\n\n----------------------------------------\n\nTITLE: Declare Remote Modules (TypeScript)\nDESCRIPTION: This TypeScript declaration file (`remote-modules.d.ts`) declares the existence of remote modules that will be loaded dynamically at runtime. This allows TypeScript to recognize the modules and prevent compilation errors. Without this declaration, the compiler would not know about modules like 'mf1/Contact' and 'mf1/Clock'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'mf1/Contact';\ndeclare module 'mf1/Clock';\n```\n\n----------------------------------------\n\nTITLE: Configure Module Federation in Host\nDESCRIPTION: This code configures the ModuleFederationPlugin in the host application. It sets the unique name for the host and defines a remote module ('remote1') pointing to the remote application's mf-manifest.json.  This allows the host to load and use modules exposed by the remote.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n//rsbuild.config.ts\nexport default defineConfig({\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      config.output!.uniqueName = 'host';\n      appendPlugins([\n        new ModuleFederationPlugin({\n          name: 'host',\n          remotes: {\n            remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n          },\n        }),\n      ]);\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Button Component with usePrefetch Hook TSX\nDESCRIPTION: This TypeScript JSX snippet shows how to use the `usePrefetch` hook from `@module-federation/enhanced/prefetch` within a React component. It defines a button that triggers a re-fetch of data with new parameters. It uses Suspense and Await components from `react-router-dom` to handle the asynchronous data loading and rendering.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Suspense } from 'react';\nimport { usePrefetch } from '@module-federation/enhanced/prefetch';\nimport { Await } from 'react-router-dom';\n\ninterface UserInfo {\n  id: number;\n  title: string;\n};\nconst reFetchParams = {\n  data: {\n    id: 2,\n    title: 'Another Prefetch Title',\n  }\n}\nexport default function Button () {\n  const [prefetchResult, reFetchUserInfo] = usePrefetch<UserInfo>({\n    // 对应生产者 ModuleFederationPlugin 中的 (name + expose)，例如 `app2/Button` 用于消费 `Button.prefetch.ts`\n    id: 'app2/Button',\n    // 可选参数，使用 defer 后必填\n    deferId: 'userInfo',\n    // default 导出默认可以不传 functionId，此处为举例说明，如果非 default 导出则需要填函数名,\n    // functionId: 'default',\n  });\n\n  return (\n    <>\n      <button onClick={() => reFetchUserInfo(reFetchParams)}>重新发送带参数的请求</button>\n      <Suspense fallback={<p>Loading...</p>}>\n        <Await\n          resolve={prefetchResult}\n          children={userInfo => (\n            <div>\n              <div>{userInfo.data.id}</div>\n              <div>{userInfo.data.title}</div>\n            </div>\n          )}\n        ></Await>\n      </Suspense>\n    </>\n  )\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Runtime Tools\nDESCRIPTION: This command installs the `@module-federation/runtime-tools` package using npm. This package provides essential runtime components for module federation, simplifying setup by bundling multiple related packages.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @module-federation/runtime-tools\n```\n\n----------------------------------------\n\nTITLE: Generating a New Angular Application (login)\nDESCRIPTION: This command uses the Angular CLI to generate a new Angular application named 'login'. The `--style=scss` flag specifies that the application should use SCSS for styling, and the `--routing` flag indicates that the application should include routing support. The new application will become a micro-frontend responsible for the login functionality.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nng generate application login --style=scss --routing\n```\n\n----------------------------------------\n\nTITLE: Creating Rsbuild Provider Project\nDESCRIPTION: This snippet shows an example of creating a rsbuild provider project using `npm create module-federation@latest` with interactive prompts to configure the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n➜  ~  ✗ npm create module-federation@latest\n\n> npx\n> create-module-federation\n\n◆  Create Module Federation Project\n│\n◇  Please input Module Federation name:\n│  mf_provider\n│\n◇  Please select the type of project you want to create:\n│  Application\n│\n◇  Select template\n│  Rsbuild\n│\n◇  Please select the role of project you want to create:\n│  Provider\n│\n◇  Next steps ─────╮\n│                  │\n│  cd mf_provider  │\n│  npm install     │\n│  npm run dev     │\n│                  │\n├──────────────────╯\n│\n└  Done.\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with useIsRemote Hook\nDESCRIPTION: This snippet demonstrates using the `useIsRemote` hook to conditionally render the `LanguageSwitcher` component in App B.  The `LanguageSwitcher` is only displayed if the application is not running as a remote (i.e., it is running standalone).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/i18n-react.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport useIsRemote from './hooks/useIsRemote';\nimport LanguageSwitcher from './components/LanguageSwitcher';\n\nconst App = () => {\n  const isRemote = useIsRemote();\n\n  return (\n    <div>\n      {/* Only display the LanguageSwitcher if not running as a remote */}\n      {!isRemote && <LanguageSwitcher />}\n    </div>\n  );\n};\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 18 LTS via nvm (Bash)\nDESCRIPTION: These commands install Node.js version 18 (LTS) using nvm (Node Version Manager), set it as the default version, and switch to it. This ensures the correct Node.js environment for Modern.js development.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 18\nnvm install 18 --lts\n\n# Make the newly installed Node.js 18 as the default version\nnvm alias default 18\n\n# Switch to the newly installed Node.js 18\nnvm use 18\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies with pnpm\nDESCRIPTION: This command installs the necessary dependencies for the Rsbuild project using the pnpm package manager. It ensures that all project dependencies are resolved and installed correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-2000/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Provider Module Federation config (TS)\nDESCRIPTION: This configuration file (`module-federation.config.ts`) defines the Module Federation settings for the provider application.  It specifies the name of the module, the filename for the remote entry point, the exposed modules (e.g., `./Image`), and shared dependencies like React and ReactDOM.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'provider',\n  filename: 'remoteEntry.js',\n  exposes: {\n    './Image': './src/components/Image.tsx',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Federation Tests with Rspack\nDESCRIPTION: This configuration snippet shows how to integrate `NativeFederationTestsHost` and `NativeFederationTestsRemote` plugins within a `rspack.config.js` file. The plugins are added to the `plugins` array in the Rspack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// rspack.config.js\nconst { NativeFederationTestsHost, NativeFederationTestsRemote } = require('@module-federation/native-federation-tests/rspack');\n\nmodule.exports = {\n  /* ... */\n  plugins: [\n    NativeFederationTestsRemote({\n      /* options */\n    }),\n    NativeFederationTestsHost({\n      /* options */\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 20 LTS with nvm\nDESCRIPTION: These commands use nvm (Node Version Manager) to install Node.js version 20 (Long Term Support), set it as the default version, and switch to using it. nvm allows managing multiple Node.js versions on a single system.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 20\nnvm install 20 --lts\n\n# Make the newly installed Node.js 20 as the default version\nnvm alias default 20\n\n# Switch to the newly installed Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR Option\nDESCRIPTION: Demonstrates how to configure the `ssr` option within the `moduleFederationPlugin` in `modern.config.ts` to disable server-side rendering for Module Federation, allowing progressive migration to CSR-only scenarios.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  dev: {\n    port: 3050,\n  },\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n  },\n  plugins: [\n    appTools(),\n    moduleFederationPlugin({ ssr: false })\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Starting Shell and Remote Applications (Bash)\nDESCRIPTION: These commands start the Shell and Remote applications using the Angular CLI. The `ng serve` command starts the development server for each project. The `-o` flag opens the application in the default browser. Starting both applications allows for testing the Module Federation setup.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nng serve shell -o\nng serve mfe1 -o\n```\n\n----------------------------------------\n\nTITLE: Bootstrap - Importing Delegated Modules in TypeScript\nDESCRIPTION: This example demonstrates how to import and use the delegated modules `test1` and `test2` from the remote entry `delegateModulesA`. The imports are resolved by the module delegation plugin, and the imported modules contain the resolved values after the delay.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// src/bootstrap.js\nimport test1 from \"delegateModulesA/test1\"\nimport test2 from \"delegateModulesA/test2\"\ntest1 // \"test1 value\"\ntest2 // \"test2 value\"\n```\n\n----------------------------------------\n\nTITLE: Remote _app.js in Next.js\nDESCRIPTION: This code defines a custom `_app.js` component in a Next.js application. It extends the default `App` component and overrides the `getInitialProps` method. It wraps the page component with some layout or context providers.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/importing-pages.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport App  from 'next/app'\n\nexport default function MyApp({\n  Component,\n  pageProps,\n  example,\n}) {\n  return (\n    <>\n      <Component {...pageProps} />\n    </>\n  )\n}\n\nMyApp.getInitialProps = async (context) => {\n  const ctx = await App.getInitialProps(context)\n\n  return { ...ctx }\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Modules Dangerously in Module Federation - Javascript\nDESCRIPTION: This code snippet demonstrates how to manually share modules in a Module Federation setup, which is now considered a potentially dangerous practice due to issues with singleton packages. It defines a shared configuration object where `fakeLodash` is configured to import `lodash` using the `lodash` share key.  Use this with caution as its primary use case has been deprecated in favor of internal Next package management.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/nextjs-mf/CHANGELOG.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: PluginDevOptions Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the options available for configuring the development behavior of the Module Federation plugin. It includes options for disabling live reload, hot type reloading, and dynamic remote type hints. These options allow developers to fine-tune the development experience based on their specific needs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/configure/dev.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface PluginDevOptions {\n  disableLiveReload?: boolean;\n  disableHotTypesReload?: boolean;\n  disableDynamicRemoteTypeHints?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Generate New Angular Application (Bash)\nDESCRIPTION: Generates a new Angular application named `mfe-profile` using the Angular CLI. The command includes options for routing, CSS styling, inline styles, and skipping test file creation. This application will be configured as a micro-frontend.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/okta-auth.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nng generate application mfe-profile --routing --style css --inline-style --skip-tests\n```\n\n----------------------------------------\n\nTITLE: Host Module Federation Configuration in TypeScript\nDESCRIPTION: This configuration uses the `@module-federation/rsbuild-plugin` to define a host module federation setup.  It specifies the name of the host (`host`), and remotes that it will consume modules from.  Requires @module-federation/rsbuild-plugin and rsbuild.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n//rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginModuleFederation({\n      name: 'host',\n      remotes: {\n        remote1: 'remote1@http://localhost:2001/mf-manifest.json',\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Workbox Webpack Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet configures Workbox as a Webpack plugin to manage service worker behavior in a Module Federation setup. It encourages fast activation and prevents old service workers from lingering.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { GenerateSW } = require('workbox-webpack-plugin');\n\nmodule.exports = {\n  // ... other webpack config relevant to Module Federation\n  plugins: [\n    new GenerateSW({\n      // Configurations specific to your Module Federation setup\n      // these options encourage the ServiceWorkers to get in there fast\n      // and not allow any straggling \"old\" SWs to hang around\n      clientsClaim: true,\n      skipWaiting: true,\n    })\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Consumer: module-federation.config.ts\nDESCRIPTION: This TypeScript file configures the Module Federation settings for the consumer application. It defines the name, remotes, and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'consumer',\n  remotes: {\n    remote: 'provider@http://localhost:3006/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initialize Module Federation Runtime with Node Plugin\nDESCRIPTION: This snippet shows how to initialize the Module Federation Runtime with the Node plugin. It imports the `init` function and the `nodeRuntimePlugin`, then calls `init` with configuration options including remotes and plugins.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/plugins/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {init} from '@module-federation/runtime';\nimport nodeRuntimePlugin from '@module-federation/node/runtimePlugin';\ninit({\n  name: '@demo/app-main',\n  remotes: [\n    {\n      name: '@demo/app2',\n      entry: 'http: //localhost:3006/mf-manifest.json',\n      alias: 'app2',\n    },\n  ],\n  plugins: [nodeRuntimePlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Route Cache Clear During Revalidation (JSX)\nDESCRIPTION: This code snippet shows how to trigger the `global.clearRoutes` callback within the `getInitialProps` method of the `_document.js` file in a Next.js application. By calling `global.clearRoutes()` during the revalidation process (specifically, after `revalidate()` resolves and returns `true`), the Express route cache is cleared, enabling updated routes to be served without requiring a server restart. This integration is crucial for hot module replacement in Express.js when combined with Next.js.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/express.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    if (ctx?.pathname && !ctx?.pathname?.endsWith('_error')) {\n      await revalidate().then((shouldUpdate) => {\n        if (shouldUpdate) {\n          global.clearRoutes();\n        }\n      });\n    }\n\n    const initialProps = await Document.getInitialProps(ctx);\n    return initialProps;\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modify rsbuild.config.ts for MFE2\nDESCRIPTION: This code modifies the `rsbuild.config.ts` file in MFE2 to include the Module Federation plugin. It imports the plugin and the Module Federation configuration, then adds the plugin to the `plugins` array.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\n+ import { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n+ import mfConfig from './module-federation.config';\n\nexport default defineConfig({\n  server: {\n    port: 3002\n  },\n  plugins: [\n    pluginReact()\n+   pluginModuleFederation(mfConfig)\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Update App.tsx in MFE1\nDESCRIPTION: This code updates the `App.tsx` file in MFE1 to import and render the `Button` component from MFE2 via Module Federation. It uses a federated import `remote/Button` to access the exposed component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport Button from 'remote/Button'; // federated import\n\nfunction App() {\n  return (\n    <div>\n      <h1>MFE1</h1>\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: rsbuild Configuration for Remote - TS\nDESCRIPTION: This example shows the rsbuild configuration for the remote application. It uses the `pluginModuleFederation` plugin to configure the module federation settings, including the name of the remote, the exposed modules, and the shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/vue-bridge.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// rsbuild.config.ts\nimport { pluginModuleFederation } from '@module-federation/rsbuild-plugin';\n\nexport default defineConfig({\n  plugins: [\n    pluginModuleFederation({\n      name: 'remote1',\n      exposes: {\n        './export-app': './src/export-app.ts',\n      },\n      shared: ['vue', 'vue-router'],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Build Login Library\nDESCRIPTION: This command uses the Angular CLI to build the login-lib library.  This prepares the module for use in other applications by packaging it according to the configuration in angular.json and ng-package.json.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nng build login-lib\n```\n\n----------------------------------------\n\nTITLE: Basic createRemoteComponent Usage (TypeScript/JSX)\nDESCRIPTION: This snippet showcases a basic usage of `createRemoteComponent` to load a remote module.  It loads the module 'remote1/export-app' and assigns the resulting component to `Remote1App`.  Requires `@module-federation/bridge-vue3` and a global or imported `loadRemote` function.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/bridge/vue-bridge.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst Remote1App = createRemoteComponent({ loader: () => loadRemote('remote1/export-app') });\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for Remote Module\nDESCRIPTION: Defines a TypeScript declaration for the virtual path used to import the remote module. This declaration helps the TypeScript compiler to recognize the `mfe1/Module` path and avoid compilation errors when importing the remote module in the shell application. This goes inside a `decl.d.ts` file.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// decl.d.ts\ndeclare module 'mfe1/Module';\n```\n\n----------------------------------------\n\nTITLE: Remote Component Renderer Usage (Angular)\nDESCRIPTION: This HTML snippet shows how to use the `remoteComponentRenderer` directive in an Angular view. It specifies the component name (`ClockComponent`) and the module to load (`mf1/Clock`). The directive dynamically renders the specified component within the `ng-container`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_13\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *remoteComponentRenderer=\"'ClockComponent'; module:'mf1/Clock'\"></ng-container>\n```\n\n----------------------------------------\n\nTITLE: Exposing Hook via Module Federation\nDESCRIPTION: This snippet shows how to expose the `useSwitchLanguage` hook via Module Federation.  It configures the module federation plugin to expose the hook at a specific path. This allows other applications, such as App A, to import and use the hook.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/i18n-react.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Module Federation exposes configuration\nexposes: {\n  './hooks/useSwitchAppBLanguage': './src/hooks/useSwitchLanguage',\n},\n```\n\n----------------------------------------\n\nTITLE: Generate a New Angular Application\nDESCRIPTION: This command generates a new Angular application named `mfe-profile` with routing enabled, CSS styling, inline styles, and skipping tests. The new app is configured to support routing and has a basic setup for styling.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nng generate application mfe-profile --routing --style css --inline-style --skip-tests\n```\n\n----------------------------------------\n\nTITLE: Example Plugin with Naming Convention\nDESCRIPTION: Demonstrates a plugin adhering to the recommended naming convention. The plugin is a function that returns a plugin instance with a name in the 'xxx-plugin' format.  It showcases how to properly structure and export a Module Federation runtime plugin.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/plugin/dev/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/enhanced/runtime';\nconst pluginFooBar = (): FederationRuntimePlugin => ({\n  name: 'xxx-plugin',\n  //...\n});\n\nexport default pluginFooBar;\n```\n\n----------------------------------------\n\nTITLE: Running All Applications Simultaneously (Bash)\nDESCRIPTION: This command uses the `run:all` npm script (installed by the plugin) to simultaneously serve all configured applications. This simplifies the development workflow by starting the Shell and Remote applications with a single command.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-cli.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm run run:all\n# or\nnpm run run:all shell mfe1\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation Project with Yarn\nDESCRIPTION: This snippet shows how to use the `create-module-federation` tool with yarn to create a new Module Federation project. It creates a new project interactively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create module-federation\n```\n\n----------------------------------------\n\nTITLE: Alternative NextFederationPlugin Configuration\nDESCRIPTION: This code snippet provides an alternative example of configuring the NextFederationPlugin in the `next.config.js` file. It demonstrates a configuration where the application acts as a host, consuming modules from a remote application named 'next2'.  It's configuring webpack as a local dependency by using NEXT_PRIVATE_LOCAL_WEBPACK=true to expose webpack internals.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n// next.config.js\n\nconst NextFederationPlugin = require('@module-federation/nextjs-mf');\n\nmodule.exports = {\n  webpack(config, options) {\n    const { isServer } = options;\n    config.plugins.push(\n      new NextFederationPlugin({\n        name: 'next1',\n        remotes: {\n          next2: `next2@http://localhost:3000/_next/static/${\n            isServer ? 'ssr' : 'chunks'\n          }/remoteEntry.js`,\n        },\n      }),\n    );\n\n    return config;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring esbuild with Module Federation\nDESCRIPTION: This code shows how to configure esbuild to use the Module Federation plugin. It defines the entry point, output directory, and other build options. The plugin is initialized with a federation configuration file.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/esbuild/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst esbuild = require('esbuild');\nconst path = require('path');\nconst { moduleFederationPlugin } = require('@module-federation/esbuild/plugin');\nconst federationConfig = require('./federation.config.js');\n\nasync function buildApp() {\n  const tsConfig = 'tsconfig.json';\n  const outputPath = path.join('dist', 'host');\n\n  try {\n    await esbuild.build({\n      entryPoints: [path.join('host', 'main.ts')],\n      outdir: outputPath,\n      bundle: true,\n      platform: 'browser',\n      format: 'esm',\n      mainFields: ['es2020', 'browser', 'module', 'main'],\n      conditions: ['es2020', 'es2015', 'module'],\n      resolveExtensions: ['.ts', '.tsx', '.mjs', '.js'],\n      tsconfig: tsConfig,\n      splitting: true,\n      plugins: [moduleFederationPlugin(federationConfig)],\n    });\n  } catch (err) {\n    console.error(err);\n    process.exit(1);\n  }\n}\n\nbuildApp();\n```\n\n----------------------------------------\n\nTITLE: Change Directory to Workspace\nDESCRIPTION: Navigates the user into the newly created Nx workspace directory using the `cd` command. This step is crucial to ensure that all subsequent commands are executed within the correct context of the workspace.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd myorganization\n```\n\n----------------------------------------\n\nTITLE: CSS Module for Styling (CSS)\nDESCRIPTION: Defines a CSS module that styles the button within the exposed React component. It sets the background color of the button to red. This CSS module is used to encapsulate the styling and avoid naming conflicts with other styles.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/dynamic-remote.mdx#_snippet_3\n\nLANGUAGE: css\nCODE:\n```\n.button {\n  background: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Producer: module-federation.config.ts\nDESCRIPTION: This TypeScript file configures the Module Federation settings for the producer application. It defines the name, filename, exposed modules, and shared dependencies.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/modern-js';\n\nexport default createModuleFederationConfig({\n  name: 'provider',\n  filename: 'remoteEntry.js',\n  exposes: {\n    './Image': './src/components/Image.tsx',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Set uniqueName in Webpack Config (Consumer)\nDESCRIPTION: This JavaScript snippet sets a unique name for the Webpack output to avoid conflicts, especially in monorepo setups. It assigns the string 'shell' to the `uniqueName` property of the Webpack `config.output` object.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.output.uniqueName = 'shell';\n```\n\n----------------------------------------\n\nTITLE: Set Local Webpack Environment (Bash)\nDESCRIPTION: These commands set the `NEXT_PRIVATE_LOCAL_WEBPACK` environment variable to `true` to force Next.js to use a locally installed webpack rather than its built-in version.  This is required to properly configure Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncross-env NEXT_PRIVATE_LOCAL_WEBPACK=true next dev\n# or\ncross-env NEXT_PRIVATE_LOCAL_WEBPACK=true next build\n```\n\n----------------------------------------\n\nTITLE: Configure Unique Output Name for Remote (Webpack)\nDESCRIPTION: This TypeScript snippet configures a unique output name and disables the runtime chunk optimization for the remote application's Webpack configuration. This helps avoid conflicts and addresses a known issue with Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconfig.output.uniqueName = 'contact';\nconfig.optimization.runtimeChunk = false;\n```\n\n----------------------------------------\n\nTITLE: Install Workbox (Bash)\nDESCRIPTION: This bash command installs the `workbox-webpack-plugin` as a development dependency in an Angular project. Workbox enhances the capabilities of service workers, especially in complex setups like Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install workbox-webpack-plugin --save-dev\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation via PNPM\nDESCRIPTION: This command installs the `@module-federation/enhanced` package using pnpm.  This package is essential to enable and utilize data prefetching in both the producer and consumer applications.  \nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Modify Entry File (index.js)\nDESCRIPTION: This code snippet demonstrates how to modify the original entry file (index.js). It imports the './bootstrap' file.  All other imports and the ReactDOM.render call are removed. This makes the bootstrap.js file the asynchronous entry point.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/src/components/en/EnableAsyncEntry.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport('./bootstrap');\n```\n\n----------------------------------------\n\nTITLE: Rename index.tsx to bootstrap.tsx\nDESCRIPTION: This command renames the `index.tsx` file to `bootstrap.tsx`. This is done to allow asynchronous loading of the `bootstrap.tsx` file, which is crucial for Module Federation to function correctly between the two applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv src/index.tsx src/bootstrap.tsx\n```\n\n----------------------------------------\n\nTITLE: Initializing Module Federation with Angular CLI\nDESCRIPTION: This command configures Module Federation for the specified Angular project, updates the Angular CLI configuration, creates a manifest file for loading remote entries, and reorganizes the bootstrap process.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project app-micro --type dynamic-host --port 4200\n```\n\n----------------------------------------\n\nTITLE: Adding UniverseEntryChunkTrackerPlugin\nDESCRIPTION: This snippet describes adding the `UniverseEntryChunkTrackerPlugin` to track entry chunks in the server plugin. This change enhances tracking of entry chunks in the server environment for hot reloading prod instances. The plugin is applied in the `applyServerPlugins` function.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/nextjs-mf/CHANGELOG.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Configure Routes in mfe-profile\nDESCRIPTION: This code configures the routes for the `mfe-profile` application. It includes a route for the `HomeComponent` as the default route and a lazy-loaded route for the `ProfileModule`, allowing it to be loaded on demand.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/okta-auth.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'profile', loadChildren: () => import('./profile/profile.module').then(m => m.ProfileModule) }\n];\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Manifest file configuration\nDESCRIPTION: This JSON snippet shows the structure of the manifest file (`mf.manifest.json`) and how to update the port to avoid conflicts with the main application. The `login` entry points to the remote entry of the secondary application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"login\": \"http://localhost:4201/remoteEntry.js\"\n}\n```\n\n----------------------------------------\n\nTITLE: Module Federation: Toggle bootstrapping process\nDESCRIPTION: These commands toggle the bootstrapping process temporarily to allow other schematics like `@angular/pwa` and `@angular/material` to be added that expect bootstrapping in `main.ts`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nng g @angular-architects/module-federation:boot-async false --project [YOUR_MAIN_PROJECT]\nng add [YOUR_LIBRARIES_OF_CHOICE] --project yourProject\nng g @angular-architects/module-federation:boot-async true --project [YOUR_MAIN_PROJECT]\n```\n\n----------------------------------------\n\nTITLE: Check Node.js Version (bash)\nDESCRIPTION: This command checks the currently installed version of Node.js.  It is used to verify if the installed version meets the minimum requirement (>= 16) or the recommended LTS version (20).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/setting-up-env.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Default Shared Scope Configuration in TypeScript\nDESCRIPTION: This code snippet defines the DEFAULT_SHARE_SCOPE object, which specifies the default shared modules for the Next.js Module Federation plugin. It includes configurations for Next.js internals like next/dynamic, next/head, next/link, next/router, next/image, next/script, as well as React and styled-jsx. The configuration includes properties like singleton, requiredVersion, and import, controlling how these modules are shared between federated applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/nextjs.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const DEFAULT_SHARE_SCOPE: SharedObject = {\n  'next/dynamic': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/head': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/link': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/router': {\n    requiredVersion: false,\n    singleton: true,\n    import: undefined,\n  },\n  'next/image': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  'next/script': {\n    requiredVersion: undefined,\n    singleton: true,\n    import: undefined,\n  },\n  react: {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom/': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react-dom': {\n    singleton: true,\n    requiredVersion: false,\n    import: false,\n  },\n  'react/jsx-dev-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'react/jsx-runtime': {\n    singleton: true,\n    requiredVersion: false,\n  },\n  'styled-jsx': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/style': {\n    singleton: true,\n    import: false,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n  'styled-jsx/css': {\n    singleton: true,\n    import: undefined,\n    version: require('styled-jsx/package.json').version,\n    requiredVersion: '^' + require('styled-jsx/package.json').version,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Controlling Routing with MemoryRoute in Remote Component\nDESCRIPTION: This snippet demonstrates the usage of the `memoryRoute` prop in `Remote1App` to manage routing within the remote component. It configures the remote application to use a memory router, enabling navigation without directly displaying URLs in the browser's address bar. The `entryPath` specifies the initial route within the remote component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  return (\n    <BrowserRouter basename=\"/\">\n      <Routes>\n        <Route\n          path=\"/remote1/*\"\n          Component={() => (\n            <Remote1App\n              className={styles.remote1}\n              style={{ color: 'red' }}\n              // Use memoryRoute to control child application routing as memoryRouter\n              // Will not directly display URL in browser address bar\n              memoryRoute={{ entryPath: '/detail' }}\n              // Other properties will be passed to remote component\n              props1={'props_value'}\n              props2={'another_props_value'}\n              ref={ref}\n            />\n          )}\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Update App.tsx in MFE2\nDESCRIPTION: This code updates the `App.tsx` file in MFE2 to import and render the `Button` component. This makes the `Button` component visible within the MFE2 application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport './App.css';\nimport Button from './Button';\n\nconst App = () => {\n  return (\n    <div className=\"content\">\n      <h1>MFE2</h1>\n      <Button />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Producer: modern.config.ts\nDESCRIPTION: This TypeScript file configures the Modern.js application settings, including enabling the Module Federation plugin and setting up SSR.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appTools, defineConfig } from '@modern-js/app-tools';\nimport { moduleFederationPlugin } from '@module-federation/modern-js';\n\n// https://modernjs.dev/en/configure/app/usage\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n    port: 3006,\n  },\n  plugins: [appTools(), moduleFederationPlugin()],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Native Federation Tests via npm\nDESCRIPTION: This command installs the `@module-federation/native-federation-tests` package as a development dependency using npm. This is a necessary first step before using the plugin in any project.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/native-federation-tests/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @module-federation/native-federation-tests\n```\n\n----------------------------------------\n\nTITLE: Lazy Load Module\nDESCRIPTION: This JavaScript snippet shows how to lazy load the LoginModule using dynamic imports. The application routing is updated to use the new library (login-lib), allowing the login module to be loaded on demand.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nloadChildren: () => import('@@login').then((m) => m.LoginModule),\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation via NPM\nDESCRIPTION: This command installs the `@module-federation/enhanced` package using npm. This package is required for enabling and utilizing data prefetching features in both the producer and consumer applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Adding Module Federation to a Remote Application\nDESCRIPTION: This command adds Module Federation capabilities to the remote Angular application. It specifies the project name, the type as 'remote', and the port on which the application will run (4201).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part2.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nng add @angular-architects/module-federation --project login --type remote --port 4201\n```\n\n----------------------------------------\n\nTITLE: Use ErrorCodeTitle React Component\nDESCRIPTION: Uses the `ErrorCodeTitle` React component to display the error code 'RUNTIME-006'. This snippet demonstrates how to pass the error code as a prop to the component for rendering. The component is expected to render the error code title.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/runtime/RUNTIME-006.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ErrorCodeTitle code='RUNTIME-006'/>\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with pnpm\nDESCRIPTION: This command starts the development server using pnpm. The development server provides hot reloading and other development-friendly features, allowing for rapid iteration and testing of code changes.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/rsbuild-common/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Building for Production with pnpm\nDESCRIPTION: This command builds the Rsbuild project for production using pnpm. The output will be optimized for performance and ready for deployment to a production environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-host-v5-2200/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Import ErrorCodeTitle React Component\nDESCRIPTION: Imports the `ErrorCodeTitle` React component, likely for displaying error codes within the Module Federation documentation or application. This component is expected to accept a `code` prop to display a specific error code.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/runtime/RUNTIME-006.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport ErrorCodeTitle from '@components/ErrorCodeTitle';\n```\n\n----------------------------------------\n\nTITLE: Access User Info in Micro Frontend\nDESCRIPTION: Demonstrates how to access the current user's information in a micro frontend component using the `AuthService`. It subscribes to the `user$` observable and uses the user data to pre-fill form fields or perform other actions.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AuthService } from '@auth0/auth0-angular';\nimport { FormBuilder } from '@angular/forms';\nimport { take } from 'rxjs/operators';\n\n@Component({\n  // component metadata...\n})\nexport class AddressComponent {\n  // component properties...\n  constructor(\n    private auth: AuthService,\n    private fb: FormBuilder) {\n    this.auth.user$.pipe(take(1)).subscribe(user => {\n      if (!user) return;\n      // Use user information to pre-fill form, etc.\n    });\n  }\n  // other component methods...\n}\n```\n\n----------------------------------------\n\nTITLE: InvertedContainerPlugin Refactoring\nDESCRIPTION: Simplified InvertedContainerPlugin by removing configuration dependencies and improving runtime module integration. It refactors `InvertedContainerPlugin` to remove redundant configurations.  `EmbeddedContainerPlugin` is deleted and its logic is moved into `InvertedContainerPlugin`.  `InvertedContainerRuntimeModule` is modified to dynamically locate and integrate container entry modules.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/nextjs-mf/CHANGELOG.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Install Custom Webpack Builder\nDESCRIPTION: This bash snippet installs the `@angular-builders/custom-webpack` package as a development dependency using Yarn. This is a prerequisite for using custom Webpack configurations in Angular projects.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @angular-builders/custom-webpack -D\n# or\nnpm i -D @angular-builders/custom-webpack\n```\n\n----------------------------------------\n\nTITLE: Force Webpack 5 using Yarn\nDESCRIPTION: This snippet demonstrates how to force the use of Webpack 5 in an Angular project using Yarn's `resolutions` feature in `package.json`. This ensures compatibility with Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"resolutions\": {\n    \"webpack\": \"^5.0.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ErrorLoadRemote Hook with Fallback - Javascript\nDESCRIPTION: This snippet shows how to use the `errorLoadRemote` hook to handle remote module loading errors.  It defines a fallback plugin that returns a default component when a remote module fails to load. This plugin is then registered during the initialization of the Module Federation runtime.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react';\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\n// 模块注册\ninit({\n    name: 'host',\n    remotes: [\n        {\n            name: \"remote1\",\n            entry: \"http://localhost:2001/mf-manifest.json\",\n            alias: \"remote1\"\n        }\n    ],\n    plugins: [\n      RetryPlugin({\n        fetch: {},\n        script: {},\n      }),\n    ]\n});\n\n// 模块加载\nconst Remote1Button = React.lazy(() => loadRemote('remote1/button'));\n\nexport default () => {\n  return (\n    <React.Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1Button />\n    </React.Suspense>\n  );\n}\n\n// 方法/函数加载\nloadRemote<{add: (...args: Array<number>)=> number }>(\"remote1/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\nLANGUAGE: diff\nCODE:\n```\nimport React from 'react';\nimport { init, loadRemote } from '@module-federation/enhanced/runtime';\nimport { RetryPlugin } from '@module-federation/retry-plugin';\n\n+ const fallbackPlugin: () => FederationRuntimePlugin = function () {\n+  return {\n+    name: 'fallback-plugin',\n+    errorLoadRemote(args) {\n+      return { default: () => <div> fallback component </div> };\n+    },\n+  };\n+ };\n\n// 模块注册\ninit({\n    name: 'host',\n    remotes: [\n        {\n            name: \"remote1\",\n            alias: \"remote1\"\n            entry: \"http://localhost:2001/mf-manifest.json\",\n        }\n    ],\n    plugins: [\n      RetryPlugin({\n        fetch: {},\n        script: {},\n      }),\n+     fallbackPlugin()\n    ]\n});\n\n// 模块加载\nconst Remote1Button = React.lazy(() => loadRemote('remote1/button'));\n\nexport default () => {\n  return (\n    <React.Suspense fallback={<div> Loading Remote1App...</div>}>\n      <Remote1Button />\n    </React.Suspense>\n  );\n}\n\n// 方法/函数加载\nloadRemote<{add: (...args: Array<number>)=> number }>(\"remote1/util\").then((md)=>{\n    md.add(1,2,3);\n});\n```\n\n----------------------------------------\n\nTITLE: Recording All Declared Remotes\nDESCRIPTION: This patch ensures that all remotes declared in the build configuration are recorded in the manifest.  This change ensures all remotes are available at runtime for module federation.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_5\n\nLANGUAGE: none\nCODE:\n```\n83c8620: fix(manifest): record all remotes which are declared in build config\n```\n\n----------------------------------------\n\nTITLE: Disable Runtime Chunk Optimization (Consumer)\nDESCRIPTION: This JavaScript snippet disables runtime chunk optimization in the Webpack configuration.  This is a workaround for a known issue that can cause module federation setup to fail.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-mfe.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.optimization.runtimeChunk = false;\n```\n\n----------------------------------------\n\nTITLE: Angular Library Generation (auth)\nDESCRIPTION: This command uses the Angular CLI to generate a new library named 'auth'. It is used to encapsulate authentication-related services and guards, promoting reusability across micro-frontends.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nng generate library auth\n```\n\n----------------------------------------\n\nTITLE: Check Node.js Version\nDESCRIPTION: This command checks the version of Node.js currently installed on the system. It is used to verify that the Node.js version meets the minimum requirement (>= 16) for the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/react/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Build Rslib Package (Shell)\nDESCRIPTION: This command builds the Rslib package. It is a standard command used in the project's build process. Ensure that `pnpm` is installed and configured correctly to execute this command.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/provider-rslib-storybook-ts/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: loadRemote API Usage TS\nDESCRIPTION: This TypeScript snippet demonstrates the usage of the `loadRemote` API from `@module-federation/enhanced/runtime`. It loads a remote module and triggers the pre-fetching of associated data.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/performance/prefetch.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loadRemote } from '@module-federation/enhanced/runtime';\n\nloadRemote('app2/Button');\n```\n\n----------------------------------------\n\nTITLE: Using ErrorCodeTitle Component (HTML/JSX)\nDESCRIPTION: This snippet demonstrates the usage of the ErrorCodeTitle component, passing 'RUNTIME-003' as the code prop.  This is used to display the error code and corresponding title in the user interface.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/troubleshooting/runtime/RUNTIME-003.mdx#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<ErrorCodeTitle code='RUNTIME-003'/>\n```\n\n----------------------------------------\n\nTITLE: Build for Production with pnpm\nDESCRIPTION: This command builds the Rsbuild project for production using pnpm. It optimizes the application for deployment, including minification and bundling of assets.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote2-2002/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Display User Information\nDESCRIPTION: Displays the logged-in user's name in the consumer application's home component using Angular's `async` pipe.  It subscribes to the `user$` observable provided by the `AuthService` to retrieve user information.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<h1>Welcome!</h1>\n\n<p *ngIf=\"user$ | async as user\">\n    User: {{user.name}}\n</p>\n\n<div>\n    <button (click)=\"login()\" mat-flat-button color=\"primary\">Login</button>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Flights Search Route Configuration (TypeScript)\nDESCRIPTION: Defines the route for the `FlightsSearchComponent` within the `FlightsModule`. This route maps the `flights-search` path to the `FlightsSearchComponent`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const FLIGHTS_ROUTES: Routes = [\n     {\n       path: 'flights-search',\n       component: FlightsSearchComponent\n     }\n ];\n```\n\n----------------------------------------\n\nTITLE: Remote Shop Component with getInitialProps in Next.js\nDESCRIPTION: This code defines a React component 'Shop' within a Next.js page. It includes a 'getInitialProps' function for fetching data before rendering on the server. The component displays the fetched data as a JSON string. The 'Head' component is used to set the page title.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/importing-pages.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport Head from 'next/head';\n\nconst Shop = (props) => {\n  return (\n    <div>\n      <Head>\n        <title>Shop</title>\n      </Head>\n      <pre>{JSON.stringify(props)}</pre>\n    </div>\n  );\n};\nShop.getInitialProps = async () => {\n  const fallback = {\n    name: 'Luke Skywalker',\n    height: '172',\n    mass: '77',\n    hair_color: 'blond'\n  };\n  return Promise.resolve(fallback);\n};\n\nexport default Shop;\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 20 LTS using nvm\nDESCRIPTION: This snippet demonstrates how to install Node.js version 20 (LTS) using nvm (Node Version Manager). It also sets the installed version as the default and switches to using it in the current shell session. Requires nvm to be installed.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/setting-up-env.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# 安装 Node.js 20 的长期支持版本\nnvm install 20 --lts\n\n# 将刚安装的 Node.js 20 设置为默认版本\nnvm alias default 20\n\n# 切换到刚安装的 Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 20 LTS with nvm (bash)\nDESCRIPTION: These commands install the LTS version of Node.js 20 using nvm, set it as the default version, and switch to using it.  nvm must be pre-installed to use these commands. It ensures that the environment is using the recommended Node.js version for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/setting-up-env.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 20\nnvm install 20 --lts\n\n# Set the newly installed Node.js 20 as the default version\nnvm alias default 20\n\n# Switch to the newly installed Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Install Auth0 Angular Package\nDESCRIPTION: Installs the `@auth0/auth0-angular` package using npm. This package provides the necessary services and modules for integrating with Auth0 for authentication in an Angular application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/auth0.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @auth0/auth0-angular\n```\n\n----------------------------------------\n\nTITLE: Installing Module Federation Plugin for Modern.js\nDESCRIPTION: Commands to install the `@module-federation/modern-js` plugin using npm, yarn, pnpm, and bun. This plugin provides Module Federation support for Modern.js applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm add @module-federation/modern-js --save\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @module-federation/modern-js --save\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @module-federation/modern-js --save\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun add @module-federation/modern-js --save\n```\n\n----------------------------------------\n\nTITLE: Starting Shell and Remote Applications\nDESCRIPTION: Commands to start the Angular shell and remote (microfrontend) applications using `ng serve`. The `-o` flag opens the applications in the browser.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/angular-cli.mdx#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nng serve shell -o\nng serve mfe1 -o\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js LTS version using nvm\nDESCRIPTION: These commands use nvm (Node Version Manager) to install Node.js version 20 (LTS), set it as the default version, and switch to it. This ensures the project uses a compatible Node.js version.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 20\nnvm install 20 --lts\n\n# Make the newly installed Node.js 20 as the default version\nnvm alias default 20\n\n# Switch to the newly installed Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Install pnpm globally (Bash)\nDESCRIPTION: This command installs pnpm (a package manager) globally. It is recommended for managing dependencies in Modern.js projects.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/modern/index.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g pnpm@8\n```\n\n----------------------------------------\n\nTITLE: Display ErrorCodeTitle Component\nDESCRIPTION: This snippet renders the `ErrorCodeTitle` component, passing the error code 'RUNTIME-006' as a prop. This is how the error code is displayed on the page.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-006.mdx#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<ErrorCodeTitle code='RUNTIME-006'/>\n```\n\n----------------------------------------\n\nTITLE: Install React Bridge\nDESCRIPTION: This command installs the `@module-federation/bridge-react` library, which is a dependency for creating bridge components in a React application.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react-webpack-plugin/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/bridge-react\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation Project with Pnpm\nDESCRIPTION: This snippet shows how to use the `create-module-federation` tool with pnpm to create a new Module Federation project. It creates a new project interactively.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/start/quick-start.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm create module-federation@latest\n```\n\n----------------------------------------\n\nTITLE: Install Webpack (Bash)\nDESCRIPTION: This command installs webpack as a development dependency. This is necessary because Next.js needs the complete webpack internals to run Module Federation correctly.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm i webpack -D\n```\n\n----------------------------------------\n\nTITLE: Updating bootstrap.tsx content\nDESCRIPTION: This code snippet updates the content of `bootstrap.tsx` to render the main `App` component within a React StrictMode. It's a standard React entry point setup using ReactDOM.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Angular plugin to Nx workspace\nDESCRIPTION: This command adds the '@nx/angular' plugin to the Nx workspace, enabling Angular-specific capabilities.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx add @nx/angular\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Plugin (pnpm)\nDESCRIPTION: This command installs the @module-federation/enhanced package using pnpm.  This package provides enhanced functionality for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Install Module Federation Plugin (yarn)\nDESCRIPTION: This command installs the @module-federation/enhanced package using yarn.  This package provides enhanced functionality for Module Federation.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/rspack.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Use ShowcaseList component in Markdown\nDESCRIPTION: This code snippet renders the `ShowcaseList` component within the Markdown document. It leverages the imported component to display a list of Module Federation showcases.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/showcase/index.mdx#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n<ShowcaseList />\n```\n\n----------------------------------------\n\nTITLE: Delegate Modules A (TypeScript)\nDESCRIPTION: Delegate module A exposing 2 functions for delegation\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/delegateModulesA.js\nexport async function test1() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"test1 value\")\n    }, 3000)\n  })\n}\nexport async function test2() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"test2 value\")\n    }, 3000)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Install @module-federation/enhanced using npm\nDESCRIPTION: This command installs the @module-federation/enhanced package, which is required for data prefetching, using npm. This package needs to be installed in both the producer and host applications.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/performance/prefetch.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @module-federation/enhanced\n```\n\n----------------------------------------\n\nTITLE: Render ErrorCodeTitle React Component\nDESCRIPTION: Renders the ErrorCodeTitle component with the code prop set to 'RUNTIME-003'. This will display the title associated with the given error code.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/runtime/RUNTIME-003.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ErrorCodeTitle code='RUNTIME-003'/>\n```\n\n----------------------------------------\n\nTITLE: Creating a new Nx workspace\nDESCRIPTION: This command creates a new Nx workspace named 'myorg' with the 'apps' preset. It's the first step to setting up an Nx workspace for application development.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/using-nx-for-react.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y create-nx-workspace@latest myorg --preset=apps\ncd myorg\n```\n\n----------------------------------------\n\nTITLE: Install Nx Angular Plugin\nDESCRIPTION: Installs the official Nx Angular plugin using npm. This plugin provides the necessary tools and functionalities for managing Angular applications within the Nx workspace, including support for module federation and SSR.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @nx/angular\n```\n\n----------------------------------------\n\nTITLE: Installing the Module Federation plugin\nDESCRIPTION: Shows how to install the @module-federation/modern-js plugin using npm, yarn, pnpm and bun.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Adding nx globally\nDESCRIPTION: This command adds the nx build system globally. This ensures you can run nx commands from anywhere in your system. Dependencies: pnpm.\nSOURCE: https://github.com/module-federation/core/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm add nx@latest -g\n```\n\n----------------------------------------\n\nTITLE: Generating a New Angular Library (auth)\nDESCRIPTION: This command uses the Angular CLI to generate a new library named 'auth'. This library will contain the authentication service and related guards.  The generated library will be configured to be independently buildable and testable, facilitating reuse across multiple micro-frontends. This segregates authentication logic into a shared module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nng generate library auth\n```\n\n----------------------------------------\n\nTITLE: Dynamic Workbox Service Worker Import (TypeScript)\nDESCRIPTION: This TypeScript snippet dynamically imports and registers a Workbox service worker in an Angular application. It utilizes `workbox-window` to simplify the service worker registration process in the client application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/service-workers-mf.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Workbox } from 'workbox-window';\n\nif ('serviceWorker' in navigator) {\n  const wb = new Workbox('/service-worker.js');\n\n  wb.register();\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Debugging Runtime Variable\nDESCRIPTION: This commit removes a debugging runtime variable. This is a standard practice in software development to clean up code and prevent potential issues in production environments.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Serve SSR Host Application\nDESCRIPTION: This command serves the 'dashboard' (host) application with server-side rendering (SSR) enabled. It builds both browser and server bundles for the 'login' application and runs it using Node.js.  Note that changes to the 'login' app will not be automatically reflected without the `--devRemotes` option.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/angular/mf-ssr-angular.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx serve-ssr dashboard\n```\n\n----------------------------------------\n\nTITLE: Check Node.js Version (Bash)\nDESCRIPTION: This command checks the currently installed version of Node.js.  It is used to verify that the Node.js version meets the minimum requirements (>=16, recommended LTS 20).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: React 16/17 Import\nDESCRIPTION: Explicitly specifies React 16/17 version for `createBridgeComponent`.  This is recommended for React 16/17 projects. It ensures compatibility with the traditional ReactDOM APIs.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/bridge/react-bridge.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Explicitly specify React 16/17 version (recommended for React 16/17)\nimport { createBridgeComponent } from '@module-federation/bridge-react';\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies with pnpm\nDESCRIPTION: This command installs the necessary dependencies for the Rsbuild project using the pnpm package manager. It ensures that all required packages are available for development, building, and running the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote2-2002/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Angular Library Build (auth)\nDESCRIPTION: This command compiles the 'auth' library using the Angular CLI.  It prepares the library for distribution and consumption by other parts of the application or other micro-frontends.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/splitting-to-mf-part1.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nng build auth\n```\n\n----------------------------------------\n\nTITLE: Building affected projects only\nDESCRIPTION: This command builds only the projects that have been changed since the last successful build, reducing build time.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/using-nx-for-angular.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx affected -t build\n```\n\n----------------------------------------\n\nTITLE: Module Federation Plugin Configuration (Webpack/Rspack/Rsbuild)\nDESCRIPTION: This code snippet demonstrates the configuration of the `ModuleFederationPlugin` in a webpack, rspack, or rsbuild configuration file. It highlights the importance of ensuring that all keys in the `exposes` object start with `./` to avoid TypeScript compilation errors. The snippet shows an example of exposing a `Foo` component located at `./src/<path-to-file>/Foo.tsx`.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/troubleshooting/type/TYPE-001.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew ModuleFederationPlugin({\n    ...\n    // 确保所有的 key 都以 \"./\" 开头\n    exposes: { './Foo': './src/<path-to-file>/Foo.tsx' },\n    ...\n  })\n```\n\n----------------------------------------\n\nTITLE: Install Node.js 18 LTS with nvm (Bash)\nDESCRIPTION: These commands use nvm to install Node.js version 18 (LTS), set it as the default version, and activate it for the current session. nvm is a Node.js version management tool.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# 安装 Node.js 18 的长期支持版本\nnvm install 18 --lts\n\n# 将刚安装的 Node.js 18 设置为默认版本\nnvm alias default 18\n\n# 切换到刚安装的 Node.js 18\nnvm use 18\n```\n\n----------------------------------------\n\nTITLE: Starting the development server using pnpm\nDESCRIPTION: This command starts the Rsbuild development server using pnpm. It allows developers to preview and test their changes in real-time during development.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote1-2001/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server with PNPM\nDESCRIPTION: This command starts the development server for the Next.js App Router Playground using the PNPM package manager. It allows developers to view and interact with the application in a development environment.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/next-app-router/next-app-router-4001/readme.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Next.js Externals Refactoring\nDESCRIPTION: Refactors external handling in Next.js to dynamically find and replace the first function in the 'externals' array. This change improves robustness by ensuring the system correctly overrides external functions regardless of their position in the list.  The existing logic is maintained to preserve intended behavior with conditions checking specific package prefixes and names.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/nextjs-mf/CHANGELOG.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Configure Unique Output Name (Webpack)\nDESCRIPTION: This JavaScript snippet configures a unique output name for the Webpack build. This is particularly important in monorepo setups to avoid conflicts.  The `config` object represents the Webpack configuration.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/angular/angular-mfe.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.output.uniqueName = 'shell';\n```\n\n----------------------------------------\n\nTITLE: Install Enhanced Module Federation Package\nDESCRIPTION: Command line instruction to install the @module-federation/enhanced package using npm, yarn, pnpm, or bun. This package is required to use the Federation Runtime features.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/basic/runtime.mdx#_snippet_0\n\nLANGUAGE: npm\nCODE:\n```\nnpm add @module-federation/enhanced --save\n```\n\nLANGUAGE: yarn\nCODE:\n```\nyarn add @module-federation/enhanced --save\n```\n\nLANGUAGE: pnpm\nCODE:\n```\npnpm add @module-federation/enhanced --save\n```\n\nLANGUAGE: bun\nCODE:\n```\nbun add @module-federation/enhanced --save\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies using pnpm\nDESCRIPTION: This command installs the necessary dependencies for the Rsbuild project using the pnpm package manager. It ensures that all required packages are available for development and production.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/router-demo/router-remote1-2001/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation project using npx with abbreviated CLI flags\nDESCRIPTION: This command uses npx to execute create-module-federation with abbreviated CLI flags. It allows customization of the project directory, template, and project name using short-hand notation.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-module-federation -d my-project -t provider-modern -n provider\n```\n\n----------------------------------------\n\nTITLE: Interface Definition for PluginManifestOptions in TypeScript\nDESCRIPTION: Defines the structure for configuring the plugin manifest generation, including the file path, file name, and whether to disable asset analysis. The filePath specifies where the manifest will be stored. fileName sets the name of the manifest file and disableAssetsAnalyze determines if assets analysis should be disabled.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/configure/manifest.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PluginManifestOptions {\n  filePath?: string;\n  disableAssetsAnalyze?: boolean;\n  fileName?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared Modules (Dangerous Method) - JavaScript\nDESCRIPTION: This code snippet demonstrates a method for dangerously sharing a package. It involves defining a shared module configuration with 'import' and 'shareKey' properties.  It's crucial to understand that this approach is considered dangerous and should only be used with caution, as it can lead to issues like bundling the same singleton package multiple times.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/sdk/CHANGELOG.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying remotes Configuration in module-federation.config.ts\nDESCRIPTION: Illustrates how to modify the `remotes` configuration in `module-federation.config.ts` to replace the default published provider with a local provider. This involves changing the URL of the remote module.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/start/quick-start.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';\n\nexport default createModuleFederationConfig({\n  name: 'mf_consumer',\n  remotes: {\n-   'provider': 'rslib_provider@https://unpkg.com/module-federation-rslib-provider@latest/dist/mf/mf-manifest.json',\n+   'provider': 'rslib_provider@http://localhost:3000/mf-manifest.json',\n  },\n  shared: {\n    react: { singleton: true },\n    'react-dom': { singleton: true },\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: This command installs the necessary dependencies for the Modern.js application using the pnpm package manager. It ensures all required modules are present for running and building the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/modernjs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Dev Rslib Module\nDESCRIPTION: This command starts the 'rslib-module' package in development mode using Nx dev.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/rslib-module/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnx dev rslib-module\n```\n\n----------------------------------------\n\nTITLE: Dangerous Shared Module Configuration (Next.js)\nDESCRIPTION: This code snippet demonstrates a now-discouraged method for sharing modules in Next.js using Module Federation.  It involves manually setting the `shareKey` for a shared module.  This approach was previously used to prevent eager consumption issues but can lead to problems with singleton packages being bundled multiple times. It's recommended to use this method with caution.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared Modules (Deprecated)\nDESCRIPTION: This snippet demonstrates a deprecated method of configuring shared modules within a Module Federation setup. It shows how to define a shared module with a specific `shareKey`.  This approach has potential issues when sharing singleton packages and should be used with caution. It's provided as an example of a configuration to be avoided.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/runtime-tools/CHANGELOG.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst shared = {\n  fakeLodash: {\n    import: \"lodash\",\n    shareKey: \"lodash\",\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fallback Component using React.createElement\nDESCRIPTION: This snippet demonstrates creating a styled fallback component using React.createElement. This component is displayed when module loading fails, providing a user-friendly error message.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/blog/error-load-remote.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst FallbackComponent = React.memo(() => {\n  return React.createElement(\n    'div',\n    {\n      style: {\n        padding: '16px',\n        border: '1px solid #ffa39e',\n        borderRadius: '4px',\n        backgroundColor: '#fff1f0',\n        color: '#cf1322'\n      }\n    },\n    'fallback component'\n  );\n});\nFallbackComponent.displayName = 'ErrorFallbackComponent';\nreturn () => ({\n  __esModule: true,\n  default: FallbackComponent\n});\n}\n```\n\n----------------------------------------\n\nTITLE: createRemoteSSRComponent Declaration\nDESCRIPTION: Declares the `createRemoteSSRComponent` function and its associated types, including `CreateRemoteSSRComponentOptions` and `ComponentType`. This function simplifies the integration of remote components in server-side rendering scenarios, ensuring correct style and script injection.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/framework/modernjs.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function createRemoteSSRComponent(\n  props: CreateRemoteSSRComponentOptions\n): (props: ComponentType) => React.JSX.Element;\n\ntype CreateRemoteSSRComponentOptions = {\n  loader: () => Promise<T>;\n  loading: React.ReactNode;\n  fallback: ErrorBoundaryPropsWithComponent['FallbackComponent'];\n  export?: E;\n};\n\ntype ComponentType = T[E] extends (...args: any) => any\n  ? Parameters<T[E]>[0] extends undefined\n    ? Record<string, never>\n    : Parameters<T[E]>[0]\n  : Record<string, never>;\n```\n\n----------------------------------------\n\nTITLE: Previewing the Production Build with pnpm\nDESCRIPTION: This command starts a local server to preview the production build using pnpm. It allows developers to test the application in a production-like environment before deploying it to a live server.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/templates/rsbuild-common/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Adding Module Federation Types Reference in modern-app-env.d.ts\nDESCRIPTION: Snippet to add a reference to the Module Federation types in `modern-app-env.d.ts`. This provides type support for the runtime `@@modern-js/runtime/mf` within the application.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/guide/framework/modernjs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types='@module-federation/modern-js/types' />\n```\n\n----------------------------------------\n\nTITLE: Simplified Fallback Plugin Implementation (TS)\nDESCRIPTION: This simplified plugin implementation provides a generic error handling solution without distinguishing between error types. It leverages the `errorLoadRemote` hook to render a fallback component with a predefined error message.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/blog/error-load-remote.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport type { FederationRuntimePlugin } from '@module-federation/runtime';\n\nconst fallbackPlugin = (errorMessage = '模块加载失败，请稍后重试'): FederationRuntimePlugin => {\n  return {\n    name: 'fallback-plugin',\n    async errorLoadRemote() {\n      const React = await import('react');\n      const FallbackComponent = React.memo(() => {\n        return React.createElement(\n          'div',\n          {\n            style: {\n              padding: '16px',\n              border: '1px solid #ffa39e',\n              borderRadius: '4px',\n              backgroundColor: '#fff1f0',\n              color: '#cf1322'\n            }\n          },\n          errorMessage\n        );\n      });\n      FallbackComponent.displayName = 'ErrorFallbackComponent';\n      return () => ({\n        __esModule: true,\n        default: FallbackComponent\n      });\n    },\n  };\n};\nexport default fallbackPlugin;\n```\n\n----------------------------------------\n\nTITLE: Consumer: src/routes/page.tsx (Initial)\nDESCRIPTION: This TypeScript file is the initial entry point for the consumer application, importing and rendering the Image component from the remote producer.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport ProviderImage from 'remote/Image';\nimport './index.css';\n\nconst Index = () => (\n  <div className=\"container-box\">\n    <ProviderImage />\n  </div>\n);\n\nexport default Index;\n```\n\n----------------------------------------\n\nTITLE: Add Local Webpack Env (.env)\nDESCRIPTION: This line sets the environment variable `NEXT_PRIVATE_LOCAL_WEBPACK` to `true` in the `.env` file. This instructs Next.js to use the locally installed webpack, crucial for Module Federation, though potentially unreliable in setting the variable in time.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_7\n\nLANGUAGE: .env\nCODE:\n```\nNEXT_PRIVATE_LOCAL_WEBPACK=true\n```\n\n----------------------------------------\n\nTITLE: Updating App.tsx in MFE2\nDESCRIPTION: This code updates the `App.tsx` file in `MFE2` to import and render the `Button` component created earlier. It demonstrates how to use a locally defined component.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/react/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport './App.css';\nimport Button from './Button';\n\nconst App = () => {\n  return (\n    <div className=\"content\">\n      <h1>MFE2</h1>\n      <Button />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Create a Modern.js Consumer Project (Bash)\nDESCRIPTION: This command uses the `@modern-js/create` tool to scaffold a new Modern.js project named 'modern-consumer'.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/modern/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modern-js/create@latest modern-consumer\n```\n\n----------------------------------------\n\nTITLE: Unifying Logger Implementation\nDESCRIPTION: This patch unifies the logger implementation across the project.  Consolidating the logger improves maintainability and ensures consistent logging behavior throughout the codebase.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_9\n\nLANGUAGE: none\nCODE:\n```\nad605d2: chore: unified logger\n```\n\n----------------------------------------\n\nTITLE: Create a Button Component (JavaScript)\nDESCRIPTION: This code creates a simple React button component in `MFE2`.  It exports the `Button` component as default.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/practice/frameworks/next/index.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n\nconst Button = () => (\n  <button>MFE2 Button</button>\n);\n\nexport default Button;\n\n```\n\n----------------------------------------\n\nTITLE: Creating Module Federation project using npm\nDESCRIPTION: This command uses npm create to scaffold a new Module Federation project with the latest version of create-module-federation. It initializes the project setup process.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/create-module-federation/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm create module-federation@latest\n```\n\n----------------------------------------\n\nTITLE: Creating Bootstrap File JavaScript\nDESCRIPTION: This code snippet shows the creation of a 'bootstrap.js' file. It imports React, ReactDOM, and App, then renders the App component into the DOM element with the ID 'root'. This effectively contains the original entry point logic.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/src/components/zh/EnableAsyncEntry.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n+ import React from 'react';\n+ import ReactDOM from 'react-dom';\n+ import App from './App';\n+ ReactDOM.render(<App />, document.getElementById('root'));\n```\n\n----------------------------------------\n\nTITLE: Import ShowcaseList component in Markdown\nDESCRIPTION: This code snippet imports the `ShowcaseList` component from a TypeScript file to be used within a Markdown document. This allows dynamic rendering of the list of showcases.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/zh/showcase/index.mdx#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\nimport { ShowcaseList } from '@components/ShowcaseList/index.tsx';\n```\n\n----------------------------------------\n\nTITLE: Disabling Package JSON Generation\nDESCRIPTION: This patch disables the generation of package.json files during the build process. This change can streamline the build process, especially in environments where package.json files are not required.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/manifest/CHANGELOG.md#_snippet_7\n\nLANGUAGE: none\nCODE:\n```\n4ab9295: disable package json generation during build\n```\n\n----------------------------------------\n\nTITLE: Apply DataPrefetchPlugin on demand\nDESCRIPTION: This snippet refers to a fix related to the `DataPrefetchPlugin`. It indicates that the plugin is now applied on demand, which likely improves performance by avoiding unnecessary initialization or execution.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Rsbuild App or Rslib Module Storybook Config\nDESCRIPTION: This snippet showcases the Storybook configuration for Rsbuild apps or Rslib modules, highlighting the use of `storybook-react-rsbuild` and the `@module-federation/storybook-addon/preset`.  The `remotes` option allows for specifying remote modules to be loaded into Storybook.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/storybook-addon/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { dirname, join } from 'node:path';\nimport type { StorybookConfig } from 'storybook-react-rsbuild';\n\nfunction getAbsolutePath(value: string): any {\n  return dirname(require.resolve(join(value, 'package.json')));\n}\n\nconst config: StorybookConfig = {\n  stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|mjs|ts|tsx)'],\n  framework: {\n    name: getAbsolutePath('storybook-react-rsbuild'),\n    options: {},\n  },\n  addons: [\n    {\n      name: '@module-federation/storybook-addon/preset',\n      options: {\n        // add remote here and then you can load remote in your story\n        remotes: {\n          'rslib-module':\n            'rslib-module@http://localhost:3000/mf/mf-manifest.json',\n        },\n      },\n    },\n  ],\n};\n\nexport default config;\n\n```\n\n----------------------------------------\n\nTITLE: Skip processing with virtualRuntimeEntry\nDESCRIPTION: This snippet describes the addition of a check in the `FederationRuntimePlugin` to skip processing when `options.virtualRuntimeEntry` is defined. This optimization avoids unnecessary processing when using virtual runtime entrypoints.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/enhanced/CHANGELOG.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Illustrating transitive dependents issue\nDESCRIPTION: This code snippet illustrates the issue that caused transitive dependents of dev dependents to be bumped when a package got bumped and when using `___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.updateInternalDependents: \"always\"`. It shows the relationship between three packages, pkg-a, pkg-b, and pkg-c, where pkg-a is a dependency of pkg-b (as a devDependency) and pkg-b is a dependency of pkg-c.\nSOURCE: https://github.com/module-federation/core/blob/main/packages/assemble-release-plan/CHANGELOG.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npkg-a - version: 1.0.0\npkg-b - devDependencies['pkg-a']: 1.0.0\npkg-c - dependencies['pkg-b']: 1.0.0\n```\n\n----------------------------------------\n\nTITLE: Build Rslib Module\nDESCRIPTION: This command builds the 'rslib-module' package using Nx build.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/rslib-module/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnx build rslib-module\n```\n\n----------------------------------------\n\nTITLE: Install Node.js with nvm (Bash)\nDESCRIPTION: These commands install the specified LTS version of Node.js (20) using nvm, set it as the default version, and switch to it. This ensures the correct Node.js version is used for the project.\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/practice/frameworks/next/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the long-term support version of Node.js 20\nnvm install 20 --lts\n\n# Make the newly installed Node.js 20 as the default version\nnvm alias default 20\n\n# Switch to the newly installed Node.js 20\nnvm use 20\n```\n\n----------------------------------------\n\nTITLE: Output of the help command\nDESCRIPTION: This is the expected output when running the help command on the Module Federation CLI. It shows the available commands (dts, help) and options (version, help).\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/guide/basic/cli.mdx#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage: mf <command> [options]\n\nOptions:\n  -V, --version   output the version number\n  -h, --help      display help for command\n\nCommands:\n  dts [options]   generate or fetch the mf types\n  help [command]  display help for command\n```\n\n----------------------------------------\n\nTITLE: Import JSON Data Module (TypeScript)\nDESCRIPTION: Importing the jsonA data module within bootstrap.js\nSOURCE: https://github.com/module-federation/core/blob/main/apps/website-new/docs/en/plugin/dev/index.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// src/bootstrap.js\nimport jsonA from \"jsonA\"\njsonA // {...json data}\n```"
  }
]