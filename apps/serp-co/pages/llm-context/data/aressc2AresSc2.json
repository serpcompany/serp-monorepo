[
  {
    "owner": "aressc2",
    "repo": "ares-sc2",
    "content": "TITLE: Advanced Ares SC2 Bot Implementation with MacroPlan\nDESCRIPTION: Demonstrates how to create a more sophisticated Ares SC2 bot using MacroPlan to manage multiple macro behaviors in a prioritized order, including supply, worker production, gas management, and army production.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/managing_production.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.macro import (\n    AutoSupply, \n    BuildWorkers,\n    GasBuildingController,\n    MacroPlan, \n    ProductionController, \n    SpawnController,\n)\n\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\n\nclass TestBot(AresBot):\n    \n    @property\n    def viking_tank(self) -> dict:\n        return {\n            UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n            UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n            UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n            UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n        }\n\n    async def on_step(self, iteration: int) -> None:\n        await super(TestBot, self).on_step(iteration)\n        \n        production_location = self.start_location\n        \n        macro_plan: MacroPlan = MacroPlan()\n        macro_plan.add(AutoSupply(production_location))\n        macro_plan.add(BuildWorkers(to_count=48))\n        macro_plan.add(GasBuildingController(to_count=8))\n        macro_plan.add(SpawnController(self.viking_tank))\n        macro_plan.add(ProductionController(\n            self.viking_tank, production_location\n        ))\n        \n        # only need to register once for whole plan\n        self.register_behavior(macro_plan)\n```\n\n----------------------------------------\n\nTITLE: Complete Zerg Bot Implementation with Squad Management\nDESCRIPTION: Full implementation of a Zerg bot using the ares-sc2 framework, including unit role assignment, squad management, and combat behaviors.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup, StutterGroupForward\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole, UnitTreeQueryType\nfrom ares.managers.squad_manager import UnitSquad\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n        \n        self._assigned_roach_hit_squad: bool = False\n        \n    async def on_step(self, iteration: int) -> None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        \n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n        \n        self.control_roach_hit_squad(\n            roach_hit_squad=roach_hit_squad, \n            target=self.enemy_start_locations[0]\n        )\n        \n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time > 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n                \n    def control_roach_hit_squad(\n            self, \n            roach_hit_squad: Units, \n            target: Point2\n        ) -> None:\n        \n        squads: list[UnitSquad] = self.mediator.get_squads(\n            role=UnitRole.CONTROL_GROUP_ONE, squad_radius=9.0\n        )\n        for squad in squads:\n            squad_position: Point2 = squad.squad_position\n            units: list[Unit] = squad.squad_units\n            squad_tags: set[int] = squad.tags\n            \n            # retreive close enemy to the roach squad\n            close_ground_enemy: Units = self.mediator.get_units_in_range(\n                start_points=[squad_position],\n                distances=11.5,\n                query_tree=UnitTreeQueryType.EnemyGround,\n            )[0]\n            \n            # declare a new group maneuver\n            roach_squad_maneuver: CombatManeuver = CombatManeuver()\n            \n            # stutter forward to any ground enemies\n            # as this behavior is added first to the maneuver it \n            # has the highest priority\n            roach_squad_maneuver.add(\n              StutterGroupForward(\n                group=units,\n                group_tags=squad_tags,\n                group_position=squad_position,\n                target=target,\n                enemies=close_ground_enemy,\n              )\n            )\n            \n            # if StutterGroupForward does not execute, our units will AMove\n            roach_squad_maneuver.add(\n              AMoveGroup(\n                group=units, \n                group_tags=squad_tags, \n                target=target\n              )\n            )\n            \n            self.register_behavior(roach_squad_maneuver)\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n```\n\n----------------------------------------\n\nTITLE: Implementing Medivac Mine Drop Using CombatManeuver in Ares-SC2\nDESCRIPTION: This example shows how to create a mine drop strategy by combining individual combat behaviors. The code demonstrates the hierarchical organization of behaviors within a CombatManeuver, including picking up widow mines, pathing to the enemy base, dropping cargo, and keeping the medivac safe when not carrying cargo.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/combat_maneuver_example.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import (\n    DropCargo,\n    KeepUnitSafe,\n    PathUnitToTarget,\n    PickUpCargo,\n)\nfrom sc2.unit import Unit\nfrom sc2.units import Units\nimport numpy as np\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        # retrieve medivac and mines_to_pickup and pass to method\n        # left out here for clarity\n        # mines would require their own behavior\n        self.do_medivac_mine_drop(medivac, mines_to_pickup)\n        \n    def do_medivac_mine_drop(\n            self, \n            medivac: Unit, \n            mines_to_pickup: Units\n    ) -> None:\n        # initialize a new CombatManeuver\n        mine_drop: CombatManeuver = CombatManeuver()\n        # get a grid for the medivac to path on\n        air_grid: np.ndarray = self.mediator.get_air_grid\n        # first priority is picking up units\n        mine_drop.add(\n            PickUpCargo(\n                unit=medivac, \n                grid=air_grid, \n                pickup_targets=mines_to_pickup)\n        )\n        # if there is cargo, path to target and drop them off\n        if medivac.has_cargo:\n            # path\n            mine_drop.add(\n                PathUnitToTarget(\n                    unit=medivac,\n                    grid=air_grid,\n                    target=self.enemy_start_locations[0],\n                )\n            )\n            # drop off the mines\n            mine_drop.add(\n                DropCargo(unit=medivac, target=medivac.position)\n            )\n        # no cargo and no units to pick up, stay safe\n        else:\n            mine_drop.add(\n                KeepUnitSafe(unit=medivac, grid=air_grid)\n            )\n        \n        # finally register this maneuver to be executed\n        self.register_behavior(mine_drop)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Pathfinding Grids in Ares SC2 with Python\nDESCRIPTION: Example implementation of custom ground and air pathfinding grids using SC2MapAnalysis library. Shows how to create blank grids, add cost weights for enemy locations and units, and integrate with Ares pathfinding functions. Includes handling of both ground and air unit threats with appropriate range buffers.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom map_analyzer import MapData\nfrom ares import AresBot\nimport numpy as np\nfrom sc2.position import Point2\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        # get access to the SC2MapAnalysis library\n        map_data: MapData = self.mediator.get_map_data_object\n        \n        # get a clean ground grid\n        my_ground_grid: np.ndarray = map_data.get_pyastar_grid()\n        # or an air grid if needed\n        my_air_grid: np.ndarray = map_data.get_clean_air_grid()\n        \n        \"\"\"\n        Add cost to this grid\n        For this example, let's make the enemy spawn location\n        really dangerous!\n        In effect this will draw a circle (20 radius) around the enemy spawn,\n        and add 100 cost to all tiles in this circle.\n        \"\"\"\n        my_ground_grid = map_data.add_cost(\n            position=self.enemy_start_locations[0],\n            radius=20,\n            grid=my_ground_grid,\n            weight=100.5\n        )\n        \n        \n        \"\"\"\n        In a real world bot, you probably add cost for enemy units,\n        structures and effects, something like:\n        \"\"\"\n        radius_buffer: float = 2.0\n        for unit in self.all_enemy_units:\n            if unit.can_attack_ground:\n                my_ground_grid = map_data.add_cost(\n                    position=unit.position,\n                    radius=unit.ground_range + radius_buffer,\n                    grid=my_ground_grid,\n                    weight=unit.ground_dps\n                )\n            if unit.can_attack_air:\n                my_air_grid = map_data.add_cost(\n                    position=self.enemy_start_locations[0],\n                    radius=unit.air_range + radius_buffer,\n                    grid=my_air_grid,\n                    weight=unit.ground_dps\n                )\n                \n        # now my_ground_grid, my_ground_grid are ready to use\n        \n        # will find the best path to enemy spawn, factoring in enemy cost\n        move_to: Point2 = self.mediator.find_path_next_point(\n            start=self.start_location,\n            target=self.enemy_start_locations[0],\n            grid=my_ground_grid\n        )\n```\n\n----------------------------------------\n\nTITLE: Creating Combat Maneuvers with Individual Unit Behaviors in Ares-SC2\nDESCRIPTION: This example shows how to implement a medivac mine drop maneuver by combining individual unit behaviors. It demonstrates the flexibility of Ares-SC2's combat behavior system for creating custom unit tactics.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import (\n    DropCargo,\n    KeepUnitSafe,\n    PathUnitToTarget,\n    PickUpCargo,\n)\nfrom sc2.unit import Unit\nfrom sc2.units import Units\nimport numpy as np\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        # retrieve medivac and mines_to_pickup and pass to method\n        # left out here for clarity\n        # mines would require their own behavior\n        self.do_medivac_mine_drop(medivac, mines_to_pickup)\n\n    def do_medivac_mine_drop(\n            self, \n            medivac: Unit, \n            mines_to_pickup: Units\n    ) -> None:\n        # initialize a new CombatManeuver\n        mine_drop: CombatManeuver = CombatManeuver()\n        # get a grid for the medivac to path on\n        air_grid: np.ndarray = self.mediator.get_air_grid\n        # first priority is picking up units\n        mine_drop.add(\n            PickUpCargo(\n                unit=medivac, \n                grid=air_grid, \n                pickup_targets=mines_to_pickup)\n        )\n        # if there is cargo, path to target and drop them off\n        if medivac.has_cargo:\n            # path\n            mine_drop.add(\n                PathUnitToTarget(\n                    unit=medivac,\n                    grid=air_grid,\n                    target=self.enemy_start_locations[0],\n                )\n            )\n            # drop off the mines\n            mine_drop.add(\n                DropCargo(unit=medivac, target=medivac.position)\n            )\n        # no cargo and no units to pick up, stay safe\n        else:\n            mine_drop.add(\n                KeepUnitSafe(unit=medivac, grid=air_grid)\n            )\n\n        # finally register this maneuver to be executed\n        self.register_behavior(mine_drop)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Ares SC2 Bot with Production and Spawn Controllers\nDESCRIPTION: Shows how to create a simple Ares SC2 bot that uses ProductionController and SpawnController to manage army production based on a defined composition.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/managing_production.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.macro import ProductionController, SpawnController\n\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\n\nclass TestBot(AresBot):\n    \n    @property\n    def viking_tank(self) -> dict:\n        return {\n            UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n            UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n            UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n            UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n        }\n\n    async def on_step(self, iteration: int) -> None:\n        await super(TestBot, self).on_step(iteration)\n        \n        production_location = self.start_location\n        \n        # production controller\n        self.register_behavior(\n            ProductionController(self.viking_tank, production_location)\n        )\n        \n        # spawn controller\n        self.register_behavior(\n            SpawnController(self.viking_tank)\n        )\n```\n\n----------------------------------------\n\nTITLE: Custom SiegeTankDecision Behavior Implementation for Ares-SC2\nDESCRIPTION: Implementation of a custom SiegeTankDecision behavior that follows the CombatIndividualBehavior protocol. This behavior decides when tanks should siege or unsiege based on nearby enemy units, using KDTree for efficient distance queries.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_behaviors.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# siege_tank_decision.py`\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING\n\nfrom ares.behaviors.combat.individual import CombatIndividualBehavior\nfrom ares.cython_extensions.geometry import cy_distance_to\nfrom ares.managers.manager_mediator import ManagerMediator\nfrom ares.consts import UnitTreeQueryType\nfrom sc2.ids.ability_id import AbilityId\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nif TYPE_CHECKING:\n    from ares import AresBot\n\n@dataclass\nclass SiegeTankDecision(CombatIndividualBehavior):\n    \"\"\"Decide if a tank should either siege or unsiege.\n\n    Attributes\n    ----------\n    unit : Unit\n        The siege tank unit.\n    \"\"\"\n\n    unit: Unit\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -> bool:\n        unit_pos: Point2 = self.unit.position\n        type_id: UnitID = self.unit.type_id\n        \n        # get near enemy ground\n        # ares uses `KDTree` algorithm for faster distance queries\n        # let's make use of that\n        near_enemy_ground: Units = mediator.get_units_in_range(\n            start_points=[self.unit.position],\n            distances=14,\n            query_tree=UnitTreeQueryType.EnemyGround,\n        )[0]\n\n        if type_id == UnitID.SIEGETANK:\n            # if enemies are not too close, and enough ground enemy around then siege\n            close_to_tank: list[Unit] = [\n                e for e in near_enemy_ground if cy_distance_to(e.position, unit_pos) < 6.5\n            ]\n            if len(close_to_tank) == 0 and (\n                (ai.get_total_supply(near_enemy_ground) >= 4.0 and len(near_enemy_ground) > 3)\n            ):\n                self.unit(AbilityId.SIEGEMODE_SIEGEMODE)\n                return True\n\n        elif type_id == UnitID.SIEGETANKSIEGED:\n            # just a general if nothing around then unsiege\n            if len(near_enemy_ground) == 0:\n                self.unit(AbilityId.UNSIEGE_UNSIEGE)\n                return True\n        \n        # no action was carried out\n        return False\n```\n\n----------------------------------------\n\nTITLE: Using BuildStructure Behavior for Natural Wall Placement in Python\nDESCRIPTION: Python code showing how to use the BuildStructure behavior to programmatically place structures in the natural wall. This approach uses the registered behaviors system instead of build orders.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.ids.unit_typeid import UnitTypeId\n\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.GATEWAY,\n        wall=True,\n        to_count_per_base=2\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.CYBERNETICSCORE,\n        wall=True,\n        to_count_per_base=1\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.PYLON,\n        wall=True,\n        to_count_per_base=2\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.SHIELDBATTERY,\n        wall=True,\n        to_count_per_base=1\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Simplified Squad-Based AMoveGroup Implementation\nDESCRIPTION: Demonstrates simplified usage of UnitSquad attributes for group movement behavior.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsquad: UnitSquad\nAMoveGroup(\n    group=squad.squad_units, \n    group_tags=squad.tags, \n    target=target\n)\n```\n\n----------------------------------------\n\nTITLE: Build Configuration with Natural Wall Placements in YAML\nDESCRIPTION: Example build order configuration using the '@nat_wall' directive to place structures at natural wall positions. This uses the BuildRunner system to automatically handle placement based on custom definitions.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_4\n\nLANGUAGE: yml\nCODE:\n```\nUseData: True\n# How should we choose a build? Cycle is the only option for now\nBuildSelection: Cycle\n# For each Race / Opponent ID choose a build selection\nBuildChoices:\n    # test_123 is active if Debug: True (set via a `config.yml` file)\n    test_123:\n        BotName: Test\n        Cycle:\n            - NatWall\n\n    Protoss:\n        BotName: ProtossRace\n        Cycle:\n            - NatWall\n\n    Random:\n        BotName: RandomRace\n        Cycle:\n            - NatWall\n\n    Terran:\n        BotName: TerranRace\n        Cycle:\n            - NatWall\n\n    Zerg:\n        BotName: ZergRace\n        Cycle:\n            - NatWall\n\n\nBuilds:\n    NatWall:\n        ConstantWorkerProductionTill: 44\n        AutoSupplyAtSupply: 23\n        OpeningBuildOrder:\n            - 14 pylon @ nat_wall\n            - 15 gate @ nat_wall\n            - 16 gate @ nat_wall\n            - 16 core @ nat_wall\n            - 16 pylon @ nat_wall\n            - 16 shieldbattery @ nat_wall\n```\n\n----------------------------------------\n\nTITLE: Implementing Ling Harassment with Unit Roles in Ares-SC2\nDESCRIPTION: This snippet demonstrates a more complex strategy using unit roles. It assigns half of the zerglings to a harassment role and implements separate micro for the main force and harassers.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\n\nfrom ares.consts import UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n    \n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n        \n        # Add attribute to remember assigning ling harass\n        self._assigned_ling_harass: bool = False\n        \n\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n        \n        # we can now retrieve our units based on roles\n        ling_roach_force: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        ling_harassers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.HARASSING\n        )\n        \n        if ling_roach_force:\n            if not self._assigned_ling_harass:\n                self._assign_ling_harass(ling_roach_force)\n                self._assigned_ling_harass = True\n                \n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n            \n        if ling_harassers:\n            self._micro_ling_harassers(ling_harassers)\n            \n    async def on_unit_created(self, unit: Unit) -> None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # assign all units to ATTACKING role by default\n        if unit.type_id in self.LING_ROACH_TYPES:\n            self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n            \n    def _assign_ling_harass(self, ling_roach_force: Units) -> None:\n        # get all lings from our force\n        lings: list[Unit] = [\n            u for u in ling_roach_force if u.type_id == UnitTypeId.ZERGLING\n        ]\n        \n        # iterate through lings\n        for i, ling in enumerate(lings):\n            # if current iteration is an even number, assign ling to harass\n            # this should select half lings\n            if i % 2 == 0:\n                # actually assign the role\n                self.mediator.assign_role(\n                    tag=ling.tag, role=UnitRole.HARASSING\n                )\n    \n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -> None:\n        # Here we micro the main force\n        for unit in ling_roach_force:\n            unit.attack(target)\n            \n    def _micro_ling_harassers(self, ling_harassers: Units) -> None:\n        # Here we micro the harass force\n        for unit in ling_harassers:\n            # now do whatever you want with these harassing units!\n            # here we ask ares for a potential enemy third location\n            unit.attack(self.mediator.get_enemy_third)\n```\n\n----------------------------------------\n\nTITLE: Extended Group Combat with StutterForward Behavior\nDESCRIPTION: Implements advanced group combat behavior combining StutterGroupForward for engaging nearby enemies and AMoveGroup as a fallback behavior.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom cython_extensions import cy_center\n\nfrom sc2.position import Point2\nfrom sc2.units import Units\n\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup, StutterGroupForward\nfrom ares.consts import UnitTreeQueryType\n\n\ndef control_roach_hit_squad(\n        self, \n        roach_hit_squad: \n        Units, target: Point2\n    ) -> None:\n    squad_position: Point2 = Point2(cy_center(roach_hit_squad))\n    \n    # retreive close enemy to the roach squad\n    close_ground_enemy: Units = self.mediator.get_units_in_range(\n        start_points=[squad_position],\n        distances=15.5,\n        query_tree=UnitTreeQueryType.EnemyGround,\n    )[0]\n    \n    # declare a new group maneuver\n    roach_squad_maneuver: CombatManeuver = CombatManeuver()\n    \n    # stutter forward to any ground enemies\n    # as this behavior is added first to the maneuver it \n    # has the highest priority\n    roach_squad_maneuver.add(\n      StutterGroupForward(\n        group=roach_hit_squad,\n        group_tags={u.tag for u in roach_hit_squad},\n        group_position=squad_position,\n        target=target,\n        enemies=close_ground_enemy,\n      )\n    )\n    \n    # if StutterGroupForward does not execute, our units will AMove\n    roach_squad_maneuver.add(\n      AMoveGroup(\n        group=roach_hit_squad, \n        group_tags={r.tag for r in roach_hit_squad}, \n        target=target\n      )\n    )\n    \n    self.register_behavior(roach_squad_maneuver)\n```\n\n----------------------------------------\n\nTITLE: Using KeepUnitSafe Combat Behavior in Python\nDESCRIPTION: Demonstrates how to use the KeepUnitSafe behavior to automatically find and move a unit to a safe position based on grid influence.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.behaviors.combat.individual import KeepUnitSafe\nfrom ares.behaviors.behavior import Behavior\n\nunit: Unit = self.workers[0]\n\n\nkeep_safe: Behavior = KeepUnitSafe(\n    unit=unit,\n    grid=self.mediator.get_ground_grid,\n)\nself.register_behavior(keep_safe)\n```\n\n----------------------------------------\n\nTITLE: Working with Raw Wall Placement Data in Python\nDESCRIPTION: Shows how to access and filter the raw placement data to get specific building locations that are part of a wall at the natural expansion. It extracts both 2x2 and 3x3 building placements marked as wall positions.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import BuildingSize\nfrom sc2.position import Point2\n\nplacements_dict: dict[Point2, dict[BuildingSize, dict]] = self.mediator.get_placements_dict\nnatural_placements: dict[BuildingSize, dict] = placements_dict[self.mediator.get_own_nat]\n\ntwo_by_twos_at_wall: list[Point2] = [\n            placement\n            for placement in natural_placements[BuildingSize.TWO_BY_TWO]\n            if natural_placements[BuildingSize.TWO_BY_TWO][placement][\"is_wall\"]\n        ]\n\nthree_by_threes_at_wall: list[Point2] = [\n            placement\n            for placement in natural_placements[BuildingSize.TWO_BY_TWO]\n            if natural_placements[BuildingSize.THREE_BY_THREE][placement][\"is_wall\"]\n        ]\n```\n\n----------------------------------------\n\nTITLE: Building Structures with BuildStructure Behavior in Ares-SC2\nDESCRIPTION: This snippet demonstrates how to use the BuildStructure behavior to construct a Barracks at a specified base location. The behavior handles the placement logic using Ares-SC2's calculated production formations.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.behaviors.macro import BuildStructure\nfrom sc2.ids.unit_typeid import UnitTypeId\n\nself.register_behavior(\n    BuildStructure(\n        base_location=self.start_location,\n        structure_id=UnitTypeId.BARRACKS\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Using PathGroupToTarget Combat Behavior in Python\nDESCRIPTION: Demonstrates how to use the PathGroupToTarget behavior to handle pathing and movement for a group of units, taking into account grid influence.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.behaviors.combat.group import PathGroupToTarget\nfrom ares.behaviors.behavior import Behavior\n\ngroup: Units = self.workers\n\n\npath_group: Behavior = PathGroupToTarget(\n    start=group.center,\n    group=group,\n    group_tags={u.tag for u in group},\n    grid=self.mediator.get_ground_grid,\n    target=self.game_info.map_center\n)\nself.register_behavior(path_group)\n```\n\n----------------------------------------\n\nTITLE: Selecting a Worker for Building Tasks\nDESCRIPTION: Shows how to select a worker using Ares mediator and assign it to the BUILDING role. This is an alternative to python-sc2's select_build_worker method that works with the Mining behavior.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import UnitRole\n\nif worker := self.mediator.select_worker(\n        target_position=self.start_location\n    ):\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.BUILDING)\n```\n\n----------------------------------------\n\nTITLE: Selecting and Assigning a Worker in Ares SC2\nDESCRIPTION: Demonstrates how to properly select a worker through the mediator and assign it a role to prevent the Mining task from reassigning it. The mediator selects a worker that isn't currently mining or holding resources when possible.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import UnitRole\n\nif worker := self.mediator.select_worker(\n        target_position=self.start_location\n    ):\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.DEFENDING)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Units from Multiple Roles in Ares-SC2\nDESCRIPTION: This snippet demonstrates how to get units assigned to multiple roles simultaneously.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nself.mediator.get_units_from_roles(\n    roles={UnitRole.HARASSING, UnitRole.DROP_UNITS_ATTACKING}\n)\n```\n\n----------------------------------------\n\nTITLE: Using KeepGroupSafe Combat Behavior in Python\nDESCRIPTION: Shows how to use the KeepGroupSafe behavior to automatically find and move a group of units to a safe position based on grid influence.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.behaviors.combat.group import KeepGroupSafe \nfrom ares.behaviors.behavior import Behavior\n\ngroup: Units = self.workers\n\n\nkeep_group_safe: Behavior = KeepGroupSafe(\n    group=group,\n    grid=self.mediator.get_ground_grid,\n)\nself.register_behavior(keep_group_safe)\n```\n\n----------------------------------------\n\nTITLE: Switching Unit Roles in Ares-SC2\nDESCRIPTION: This snippet demonstrates how to switch units from one role to another, specifically from ATTACKING to DEFENDING.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nself.mediator.switch_roles(\n    from_role=UnitRole.ATTACKING, to_role=UnitRole.DEFENDING\n)\n```\n\n----------------------------------------\n\nTITLE: Expanding with Ares Worker Selection\nDESCRIPTION: Shows how to combine python-sc2's get_next_expansion with Ares's build_with_specific_worker to expand a base. This approach provides additional functionality like replacing dead building workers and pathing control.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Use `python-sc2` get_next_expansion to get a new base location\nif next_expand_loc := await self.get_next_expansion():\n    # ask ares for a worker\n    if worker := self.mediator.select_worker(\n            target_position=next_expand_loc,\n            force_close=True,\n    ):\n        # use ares build_with_specific_worker worker to build base\n        # this will assign worker a new role\n        # additionally by using this method, you get some extra functionality!\n        # Such as replacing dead building workers and pathing control or worker\n        self.mediator.build_with_specific_worker(\n            worker=worker,\n            structure_type=UnitTypeId.NEXUS,\n            pos=next_expand_loc,\n        )\n```\n\n----------------------------------------\n\nTITLE: Checking Pending Structures in Ares\nDESCRIPTION: Demonstrates how to check for pending structures in Ares, which is an alternative to python-sc2's already_pending method. This accounts for workers on route to build structures that already_pending would miss.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# checks workers on route and in progress structures\nnum_pending_barracks: int = self.structure_pending(UnitTypeId.BARRACKS)\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom SiegeTankDecision with Existing Combat Maneuvers\nDESCRIPTION: Updated implementation of the marine and tank controller that incorporates the custom SiegeTankDecision behavior into the combat maneuver. The behavior is added with higher priority than AMove, allowing it to handle siege/unsiege decisions before movement commands.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_behaviors.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import AMove\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\nfrom sc2.position import Point2\n\n# IMPORT SiegeTankDecision, modify import based on where you saved it\nfrom bot.siege_tank_decision import SiegeTankDecision\n\n\nclass MyBot(AresBot):\n    MARINE_TANK_TYPES: set[UnitTypeId] = {\n        UnitTypeId.MARINE, UnitTypeId.SIEGETANKSIEGED, UnitTypeId.SIEGETANK\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n\n        if marine_tank_force := self.units(self.MARINE_TANK_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_marine_tank(marine_tank_force, attack_target)\n\n    def _micro_marine_tank(self, units: Units, target: Point2) -> None:\n        for unit in units:\n            # set up a new CombatManeuver for this unit\n            offensive_attack: CombatManeuver = CombatManeuver()\n            \n            # ADD OUR CUSTOM SIEGE BEHAVIOR HERE\n            # Maneuvers should be set up so that higher priority tasks are added first.\n            # If this returns False for a tank, then the \n            # AMove behavior will try to execute an action instead\n            offensive_attack.add(SiegeTankDecision(unit))\n            \n            # add AMove to this maneuver\n            # AMove always returns True so should typically be added at the end\n            offensive_attack.add(AMove(unit, target))\n            # register the maneuver so it gets executed\n            self.register_behavior(offensive_attack)\n```\n\n----------------------------------------\n\nTITLE: Counting Workers on Route to Build Structures\nDESCRIPTION: Shows how to count only workers on route to build a structure, which is useful for Protoss or Zerg where this differs from structure_pending. For Terran, this returns the same value as structure_pending.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# checks workers on route, doesn't include gateways in construction\nnum_on_route_to_build_gateways: int = self.mediator.get_building_counter[UnitTypeId.GATEWAY]\n```\n\n----------------------------------------\n\nTITLE: Implementing Roach Squad Control with UnitSquad System\nDESCRIPTION: Core method for controlling roach squads using the UnitSquad system. Handles squad formation, enemy detection, and combat maneuvers with StutterGroupForward and AMoveGroup behaviors.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef control_roach_hit_squad(\n        self, \n        roach_hit_squad: Units, \n        target: Point2\n    ) -> None:\n    \n    squads: list[UnitSquad] = self.mediator.get_squads(\n        role=UnitRole.CONTROL_GROUP_ONE, squad_radius=9.0\n    )\n    for squad in squads:\n        squad_position: Point2 = squad.squad_position\n        units: list[Unit] = squad.squad_units\n        squad_tags: set[int] = squad.tags\n        \n        # retreive close enemy to the roach squad\n        close_ground_enemy: Units = self.mediator.get_units_in_range(\n            start_points=[squad_position],\n            distances=11.5,\n            query_tree=UnitTreeQueryType.EnemyGround,\n        )[0]\n        \n        # declare a new group maneuver\n        roach_squad_maneuver: CombatManeuver = CombatManeuver()\n        \n        # stutter forward to any ground enemies\n        # as this behavior is added first to the maneuver it \n        # has the highest priority\n        roach_squad_maneuver.add(\n          StutterGroupForward(\n            group=units,\n            group_tags=squad_tags,\n            group_position=squad_position,\n            target=target,\n            enemies=close_ground_enemy,\n          )\n        )\n        \n        # if StutterGroupForward does not execute, our units will AMove\n        roach_squad_maneuver.add(\n          AMoveGroup(\n            group=units, \n            group_tags=squad_tags, \n            target=target\n          )\n        )\n        \n        self.register_behavior(roach_squad_maneuver)\n```\n\n----------------------------------------\n\nTITLE: Defining Army Composition Dictionary in Python for SC2 Bot\nDESCRIPTION: Demonstrates how to define an army composition dictionary for a Viking-Tank strategy in StarCraft 2. The dictionary specifies unit types, their proportions, and priorities for production.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/managing_production.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\n\n@property\ndef viking_tank(self) -> dict:\n    return {\n        UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n        UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n        UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n        UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n    }\n```\n\n----------------------------------------\n\nTITLE: Removing a Unit from a UnitSquad\nDESCRIPTION: Demonstrates how to properly remove a unit from a UnitSquad using the mediator's remove_tag_from_squads method. This ensures accurate squad calculations when selecting units already assigned to squads.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.unit import Unit\n\n# pretend this unit is already assigned to a unit squad\nunit: Unit = self.units[0]\nself.mediator.remove_tag_from_squads(tag=unit.tag)\n```\n\n----------------------------------------\n\nTITLE: Using Cython Extensions to Check Grid Safety in Python\nDESCRIPTION: Shows how to use the cython_extensions-sc2 library's cy_point_below_value function to efficiently check if a position is safe based on grid values.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom cython_extensions import cy_point_below_value\n\ngrid: np.ndarray = self.mediator.get_climber_grid\n\nif reapers := self.mediator.get_own_army_dict[UnitTypeId.REAPER]:\n    for reaper in reapers:\n        pos: Point2 = reaper.position\n        reaper_is_safe: float = cy_point_below_value(\n            grid=grid, \n            position=pos.rounded,\n            weight_safety_limit=1.0 # default pathing cell with no danger is 1.0\n        )\n```\n\n----------------------------------------\n\nTITLE: Reassigning a Unit's Role to Remove from Squad\nDESCRIPTION: Shows how to automatically remove a unit from a squad by assigning it a new role. When using the Ares role system, units are automatically removed from squads when assigned a new role.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import UnitRole\nfrom sc2.unit import Unit\n\n# pretend this unit is already assigned to a unit squad\nunit: Unit = self.units[0]\n# switches unit to new role, and removes from any squad\nself.mediator.assign_role(tag=unit.tag, role=UnitRole.DEFENDING)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Runner YAML Structure\nDESCRIPTION: Example configuration file showing the structure for declaring build orders and race-specific choices in protoss_builds.yml\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Save the game opening and result to disk?\n# Setting to `True` allows Ares to select a new opening after defeat\nUseData: True\n# How should we choose a build? Cycle is the only option for now\nBuildSelection: Cycle\n# For each Race / Opponent ID choose a build selection\nBuildChoices:\n    # test_123 is active if Debug: True (set via a `config.yml` file)\n    test_123:\n        BotName: Test\n        Cycle:\n            - FastExpand\n            \n    Protoss:\n        BotName: ProtossRace\n        Cycle:\n            - FastExpand\n            - WorkerBuild\n            \n    Random:\n        BotName: RandomRace\n        Cycle:\n            - FastExpand\n            \n    Terran:\n        BotName: TerranRace\n        Cycle:\n            - FastExpand\n            \n    Zerg:\n        BotName: ZergRace\n        Cycle:\n            - FastExpand\n            - WorkerBuild\n    \n    # Can also use specific opponent ids (overrides race options above)\n    a_bot_opponent_id_from_aiarena:\n        BotName: QueenBot\n        Cycle:\n            - FastExpand\n\nBuilds:\n    WorkerBuild:\n        ConstantWorkerProductionTill: 22\n        OpeningBuildOrder:\n            - 12 chrono @ nexus\n            - 14 pylon @ ramp\n            - 16 gateway\n    FastExpand:\n        ConstantWorkerProductionTill: 0\n        OpeningBuildOrder:\n            ['12 worker', '13 worker', '14 supply', '14 worker', '14 chrono @ nexus',\n             '15 worker', '15 gateway', '16 worker', '17 expand', '17 worker', '17 zealot']\n```\n\n----------------------------------------\n\nTITLE: Working with Unit Roles and Worker Assignment in Ares-SC2\nDESCRIPTION: This snippet shows how to select a worker for a defensive role using the mediator system. It demonstrates worker selection and role assignment, then retrieves all workers with the specified role for further commands.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import UnitRole\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\n\nif worker := self.mediator.select_worker(target_position=self.main_base_ramp.top_center):\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.DEFENDING)\n\n# retrieve `UnitRole.DEFENDING` workers\ndefending_workers: Units = self.mediator.get_units_from_role(\n    role=UnitRole.DEFENDING, unit_type=UnitTypeId.SCV\n)\n```\n\n----------------------------------------\n\nTITLE: Executing Individual Combat Behavior in Ares-SC2\nDESCRIPTION: This snippet demonstrates how to execute a single combat behavior directly instead of combining multiple behaviors in a CombatManeuver. In this case, it's registering the KeepUnitSafe behavior for a medivac unit.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/combat_maneuver_example.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nself.register_behavior(KeepUnitSafe(unit=medivac, grid=air_grid))\n```\n\n----------------------------------------\n\nTITLE: Initializing an Ares StarCraft 2 Bot with Mining Behavior in Python\nDESCRIPTION: This code snippet demonstrates how to create a basic StarCraft 2 bot using the Ares framework. It shows the standard pattern of extending the AresBot base class and registering the Mining behavior in the on_step method, which handles resource gathering for the bot.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/api_reference/behaviors/macro_behaviors.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.macro.mining import Mining\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n        self.register_behavior(Mining())\n```\n\n----------------------------------------\n\nTITLE: Separating Roach Units into Hit Squad\nDESCRIPTION: Extends the Zerg bot to separate roaches into a dedicated hit squad at 6 minutes using the CONTROL_GROUP_ONE role.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n        \n        self._assigned_roach_hit_squad: bool = False\n        \n    async def on_step(self, iteration: int) -> None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        \n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n        \n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time > 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n```\n\n----------------------------------------\n\nTITLE: Basic Zerg Bot with Unit Role Assignment\nDESCRIPTION: Implements a basic Zerg bot that assigns all non-worker, non-structure units to the ATTACKING role using the Ares unit role system.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n        \n    async def on_step(self, iteration: int) -> None:\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n```\n\n----------------------------------------\n\nTITLE: Clearing a Unit's Role in Ares-SC2\nDESCRIPTION: This snippet shows how to remove a unit from the unit role system completely.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nself.mediator.clear_role(tag=unit.tag)\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Unit Types from a Role in Ares-SC2\nDESCRIPTION: This snippet shows how to retrieve specific unit types (e.g., Banshees) from a given role (HARASSING).\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nself.mediator.get_units_from_role(\n    role=UnitRole.HARASSING, unit_type={UnitTypeId.BANSHEE}\n)\n```\n\n----------------------------------------\n\nTITLE: Using python-sc2 build Method with Ares Worker Selection\nDESCRIPTION: Demonstrates how to select a worker using Ares and then use it with python-sc2's build method by passing the worker as a parameter. This ensures the Mining behavior doesn't interfere with the building process.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# building_pos is the area you want to build in\nbuilding_pos: Point2 = self.start_location\n\nif worker := self.mediator.select_worker(target_position=building_pos):\n    # ares has given us a worker, assign it a role so ares doesn't\n    # steal it for mining\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.BUILDING)\n    # now we are free to use this worker with `self.build())   \n    await self.build(\n        building=UnitTypeId.BARRACKS, \n        near=building_pos, \n        build_worker=worker\n    )\n```\n\n----------------------------------------\n\nTITLE: Requesting Pylon Placement via ManagerMediator in Python\nDESCRIPTION: Demonstrates how to request a pylon placement at the natural expansion without reserving the placement in the building tracker. This is useful for checking potential building locations without committing to them.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.ids.unit_typeid import UnitTypeId\n\nif placement := mediator.request_building_placement(\n        base_location=self.mediator.get_own_nat,\n        structure_type=UnitTypeId.PYLON,\n        first_pylon=self.first_pylon,\n        reserve_placement=False\n    ):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Building Placements in YAML\nDESCRIPTION: Example YAML configuration for custom building placements across multiple maps, defining Protoss vs Zerg natural wall setups. The file structure includes race, map, placement type, and specific position coordinates for different building types.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_0\n\nLANGUAGE: yml\nCODE:\n```\nProtoss:\n    AbyssalReef:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [[64., 105.]]\n                Pylons: [[63., 112.]]\n                ThreeByThrees: [[68.5, 109.5], [66.5, 106.5], [60.5, 106.5]]\n                StaticDefences: [[64., 110.]]\n                GateKeeper: [[62.25, 105.86]]\n            LowerSpawn:\n                FirstPylon: [[136., 39.]]\n                Pylons: [[137., 32.]]\n                ThreeByThrees: [[131.5, 34.5], [133.5, 37.5], [139.5, 37.5]]\n                StaticDefences: [[136., 36.]]\n                GateKeeper: [[137.25, 38.6]]\n    Acropolis:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 35., 109. ] ]\n                Pylons: [ [ 32., 109. ] ]\n                ThreeByThrees: [ [ 38.5, 106.5 ], [ 34.5, 105.5 ], [ 31.5, 105.5 ] ]\n                StaticDefences: [ [ 39., 109. ] ]\n                GateKeeper: [ [ 36.6, 105.6 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 141., 63. ] ]\n                Pylons: [ [ 144., 63. ] ]\n                ThreeByThrees: [ [ 137.5, 66.5 ], [ 141.5, 66.5 ], [ 144.5, 66.5 ] ]\n                StaticDefences: [ [ 137., 63. ] ]\n                GateKeeper: [ [ 139.3, 67.4 ] ]\n    Automaton:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 141., 139. ] ]\n                Pylons: [ [ 140., 142. ] ]\n                ThreeByThrees: [ [ 138.5, 133.5 ], [ 136.5, 137.5 ], [ 136.5, 140.5 ] ]\n                StaticDefences: [ [ 142., 136. ] ]\n                GateKeeper: [ [ 136.9, 135.6 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 43., 42. ] ]\n                Pylons: [ [ 44., 39. ] ]\n                ThreeByThrees: [ [ 45.5, 46.5 ], [ 47.5, 42.5 ], [ 47.5, 39.5 ] ]\n                StaticDefences: [ [ 42., 45. ] ]\n                GateKeeper: [ [ 47.15, 45.3 ] ]\n    Ephemeron:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 37., 112. ] ]\n                Pylons: [ [ 37., 109. ] ]\n                ThreeByThrees: [ [ 42.5, 114.5 ], [ 42.5, 110.5 ], [ 41.5, 107.5 ] ]\n                StaticDefences: [ [ 38., 115. ] ]\n                GateKeeper: [ [ 43.1, 112.58 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 125., 49. ] ]\n                Pylons: [ [ 125., 52. ] ]\n                ThreeByThrees: [ [ 120.5, 45.5 ], [ 120.5, 49.5 ], [ 120.5, 52.5 ] ]\n                StaticDefences: [ [ 125., 46. ] ]\n                GateKeeper: [ [ 119.7, 47.4 ] ]\n    Interloper:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 31., 112. ] ]\n                Pylons: [ [ 31., 109. ] ]\n                ThreeByThrees: [ [ 35.5, 114.5 ], [ 35.5, 110.5 ], [ 35.5, 107.5 ] ]\n                StaticDefences: [ [ 31., 115. ] ]\n                GateKeeper: [ [ 36.16, 112.68 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 121., 56. ] ]\n                Pylons: [ [ 121., 59. ] ]\n                ThreeByThrees: [ [ 116.5, 53.5 ], [ 116.5, 57.5 ], [ 116.5, 60.5 ] ]\n                StaticDefences: [ [ 121., 53. ] ]\n                GateKeeper: [ [ 115.78, 55.75 ] ]\n    Thunderbird:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 46., 106. ] ]\n                Pylons: [ [ 46., 103. ] ]\n                ThreeByThrees: [ [ 50.5, 109.5 ], [ 50.5, 105.5 ], [ 50.5, 102.5 ] ]\n                StaticDefences: [ [ 46., 109. ] ]\n                GateKeeper: [ [ 51.18, 107.67 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 144., 51 ] ]\n                Pylons: [ [ 144., 54. ] ]\n                ThreeByThrees: [ [ 139.5, 46.5 ], [ 139.5, 50.5 ], [ 139.5, 53.5 ] ]\n                StaticDefences: [ [ 144., 48. ] ]\n                GateKeeper: [ [ 138.64, 48.49 ] ]\n```\n\n----------------------------------------\n\nTITLE: Finding Complete Path using find_raw_path in Python\nDESCRIPTION: Shows how to get the entire path from a start to target location using the find_raw_path method with influence from the air grid.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npath: list[Point2] = self.mediator.find_raw_path(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n```\n\n----------------------------------------\n\nTITLE: Minimal Custom Building Placement in YAML\nDESCRIPTION: Example of a minimal custom building_placements.yml file that only overrides specific positions (first pylon) for Thunderbird map while inheriting other default values.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_1\n\nLANGUAGE: yml\nCODE:\n```\n    Thunderbird:\n        VsZergNatWall:\n            UpperSpawn:\n                FirstPylon: [ [ 47., 107. ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 143., 52 ] ]\n```\n\n----------------------------------------\n\nTITLE: Finding Safe Spots using find_closest_safe_spot in Python\nDESCRIPTION: Shows how to find the closest safe position from a given location using the find_closest_safe_spot method with the air avoidance grid.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsafe_spot: Point2 = self.mediator.find_closest_safe_spot(\n    from_pos=self.start_location,\n    grid=self.mediator.get_air_avoidance_grid,\n    radius=8\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Gas Steal Prevention in YAML Build Order\nDESCRIPTION: Demonstrates how to disable the automatic gas steal prevention logic in a build order configuration using the ShouldHandleGasSteal flag. The example also includes a worker scout command at 12 supply.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nBuilds:\n    DummyBuild:\n        ShouldHandleGasSteal: False\n        OpeningBuildOrder:\n            - 12 worker_scout\n```\n\n----------------------------------------\n\nTITLE: Finding Next Point in Path using find_path_next_point in Python\nDESCRIPTION: Demonstrates how to use the find_path_next_point method to get the next point a unit should move to along a path, using the air grid for influence.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmove_to: Point2 = self.mediator.find_path_next_point(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Gatekeeper Position in Python\nDESCRIPTION: Code snippet showing how to retrieve the position for the gatekeeper (gap in wall) from the ares-sc2 mediator. Returns a Point2 object or None if no position is available.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnat_wall_gatekeeper_pos: Union[Point2, None] = self.mediator.get_pvz_nat_gatekeeping_pos\n```\n\n----------------------------------------\n\nTITLE: Using PathUnitToTarget Combat Behavior in Python\nDESCRIPTION: Shows how to use the PathUnitToTarget behavior to handle pathing and movement for an individual unit, taking into account grid influence.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.behaviors.combat.individual import PathUnitToTarget\nfrom ares.behaviors.behavior import Behavior\n\nunit: Unit = self.workers[0]\n\n\npath_unit: Behavior = PathUnitToTarget(\n    unit=unit,\n    grid=self.mediator.get_ground_grid,\n    target=self.game_info.map_center\n)\nself.register_behavior(path_unit)\n```\n\n----------------------------------------\n\nTITLE: Build Order Target Options Enum Definition\nDESCRIPTION: Enum class defining valid target locations for build commands\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass BuildOrderTargetOptions(str, Enum):\n    ENEMY_FOURTH = \"ENEMY_FOURTH\"\n    ENEMY_NAT = \"ENEMY_NAT\"\n    ENEMY_NAT_HG_SPOT = \"ENEMY_NAT_HG_SPOT\"\n    ENEMY_NAT_VISION = \"ENEMY_NAT_VISION\"\n    ENEMY_RAMP = \"ENEMY_RAMP\"\n    ENEMY_SPAWN = \"ENEMY_SPAWN\"\n    ENEMY_THIRD = \"ENEMY_THIRD\"\n    FIFTH = \"FIFTH\"\n    FOURTH = \"FOURTH\"\n    MAP_CENTER = \"MAP_CENTER\"\n    NAT = \"NAT\"\n    NAT_WALL = \"NAT_WALL\"\n    RAMP = \"RAMP\"\n    SIXTH = \"SIXTH\"\n    SPAWN = \"SPAWN\"\n    THIRD = \"THIRD\"\n```\n\n----------------------------------------\n\nTITLE: Finding Low Priority Path in Python\nDESCRIPTION: Demonstrates using find_low_priority_path to get several waypoints along a path instead of all points, useful for queuing commands for units like overlords.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath: list[Point2] = self.mediator.find_low_priority_path(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n```\n\n----------------------------------------\n\nTITLE: Building Placement Options Enum in Python\nDESCRIPTION: Python enum showing the valid building placement options that ares-sc2 uses when parsing the building_placements.yml file. These keys must match exactly when creating custom placements.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_building_placements.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass BuildingPlacementOptions(str, Enum):\n    LOWER_SPAWN = \"LowerSpawn\"\n    UPPER_SPAWN = \"UpperSpawn\"\n    VS_ZERG_NAT_WALL = \"VsZergNatWall\"\n    FIRST_PYLON = \"FirstPylon\"\n    PYLONS = \"Pylons\"\n    THREE_BY_THREES = \"ThreeByThrees\"\n    STATIC_DEFENCES = \"StaticDefences\"\n    GATE_KEEPER = \"GateKeeper\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic A-Move Combat with Marines and Tanks in Ares-SC2\nDESCRIPTION: A basic example showing how to implement a simple a-move attack for marine and tank units using Ares-SC2's CombatManeuver and AMove behaviors. The code registers an offensive attack maneuver for each unit in the force.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/custom_behaviors.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import AMove\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\nfrom sc2.position import Point2\n\n\nclass MyBot(AresBot):\n    MARINE_TANK_TYPES: set[UnitTypeId] = {\n        UnitTypeId.MARINE, UnitTypeId.SIEGETANKSIEGED, UnitTypeId.SIEGETANK\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n\n        if marine_tank_force := self.units(self.MARINE_TANK_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_marine_tank(marine_tank_force, attack_target)\n\n    def _micro_marine_tank(self, units: Units, target: Point2) -> None:\n        for unit in units:\n            # set up a new CombatManeuver for this unit\n            offensive_attack: CombatManeuver = CombatManeuver()\n            # add AMove to this maneuver\n            offensive_attack.add(AMove(unit, target))\n            # register the maneuver so it gets executed\n            self.register_behavior(offensive_attack)\n```\n\n----------------------------------------\n\nTITLE: Accessing Ares's Role Dictionary in Python\nDESCRIPTION: This snippet demonstrates how to access Ares's internal role dictionary, which can be useful for debugging.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nself.mediator.get_unit_role_dict\n```\n\n----------------------------------------\n\nTITLE: Using KDTree for Fast Unit Distance Queries in Ares-SC2\nDESCRIPTION: This code snippet demonstrates how to use KDTree to efficiently query enemy ground units near a group of Reapers. The method returns a dictionary mapping unit tags to nearby enemy units, enabling quick distance-based calculations.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ares.consts import UnitTreeQueryType\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nreapers: list[Unit] = self.mediator.get_own_units_dict[UnitTypeId.REAPER]\nall_ground_near_reapers: dict[int, Units] = self.mediator.get_units_in_range(\n    start_points=reapers,\n    distances=15,\n    query_tree=UnitTreeQueryType.EnemyGround,\n    return_as_dict=True,\n)\n\nfor reaper in reapers:\n    near_ground: Units = all_ground_near_reapers[reaper.tag]\n```\n\n----------------------------------------\n\nTITLE: Documenting ARES SC2 Combat Behaviors with MkDocs\nDESCRIPTION: This code represents MkDocs directives that include various ARES combat behavior modules in the documentation. Each ':::' directive imports documentation from a specific Python module path.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/api_reference/behaviors/combat_behaviors.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: ares.behaviors.combat.combat_maneuver\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.a_move\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.attack_target\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.drop_cargo\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.keep_unit_safe\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.medivac_heal\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.path_unit_to_target\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.pick_up_cargo\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.raven_auto_turret\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.siege_tank_decision\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.place_predictive_aoe\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.shoot_target_in_range\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.stutter_unit_back\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.stutter_unit_forward\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.use_ability\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.use_aoe_ability\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.use_transfuse\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n\n::: ares.behaviors.combat.individual.worker_kite_back\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false \n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Group Combat Maneuver\nDESCRIPTION: Adds group combat maneuver functionality to control the roach hit squad using AMoveGroup behavior.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/unit_squads_group_behaviors.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n        \n        self._assigned_roach_hit_squad: bool = False\n        \n    async def on_step(self, iteration: int) -> None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        \n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n        \n        self.control_roach_hit_squad(\n            roach_hit_squad=roach_hit_squad, \n            target=self.enemy_start_locations[0]\n        )\n        \n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time > 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n                \n    def control_roach_hit_squad(\n        self, \n        roach_hit_squad: Units, \n        target: Point2\n    ) -> None:\n        # declare a new group maneuver\n        roach_squad_maneuver: CombatManeuver = CombatManeuver()\n        # add group behaviors, these can be behaviors provided by ares\n        # or create your own custom group behaviors!\n        roach_squad_maneuver.add(\n          AMoveGroup(\n            group=roach_hit_squad, \n            group_tags={r.tag for r in roach_hit_squad}, \n            target=target\n          )\n        )\n        \n        self.register_behavior(roach_squad_maneuver)\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry Format\nDESCRIPTION: Shows the standard format used for version changelog entries with features, fixes, and documentation changes\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## v2.38.0 (2025-04-15)\n\n### Feature\n\n* **tech_up:** Check affordability before executing tech-up logic. Add techlabs if required. ([`e355df3`])\n* **combat:** Refactor siege tank decision logic for staying sieged near target. ([`2c4a290`])\n* **behaviors:** Add memory check to shoot_target_in_range ([`4f270d3`])\n\n### Fix\n\n* **combat:** Add execute method for shooting and moving to target. ([`0ca57ef`])\n* **aoe_ability_to_range:** Correct range and radius values for KD8CHARGE_KD8CHARGE. ([`b256e38`])\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic A-Move Bot in Python using Ares-SC2\nDESCRIPTION: This snippet shows a basic implementation of an a-move bot using python-sc2 and Ares-SC2. It defines a simple strategy where all units attack the enemy's starting location.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n    \n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n        \n\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n\n        if ling_roach_force := self.units(self.LING_ROACH_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n            \n            \n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -> None:\n        for unit in ling_roach_force:\n            unit.attack(target)\n```\n\n----------------------------------------\n\nTITLE: Initializing Poetry Project\nDESCRIPTION: Command to initialize a new Poetry project with specified name without interaction\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/contributing/index.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry init --name ares-sc2 --no-interaction\n```\n\n----------------------------------------\n\nTITLE: Introducing Unit Roles in Ares-SC2 Bot\nDESCRIPTION: This snippet enhances the previous bot by introducing unit roles. It assigns all created units to the ATTACKING role and retrieves them using the mediator.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/assigning_unit_roles.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\n\n# ADD IMPORT\nfrom ares.consts import UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n    \n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n        \n\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n        \n        ling_roach_force: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        if ling_roach_force:\n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n            \n    async def on_unit_created(self, unit: Unit) -> None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # assign all units to ATTACKING role by default\n        if unit.type_id in self.LING_ROACH_TYPES:\n            self.mediator.assign_role(\n                tag=unit.tag, role=UnitRole.ATTACKING\n            )\n            \n            \n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -> None:\n        for unit in ling_roach_force:\n            unit.attack(target)\n```\n\n----------------------------------------\n\nTITLE: Configuring isort with black in pyproject.toml\nDESCRIPTION: Configuration to make isort and black formatting tools work together harmoniously\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/contributing/index.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.isort]\nprofile = \"black\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workers with a Specific Role\nDESCRIPTION: Shows how to get all workers with a particular role (DEFENDING in this example) using the mediator's get_units_from_role method. This returns a Units collection filtered by both role and unit type.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/gotchas.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\n\ndefending_workers: Units = self.mediator.get_units_from_role(\n    role=UnitRole.DEFENDING, unit_type=UnitTypeId.SCV\n)\n```\n\n----------------------------------------\n\nTITLE: Markdown Header with Code Reference\nDESCRIPTION: Basic markdown header with inline code formatting referencing the ares-sc2 project name.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/index.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Tutorials\n\nIn this section you'll find tutorials of how to accomplish certain tasks in `ares-sc2`\n```\n\n----------------------------------------\n\nTITLE: Accessing Manager Data through Mediator in Python\nDESCRIPTION: Example of how to retrieve information from a manager through the mediator pattern in ares-sc2. The code accesses the ground grid data by calling the mediator's get_ground_grid method.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/api_reference/manager_mediator.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nground_grid: np.ndarray = self.mediator.get_ground_grid\n```\n\n----------------------------------------\n\nTITLE: Build Order Options Enum Definition\nDESCRIPTION: Enum class defining valid build order commands supported by the system\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass BuildOrderOptions(str, Enum):\n    ADDONSWAP = \"ADDONSWAP\"\n    CHRONO = \"CHRONO\"\n    CORE = \"CORE\"\n    GAS = \"GAS\"\n    GATE = \"GATE\"\n    EXPAND = \"EXPAND\"\n    ORBITAL = \"ORBITAL\"\n    OVERLORD_SCOUT = \"OVERLORD_SCOUT\"\n    SUPPLY = \"SUPPLY\"\n    WORKER = \"WORKER\"\n    WORKER_SCOUT = \"WORKER_SCOUT\"\n```\n\n----------------------------------------\n\nTITLE: Build Completion Check Code\nDESCRIPTION: Python code showing how to check if a build order is completed\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nself.build_order_runner.build_completed\n```\n\n----------------------------------------\n\nTITLE: Scout Control Code Example\nDESCRIPTION: Python code demonstrating how to take control of scout units\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nworker_scouts: Units = self.mediator.get_units_from_role(\n    role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=self.worker_type\n)\nfor scout in worker_scouts:\n    # issue custom commands\n    pass\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure Examples\nDESCRIPTION: Examples showing the directory structure before and after migration from python-sc2 to ares-sc2 starter bot template.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/migrating.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nMyBot\nmy_bot\n   some_folder\n   another_folder\n   main.py \nsc2\nrun.py\nladder.py\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nares-sc2-bot-template\nares-sc2\nbot\n   main.py \nscripts\nrun.py\nladder.py\n```\n\n----------------------------------------\n\nTITLE: Ares-SC2 Event Hooks Implementation\nDESCRIPTION: Example of event hook methods implementation in ares-sc2 with required super calls.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/migrating.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        await super(MyBot, self).on_step(iteration)\n        \n        # on_step logic here ...\n\n    async def on_start(self, iteration: int) -> None:\n        await super(MyBot, self).on_start(iteration)\n        \n        # on_start logic here ...\n\n    async def on_end(self, game_result: Result) -> None:\n        await super(MyBot, self).on_end(iteration)\n        \n        # custom on_end logic here ...\n\n    async def on_building_construction_complete(self, unit: Unit) -> None:\n        await super(MyBot, self).on_building_construction_complete(iteration)\n\n        # custom on_building_construction_complete logic here ...\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # custom on_unit_created logic here ...\n\n    async def on_unit_destroyed(self, unit_tag: int) -> None:\n        await super(MyBot, self).on_unit_destroyed(unit_tag)\n\n        # custom on_unit_destroyed logic here ...\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -> None:\n        await super(MyBot, self).on_unit_took_damage(unit, amount_damage_taken)\n\n        # custom on_unit_took_damage logic here ...\n```\n\n----------------------------------------\n\nTITLE: Python-SC2 Event Hooks Implementation\nDESCRIPTION: Example of event hook methods implementation in python-sc2 without super calls.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/migrating.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -> None:\n        pass\n\n    async def on_start(self, iteration: int) -> None:\n        pass\n\n    async def on_end(self, game_result: Result) -> None:\n        pass\n\n    async def on_building_construction_complete(self, unit: Unit) -> None:\n        pass\n\n    async def on_unit_created(self, unit: Unit) -> None:\n        pass\n\n    async def on_unit_destroyed(self, unit_tag: int) -> None:\n        pass\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -> None:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Bot Class Inheritance Change\nDESCRIPTION: Code comparison showing how to change the bot class inheritance from python-sc2's BotAI to ares-sc2's AresBot.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/migrating.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sc2.bot_ai import BotAI\n\nclass MyBot(BotAI):\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom ares import AresBot\n\nclass MyBot(AresBot):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Auto Supply Build Configuration\nDESCRIPTION: Example YAML configuration demonstrating auto supply feature usage\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/build_runner.md#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nBuilds:\n    DummyBuild:\n        # After 17 supply turn AutoSupply on\n        AutoSupplyAtSupply: 17\n        ConstantWorkerProductionTill: 50\n        OpeningBuildOrder:\n            - 14 pylon @ ramp\n            - 15 worker_scout:\n                [spawn, nat, enemy_spawn, third, fourth, map_center, enemy_nat]\n            - 16 gate\n            - 16 gas\n            - 17 gas\n            - 19 gate\n            - 20 core\n            - 22 adept x2\n            - 25 stargate\n```\n\n----------------------------------------\n\nTITLE: Group Combat Behavior Documentation Structure\nDESCRIPTION: Documentation structure for multiple combat-related group behaviors including a-move, path finding, safety management, stuttering, and ability usage.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/api_reference/behaviors/group_combat_behaviors.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: ares.behaviors.combat.group.a_move_group\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n\n::: ares.behaviors.combat.group.keep_group_safe\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n\n::: ares.behaviors.combat.group.path_group_to_target\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n\n::: ares.behaviors.combat.group.stutter_group_back\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n\n::: ares.behaviors.combat.group.stutter_group_forward\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n\n::: ares.behaviors.combat.group.group_use_ability\n    options:\n        show_root_heading: false\n        show_root_toc_entry: false\n```\n\n----------------------------------------\n\nTITLE: Checking Grid Cost at a Specific Position in Python\nDESCRIPTION: Demonstrates how to check the danger level (cost/influence) at a specific position using numpy array indexing with a grid.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/influence_and_pathing.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\n\ngrid: np.ndarray = self.mediator.get_climber_grid\n\nif reapers := self.mediator.get_own_army_dict[UnitTypeId.REAPER]:\n    for reaper in reapers:\n        pos: Point2 = reaper.position\n        reaper_danger_level: float = grid[pos[0], pos[1]]\n```\n\n----------------------------------------\n\nTITLE: Spawning Units with Chat Commands\nDESCRIPTION: Examples of chat commands to spawn various units at the camera location for different players.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/chat_debug.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nmake 4 marine - Spawns 4 marines for player 1 at camera location.\n\nmake 3 mothership 1 - Spawns 3 motherships for player 1 at camera location. \n\nmake 1 hive 2 - Spawn a hive for the enemy at camera location. Note\nthe 2 in the chat command, this spawns units for the enemy. \n\ncreate 4 banshee 2 - Spawn four banshees for the enemy at camera location. \n\ncreate 2 ultralisk 1 - Spawn two ultralisks for player one at camera location. Specifying player one in\nthis command even though it's not required.\n```\n\n----------------------------------------\n\nTITLE: Additional Debug Commands for Game Manipulation\nDESCRIPTION: Chat commands to enable various cheats and debug options like disabling cooldowns, revealing the map, and adding resources.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/chat_debug.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\ncooldown - Disables cooldowns of unit abilities for the bot\nfood - Disable food usage (not sure this one works)\ngod - Units and structures no longer take damage\nresources - Get 5000 minerals and 5000 vespene\nshow - Reveal map\ntech - Remove all tech requirements\nupgrades - Research all currently available upgrades\n```\n\n----------------------------------------\n\nTITLE: Destroying Units with Chat Commands\nDESCRIPTION: Examples of chat commands to destroy units for different players, regardless of camera location.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/chat_debug.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nkill 4 marine - Destroys 4 marines for player 1.\n\nkill 125 mothership 2 - Destroys 125 motherships. Note\nthe 2 in the chat command, this kills units for the enemy. \n\nkill 1 hive - Destroys a hive for player one. \n\ndestroy 4 banshee - Destroys three banshees for player one. \n\ndestroy 2 ultralisk 1 - Destroys two ultralisks for player one. Specifying player one in\nthis command even though it's not required.\n```\n\n----------------------------------------\n\nTITLE: Activating Chat Debug Configuration in YAML\nDESCRIPTION: Configuration settings required in config.yml to enable the chat debug feature in Ares SC2.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/tutorials/chat_debug.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nDebug: True\nChatDebug: True\n```\n\n----------------------------------------\n\nTITLE: Conventional Commit Message Format\nDESCRIPTION: Template showing the required structure for commit messages following conventional commits specification\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/contributing/index.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n\n----------------------------------------\n\nTITLE: MkDocs Python Documentation Example\nDESCRIPTION: Example of how to include Python docstrings in MkDocs documentation using mkdocstrings\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/contributing/index.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n::: ares.example_docstrings\n    options:\n        show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Markdown TODO Header\nDESCRIPTION: Simple markdown document with a header and TODO placeholder for future content about contributing to the Ares-SC2 project.\nSOURCE: https://github.com/aressc2/ares-sc2/blob/main/docs/dev-guide.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Required reading only if planning to contribute to Ares or understand inner workings\n\nTODO\n```"
  }
]