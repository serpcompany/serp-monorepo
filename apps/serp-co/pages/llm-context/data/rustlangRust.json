[
  {
    "owner": "rust-lang",
    "repo": "rust",
    "content": "TITLE: Installing Clippy Component via Rustup\nDESCRIPTION: Command to install Clippy using Rustup package manager. Optionally allows specifying a particular toolchain using the --toolchain flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/installation.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustup component add clippy [--toolchain=<name>]\n```\n\n----------------------------------------\n\nTITLE: Proper Variable Initialization in Rust\nDESCRIPTION: Shows the correct way to initialize and use variables in Rust by assigning a value at declaration time. This prevents the E0381 compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0381.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Vector Clone in Rust\nDESCRIPTION: Example showing trait bound checking for Clone implementation on Vec<T>. The function demonstrates how the trait solver verifies that Vec<T> implements Clone when T has a Clone bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/trait-solving.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn uses_vec_clone<T: Clone>(x: Vec<T>) -> (Vec<T>, Vec<T>) {\n    (x.clone(), x)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Box Type with Lang Items in Rust\nDESCRIPTION: This code snippet demonstrates how to implement a custom `Box` type in a freestanding Rust program using lang items. It includes implementations for memory allocation, deallocation, and necessary language items for a basic executable without the standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/lang-items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items, core_intrinsics, rustc_private, panic_unwind, rustc_attrs)]\n#![allow(internal_features)]\n#![no_std]\n#![no_main]\n\nextern crate libc;\nextern crate unwind;\n\nuse core::ffi::{c_int, c_void};\nuse core::intrinsics;\nuse core::panic::PanicInfo;\nuse core::ptr::NonNull;\n\npub struct Global; // the global allocator\nstruct Unique<T>(NonNull<T>);\n\n#[lang = \"owned_box\"]\npub struct Box<T, A = Global>(Unique<T>, A);\n\nimpl<T> Box<T> {\n    pub fn new(x: T) -> Self {\n        #[rustc_box]\n        Box::new(x)\n    }\n}\n\nimpl<T, A> Drop for Box<T, A> {\n    fn drop(&mut self) {\n        unsafe {\n            libc::free(self.0.0.as_ptr() as *mut c_void);\n        }\n    }\n}\n\n#[lang = \"exchange_malloc\"]\nunsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n    let p = libc::malloc(size) as *mut u8;\n\n    // Check if `malloc` failed:\n    if p.is_null() {\n        intrinsics::abort();\n    }\n\n    p\n}\n\n#[no_mangle]\nextern \"C\" fn main(_argc: c_int, _argv: *const *const u8) -> c_int {\n    let _x = Box::new(1);\n\n    0\n}\n\n#[lang = \"eh_personality\"]\nfn rust_eh_personality() {}\n\n#[panic_handler]\nfn panic_handler(_info: &PanicInfo) -> ! { intrinsics::abort() }\n```\n\n----------------------------------------\n\nTITLE: Reverting Accidental Submodule Changes in Git\nDESCRIPTION: A sequence of commands to fix accidentally committed changes to a submodule (like `src/tools/cargo`). It involves finding the offending commit, checking out the correct version of the submodule from the previous commit, creating a fixup commit, and then autosquashing during an interactive rebase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n# 1. Find the commit\ngit log --stat -n1 src/tools/cargo\n\n# 2. Revert the submodule change for that commit\n# Replace <my-commit> with the hash from step 1\ngit checkout <my-commit>~ src/tools/cargo\n\n# 3. Create a fixup commit\ngit commit --fixup <my-commit>\n\n# 4. Repeat for other affected commits/submodules\n\n# 5. Squash the fixup commits\ngit rebase --autosquash -i upstream/master\n\n# 6. Push the corrected history\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Registering New Rust Error Code\nDESCRIPTION: This Rust code snippet demonstrates how to register a new error code within the `register_diagnostics!` macro in `rustc_error_codes/src/error_codes.rs`.  It includes the error code and the path to its corresponding Markdown explanation file. This is a crucial step in making the error code available for use by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/error-codes.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nregister_diagnostics! {\n    ...\n    E0592: include_str!(\"./error_codes/E0592.md\"),\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Rust Analyzer in VS Code\nDESCRIPTION: This JSON configuration sets the RUSTUP_TOOLCHAIN environment variable to 'stable' for rust-analyzer in VS Code or coc-rust-analyzer. It ensures that rust-analyzer uses the stable toolchain regardless of project-specific overrides.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/installation.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{ \"rust-analyzer.server.extraEnv\": { \"RUSTUP_TOOLCHAIN\": \"stable\" } }\n```\n\n----------------------------------------\n\nTITLE: Cloning Rust Source Code\nDESCRIPTION: Commands to clone the Rust source code repository from GitHub and navigate to the project directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/rust-lang/rust.git\ncd rust\n```\n\n----------------------------------------\n\nTITLE: Configuring Conditional Compilation with --cfg\nDESCRIPTION: Examples of using the --cfg flag to enable conditional compilation features in Rust. The flag accepts either a single identifier or two identifiers separated by =.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n--cfg 'verbose'\n--cfg 'feature=\"serde\"'\n```\n\n----------------------------------------\n\nTITLE: Auto-importing Unresolved Names in Rust\nDESCRIPTION: This assist provides all possible imports for an unresolved name. It adds the necessary use statement to import the symbol.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let map = HashMap::new();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let map = HashMap::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Import Naming Conflict Using Full Paths in Rust\nDESCRIPTION: Demonstrates resolving naming conflicts by using fully qualified paths to reference items instead of importing them directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0252.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse bar::baz;\n\nfn main() {\n    let x = foo::baz; // ok!\n}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of impl Trait as Function Return Type in Rust\nDESCRIPTION: This example shows the proper use of `impl Trait` syntax as a function return type. The function `count_to_n` returns an iterator over a range from 0 to n, and the main function consumes this iterator in a for loop.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0562.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n    0..n\n}\n\nfn main() {\n    for i in count_to_n(10) {  // ok!\n        println!(\"{}\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Borrowing Mutation Error in Rust\nDESCRIPTION: Shows an example of attempting to modify a struct while a reference is active, which causes a compile-time error due to Rust's borrowing rules\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0506.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\n----------------------------------------\n\nTITLE: Fully Instantiated Query Example\nDESCRIPTION: This snippet shows the instantiation of a canonicalized query using the substitution S, replacing bound canonical variables with inference variables in preparation for solving the trait query.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n?A: Foo<'?B, ?C>\n```\n\n----------------------------------------\n\nTITLE: Managing Implied Bounds in Rust Language\nDESCRIPTION: This section of the Rust source code outlines the handling of implied bounds, focusing on the mechanism by which the Rust compiler handles these bounds indirectly through specific functions. Functions like `fn inferred_outlives_of`, `fn insert_required_predicates_to_be_wf`, and `fn check_explicit_predicates` play key roles in managing explicit bounds using fixpoint algorithms and the addition of required predicates. Implicit bounds are dealt with through environments set up by functions such as `fn OutlivesEnvironment::from_normalized_bounds` and `fn UniversalRegionRelationsBuilder::add_implied_bounds`. These functions include references to MIR borrow checking and the use of outlives requirements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/implied-bounds.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching in Rust\nDESCRIPTION: This example shows the correct way to perform pattern matching in Rust by using enum variants instead of methods. The code properly matches against the A::B variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0164.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum A {\n    B,\n    C,\n}\n\nimpl A {\n    fn new() {}\n}\n\nfn bar(foo: A) {\n    match foo {\n        A::B => (), // ok!\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Output with Custom Paths Example\nDESCRIPTION: Examples of using --emit flag to specify custom output paths for different emit types. Shows how to output to specific files and stdout.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n--emit=link,dep-info=/path/to/dep-info.d\n--emit=llvm-ir=-,mir\n```\n\n----------------------------------------\n\nTITLE: Utility Function is_foo_fn to Check Function Name - Rust\nDESCRIPTION: Defines the is_foo_fn utility, which checks whether the analyzed item in FnKind is a function named 'foo'. It pattern-matches FnKind::Fn to extract the Ident and compares its name to 'foo'; closures are ignored by returning false. Assumes the use of Ident's name.as_str API. This pure function aids separation of concerns and can be tested independently from the lint pass.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// use statements, impl EarlyLintPass, check_fn, ..\n\nfn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n    match fn_kind {\n        FnKind::Fn(_, ident, ..) => {\n            // check if `fn` name is `foo`\n            ident.name.as_str() == \"foo\"\n        }\n        // ignore closures\n        FnKind::Closure(..) => false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking rustc with linker plugin LTO and linker arguments\nDESCRIPTION: This snippet demonstrates how to invoke `rustc` directly with linker plugin LTO enabled and additional linker arguments. It includes the `-Clinker-plugin-lto`, `-L.`, `-Copt-level=2`, `-Clinker=clang`, and `-Clink-arg=-fuse-ld=lld` flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n\"rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs\"\n```\n\n----------------------------------------\n\nTITLE: Running Clippy with Cargo\nDESCRIPTION: Basic command to run Clippy using cargo subcommand.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy\n```\n\n----------------------------------------\n\nTITLE: Conditional compilation for target features (recommended)\nDESCRIPTION: This Rust code snippet demonstrates conditionally compiling code based on target features, which is the recommended approach. The `#[cfg(target_feature = \"...\")]` attribute ensures that the `foo` function is only compiled if the \"simd128\" feature is enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_feature = \"simd128\")]\nfn foo() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Mutable Borrow by Ending Borrow Scope\nDESCRIPTION: Shows how to fix the mutable borrow error by ensuring the borrow ends before using the original value again\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0503.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Rc and RefCell for Shared Ownership in Rust\nDESCRIPTION: This snippet demonstrates how to use Rc (reference counting) and RefCell for shared mutable ownership in Rust. It shows how multiple variables can share ownership of data with runtime borrow checking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0382.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Variant Pattern Matching in Rust\nDESCRIPTION: Shows the proper way to match against a specific enum variant, demonstrating the correct syntax for pattern matching on enum variants in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0574.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Jak {\n    Daxter { i: isize },\n}\n\nlet eco = Jak::Daxter { i: 1 };\nmatch eco {\n    Jak::Daxter { i } => {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Clippy via Rustup\nDESCRIPTION: Command to install Clippy linting tool using rustup component manager. Requires Rust version 1.29 or later. May need to run rustup self update if Clippy binary is missing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/clippy_dummy/crates-readme.md#2025-04-21_snippet_0\n\nLANGUAGE: terminal\nCODE:\n```\nrustup component add clippy\n```\n\n----------------------------------------\n\nTITLE: Adding Missing Match Arms in Rust\nDESCRIPTION: This assist adds missing clauses to a `match` expression. It generates match arms for all variants of an enum that are not already covered.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        \n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } => ${1:todo!()},\n        Action::Stop => ${2:todo!()},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Rebase on Last N Commits\nDESCRIPTION: Starts an interactive rebase session focused only on the last N commits of the current branch (`HEAD~N`). This is useful for cleaning up or squashing recent 'fixup' commits without affecting older history.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --interactive HEAD~2\n```\n\n----------------------------------------\n\nTITLE: Returning Closures with Lifetime Annotations in Rust\nDESCRIPTION: This snippet illustrates a common lifetime issue encountered when returning closures in Rust. It shows how the absence of explicit lifetime annotations can lead to compilation errors, and provides a corrected version that properly annotates the lifetimes, ensuring that the closure maintains ownership semantics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0482.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0700\nfn foo(\n    x: &mut Vec<i32>\n) -> impl FnMut(&mut Vec<i32>) -> &[i32] { // error!\n    |y| {\n        y.append(x);\n        y\n    }\n}\n```\n```\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn foo<'a>(\n    x: &'a mut Vec<i32>\n) -> impl FnMut(&mut Vec<i32>) -> &[i32] + 'a { // ok!\n    move |y| {\n        y.append(x);\n        y\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Array with Constant Value in Rust\nDESCRIPTION: This snippet provides two correct examples of how to declare an array in Rust using constant values, avoiding the error demonstrated in the previous snippet. The first example uses a literal constant, and the second defines a constant variable to be used as the size of the array.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0435.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet a: [u8; 42]; // ok!\n```\n\nLANGUAGE: Rust\nCODE:\n```\nconst FOO: usize = 42;\nlet a: [u8; FOO]; // ok!\n```\n\n----------------------------------------\n\nTITLE: Introducing a Named Lifetime in Rust\nDESCRIPTION: Demonstrates converting an anonymous lifetime to a named lifetime parameter. This makes the lifetime explicit and enables referencing it within the implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_74\n\nLANGUAGE: rust\nCODE:\n```\nimpl Cursor<'_┃> {\n    fn node(self) -> &SyntaxNode {\n        match self {\n            Cursor::Replace(node) | Cursor::Before(node) => node,\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> Cursor<'a> {\n    fn node(self) -> &SyntaxNode {\n        match self {\n            Cursor::Replace(node) | Cursor::Before(node) => node,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Expressions in Rust\nDESCRIPTION: This snippet demonstrates the preferred usage of Rust's expression-oriented nature by employing a conditional expression to assign a value to a variable, which enhances code readability and conciseness. The alternative method using a mutable variable assignment after an if-else statement is also shown for contrast.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/advice.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// use\nlet x = if y { 1 } else { 0 };\n```\n\nLANGUAGE: rust\nCODE:\n```\n// not\nlet x;\nif y {\n    x = 1;\n} else {\n    x = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Trait Object Example in Rust\nDESCRIPTION: Demonstrates how trait objects enable passing a trait implementor to functions that accept either concrete or dynamic types. This shows the interoperability between static and dynamic polymorphism.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\n----------------------------------------\n\nTITLE: Replace Character with String Literal in Rust\nDESCRIPTION: Converts a character literal to an equivalent string literal. Useful when needing to change type from char to String.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_108\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    find('{');\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    find(\"{\")\n}\n```\n\n----------------------------------------\n\nTITLE: Generating 'as_' Method for Enum Variant in Rust\nDESCRIPTION: This snippet demonstrates how to generate an 'as_' method for an enum variant. It creates an impl block with a method that returns an Option containing a reference to the variant's inner value if it matches.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_48\n\nLANGUAGE: rust\nCODE:\n```\nenum Value {\n Number(i32),\n Text(String),\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Value {\n Number(i32),\n Text(String),\n}\n\nimpl Value {\n    fn as_text(&self) -> Option<&String> {\n        if let Self::Text(v) = self {\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a target specification - Rust\nDESCRIPTION: This command outputs the JSON specification for an existing target, which can be modified and saved for new target creation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustc -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json\n```\n\n----------------------------------------\n\nTITLE: Rust Test Framework Attribute Example\nDESCRIPTION: Example of the #[bench] attribute used for benchmarking functions in Rust's test framework. This feature is currently unstable and only available on nightly channel.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/tests/index.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[bench]\n```\n\n----------------------------------------\n\nTITLE: Initializing Vector with Type Inference in Rust\nDESCRIPTION: Demonstrates automatic type inference for a vector where the type is inferred based on the first pushed element\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut things = vec![];\n    things.push(\"thing\");\n}\n```\n\n----------------------------------------\n\nTITLE: Error Output with Customized Components\nDESCRIPTION: Shows the compiler error output when using a #[rustc_on_unimplemented] attribute with customized message, label, and note components.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: message\n  --> <anon>:14:5\n   |\n14 |     iterate_chars(&[1, 2, 3][..]);\n   |     ^^^^^^^^^^^^^ label\n   |\n   = note: note\n   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n   = note: required by `iterate_chars`\n```\n\n----------------------------------------\n\nTITLE: Valid Mutable and Immutable Borrows in Rust\nDESCRIPTION: This example shows valid borrowing scenarios in Rust.  First, it demonstrates a single mutable borrow. Second, it shows multiple immutable borrows being allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0499.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Unifying Lifetimes in Rust\nDESCRIPTION: This snippet shows an alternative solution by removing the separate lifetime 'b and using a single lifetime 'a for both input and output values. It simplifies the function signature, ensuring the values have a consistent lifetime, thus preventing the previous mismatches.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0495.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n    match (&t,) { // ok!\n        ((u,),) => u,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Type Inference in Async Rust Functions\nDESCRIPTION: This code snippet demonstrates the correct way to use generic async functions by explicitly specifying the type for the generic parameter. By binding T to a concrete type (String in this case), the compiler can construct the coroutine.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0698.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn bar<T>() -> () {}\n\nasync fn foo() {\n    bar::<String>().await;\n    //   ^^^^^^^^ specify type explicitly\n}\n```\n\n----------------------------------------\n\nTITLE: Using If-Let Statement Inside Rust Loop\nDESCRIPTION: Another corrected version that uses an if-let statement inside the loop body. This approach allows executing code only when the pattern matches, silently skipping non-matching items (None values in this case).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0297.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\nfor item in xs {\n    if let Some(x) = item {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation in Rust with Multiple Methods\nDESCRIPTION: This example demonstrates the correct way to implement a trait with multiple methods. Both methods 'a' and 'b' are defined in the trait 'Foo' and implemented for the struct 'Bar'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0407.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Clippy Lint Documentation in Rust\nDESCRIPTION: A template for documenting a Clippy lint with a structured format that explains what the lint does, why the detected pattern is problematic, and provides examples of both code that triggers the lint and improved alternatives.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_clippy_lint! {\n    /// ### What it does\n    /// Checks for ... (describe what the lint matches).\n    ///\n    /// ### Why is this bad?\n    /// Supply the reason for linting the code.\n    ///\n    /// ### Example\n    ///\n    /// ```rust,ignore\n    /// // A short example of code that triggers the lint\n    /// ```\n    ///\n    /// Use instead:\n    /// ```rust,ignore\n    /// // A short example of improved code that doesn't trigger the lint\n    /// ```\n    #[clippy::version = \"1.29.0\"]\n    pub FOO_FUNCTIONS,\n    pedantic,\n    \"function named `foo`, which is not a descriptive name\"\n}\n```\n\n----------------------------------------\n\nTITLE: Force Frame Pointers in Rust\nDESCRIPTION: Forces the use of frame pointers. Takes `y`, `yes`, `on`, `true` (force-enable) or `n`, `no`, `off`, `false` (do not force). The default behaviour, if frame pointers are not force-enabled, depends on the target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions Workflow for Rust Clippy Checks\nDESCRIPTION: A GitHub Actions workflow configuration that runs Clippy linting on a Rust project. It sets RUSTFLAGS to fail on warnings, runs on the ubuntu-latest environment, and executes Clippy against all targets and features when code is pushed to the repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/continuous_integration/github_actions.md#2025-04-21_snippet_0\n\nLANGUAGE: yml\nCODE:\n```\non: push\nname: Clippy check\n\n# Make sure CI fails on all warnings, including Clippy lints\nenv:\n  RUSTFLAGS: \"-Dwarnings\"\n\njobs:\n  clippy_check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Run Clippy\n        run: cargo clippy --all-targets --all-features\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Cargo in Rust (bash)\nDESCRIPTION: This snippet demonstrates how to execute the entire test suite for the rust-analyzer project using Cargo. It assumes Rust and Cargo are installed and available in the system PATH. The 'cargo test' command compiles and runs all tests in the current workspace, reporting results in the terminal. No additional parameters are required; all code and test discovery is handled automatically by Cargo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo test\n\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Using CoerceUnsized for Custom Smart Pointers in Rust\nDESCRIPTION: This code snippet shows the proper way to enable conversion from sized to unsized types for custom smart pointers using the CoerceUnsized trait. It defines a generic struct MyType with an unsized field and implements CoerceUnsized to allow DST coercion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0328.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\n\nuse std::ops::CoerceUnsized;\n\npub struct MyType<T: ?Sized> {\n    field_with_unsized_type: T,\n}\n\nimpl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n    where T: CoerceUnsized<U> {}\n```\n\n----------------------------------------\n\nTITLE: Building Specific Documentation - Bash\nDESCRIPTION: This snippet shows how to build documentation for specific components or books within the Rust documentation. It allows customization by specifying target documentation paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/compiler-documenting.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./x doc src/doc/book\n```\n\nLANGUAGE: bash\nCODE:\n```\n./x doc src/doc/nomicon\n```\n\nLANGUAGE: bash\nCODE:\n```\n./x doc compiler library\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_LOG environment variable to filter function calls by arguments with regex\nDESCRIPTION: This bash command sets the `RUSTC_LOG` environment variable to enable tracing for the `do_mir_borrowck` function, but only when the `id` argument matches the provided regular expression. This allows filtering function calls based on their arguments for more targeted debugging.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_LOG=[do_mir_borrowck{id=\\.\\*from_utf8_unchecked\\.\\*}]\n```\n\n----------------------------------------\n\nTITLE: Explicit ABI - True\nDESCRIPTION: Demonstrates the default behavior of printing the ABI for extern items when `force_explicit_abi` is set to `true`. The \"C\" ABI is explicitly printed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" {\n    pub static lorem: c_int;\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting control flow to a function with incorrect parameter count in Rust\nDESCRIPTION: This example shows how CFI prevents calling a function that has a different number of parameters than expected at the call site. The code attempts to call a two-parameter function through a function pointer type that expects one parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn add_two(x: i32, _y: i32) -> i32 {\n    x + 2\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n\n    println!(\"With CFI enabled, you should not see the next answer\");\n    let f: fn(i32) -> i32 =\n        unsafe { mem::transmute::<*const u8, fn(i32) -> i32>(add_two as *const u8) };\n    let next_answer = do_twice(f, 5);\n\n    println!(\"The next answer is: {}\", next_answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Native Static Libraries\nDESCRIPTION: Shows how to get linker flags for static libraries using rustc's --print flag with native-static-libs option.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print native-static-libs --crate-type staticlib a.rs\nnote: Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n\nnote: native-static-libs: -lgcc_s -lutil [REDACTED] -lpthread -lm -ldl -lc\n```\n\n----------------------------------------\n\nTITLE: Declaring a New Clippy Lint with Documentation in Rust\nDESCRIPTION: Example of declaring a new lint named 'FOO_FUNCTIONS' using the declare_clippy_lint macro. Includes documentation format, version information, and lint level setting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_clippy_lint! {\n    /// ### What it does\n    ///\n    /// ### Why is this bad?\n    ///\n    /// ### Example\n    /// ```rust\n    /// // example code\n    /// ```\n    #[clippy::version = \"1.29.0\"]\n    pub FOO_FUNCTIONS,\n    pedantic,\n    \"function named `foo`, which is not a descriptive name\"\n}\n```\n\n----------------------------------------\n\nTITLE: Testing AVR Firmware with SimAVR\nDESCRIPTION: Command for emulating AVR firmware using SimAVR emulator, specifically for ATmega328p microcontroller\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/avr-none.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ simavr -m atmega328p ./target/avr-none/release/your-project.elf\n```\n\n----------------------------------------\n\nTITLE: Implementing SIMD Hello World - Rust\nDESCRIPTION: This Rust code snippet demonstrates a basic example of SIMD operations using the Portable SIMD API. It initializes two SIMD vectors and performs an addition operation. The feature 'portable_simd' is required, so users must compile with the nightly version of Rust. The program outputs the result of adding the vectors when executed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/README.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(portable_simd)]\nuse std::simd::f32x4;\nfn main() {\n    let a = f32x4::splat(10.0);\n    let b = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n    println!(\"{:?}\", a + b);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation with Associated Const in Rust\nDESCRIPTION: This example shows a trait that properly defines an associated const 'N' and its implementation. When the trait defines 'const N', the implementation must match with 'const N' (rather than a type or method).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0323.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Trait Object Declaration in Rust\nDESCRIPTION: Shows the correct way to declare a trait object by specifying at least one trait. In this example, the Copy trait is used to create a valid trait object declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0224.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo = dyn 'static + Copy;\n```\n\n----------------------------------------\n\nTITLE: Correct Usage with Regular let Binding in Rust\nDESCRIPTION: This example shows the correct approach to handling irrefutable patterns in Rust. Since the pattern will always match, a regular `let` binding is used instead of an `if let` statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0162.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\nlet Irrefutable(x) = irr;\nprintln!(\"{}\", x);\n```\n\n----------------------------------------\n\nTITLE: Failing Generic Debug Trait Example in Rust\nDESCRIPTION: Example showing a compile error when using an unbounded generic type T that doesn't specify the Debug trait requirement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0277.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Foreign Trait for Local Type (Rust)\nDESCRIPTION: This code snippet shows a correct way to implement a foreign trait (Drop) for a locally defined type (Foo). It also demonstrates implementing From trait with a local type as a type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0117.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Lifetime Usage in Rust Function\nDESCRIPTION: Fixed version of the function that correctly matches the input and output lifetimes by using the same lifetime parameter 'a instead of 'static.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0312.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n    if maybestr.is_none() {\n        \"(none)\"\n    } else {\n        let s: &'a str = maybestr.as_ref().unwrap();\n        s  // Ok!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Self Type in Rust Trait Implementation\nDESCRIPTION: This example shows how to explicitly specify the implementing type (Foo) as the receiver type when implementing a trait method. This is equivalent to using &self when Self refers to Foo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0307.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# struct Foo;\n# trait Trait {\n#     fn foo(&self);\n# }\nimpl Trait for Foo {\n    fn foo(self: &Foo) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Analyzer Server using Cargo\nDESCRIPTION: Command to install the rust-analyzer language server locally, targeting VS Code Insiders with debug info level 2 in release mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/setup.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Install only the language server  \ncargo xtask install --server \\\n    --code-bin code-insiders \\\n    --dev-rel  # Build in release mode with debug info level 2  \n```\n\n----------------------------------------\n\nTITLE: Declaring an Edition-Specific Lint in Rust\nDESCRIPTION: This code snippet shows how to declare a lint that changes its default level in a specific edition. The lint starts as 'Allow' and becomes 'Warn' in the 2024 edition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/guides/editions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub SOME_LINT_NAME,\n    Allow,\n    \"my lint description\",\n    @edition Edition2024 => Warn;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Trait Implementation with Explicit Type Parameters in Rust\nDESCRIPTION: This code snippet shows the correct way to implement generic traits with impl Trait by explicitly defining named generic parameters. It demonstrates how to properly use impl Trait with nested generic arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0666.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyGenericTrait<T> {}\ntrait MyInnerTrait {}\n\nfn foo<T: MyInnerTrait>(\n    bar: impl MyGenericTrait<T>, // ok!\n) {}\n```\n\n----------------------------------------\n\nTITLE: Fluent Messages for Subdiagnostic Labels\nDESCRIPTION: Corresponding Fluent messages for the 'expected return type' labels defined in the ExpectedReturnTypeLabel enum. These messages are used to generate the actual text for the diagnostic labels.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_5\n\nLANGUAGE: fluent\nCODE:\n```\nhir_analysis_expected_default_return_type = expected `()` because of default return type\n\nhir_analysis_expected_return_type = expected `{$expected}` because of return type\n```\n\n----------------------------------------\n\nTITLE: Fixed Implementation with Generic Lifetime in Rust\nDESCRIPTION: Shows the correct way to implement the trait object with a generic lifetime parameter instead of static lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0772.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'d> dyn Person + 'd {/* ... */}\n\n// This works too, and is more elegant:\n//impl dyn Person + '_ {/* ... */}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Trait with Constant in Rust\nDESCRIPTION: This code example shows the correct way to implement a trait that defines a constant. The implementation provides a constant value that matches the trait's expected constant declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0325.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Type Inference by Annotating the Variable in Rust\nDESCRIPTION: This solution resolves the type inference error by adding a type annotation to the variable declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x: Vec<i32> = Vec::new();\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Standard Library Source with Rustup\nDESCRIPTION: This command adds the Rust standard library source code component using rustup. It's a prerequisite for rust-analyzer to function properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/installation.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ rustup component add rust-src\n```\n\n----------------------------------------\n\nTITLE: Proper Handling of Drop Trait in Rust Structs\nDESCRIPTION: This Rust code provides the correct way to initialize a static variable for structs with fields that implement the Drop trait. It ensures that the initialization is done manually to avoid const-eval restrictions. The static instance FOO is initialized correctly by avoiding arbitrary, non-const-checked code within its context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0493.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum DropType {\n    A,\n}\n\nimpl Drop for DropType {\n    fn drop(&mut self) {}\n}\n\nstruct Foo {\n    field1: DropType,\n}\n\nstatic FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n                                               // by hand.\n```\n\n----------------------------------------\n\nTITLE: Creating Search Index Aliases for Documentation\nDESCRIPTION: This snippet shows how the #[doc(alias = ...)] attribute can be applied to a struct to create alternative names in the search index, improving user accessibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#[doc(alias = \\\"TheAlias\\\")]\\npub struct SomeType;\\n\"\n```\n\n----------------------------------------\n\nTITLE: Valid Implementation with Principal and Auto Traits\nDESCRIPTION: Shows the correct way to implement traits for a dyn object by including a principal trait (non-auto trait) along with auto traits. This pattern works because it follows the rule of having one principal trait with additional auto traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0785.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(auto_traits)]\n\ntrait PrincipalTrait {}\n\nauto trait AutoTrait {}\n\nimpl dyn PrincipalTrait + AutoTrait + Send {}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Safe Trait in Rust\nDESCRIPTION: Shows the correct way to implement a safe trait without the unsafe marker. This is the proper implementation that will compile successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0199.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\ntrait Bar { }\n\nimpl Bar for Foo { } // ok!\n```\n\n----------------------------------------\n\nTITLE: Formatting `impl` blocks with indentation adjustment in Rust\nDESCRIPTION: This snippet explains how Rustfmt manages indentation when formatting code inside `impl` blocks, especially for function calls with multiple arguments. It covers the calculation of indentation levels, width constraints, and the use of checked subtraction to prevent underflow errors, ensuring proper visual alignment and line breaks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Foo {\n    fn foo(...) {\n        bar(argument_one,\n            baz());\n    }\n}\n\n// Explanation:\n// The formatter adjusts indentation to fit arguments within maximum width constraints.\n// Uses block and visual indentation levels for alignment.\n// The `rewrite` function returns an `Option`, signaling success or failure.\n// When space is insufficient, callers may attempt to reformat with a larger width.\n// Uses `checked_sub` to prevent integer underflow when calculating available space.\n```\n\n----------------------------------------\n\nTITLE: Defining Debug Flags for Enzyme Autodiff in Text\nDESCRIPTION: This snippet outlines the various debug flags that can be used with the `autodiff` feature in Enzyme to print information on type analysis, activity analysis, performance warnings, and LLVM-IR modules at different stages. These flags help understand the behavior and optimization of differentiated functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/flags.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPrintTA // Print TypeAnalysis information\nPrintAA // Print ActivityAnalysis information\nPrint // Print differentiated functions while they are being generated and optimized\nPrintPerf // Print AD related Performance warnings\nPrintModBefore // Print the whole LLVM-IR module directly before running AD\nPrintModAfter // Print the whole LLVM-IR module after running AD, before optimizations\nPrintModFinal // Print the whole LLVM-IR module after running optimizations and AD\nLooseTypes // Risk incorrect derivatives instead of aborting when missing Type Info\n```\n\n----------------------------------------\n\nTITLE: Correcting Lifetime Error in Rust Closure\nDESCRIPTION: This code snippet demonstrates the correct implementation that resolves the lifetime error. By giving the 's' parameter a static lifetime, the closure now satisfies the 'static lifetime constraint required by the i_want_static_closure function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0477.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\n\nstruct MyString<'a> {\n    data: &'a str,\n}\n\nfn i_want_static_closure<F>(a: F)\n    where F: Fn() + 'static {}\n\nfn print_string(s: Mutex<MyString<'static>>) {\n\n    i_want_static_closure(move || {     // ok!\n        println!(\"{}\", s.lock().unwrap().data);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Private Items\nDESCRIPTION: This code snippet demonstrates how to use the `--document-private-items` flag to include non-public items in the generated documentation. By default, rustdoc only documents publicly reachable items, but this flag includes private items (except those marked with `#[doc(hidden)]`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --document-private-items\n```\n\n----------------------------------------\n\nTITLE: Resolution Example 1: Avoid Moving in Rust\nDESCRIPTION: This Rust code snippet resolves the ownership issue by passing `x` by reference to `eat`, avoiding the move. This ensures that `_ref_to_val` can continue to borrow `x` without issue, maintaining the correct order of borrow and reference operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0505.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Salsa Database in Rust\nDESCRIPTION: Definition of a Salsa database struct that combines multiple query groups. This example shows the required attributes, fields, and trait implementations needed to create a functional Salsa database that can be used for incremental computation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n///This attribute specifies which query groups are going to be in the database\n#[salsa::database(InputsStorage, ParserStorage)]\n#[derive(Default)] //optional!\nstruct MyDatabase {\n    ///You also need this one field\n    runtime : salsa::Runtime<MyDatabase>,\n}\n///And this trait has to be implemented\nimpl salsa::Database for MyDatabase {\n    fn salsa_runtime(&self) -> &salsa::Runtime<MyDatabase> {\n        &self.runtime\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Correct Macro Export and Import in Rust\nDESCRIPTION: This code snippet illustrates the proper way to export macros from one crate and import them in another. It shows how to use the #[macro_export] attribute to make macros available for external use, and how to use #[macro_use] to import specific macros or all exported macros.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0466.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// In some_crate:\n#[macro_export]\nmacro_rules! get_tacos {\n    ...\n}\n\n#[macro_export]\nmacro_rules! get_pimientos {\n    ...\n}\n\n// In your crate:\n#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\nextern crate some_crate;               // `get_pimientos` macros from some_crate\n```\n\n----------------------------------------\n\nTITLE: Fixing Temporary Value Dropping by Using Local Variable in Rust\nDESCRIPTION: This code snippet demonstrates how to fix the temporary value dropping issue by introducing a local variable to store the value. This ensures the value lives long enough to be borrowed safely.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0716.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\n----------------------------------------\n\nTITLE: Running Clippy\nDESCRIPTION: Basic command to run Clippy on a project\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo clippy\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Coverage Attribute Usage in Rust\nDESCRIPTION: Example showing how to use the coverage attribute to selectively disable coverage instrumentation for specific functions while maintaining default coverage for others. The example contrasts a normal function with default coverage against one with coverage explicitly disabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coverage-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coverage_attribute)]\n\n// `foo()` will get coverage instrumentation (by default)\nfn foo() {\n  // ...\n}\n\n#[coverage(off)]\nfn bar() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation with Associated Type Override\nDESCRIPTION: Example showing the correct way to implement a trait where both the associated type is overridden and the default method is reimplemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0399.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(associated_type_defaults)]\n\npub trait Foo {\n    type Assoc = u8;\n    fn bar(&self) {}\n}\n\nimpl Foo for i32 {\n    type Assoc = i32;\n    fn bar(&self) {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Local Constants to Associated Constants in Rust\nDESCRIPTION: Moves a local constant defined within a method to an impl's associated constant. This refactoring promotes better code organization and reuse by making the constant accessible from other methods, with all references qualified with Self::.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_86\n\nLANGUAGE: rust\nCODE:\n```\nstruct S;\nimpl S {\n    fn foo() -> usize {\n        /// The answer.\n        const C: usize = 42;\n\n        C * C\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct S;\nimpl S {\n    /// The answer.\n    const C: usize = 42;\n\n    fn foo() -> usize {\n        Self::C * Self::C\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Correct Trait Implementation in Rust\nDESCRIPTION: This code snippet shows the correct way to implement the trait method. The implementation matches the trait's method signature by including the `&self` parameter, resolving the compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0186.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo(&self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo(&self) {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Example of a Freestanding UEFI Application - Rust\nDESCRIPTION: This Rust code snippet provides a simple example of a valid UEFI application that does nothing upon execution except return an exit code of 0. It includes a panic handler to manage panic situations safely.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#![no_main]\n#![no_std]\n\n#[panic_handler]\nfn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n    loop {}\n}\n\n#[export_name = \"efi_main\"]\npub extern \"C\" fn main(_h: *mut core::ffi::c_void, _st: *mut core::ffi::c_void) -> usize {\n    0\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Closure Borrowing by Sequencing in Rust\nDESCRIPTION: This snippet shows how to fix the closure borrowing issue by restructuring the order of operations. After using the borrowed reference for printing, the closure `starks` is defined, thus preventing simultaneous borrows. This demonstrates how to manage variable lifetimes effectively in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0500.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    println!(\"{}\", nights_watch);\n    let starks = || {\n        *jon_snow = 3;\n    };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing iOS Targets via Rustup\nDESCRIPTION: Commands to install tier 2 iOS targets using rustup package manager. These commands add support for building to ARM64 iOS devices and both ARM64/x86_64 simulators.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-ios.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustup target add aarch64-apple-ios\n$ rustup target add aarch64-apple-ios-sim\n$ rustup target add x86_64-apple-ios\n```\n\n----------------------------------------\n\nTITLE: Emitting Diagnostic Error in Rust\nDESCRIPTION: This Rust example demonstrates creating and emitting a diagnostic error using a defined diagnostic struct. It shows instantiating the diagnostic struct with relevant information, including field names and spans, and passing it to the context's error emission method. Dependencies encompass the diagnostic context and structs adhering to `Diagnostic`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntcx.dcx().emit_err(FieldAlreadyDeclared {\\n    field_name: f.ident,\\n    span: f.span,\\n    prev_span,\\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Pattern Matching\nDESCRIPTION: Proper enum pattern matching example using qualified variant names with the enum type prefix.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0170.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Method {\n    GET,\n    POST,\n}\n\nlet m = Method::GET;\n\nmatch m {\n    Method::GET => {},\n    Method::POST => {},\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating impl Trait in Return Position\nDESCRIPTION: This snippet shows how `impl Trait` can be used in a return position to hide the concrete type while specifying trait bounds. It returns a value implementing the `Debug` trait without revealing its actual type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/type-alias-impl-trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Debug;\n\nfn new() -> impl Debug {\n    42\n}\n\nfn main() {\n    let thing = new();\n    // What actually is a `thing`?\n    // No idea but we know it implements `Debug`, so we can debug print it\n    println!(\"{thing:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[repr(transparent)] in Rust Documentation\nDESCRIPTION: Details the usage of the `#[repr(transparent)]` attribute to document transparent representations in Rust. It outlines how visibility affects the documentation output and considerations for using `cfg_attr`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/advanced-features.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"#[cfg_attr(not(doc), repr(transparent))]\"\n```\n\n----------------------------------------\n\nTITLE: Applying Changes to Analysis in Rust\nDESCRIPTION: This code snippet illustrates the application of changes to the AnalysisHost component. It captures the mechanism through which changes to the analysis state are made, facilitating transitions from an initial state to one that reflects recent modifications provided through the apply_change method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Applying changes to the analyzer\nanalysis_host.apply_change(change);\n```\n\n----------------------------------------\n\nTITLE: Checking for Trait Implementation as a Diagnostic Item in Rust\nDESCRIPTION: This snippet illustrates how to verify if a given `DefId` belongs to a trait implementation defined by a diagnostic item, utilizing the `TyCtxt::is_diagnostic_item()` method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-items.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// This example checks if a given [`DefId`] from a method is part of a trait\n/// implementation defined by a diagnostic item.\nfn is_diag_trait_item(\n    cx: &LateContext<'_>,\n    def_id: DefId,\n    diag_item: Symbol\n) -> bool {\n    if let Some(trait_did) = cx.tcx.trait_of_item(def_id) {\n        return cx.tcx.is_diagnostic_item(diag_item, trait_did);\n    }\n    false\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition Formatting in Rust\nDESCRIPTION: Illustrates the preferred formatting for function definitions in Rust, including spacing, ordering of keywords, and handling of long signatures. This aims to improve readability and searchability of function definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"[pub] [unsafe] [extern [\\\"ABI\\\"]] fn foo(arg1: i32, arg2: i32) -> i32 {\n    ...\n}\"\n```\n\n----------------------------------------\n\nTITLE: Resolving Associated Type Ambiguity in Rust\nDESCRIPTION: This example demonstrates the correct way to resolve the ambiguous associated type reference by using explicit path specification with the syntax '<Self as Bar>::A'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0221.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait T1 {}\ntrait T2 {}\n\ntrait Foo {\n    type A: T1;\n}\n\ntrait Bar : Foo {\n    type A: T2;\n    fn do_something() {\n        let _: <Self as Bar>::A;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving E0689 Error by Specifying Numeric Types in Rust\nDESCRIPTION: This code snippet demonstrates correct ways to resolve the E0689 error by explicitly specifying the numeric type. It shows three different methods: using a type suffix, type annotation, and type casting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0689.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Lifetime Bounds in Rust Traits\nDESCRIPTION: This code snippet shows an example that triggers the E0227 compiler error due to ambiguous lifetime bounds in trait definitions and struct implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0227.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<'foo>: 'foo {}\ntrait Bar<'bar>: 'bar {}\n\ntrait FooBar<'foo, 'bar>: Foo<'foo> + Bar<'bar> {}\n\nstruct Baz<'foo, 'bar> {\n    baz: dyn FooBar<'foo, 'bar>,\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Implementation of Foreign Trait in Rust\nDESCRIPTION: This code snippet demonstrates an invalid implementation of a foreign trait for a generic type parameter, violating Rust's orphan rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0210.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate foo;\nuse foo::ForeignTrait;\n\nimpl<T> ForeignTrait for T { } // error\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Valid Async Move Closure Implementation\nDESCRIPTION: Shows the correct way to implement an async closure using move semantics, which is currently supported in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0708.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let add_one = async move |num: u8| { // ok!\n        num + 1\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Getter Method in Rust\nDESCRIPTION: This snippet demonstrates how to generate a getter method for a struct field. It creates an impl block with a method that returns a reference to the field value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_56\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n\nimpl Person {\n    fn name(&self) -> &str {\n        &self.name\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting an Implementation to a Trait Implementation in Rust\nDESCRIPTION: Demonstrates transforming a regular struct implementation into a trait implementation with the same functionality. The example shows how to maintain constants, functions, and macro invocations while creating a new trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_64\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<const N: usize>([i32; N]);\n\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => {\n        const CONST: $t = $v;\n    };\n}\n\nimpl<const N: usize> Fo┃o<N> {\n    // Used as an associated constant.\n    const CONST_ASSOC: usize = N * 4;\n\n    fn create() -> Option<()> {\n        Some(())\n    }\n\n    const_maker! {i32, 7}\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<const N: usize>([i32; N]);\n\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => {\n        const CONST: $t = $v;\n    };\n}\n\ntrait ${0:NewTrait}<const N: usize> {\n    // Used as an associated constant.\n    const CONST_ASSOC: usize = N * 4;\n\n    fn create() -> Option<()>;\n\n    const_maker! {i32, 7}\n}\n\nimpl<const N: usize> ${0:NewTrait}<N> for Foo<N> {\n    // Used as an associated constant.\n    const CONST_ASSOC: usize = N * 4;\n\n    fn create() -> Option<()> {\n        Some(())\n    }\n\n    const_maker! {i32, 7}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bevy Tool Lints in Rust\nDESCRIPTION: Shows how to register and configure lint levels for the Bevy game engine tool using register_tool feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/register-tool.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(register_tool)]\n#![register_tool(bevy)]\n#![deny(bevy::duplicate_bevy_dependencies)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust for ESP-IDF Project\nDESCRIPTION: This TOML configuration file sets up a Rust project targeting the ESP-IDF framework. It specifies the target architecture using a variable `$ARCH` and employs `ldproxy` as the linker. The configuration leverages the `build-std` feature to build the Rust standard library and handles panic behavior using `panic_abort`. Dependencies include having `ldproxy` installed from crates.io and utilizing the `esp-idf-sys` crate for compiling ESP-IDF and managing toolchains. It supports cross-compilation and propagates necessary build outputs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/esp-idf.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"$ARCH-esp-espidf\"]\n\n[target.$ARCH-esp-espidf]\nlinker = \"ldproxy\"\n\n[unstable]\nbuild-std = [\"std\", \"panic_abort\"]\n```\n\n----------------------------------------\n\nTITLE: Running CI Jobs Locally with Python Script\nDESCRIPTION: Uses a Python helper script to replicate CI behavior locally for running specific Rust test jobs in Docker containers. The script attempts to match CI conditions as closely as possible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/docker.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 src/ci/github-actions/ci.py run-local <job-name>\n# For example:\npython3 src/ci/github-actions/ci.py run-local dist-x86_64-linux-alt\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Memory with MemorySanitizer in Rust\nDESCRIPTION: This Rust snippet demonstrates how to detect the use of uninitialized memory by leveraging the MemorySanitizer tool. Using the `std::mem::MaybeUninit` API, an uninitialized array is created and then read unsafely, triggering sanitizer detection. The example requires instrumenting all program code and dependencies with `-Zsanitizer=memory` and `-Zbuild-std` for correct operation. Expected output includes a warning about uninitialized reads. This snippet is useful to detect potential undefined behavior caused by uninitialized memory usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem::MaybeUninit;\n\nfn main() {\n    unsafe {\n        let a = MaybeUninit::<[usize; 4]>::uninit();\n        let a = a.assume_init();\n        println!(\"{}\", a[2]);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using no_sanitize Attribute in Rust\nDESCRIPTION: Demonstrates how to use the no_sanitize attribute to disable address sanitizer instrumentation for a function. The example shows the basic syntax for applying the attribute to a function declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/no-sanitize.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(no_sanitize)]\n\n#[no_sanitize(address)]\nfn foo() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of #[rustc_on_unimplemented] Attribute in Rust\nDESCRIPTION: Demonstrates how to add a custom error message to a trait using the #[rustc_on_unimplemented] attribute. The example creates a custom iterator trait with a specialized error message that references the trait's generic type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n\n#[rustc_on_unimplemented=\"an iterator over elements of type `{A}` \\\n    cannot be built from a collection of type `{Self}`\"]\ntrait MyIterator<A> {\n    fn next(&mut self) -> A;\n}\n\nfn iterate_chars<I: MyIterator<char>>(i: I) {\n    // ...\n}\n\nfn main() {\n    iterate_chars(&[1, 2, 3][..]);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if Expression Calls Specific Method in Rustc Lint - Rust\nDESCRIPTION: Illustrates how to determine if a given expression in the linting context is a method call to a specific method, identified by name. It matches on the expression's kind to detect method calls and compares the method name string. Additional checks, such as examining the type of the self argument, can be added as needed. This snippet requires Rustc HIR (`hir::ExprKind`) and linting context (`LateContext`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx> LateLintPass<'tcx> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n        // Check our expr is calling a method\n        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &expr.kind\n            // Check the name of this method is `some_method`\n            && path.ident.name.as_str() == \"some_method\"\n            // Optionally, check the type of the self argument.\n            // - See \"Checking for a specific type\"\n        {\n                // ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rust Project\nDESCRIPTION: This shell snippet illustrates creating a new Rust project called 'hello_fuchsia' using cargo, the Rust package manager. It initializes a new directory with Cargo.toml and a basic src/main.rs file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo new hello_fuchsia\ncd hello_fuchsia\n```\n\n----------------------------------------\n\nTITLE: Normalizing Import Statements in Rust\nDESCRIPTION: Reorganizes and normalizes import statements by flattening nested import groups and sorting them alphabetically. This refactoring improves code readability and maintainability by enforcing a consistent import style.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_91\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{io, {fmt::Formatter}};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{fmt::Formatter, io};\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Rust Functions\nDESCRIPTION: Shows the preferred way of handling errors in Rust functions, using 'return Err(err)' for early returns to allow the compiler to flag dead code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn f() -> Result<(), ()> {\n    if condition {\n        return Err(());\n    }\n    Ok(())\n}\n\n// BAD\nfn f() -> Result<(), ()> {\n    if condition {\n        Err(())?;\n    }\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Aliases in Rust\nDESCRIPTION: This code snippet demonstrates the usage of the `trait_alias` feature in Rust. It shows how to create trait aliases, use them as bounds on type parameters, and as trait objects. The example includes creating aliases for multiple traits, including auto-traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/trait-alias.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(trait_alias)]\n\ntrait Foo = std::fmt::Debug + Send;\ntrait Bar = Foo + Sync;\n\n// Use trait alias as bound on type parameter.\nfn foo<T: Foo>(v: &T) {\n    println!(\"{:?}\", v);\n}\n\npub fn main() {\n    foo(&1);\n\n    // Use trait alias for trait objects.\n    let a: &Bar = &123;\n    println!(\"{:?}\", a);\n    let b = Box::new(456) as Box<dyn Foo>;\n    println!(\"{:?}\", b);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Deref Implementation in Rust\nDESCRIPTION: This snippet demonstrates how to generate a Deref implementation for a struct using a given field. It creates the necessary impl block with the correct Target type and deref method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_44\n\nLANGUAGE: rust\nCODE:\n```\nstruct A;\nstruct B {\n   a: A\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct A;\nstruct B {\n   a: A\n}\n\nimpl core::ops::Deref for B {\n    type Target = A;\n\n    fn deref(&self) -> &Self::Target {\n        &self.a\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Accessing Existing Struct Field in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to access a field in a struct in Rust. The code defines a struct StructWithFields with a single field x and then correctly accesses this field using s.x. This example contrasts with the previous one by showing how to properly access existing fields, avoiding the E0609 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0609.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Using Type Placeholders with Generic Functions in Rust\nDESCRIPTION: This snippet demonstrates how to use type placeholders (the _ symbol) to allow the compiler to infer some type arguments while explicitly specifying others. Without placeholders, providing too few type arguments results in an E0107 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0089.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T, U>(x: T) {}\n\nfn main() {\n    let x: bool = true;\n    foo::<f64>(x);    // error: wrong number of type arguments:\n                      //        expected 2, found 1\n    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Break Statement with Loop Label\nDESCRIPTION: Proper implementation showing how to break from a labeled loop by specifying the loop's label in the break statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0695.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n'l: loop {\n    'a: {\n        break 'l;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Variable to Closure Parameter - Rust\nDESCRIPTION: This snippet addresses the mutable borrowing issue by passing the mutable variable as a parameter to the closure. This demonstrates an effective approach to avoid borrowing conflicts while maintaining mutable access.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0501.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    let mut bar = |s: &mut i32| {\n        inside_closure(s)\n    };\n    outside_closure(a);\n    bar(a);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Error Demonstration: Moving Borrowed Value in Rust\nDESCRIPTION: This Rust code snippet illustrates an error (E0505) where a value is moved out while it is still borrowed. The function `eat` takes ownership of `x`, but this move is invalid as `x` has an outstanding borrow `_ref_to_val`. The snippet demonstrates the incorrect order of operations leading to a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0505.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[compile_fail,E0505]\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closure Mutability Errors in Rust\nDESCRIPTION: This code snippet shows examples of errors that occur when trying to mutate or mutably reference data captured immutably by a closure. It includes a function 'foo' that accepts an Fn closure, and two erroneous functions 'mutable' and 'mut_addr' that attempt to modify captured variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0387.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Accepts a function or a closure that captures its environment immutably.\n// Closures passed to foo will not be able to mutate their closed-over state.\nfn foo<F: Fn()>(f: F) { }\n\n// Attempts to mutate closed-over data. Error message reads:\n// `cannot assign to data in a captured outer variable...`\nfn mutable() {\n    let mut x = 0u32;\n    foo(|| x = 2);\n}\n\n// Attempts to take a mutable reference to closed-over data. Error message\n// reads: `cannot borrow data mutably in a captured outer variable...`\nfn mut_addr() {\n    let mut x = 0u32;\n    foo(|| { let y = &mut x; });\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Implementing the Copy Trait in Rust\nDESCRIPTION: This code demonstrates a third fix for E0507: implementing the `Copy` trait for the type. When a type is `Copy`, it is copied instead of moved, which avoids the error. This approach is suitable for small, simple types that can be easily copied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Checking Lifetime Bound Violation in Rust\nDESCRIPTION: This code snippet demonstrates an example of Rust code that triggers a compile-time error due to a lifetime bound not being satisfied. It defines a trait and a struct where the lifetimes are incorrectly specified, leading to an error message indicating that the explicit lifetime must outlive all superbounds from the trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0478.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must\n// outlive all the superbounds from the trait (`'kiss`, in this example).\n\ntrait Wedding<'t>: 't { }\n\nstruct Prince<'kiss, 'SnowWhite> {\n    child: Box<Wedding<'kiss> + 'SnowWhite>,\n    // error: lifetime bound not satisfied\n}\n```\n\n----------------------------------------\n\nTITLE: Using Helper Variables for Complex Conditions in Rust\nDESCRIPTION: Shows how to use helper variables to improve code readability, especially for multiline conditions. This approach makes debugging easier and improves code clarity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nlet rustfmt_not_installed =\n    captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n\nmatch output.status.code() {\n    Some(1) if !rustfmt_not_installed => Ok(None),\n    _ => Err(format_err!(\"rustfmt failed:\\n{}\", captured_stderr)),\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Borrowed Variables in Closures using Rust\nDESCRIPTION: The snippet demonstrates a scenario where a borrowed variable cannot be moved into a closure due to Rust's ownership rules. It suggests using references instead of moving borrowed variables directly to avoid compilation errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0504.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        println!(\"child function: {}\", fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\"main function: {}\", fancy_ref.num);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Using rustdoc\nDESCRIPTION: This snippet illustrates how to run rustdoc on a Rust source file to generate documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Fixed Example with Required 'issue' Field in Stability Attributes\nDESCRIPTION: This code example shows the correct way to use stability attributes by including the required 'issue' field. Both #[unstable] and #[rustc_const_unstable] attributes properly include the 'issue' parameter, fixing the E0547 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0547.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[unstable(feature = \"_unstable_fn\", issue = \"none\")] // ok!\nfn _unstable_fn() {}\n\n#[rustc_const_unstable(\n    feature = \"_unstable_const_fn\",\n    issue = \"none\"\n)] // ok!\nconst fn _unstable_const_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Module Import Example in Rust\nDESCRIPTION: Demonstrates how to properly import and use items from other modules using the 'use' statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0425.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Documentation Text in Rust\nDESCRIPTION: This snippet shows the basic usage of the #[doc] attribute alongside the /// syntactic sugar to create documentation comments. It demonstrates how both forms can be effectively used to annotate code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n/// This is a doc comment.\\n#[doc = r\\\" This is a doc comment.\\\"]\\n# fn f() {}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Assembly Options Using Bitflags\nDESCRIPTION: Bitflags enum for configuring inline assembly options, providing fine-grained control over assembly behavior such as purity, memory access, and syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/asm.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nbitflags::bitflags! {\n    pub struct InlineAsmOptions: u16 {\n        const PURE = 1 << 0;\n        const NOMEM = 1 << 1;\n        const READONLY = 1 << 2;\n        const PRESERVES_FLAGS = 1 << 3;\n        const NORETURN = 1 << 4;\n        const NOSTACK = 1 << 5;\n        const ATT_SYNTAX = 1 << 6;\n        const RAW = 1 << 7;\n        const MAY_UNWIND = 1 << 8;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing and Denying Clippy Lints in Code\nDESCRIPTION: This snippet provides examples of how to use attributes in Rust code to control Clippy lints. It includes options for allowing, warning, or denying lints at different scopes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/configuration.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(clippy::all)]\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(clippy::all, clippy::pedantic)]\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![deny(clippy::single_match, clippy::box_vec)]\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(...)]\n```\n\n----------------------------------------\n\nTITLE: Configuring proc-macro support in vim-lsp\nDESCRIPTION: This Vim script snippet registers the `rust-analyzer` binary and configures the LSP client to enable proc-macro support.  It defines initialization options to enable cargo build scripts and proc macro processing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_7\n\nLANGUAGE: Vim Script\nCODE:\n```\nif executable('rust-analyzer')\n  au User lsp_setup call lsp#register_server({\n        \\   'name': 'Rust Language Server',\n        \\   'cmd': {server_info->['rust-analyzer']},\n        \\   'whitelist': ['rust'],\n        \\   'initialization_options': {\n        \\     'cargo': {\n        \\       'buildScripts': {\n        \\         'enable': v:true,\n        \\       },\n        \\     },\n        \\     'procMacro': {\n        \\       'enable': v:true,\n        \\     },\n        \\   },\n        \\ })\nendif\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Representation Attributes in Rust Structs\nDESCRIPTION: This example shows how to use different representation attributes by applying them to separate structs. The `repr(C)` is applied to the inner struct, while `repr(transparent)` is used on the wrapper struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0692.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nstruct Foo {\n    x: i32,\n    // ...\n}\n\n#[repr(transparent)]\nstruct FooWrapper(Foo);\n```\n\n----------------------------------------\n\nTITLE: Using Cell for Interior Mutability in Rust Closures\nDESCRIPTION: This code snippet shows an alternative solution to the closure mutability problem using the Cell type from the standard library. It allows for interior mutability through a shared reference, enabling the closure to modify the captured value without requiring a mutable borrow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0387.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\nfn foo<F: Fn()>(f: F) { }\n\nfn mutable() {\n    let x = Cell::new(0u32);\n    foo(|| x.set(2));\n}\n```\n\n----------------------------------------\n\nTITLE: Using mem::transmute for SIMD Type Casting in Rust\nDESCRIPTION: This snippet explains how to use the mem::transmute function to cast SIMD types safely while highlighting that i32x4 can be treated as an array of four i32s. It emphasizes the pitfalls of alignment when dealing with SIMD types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/beginners-guide.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ni32x4_value = unsafe { std::mem::transmute::<[i32; 4], i32x4>(array_value) };\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation in Rust\nDESCRIPTION: This code snippet demonstrates the correct implementation of the Foo trait for the Bar struct, properly defining the constant N and the method M.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0324.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n\n    fn M();\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0;\n\n    fn M() {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Configuration Entry to Clippy Lint in Rust\nDESCRIPTION: Example of adding a new configuration entry to the Clippy configuration system, including the proper documentation format that will be automatically included in the lint documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n/// Lint: LINT_NAME.\n///\n/// <The configuration field doc comment>\n(configuration_ident: Type = DefaultValue),\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for wasm64-unknown-unknown Target\nDESCRIPTION: This snippet configures the Rust build process to include the wasm64-unknown-unknown target and enables the use of the LLVM linker (lld). It specifies the target in the bootstrap.toml file under the build and rust sections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm64-unknown-unknown.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\n    target = [\"wasm64-unknown-unknown\"]\n\n[rust]\n    lld = true\n```\n\n----------------------------------------\n\nTITLE: Desugared impl Trait Return Type in Rust\nDESCRIPTION: Shows the explicit form of impl Trait return type using type aliases with lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/member_constraints.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype MakeReturn<'x, 'y> = impl Trait<'x, 'y>;\nfn make(a: &'a u32, b: &'b u32) -> MakeReturn<'a, 'b> { .. }\n```\n\n----------------------------------------\n\nTITLE: Using a Salsa Database in a Rust Application\nDESCRIPTION: Example showing how to use a Salsa database in a Rust application. This demonstrates creating the database, setting input values, and repeatedly calling queries that will automatically reuse previous results when possible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let db = MyDatabase::default();\n    db.set_manifest(...);\n    db.set_source_text(...);\n    loop {\n        db.ast(...); //will reuse results\n        db.set_source_text(...);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Server-Side LSP Debug Logging (bash)\nDESCRIPTION: This snippet sets the RA_LOG environment variable at runtime to increase log verbosity from the LSP server before launching VS Code. The example triggers debug-level logging for the lsp_server module in rust-analyzer. This approach requires the server binary to respond to RA_LOG and, optionally, for VS Code instance to be launched from the terminal for log output to be captured. Useful for diagnosing protocol-level or communication issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nenv RA_LOG=lsp_server=debug code .\n\n```\n\n----------------------------------------\n\nTITLE: Correcting E0384 Error Using Mutable Variable in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to allow variable reassignment by declaring the variable as mutable using the 'mut' keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0384.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = 3;\n    x = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Explicit Lifetime Declarations in Rust Function Types\nDESCRIPTION: This code snippet demonstrates the correct way to declare lifetimes explicitly using `<...>` binders in `fn` and `Fn` syntax. These examples show valid Rust code for using lifetimes in function types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0687.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(x: fn(&'a u32)) {} // ok!\n\nfn bar<'a>(x: &Fn(&'a u32)) {} // ok!\n\nfn baz<'a>(x: fn(&'a u32), y: &'a u32) {} // ok!\n\nstruct Foo<'a> { x: &'a u32 }\n\nimpl<'a> Foo<'a> {\n    fn bar(&self, x: fn(&'a u32)) {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Compiler Sysroot\nDESCRIPTION: Shows how to obtain the absolute path to the Rust compiler's sysroot directory using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print sysroot a.rs\n/home/[REDACTED]/.rustup/toolchains/stable-x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Configuring Cranelift Codegen Backend in Cargo Config\nDESCRIPTION: Configuration for enabling the Cranelift codegen backend by adding settings to the .cargo/config.toml file. This enables the unstable codegen-backend feature and sets Cranelift as the backend for the dev profile.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\ncodegen-backend = true\n\n[profile.dev]\ncodegen-backend = \"cranelift\"\n```\n\n----------------------------------------\n\nTITLE: Type_of Query Flow\nDESCRIPTION: Mermaid flowchart depicting the process flow of the type_of query when resolving opaque types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    TypeOf[\"type_of query\"]\n    TypeOf -- find_opaque_ty_constraints --> FindOpaqueTyConstraints\n    FindOpaqueTyConstraints --> Iterate\n    Iterate[\"Iterate over each item in defining scope\"]\n    Iterate -- For each item --> TypeCheck\n    TypeCheck[\"Check typeck(I) to see if it constraints O\"]\n    TypeCheck -- I does not\\nconstrain O --> Iterate\n    TypeCheck -- I constrains O --> BorrowCheck\n    BorrowCheck[\"Invoke mir_borrowck(I) to get hidden type\\nfor O computed by I\"]\n    BorrowCheck --> PreviousType\n    PreviousType[\"Hidden type from I\\nsame as any previous hidden type\\nfound so far?\"]\n    PreviousType -- Yes --> Complete\n    PreviousType -- No --> ReportError\n    ReportError[\"Report an error\"]\n    ReportError --> Complete[\"Item I complete\"]\n    Complete --> Iterate\n\n    FindOpaqueTyConstraints -- All constraints found --> Done\n    Done[\"Done\"]\n```\n\n----------------------------------------\n\nTITLE: Running Fuchsia UI Tests\nDESCRIPTION: Shell command for running the UI test suite on Fuchsia with necessary compiler and linker flags\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_24\n\nLANGUAGE: sh\nCODE:\n```\n( \\\n    source config-env.sh &&                                                   \\\n    ./x.py                                                                    \\\n    --config bootstrap.toml                                                      \\\n    --stage=2                                                                 \\\n    test tests/ui                                                             \\\n    --target x86_64-unknown-fuchsia                                           \\\n    --run=always                                                              \\\n    --test-args --target-rustcflags                                           \\\n    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/sysroot/lib             \\\n    --test-args --target-rustcflags                                           \\\n    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/lib                     \\\n    --test-args --target-rustcflags                                           \\\n    --test-args -Clink-arg=--undefined-version                                \\\n    --test-args --remote-test-client                                          \\\n    --test-args src/ci/docker/scripts/fuchsia-test-runner.py                  \\\n)\n```\n\n----------------------------------------\n\nTITLE: User Type Annotation Example in Rust\nDESCRIPTION: This Rust snippet illustrates the potential issue of erasing lifetimes in user-defined types during MIR type-checking. It ensures that the user-defined type is maintained correctly to avoid incorrect type inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/type_check.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(x: &'a u32) {\n    let y: &'static u32 = x;\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the Rust Repository (Full Clone)\nDESCRIPTION: This snippet demonstrates how to clone the Rust source code repository using git. This command retrieves the complete repository history and is essential for developers who want full access to the project's commit history.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/rust-lang/rust.git\ncd rust\n```\n\n----------------------------------------\n\nTITLE: Configuring LanguageClient-neovim for Rust\nDESCRIPTION: This snippet configures LanguageClient-neovim to use rust-analyzer as the language server for Rust files.  It sets the `g:LanguageClient_serverCommands` variable to associate the `rust` filetype with the `rust-analyzer` command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_3\n\nLANGUAGE: Vim Script\nCODE:\n```\nlet g:LanguageClient_serverCommands = {\n\\ 'rust': ['rust-analyzer'],\n\\ }\n```\n\n----------------------------------------\n\nTITLE: Addressing Type Mismatch in Closure Arguments - Rust\nDESCRIPTION: This snippet illustrates an error caused by a type mismatch in closure arguments, where a function expects a closure with an `i32` argument, but receives one with a `&str` argument instead. The corrected version demonstrates the closure being aligned with the expected `i32` type. Ensure that the types align with the function's requirements or are inferable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0631.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: &str| {});\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: i32| {});\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Character Literal Definition\nDESCRIPTION: Demonstrates the proper syntax for defining a character literal with correct quote placement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0762.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstatic C: char = '●'; // ok!\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation Without Extra Constants\nDESCRIPTION: Shows the correct way to implement the trait 'Foo' for i32 by removing the unauthorized associated constant. This implementation will compile successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0438.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nimpl Foo for i32 {}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Missing Method in Rust\nDESCRIPTION: This code snippet demonstrates how to resolve the Rust compiler error E0599 by implementing the missing `chocolate` method for the `Mouth` struct.  By implementing the method within an `impl` block for `Mouth`, the method becomes available for instances of the `Mouth` struct. The corrected code allows the `chocolate` method to be called without error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0599.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Multi-line Function Signature Formatting in Rust\nDESCRIPTION: Demonstrates how to format function signatures that exceed a single line in Rust. It includes breaking after the opening parenthesis, placing each argument on a new line with block indentation, and including a trailing comma on the last argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(\n    arg1: i32,\n    arg2: i32,\n) -> i32 {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation with Explicit Lifetime Bindings\nDESCRIPTION: This code shows the corrected implementation by explicitly binding lifetimes in the trait definition and implementation. The solution adds a lifetime parameter to the trait and ensures proper lifetime annotations throughout the implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0803.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Modified trait with explicit lifetime binding\ntrait DataAccess<'a, T> {\n    fn get_ref(&'a self) -> T;\n}\n\nstruct Container<'a> {\n    value: &'a f64,\n}\n\n// Correct implementation (bound lifetimes)\nimpl<'a> DataAccess<'a, &'a f64> for Container<'a> {\n    fn get_ref(&'a self) -> &'a f64 {\n        self.value\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Assignment to a Mutable Variable in Rust\nDESCRIPTION: A correct implementation showing how to use the += operator by first declaring a mutable variable that can be assigned to.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0067.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x: i8 = 12;\nx += 1; // ok!\n```\n\n----------------------------------------\n\nTITLE: Defining a Private Constant in Rust\nDESCRIPTION: This snippet demonstrates defining a private constant within a Rust module. The constant cannot be accessed outside of its module scope, showcasing the concept of visibility in Rust modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0603.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\n----------------------------------------\n\nTITLE: Correcting Meta-Item Usage in Rust Deprecated Attribute\nDESCRIPTION: This code example demonstrates the correct way to use the deprecated attribute by properly formatting the 'note' meta-item as a key-value pair, which resolves the E0539 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0551.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[deprecated(note = \"because\")] // ok!\nfn i_am_deprecated() {}\n```\n\n----------------------------------------\n\nTITLE: Valid Rust Lint Attribute Examples\nDESCRIPTION: Examples showing correct syntax for lint attributes, demonstrating both single and multiple lint suppressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0452.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(foo)] // ok!\n// or:\n#![allow(foo, foo2)] // ok!\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of impl Trait in Variable Declaration in Rust\nDESCRIPTION: This example demonstrates the improper use of `impl Trait` syntax in a variable declaration, which causes a compilation error E0562. The `impl Trait` syntax is only allowed in function and inherent method return types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0562.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n    // error: `impl Trait` not allowed outside of function and inherent method\n    //        return types\n    for i in count_to_ten {\n        println!(\"{}\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Name Conflicts with Rustdoc Links\nDESCRIPTION: In this snippet, a potential name conflict between a struct and a function is demonstrated. It shows how to disambiguate between different Rust namespaces using intra-doc links with added context such as prefixes and parentheses.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n/// See also: [`Foo`](struct@Foo)\nstruct Bar;\n\n/// This is different from [`Foo`](fn@Foo)\nstruct Foo {}\n\nfn Foo() {}\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote (HTTPS) in Git\nDESCRIPTION: Adds a remote named 'upstream' pointing to the official rust-lang/rust repository using the HTTPS protocol. This allows fetching updates directly from the main repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit remote add upstream https://github.com/rust-lang/rust.git\n```\n\n----------------------------------------\n\nTITLE: Scoping Solution for Rust Private Item Use\nDESCRIPTION: This snippet provides a solution by limiting the scope of a private method to its module and creating a public function to call the method. This method ensures that private methods are called only within their defined scope, leveraging a public function as an intermediary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0624.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n\n    pub fn call_method(foo: &Foo) { // We create a public function.\n        foo.method(); // Which calls the item.\n    }\n}\n\nlet foo = inner::Foo;\ninner::call_method(&foo); // And since the function is public, we can call the\n                          // method through it.\n```\n\n----------------------------------------\n\nTITLE: Fixing Mutability Error by Making Container Mutable in Rust\nDESCRIPTION: This snippet demonstrates how to fix the mutability error by making the Box container mutable, allowing mutation of the contained data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0386.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x: i64 = 1;\nlet mut y: Box<_> = Box::new(&mut x);\n**y = 2;\n```\n\n----------------------------------------\n\nTITLE: Trait Return Types with Anonymous Lifetime\nDESCRIPTION: Implementation using anonymous lifetime bounds ('_) to derive lifetimes from function arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0759.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::Debug;\nfn foo(x: &i32) -> impl Debug + '_ {\n    x\n}\nfn bar(x: &i32) -> Box<dyn Debug + '_> {\n    Box::new(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a New Provider to the Providers Struct in Rust Compiler\nDESCRIPTION: Demonstrates how to extend the provide() function to include a new query provider. This example adds a 'fubar' query provider to the existing providers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn provide(providers: &mut Providers) {\n    *providers = Providers {\n        type_of,\n        fubar,\n        ..*providers\n    };\n}\n\nfn fubar<'tcx>(tcx: TyCtxt<'tcx>, key: DefId) -> Fubar<'tcx> { ... }\n```\n\n----------------------------------------\n\nTITLE: Checking if a Type Defines a Specific Method in Rustc Lint Impl Item - Rust\nDESCRIPTION: Illustrates checking that a type implementation defines a method with a specific name (`some_method`) during the `check_impl_item` lint pass. It checks the item kind is a function, method signature includes an implicit self parameter, and optionally verifies the method's return type (e.g., returns `String`). This uses Clippy utilities such as `is_type_lang_item` and `return_ty`. The snippet demonstrates detailed inspection of impl items within Rustc internals.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::ty::is_type_lang_item;\nuse clippy_utils::{sym, return_ty};\n\nimpl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n        // Check if item is a method/function\n        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind\n            // Check the method is named `some_method`\n            //\n            // Add `some_method` to `clippy_utils::sym` if it's not already there\n            && impl_item.ident.name == sym::some_method\n            // We can also check it has a parameter `self`\n            && signature.decl.implicit_self.has_implicit_self()\n            // We can go further and even check if its return type is `String`\n            && is_type_lang_item(cx, return_ty(cx, impl_item.hir_id), LangItem::String)\n        {\n            // ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Individual Tests\nDESCRIPTION: Commands to run individual tests, either by specifying a file path or using test arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n./x test compiler/rustc_data_structures/src/thin_vec/tests.rs\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui --test-args issue-1234\n```\n\n----------------------------------------\n\nTITLE: Method Chain Formatting Examples in Rust\nDESCRIPTION: Examples of properly formatted method chains in Rust, showing various scenarios including try operators, indentation rules, and how to handle multi-line expressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nx.baz?\n    .qux()\n\nx.y.z\n    .qux()\n\nlet foo = x\n    .baz?\n    .qux();\n\nfoo(\n    expr1,\n    expr2,\n).baz?\n    .qux();\n```\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer on Linux using curl and gunzip\nDESCRIPTION: This snippet shows how to download, decompress, and install the rust-analyzer binary into ~/.local/bin on a Linux system. It uses curl to download the gzipped binary, gunzip to decompress it, and chmod to make it executable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/rust_analyzer_binary.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p ~/.local/bin\n$ curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - > ~/.local/bin/rust-analyzer\n$ chmod +x ~/.local/bin/rust-analyzer\n```\n\n----------------------------------------\n\nTITLE: Checking MSRV Before Running Lint Logic - Rust\nDESCRIPTION: Demonstrates the runtime check to ensure the lint only executes when the configured MSRV meets the feature's required version. If the MSRV is below STR_STRIP_PREFIX, the lint logic is skipped with a return. Inputs are the static msrv, the lint context (cx), and the constant, typically from msrv_aliases. Use when writing lints reliant on Rust versioned features. Requires the Msrv::meets method and configured msrv field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nif !self.msrv.meets(cx, msrvs::STR_STRIP_PREFIX) {\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Getters with Borrowing\nDESCRIPTION: This code snippet demonstrates the correct implementation of getters for the `Person` struct using borrowed references, ensuring that field invariants are respected while avoiding unnecessary cloning.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    // Invariant: never empty\n    first_name: String,\n    middle_name: Option<String>\n}\n\n// GOOD\nimpl Person {\n    fn first_name(&self) -> &str { self.first_name.as_str() }\n    fn middle_name(&self) -> Option<&str> { self.middle_name.as_ref() }\n}\n\n// BAD\nimpl Person {\n    fn first_name(&self) -> String { self.first_name.clone() }\n    fn middle_name(&self) -> &Option<String> { &self.middle_name }\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Checking Generic Function - Rust\nDESCRIPTION: This snippet modifies the previous example to create a generic function `foo<T: Eq<T>>()`, demonstrating the type-checking process for generic types in Rust with logical rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Eq<T>>() { bar::<T>() }\nfn bar<U: Eq<U>>() { }\n```\n\n----------------------------------------\n\nTITLE: Declaring Edition-Gated Lints\nDESCRIPTION: This Rust code snippet demonstrates how to declare a lint that changes behavior based on the Rust edition. The `ANONYMOUS_PARAMETERS` lint is set to allow-by-default in the 2015 edition and warn-by-default in the 2018 edition using the `declare_lint!` macro. This technique requires knowledge of Rust editions and lint macros.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub ANONYMOUS_PARAMETERS,\n    Allow,\n    \"detects anonymous parameters\",\n    Edition::Edition2018 => Warn,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Encodable and Decodable for a Custom Struct\nDESCRIPTION: Example implementation of the Encodable and Decodable traits for a custom struct, showing how manual implementations handle serialization of fields. This pattern is typically automated using derive macros in the actual compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/serialization.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_private)]\nextern crate rustc_serialize;\nuse rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n\nstruct MyStruct {\n    int: u32,\n    float: f32,\n}\n\nimpl<E: Encoder> Encodable<E> for MyStruct {\n    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n        s.emit_struct(\"MyStruct\", 2, |s| {\n            s.emit_struct_field(\"int\", 0, |s| self.int.encode(s))?;\n            s.emit_struct_field(\"float\", 1, |s| self.float.encode(s))\n        })\n    }\n}\n\nimpl<D: Decoder> Decodable<D> for MyStruct {\n    fn decode(s: &mut D) -> Result<MyStruct, D::Error> {\n        s.read_struct(\"MyStruct\", 2, |d| {\n            let int = d.read_struct_field(\"int\", 0, Decodable::decode)?;\n            let float = d.read_struct_field(\"float\", 1, Decodable::decode)?;\n\n            Ok(MyStruct { int, float })\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Function with \"rust-call\" ABI in Rust\nDESCRIPTION: This snippet demonstrates how to use the `unboxed_closures` feature to create a function with the \"rust-call\" ABI. The function `add_args` takes a tuple of two u32 values as its single argument and returns their sum.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unboxed-closures.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unboxed_closures)]\n\nextern \"rust-call\" fn add_args(args: (u32, u32)) -> u32 {\n    args.0 + args.1\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Copying Generic Parameters for Inner Type\nDESCRIPTION: Solution showing how to properly define generic parameters for inner type definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Fix Using Reference Assignment in Rust\nDESCRIPTION: This snippet shows an alternative way to fix the issue by directly assigning the reference to a variable. In this case, the compiler extends the lifetime of the temporary until the end of the enclosing block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0716.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Implementation with Missing Lifetime Links\nDESCRIPTION: This code demonstrates an error when implementing a trait that returns a reference without explicitly linking the lifetime to 'self'. The compiler cannot verify if the returned reference satisfies lifetime constraints, resulting in E0803.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0803.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait DataAccess<T> {\n    fn get_ref(&self) -> T;\n}\n\nstruct Container<'a> {\n    value: &'a f64,\n}\n\n// Attempting to implement reference return\nimpl<'a> DataAccess<&f64> for Container<'a> {\n    fn get_ref(&self) -> &f64 { // Error: Lifetime mismatch\n        self.value\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin Usage Example Causing Error\nDESCRIPTION: Shows how attempting to use a plugin compiled as rlib results in a compiler error. The plugin must be available in dylib format to work correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0457.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(plugin)]\n#![plugin(rlib_plugin)] // error: plugin `rlib_plugin` only found in rlib\n                        //        format, but must be available in dylib\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Where Predicates in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for where predicates. Each predicate is indented as a block with the 'where' keyword on its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<Ipsum, Dolor, Sit, Amet>() -> T\nwhere\n    Ipsum: Eq,\n    Dolor: Eq,\n    Sit: Eq,\n    Amet: Eq,\n{\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Using assert! Macros for Doctests in Rust\nDESCRIPTION: This code snippet shows how to use the assert_eq! macro within a doctest in Rust. The purpose is to illustrate that some computation gives a certain result. The testing environment ensures that if the computation deviates from expectations, the code will panic and the test will fail.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet foo = \"foo\";\nassert_eq!(foo, \"foo\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Trusty Targets with Rustc in TOML\nDESCRIPTION: This TOML configuration snippet demonstrates how to set up Trusty targets for compilation using rustc. It specifies the build stage and the target architectures 'aarch64' and 'armv7' for the Trusty operating system. It is used to enable building for Trusty within the Rust compiler build system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/trusty.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"aarch64-unknown-trusty\", \"armv7-unknown-trusty\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Type Check Crate Query Provider in Rust Compiler\nDESCRIPTION: Example of a query provider implementation for the type_check_crate query, showing how it accesses input data from the HIR map and invokes other queries like type_check_item for each item in the crate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/query-evaluation-model-in-detail.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn type_check_crate_provider(tcx, _key: ()) {\n    let list_of_hir_items = tcx.hir_map.list_of_items();\n\n    for item_def_id in list_of_hir_items {\n        tcx.type_check_item(item_def_id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Contributing Documentation Links in Markdown\nDESCRIPTION: Reference links section in markdown format defining important URLs for Rust project documentation, communication channels, and bug reporting resources.\nSOURCE: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n[std-dev-guide]: https://std-dev-guide.rust-lang.org/\n[contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n[issue template]: https://github.com/rust-lang/rust/issues/new/choose\n[internals]: https://internals.rust-lang.org\n[rust-discord]: http://discord.gg/rust-lang\n[rust-zulip]: https://rust-lang.zulipchat.com\n```\n\n----------------------------------------\n\nTITLE: Using doc_masked Attribute in Rust\nDESCRIPTION: Demonstrates how to use the `#[doc(masked)]` attribute on an `extern crate` statement to mark a crate as masked, preventing its types from appearing in documentation lists.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/doc-masked.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[doc(masked)]\\nextern crate some_crate;\n```\n\n----------------------------------------\n\nTITLE: Error Example: Using Undeclared External Crate\nDESCRIPTION: Shows the error when trying to use a module from an external crate that hasn't been properly added as a dependency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0433.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Parameter Environment\nDESCRIPTION: Example of a function with a parameter environment containing trait bounds and constraints on associated types\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Trait>() \nwhere\n    <T as Trait>::Assoc: Clone,\n{}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Resolving Lifetime Shadowing in Rust\nDESCRIPTION: This code demonstrates how to resolve the lifetime shadowing error.  By renaming the lifetime parameter in the `f` function to `'b`, we avoid shadowing the lifetime `'a` defined at the `impl` level, allowing the code to compile successfully. The lifetime `'b` is independent and distinct from `'a`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0496.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nstruct Foo<'a> {\n    a: &'a i32,\n}\n\nimpl<'a> Foo<'a> {\n    fn f<'b>(x: &'b i32) { // ok!\n    }\n}\n\nfn main() {\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Resolving External Crate Naming Conflict in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to import external crates without naming conflicts. It uses a different alias for the 'std' crate to avoid collision with the 'core' crate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0259.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core;\nextern crate std as other_name;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Expanding Record Rest Pattern in Rust\nDESCRIPTION: Replaces rest pattern (..) in record patterns with explicit field bindings. Makes pattern matching more explicit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_42\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar { y: Y, z: Z }\n\nfn foo(bar: Bar) {\n    let Bar { .. } = bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cargo Features for Conditional Compilation in TOML\nDESCRIPTION: Example of defining features in Cargo.toml that automatically declare corresponding cfgs. This shows how to express conditional compilation and optional dependencies that Cargo will handle automatically.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg/cargo-specifics.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[features]\nserde = [\"dep:serde\"]\nmy_feature = []\n```\n\n----------------------------------------\n\nTITLE: Trait Definition with Multiple Implementations\nDESCRIPTION: Illustrates complex trait implementation scenario with overlapping impl blocks for Get trait, demonstrating trait resolution challenges and ambiguity handling\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/resolution.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Get {\n    fn get(&self) -> Self;\n}\n\nimpl<T: Copy> Get for T {\n    fn get(&self) -> T {\n        *self\n    }\n}\n\nimpl<T: Get> Get for Box<T> {\n    fn get(&self) -> Box<T> {\n        Box::new(<T>::get(self))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Public Function in Rust\nDESCRIPTION: Example showing how to define a simple public function in a Rust library file. This function serves as a documented item that Rustdoc will look for usage examples of in other source files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/scrape-examples-help.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// src/lib.rs\npub fn a_func() {}\n```\n\n----------------------------------------\n\nTITLE: Fixing Static Methods with Self: Sized in Rust\nDESCRIPTION: Shows how to make a trait with static methods dyn-compatible by making the static methods only available on concrete types using the `where Self: Sized` bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Imports with merge_imports Option in Rust\nDESCRIPTION: Shows the difference in import formatting when merge_imports is set to false (default) vs true.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_55\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::{a, c, d};\nuse foo::{b, g};\nuse foo::{e, f};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::{a, b, c, d, e, f, g};\n```\n\n----------------------------------------\n\nTITLE: Direct Namespace Import in Rust\nDESCRIPTION: Shows how to import a namespace directly without using the 'self' keyword when only the namespace is needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0429.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Enforcing Lifetime Constraints in Rust\nDESCRIPTION: This solution involves amending the function by specifying that the lifetime 'a must live at least as long as 'b, thereby aligning with Rust's borrow checker requirements. It ensures the safe usage of references throughout the function's execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0495.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n    match (&t,) { // ok!\n        ((u,),) => u,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Trait Object Declaration With dyn Keyword\nDESCRIPTION: Corrected example showing proper trait object declaration using the 'dyn' keyword, which is required in Rust 2021 edition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0782.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\nfn test(arg: Box<dyn Foo>) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Generating a Trait Implementation Template for a Struct in Rust\nDESCRIPTION: Shows the generation of a new trait implementation skeleton for a struct with generic type parameters. The assist creates an empty implementation block with proper generic constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_65\n\nLANGUAGE: rust\nCODE:\n```\nstruct ┃Ctx<T: Clone> {\n    data: T,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ctx<T: Clone> {\n    data: T,\n}\n\nimpl<T: Clone> ${1:_} for Ctx<T> {┃}\n```\n\n----------------------------------------\n\nTITLE: Correcting E0412 Error with Proper Imports in Rust Modules\nDESCRIPTION: This snippet demonstrates how to correct the E0412 error from the previous example by either importing the File type from the parent scope or re-importing it directly in the child module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0412.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n\n----------------------------------------\n\nTITLE: Cloning Values in Rust\nDESCRIPTION: This snippet shows how to create a duplicate of a value in Rust using the clone() method. It demonstrates cloning a string and how modifications to the clone do not affect the original value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0382.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating with for_each in Rust\nDESCRIPTION: Demonstrates the use of the for_each method on an iterator in Rust to print each value multiplied by two. No external dependencies are required.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = vec![1, 2, 3];\n    x.into_iter().for_each(|v| {\n        let y = v * 2;\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Borrow Lifetime in Rust with Scoped Blocks\nDESCRIPTION: This example demonstrates how to limit the lifetime of a borrow using a scoped block. By releasing the borrow before the closure, the value can be moved without conflicts with borrowed references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0504.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"main function: {}\", fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\"child function: {}\", fancy_num.num);\n    };\n\n    x();\n}\n```\n\n----------------------------------------\n\nTITLE: Generating From Implementation for Enum in Rust\nDESCRIPTION: This snippet demonstrates how to add a From implementation for an enum variant with one tuple field. It creates an impl block that converts the field type into the enum variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_54\n\nLANGUAGE: rust\nCODE:\n```\nenum A { One(u32) }\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum A { One(u32) }\n\nimpl From<u32> for A {\n    fn from(v: u32) -> Self {\n        Self::One(v)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of #[derive] Attribute in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to use the #[derive] attribute in Rust. It shows how to properly derive the Clone trait for a struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0777.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone)] // ok!\nstruct Foo;\n```\n\n----------------------------------------\n\nTITLE: Interactive Rebase for Conflict Resolution or Cleanup\nDESCRIPTION: Initiates an interactive rebase session against the master branch. This allows advanced control over individual commits being rebased, including skipping, editing, reordering, or squashing them. Useful for complex conflict resolution or significant history rewriting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --interactive master\n```\n\n----------------------------------------\n\nTITLE: Avoiding Single-Use Helper Functions in Rust\nDESCRIPTION: Shows the recommendation to avoid creating single-use helper functions in Rust, instead using blocks to delineate logic while maintaining access to context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nlet buf = {\n    let mut buf = get_empty_buf(&mut arena);\n    buf.add_item(item);\n    buf\n};\n\n// BAD\nlet buf = prepare_buf(&mut arena, item);\n\n...\n\nfn prepare_buf(arena: &mut Arena, item: Item) -> ItemBuf {\n    let mut res = get_empty_buf(&mut arena);\n    res.add_item(item);\n    res\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rustfmt on Stable Toolchain\nDESCRIPTION: Commands to install and run Rustfmt using the stable Rust toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustup component add rustfmt\n```\n\nLANGUAGE: sh\nCODE:\n```\ncargo fmt\n```\n\n----------------------------------------\n\nTITLE: Correctly Calling a Function in Rust\nDESCRIPTION: This Rust snippet provides a simple, correct example of how to call a function. It declares a basic function `i_am_a_function` that takes no arguments and returns nothing, and then demonstrates the correct syntax `()` for invoking this function. This contrasts with the erroneous examples provided earlier.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0618.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n\n----------------------------------------\n\nTITLE: Correct Main Function Signature in Rust\nDESCRIPTION: The proper signature for the main function in Rust, which takes no parameters and returns nothing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0211.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main();\n```\n\n----------------------------------------\n\nTITLE: Using bool::then for Conditional Logic in Rust\nDESCRIPTION: Transforms an if-else expression into the bool::then method, streamlining the logic to return Some or None based on the condition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    cond.then(|| val)\n}\n```\n\n----------------------------------------\n\nTITLE: Using unwrap for Error Handling in Rust\nDESCRIPTION: Demonstrates using unwrap() to extract a value from a Result, which will panic if the Result is an Err. In this case, it's trying to read an environment variable and will panic if it's not set.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/error.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Read environment variable, panic if it is not present\nlet path = std::env::var(\"IMPORTANT_PATH\").unwrap();\n```\n\n----------------------------------------\n\nTITLE: Splitting Import Statements in Rust\nDESCRIPTION: Demonstrates how to refactor a single combined import statement into separate import statements. This can improve readability and organization of import declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_111\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{Debug, Display};\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{Debug};\nuse std::fmt::Display;\n```\n\n----------------------------------------\n\nTITLE: Reordered Import Example in Rust\nDESCRIPTION: Shows the expected output after applying version-sorting to imports within each group, while maintaining the separation between groups.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nuse c;\nuse d;\n\nuse a;\nuse b;\n```\n\n----------------------------------------\n\nTITLE: Correct documentation comment usage in Rust\nDESCRIPTION: This code snippet shows the proper way to use documentation comments in Rust. Doc comments should be placed immediately before items like structs, functions, or modules to document them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0585.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// I'm documenting the following struct:\nstruct Foo;\n\n/// I'm documenting the following function:\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Declaring Future-Incompatible Lints\nDESCRIPTION: This code declares a future-incompatible lint with the `declare_lint!` macro, indicating compatibility issues in upcoming Rust releases. The `ANONYMOUS_PARAMETERS` lint is defined with a reason field, highlighting why code may fail in future versions. This directs users on proactive fixes for their code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub ANONYMOUS_PARAMETERS,\n    Allow,\n    \"detects anonymous parameters\",\n    @future_incompatible = FutureIncompatibleInfo {\n        reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n        reason: FutureIncompatibilityReason::EditionError(Edition::Edition2018),\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rust function with universal quantification\nDESCRIPTION: Examples of Rust functions demonstrating universal quantification in type checking and trait solving. The code illustrates how generic types and lifetimes are universally quantified, meaning the function must be well-typed for all possible types or lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_4\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo<T>()\n```\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo<'a>(_: &'a usize)\n```\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo<F>()\nwhere for<'a> F: Fn(&'a u8)\n```\n\n----------------------------------------\n\nTITLE: Defining Runnables Interface in TypeScript\nDESCRIPTION: The RunnablesParams interface facilitates requesting runnable items from a language server by identifying the specific document and optionally the position in the document. It's used heavily within language server-client communications in TypeScript, specifically for tools interacting with Rust projects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RunnablesParams {\n    textDocument: TextDocumentIdentifier;\n    position?: Position;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Subdiagnostic Implementation in Rust\nDESCRIPTION: Example of the implementation generated by the #[derive(Subdiagnostic)] macro for the ExpectedReturnTypeLabel enum. It shows how the enum variants are converted into diagnostic labels.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx> Subdiagnostic for ExpectedReturnTypeLabel<'tcx> {\n    fn add_to_diag(self, diag: &mut rustc_errors::Diagnostic) {\n        use rustc_errors::{Applicability, IntoDiagArg};\n        match self {\n            ExpectedReturnTypeLabel::Unit { span } => {\n                diag.span_label(span, rustc_errors::fluent::hir_analysis_expected_default_return_type)\n            }\n            ExpectedReturnTypeLabel::Other { span, expected } => {\n                diag.set_arg(\"expected\", expected);\n                diag.span_label(span, rustc_errors::fluent::hir_analysis_expected_return_type)\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Declaration of Atomic Operation Intrinsic in Rust\nDESCRIPTION: Example of correctly declaring a valid atomic operation intrinsic function in Rust. This uses a recognized intrinsic name that exists in the Rust source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0092.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn atomic_fence_seqcst(); // ok!\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Universal Regions\nDESCRIPTION: Example of a function with lifetime parameters demonstrating potential lifetime inference error\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/lifetime_parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unused Variable 'foo' in Rust REPL Subcommand\nDESCRIPTION: This snippet shows a diagnostic for an unused variable 'foo' in a Rust file. The compiler suggests prefixing it with an underscore to indicate intentional non-use. The diagnostic includes both a warning and a hint for fixing the issue.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_unused_variable_as_info.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfoo\n```\n\n----------------------------------------\n\nTITLE: Generic Transparent Unions in Rust\nDESCRIPTION: Illustrates how to create a generic transparent union that can handle zero-sized types. The union has the same representation as the generic type T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/transparent-unions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(transparent_unions)]\n\n// This union has the same representation as `T`.\n#[repr(transparent)]\npub union GenericUnion<T: Copy> { // Unions with non-`Copy` fields are unstable.\n    pub field: T,\n    pub nothing: (),\n}\n\n// This is okay even though `()` is a zero-sized type.\npub const THIS_IS_OKAY: GenericUnion<()> = GenericUnion { field: () };\n```\n\n----------------------------------------\n\nTITLE: Current Range Pattern Syntax in Rust\nDESCRIPTION: Correct implementation using the ..= syntax for inclusive range patterns in a match expression.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0783.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmatch 2u8 {\n    0..=9 => println!(\"Got a number less than 10\"), // ok!\n    _ => println!(\"Got a number 10 or more\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Attributes to All Doctests\nDESCRIPTION: This snippet showcases the use of #[doc(test(attr(...)))] to apply specific attributes to all doctests, such as denying dead code to maintain code quality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(test(attr(deny(dead_code))))]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Resolving Trait Scope Error in Rust\nDESCRIPTION: This code snippet demonstrates two solutions to resolve the trait scope error: importing the trait or defining it in the current scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0405.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(for_demonstration_only)]\n// solution 1:\nuse some_file::SomeTrait;\n\n// solution 2:\ntrait SomeTrait {\n    // some functions\n}\n\nstruct Foo;\n\nimpl SomeTrait for Foo { // ok!\n    // implements functions\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing check_fn in EarlyLintPass for Lint Emission - Rust\nDESCRIPTION: Implements the EarlyLintPass trait for a custom FooFunctions struct, providing a check_fn method to interact with each function definition in the AST. This basic skeleton serves as a template for further lint logic, granting access to the context, function kind, span, and node identifier. No lint is emitted here; further implementation is needed for actual lint logic. This snippet requires relevant imports and is used within Clippy lint development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl EarlyLintPass for FooFunctions {\n    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n        // TODO: Emit lint here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Move Errors with Drop Trait in Rust\nDESCRIPTION: This snippet illustrates an error that occurs when trying to move a field out of a struct that implements the Drop trait. It shows that the struct cannot be dropped if fields are moved out, leading to an error. The solution involves using references instead of moving the field directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0509.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0509\nstruct FancyNum {\n    num: usize\n}\n\nstruct DropStruct {\n    fancy: FancyNum\n}\n\nimpl Drop for DropStruct {\n    fn drop(&mut self) {\n        // Destruct DropStruct, possibly using FancyNum\n    }\n}\n\nfn main() {\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n    let fancy_field = drop_struct.fancy; // Error E0509\n    println!(\"Fancy: {}\", fancy_field.num);\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Including External File as Documentation\nDESCRIPTION: This snippet demonstrates including an external file (README.md) as documentation using the #[doc] attribute, allowing for easy integration of additional documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#[doc = include_str!(\\\"../../README.md\\\")]\\n# fn f() {}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Command Line Flags for Clippy\nDESCRIPTION: This snippet shows how to enable or disable Clippy lints through command line flags when running Clippy. It provides commands for allowing and warning on specific lints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/configuration.md#2025-04-21_snippet_2\n\nLANGUAGE: terminal\nCODE:\n```\ncargo clippy -- -A clippy::lint_name\n```\n\nLANGUAGE: terminal\nCODE:\n```\ncargo clippy -- -W clippy::lint_name\n```\n\nLANGUAGE: terminal\nCODE:\n```\ncargo clippy -- -W clippy::pedantic\n```\n\nLANGUAGE: terminal\nCODE:\n```\ncargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n```\n\n----------------------------------------\n\nTITLE: Generating Setter Method in Rust\nDESCRIPTION: This snippet demonstrates how to generate a setter method for a struct field. It creates an impl block with a method that takes a new value for the field and updates it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_62\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n\nimpl Person {\n    fn set_name(&mut self, name: String) {\n        self.name = name;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing E0573: Returning an enum type\nDESCRIPTION: This code snippet demonstrates the correct way to return an enum variant. Instead of specifying the variant as the return type, the function should return the entire enum type itself.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0573.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon { // ok!\n    Dragon::Born\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Rust Struct Initialization\nDESCRIPTION: This code snippet demonstrates the correct way to initialize a struct in Rust, specifying each field exactly once.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0062.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Default Trait Derivation for Rust Enum Using #[default] Attribute\nDESCRIPTION: This code snippet shows the correct way to derive the Default trait for a Rust enum when the desired default variant has no payload. The #[default] attribute is used to specify the default variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0665.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Default)]\nenum Food {\n    #[default]\n    Sweet,\n    Salty,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Stability Attributes in Rust\nDESCRIPTION: The code snippets illustrate the definition and correction of stability attributes in Rust. The erroneous example highlights missing 'since' values in stability attributes, which is a required field. The corrected example shows proper usage by adding the 'since' value, which specifies the version since the feature or function is considered stable. This ensures compatibility and clarity in versioning for Rust developers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0542.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(feature = \\\"_stable_fn\\\")] // invalid\\nfn _stable_fn() {}\\n\\n#[rustc_const_stable(feature = \\\"_stable_const_fn\\\")] // invalid\\nconst fn _stable_const_fn() {}\\n\\n#[stable(feature = \\\"_deprecated_fn\\\", since = \\\"0.1.0\\\")]\\n#[deprecated(\\n    note = \\\"explanation for deprecation\\\"\\n)] // invalid\\nfn _deprecated_fn() {}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(feature = \\\"_stable_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nfn _stable_fn() {}\\n\\n#[stable(feature = \\\"_stable_const_fn\\\", since = \\\"1.0.0\\\")]\\n#[rustc_const_stable(feature = \\\"_stable_const_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nconst fn _stable_const_fn() {}\\n\\n#[stable(feature = \\\"_deprecated_fn\\\", since = \\\"0.1.0\\\")]\\n#[deprecated(\\n    since = \\\"1.0.0\\\",\\n    note = \\\"explanation for deprecation\\\"\\n)] // ok!\\nfn _deprecated_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Errors in Rust Structs, Enums, and Type Aliases\nDESCRIPTION: This code snippet showcases various examples of incorrect and correct usage of lifetimes in Rust structs, enums, and type aliases. It highlights common mistakes that lead to the E0106 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0106.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo1 { x: &bool }\n              // ^ expected lifetime parameter\nstruct Foo2<'a> { x: &'a bool } // correct\n\nstruct Bar1 { x: Foo2 }\n              // ^^^^ expected lifetime parameter\nstruct Bar2<'a> { x: Foo2<'a> } // correct\n\nenum Baz1 { A(u8), B(&bool), }\n                  // ^ expected lifetime parameter\nenum Baz2<'a> { A(u8), B(&'a bool), } // correct\n\ntype MyStr1 = &str;\n           // ^ expected lifetime parameter\ntype MyStr2<'a> = &'a str; // correct\n```\n\n----------------------------------------\n\nTITLE: Changing Visibility of Items in Rust\nDESCRIPTION: This assist adds or changes existing visibility specifiers. It allows cycling through different visibility levels for modules, functions, and other items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn frobnicate() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn frobnicate() {}\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Variable Usage Error in Rust\nDESCRIPTION: Demonstrates incorrect code that attempts to use an uninitialized variable, resulting in compilation error E0381. This shows why Rust requires variables to be initialized before use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0381.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly-uninitialized variable\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Placement of Doc Comments in Rust Trait Definition\nDESCRIPTION: This code example demonstrates the proper way to place doc comments in Rust, showing comments properly attached to both a trait definition and a method declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0584.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// I'm THE island!\ntrait Island {\n    /// I'm lost!\n    fn lost();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Config Struct for Multiple Parameters\nDESCRIPTION: This snippet illustrates how to utilize a configuration struct to manage multiple parameters for a function, thus reducing function complexity and improving readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\npub struct AnnotationConfig {\n    pub binary_target: bool,\n    pub annotate_runnables: bool,\n    pub annotate_impls: bool,\n}\n\npub fn annotations(\n    db: &RootDatabase,\n    file_id: FileId,\n    config: AnnotationConfig\n) -> Vec<Annotation> {\n    ...\n}\n\n// BAD\npub fn annotations(\n    db: &RootDatabase,\n    file_id: FileId,\n    binary_target: bool,\n    annotate_runnables: bool,\n    annotate_impls: bool,\n) -> Vec<Annotation> {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rust DefPath Example\nDESCRIPTION: Example of a stable identifier path used to reference items across compilation sessions\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/incremental-compilation-in-detail.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstd::collections::HashMap\n```\n\n----------------------------------------\n\nTITLE: Declaring Feature-Gated Lints\nDESCRIPTION: This Rust snippet shows how to declare a lint that is gated by a feature. The `SOME_LINT_NAME` lint is declared with the `declare_lint!` macro and includes a feature gate definition. Activation of the lint depends on whether the specified feature is enabled, requiring a feature flag configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub SOME_LINT_NAME,\n    Warn,\n    \"a new and useful, but feature gated lint\",\n    @feature_gate = sym::feature_name;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Extending `rustdoc` Styling with Custom CSS (Bash)\nDESCRIPTION: This bash command runs `rustdoc` directly on a Rust source file (`src/lib.rs`), applying additional CSS rules from a specified file (`custom.css`) using the `--extend-css` flag. This allows customization of the generated HTML documentation's appearance beyond the default styles.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nrustdoc --extend-css custom.css src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating a Cyclic Query Provider in Rust Compiler\nDESCRIPTION: Example of an invalid query provider that causes a cycle by invoking itself with the same key, which would result in infinite recursion. The compiler detects and reports such cycles as errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/query-evaluation-model-in-detail.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn cyclic_query_provider(tcx, key) -> u32 {\n  // Invoke the same query with the same key again\n  tcx.cyclic_query(key)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling colored log output with RUSTC_LOG_COLOR\nDESCRIPTION: This bash command demonstrates how to enable colored log output when piping the output of `rustc` to `less`.  It sets the `RUSTC_LOG_COLOR` environment variable to `always` to force colored output, and uses the `-R` switch in `less` to interpret ANSI color codes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# The `-R` switch tells less to print ANSI colors without escaping them.\n$ RUSTC_LOG=debug RUSTC_LOG_COLOR=always rustc +stage1 ... | less -R\n```\n\n----------------------------------------\n\nTITLE: Transforming Conditional Feature-Gated Code for Stabilization\nDESCRIPTION: Examples showing how to modify code that conditionally executes based on feature flag status. When stabilizing, the feature check can be removed as the feature is now always enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nif self.tcx.sess.features.borrow().pub_restricted { /* XXX */ }\n```\n\nLANGUAGE: rust\nCODE:\n```\nif self.tcx.sess.features.borrow().pub_restricted && something { /* XXX */ }\n```\n\n----------------------------------------\n\nTITLE: Installing Rust using rustup\nDESCRIPTION: Command to install Rust using the rustup toolchain manager on Unix-like systems. This is the recommended way to install Rust for most users.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ra-salsa/ra-salsa-macros/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Configuring External Crate Link URLs in Documentation\nDESCRIPTION: This code defines a URL for linking to external crate documentation through #[doc(html_root_url = ...)], aiding in documentation integrity and navigation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(html_root_url = \\\"https://docs.rs/serde/1.0\\\")]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Substitution Instantiation Example\nDESCRIPTION: This example demonstrates the creation of a substitution S which replaces canonical variables with fresh inference variables suitable for solving the canonicalized trait query in a fresh context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nS = [?A, '?B, ?C]\n```\n\n----------------------------------------\n\nTITLE: Creating a static library from C object files\nDESCRIPTION: This snippet demonstrates how to create a static library from a compiled C object file using the `ar` command. The `crus` flags indicate create, replace, update, and symbol table generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n\"ar crus ./libxyz.a ./clib.o\"\n```\n\n----------------------------------------\n\nTITLE: Correct Constant Initialization in Rust\nDESCRIPTION: These code snippets show the correct way to initialize constants in Rust. The first example uses a nested constant declaration, while the second example demonstrates a simpler, direct initialization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0014.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst FOO: i32 = { const X : i32 = 0; X };\n// or even:\nconst FOO2: i32 = { 0 }; // but brackets are useless here\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of offset_of! Macro with Enum Variants in Rust\nDESCRIPTION: This example shows the proper way to use offset_of! with enum variants by specifying a field within the variant. Here, 'Some.0' correctly accesses the contained u8 field inside the Some variant of Option<u8>.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0795.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(offset_of_enum)]\n\nlet x: usize = std::mem::offset_of!(Option<u8>, Some.0);\n```\n\n----------------------------------------\n\nTITLE: Defining a Future Compatibility Lint in Rust\nDESCRIPTION: This code snippet demonstrates how to define a future compatibility lint in the Rust compiler's lint framework. The lint is intended to issue warnings about illegal uses of specific patterns in the codebase. It includes steps to declare the lint, add it to the list of hardwired lints, register it for future compatibility, and report the lint when it triggers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/bug-fix-procedure.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// 1. Define the lint in `compiler/rustc_middle/src/lint/builtin.rs`:\ndeclare_lint! {\n    pub YOUR_ERROR_HERE,\n    Warn,\n    \"illegal use of foo bar baz\"\n}\n\n// 2. Add to the list of HardwiredLints in the same file:\nimpl LintPass for HardwiredLints {\n    fn get_lints(&self) -> LintArray {\n        lint_array!(\n            ..,\n            YOUR_ERROR_HERE\n        )\n    }\n}\n\n// 3. Register the lint in `compiler/rustc_lint/src/lib.rs`:\nstore.register_future_incompatible(sess, vec![\n    ..., \n    FutureIncompatibleInfo {\n        id: LintId::of(YOUR_ERROR_HERE),\n        reference: \"issue #1234\", // your tracking issue here!\n    },\n]);\n\n// 4. Report the lint:\ntcx.lint_node(\n    lint::builtin::YOUR_ERROR_HERE,\n    path_id,\n    binding.span,\n    format!(\"some helper message here\"));\n```\n\n----------------------------------------\n\nTITLE: Adding Explicit Type for Let Bindings in Rust\nDESCRIPTION: This assist specifies the type for a let binding. It infers the type from the assigned value and adds it explicitly to the variable declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 92;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x: i32 = 92;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Pattern Binding in Rust\nDESCRIPTION: Example showing incorrect pattern binding that fails compilation because it uses a refutable pattern (Some) in a let binding, which requires irrefutable patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0005.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(1);\nlet Some(y) = x;\n// error: refutable pattern in local binding: `None` not covered\n```\n\n----------------------------------------\n\nTITLE: Handling Compile Failures due to Dangling References in Rust\nDESCRIPTION: This snippet shows an erroneous function trying to return a reference to a local variable. The reference becomes invalid since the variable is dropped when the function exits. Rust ownership rules prevent this by not allowing functions to return references to local variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0515.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn get_dangling_reference() -> &'static i32 {\n    let x = 0;\n    &x\n}\n```\n\n----------------------------------------\n\nTITLE: Generics Clause Formatting in Rust\nDESCRIPTION: Illustrates the preferred formatting for generics clauses in Rust, including spacing, commas, and line breaking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Display, U: Debug>(x: Vec<T>, y: Vec<U>) ...\n\nimpl<T: Display, U: Debug> SomeType<T, U> { ...\n```\n\n----------------------------------------\n\nTITLE: Corrected Function Pointer Type Definitions\nDESCRIPTION: Shows the correct ways to define function pointer types by removing patterns, using wildcard patterns, or omitting parameter names\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0561.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype A1 = fn(param: u8); // ok!\ntype A2 = fn(_: u32); // ok!\ntype A3 = fn(i16); // ok!\n```\n\n----------------------------------------\n\nTITLE: Inverting an If Statement in Rust\nDESCRIPTION: Demonstrates inverting a negated if condition and swapping its branches. This transformation simplifies the logic by removing the negation and making the code more readable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_76\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if┃ !y { A } else { B }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if y { B } else { A }\n}\n```\n\n----------------------------------------\n\nTITLE: Casting Between Integers and Pointers in Rust\nDESCRIPTION: This code shows how to cast between integers and pointers in Rust. It demonstrates creating a raw pointer from an integer address and casting a pointer back to an integer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet address = 0x012345usize;\nlet r = address as *const i32;\n\nunsafe {\n    println!(\"{:?}\", r);\n}\n\nlet address = r as usize;\nprintln!(\"{:?}\", address);\n```\n\n----------------------------------------\n\nTITLE: Defining Structs with Intra-Doc Links in Rust\nDESCRIPTION: This snippet demonstrates how to define structs in Rust with intra-doc links pointing to the documentation of other items. It highlights different linking syntaxes supported by rustdoc, such as standard markdown links and square brackets for referencing items directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// This struct is not [Bar]\npub struct Foo1;\n\n/// This struct is also not [bar](Bar)\npub struct Foo2;\n\n/// This struct is also not [bar][b]\n///\n/// [b]: Bar\npub struct Foo3;\n\n/// This struct is also not [`Bar`]\npub struct Foo4;\n\n/// This struct *is* [`Bar`]!\npub struct Bar;\n```\n\n----------------------------------------\n\nTITLE: Defining Main Void Vector in Rust\nDESCRIPTION: This Rust function initializes a vector of unit type and sets it to an empty vector. Useful as a placeholder to track types or define empty structures with specific length expectations. Dependencies include the Rust standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x: Vec<()> = vec![];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_BOOTSTRAP environment variable for enabling unstable features\nDESCRIPTION: Examples of different ways to set the RUSTC_BOOTSTRAP environment variable to control unstable feature availability. Options include enabling for all crates, specific crates, or forcing stable behavior on nightly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/rustc-bootstrap.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_BOOTSTRAP=1             # Enable for all crates\nRUSTC_BOOTSTRAP=crate_name    # Enable only for crates named 'crate_name'\nRUSTC_BOOTSTRAP=-1            # Force stable behavior even on nightly\n```\n\n----------------------------------------\n\nTITLE: Rust Function Signature with Early/Late Bound Lifetimes\nDESCRIPTION: Presents a Rust function `foo` with an early-bound lifetime `'a`, a late-bound lifetime `'b`, and a type parameter `T`. The accompanying comment shows a simplified internal representation, illustrating how early-bound regions (`'a/#0`) use `RegionKind::EarlyParam` (implied by the debug format), late-bound regions (`ReLateParam(...)`) use `RegionKind::LateParam`, and type parameters (`T/#2`) use `TyKind::Param` with their assigned index.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/param_ty_const_regions.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// This function would have its signature represented as:\n//\n// ```\n// fn(\n//     T/#2,\n//     Ref('a/#0, Ref(ReLateParam(...), u32))\n// ) -> Ref(ReLateParam(...), u32)\n// ```\nfn foo<'a, 'b, T: 'a>(one: T, two: &'a &'b u32) -> &'b u32 {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Trait Implementation Error in Rust\nDESCRIPTION: This example shows erroneous code that generates the E0046 compiler error. It defines a trait 'Foo' with a required method 'foo()', then attempts to implement it for a struct 'Bar' without implementing the required method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0046.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\n----------------------------------------\n\nTITLE: Inlining Rules Example in Rust\nDESCRIPTION: This code shows how inlining works based on module visibility.  `Public` struct inside `private_module` is re-exported in the public module `public_mod` and then re-exported from the crate root. The first re-export of `Public` will be inlined, the second one will not be inlined because `public_mod` is public.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_module {\n    pub struct Public;\n}\npub mod public_mod {\n    // `Public` will inlined here since `private_module` is private.\n    pub use super::private_module::Public;\n}\n// `Public` will not be inlined here since `public_mod` is public.\npub use self::public_mod::Public;\n```\n```\n\n----------------------------------------\n\nTITLE: Using #[track_caller] Attribute in Rust\nDESCRIPTION: Demonstrates how to use the #[track_caller] attribute on closures and coroutines. This feature allows accessing caller location information through std::panic::Location::caller(), similar to using #[track_caller] on regular functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/closure-track-caller.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[track_caller]\n```\n\n----------------------------------------\n\nTITLE: Fixed Associated Type with Dummy Lifetime Parameter\nDESCRIPTION: Resolves the associated type lifetime issue by introducing a dummy parameter to ensure lifetime usage\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0582.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# trait Foo {\n#     type Assoc<'a>;\n# }\nstruct Bar<X, F>\nwhere\n    X: Foo,\n    F: for<'a> Fn(X::Assoc<'a>, /* dummy */ &'a ()) -> &'a i32\n{\n    x: X,\n    f: F\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Object Declaration with Associated Type\nDESCRIPTION: Example showing the correct way to specify an associated type for a trait object by providing a concrete type using the syntax Trait<Bar=Type>.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0191.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = dyn Trait<Bar=i32>; // ok!\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Test Runner in Rust\nDESCRIPTION: Demonstrates how to implement a custom test runner using the custom_test_frameworks feature. The example shows a simple runner that checks if test case values equal zero, marking them as PASSED or FAILED accordingly. Uses const values as test cases instead of traditional test functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/custom-test-frameworks.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(custom_test_frameworks)]\n#![test_runner(my_runner)]\n\nfn my_runner(tests: &[&i32]) {\n    for t in tests {\n        if **t == 0 {\n            println!(\"PASSED\");\n        } else {\n            println!(\"FAILED\");\n        }\n    }\n}\n\n#[test_case]\nconst WILL_PASS: i32 = 0;\n\n#[test_case]\nconst WILL_FAIL: i32 = 4;\n```\n\n----------------------------------------\n\nTITLE: Avoiding Unnecessary Allocations\nDESCRIPTION: This code provides examples of how to avoid unnecessary allocations by using iterators instead of vectors, leading to more efficient resource management.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nuse itertools::Itertools;\n\nlet (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {\n    Some(it) => it,\n    None => return,\n}\n\n// BAD\nlet words = text.split_ascii_whitespace().collect::<Vec<_>>();\nif words.len() != 2 {\n    return\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Coverage Reports for Test Binaries Using llvm-cov\nDESCRIPTION: This shell script block runs `llvm-cov report` and `llvm-cov show` to generate coverage reports for test binaries, using the previously merged `.profdata` file. It highlights the use of filters and options for color display and specific directory exclusion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ llvm-cov report \\\n    --use-color --ignore-filename-regex='/.cargo/registry' \\\n    --instr-profile=json5format.profdata \\\n    --object target/debug/deps/lib-30768f9c53506dc5 \\\n    --object target/debug/deps/json5format-fececd4653271682\n$ llvm-cov show \\\n    --use-color --ignore-filename-regex='/.cargo/registry' \\\n    --instr-profile=json5format.profdata \\\n    --object target/debug/deps/lib-30768f9c53506dc5 \\\n    --object target/debug/deps/json5format-fececd4653271682 \\\n    --show-instantiations --show-line-counts-or-regions \\\n    --Xdemangler=rustfilt | less -R\n```\n\n----------------------------------------\n\nTITLE: Installing Rustfmt with Rustup for Clippy Development\nDESCRIPTION: Command to install the rustfmt component for the nightly toolchain, which is required for formatting Clippy code before submitting a PR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nrustup component add rustfmt --toolchain=nightly\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Undeclared Lifetimes in Rust\nDESCRIPTION: Example showing incorrect code that fails to declare lifetime parameters in both a function and struct definition. This code will fail to compile with error E0261.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0261.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// error, use of undeclared lifetime name `'a`\nfn foo(x: &'a str) { }\n\nstruct Foo {\n    // error, use of undeclared lifetime name `'a`\n    x: &'a str,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Notes and Snippets to Rust Errors\nDESCRIPTION: This Rust code demonstrates how to add notes and labels to error messages using methods like `.span_label()` and `.span_note()` before calling `.emit()`. It allows for providing more detailed context and guidance to the user regarding the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/error-codes.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nstruct_span_code_err!(...)\n    .span_label(another_span, fluent::example::example_label)\n    .span_note(another_span, fluent::example::separate_note)\n    .emit()\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Self Import Example in Rust\nDESCRIPTION: Demonstrates an erroneous attempt to import self into the current module, which triggers compile error E0431. This is invalid because self imports can only appear in import lists with non-empty prefixes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0431.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse {self}; // error: `self` import can only appear in an import list with a\n            //        non-empty prefix\n```\n\n----------------------------------------\n\nTITLE: Tracing Macro Expansion in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `trace_macros` feature in Rust. It enables macro tracing, prints a simple message using the `println!` macro, and then disables tracing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/trace-macros.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(trace_macros)]\n\nfn main() {\n    trace_macros!(true);\n    println!(\"Hello, Rust!\");\n    trace_macros!(false);\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Unused Variable Warning in Rust\nDESCRIPTION: This snippet represents a compiler warning for an unused variable 'foo' in a Rust file. It suggests prefixing the variable with an underscore to indicate it's intentionally unused.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_unused_variable.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfoo\n```\n\n----------------------------------------\n\nTITLE: Correct Function Declaration and Usage\nDESCRIPTION: Shows the correct way to declare and use a function named Foo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0423.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn Foo() -> u32 { 0 }\n\nlet f = Foo(); // ok!\n```\n\n----------------------------------------\n\nTITLE: Invalid Inherent Implementation Example in Rust\nDESCRIPTION: Demonstrates the incorrect attempt to create an inherent implementation for Vec<u8>, which fails because Vec is defined in the standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0116.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Vec<u8> { } // error\n```\n\n----------------------------------------\n\nTITLE: Configuring Read-Only Patterns for Rust Library Sources in settings.json (JSON)\nDESCRIPTION: This snippet configures the settings.json file in an editor, specifying glob patterns that match Rust library source files to be marked as read-only. Dependencies: An editor that recognizes and implements the 'files.readonlyInclude' setting (such as Visual Studio Code with appropriate extensions). Key parameters include file path glob patterns for the Cargo registry, git checkouts, and official Rust library sources, each mapped to true to indicate read-only status. Inputs are the file path patterns, and the output is native editor enforcement making these files non-editable. Limitation: Only effective in editors that support and honor these settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/editors/code/walkthrough-setup-tips.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"files.readonlyInclude\": {\n  \"**/.cargo/registry/src/**/*.rs\": true,\n  \"**/.cargo/git/checkouts/**/*.rs\": true,\n  \"**/lib/rustlib/src/rust/library/**/*.rs\": true,\n}\n```\n\n----------------------------------------\n\nTITLE: Import Merging Examples in Rust\nDESCRIPTION: Shows the difference between merged and unmerged imports, noting that tools should not automatically merge or unmerge imports by default.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\n// Un-merged\nuse a::b;\nuse a::c::d;\n\n// Merged\nuse a::{b, c::d};\n```\n\n----------------------------------------\n\nTITLE: Invalid Receiver Type in Rust Trait Implementation\nDESCRIPTION: This code fails to compile with error E0307. It shows an attempt to implement a trait for Foo using &Bar as the receiver type, which is invalid because the receiver must be related to the implementing type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0307.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# struct Foo;\n# struct Bar;\n# trait Trait {\n#     fn foo(&self);\n# }\nimpl Trait for Foo {\n    fn foo(self: &Bar) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Correct Full Reinitialization in Rust\nDESCRIPTION: Shows the correct way to reinitialize a structure after it has been dropped by creating a new instance of the structure with all fields initialized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0383.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x);\nx = Foo { a: 2 };\n```\n\n----------------------------------------\n\nTITLE: Resolving Lexical Region Constraints in Rust\nDESCRIPTION: This snippet describes how to resolve lexical region constraints by invoking the `resolve_regions_and_report_errors` method, which finalizes the constraint process and triggers the `lexical_region_resolve` method. It emphasizes the impact of this step on subsequent attempts to equate or create subtyping relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nTo solve **lexical** region constraints, you invoke [`resolve_regions_and_report_errors`].  This \"closes\" the region constraint process and invokes the [`lexical_region_resolve`] code. Once this is done, any further attempt to equate or create a subtyping relationship will yield an ICE.\n```\n\n----------------------------------------\n\nTITLE: Erroneous Associated Item Constraint Usage in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect usage of associated item constraints, leading to a compiler error E0229. The constraint is placed in an unexpected context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0229.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Foo {\n    type A;\n    fn boo(&self) -> <Self as Foo>::A;\n}\n\nstruct Bar;\n\nimpl Foo for isize {\n    type A = usize;\n    fn boo(&self) -> usize { 42 }\n}\n\nfn baz<I>(x: &<I as Foo<A = Bar>>::A) {}\n// error: associated item constraint are not allowed here\n```\n\n----------------------------------------\n\nTITLE: Failed Import Due to Name Conflict\nDESCRIPTION: Shows an error case where attempting to import a trait named 'core' conflicts with an existing extern crate import of the same name, resulting in error E0254.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0254.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core;\n\nmod foo {\n    pub trait core {\n        fn do_something();\n    }\n}\n\nuse foo::core;  // error: an extern crate named `core` has already\n                //        been imported in this module\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Object Usage with Generic Methods in Rust\nDESCRIPTION: Shows why generic method parameters are problematic for trait objects by demonstrating multiple different types being passed to the same generic method, which would require multiple vtable entries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Inference Variables Syntax in Rust Compiler\nDESCRIPTION: Describes the syntax for inference variables used in the Rust compiler. The format is ?{id}, where id identifies the specific inference variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n?x\n```\n\nLANGUAGE: rust\nCODE:\n```\n?0\n```\n\n----------------------------------------\n\nTITLE: Testing with Raw String Literals\nDESCRIPTION: Demonstrates the preferred way to write tests using unindented raw string literals for multiline fixtures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    #[test]\n    fn inline_field_shorthand() {\n        check_assist(\n            inline_local_variable,\n            r#\"\nstruct S { foo: i32}\nfn main() {\n    let $0foo = 92;\n    S { foo }\n}\n\"#,\n            r#\"\nstruct S { foo: i32}\nfn main() {\n    S { foo: 92 }\n}\n\"#,\n        );\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Supported Rust Version\nDESCRIPTION: This snippet demonstrates how to specify the minimum supported Rust version (MSRV) for a project in the Clippy configuration file and as an attribute in the code. It explains how to omit the patch version.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/configuration.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\nmsrv = \"1.30.0\"\n```\n\n----------------------------------------\n\nTITLE: Fluent Translation for Use Loop Suggestion\nDESCRIPTION: A fluent translation snippet providing a suggestion message for the `WHILE_TRUE` lint, suggesting the use of `loop {}` for infinite loops. This snippet is meant for localization purposes and is utilized by the lint's suggestion system within Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_13\n\nLANGUAGE: fluent\nCODE:\n```\nexample-use-loop = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n  .suggestion = use `loop`\n\n```\n\n----------------------------------------\n\nTITLE: Example Rust Doctest with Compilation Features\nDESCRIPTION: This example shows a Rust doctest that uses feature flags and warning configurations. The doctest demonstrates a scenario where custom compiler arguments might be needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n/// #![deny(warnings)]\n/// #![feature(async_await)]\n///\n/// let x = 12;\n/// ```\npub struct Bar;\n```\n\n----------------------------------------\n\nTITLE: Git Source Configuration - TOML\nDESCRIPTION: Defines a Git source in a TOML file, requiring the project's name, repository URL, and a specific commit hash, branch, or tag. This ensures that a fixed state of the repo is used for linting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\npuffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n```\n\n----------------------------------------\n\nTITLE: Enabling and Configuring rust-analyzer Runnables in JSON\nDESCRIPTION: Specifies how runnable commands such as tests and binaries are executed within rust-analyzer. It indicates the base command override, additional arguments appended to cargo invocations, and extra test binary arguments which are passed through Cargo to the launched test executables. This allows custom test harness support and fine control over how tests run within the development environment. Requires rust-analyzer version supporting these keys and a cargo-based Rust project. Inputs are arrays or strings controlling CLI commands, outputs influence in-editor run functionality and test command-line options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.runnables.command\": null,\n  \"rust-analyzer.runnables.extraArgs\": [],\n  \"rust-analyzer.runnables.extraTestBinaryArgs\": [\n    \"--show-output\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Panic Usage in Rust\nDESCRIPTION: This example shows various ways to use the panic macro in Rust. It demonstrates basic usage, formatted string panics, and the panic_any function. These examples would normally terminate program execution and are marked with should_panic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/macros/panic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(unreachable_code)]\npanic!();\npanic!(\"this is a terrible mistake!\");\npanic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\nstd::panic::panic_any(4); // panic with the value of 4 to be collected elsewhere\n```\n\n----------------------------------------\n\nTITLE: Fixing Unused Type Parameter by Removing It in Rust Enum\nDESCRIPTION: This code snippet demonstrates how to fix the E0392 error by removing the unused type parameter from the enum declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0392.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    Bar,\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Access of Associated Constant in Rust Trait\nDESCRIPTION: This code snippet shows the correct way to access an associated constant in a Rust trait. It demonstrates accessing the constant through a concrete type, which is the supported approach.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0329.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    const BAR: f64;\n}\n\nstruct MyStruct;\n\nimpl Foo for MyStruct {\n    const BAR: f64 = 0f64;\n}\n\nfn get_bar_good() -> f64 {\n    <MyStruct as Foo>::BAR\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching in Rust\nDESCRIPTION: Demonstrates proper handling of Option types using match and if let expressions, which safely handle both Some and None cases.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0005.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(1);\n\nmatch x {\n    Some(y) => {\n        // do something\n    },\n    None => {}\n}\n\n// or:\n\nif let Some(y) = x {\n    // do something\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Variable Declaration and Usage in Rust\nDESCRIPTION: Shows proper variable declaration before usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0425.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Irrefutable Pattern with Loop and Let-Binding (Rust)\nDESCRIPTION: This code snippet demonstrates the correct way to handle an irrefutable pattern using a regular let-binding inside a loop. It defines the same 'Irrefutable' struct but uses a loop construct instead of while-let, avoiding the deprecated error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0165.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\nloop {\n    let Irrefutable(x) = irr;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Let Statement Formatting in Rust\nDESCRIPTION: Demonstrates standard formatting for let statements with type annotations and initializers, emphasizing spacing and line placement\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet pattern: Type = expr;\n```\n\n----------------------------------------\n\nTITLE: Resolving Associated Type Mismatch by Changing Trait Implementation\nDESCRIPTION: This solution resolves the E0271 error by modifying the trait implementation for i8 to match the function's constraint. The associated type in the implementation is changed to u32.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0271.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n\n----------------------------------------\n\nTITLE: Building Standard Library\nDESCRIPTION: This command builds the standard library using the bootstrap compiler. The `--stage 0` flag specifies that the library should be built using the stage 0 compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./x build --stage 0 library\n```\n\n----------------------------------------\n\nTITLE: Linking Rust staticlib and C code with LLD linker\nDESCRIPTION: This snippet demonstrates how to link a Rust static library and compiled C code using the LLD linker, which is required for linker plugin LTO. It uses `clang` with the `-flto=thin` flag, specifies the LLD linker with `-fuse-ld=lld`, and links the Rust library using `-l\"name-of-your-rust-lib\"`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"clang -flto=thin -fuse-ld=lld -L . -l\\\"name-of-your-rust-lib\\\" -o main -O2 ./cmain.o\"\n```\n\n----------------------------------------\n\nTITLE: Normalizing Where Clauses in Rust\nDESCRIPTION: This snippet discusses normalizing where clauses in a `ParamEnv` to ensure correct functionality of Rust's old trait solver. It showcases needing normalized associated types to prove trait bounds. Dependencies include the `Trait` and `Other` traits; input is unnormalized where clauses, and output is a normalized `ParamEnv`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait<T> {\n    type Assoc;\n}\n\ntrait Other {\n    type Bar;\n}\n\nimpl<T> Other for T {\n    type Bar = u32;\n}\n\n// `foo`'s unnormalized `ParamEnv` would be:\n// `[T: Sized, U: Sized, U: Trait<T::Bar>]`\nfn foo<T, U>(a: U) \nwhere\n    U: Trait<<T as Other>::Bar>,\n{\n    requires_impl(a);\n}\n\nfn requires_impl<U: Trait<u32>>(_: U) {}\n```\n\n----------------------------------------\n\nTITLE: Handling Mutable Borrow Error in Closure - Rust\nDESCRIPTION: This snippet illustrates an erroneous situation where a mutable variable `a` is borrowed by a closure, preventing further mutable access in the outer function. The error emphasizes Rust's borrowing rules and unique access requirements for mutable references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0501.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0501\nfn inside_closure(x: &mut i32) {\n    // Actions which require unique access\n}\n\nfn outside_closure(x: &mut i32) {\n    // Actions which require unique access\n}\n\nfn foo(a: &mut i32) {\n    let mut bar = || {\n        inside_closure(a)\n    };\n    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n                        //        closure requires unique access.\n    bar();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Type Inference Error with Generic Struct Methods in Rust\nDESCRIPTION: This code demonstrates an E0282 error occurring when calling a static method on a generic struct without specifying the type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Well-Commented Rust Test Structure\nDESCRIPTION: A template for how to structure a test with good documentation, including proper comment formatting for test purpose, relevant links, test case descriptions, and platform-specific directives. Demonstrates best practices for making tests maintainable and understandable for future contributors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/best-practices.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n//! Brief summary of what the test is exercising.\n//! Example: Regression test for #123456: make sure coverage attribute don't ICE\n//!     when applied to non-items.\n//!\n//! Optional: Remarks on related tests/issues, external APIs/tools, crash\n//!     mechanism, how it's fixed, FIXMEs, limitations, etc.\n//! Example: This test is like `tests/attrs/linkage.rs`, but this test is\n//!     specifically checking `#[coverage]` which exercises a different code\n//!     path. The ICE was triggered during attribute validation when we tried\n//!     to construct a `def_path_str` but only emitted the diagnostic when the\n//!     platform is windows, causing an ICE on unix.\n//!\n//! Links to relevant issues and discussions. Examples below:\n//! Regression test for <https://github.com/rust-lang/rust/issues/123456>.\n//! See also <https://github.com/rust-lang/rust/issues/101345>.\n//! See discussion at <https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/123456-example-topic>.\n//! See [`clone(2)`].\n//!\n//! [`clone(2)`]: https://man7.org/linux/man-pages/man2/clone.2.html\n\n//@ ignore-windows\n// Reason: (why is this test ignored for windows? why not specifically\n// windows-gnu or windows-msvc?)\n\n// Optional: Summary of test cases: What positive cases are checked?\n// What negative cases are checked? Any specific quirks?\n\nfn main() {\n    #[coverage]\n    //~^ ERROR coverage attribute can only be applied to function items.\n    let _ = {\n        // Comment highlighting something that deserves reader attention.\n        fn foo() {}\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Unconstrained Type Parameter in Impl Block Error Example\nDESCRIPTION: This code demonstrates an E0207 error where a type parameter T is declared in an impl block but is not constrained by the implementing type, implemented trait, or associated type binding.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl<T: Default> Foo {\n    // error: the type parameter `T` is not constrained by the impl trait, self\n    // type, or predicates [E0207]\n    fn get(&self) -> T {\n        <T as Default>::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up basic benchmarking in Rust\nDESCRIPTION: Demonstrates how to set up a basic benchmark test in Rust using the 'test' crate. The example shows a simple function to benchmark and the test module structure with both a regular test and a benchmark test.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/test.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(test)]\n\nextern crate test;\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[bench]\n    fn bench_add_two(b: &mut Bencher) {\n        b.iter(|| add_two(2));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Token Naming Conventions in Rust\nDESCRIPTION: Demonstrates the preferred use of T![foo] syntax instead of SyntaxKind::FOO_KW for better readability and familiar Rust syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nmatch p.current() {\n    T![true] | T![false] => true,\n    _ => false,\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Debug Trait Example in Rust\nDESCRIPTION: Fixed version showing how to properly constrain a generic type T to types that implement the Debug trait, allowing for debug printing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0277.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of unsafe function without an unsafe block in Rust\nDESCRIPTION: This example demonstrates erroneous code that calls an unsafe function without wrapping it in an unsafe block, which violates Rust's safety checks and results in error E0133.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0133.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Crate Name\nDESCRIPTION: This code snippet illustrates how to use the `--crate-name` flag to override the default crate name used by rustdoc. By default, rustdoc assumes the crate name is the same as the `.rs` file name, but this flag allows users to specify a different name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --crate-name mycrate\n```\n\n----------------------------------------\n\nTITLE: Invalid Generic Receiver Type Example 1 (Using Generic Type Parameter)\nDESCRIPTION: Example of invalid code that generates error E0801 by attempting to use a generic type parameter R as the receiver type for a method, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0801.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn foo<R: std::ops::Deref<Target=Self>>(self: R) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Note-style Lint Output in Rust\nDESCRIPTION: Example showing how notes appear in lint output, demonstrating reference-related lint messages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nerror: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n  --> tests/ui/drop_forget_ref.rs:10:5\n   |\n10 |     forget(&SomeStruct);\n   |     ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `-D clippy::forget-ref` implied by `-D warnings`\nnote: argument has type &SomeStruct\n  --> tests/ui/drop_forget_ref.rs:10:12\n   |\n10 |     forget(&SomeStruct);\n   |            ^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Matching Arrays with Flexible Pattern Length in Rust\nDESCRIPTION: This snippet shows a correct pattern matching approach using the `..` syntax, allowing the pattern to match more elements than explicitly defined by the pattern variables, thus preventing compile errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0527.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet r = &[1, 2, 3, 4];\nmatch r {\n    &[a, b, ..] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Type Equality in Rust's Type Inference\nDESCRIPTION: Demonstrates the recommended method for enforcing type equality using the inference context's 'at' and 'eq' methods\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ninfcx.at(...).eq(t, u);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0061 Error with Missing Function Arguments in Rust\nDESCRIPTION: This example shows code that will fail to compile because the function 'f' requires one argument (u: i32) but is called with zero arguments, triggering the E0061 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0061.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f(u: i32) {}\n\nf(); // error!\n```\n\n----------------------------------------\n\nTITLE: Erroneous Mutable Borrowing of Non-Mutable Variable in Rust\nDESCRIPTION: Demonstrates a compilation error when trying to create a mutable reference to a non-mutable variable. This code fails because the original variable `x` is not declared as mutable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0596.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\nlet y = &mut x; // error: cannot borrow mutably\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Floating Point Type f32\nDESCRIPTION: Describes the standard floating-point type in Rust, which is typically f32 and compliant with IEEE 754 single-precision float standard. The type guarantees a floating-point number but may have implementation variations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_float.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet float_value: f32 = 3.14;\n```\n\n----------------------------------------\n\nTITLE: Fixing E0713 Error by Taking S as a Mutable Reference\nDESCRIPTION: This code snippet demonstrates how to fix the E0713 error by modifying the demo function to take S as a mutable reference. This approach prevents the destructor from running while the string data is borrowed, resolving the conflict with the Drop trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0713.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct S<'a> { data: &'a mut String }\n\nimpl<'a> Drop for S<'a> {\n    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n}\n\nfn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n```\n\n----------------------------------------\n\nTITLE: Deriving Copy on a struct with mutable reference\nDESCRIPTION: An example showing an E0204 error when trying to derive the Copy trait on a struct that contains a mutable reference field, as mutable references don't implement Copy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0204.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Copy)] // error!\nstruct Foo<'a> {\n    ty: &'a mut bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Blank Lines Example Original\nDESCRIPTION: Example showing code before blank lines formatting is applied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![rustfmt::skip]\n\nfn foo() {\n    println!(\"a\");\n}\nfn bar() {\n    println!(\"b\");\n    println!(\"c\");\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Type Alias Impl Trait in Rust\nDESCRIPTION: Proper implementation of type_alias_impl_trait using a generic function. This ensures the hidden type (u32) is consistently used regardless of the generic parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0792.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(type_alias_impl_trait)]\n\ntype Foo<T> = impl std::fmt::Debug;\n\n#[define_opaque(Foo)]\nfn foo<U>() -> Foo<U> {\n    5u32\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of repr Attribute in Rust\nDESCRIPTION: This snippet shows the correct usage of a supported repr attribute 'C'. The repr attribute 'C' specifies that the struct should have the same memory layout as C language structs, which ensures compatibility with C code. Using this recognized representation layout is crucial for defining how data is structured in memory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0552.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)] // ok!\nstruct MyStruct {\n    my_field: usize\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Struct Pattern Matching in Rust\nDESCRIPTION: Example showing incorrect pattern matching where not all struct fields are specified, resulting in compilation error E0027.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0027.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Dog {\n    name: String,\n    age: u32,\n}\n\nlet d = Dog { name: \"Rusty\".to_string(), age: 8 };\n\n// This is incorrect.\nmatch d {\n    Dog { age: x } => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Associated Type Constraint in Rust Traits\nDESCRIPTION: This code snippet demonstrates an invalid attempt to constrain an associated type Color in a BoxCar trait that inherits from both Vehicle and Box traits. The constraint in the function signature is not allowed and results in an E0222 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0222.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Vehicle {\n    type Color;\n}\n\npub trait Box {\n    type Color;\n}\n\npub trait BoxCar : Box + Vehicle {}\n\nfn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {} // Invalid constraint\n```\n\n----------------------------------------\n\nTITLE: Loading Shell Completions for Bash, Zsh, and Fish\nDESCRIPTION: This snippet provides instructions to load shell completions for Bash, Zsh, or Fish using the `source` command. It is essential for users seeking to enhance their command-line experience with autocompletion features for the Rust project's `x.py`. The primary prerequisite is having the shell completion script available in the specified path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nsource ./src/etc/completions/x.py.<extension>\n```\n\n----------------------------------------\n\nTITLE: Correct Value Dropping in Rust\nDESCRIPTION: Proper implementation showing how to manually drop a value using std::mem::drop function when necessary. This is the correct way to explicitly drop values in Rust when required.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0040.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n}\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"kaboom\");\n    }\n}\nfn main() {\n    let mut x = Foo { x: -7 };\n    drop(x); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Async Functions to Impl Future (Rust)\nDESCRIPTION: This snippet demonstrates how async functions are desugared to return impl Future. It shows the equivalence between an async function and its desugared form.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0706.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn foo() -> User {\n    unimplemented!()\n}\n// The async fn above gets desugared as follows:\nfn foo(&self) -> impl Future<Output = User> + '_ {\n    unimplemented!()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Non-Inclusive Range in Rust\nDESCRIPTION: This solution demonstrates how to fix the error by using a non-inclusive range operator (..) which doesn't require an end value. This syntax creates a range from the start index to the end of the collection.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0586.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n    let x = &tmp[1..]; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up rust-analyzer with nvim-lsp using Lua\nDESCRIPTION: This Lua snippet configures rust-analyzer with nvim-lsp, the built-in LSP client for Neovim.  It sets up the rust-analyzer server with custom settings for imports, cargo build scripts, and proc macro support.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_4\n\nLANGUAGE: Lua\nCODE:\n```\nlua << EOF\nlocal lspconfig = require'lspconfig'\n\nlocal on_attach = function(client)\n    require'completion'.on_attach(client)\nend\n\nlspconfig.rust_analyzer.setup({\n    on_attach = on_attach,\n    settings = {\n        [\"rust-analyzer\"] = {\n            imports = {\n                granularity = {\n                    group = \"module\",\n                },\n                prefix = \"self\",\n            },\n            cargo = {\n                buildScripts = {\n                    enable = true,\n                },\n            },\n            procMacro = {\n                enable = true\n            },\n        }\n    }\n})\nEOF\n```\n\n----------------------------------------\n\nTITLE: Universal Regions Liveness Constraints Visualization\nDESCRIPTION: Textual representation of universal regions' liveness constraints during region inference\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/lifetime_parameters.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n'a live at {B, end('a)}\n'b live at {B, end('b)}\n'a: 'b\n```\n\n----------------------------------------\n\nTITLE: Rust Lifetime Resolution with Single Lifetime\nDESCRIPTION: Simplifies the lifetime handling by using a single lifetime parameter for both input and output. This approach removes the complexity of multiple lifetime constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0623.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a, 'b, T>(std::marker::PhantomData<(&'a (), &'b (), T)>)\nwhere\n    T: Convert<'a, 'b>;\n\ntrait Convert<'a, 'b>: Sized {\n    fn cast(&'a self) -> &'b Self;\n}\nimpl<'long: 'short, 'short, T> Convert<'long, 'short> for T {\n    fn cast(&'long self) -> &'short T {\n        self\n    }\n}\nfn badboi<'out, T>(x: Foo<'out, 'out, T>, sadness: &'out T) -> &'out T {\n    sadness.cast()\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example with typeof in Rust\nDESCRIPTION: This code demonstrates the use of the `typeof` keyword, which is currently unimplemented in Rust. Attempting to compile this code will result in a compilation error (E0516). The code attempts to declare a variable `x` with the type of the expression `92` using `typeof`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0516.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0516\nfn main() {\n    let x: typeof(92) = 92;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using the src-hash-algorithm Compiler Flag in Rust\nDESCRIPTION: The `-Z src-hash-algorithm` flag allows specifying which algorithm (md5, sha1, or sha256) is used when the Rust compiler hashes source files for debug information. Support varies by debug info format, and the default is based on the target specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/src-hash-algorithm.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Z src-hash-algorithm\n```\n\n----------------------------------------\n\nTITLE: Invalid Non-exhaustive Attribute Usage on Trait in Rust\nDESCRIPTION: Example showing incorrect placement of #[non_exhaustive] attribute on a trait declaration, which results in compilation error E0701. The #[non_exhaustive] attribute can only be used with structs and enums.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0701.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[non_exhaustive]\ntrait Foo { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutability Error in Rust\nDESCRIPTION: This snippet shows an attempt to mutate data through a mutable reference stored in an immutable Box, which results in a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0386.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x: i64 = 1;\nlet y: Box<_> = Box::new(&mut x);\n**y = 2; // error, cannot assign to data in an immutable container\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Stages Diagram in Mermaid\nDESCRIPTION: Visual representation of the Rust compiler bootstrapping process, showing the progression through different stages of compiler and standard library compilation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/what-bootstrapping-does.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    s0c[\"stage0 compiler (1.63)\"]:::downloaded -->|A| s0l(\"stage0 std (1.64)\"):::with-s0c;\n    s0c & s0l --- stepb[ ]:::empty;\n    stepb -->|B| s0ca[\"stage0 compiler artifacts (1.64)\"]:::with-s0c;\n    s0ca -->|copy| s1c[\"stage1 compiler (1.64)\"]:::with-s0c;\n    s1c -->|C| s1l(\"stage1 std (1.64)\"):::with-s1c;\n    s1c & s1l --- stepd[ ]:::empty;\n    stepd -->|D| s1ca[\"stage1 compiler artifacts (1.64)\"]:::with-s1c;\n    s1ca -->|copy| s2c[\"stage2 compiler\"]:::with-s1c;\n\n    classDef empty width:0px,height:0px;\n    classDef downloaded fill: lightblue;\n    classDef with-s0c fill: yellow;\n    classDef with-s1c fill: lightgreen;\n```\n\n----------------------------------------\n\nTITLE: Unresolved Import Error Example\nDESCRIPTION: Demonstrates an erroneous import that will fail to compile due to an unresolved path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0432.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\n----------------------------------------\n\nTITLE: Using Turbofish Syntax with collect() in Rust\nDESCRIPTION: This example demonstrates specifying the generic type parameter directly on the collect() method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Compare Modes\nDESCRIPTION: This command allows running UI tests in specific compiler modes, which can affect the expected output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui --compare-mode=polonius\n```\n\n----------------------------------------\n\nTITLE: Rust for Linux Notification Bot Command\nDESCRIPTION: Command used to ping the Rust for Linux notification group using rustbot\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/rust-for-linux.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n@rustbot ping rfl\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Hexadecimal Underscore and Character Error\nDESCRIPTION: This snippet demonstrates an error where a hexadecimal integer literal (0x_) contains an underscore followed by invalid character 'g'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0x_g\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting Edition for Rustdoc Compilation (Bash)\nDESCRIPTION: This snippet demonstrates how to use the --edition flag with rustdoc to specify the Rust edition for compiling documentation and doctests. The default edition is 2015 if not specified.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --edition 2018\n$ rustdoc --test src/lib.rs --edition 2018\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Configuration Values\nDESCRIPTION: Shows how to list all cfg values for conditional compilation using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print cfg a.rs\ndebug_assertions\npanic=\"unwind\"\ntarget_abi=\"\"\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"gnu\"\ntarget_family=\"unix\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"linux\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"unknown\"\nunix\n```\n\n----------------------------------------\n\nTITLE: Using Fully Qualified Syntax to Resolve Method Call Ambiguity\nDESCRIPTION: This code snippet shows how to use fully qualified syntax to specify which trait's method to call when multiple traits define methods with the same name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0034.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Missing Impl Members in Rust\nDESCRIPTION: This assist adds scaffold for required impl members. It inserts placeholders for all trait items that need to be implemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait<T> {\n    type X;\n    fn foo(&self) -> T;\n    fn bar(&self) {}\n}\n\nimpl Trait<u32> for () {\n\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait<T> {\n    type X;\n    fn foo(&self) -> T;\n    fn bar(&self) {}\n}\n\nimpl Trait<u32> for () {\n    type X;\n\n    fn foo(&self) -> u32 {\n        todo!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Module and Struct Instantiation in Rust\nDESCRIPTION: Demonstrates the correct way to create a struct within a module and instantiate it using the module's namespace. Shows how to properly expose and use types defined within modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0574.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod mordor {\n    pub struct TheRing {\n        pub x: usize,\n    }\n}\n\nlet sauron = mordor::TheRing { x: 1 }; // ok!\n```\n\n----------------------------------------\n\nTITLE: Dummy Trait Definition in Rust\nDESCRIPTION: Defines a simple trait with lifetime parameters and its blanket implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/member_constraints.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait<'a, 'b> { }\nimpl<T> Trait<'_, '_> for T { }\n```\n\n----------------------------------------\n\nTITLE: Defining Closure After Mutable Access - Rust\nDESCRIPTION: This snippet shows how to define the closure after the mutable variable has been accessed, thus avoiding borrow conflicts. The implementation demonstrates flexible closure positioning to ensure compliance with Rust's borrowing rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0501.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    outside_closure(a);\n    let mut bar = || {\n        inside_closure(a)\n    };\n    bar();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Struct Definition Formatting in Rust\nDESCRIPTION: Shows the standard formatting for struct definitions in Rust, including placing the opening brace on the same line, indenting fields, adding a trailing comma to each field, and placing the closing brace on its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: A,\n    b: B,\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Complex Number Literal Scenarios in Rust\nDESCRIPTION: Test cases for edge cases involving number literals, including dot operations and method calls\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/numbers.txt#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nINT_NUMBER \"0\"DOT \".\"DOT \".\"INT_NUMBER \"2\"\nINT_NUMBER \"0\"DOT \".\"IDENT \"foo\"L_PAREN \"(\"R_PAREN \")\"\nINT_NUMBER \"0\"DOT \".\"IDENT \"e\"PLUS \"+\"INT_NUMBER \"1\"\n```\n\n----------------------------------------\n\nTITLE: Error Example: Referencing Non-existent Associated Type in Rust Trait\nDESCRIPTION: This code demonstrates the E0576 error by attempting to reference a non-existent associated type 'You' in the 'Hello' trait. The compiler will fail because this associated type has not been defined.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0576.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Hello {\n    type Who;\n\n    fn hello() -> <Self as Hello>::You; // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Mutable Reference by Removing Outer Reference\nDESCRIPTION: Shows how to correctly modify data by using a direct mutable reference without the additional immutable reference layer\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0389.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &mut fancy;\n    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\"{}\", fancy_ref.num);\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing E0573: Using pattern matching with enums\nDESCRIPTION: This code snippet demonstrates how to correctly use enum variants within a trait function. Instead of specifying a particular variant as the parameter type, it uses the entire enum type and then uses pattern matching (`match`) to handle different variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0573.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(w: Wizard) { // ok!\n        match w {\n            Wizard::Saruman => {\n                // do something\n            }\n            _ => {} // ignore everything else\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_1 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_1` function in Rust, passing an integer argument (14). It demonstrates how to call a function with a single integer argument using the `stdcall` calling convention. There are no explicit dependencies mentioned here, assuming the function itself has been defined elsewhere in the code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_1(14)\n```\n\n----------------------------------------\n\nTITLE: Correctly Terminating a Byte String in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to declare a byte string in Rust by properly terminating it with a double quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0766.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet s = b\"\"; // ok!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unused Type Parameter Error in Rust Enum\nDESCRIPTION: This code snippet shows an erroneous example where a type parameter T is declared in an enum but not used, resulting in the E0392 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0392.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo<T> {\n    Bar,\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Modules by Source Appearance in Rustdoc\nDESCRIPTION: Demonstrates how to disable alphabetical sorting of items in module pages, instead showing them in the order they appear in the source code. By default, Rustdoc sorts items alphabetically with stability considerations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance\n```\n\n----------------------------------------\n\nTITLE: Correcting Binary Operation Usage with Supported Type in Rust\nDESCRIPTION: This code snippet demonstrates the correct usage of the left shift operation by using a type (u32) that implements the required trait (Shl). It shows how to fix the previous error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0369.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\n----------------------------------------\n\nTITLE: Implementing the Panic Handler in Standard Library\nDESCRIPTION: This snippet shows the implementation of the panic handler in std that receives panic information from core. The function is marked with the #[panic_handler] attribute which connects it to core's panic_impl lang item, allowing panics from core to use std's panic infrastructure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/panic-implementation.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// Entry point of panic from the core crate.\n#[cfg(not(test))]\n#[panic_handler]\n#[unwind(allowed)]\npub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incompatible Naked Function Attributes in Rust\nDESCRIPTION: Example showing an erroneous code snippet that demonstrates the incompatibility between #[inline] and #[naked] attributes. This code will fail to compile with error E0736.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0736.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[inline]\n#[unsafe(naked)]\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct FileSymbols in Rust\nDESCRIPTION: Represents file-level symbol definitions with complex metadata including struct IDs, declaration locations, and symbol attributes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_doc_alias.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"Struct\",\n    def: Adt(Struct(Struct { id: StructId(0) })),\n    loc: DeclarationLocation { ... },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Removed Lint in Rust Compiler\nDESCRIPTION: This snippet demonstrates how to register a lint as removed in the Rust compiler. It updates the `register_removed` function call with the lint name and a reference link to the tracking issue, indicating the reason for removal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/bug-fix-procedure.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstore.register_removed(\"overlapping_inherent_impls\", \"converted into hard error, see #36889\");\n```\n\n----------------------------------------\n\nTITLE: Avoiding Monomorphization\nDESCRIPTION: This snippet emphasizes the need to minimize extensive use of type parameters at crate boundaries to reduce compile times and prevent inefficient compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn frobnicate(f: impl FnMut()) {\n    frobnicate_impl(&mut f)\n}\nfn frobnicate_impl(f: &mut dyn FnMut()) {\n    // lots of code\n}\n\n// BAD\nfn frobnicate(f: impl FnMut()) {\n    // lots of code\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Help-style Lint Output in Rust\nDESCRIPTION: Example showing how help messages appear in lint output, demonstrating NaN-related suggestions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nerror: constant division of 0.0 with 0.0 will always result in NaN\n  --> tests/ui/zero_div_zero.rs:6:25\n   |\n6  |     let other_f64_nan = 0.0f64 / 0.0;\n   |                         ^^^^^^^^^^^^\n   |\n   = help: consider using `f64::NAN` if you would like a constant representing NaN\n```\n\n----------------------------------------\n\nTITLE: Storing Temporaries in Aggregate Structures in Rust\nDESCRIPTION: This example demonstrates how temporaries stored in aggregate structures like tuples are not dropped until the end of the enclosing block, providing another way to extend temporary lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0716.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n\n----------------------------------------\n\nTITLE: Complex Type-Based Search Matching in Rustdoc\nDESCRIPTION: This snippet delves into the logic behind complex type-based searches in Rustdoc, explaining how type parameters are treated and outlining query structuring for matching function signatures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/read-documentation/search.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nFunction parameters are order-agnostic, but sensitive to nesting and number of matches. For example, a function with the signature\n`fn read_all(&mut self: impl Read) -> Result<Vec<u8>, Error>`\nwill match these queries:\n\n* `&mut Read -> Result<Vec<u8>, Error>`\n* `Read -> Result<Vec<u8>, Error>`\n* `Read -> Result<Vec<u8>>`\n* `Read -> Vec<u8>`\n\nBut it *does not* match `Result<Vec, u8>` or `Result<u8<Vec>>`, because those are nested incorrectly...\n```\n\n----------------------------------------\n\nTITLE: Checking Iterator Cloned Method Using Type Path\nDESCRIPTION: Demonstrates checking trait method implementation using clippy_utils paths when diagnostic or lang items are not available. Uses match_trait_method to check for specific trait method implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/trait_checking.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::{match_trait_method, paths};\nuse rustc_hir::Expr;\nuse rustc_lint::{LateContext, LateLintPass};\n\nimpl LateLintPass<'_> for CheckTokioAsyncReadExtTrait {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        if match_trait_method(cx, expr, &paths::CORE_ITER_CLONED) {\n            println!\"`expr` implements `CORE_ITER_CLONED` trait!\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0062 Error in Rust Struct Initialization\nDESCRIPTION: This code snippet shows an erroneous struct initialization where the field 'x' is specified twice, resulting in a compilation error E0062.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0062.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n}\n\nfn main() {\n    let x = Foo {\n                x: 0,\n                x: 0, // error: field `x` specified more than once\n            };\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation with Constrained Lifetimes\nDESCRIPTION: This snippet defines a trait with an associated type and shows how lifetime parameters are handled in its implementation. It stresses the importance of avoiding unconstrained lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type Assoc;\n}\n\nimpl<'a> Trait for u8 {\n    type Assoc = &'a String;\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Mutable Reference by Making Outer Reference Mutable\nDESCRIPTION: Demonstrates an alternative fix by making both the inner and outer references mutable, allowing modification of the underlying data\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0389.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &mut (&mut fancy);\n    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\"{}\", fancy_ref.num);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking External Macro Usage\nDESCRIPTION: Example code showing how to check for macros from external crates using in_external_macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use]\nextern crate a_foreign_crate_with_macros;\n\n// `foo` macro is defined in `a_foreign_crate_with_macros`\nfoo!(\"bar\");\n```\n\n----------------------------------------\n\nTITLE: Replacing Arithmetic with Saturating Operations in Rust\nDESCRIPTION: Converts basic arithmetic operations to their saturating equivalents that clamp the result at numeric bounds. This refactoring is useful when you want to prevent overflow by having operations return the maximum or minimum value instead of wrapping.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_106\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1 + 2;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1.saturating_add(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom MIR Visitor Structure in Rust\nDESCRIPTION: This snippet demonstrates how to define a structure for a custom MIR visitor in Rust. It showcases the necessary component 'tcx' that holds the type context required for processing the MIR, ensuring easy access to needed state during traversal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/visitor.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct MyVisitor<...> {\n    tcx: TyCtxt<'tcx>,\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Test Module Snippet Completion\nDESCRIPTION: Generates a standard Rust test module with boilerplate configuration and a sample test function\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_name() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Non-Mutable Struct Assignment in Rust\nDESCRIPTION: This snippet demonstrates an error caused by attempting to assign a new value to a non-mutable field of a struct in Rust. The original code defines a struct 'SolarSystem' with a field 'earth' and attempts to modify it without declaring the instance 'ss' as mutable, resulting in a compile-time error. The corrected snippet showcases how to declare 'ss' as mutable to allow reassignment of the 'earth' field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0594.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0594\nstruct SolarSystem {\n    earth: i32,\n}\n\nlet ss = SolarSystem { earth: 3 };\nss.earth = 2; // error!\n```\n```\n\nLANGUAGE: Rust\nCODE:\n```\n```\nstruct SolarSystem {\n    earth: i32,\n}\n\nlet mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable\nss.earth = 2; // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing FnOnce for Custom Struct in Rust\nDESCRIPTION: This snippet demonstrates how to use the fn_traits and unboxed_closures features to implement the FnOnce trait for a custom Adder struct. It allows the struct to be called like a function, adding its internal value to the provided argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/fn-traits.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder {\n    a: u32\n}\n\nimpl FnOnce<(u32, )> for Adder {\n    type Output = u32;\n    extern \"rust-call\" fn call_once(self, b: (u32, )) -> Self::Output {\n        self.a + b.0\n    }\n}\n\nfn main() {\n    let adder = Adder { a: 3 };\n    assert_eq!(adder(2), 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Type Specification in Rust Signatures\nDESCRIPTION: Examples showing the correct way to explicitly specify types in function return types and static variable declarations instead of using placeholders.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0121.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 5 } // ok!\n\nstatic BAR: &str = \"test\"; // ok!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Undefined Behavior with Mutable Static References in Rust\nDESCRIPTION: Example showing how creating a mutable reference to a static variable can lead to undefined behavior due to aliasing violations. The code demonstrates a dangerous pattern where a function potentially reads from the static while a mutable reference exists elsewhere.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0796.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstatic mut X: i32 = 23;\nfn work() {\n  let _val = unsafe { X };\n}\nlet x_ref = unsafe { &mut X };\nwork();\n// The next line has Undefined Behavior!\n// `x_ref` is a mutable reference and allows no aliases,\n// but `work` has been reading the reference between\n// the moment `x_ref` was created and when it was used.\n// This violates the uniqueness of `x_ref`.\n*x_ref = 42;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Negative Trait Implementation in Rust\nDESCRIPTION: This example shows erroneous code that attempts to use a negative implementation (impl !) for a non-auto trait. Negative implementations are only allowed for auto traits as specified in RFC 19.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0192.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type Bar;\n}\n\nstruct Foo;\n\nimpl !Trait for Foo { } //~ ERROR\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Bumping Clippy Version - Bash\nDESCRIPTION: This command uses `cargo dev release bump_version` to update the version numbers in all relevant `Cargo.toml` files within the Clippy project. This is a crucial step before creating a new release to ensure version consistency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev release bump_version\n```\n\n----------------------------------------\n\nTITLE: Creating Getter Methods with Concatenated Names in Rust\nDESCRIPTION: This example shows how to use the concat metavariable expression to create a getter method with a name that is formed by concatenating 'get_' with a field name. The macro implements the method for a specified struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(macro_metavar_expr_concat)]\n\nmacro_rules! make_getter {\n    ($name:ident, $field: ident, $ret:ty) => {\n        impl $name {\n            pub fn ${ concat(get_, $field) }(&self) -> &$ret {\n                &self.$field\n            }\n        }\n    }\n}\n\npub struct Thing {\n    description: String,\n}\n\nmake_getter!(Thing, description, String);\n```\n\n----------------------------------------\n\nTITLE: Generating Closer HIR Representation in Rust\nDESCRIPTION: This bash command generates a HIR representation that closely aligns with the original source code expressions. Like the previous command, it requires cargo to be set up to run rustc with the specified configurations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc -- -Z unpretty=hir\n```\n\n----------------------------------------\n\nTITLE: Implementing a Derived Query Function in Salsa\nDESCRIPTION: Implementation of the 'ast' derived query defined in the Parser trait. This shows how to write the actual function that Salsa will call when the query needs to be computed, accepting a database parameter that implements the query group trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n/// This is going to be the definition of the `ast` query in the `Parser` trait.\n/// So, when the query `ast` is invoked, and it needs to be recomputed, Salsa is\n/// going to call this function and it's going to give it the database as `impl\n/// Parser`. The function doesn't need to be aware of all the queries of all the\n/// query groups\nfn ast(db: &impl Parser, name: String) -> String {\n    //! Note, `impl Parser` is used here but `dyn Parser` works just as well\n    /* code */\n    ///By passing an `impl Parser`, this is allowed\n    let source_text = db.input_file(name);\n    /* do the actual parsing */\n    return ast;\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Drop Implementation Using Wrapper Type\nDESCRIPTION: Shows a valid workaround for implementing Drop on a specific generic type by creating a wrapper struct. The Bar struct wraps Foo<u32> and implements Drop, avoiding the specialization restriction.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0366.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> {\n    t: T\n}\n\nstruct Bar {\n    t: Foo<u32>\n}\n\nimpl Drop for Bar {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Recursion Limit Error with Auto-Dereferencing in Rust\nDESCRIPTION: This example shows a compilation error that occurs when the recursion limit is exceeded during auto-dereferencing. The code sets a recursion limit of 4, but tries to dereference a reference with 5 levels of indirection, resulting in error E0055.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0055.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![recursion_limit=\"4\"]\n\nstruct Foo;\n\nimpl Foo {\n    fn foo(&self) {}\n}\n\nfn main() {\n    let foo = Foo;\n    let ref_foo = &&&&&Foo;\n\n    // error, reached the recursion limit while auto-dereferencing `&&&&&Foo`\n    ref_foo.foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation with Lifetime Constraints\nDESCRIPTION: Example showing how trait implementations can have complex lifetime and generic parameter constraints\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/instantiating_binders.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> Other<'a> for &'a u32 { }\n\nimpl<T> Trait for T\nwhere\n    for<'a> T: Other<'a>,\n{ ... }\n\nimpl<T> Bar for T\nwhere\n    for<'a> &'a T: Trait\n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Valid Trait Implementation with Self Reference in Rust\nDESCRIPTION: This example demonstrates the correct way to implement a trait method with a reference to Self as the receiver type. It shows how &self is syntactic sugar for self: &Self.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0307.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct Foo;\ntrait Trait {\n    fn foo(&self);\n//         ^^^^^ `self` here is a reference to the receiver object\n}\n\nimpl Trait for Foo {\n    fn foo(&self) {}\n//         ^^^^^ the receiver type is `&Foo`\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Binary Operation Error on Unsupported Type in Rust\nDESCRIPTION: This code snippet shows an example of attempting a binary operation (left shift) on a floating-point type (f32) which doesn't support it, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0369.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\n----------------------------------------\n\nTITLE: Configuring Coverage Instrumentation Levels in Rust\nDESCRIPTION: This snippet outlines the different coverage instrumentation levels available in Rust. It includes block, branch, condition, and MC/DC coverage options, each building upon the previous level for more comprehensive code coverage analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/coverage-options.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n- `block`, `branch`, `condition`, `mcdc`:\n  Sets the level of coverage instrumentation.\n  Setting the level will override any previously-specified level.\n  - `block` (default):\n    Blocks in the control-flow graph will be instrumented for coverage.\n  - `branch`:\n    In addition to block coverage, also enables branch coverage instrumentation.\n  - `condition`:\n    In addition to branch coverage, also instruments some boolean expressions\n    as branches, even if they are not directly used as branch conditions.\n  - `mcdc`:\n    In addition to condition coverage, also enables MC/DC instrumentation.\n    (Branch coverage instrumentation may differ in some cases.)\n```\n\n----------------------------------------\n\nTITLE: Correct Associated Type Implementation in Rust\nDESCRIPTION: Demonstrates the correct way to specify and use an associated type by implementing the trait for a concrete type and using the proper syntax to reference the associated type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0223.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Diagnostic Struct in Rust\nDESCRIPTION: This Rust code snippet illustrates how to derive a `Diagnostic` for a struct using attributes such as `#[primary_span]` and `#[label]`. Dependencies include the `Diagnostic` trait and compatible attributes. Key parameters include the struct fields such as `field_name` and spans used for displaying error messages. The `Diagnostic` is intended to emit structured diagnostics, including primary error messages and subdiagnostics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Diagnostic)]\\n#[diag(hir_analysis_field_already_declared, code = E0124)]\\npub struct FieldAlreadyDeclared {\\n    pub field_name: Ident,\\n    #[primary_span]\\n    #[label]\\n    pub span: Span,\\n    #[label(previous_decl_label)]\\n    pub prev_span: Span,\\n}\n```\n\n----------------------------------------\n\nTITLE: Using Appropriate String Types for OS Interfacing\nDESCRIPTION: This guideline emphasizes the importance of using `OsString` when interfacing with OS APIs to preserve data integrity and to clarify data boundaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n// Rationale: cleanly delineates the boundary when the data goes into the OS-land.\n```\n\n----------------------------------------\n\nTITLE: Negated Has Directive Example\nDESCRIPTION: Example showing how to use a negated 'has' directive to check that a struct page does not exist in the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/rustdoc-test-suite.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n//@ !has 'foo/struct.Bar.html'\n```\n\n----------------------------------------\n\nTITLE: Fixing Move Errors with References in Rust\nDESCRIPTION: This code snippet presents a solution to the move-out-of-drop error by using references. By creating a reference to the field of the struct instead of moving it, the error is resolved, allowing the struct's Drop implementation to execute correctly when it goes out of scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0509.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nstruct FancyNum {\n    num: usize\n}\n\nstruct DropStruct {\n    fancy: FancyNum\n}\n\nimpl Drop for DropStruct {\n    fn drop(&mut self) {\n        // Destruct DropStruct, possibly using FancyNum\n    }\n}\n\nfn main() {\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n    let ref fancy_field = drop_struct.fancy; // No more errors!\n    println!(\"Fancy: {}\", fancy_field.num);\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait for a Specific Lifetime in Rust\nDESCRIPTION: This snippet defines a struct `AnyInt` and implements the `Foo` trait for it, specifically for references to `isize` with any lifetime `'a`. This demonstrates how a type can implement a trait generically over lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/hrtb.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct AnyInt;\nimpl<'a> Foo<&'a isize> for AnyInt { }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Usage of await Outside async Context in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the `await` keyword outside an `async` function, which results in a compilation error (E0728).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0728.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    wake_and_yield_once().await // `await` is used outside `async` context\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Associated Type Error in Rust Traits\nDESCRIPTION: An example showing how using 'Self' with traits that have common associated types can lead to ambiguity errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0411.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ncompile_fail\ntrait Foo {\n    type Bar;\n}\n\ntrait Foo2 {\n    type Bar;\n}\n\ntrait Baz : Foo + Foo2 {\n    fn bar() -> Self::Bar;\n    // error: ambiguous associated type `Bar` in bounds of `Self`\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of ffi_const Attribute in Rust\nDESCRIPTION: This code snippet shows the correct usage of the ffi_const attribute for a foreign function declaration. The ffi_pure attribute is removed as ffi_const provides stronger guarantees.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0757.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_const)]\n\nextern \"C\" {\n    #[unsafe(ffi_const)]\n    pub fn square(num: i32) -> i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Including Default Linker Libraries in Rust\nDESCRIPTION: Controls whether the linker includes default libraries. Accepts `y`, `yes`, `on`, `true` (include) or `n`, `no`, `off`, `false` or no value (exclude, default). For gcc linkers, this translates to the `-nodefaultlibs` flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Using Match Instead of If-Let in Rust\nDESCRIPTION: Demonstrates the preference for using 'match' instead of 'if let ... { } else { }' construct in Rust for improved compactness and precision.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nmatch ctx.expected_type.as_ref() {\n    Some(expected_type) => completion_ty == expected_type && !expected_type.is_unit(),\n    None => false,\n}\n\n// BAD\nif let Some(expected_type) = ctx.expected_type.as_ref() {\n    completion_ty == expected_type && !expected_type.is_unit()\n} else {\n    false\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Solution Using Shadowing in Rust\nDESCRIPTION: This code snippet shows an alternative approach to variable reassignment using shadowing, where a new variable with the same name is declared, effectively creating a new binding.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0384.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 3;\n    let x = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Closure Borrowing with Mutability in Rust\nDESCRIPTION: This snippet demonstrates an erroneous closure that attempts to borrow a variable that is already borrowed. The code identifies the issue where the closure `starks` tries to modify `jon_snow`, but `nights_watch` already holds a reference to it, resulting in a compilation error. The provided comments clarify the nature of the borrowing conflict and suggest a resolution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0500.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0500\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    let starks = || {\n        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n                       //        but it is already borrowed\n    };\n    println!(\"{}\", nights_watch);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Block with Lifetime Parameters\nDESCRIPTION: Proper implementation showing how to correctly declare lifetime parameters in an impl block for a struct that has lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0261.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a> {\n    x: &'a str,\n}\n\n// correct\nimpl<'a> Foo<'a> {\n    fn foo(x: &'a str) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using rustc_driver::run_compiler in Rust\nDESCRIPTION: The main entry point of rustc_driver, which accepts command-line args, Callbacks implementation, and other options to run the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nrustc_driver::run_compiler\n```\n\n----------------------------------------\n\nTITLE: Running a Subset of Tests\nDESCRIPTION: You can run a specific test suite or a subset of tests suitable for your changes, such as the ui test suite or a specific debuginfo test suite.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/debuginfo\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui/const-generics\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui/const-generics/const-test.rs\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test src/tools/miri --test-args tests/fail/uninit/padding-enum.rs\n```\n\n----------------------------------------\n\nTITLE: Resolving Trait Method Ambiguity with Concrete Types in Rust\nDESCRIPTION: This solution demonstrates how to correctly call trait methods when multiple implementations exist. It shows two approaches: directly using the implementing type's namespace, and using the fully qualified syntax with the 'as' keyword for disambiguation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0790.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Coroutine {\n    fn create() -> u32;\n}\n\nstruct AnotherImpl;\n\nimpl Coroutine for AnotherImpl {\n    fn create() -> u32 { 2 }\n}\n\nlet gen1 = AnotherImpl::create();\n\n// if there are multiple methods with same name (different traits)\nlet gen2 = <AnotherImpl as Coroutine>::create();\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_2 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_2` function in Rust, passing two arguments: an integer (16) and a floating-point number (3.5). It showcases the `stdcall` calling convention with mixed data types, essential for functions interacting with other components. There are no explicit dependencies, assuming the function is declared properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_2(16, 3.5)\n```\n\n----------------------------------------\n\nTITLE: Correct Self Parameter Type in Rust\nDESCRIPTION: Proper implementation of a method with an explicit self parameter using Box<Self>, which is one of the allowed self types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0211.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn x(self: Box<Foo>) {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation in Rust\nDESCRIPTION: This example demonstrates the correct way to implement a trait by providing implementations for all required methods. It shows how to properly implement the 'foo()' method for the 'Foo' trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0046.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Conflicting Trait Implementations Example\nDESCRIPTION: Demonstrates an error case where a trait is implemented both generically for all types T and specifically for type Foo, causing a compilation error due to conflicting implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0119.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Generic Functions with impl Trait in Rust\nDESCRIPTION: The snippet showcases an erroneous function call where an explicit generic argument is provided to a function that uses `impl Trait` in an argument position, which is not necessary. The corrected examples demonstrate how to either infer all generic arguments at the call site or redefine the function to use explicit generic type parameters. Dependencies include the Rust programming language, and key parameters involve generic types and the `impl Trait` syntax. These functions take inputs that are constrained by trait bounds—Copy and Clone—and produce no direct outputs but emphasize correct function signature usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0632.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn foo<T: Copy>(a: T, b: impl Clone) {}\n\nfoo::<i32>(0i32, \\\"abc\\\".to_string());\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn foo<T: Copy>(a: T, b: impl Clone) {}\nfn bar<T: Copy, U: Clone>(a: T, b: U) {}\n\nfoo(0i32, \\\"abc\\\".to_string());\n\nbar::<i32, String>(0i32, \\\"abc\\\".to_string());\nbar::<_, _>(0i32, \\\"abc\\\".to_string());\nbar(0i32, \\\"abc\\\".to_string());\n```\n\n----------------------------------------\n\nTITLE: Correct Packed Attribute Usage\nDESCRIPTION: This code snippet shows the correct way to use the `packed` attribute in Rust. It demonstrates a struct with a single `packed` attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0634.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\n#[repr(packed)] // ok!\nstruct Company(i32);\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Various Attributes in rustdoc Testing\nDESCRIPTION: The snippet section explains how to use rustdoc attributes like `ignore`, `should_panic`, `no_run`, and `compile_fail`. These attributes guide rustdoc in understanding the expected behavior when running tests on code snippets in documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n/// ```ignore\n/// fn foo() {\n/// ```\n# fn foo() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// ```should_panic\n/// assert!(false);\n/// ```\n# fn foo() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// ```no_run\n/// loop {\n///     println!(\"Hello, world\");\n/// }\n/// ```\n# fn foo() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// ```compile_fail\n/// let x = 5;\n/// x += 2; // shouldn't compile!\n/// ```\n# fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Enabling Missing Documentation Warnings in Rust\nDESCRIPTION: This Rust attribute, placed at the crate root (lib.rs or main.rs), enables the `missing_docs` lint. It instructs the Rust compiler (`rustc`) and `cargo doc` to issue warnings for any public items (functions, structs, enums, modules, traits, etc.) lacking documentation comments. This helps ensure documentation coverage during development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![warn(missing_docs)]\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Renaming Local Item in Rust\nDESCRIPTION: Demonstrates how to resolve the naming conflict by renaming the local struct declaration to a different name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0260.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core;\n\nstruct xyz;\n```\n\n----------------------------------------\n\nTITLE: Valid Const Generic Parameter Type Implementation\nDESCRIPTION: Corrected example showing proper implementation of a type for use as a const generic parameter by deriving PartialEq, Eq, and ConstParamTy traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0741.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(adt_const_params)]\n\nuse std::marker::ConstParamTy;\n\n#[derive(PartialEq, Eq, ConstParamTy)] // We derive both traits here.\nstruct A;\n\nstruct B<const X: A>; // ok!\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer Rustfmt and Semantic Highlighting in JSON\nDESCRIPTION: Settings related to automatic formatting and styling in rust-analyzer integration. This covers additional rustfmt arguments, overriding the rustfmt command, enabling unstable rustfmt range formatting, and semantic token highlighting configurations (for doc comments, non-standard tokens, operator semantic tokens). These influence code formatting behavior and text coloring/tokenization in IDEs. Dependencies include having rustfmt installed and IDE support for semantic tokens. Inputs are booleans, arrays or nullable strings, affecting formatting rules and syntax highlighting output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.rustfmt.extraArgs\": [],\n  \"rust-analyzer.rustfmt.overrideCommand\": null,\n  \"rust-analyzer.rustfmt.rangeFormatting.enable\": false,\n  \"rust-analyzer.semanticHighlighting.doc.comment.inject.enable\": true,\n  \"rust-analyzer.semanticHighlighting.nonStandardTokens\": true,\n  \"rust-analyzer.semanticHighlighting.operator.enable\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Rust E0161 Using References\nDESCRIPTION: This Rust code demonstrates a common workaround for the E0161 error. By modifying the trait method `f` to accept `self` by reference (`&self`) instead of by value (`self`), it avoids the need to move the underlying `dyn Bar` value. Since references (`&T`) have a fixed, known size at compile time, they can be moved or copied as needed, resolving the compile error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0161.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Bar {\n    fn f(&self);\n}\n\nimpl Bar for i32 {\n    fn f(&self) {}\n}\n\nfn main() {\n    let b: Box<dyn Bar> = Box::new(0i32);\n    b.f();\n    // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Resolution Example 2: Release Borrow Before Move in Rust\nDESCRIPTION: This Rust code snippet provides a solution by rearranging operations so that `ref_to_val` is no longer used before calling `eat`. This allows `eat` to take ownership of `x` as the borrow is no longer active.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0505.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Method Referencing Self Type in Return Example in Rust\nDESCRIPTION: Shows a trait implementation that violates dyn-compatibility by returning Self. This pattern is problematic for trait objects because the concrete return type cannot be determined at compile time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Syncing with Upstream and Creating a Feature Branch in Git\nDESCRIPTION: Demonstrates the initial steps of the standard workflow: switching to the master branch, pulling the latest changes from the upstream repository using a fast-forward-only strategy, and creating a new feature branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout master\ngit pull upstream master --ff-only\ngit checkout -b issue-12345-fix\n```\n\n----------------------------------------\n\nTITLE: Compiling and running a Rust program\nDESCRIPTION: Basic example of compiling and running a 'Hello, World!' program in Rust. This demonstrates the simplicity of getting started with Rust development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ra-salsa/ra-salsa-macros/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nrustc hello.rs\n./hello\n```\n\n----------------------------------------\n\nTITLE: Complex Escaped String Literal in Rust\nDESCRIPTION: A string literal with multiple escape sequences including newline, quote, and backslash characters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/strings.txt#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"\\n\\\"\\\\no escape\"\n```\n\n----------------------------------------\n\nTITLE: Rust Region Canonicalization Example\nDESCRIPTION: Illustrates how region canonicalization works by converting a trait bound with lifetime parameters to its canonicalized form.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/canonicalization.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n&'a (): Trait<'a>\n```\n\n----------------------------------------\n\nTITLE: Malformed instruction_set attribute in Rust (E0778)\nDESCRIPTION: This example demonstrates an incorrect usage of the instruction_set attribute that triggers error E0778. The attribute is provided with empty parentheses, but it requires a specific instruction set parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0778.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(isa_attribute)]\n\n#[instruction_set()] // error: expected one argument\npub fn something() {}\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Overlapping From Implementations Example\nDESCRIPTION: Demonstrates trait implementation overlap with a custom error type and different trait implementations\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coherence.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyCustomErrorType;\n\n// both in your own crate\nimpl From<&str> for MyCustomErrorType {}\nimpl<E> From<E> for MyCustomErrorType where E: Error {}\n```\n\n----------------------------------------\n\nTITLE: Small no_std application example for QNX\nDESCRIPTION: A minimal `no_std` Rust application targeting QNX. This example demonstrates how to create a basic program that links against `libc.so` and uses the `printf` function to print a message to the console. It also includes panic handling and the `eh_personality` function which are required for `no_std` applications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```rust,ignore (platform-specific)\n#![no_std]\n#![no_main]\n#![feature(lang_items)]\n\n// We must always link against libc, even if no external functions are used\n// \"extern C\" - Block can be empty but must be present\n#[link(name = \"c\")]\nextern \"C\" {\n    pub fn printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;\n}\n\n#[no_mangle]\npub extern \"C\" fn main(_argc: core::ffi::c_int, _argv: *const *const u8) -> core::ffi::c_int {\n    const HELLO: &'static str = \"Hello World, the answer is %d\\n\\0\";\n    unsafe {\n        printf(HELLO.as_ptr() as *const _, 42);\n    }\n    0\n}\n\nuse core::panic::PanicInfo;\n\n#[panic_handler]\nfn panic(_panic: &PanicInfo<'_>) -> ! {\n    loop {}\n}\n\n#[lang = \"eh_personality\"]\n#[no_mangle]\npub extern \"C\" fn rust_eh_personality() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Sanitizers in Rust Build Configuration\nDESCRIPTION: This TOML configuration enables building sanitizer runtime libraries as part of the Rust compiler build process. It is added to the bootstrap.toml file to include sanitizers in the build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/sanitizers.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nsanitizers = true\n```\n\n----------------------------------------\n\nTITLE: Positioning Error Annotations Below Error Line in Rust UI Tests\nDESCRIPTION: Shows how to use the //~^ idiom with carets to indicate errors on lines above the annotation. The number of carets corresponds to the number of lines above.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = (1, 2, 3);\n    match x {\n        (_a, _x @ ..) => {}  // <- the error is on this line\n        _ => {}\n    }\n}\n//~^^^^ ERROR `_x @` is not allowed in a tuple\n```\n\n----------------------------------------\n\nTITLE: Squashing All Changes into One Commit\nDESCRIPTION: A two-step process to squash all commits on the current branch relative to master into a single commit. The interactive rebase with `--keep-base` is used first to mark commits for squashing, followed by a regular rebase onto master (which may involve conflict resolution), and finally continuing the rebase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase -i --keep-base master\ngit rebase master\ngit rebase --continue\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Try Blocks in Rust\nDESCRIPTION: This code snippet shows how to use try blocks in Rust. It demonstrates successful and unsuccessful parsing of integers within try blocks, using the ? operator for error propagation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/try-blocks.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(try_blocks)]\n\nuse std::num::ParseIntError;\n\nlet result: Result<i32, ParseIntError> = try {\n    \"1\".parse::<i32>()?\n        + \"2\".parse::<i32>()?\n        + \"3\".parse::<i32>()?\n};\nassert_eq!(result, Ok(6));\n\nlet result: Result<i32, ParseIntError> = try {\n    \"1\".parse::<i32>()?\n        + \"foo\".parse::<i32>()?\n        + \"3\".parse::<i32>()?\n};\nassert!(result.is_err());\n```\n\n----------------------------------------\n\nTITLE: Implementing Postfix Match Pattern in Rust\nDESCRIPTION: Demonstrates the usage of postfix match feature in Rust using an enum example. Shows how to apply pattern matching directly after an expression using the postfix syntax, rather than the traditional match statement format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/postfix-match.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(postfix_match)]\n\nenum Foo {\n    Bar,\n    Baz\n}\n\nfn get_foo() -> Foo {\n    Foo::Bar\n}\n\nget_foo().match {\n    Foo::Bar => {},\n    Foo::Baz => panic!(),\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Non-North Directions as a Group in Rust Pattern Matching\nDESCRIPTION: This example demonstrates how non-North directions can be treated as a single group in pattern matching, simplifying the exhaustiveness check.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Direction { North, South, East, West }\n# let wind = (Direction::North, 0u8);\nmatch wind {\n    (Direction::North, 50..) => {}\n    (_, _) => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configure rust-analyzer Server Path in VS Code (json)\nDESCRIPTION: This JSON snippet should be added to VS Code's settings.json to specify the path to the rust-analyzer language server. It ensures the VS Code extension correctly locates the local rust-analyzer binary. The 'rust-analyzer.server.path' property accepts a string path, with 'rust-analyzer' defaulting to the binary in PATH. Required for running or debugging the extension with a custom or locally-built language server; no further configuration is needed if using the default system install.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"rust-analyzer.server.path\": \"rust-analyzer\"\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building the Rust Standard Library\nDESCRIPTION: This command builds the Rust standard library along with the Rust compiler, utilizing the initial stage compiler created during the process. It is essential for setting up a working environment for compiling other Rust programs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./x build library\n```\n\n----------------------------------------\n\nTITLE: Correct Macro Export and Import in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to export macros from one crate and import them in another. It shows how to use the #[macro_export] attribute and the #[macro_use] attribute properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0469.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// In some_crate crate:\n#[macro_export]\nmacro_rules! eat {\n    ...\n}\n\n#[macro_export]\nmacro_rules! drink {\n    ...\n}\n\n// In your crate:\n#[macro_use(eat, drink)]\nextern crate some_crate; //ok!\n```\n\n----------------------------------------\n\nTITLE: Fixing E0572: Moving Return Inside Function in Rust\nDESCRIPTION: This snippet demonstrates how to fix the E0572 error by either removing the `return` keyword when assigning a constant value or by moving the `return` statement inside a function. The first part shows a correct constant assignment, and the second part shows a function returning the constant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0572.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nconst FOO: u32 = 0;\n\nfn some_fn() -> u32 {\n    return FOO;\n}\n\nfn main() {\n    some_fn();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Fixing E0071 Using Type Annotation in Rust\nDESCRIPTION: This solution fixes the E0071 error by using proper type annotation syntax for the primitive type alias, instead of incorrectly using structure-literal syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0071.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype U32 = u32;\nlet t: U32 = 4;\n```\n\n----------------------------------------\n\nTITLE: Formatting Format String Macros in Rust\nDESCRIPTION: Guidelines for formatting macros that take a format string. If arguments are small, they should appear before and after the format string on a single line; otherwise, each argument should be on its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\n    \"Hello {} and {}\",\n    name1, name2,\n);\n\nassert_eq!(\n    x, y,\n    \"x and y were not equal, see {}\",\n    reason,\n);\n```\n\n----------------------------------------\n\nTITLE: Fixing Enum Overflow by Reordering Variants\nDESCRIPTION: Alternative solution showing how to fix the overflow by reordering enum variants to place the maximum value at the end.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0370.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(i64)]\nenum Foo {\n    Y = 0, // ok!\n    X = 0x7fffffffffffffff,\n}\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly Target Build Locally\nDESCRIPTION: Runs a subset of tests locally for the wasm32-wasip1 target. This shell command utilizes Rust's build system to execute UI tests, libcore tests, and more to ensure compatibility and functionality before deploying the code. It's particularly useful for verifying changes in development environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./x.py test --target wasm32-wasip1 tests/ui\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Trait Bound in Rust\nDESCRIPTION: This code snippet defines a generic function `convertAll` that takes a slice of type `T` and converts each element to type `A`, where `T` implements the `ConvertTo<A>` trait. The ellipsis indicates that the actual implementation is omitted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"fn convertAll<A,T:ConvertTo<A>>(v: &[T]) { ... }\"\n```\n\n----------------------------------------\n\nTITLE: Generating Coverage Reports with llvm-cov show\nDESCRIPTION: This shell command uses `llvm-cov show` to display detailed line and region coverage of a Rust binary, overlaid on the source code. Key options include demangling Rust symbols, specifying the instrumented binary, and filtering coverage display by function name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ llvm-cov show -Xdemangler=rustfilt target/debug/examples/formatjson5 \\\n    -instr-profile=formatjson5.profdata \\\n    -show-line-counts-or-regions \\\n    -show-instantiations \\\n    -name=add_quoted_string\n```\n\n----------------------------------------\n\nTITLE: Using concat_idents Macro in Rust\nDESCRIPTION: This example demonstrates how to use the concat_idents macro to combine multiple identifiers into one. It creates a function named foobar(), then uses concat_idents!(foo, bar) to obtain a reference to that function and call it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/concat-idents.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(concat_idents)]\n\nfn main() {\n    fn foobar() -> u32 { 23 }\n    let f = concat_idents!(foo, bar);\n    assert_eq!(f(), 23);\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Statement Formatting\nDESCRIPTION: Shows how to properly terminate expressions in statement position\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nan_expression();\nexpr_as_value()\n```\n\n----------------------------------------\n\nTITLE: Failing Coroutine Example (E0626)\nDESCRIPTION: This code demonstrates the E0626 error.  A borrow `a` is created within the coroutine and is still in scope when the `yield` occurs, causing a compilation error. The coroutine is movable (unmarked or implicitly movable).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] || {\n    let a = &String::new(); // <-- This borrow...\n    yield (); // ...is still in scope here, when the yield occurs.\n    println!(\"{}\", a);\n};\nPin::new(&mut b).resume(());\n```\n\n----------------------------------------\n\nTITLE: Function with Lifetime References for Demangling\nDESCRIPTION: Example Rust function showing how lifetimes are used in type parameters. This illustrates how lifetimes are encoded and later demangled in the symbol names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    example::<fn(&u8, &u16)>();\n}\n\npub fn example<T>() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0584 Error with Misplaced Doc Comments in Rust\nDESCRIPTION: This code example shows the incorrect placement of a doc comment inside a trait definition rather than before the item it documents, resulting in compile error E0584.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0584.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Island {\n    fn lost();\n\n    /// I'm lost!\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Move Value into Coroutine\nDESCRIPTION: This code fixes the E0626 error by removing the borrow and storing the type by value. This prevents any borrows from persisting across the yield point. The coroutine remains movable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] || {\n    let a = String::from(\"hello, world\");\n    yield ();\n    println!(\"{}\", a);\n};\nPin::new(&mut b).resume(());\n```\n\n----------------------------------------\n\nTITLE: Using the unstable attribute in Rust\nDESCRIPTION: The #[unstable] attribute marks an item as unstable, requiring a feature flag to use across crate boundaries. It includes a feature name, associated GitHub issue number, and reason for instability. The attribute infects all sub-items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stability.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[unstable(feature = \"foo\", issue = \"1234\", reason = \"lorem ipsum\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing Parent Module Lookup in Rust\nDESCRIPTION: This Rust code snippet demonstrates how the parent module information is stored and retrieved in the search index. It iterates through the search index entries and updates the parent module based on the 'q' field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut parent_module = \"\";\nfor (i, entry) in search_index.iter().enumerate() {\n    if q.contains(i) {\n        parent_module = q.get(i);\n    }\n    // ... do other stuff with `entry` ...\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Multiple Closures Borrowing Mutably\nDESCRIPTION: This code snippet demonstrates a compile-time error in Rust where two closures attempt to mutably borrow the same variable `x` simultaneously. This is not allowed due to Rust's ownership and borrowing rules, which enforce exclusive mutable access to prevent data races.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0524.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0524\nfn set(x: &mut isize) {\n    *x += 4;\n}\n\nfn dragoooon(x: &mut isize) {\n    let mut c1 = || set(x);\n    let mut c2 = || set(x); // error!\n\n    c2();\n    c1();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring check-incompatible-msrv-in-tests\nDESCRIPTION: Determines whether to check for Minimum Supported Rust Version (MSRV) compatibility within `#[test]` and `#[cfg(test)]` code blocks.  Defaults to `false`. Enabling this helps ensure tests are compatible with the specified MSRV.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Formatting Example: Style Edition 2015 vs 2024 - Import Sorting\nDESCRIPTION: Shows how import statements are sorted differently between style_edition 2015 and 2024 using version sorting algorithm.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// with style_edition=2015\nuse std::num::{NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8};\n\n// with style_edition=2024\nuse std::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64};\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Include File Size in Rust\nDESCRIPTION: This option sets the maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes, before the `large_include_file` lint is triggered. The default value is `1000000`. The input is an integer, representing the maximum allowed file size in bytes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_27\n\n\n\n----------------------------------------\n\nTITLE: Resolving Method Call Ambiguity by Removing Duplicate Methods\nDESCRIPTION: This code snippet demonstrates how to resolve the method call ambiguity by keeping only one implementation of the method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0034.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Single-Field Struct with SIMD Attribute\nDESCRIPTION: Example showing correct usage of #[repr(simd)] on a struct with a single array field, which is the proper way to define SIMD vector types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0075.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good([u32; 2]); // ok!\n```\n\n----------------------------------------\n\nTITLE: Handling Namespace Conflicts with Ribs in Rust\nDESCRIPTION: Illustrates the concept of 'Ribs' for scope management in the Rust compiler, exploring how different namespaces are managed and resolved. The code shows how variable 'val' and 'helper' function are scoped, introducing new 'Ribs' as needed during compilation. This snippet requires understanding of Rust's scoping and namespace principles, but no additional dependencies. It highlights the manipulation of scoping stacks ('Ribs') to resolve potential name conflicts, limiting access to variables based on scope boundaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/name-resolution.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn do_something<T: Default>(val: T) { // <- New rib in both types and values (1)\n    // `val` is accessible, as is the helper function\n    // `T` is accessible\n   let helper = || { // New rib on the block (2)\n        // `val` is accessible here\n    }; // End of (2), new rib on `helper` (3)\n    // `val` is accessible, `helper` variable shadows `helper` function\n    fn helper() { // <- New rib in both types and values (4)\n        // `val` is not accessible here, (4) is not transparent for locals\n        // `T` is not accessible here\n    } // End of (4)\n    let val = T::default(); // New rib (5)\n    // `val` is the variable, not the parameter here\n} // End of (5), (3) and (1)\n```\n\n----------------------------------------\n\nTITLE: Complete Auto Trait Implementation Example in Rust\nDESCRIPTION: Shows a complete example of defining and using an auto trait with positive and negative implementations, demonstrating compile-time validation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/auto-traits.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(negative_impls)]\n#![feature(auto_traits)]\n\nauto trait Valid {}\n\nstruct True;\nstruct False;\n\nimpl !Valid for False {}\n\nstruct MaybeValid<T>(T);\n\nfn must_be_valid<T: Valid>(_t: T) { }\n\nfn main() {\n    // works\n    must_be_valid( MaybeValid(True) );\n\n    // compiler error - trait bound not satisfied\n    // must_be_valid( MaybeValid(False) );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compile Flags Directive in Rust Test\nDESCRIPTION: Example showing how to use the compile-flags directive to disable overflow checks in a Rust test. The directive is specified using //@ syntax and affects how rustc compiles the test.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/directives.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Test the behavior of `0 - 1` when overflow checks are disabled.\n\n//@ compile-flags: -C overflow-checks=off\n\nfn main() {\n    let x = 0 - 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Backtrace in Miri with Environment Variables\nDESCRIPTION: This shell command demonstrates how to enable backtraces when running Miri tests by setting the `RUST_BACKTRACE` environment variable and disabling isolation using the `-Zmiri-disable-isolation` flag.  This is necessary because Miri isolates the environment by default, preventing the `RUST_BACKTRACE` variable from being passed to the program.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nRUST_BACKTRACE=1 MIRIFLAGS=\"-Zmiri-disable-isolation\" cargo miri test\n```\n\n----------------------------------------\n\nTITLE: String Literal Formatting Options\nDESCRIPTION: Shows how string literal formatting can be controlled in Rust code\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = \"ipsum dolor sit amet consectetur adipiscing elit lorem ipsum dolor sit amet consectetur adipiscing\";\n}\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Structs in Rust\nDESCRIPTION: This code snippet demonstrates how to re-export structs from private modules in Rust. The `sub_module1` and `sub_module2` are defined as private, and their respective structs (`Foo` and `AnotherFoo`) are re-exported to the crate root using `pub use`. This makes the structs available directly without exposing the module structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// `sub_module1` and `sub_module2` are not visible outside.\nmod sub_module1 {\n    pub struct Foo;\n}\nmod sub_module2 {\n    pub struct AnotherFoo;\n}\n// We re-export both types:\npub use crate::sub_module1::Foo;\npub use crate::sub_module2::AnotherFoo;\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Using Trait in Rust\nDESCRIPTION: This code snippet shows the correct way to implement a method for a primitive type (*mut Foo) using a trait in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0390.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32\n}\n\ntrait Bar {\n    fn bar();\n}\n\nimpl Bar for *mut Foo {\n    fn bar() {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Theme to Rustdoc Output (Bash)\nDESCRIPTION: This example shows how to use the --theme flag to add a custom CSS theme to the rustdoc output. The theme name is derived from the filename of the CSS file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --theme /path/to/your/custom-theme.css\n```\n\n----------------------------------------\n\nTITLE: Adding Error Annotations to Rust UI Tests\nDESCRIPTION: Shows how to annotate expected compiler errors in UI tests using error annotation comments. This technique is essential for ensuring tests correctly validate error messages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/adding.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn bar() {\n    foo().await\n    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Rust Compiler Error E0284 with Explicit Type Annotation\nDESCRIPTION: This code snippet demonstrates how to resolve the E0284 error by explicitly specifying the intermediate type. It converts the u32 value to u64 before addition, eliminating ambiguity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0284.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    let m: u64 = n.into();\n    d = d + m;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of not Predicate in cfg Attribute\nDESCRIPTION: This code snippet shows a valid usage of the cfg attribute with the not predicate, allowing conditional function definition based on the target operating system in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0537.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(not(target_os = \"linux\"))] // ok!\npub fn something() {}\n\npub fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Parameter Usage in Rust Type Bounds\nDESCRIPTION: Example showing incorrect usage of function names and arguments in use<...> bounds where only type and const parameters are allowed. The code demonstrates two cases that trigger E0799: using a function name and using a function parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0799.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn bad1() -> impl Sized + use<main> {}\n\nfn bad2(x: ()) -> impl Sized + use<x> {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Fixing Private Trait Error in Rust\nDESCRIPTION: Corrected version showing proper usage by making the trait public. Demonstrates how to properly use traits in public interfaces by marking the base trait as public while maintaining the same functionality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0445.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait Foo { // we set the Foo trait public\n    fn dummy(&self) { }\n}\n\npub trait Bar : Foo {} // ok!\npub struct Bar2<T: Foo>(pub T); // ok!\npub fn foo<T: Foo> (t: T) {} // ok!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Break Statement Without Label\nDESCRIPTION: Example showing erroneous code where a break statement appears inside a labeled block without specifying the label. This causes compilation error E0695.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0695.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    'a: {\n        break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unused Variable Lint in Rust\nDESCRIPTION: Example showing how the Rust compiler warns about unused variables using the unused_variables lint. The code declares an unused variable 'x' and shows the resulting compiler warning.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cat main.rs\nfn main() {\n    let x = 5;\n}\n$ rustc main.rs\nwarning: unused variable: `x`\n --> main.rs:2:9\n  |\n2 |     let x = 5;\n  |         ^\n  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: to avoid this warning, consider using `_x` instead\n```\n\n----------------------------------------\n\nTITLE: Parallel Iterators Usage in Rust Compiler - Rust\nDESCRIPTION: This section details the usage of parallel iterators through the `rayon` crate in the Rust compiler. Several iterator functions are utilized to execute loops in parallel when the `parallel-compiler` feature is enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/parallel-rustc.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n| Function(Omit `Send` and `Sync`)                             | Introduction                                                 | Owning Module              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |\n| **par_iter**<T: IntoParallelIterator>(t: T) -> T::Iter       | generate a parallel iterator                                 | rustc_data_structure::sync |\n| **par_for_each_in**<T: IntoParallelIterator>(t: T, for_each: impl Fn(T::Item)) | generate a parallel iterator and run `for_each` on each element | rustc_data_structure::sync |\n| **Map::par_body_owners**(self, f: impl Fn(LocalDefId))       | run `f` on all hir owners in the crate                       | rustc_middle::hir::map     |\n| **Map::par_for_each_module**(self, f: impl Fn(LocalDefId))   | run `f` on all modules and submodules in the crate           | rustc_middle::hir::map     |\n| **ModuleItems::par_items**(&self, f: impl Fn(ItemId))        | run `f` on all items in the module                           | rustc_middle::hir          |\n| **ModuleItems::par_trait_items**(&self, f: impl Fn(TraitItemId)) | run `f` on all trait items in the module                     | rustc_middle::hir          |\n| **ModuleItems::par_impl_items**(&self, f: impl Fn(ImplItemId)) | run `f` on all impl items in the module                      | rustc_middle::hir          |\n| **ModuleItems::par_foreign_items**(&self, f: impl Fn(ForeignItemId)) | run `f` on all foreign items in the module                   | rustc_middle::hir          |\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_2 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_2` function in Rust, passing an integer (16) and a floating-point number (3.5) as arguments.  It demonstrates using mixed data types and the `fastcall` calling convention. The expected output is contingent on the code within the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_2(16, 3.5)\n```\n\n----------------------------------------\n\nTITLE: Specifying the linker plugin path with rustc\nDESCRIPTION: This snippet shows how to explicitly specify the path to the LLVM linker plugin using the `-Clinker-plugin-lto` option with `rustc`. This is necessary when using a linker other than LLD.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n\"rustc -Clinker-plugin-lto=\\\"/path/to/LLVMgold.so\\\" -L. -Copt-level=2 ./main.rs\"\n```\n\n----------------------------------------\n\nTITLE: Generating 'try_into_' Method for Enum Variant in Rust\nDESCRIPTION: This snippet demonstrates how to generate a 'try_into_' method for an enum variant. It creates an impl block with a method that attempts to convert the enum into the specified variant's inner type, returning a Result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_50\n\nLANGUAGE: rust\nCODE:\n```\nenum Value {\n Number(i32),\n Text(String),\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Value {\n Number(i32),\n Text(String),\n}\n\nimpl Value {\n    fn try_into_text(self) -> Result<String, Self> {\n        if let Self::Text(v) = self {\n            Ok(v)\n        } else {\n            Err(self)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Lifetime Binding in Function\nDESCRIPTION: Resolves the lifetime parameter issue by either introducing the lifetime in input types or using `'static` lifetime\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0582.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn bar<F, G>(t: F, u: G)\n    where F: for<'a> Fn(&'a i32) -> Option<&'a i32>,\n          G: Fn(i32) -> Option<&'static i32>,\n{\n}\n\nfn main() { }\n```\n\n----------------------------------------\n\nTITLE: Invalid CoerceUnsized Implementation with Multiple Unsized Fields\nDESCRIPTION: Demonstrates an erroneous implementation of CoerceUnsized on a struct containing multiple unsized fields (T and U). This code fails because the compiler cannot determine how to handle multiple unsized fields during coercion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0375.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo<T: ?Sized, U: ?Sized> {\n    a: i32,\n    b: T,\n    c: U,\n}\n\n// error: Struct `Foo` has more than one unsized field.\nimpl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Control Flow in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for control flow statements. In this style, each condition is indented to the same level, creating a block-like structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if lorem_ipsum\n        && dolor_sit\n        && amet_consectetur\n        && lorem_sit\n        && dolor_consectetur\n        && amet_ipsum\n        && lorem_consectetur\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Union with Destructor - Compile Fail (E0740)\nDESCRIPTION: This Rust code snippet demonstrates a compile-time error E0740.  It defines a union `Test` containing a field `a` of type `A`. The struct `A` implements the `Drop` trait, thus having a destructor. Unions are not allowed to contain fields with destructors because Rust cannot reliably determine when to call them, leading to undefined behavior and memory unsafety. This results in a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0740.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunion Test {\n    a: A, // error!\n}\n\n#[derive(Debug)]\nstruct A(i32);\n\nimpl Drop for A {\n    fn drop(&mut self) { println!(\"A\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Type Inference Instead of Annotation in Closure\nDESCRIPTION: This snippet provides an alternative code example where the closure parameter's type is inferred by the Rust compiler. It avoids the lifetime issue present in the previous example by omitting type annotations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0521.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut list: Vec<&str> = Vec::new();\n\nlet _add = |el| {\n    list.push(el);\n};\n```\n\n----------------------------------------\n\nTITLE: Embedding Bitcode in Rust\nDESCRIPTION: Controls whether LLVM bitcode is embedded in object files (rlibs). Accepts `y`, `yes`, `on`, `true` (default) or `n`, `no`, `off`, `false`. Bitcode is required for LTO.  Using `-C embed-bitcode=no` can improve compile times if LTO isn't being used. If combined with `-C lto`, the compiler will abort at start-up.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Using rustc_interface::run_compiler in Rust\nDESCRIPTION: The main entry point of rustc_interface, which takes a compiler configuration and a closure with an unresolved Compiler to manually drive the compilation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nrustc_interface::run_compiler\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Definition AST Node - Rust\nDESCRIPTION: This snippet implements the `FnDef` struct conforming to the `AstNode` trait. It enables further functionalities such as retrieving the parameter list, return type, and function body from the function definition node. Each method showcases how to interact with the AST in a type-safe manner.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct FnDef {\n    syntax: SyntaxNode,\n}\n\nimpl AstNode for FnDef {\n    fn cast(syntax: SyntaxNode) -> Option<Self> {\n        match kind {\n            FN => Some(FnDef { syntax }),\n            _ => None,\n        }\n    }\n    fn syntax(&self) -> &SyntaxNode {\n        &self.syntax\n    }\n}\n\nimpl FnDef {\n    pub fn param_list(&self) -> Option<ParamList> {\n        self.syntax.children().find_map(ParamList::cast)\n    }\n    pub fn ret_type(&self) -> Option<RetType> {\n        self.syntax.children().find_map(RetType::cast)\n    }\n    pub fn body(&self) -> Option<BlockExpr> {\n        self.syntax.children().find_map(BlockExpr::cast)\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Evaluating Root Goal in Rust Trait Solver\nDESCRIPTION: The entry point of the solver is the evaluate_root_goal function, which sets up the root EvalCtxt and calls evaluate_goal to enter the trait solver. This function handles canonicalization, caching, overflow, and solver cycles.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/the-solver.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nInferCtxtEvalExt::evaluate_root_goal\n```\n\n----------------------------------------\n\nTITLE: Highlighting Stability Attribute Error in Rust\nDESCRIPTION: This code snippet illustrates a common error found when the 'feature' attribute is missing from stability annotations in Rust. It showcases an invalid application of Rust's stability attributes, where the 'feature' is omitted from both unstable and stable function declarations. This results in a compile error E0546.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0546.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(issue = \\\"none\\\")] // invalid\\nfn unstable_fn() {}\\n\\n#[stable(since = \\\"1.0.0\\\")] // invalid\\nfn stable_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unterminated Double Quote String in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to terminate a double quote string in Rust. By adding the missing closing double quote, the code compiles successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0765.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"\"; // ok!\n```\n\n----------------------------------------\n\nTITLE: Inlining a Function into All Callers in Rust\nDESCRIPTION: Demonstrates inlining a function's body into all places where it's called, preserving the function's logic. This example shows how a conditional print function gets inlined into its calling function, allowing the original function to be removed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_68\n\nLANGUAGE: rust\nCODE:\n```\nfn print(_: &str) {}\nfn foo┃(word: &str) {\n    if !word.is_empty() {\n        print(word);\n    }\n}\nfn bar() {\n    foo(\"안녕하세요\");\n    foo(\"여러분\");\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn print(_: &str) {}\n\nfn bar() {\n    {\n        let word: &str = \"안녕하세요\";\n        if !word.is_empty() {\n            print(word);\n        }\n    };\n    {\n        let word: &str = \"여러분\";\n        if !word.is_empty() {\n            print(word);\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Placeholder Usage in Rust Signatures\nDESCRIPTION: Examples showing incorrect usage of type placeholder (_) in function return types and static variable declarations. These cases will result in compilation error E0121.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0121.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> _ { 5 } // error\n\nstatic BAR: _ = \"test\"; // error\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Implementation in Rust\nDESCRIPTION: This code snippet shows an incorrect implementation of a trait where a constant is mistakenly implemented as a method, resulting in a compilation error E0324.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0324.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n\n    fn M();\n}\n\nimpl Foo for Bar {\n    fn N() {}\n    // error: item `N` is an associated method, which doesn't match its\n    //        trait `<Bar as Foo>`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring No-Sysroot Test Suite in Rust Build System\nDESCRIPTION: Configuration section for test suite components that don't require a sysroot. Each line represents a test that will be run by default, but can be commented out to skip individual tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/config.txt#2025-04-21_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\ntestsuite.no_sysroot\nbuild.mini_core\nbuild.example\njit.mini_core_hello_world\naot.mini_core_hello_world\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unresolved Name Errors in Rust\nDESCRIPTION: Examples of code that will fail to compile due to unresolved names, including undefined module access, invalid Self usage, and unknown variable references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0425.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\n----------------------------------------\n\nTITLE: Defining a Library Crate - Rust\nDESCRIPTION: This snippet defines a Rust library crate using the `#[crate_type = \"lib\"]` attribute. The code snippet demonstrates how to declare a library crate which will be used as a dependency in other crates. It does not take any parameters or produce any output by itself. It's a fundamental part of the Rust build process, specifying the crate type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0514.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// compiled with stable `rustc`\n\n#[crate_type = \"lib\"]\n```\n\n----------------------------------------\n\nTITLE: Fixing Struct Constructor Error by Making All Fields Public in Rust\nDESCRIPTION: This solution demonstrates how to fix the struct constructor error by making all fields of the struct public.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0451.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod bar {\n    pub struct Foo {\n        pub a: isize,\n        pub b: isize, // we set `b` field public\n    }\n}\n\nlet f = bar::Foo{ a: 0, b: 0 }; // ok!\n```\n\n----------------------------------------\n\nTITLE: Overflow Delimited Expressions in Rust\nDESCRIPTION: Demonstrates the effect of the overflow_delimited_expr option on formatting structs, slices, and arrays in function calls.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_58\n\nLANGUAGE: rust\nCODE:\n```\nfn example() {\n    foo(ctx, |param| {\n        action();\n        foo(param)\n    });\n\n    foo(\n        ctx,\n        Bar {\n            x: value,\n            y: value2,\n        },\n    );\n\n    foo(\n        ctx,\n        &[\n            MAROON_TOMATOES,\n            PURPLE_POTATOES,\n            ORGANE_ORANGES,\n            GREEN_PEARS,\n            RED_APPLES,\n        ],\n    );\n\n    foo(\n        ctx,\n        vec![\n            MAROON_TOMATOES,\n            PURPLE_POTATOES,\n            ORGANE_ORANGES,\n            GREEN_PEARS,\n            RED_APPLES,\n        ],\n    );\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn example() {\n    foo(ctx, |param| {\n        action();\n        foo(param)\n    });\n\n    foo(ctx, Bar {\n        x: value,\n        y: value2,\n    });\n\n    foo(ctx, &[\n        MAROON_TOMATOES,\n        PURPLE_POTATOES,\n        ORGANE_ORANGES,\n        GREEN_PEARS,\n        RED_APPLES,\n    ]);\n\n    foo(ctx, vec![\n        MAROON_TOMATOES,\n        PURPLE_POTATOES,\n        ORGANE_ORANGES,\n        GREEN_PEARS,\n        RED_APPLES,\n    ]);\n}\n```\n\n----------------------------------------\n\nTITLE: Negative Implementation Syntax for Auto Traits in Rust\nDESCRIPTION: Demonstrates the syntax for creating a negative implementation of an auto trait for a specific type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/auto-traits.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl !Trait for Type {}\n```\n\n----------------------------------------\n\nTITLE: Correct Handling of Packed Struct Field Access in Rust\nDESCRIPTION: This example shows the proper way to handle packed struct field access using raw pointers with explicit unaligned reads and creating copies to avoid direct references. It demonstrates both safe patterns for accessing and formatting packed field values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0793.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Reference Lifetime with Scoped Block\nDESCRIPTION: Shows how to manage references by limiting their scope, allowing mutation after the reference is no longer active\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0506.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\n----------------------------------------\n\nTITLE: Single Lifetime Argument Future Compatibility Warnings\nDESCRIPTION: Shows cases where specifying a single lifetime argument results in future compatibility warnings rather than errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nFoo.trait_method::<'static>(&(), &());\nFoo::trait_method::<'static>(Foo, &(), &());\nFoo::trait_function::<'static>(&(), &());\nFoo.inherent_method::<'static>(&(), &());\nFoo::inherent_function::<'static>(&(), &());\nfree_function::<'static>(&(), &());\n```\n\n----------------------------------------\n\nTITLE: Desugared Trait Definition with GAT\nDESCRIPTION: This Rust code shows the desugared version of the trait definition using a GAT (Generic Associated Type). It highlights the `assumed wf` bound required for the GAT to be well-formed, which is inherited from the trait method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait FooDesugared {\n    type Iter<'a, T>: Iterator<Item = &'a T>;\n    //~^ assumed wf: `&'a [T]`\n    // Without assumed wf types, the GAT would not be well-formed on its own.\n\n    fn iter<'a, T>(x: &'a [T]) -> Self::Iter<'a, T>;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example of Method Calls on Unconstrained Opaque Types\nDESCRIPTION: Demonstrates a case where methods are called on an unconstrained opaque type within its defining scope. This example shows recursive async function that returns an opaque Future type, where the concrete type isn't yet known when methods are called on it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/opaque-types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\nuse futures::FutureExt;\n\nfn go(i: usize) -> impl Future<Output = ()> + Send + 'static {\n    async move {\n        if i != 0 {\n            // This returns `impl Future<Output = ()>` in its defining scope,\n            // we don't know the concrete type of that opaque at this point.\n            // Currently treats the opaque as a known type and succeeds, but\n            // from the perspective of \"easiest to soundly implement\", it would\n            // be good for this to be ambiguous.\n            go(i - 1).boxed().await;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Heap Allocation in Rust Constant\nDESCRIPTION: Demonstrates an erroneous attempt to initialize a constant with a Vec, which is not allowed because Vec requires heap allocation at runtime. This code will fail to compile with error E0010.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0010.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst CON : Vec<i32> = vec![1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Tuple Struct Declaration and Instantiation in Rust\nDESCRIPTION: Shows single-line formatting for tuple struct declarations and instantiations.  Highlights how to write the type list and instantiate the tuple structs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar(Type1, Type2);\n\nlet x = Bar(11, 22);\nlet y = (11, 22, 33);\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Implementing Copy Trait in Rust\nDESCRIPTION: Shows an alternative solution by implementing the Copy trait for the structure, which allows mixing by-move and by-ref bindings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0009.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy)]\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((y, ref z)) => {},\n    None => panic!()\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Alternative Using Newtype Wrapper and Receiver Trait\nDESCRIPTION: Shows the recommended approach to handle raw pointer receivers using a newtype wrapper that implements the core::ops::Receiver trait. This approach requires only the arbitrary_self_types feature rather than arbitrary_self_types_pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types-pointers.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types)]\n#![allow(dead_code)]\n\nstruct A;\n\nimpl A {\n    fn m(self: Wrapper<Self>) {} // can extract the pointer and do\n        // what it needs\n}\n\nstruct Wrapper<T>(*const T);\n\nimpl<T> core::ops::Receiver for Wrapper<T> {\n    type Target = T;\n}\n\nfn main() {\n    let a = A;\n    let a_ptr: *const A = &a as *const A;\n    let a_wrapper = Wrapper(a_ptr);\n    a_wrapper.m();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Profile Sample Flag in Rust Compiler\nDESCRIPTION: Example showing the usage of -Zprofile-sample-use compiler flag to specify a profile file for AFDO optimization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/profile_sample_use.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Zprofile-sample-use=code.prof\n```\n\n----------------------------------------\n\nTITLE: Illustrating Impl Path Symbol Mangling in Rust\nDESCRIPTION: Demonstrates how multiple impl blocks for the same struct are differentiated using disambiguators in the symbol mangling process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Example;\nimpl Example {\n    fn foo() {}\n}\nimpl Example {\n    fn bar() {}\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNvMCs7qp2U7fqm6G_7mycrateNtB2_7Example3foo\n     └─────────┬──────────┘\n               │\n               └── path to the impl's parent crate-root \"mycrate\"\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNvMs_Cs7qp2U7fqm6G_7mycrateNtB4_7Example3bar\n     ├┘└─────────┬──────────┘\n     │           │\n     │           └── path to the impl's parent crate-root \"mycrate\"\n     └────────────── disambiguator 1\n```\n\n----------------------------------------\n\nTITLE: Simplified Code After Feature Stabilization\nDESCRIPTION: Examples of how code is simplified after a feature is stabilized. The feature flag checks are removed, assuming the feature is always enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n/* XXX */\n```\n\nLANGUAGE: rust\nCODE:\n```\nif something { /* XXX */ }\n```\n\n----------------------------------------\n\nTITLE: Valid Single Self Import Example\nDESCRIPTION: Correct example showing proper usage of a single 'self' import in an import list.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0430.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# mod something {}\\n# fn main() {\\nuse something::{self}; // ok!\\n# }\n```\n\n----------------------------------------\n\nTITLE: Rust 2018 External Crate Import\nDESCRIPTION: Shows the simplified import syntax in Rust 2018 which doesn't require extern crate declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0432.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Trait for Visibility in AST Nodes - Rust\nDESCRIPTION: This snippet defines the `HasVisibility` trait, which adds functionality to AST nodes to retrieve visibility information. It implements this trait for the `FnDef` type, showing how to extract visibility attributes from function definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntrait HasVisibility: AstNode {\n    fn visibility(&self) -> Option<Visibility>;\n}\n\nimpl HasVisibility for FnDef {\n    fn visibility(&self) -> Option<Visibility> {\n        self.syntax.children().find_map(Visibility::cast)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Projections and Variances with RPITIT\nDESCRIPTION: This Rust code illustrates a limitation of RPITITs related to projections and variances.  It shows how RPITITs, unlike regular opaque types, don't inherently have variances, leading to errors when comparing RPITITs with different lifetimes, even if those lifetimes aren't captured.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(return_position_impl_trait_in_trait)]\n\ntrait Foo {\n    // Note that the RPITIT below does *not* capture `'lt`.\n    fn bar<'lt: 'lt>() -> impl Eq;\n}\n\nfn test<'a, 'b, T: Foo>() -> bool {\n    <T as Foo>::bar::<'a>() == <T as Foo>::bar::<'b>()\n    //~^ ERROR\n    // (requires that `'a == 'b`)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Type Parameter Error in Rust\nDESCRIPTION: This code snippet illustrates an error where a generic struct is used without specifying its type parameter. The struct 'Foo' is defined with a type parameter 'T', but when used in the 'Bar' struct, the type parameter is omitted, which would have previously triggered the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0243.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }\n```\n\n----------------------------------------\n\nTITLE: Using the temps-dir compiler flag in Rust\nDESCRIPTION: The -Ztemps-dir flag specifies a directory for Rust compiler intermediate files. This is useful when running multiple rustc instances to prevent file conflicts. Note that intermediate files are not kept unless -C save-temps=yes is also set.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/temps-dir.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Ztemps-dir\n```\n\n----------------------------------------\n\nTITLE: Diagnostic JSON Structure Example in JavaScript\nDESCRIPTION: Demonstrates the complete JSON structure of a rustc diagnostic message, including spans, children messages, and rendered output. The example shows an unused variable warning with suggestions for fixing the issue.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/json.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    \"$message_type\": \"diagnostic\",\n    \"message\": \"unused variable: `x`\",\n    \"code\": {\n        \"code\": \"unused_variables\",\n        \"explanation\": null\n    },\n    \"level\": \"warning\",\n    \"spans\": [\n        {\n            \"file_name\": \"lib.rs\",\n            \"byte_start\": 21,\n            \"byte_end\": 22,\n            \"line_start\": 2,\n            \"line_end\": 2,\n            \"column_start\": 9,\n            \"column_end\": 10,\n            \"is_primary\": true,\n            \"text\": [\n                {\n                    \"text\": \"    let x = 123;\",\n                    \"highlight_start\": 9,\n                    \"highlight_end\": 10\n                }\n            ],\n            \"label\": null,\n            \"suggested_replacement\": null,\n            \"suggestion_applicability\": null,\n            \"expansion\": {\n                \"span\": {},\n                \"macro_decl_name\": \"some_macro!\",\n                \"def_site_span\": {}\n            }\n        }\n    ],\n    \"children\": [\n        {\n            \"message\": \"`#[warn(unused_variables)]` on by default\",\n            \"code\": null,\n            \"level\": \"note\",\n            \"spans\": [],\n            \"children\": [],\n            \"rendered\": null\n        },\n        {\n            \"message\": \"if this is intentional, prefix it with an underscore\",\n            \"code\": null,\n            \"level\": \"help\",\n            \"spans\": [\n                {\n                    \"file_name\": \"lib.rs\",\n                    \"byte_start\": 21,\n                    \"byte_end\": 22,\n                    \"line_start\": 2,\n                    \"line_end\": 2,\n                    \"column_start\": 9,\n                    \"column_end\": 10,\n                    \"is_primary\": true,\n                    \"text\": [\n                        {\n                            \"text\": \"    let x = 123;\",\n                            \"highlight_start\": 9,\n                            \"highlight_end\": 10\n                        }\n                    ],\n                    \"label\": null,\n                    \"suggested_replacement\": \"_x\",\n                    \"suggestion_applicability\": \"MachineApplicable\",\n                    \"expansion\": null\n                }\n            ],\n            \"children\": [],\n            \"rendered\": null\n        }\n    ],\n    \"rendered\": \"warning: unused variable: `x`\\n --> lib.rs:2:9\\n  |\\n2 |     let x = 123;\\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\\n  |\\n  = note: `#[warn(unused_variables)]` on by default\\n\\n\"\n}\n```\n\n----------------------------------------\n\nTITLE: Doctest Compilation Performance Metrics for Rust Core Library\nDESCRIPTION: Shows performance metrics from running doctests on the Rust core library, highlighting the significant time spent on compilation versus runtime execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nwall-time duration: 102s\ntotal compile time: 775.204s\ntotal runtime: 15.487s\n```\n\n----------------------------------------\n\nTITLE: Enabling Precise Capture based on Edition and Feature Gate in Rust\nDESCRIPTION: This code snippet demonstrates how to conditionally enable a feature (precise capture) based on both a feature gate and the Rust edition. It checks if the `capture_disjoint_fields` feature is enabled or if the code is being compiled in Rust 2021 or later.  This allows for gradual adoption of features across edition boundaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/guides/editions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// An example from Edition 2021 disjoint closure captures.\n\nfn enable_precise_capture(tcx: TyCtxt<'_>, span: Span) -> bool {\n    tcx.features().capture_disjoint_fields || span.rust_2021()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Git Submodule for LLVM\nDESCRIPTION: Updates the 'src/llvm-project' submodule to the latest version available on the remote repository. This is a key step to include the backported fixes or the new LLVM release in the Rust project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_2\n\nLANGUAGE: git\nCODE:\n```\n\"git submodule update --remote src/llvm-project\"\n```\n\n----------------------------------------\n\nTITLE: Custom Completion Snippets Configuration\nDESCRIPTION: Defines custom completion snippets for rust-analyzer. These snippets allow wrapping expressions with common constructs like `Ok`, `Box::pin`, `Arc::new`, `Some`, `Err`, and `Rc::new`.  Each snippet includes a postfix, body, description, scope (typically `expr`), and optional requirements (e.g., a required crate import).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"Ok\": {\n    \"postfix\": \"ok\",\n    \"body\": \"Ok(${receiver})\",\n    \"description\": \"Wrap the expression in a `Result::Ok`\",\n    \"scope\": \"expr\"\n  },\n  \"Box::pin\": {\n    \"postfix\": \"pinbox\",\n    \"body\": \"Box::pin(${receiver})\",\n    \"requires\": \"std::boxed::Box\",\n    \"description\": \"Put the expression into a pinned `Box`\",\n    \"scope\": \"expr\"\n  },\n  \"Arc::new\": {\n    \"postfix\": \"arc\",\n    \"body\": \"Arc::new(${receiver})\",\n    \"requires\": \"std::sync::Arc\",\n    \"description\": \"Put the expression into an `Arc`\",\n    \"scope\": \"expr\"\n  },\n  \"Some\": {\n    \"postfix\": \"some\",\n    \"body\": \"Some(${receiver})\",\n    \"description\": \"Wrap the expression in an `Option::Some`\",\n    \"scope\": \"expr\"\n  },\n  \"Err\": {\n    \"postfix\": \"err\",\n    \"body\": \"Err(${receiver})\",\n    \"description\": \"Wrap the expression in a `Result::Err`\",\n    \"scope\": \"expr\"\n  },\n  \"Rc::new\": {\n    \"postfix\": \"rc\",\n    \"body\": \"Rc::new(${receiver})\",\n    \"requires\": \"std::rc::Rc\",\n    \"description\": \"Put the expression into an `Rc`\",\n    \"scope\": \"expr\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Requirement Overflow in Rust\nDESCRIPTION: Example showing how recursive trait requirements can lead to an overflow error. The code attempts to implement Foo for type T where Bar<T> must implement Foo, creating an infinite recursion in trait resolution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0275.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nstruct Bar<T>(T);\n\nimpl<T> Foo for T where Bar<T>: Foo {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating FnOnce Quirk in Async Closures (Rust)\nDESCRIPTION: This snippet illustrates a situation where the closure upvar analysis infers upvars that are too relaxed for the coroutine-closure's child coroutine, resulting in borrow-checker errors. It shows how forcing a closure to AsyncFnOnce requires by-move capture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn force_fnonce<T: async FnOnce()>(t: T) -> T { t }\n\nlet x = String::new();\nlet c = force_fnonce(async move || {\n    println!(\"{x}\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Try-Mark-Green Algorithm for Incremental Compilation in Rust\nDESCRIPTION: This function implements the try-mark-green algorithm for incremental compilation. It attempts to mark a query node as green (unchanged) by recursively checking its dependencies. If a dependency has changed (red), the current node can't be marked green. For unknown dependencies, it recursively tries to mark them green or re-runs their queries to determine their status.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/incremental-compilation-in-detail.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn try_mark_green(tcx, current_node) -> bool {\n\n    // Fetch the inputs to `current_node`, i.e. get the nodes that the direct\n    // edges from `node` lead to.\n    let dependencies = tcx.dep_graph.get_dependencies_of(current_node);\n\n    // Now check all the inputs for changes\n    for dependency in dependencies {\n\n        match tcx.dep_graph.get_node_color(dependency) {\n            Green => {\n                // This input has already been checked before and it has not\n                // changed; so we can go on to check the next one\n            }\n            Red => {\n                // We found an input that has changed. We cannot mark\n                // `current_node` as green without re-running the\n                // corresponding query.\n                return false\n            }\n            Unknown => {\n                // This is the first time we look at this node. Let's try\n                // to mark it green by calling try_mark_green() recursively.\n                if try_mark_green(tcx, dependency) {\n                    // We successfully marked the input as green, on to the\n                    // next.\n                } else {\n                    // We could *not* mark the input as green. This means we\n                    // don't know if its value has changed. In order to find\n                    // out, we re-run the corresponding query now!\n                    tcx.run_query_for(dependency);\n\n                    // Fetch and check the node color again. Running the query\n                    // has forced it to either red (if it yielded a different\n                    // result than we have in the cache) or green (if it\n                    // yielded the same result).\n                    match tcx.dep_graph.get_node_color(dependency) {\n                        Red => {\n                            // The input turned out to be red, so we cannot\n                            // mark `current_node` as green.\n                            return false\n                        }\n                        Green => {\n                            // Re-running the query paid off! The result is the\n                            // same as before, so this particular input does\n                            // not invalidate `current_node`.\n                        }\n                        Unknown => {\n                            // There is no way a node has no color after\n                            // re-running the query.\n                            panic!(\"unreachable\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // If we have gotten through the entire loop, it means that all inputs\n    // have turned out to be green. If all inputs are unchanged, it means\n    // that the query result corresponding to `current_node` cannot have\n    // changed either.\n    tcx.dep_graph.mark_green(current_node);\n\n    true\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Private Trait Error in Rust\nDESCRIPTION: Example showing incorrect usage of private traits in public interfaces, causing compiler errors. Includes attempts to use a private trait Foo in a public trait bound, struct definition, and function signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0445.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn dummy(&self) { }\n}\n\npub trait Bar : Foo {} // error: private trait in public interface\npub struct Bar2<T: Foo>(pub T); // same error\npub fn foo<T: Foo> (t: T) {} // same error\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Plugin Attribute Errors in Rust\nDESCRIPTION: This snippet shows examples of malformed `#[plugin]` attributes in Rust, highlighting incorrect argument configurations. These examples are illustrative of error codes that are no longer emitted by the compiler. No specific dependencies are required to understand the examples. Input: malformed plugin attribute usages. No outputs or runtime constraints noted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0498.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(plugin)]\n#![plugin(foo(args))] // error: invalid argument\n#![plugin(bar=\\\"test\\\")] // error: invalid argument\n```\n\n----------------------------------------\n\nTITLE: Setting Protected Visibility in Rust Compilation\nDESCRIPTION: Uses the `-Zdefault-visibility=protected` flag to set rust-mangled symbols to protected visibility. This prevents symbol overriding and may improve performance, but can cause linker errors with older GNU ld versions on Linux.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/default-visibility.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n-Zdefault-visibility=protected\n```\n\n----------------------------------------\n\nTITLE: Generating Compiler Diagnostics in Rust\nDESCRIPTION: Demonstrates creating and emitting compiler errors with suggestions using the Rust diagnostic system. Shows how to generate error messages, add suggestions, and handle span-based error reporting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Get a `Diag`. This does _not_ emit an error yet.\nlet mut err = sess.dcx.struct_span_err(sp, fluent::example::example_error);\n\n// In some cases, you might need to check if `sp` is generated by a macro to\n// avoid printing weird errors about macro-generated code.\n\nif let Ok(snippet) = sess.source_map().span_to_snippet(sp) {\n    // Use the snippet to generate a suggested fix\n    err.span_suggestion(suggestion_sp, fluent::example::try_qux_suggestion, format!(\"qux {}\", snippet));\n} else {\n    // If we weren't able to generate a snippet, then emit a \"help\" message\n    // instead of a concrete \"suggestion\". In practice this is unlikely to be\n    // reached.\n    err.span_help(suggestion_sp, fluent::example::qux_suggestion);\n}\n\n// emit the error\nerr.emit();\n```\n\n----------------------------------------\n\nTITLE: Checking for a Specific Type in Rustc Lints Using Diagnostic Items - Rust\nDESCRIPTION: Shows three approaches to check if an expression's type corresponds to a particular Rust type by using diagnostic items, language items, or matching the type path. It uses Clippy utilities such as `is_type_diagnostic_item` and `is_type_lang_item`. The snippet emphasizes preferring diagnostic and lang items due to their robustness over matching the full definition path. It requires imports from `clippy_utils`, `rustc_span::symbol`, and `rustc_hir`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\nuse clippy_utils::{paths, match_def_path};\nuse rustc_span::symbol::sym;\nuse rustc_hir::LangItem;\n\nimpl LateLintPass<'_> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        // Getting the expression type\n        let ty = cx.typeck_results().expr_ty(expr);\n\n        // 1. Using diagnostic items\n        // The last argument is the diagnostic item to check for\n        if is_type_diagnostic_item(cx, ty, sym::Option) {\n            // The type is an `Option`\n        }\n\n        // 2. Using lang items\n        if is_type_lang_item(cx, ty, LangItem::RangeFull) {\n            // The type is a full range like `.drain(..)`\n        }\n\n        // 3. Using the type path\n        // This method should be avoided if possible\n        if match_def_path(cx, def_id, &paths::RESULT) {\n            // The type is a `core::result::Result`\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Early Returns in Rust Functions\nDESCRIPTION: Illustrates the recommended use of early returns in Rust functions to reduce cognitive stack usage and improve readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn foo() -> Option<Bar> {\n    if !condition() {\n        return None;\n    }\n\n    Some(...)\n}\n\n// BAD\nfn foo() -> Option<Bar> {\n    if condition() {\n        Some(...)\n    } else {\n        None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Emscripten Compilation\nDESCRIPTION: This shell command example demonstrates how to test Rust programs targeting 'wasm32-unknown-emscripten' using specific Emscripten CFLAGS. Prerequisites include 'emcc', 'node', and ensuring 'x.py' script is accessible. The command outputs test results, skipping the linkchecker tool for efficiency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nEMCC_CFLAGS=\"-s MAXIMUM_MEMORY=2GB\" ./x.py test --target wasm32-unknown-emscripten --skip src/tools/linkchecker\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Dependency on Early-Bound Lifetimes\nDESCRIPTION: This snippet showcases how early-bound lifetimes are required during type checking to prevent errors related to uninstantiated lifetimes in function pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet f = foo::<String>;\nlet f = f as for<'a> fn(&'a String);\nf(&String::new());\n```\n\n----------------------------------------\n\nTITLE: Example of Argument Parsing for Doctest Compilation Arguments\nDESCRIPTION: This example demonstrates how the argument parsing works for --doctest_compilation_args. It shows how quotes and whitespace affect argument splitting, with specific rules for escaping characters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_36\n\nLANGUAGE: text\nCODE:\n```\n\"hello 'a'\\\" ok\" how are   'you today?'\n```\n\n----------------------------------------\n\nTITLE: Conflicting Trait Implementation Example in Rust\nDESCRIPTION: Demonstrates an error case (E0751) where both a positive and negative trait implementation are defined for the same type (i32). This is not allowed because negative implementations promise that the trait will never be implemented for the given types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0751.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {}\nimpl MyTrait for i32 { }\nimpl !MyTrait for i32 { } // error!\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Rust Program\nDESCRIPTION: Commands to compile a Rust source file and run the resulting executable on different platforms\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc hello.rs\n$ ./hello # on a *NIX\n$ .\\hello.exe # on Windows\n```\n\n----------------------------------------\n\nTITLE: Declare Unstable Features in Rust\nDESCRIPTION: Declares an unstable feature in the Rust compiler by adding an entry in the `unstable.rs` file. This involves specifying a feature name, the current Rust version, and optionally, a tracking issue number. Features might be marked as `incomplete` to warn users about their instability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/implementing_new_features.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// description of feature\n(unstable, $feature_name, \"CURRENT_RUSTC_VERSION\", Some($tracking_issue_number))\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// Allows defining identifiers beyond ASCII.\n(unstable, non_ascii_idents, \"CURRENT_RUSTC_VERSION\", Some(55467), None),\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// Allows unsized rvalues at arguments and parameters.\n(incomplete, unsized_locals, \"CURRENT_RUSTC_VERSION\", Some(48055), None),\n```\n\n----------------------------------------\n\nTITLE: Correct Struct Pattern Matching in Rust\nDESCRIPTION: Example showing correct pattern matching approaches: either specifying all struct fields or using the spread operator (..) to ignore unwanted fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0027.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Dog {\n    name: String,\n    age: u32,\n}\n\nlet d = Dog { name: \"Rusty\".to_string(), age: 8 };\n\nmatch d {\n    Dog { name: ref n, age: x } => {}\n}\n\n// This is also correct (ignore unused fields).\nmatch d {\n    Dog { age: x, .. } => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Pull Request Ready for Review in Rust\nDESCRIPTION: This command is used when a pull request in the Rust repository is ready for review after addressing comments or changes requested during the initial review phase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n@rustbot ready\n```\n\n----------------------------------------\n\nTITLE: Generating MIR with New Basic Blocks\nDESCRIPTION: This snippet illustrates how to create MIR in Rust, where expressions may require new basic blocks. It showcases the use of the `BlockAnd` type for handling control flow graphs. The function takes a starting block and may yield a different block after code execution, useful in branching scenarios. Dependencies include Rust MIR libraries and types `BasicBlock` and `BlockAnd`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/construction.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn generate_more_mir(&mut self, block: BasicBlock) -> BlockAnd<ResultType> {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Trait-Based Solution for Type-Safe Transmutation in Rust\nDESCRIPTION: A safer approach to transmuting generic types using a trait with specific implementations for each concrete type. This pattern enables type-checking at compile time for each implementation, ensuring size compatibility for each concrete type used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0139.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem::transmute;\n\nstruct Foo<T>(Vec<T>);\n\ntrait MyTransmutableType: Sized {\n    fn transmute(_: Vec<Self>) -> Foo<Self>;\n}\n\nimpl MyTransmutableType for u8 {\n    fn transmute(x: Vec<u8>) -> Foo<u8> {\n        unsafe { transmute(x) }\n    }\n}\n\nimpl MyTransmutableType for String {\n    fn transmute(x: Vec<String>) -> Foo<String> {\n        unsafe { transmute(x) }\n    }\n}\n\n// ... more impls for the types you intend to transmute\n\nfn foo<T: MyTransmutableType>(x: Vec<T>) {\n    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n    // do something with y\n}\n```\n\n----------------------------------------\n\nTITLE: Qualifying Unresolved Paths in Rust\nDESCRIPTION: Adds appropriate namespace qualifiers to unresolved identifiers, helping to resolve name resolution errors. This refactoring can automatically import types from standard libraries or other available modules when they're referenced without their full path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_95\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let map = HashMap::new();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let map = std::collections::HashMap::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Macro By Example Definition (Rust)\nDESCRIPTION: This example shows a simple `macro_rules!` definition, illustrating how metavariables are used to bind to token trees at compile time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! printer {\n    (print $mvar:ident) => {\n        println!(\"{}\", $mvar);\n    };\n    (print twice $mvar:ident) => {\n        println!(\"{}\", $mvar);\n        println!(\"{}\", $mvar);\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying package with Rustfmt CLI option\nDESCRIPTION: Example of using the -p CLI option to specify a package when formatting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_24\n\nLANGUAGE: Shell\nCODE:\n```\nrustfmt -p my_package\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Trait Bound\nDESCRIPTION: Demonstrates a generic function with a trait bound requiring Clone implementation for type T, showing how trait resolution works with generic parameters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/resolution.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { \n    let mut v = Vec::new();\n    for e in &x {\n        v.push((*e).clone()); // (*)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_7 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_7` function in Rust, passing a struct `S2` with integer members and an integer (3) as arguments.  It highlights the passing of a struct and an integer with the `stdcall` convention.  The behaviour of `stdcall_fn_7` will dictate the response.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_7(S2 { x: 15, y: 16 }, 3)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Inner Doc Comment Usage in Rust\nDESCRIPTION: This code snippet shows an erroneous use of an inner doc comment in Rust, which triggers the E0753 error. Inner doc comments cannot be used in this context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0753.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {}\n//! foo\n// ^ error!\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Associated Type Formatting in Rust\nDESCRIPTION: Shows the formatting for associated types that are bound in a generic type, including spacing around the `=` sign.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n<T: Example<Item = u32>>\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching Using Tuple Syntax\nDESCRIPTION: Shows the correct way to pattern match a tuple variant using tuple pattern syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0769.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# enum E {\n#     A(i32),\n# }\n# let e = E::A(42);\nmatch e {\n    E::A(number) => { // ok!\n        println!(\"{}\", number);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Closure Trait Implementation in Rust\nDESCRIPTION: Shows how implementing Clone and Copy traits on the struct allows the closure to meet the Fn trait requirement, resolving the previous compilation error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0525.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\nstruct X;\n\nfn foo<T>(_: T) {}\nfn bar<T: Fn(u32)>(_: T) {}\n\nfn main() {\n    let x = X;\n    let closure = |_| foo(x);\n    bar(closure); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Temporary Value Dropping Error in Rust\nDESCRIPTION: This code snippet demonstrates an error where a temporary value is dropped while still being borrowed. The function 'foo' returns a value that is immediately borrowed and passed to 'bar', creating a temporary that is dropped too soon.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0716.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\n----------------------------------------\n\nTITLE: Returning Iterator with Lifetime Annotations in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect usage of lifetimes in a function that returns an iterator. The type implementing the Iterator passed to the function lives only as long as the provided lifetime, which may not be sufficient. The solution shows how to explicitly annotate the lifetime of the returned iterator to avoid errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0482.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0700\nfn prefix<'a>(\n    words: impl Iterator<Item = &'a str>\n) -> impl Iterator<Item = String> { // error!\n    words.map(|v| format!(\"foo-{}\", v))\n}\n```\n```\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn prefix<'a>(\n    words: impl Iterator<Item = &'a str> + 'a\n) -> impl Iterator<Item = String> + 'a { // ok!\n    words.map(|v| format!(\"foo-{}\", v))\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0412 Error in Rust\nDESCRIPTION: This snippet shows three examples of code that will fail to compile due to type names not being in scope. It includes attempts to implement an undefined struct, use an undeclared type in a trait, and use an undefined type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0412.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0689 Error with Numeric Binding in Rust\nDESCRIPTION: This code snippet illustrates another case of the E0689 error, where the 'neg()' method is called on a numeric binding without a specified type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0689.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\n----------------------------------------\n\nTITLE: Enabling AddressSanitizer for Cargo Build (Shell)\nDESCRIPTION: This command demonstrates how to enable AddressSanitizer when building a Rust project using Cargo. It sets the `RUSTFLAGS` environment variable with the `-Zsanitizer=address` flag and uses `-Zbuild-std` and `--target` to build with a standard library instrumented for the specified target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ RUSTFLAGS=-Zsanitizer=address cargo build -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Associated Type Constraint in Rust\nDESCRIPTION: This code snippet shows the correct way to encode the constraint on the associated type Color using a where clause and new type parameters. It introduces a CAR type parameter and uses trait bounds to restrict the associated types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0222.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait Vehicle {\n    type Color;\n}\n\npub trait Box {\n    type Color;\n}\n\npub trait BoxCar : Box + Vehicle {}\n\n// Introduce a new `CAR` type parameter\nfn foo<CAR, COLOR>(\n    c: CAR,\n) where\n    // Bind the type parameter `CAR` to the trait `BoxCar`\n    CAR: BoxCar,\n    // Further restrict `<BoxCar as Vehicle>::Color` to be the same as the\n    // type parameter `COLOR`\n    CAR: Vehicle<Color = COLOR>,\n    // We can also simultaneously restrict the other trait's associated type\n    CAR: Box<Color = COLOR>\n{}\n```\n\n----------------------------------------\n\nTITLE: Example of On Enter Handling in Rust Comments\nDESCRIPTION: Shows how the On Enter extension handles comment continuation, automatically adding the comment prefix to the new line while preserving the cursor position using snippets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Some /*cursor here*/ docs\n    let x = 92;\n}\n```\n\n----------------------------------------\n\nTITLE: Using black_box to prevent optimization in benchmarks\nDESCRIPTION: Demonstrates how to use the test::black_box function to prevent the compiler from optimizing away calculations in benchmarks. This function acts as an opaque black box to the optimizer, forcing it to consider the value as used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/test.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(test)]\n\nextern crate test;\n\n# fn main() {\n# struct X;\n# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\nb.iter(|| {\n    let n = test::black_box(1000);\n\n    (0..n).fold(0, |a, b| a ^ b)\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Field Update Pattern\nDESCRIPTION: Fixed version of the code that properly updates enum variant fields by explicitly specifying the fields to keep and update. This approach uses pattern matching to extract and reuse the desired fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0436.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum PublicationFrequency {\n    Weekly,\n    SemiMonthly { days: (u8, u8), annual_special: bool },\n}\n\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\n                     -> PublicationFrequency {\n    match competitor_frequency {\n        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n            days: (1, 15), annual_special: false\n        },\n        PublicationFrequency::SemiMonthly{ days, .. } =>\n            PublicationFrequency::SemiMonthly {\n                days, annual_special: true // ok!\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialization and Move Tracking Example in Rust\nDESCRIPTION: This Rust code snippet demonstrates how the borrow checker tracks the initialization and moves of a variable `a`. The variable `a` is initially uninitialized, then initialized via assignment, and finally uninitialized again after being moved into the `drop` function. The code attempts to access `a` after it has been moved, resulting in a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/moves_and_initialization.md#2025-04-21_snippet_0\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo() {\n    let a: Vec<u32>;\n    \n    // a is not initialized yet\n    \n    a = vec![22];\n    \n    // a is initialized here\n    \n    std::mem::drop(a); // a is moved here\n    \n    // a is no longer initialized here\n\n    let l = a.len(); //~ ERROR\n}\n```\n\n----------------------------------------\n\nTITLE: Removing dbg! Macros in Rust\nDESCRIPTION: Removes debugging macro invocations and preserves the inner expressions. This refactoring helps clean up code by removing debugging instrumentation that was added during development but is no longer needed for production.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_97\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = dbg!(42 * dbg!(4 + 2));\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 42 * (4 + 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Declaration of Lifetime Parameters in Rust\nDESCRIPTION: Proper implementation showing how to correctly declare lifetime parameters for both a struct and function definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0261.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a> {\n    x: &'a str,\n}\n\nfn foo<'a>(x: &'a str) {}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Lifetime Mismatch in Function Signature (E0621)\nDESCRIPTION: This code snippet demonstrates the E0621 error in Rust, where the explicit lifetime annotation `'a` suggests the function returns data borrowed only from `x`, but the function body potentially returns data from `y` as well. The compiler flags this as an error, requiring either the signature or the body to be adjusted to match the actual data flow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0621.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0621\nfn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // error: explicit lifetime\n                                             //        required in the type of\n                                             //        `y`\n    if x > y { x } else { y }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Making Methods Public in Rust\nDESCRIPTION: This approach resolves the private method error by altering the method's visibility to public. It allows the method to be accessed without any restrictions, enabling its use outside its original scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0624.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        pub fn method(&self) {} // It's now public.\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // Ok!\n```\n\n----------------------------------------\n\nTITLE: Generating Flamegraphs from Profiling Data\nDESCRIPTION: Demonstrates creating a flamegraph visualization from rustc profiling data using the inferno tool from measureme.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ ../measureme/target/release/inferno foo-1234\n```\n\n----------------------------------------\n\nTITLE: Using expect as an Error Message in Rust\nDESCRIPTION: Shows the 'expect as error message' style where expect's message describes the error that occurred. This approach focuses on describing what went wrong in a user-friendly way.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/error.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet path = std::env::var(\"IMPORTANT_PATH\")\n    .expect(\"env variable `IMPORTANT_PATH` is not set\");\n```\n\n----------------------------------------\n\nTITLE: Correct Negative Trait Implementation Example in Rust\nDESCRIPTION: Shows the correct way to implement a negative trait by removing all items from the implementation block, simply declaring that the trait is not implemented for the type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0749.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(negative_impls)]\ntrait MyTrait {\n    type Foo;\n}\n\nimpl !MyTrait for u32 {}\n```\n\n----------------------------------------\n\nTITLE: Canonical Query Result Structure\nDESCRIPTION: This snippet outlines the structure of a canonical query result. It combines certainty, variable values, region constraints, and value data, producing a form suitable for re-applying results in original contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nQR = {\n    certainty: Proven,             // or whatever\n    var_values: [Vec<?E>, '?D, ?E] // this is S\n    region_constraints: [?E: '?D], // from the impl\n    value: (),                     // for our purposes, just (), but\n                                   // in some cases this might have\n                                   // a type or other info\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit and Explicit Deref Patterns in Rust\nDESCRIPTION: This code demonstrates both implicit and explicit dereferencing in pattern matching using the `deref_patterns` feature. It initializes a vector containing a boxed optional integer, and then uses pattern matching to increment the integer value within. The code highlights how implicit dereferences are inserted when a pattern matches the dereferenced value and showcases the use of `deref!(_)` for explicit dereferencing, including binding the dereferenced value to a variable. Requires `deref_patterns` and `incomplete_features` feature flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/deref-patterns.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(deref_patterns)]\n#![allow(incomplete_features)]\n\nlet mut v = vec![Box::new(Some(0))];\n\n// Implicit dereferences are inserted when a pattern can match against the\n// result of repeatedly dereferencing but can't match against a smart\n// pointer itself. This works alongside match ergonomics for references.\nif let [Some(x)] = &mut v {\n    *x += 1;\n}\n\n// Explicit `deref!(_)` patterns may instead be used when finer control is\n// needed, e.g. to dereference only a single smart pointer, or to bind the\n// the result of dereferencing to a variable.\nif let deref!([deref!(opt_x @ Some(1))]) = &mut v {\n    opt_x.as_mut().map(|x| *x += 1);\n}\n\nassert_eq!(v, [Box::new(Some(2))]);\n```\n\n----------------------------------------\n\nTITLE: Invalid Copy Trait Implementation Example in Rust\nDESCRIPTION: Shows an erroneous attempt to implement the Copy trait on a static mutable reference type &'static mut Bar, which is not allowed. The Copy trait can only be implemented for structs, enums, or unions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0206.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Copy, Clone)]\nstruct Bar;\n\nimpl Copy for &'static mut Bar { } // error!\n```\n\n----------------------------------------\n\nTITLE: Type Checking Expression Method Signature\nDESCRIPTION: Method signature for expr_ty that retrieves the type of an expression\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn expr_ty(&self, expr: &Expr<'_>) -> Ty<'tcx>\n```\n\n----------------------------------------\n\nTITLE: Compile Fail Example: Incorrect Fn Argument Count in Rust\nDESCRIPTION: This code snippet demonstrates the E0593 error, which occurs when the number of arguments in a closure doesn't match the expected number defined in the `Fn` trait bound. The `foo` function expects an `Fn()` (no arguments) but is called with a closure that takes one argument (`|y| {}`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0593.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0593\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    // [E0593] closure takes 1 argument but 0 arguments are required\n    foo(|y| { });\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Checking if a Type Implements a Specific Trait in Rustc Lints - Rust\nDESCRIPTION: Provides methods to verify if an expression's type implements a particular trait using Clippy utils such as `is_trait_method` and `implements_trait`. The examples show usage with diagnostic items (e.g., `Iterator` trait) and lang items (e.g., `Drop` trait) accessed via the type context `tcx`. This snippet depends on Rustc internals and Clippy utilities and encourages using diagnostic/lang items if available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::ty::implements_trait;\nuse clippy_utils::is_trait_method;\nuse rustc_span::symbol::sym;\n\nimpl LateLintPass<'_> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        // 1. Using diagnostic items with the expression\n        // we use `is_trait_method` function from Clippy's utils\n        if is_trait_method(cx, expr, sym::Iterator) {\n            // method call in `expr` belongs to `Iterator` trait\n        }\n\n        // 2. Using lang items with the expression type\n        let ty = cx.typeck_results().expr_ty(expr);\n        if cx.tcx.lang_items()\n            // we are looking for the `DefId` of `Drop` trait in lang items\n            .drop_trait()\n            // then we use it with our type `ty` by calling `implements_trait` from Clippy's utils\n            .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n                // `expr` implements `Drop` trait\n            }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing E0071 by Defining a Proper Struct in Rust\nDESCRIPTION: This alternative solution fixes the E0071 error by creating a proper struct definition that can be correctly initialized with structure-literal syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0071.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct U32 { value: u32 }\nlet t = U32 { value: 4 };\n```\n\n----------------------------------------\n\nTITLE: Correct Use of Break in Closures with Loops\nDESCRIPTION: This code demonstrates the correct usage of a 'break' statement inside a closure. Loop keywords are valid in closures as long as they are contained within a loop structure. The example shows a closure with a for loop where the break statement is properly scoped.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0267.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet w = || {\n    for _ in 0..10 {\n        break;\n    }\n};\n\nw();\n```\n\n----------------------------------------\n\nTITLE: Getting Backtrace from Rust Compiler on Panic\nDESCRIPTION: In this example, the environment variable `RUST_BACKTRACE` is set to 1 to enable stack traces on panic events in the Rust compiler, facilitating debugging.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRUST_BACKTRACE=1 rustc +stage1 error.rs -Z treat-err-as-bug\n```\n\n----------------------------------------\n\nTITLE: Defining FetchDependencyList Result Interface in TypeScript\nDESCRIPTION: TypeScript interface for the response of the 'rust-analyzer/fetchDependencyList' method. Returns an array of crates with their name, version, and path to help navigate the dependency tree.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FetchDependencyListResult {\n    crates: {\n        name: string;\n        version: string;\n        path: string;\n    }[];\n}\n```\n\n----------------------------------------\n\nTITLE: Failed Generic Parameter Inheritance in Nested Function\nDESCRIPTION: Example showing incorrect attempt to use outer function's generic parameter in inner function, which results in compilation error E0401.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Mutable Borrow Issue in Closure - Rust\nDESCRIPTION: This snippet provides a solution to the mutable borrow error by ensuring that the closure is invoked before further mutable access is required for the captured variable. This demonstrates how to correctly manage variable scopes and borrowing in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0501.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    let mut bar = || {\n        inside_closure(a)\n    };\n    bar();\n    // borrow on `a` ends.\n    outside_closure(a); // ok!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Asm DWARF Debugging Information - Rust Compiler\nDESCRIPTION: This code snippet contains sample debugging information output in the DWARF format by the Rust compiler. It highlights the usage of debugging attributes like 'DW_AT_containing_type' to point to real types from virtual tables in order to dissect trait objects. The expected output is generated through the Rust compiler to align with debugger requirements, accommodating the limitations of existing DWARF implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/debugging-support-in-rustc.md#2025-04-21_snippet_0\n\nLANGUAGE: ASM\nCODE:\n```\n<1><1a9>: Abbrev Number: 3 (DW_TAG_structure_type)\n   <1aa>   DW_AT_containing_type: <0x1b4>\n   <1ae>   DW_AT_name        : (indirect string, offset: 0x23d): vtable\n   <1b2>   DW_AT_byte_size   : 0\n   <1b3>   DW_AT_alignment   : 8\n```\n\n----------------------------------------\n\nTITLE: Handling Pattern Matching Error in Rust Enums\nDESCRIPTION: This snippet demonstrates an erroneous pattern match in Rust where the kind of match arm did not correspond with the matched expression, causing a compile error. The example shows a mismatch due to using a structure pattern for a tuple variant in an enum.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0532.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenum State {\n    Succeeded,\n    Failed(String),\n}\n\nfn print_on_failure(state: &State) {\n    match *state {\n        // error: expected unit struct, unit variant or constant, found tuple\n        //        variant `State::Failed`\n        State::Failed => println!(\"Failed\"),\n        _ => ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional compilation for wasm32 target in Rust\nDESCRIPTION: This code snippet demonstrates how to conditionally compile code specifically for the `wasm32-unknown-unknown` target in Rust. This is done using the `#[cfg]` attribute, which checks for the target family being \"wasm\" and the target OS being \"unknown\".\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n#[cfg(all(target_family = \"wasm\", target_os = \"unknown\"))]\n```\n\n----------------------------------------\n\nTITLE: Configuring Trailing Semicolons in Rust\nDESCRIPTION: Demonstrates the 'trailing_semicolon' option. When true (default), semicolons are added after break, continue, and return statements. When false, these semicolons are omitted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_72\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> usize {\n    return 0;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> usize {\n    return 0\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Function Item to Pointer Casts\nDESCRIPTION: The snippet illustrates two methods to correctly convert a function item to a function pointer without triggering type safety issues while using transmute in Rust. It emphasizes matching the expected signatures properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0591.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n/// This pattern should be rewritten. There are a few possible ways to do this:\n// - change the original fn declaration to match the expected signature,\n//   and do the cast in the fn body (the preferred option)\n// - cast the fn item of a fn pointer before calling transmute, as shown here:\n\n# extern \"C\" fn foo(_: Box<i32>) {}\n# use std::mem::transmute;\n# unsafe {\nlet f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\nlet f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n# }\n```\n\n----------------------------------------\n\nTITLE: Running Rust Compiler with Backtrace and Tracking Diagnostics\nDESCRIPTION: This command runs the Rust compiler with backtrace enabled while utilizing the `-Z track-diagnostics` flag to pinpoint where errors were emitted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nRUST_BACKTRACE=1 rustc +stage1 error.rs -Z track-diagnostics\n```\n\n----------------------------------------\n\nTITLE: Range Patterns with Parentheses in Rust Slices\nDESCRIPTION: Shows how range patterns can be used in slice patterns when wrapped in parentheses, which doesn't require the half_open_range_patterns_in_slices feature flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/half-open-range-patterns-in-slices.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let xs = [13, 1];\n    let [(a @ 3..), c] = xs else { return; };\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unterminated String Literal Error in Rust\nDESCRIPTION: Demonstrates an example in Rust where a string literal is not properly terminated, resulting in a compile-time error. No external dependencies are required; standard Rust parsing raises the error. The snippet expects a closing double quote at the end of the string, and its omission produces a syntax error, which is typically caught by the Rust compiler and shown in the error output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_string_with_slash.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSTRING \"\\\n```\n\n----------------------------------------\n\nTITLE: Using EarlyBinder with a Vector of Tuples\nDESCRIPTION: This snippet illustrates how to define a generic function 'foo' returning a vector of tuples containing a u32 and a generic type T. It demonstrates the instantiation of the EarlyBinder type with a specific type, u64, resulting in a vector of tuples of type u32 and u64. The dependency required is the Rust standard library for vector operations. The expected output is a vector of type Vec<(u32, u64)>.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/early_binder.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>() -> Vec<(u32, T)> { Vec::new() }\nfn bar() {\n    // the return type of `foo` before instantiating it would be:\n    // `EarlyBinder(Adt(Vec, &[Tup(&[u32, T/#=0])]))`\n    // we then instantiate the binder with `[u64]` resulting in the type:\n    // `Adt(Vec, &[Tup(&[u32, u64])])`\n    let a = foo::<u64>();\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling and Using Unstable Feature in Rust\nDESCRIPTION: This code snippet demonstrates how to properly enable and use the unstable 'repr128' feature in a nightly version of Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0658.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with ? in Doc Tests\nDESCRIPTION: The snippet explains how to use the `?` operator for error handling in Rust doc tests by manually adding a main that returns Result<T, E>. Key parameters include error types and I/O operations. A properly structured main method allows for compiling without intricate boilerplate code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n/// use std::io;\n///\n/// fn main() -> io::Result<()> {\n///     let mut input = String::new();\n///     io::stdin().read_line(&mut input)?;\n///     Ok(())\n/// }\n/// ```\n# fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Line Length in Rust Code\nDESCRIPTION: This snippet provides guidance on how to exempt certain lines from the tidy line length check in Rust code by using a specific comment. This is useful for cases where longer lines may be necessary, particularly in tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/conventions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// ignore-tidy-linelength\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid Assignment Operations in Rust\nDESCRIPTION: This code snippet illustrates correct usage of the assignment operator in Rust, showing proper assignment to struct fields and dereferenced mutable references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0070.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\nlet mut s = SomeStruct { x: 0, y: 0 };\n\ns.x = 3; // that's good !\n\n// ...\n\nfn some_func(x: &mut i32) {\n    *x = 12; // that's good !\n}\n```\n\n----------------------------------------\n\nTITLE: Handling environment variable errors - Rust\nDESCRIPTION: This snippet illustrates the error message you might encounter if necessary environment variables are not set while running a Rust compiler binary. It emphasizes the need for certain environment variables during the compilation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/what-bootstrapping-does.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nthread 'main' panicked at 'RUSTC_STAGE was not set: NotPresent', library/core/src/result.rs:1165:5\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation\nDESCRIPTION: Demonstrates the proper way to define and implement a trait for a struct type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0404.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    // some functions\n}\nstruct Bar;\n\nimpl Foo for Bar { // ok!\n    // functions implementation\n}\n\nfn baz<T: Foo>(t: T) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Fuchsia Target Configuration for rustc\nDESCRIPTION: This TOML snippet configures the Rust build process to target Fuchsia with a clang toolchain and sets the install directory. It includes configurations for both x86-64 and AArch64 architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"<host_platform>\", \"aarch64-unknown-fuchsia\", \"x86_64-unknown-fuchsia\"]\n\n[rust]\nlld = true\n\n[llvm]\ndownload-ci-llvm = false\n\n[target.x86_64-unknown-fuchsia]\ncc = \"clang\"\ncxx = \"clang++\"\n\n[target.aarch64-unknown-fuchsia]\ncc = \"clang\"\ncxx = \"clang++\"\n\n[target.<host_platform>]\ncc = \"clang\"\ncxx = \"clang++\"\n\n[install]\nprefix = \"<RUST_SRC_PATH>/install\"\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation in Rust\nDESCRIPTION: This example shows the correct implementation of the Foo trait for Bar. Since the trait defines foo() as a static function without parameters, the implementation must also define it as a static function without parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0185.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Config Extensions in TOML\nDESCRIPTION: This TOML file defines a configuration extension for bootstrapping Rust projects. It specifies build, host, and target settings and sets LLVM options. The file is intended for inclusion in another TOML configuration to manage different build configurations. No external dependencies are needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild = \"x86_64-unknown-linux-gnu\"\nhost = [\"i686-unknown-linux-gnu\"]\ntarget = [\"i686-unknown-linux-gnu\"]\n\n\n[llvm]\ndownload-ci-llvm = false\n\n[target.x86_64-unknown-linux-gnu]\nllvm-config = \"/path/to/llvm-19/bin/llvm-config\"\n```\n\n----------------------------------------\n\nTITLE: Implementing an Empty Lint Pass in Rust for Clippy\nDESCRIPTION: Skeleton implementation of an EarlyLintPass for a new Clippy lint. This defines a new lint pass named 'FooFunctions' that will check for the FOO_FUNCTIONS lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint_pass!(FooFunctions => [FOO_FUNCTIONS]);\n\nimpl EarlyLintPass for FooFunctions {}\n```\n\n----------------------------------------\n\nTITLE: Moving Match Guard to Pattern in Rust\nDESCRIPTION: Demonstrates how to move a condition from a match guard to the pattern itself for cleaner, more concise code. This refactoring simplifies match expressions by incorporating conditionals directly into the pattern matching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_84\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } => if distance > 10 { foo() },\n        _ => (),\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } if distance > 10 => foo(),\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Imports in Rust\nDESCRIPTION: Removes import statements that aren't used anywhere in the code. This refactoring helps clean up the codebase by eliminating dead imports that might have been left over from previous development or code changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_101\n\nLANGUAGE: rust\nCODE:\n```\nstruct X();\nmod foo {\n    use super::X;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct X();\nmod foo {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust for SPARC Target in TOML\nDESCRIPTION: This snippet demonstrates how to configure Rust to support the `sparc-unknown-none-elf` target by modifying `bootstrap.toml`. It sets up the build configuration to include the target, which is necessary for building Rust programs that run on SPARC hardware.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[build]\nbuild-stage = 1\nhost = [\"<target for your host>\"]\ntarget = [\"<target for your host>\", \"sparc-unknown-none-elf\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Rust Edition in TOML Configuration\nDESCRIPTION: This snippet shows how to specify the Rust edition in a `Cargo.toml` file. Rustfmt uses this setting to parse the code correctly.  Setting the edition ensures the code is formatted according to the rules of that specific Rust edition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\nedition = \"2018\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Library Path\nDESCRIPTION: This code snippet illustrates how to use the `-L` or `--library-path` flag to specify directories where rustdoc should look for dependencies. This is essential when the crate being documented has external dependencies.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -L target/debug/deps\n$ rustdoc src/lib.rs --library-path target/debug/deps\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Macro Import Declarations in Rust\nDESCRIPTION: This code snippet shows two examples of incorrect macro import declarations that will result in compilation errors. The first attempts to nest macros, while the second uses an invalid key-value syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0466.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use(a_macro(another_macro))] // error: invalid import declaration\nextern crate core as some_crate;\n\n#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\nextern crate core as another_crate;\n```\n\n----------------------------------------\n\nTITLE: Ensuring Unique Type Parameters in Opaque Types in Rust\nDESCRIPTION: Illustrates the need for unique type parameters in the definition of opaque types in Rust. A valid case with unique type parameters is presented, followed by an invalid case where a type parameter is repeated, resulting in ambiguity. This enforces the requirement for unique type arguments to ensure clear type inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<X, Y> = impl Sized;\n\n// `T` and `U` are unique in the generic args.\n// Opaque<T, U> := T;\nfn good<T, U>(t: T, _u: U) -> Opaque<T, U> { t }\n\n// `T` appears twice in the generic args.\n// Opaque<T, T> := T;\nfn bad<T>(t: T) -> Opaque<T, T> { t } //~ ERROR\n\n```\n\n----------------------------------------\n\nTITLE: Error Example: Attempting Integer Representation on Zero-Variant Enum in Rust\nDESCRIPTION: This code demonstrates the E0084 error that occurs when trying to define an integer representation for a zero-variant enum. Since there are no variants, there are no values to represent with the integer type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0084.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(i32)]\nenum NightsWatch {} // error: unsupported representation for zero-variant enum\n```\n\n----------------------------------------\n\nTITLE: Implementing Foreign Trait for Foreign Type (Rust)\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to implement the Drop trait for u32, which violates Rust's orphan rules. This will result in a compilation error E0117.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0117.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Drop for u32 {}\n```\n\n----------------------------------------\n\nTITLE: Register Class Definition Example\nDESCRIPTION: Note showing special case for NVPTX and WebAssembly register handling. These architectures don't support named registers due to their execution models.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-experimental-arch.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n> **Notes**:\\n> - NVPTX doesn't have a fixed register set, so named registers are not supported.\\n>\\n> - WebAssembly doesn't have registers, so named registers are not supported.\n```\n\n----------------------------------------\n\nTITLE: Executing Documentation Examples as Tests in Rust\nDESCRIPTION: This code snippet demonstrates a basic example of how rustdoc can extract and execute an example within Rust documentation for testing purposes. No dependencies are needed. The primary input is a Rust code snippet enclosed in triple backticks with a Rust code identifier. The output ensures that the code compile and runs correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// # Examples\n///\n/// ```\n/// let x = 5;\n/// ```\n# fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Complete PGO Workflow with Cargo\nDESCRIPTION: Full 4-step workflow for profile-guided optimization in a Cargo project. Shows how to use RUSTFLAGS to enable PGO for all crates in the project, with considerations for build scripts and path handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/profile-guided-optimization.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# STEP 0: Make sure there is no left-over profiling data from previous runs\nrm -rf /tmp/pgo-data\n\n# STEP 1: Build the instrumented binaries\nRUSTFLAGS=\"-Cprofile-generate=/tmp/pgo-data\" \\\n    cargo build --release --target=x86_64-unknown-linux-gnu\n\n# STEP 2: Run the instrumented binaries with some typical data\n./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv\n./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv\n./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv\n\n# STEP 3: Merge the `.profraw` files into a `.profdata` file\nllvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data\n\n# STEP 4: Use the `.profdata` file for guiding optimizations\nRUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n    cargo build --release --target=x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Formatting Control Flow Expressions in Rust\nDESCRIPTION: Guidelines for formatting if/else statements and blocks in Rust, showing proper placement of braces, keywords, and whitespace for various control flow scenarios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nif ... {\n    ...\n} else {\n    ...\n}\n\nif let ... {\n    ...\n} else if ... {\n    ...\n} else {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Rebase Keeping Base\nDESCRIPTION: Starts an interactive rebase session against the master branch, preserving the original merge base. This command is used to clean up commit history (e.g., squashing, reordering) without changing the point where the branch diverged from master.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --interactive --keep-base master\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Aliasing External Crate in Rust\nDESCRIPTION: Shows how to resolve the naming conflict by importing the external crate with an alias using the 'as' keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0260.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core as xyz;\n\nstruct abc;\n```\n\n----------------------------------------\n\nTITLE: Documenting Macros with Extern Crate and Main\nDESCRIPTION: This snippet demonstrates documentation and testing of Rust macros, properly using `extern crate` with the `#[macro_use]` attribute and defining a `main()` function. This structure ensures the documentation and examples are correct and testable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n/// # #[macro_use] extern crate foo;\n/// # fn main() {\n/// panic_unless!(1 + 1 == 2, “Math is broken.”);\n/// # }\n/// ```\n```\n\n----------------------------------------\n\nTITLE: General Form of Trait Implementation in Rust\nDESCRIPTION: This code snippet shows the general form of a trait implementation, used to explain the rules for valid implementations according to Rust's orphan rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0210.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n\n----------------------------------------\n\nTITLE: Demangling Rust Symbol with rustfilt\nDESCRIPTION: This snippet demonstrates how to use the `rustfilt` command-line tool to demangle a Rust symbol. It shows an example of demangling a mangled symbol `_RNvCskwGfYPst2Cb_3foo16example_function` to its human-readable form `foo::example_function`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/index.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"$ rustfilt _RNvCskwGfYPst2Cb_3foo16example_function\nfoo::example_function\"\n```\n\n----------------------------------------\n\nTITLE: Corrected Rust Function Type with Lifetime Constraints\nDESCRIPTION: Shows two valid ways to handle lifetimes in function type declarations: using a lifetime in arguments or using the 'static lifetime\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0581.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Here, `'a` appears only in the return type:\n    let x: for<'a> fn(&'a i32) -> &'a i32;\n    let y: fn() -> &'static i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Continuing Rebase After Conflict Resolution\nDESCRIPTION: Instructs Git to continue the rebase process after conflicts have been resolved and the affected files have been staged. Git will attempt to apply the next commit in the sequence.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --continue\n```\n\n----------------------------------------\n\nTITLE: Correction Example: Using Properly Defined Associated Type in Rust Trait\nDESCRIPTION: This corrected code fixes the E0576 error by using the properly defined associated type 'Who' instead of the non-existent 'You'. This compiles successfully because the associated type is defined within the trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0576.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Hello {\n    type Who;\n\n    fn hello() -> <Self as Hello>::Who; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Basic impl Trait Example in Rust\nDESCRIPTION: Demonstrates a basic function signature using impl Trait with lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/member_constraints.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn make(a: &'a u32, b: &'b u32) -> impl Trait<'a, 'b> { .. }\n```\n\n----------------------------------------\n\nTITLE: Applying Conditional Compilation for Documentation in Rust\nDESCRIPTION: Demonstrates how to use the `#[cfg(doc)]` attribute in Rust to ensure items are included in documentation regardless of target platform. It displays examples of platform-specific structs that are documented across different OS contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/advanced-features.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"/// Token struct that can only be used on Windows.\\n#[cfg(any(windows, doc))]\\npub struct WindowsToken;\\n/// Token struct that can only be used on Unix.\\n#[cfg(any(unix, doc))]\\npub struct UnixToken;\"\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Suffix to CSS/JavaScript Files in Rustdoc\nDESCRIPTION: Demonstrates how to modify the filenames of CSS and JavaScript resources generated by Rustdoc. This is useful for cache control, adding a suffix to resource filenames like 'light.css' becoming 'light-suf.css'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Query Syntax for Type-Based Searches\nDESCRIPTION: This code snippet outlines the syntax rules for querying types in Rust. It defines structures and characters used to construct valid search queries for Rustdoc, focusing on identifiers, paths, and expression types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/read-documentation/search.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nident = *(ALPHA / DIGIT / \"_\")\npath = ident *(DOUBLE-COLON ident) [BANG]\nslice-like = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET\ntuple-like = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN\nborrow-ref = AMP *WS [MUT] *WS [arg]\narg = [type-filter *WS COLON *WS] (path [generics] / slice-like / tuple-like / borrow-ref)\ntype-sep = COMMA/WS *(COMMA/WS)\nnonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep) [ return-args ]\ngeneric-arg-list = *(type-sep) arg [ EQUAL arg ] *(type-sep arg [ EQUAL arg ]) *(type-sep)\nnormal-generics = OPEN-ANGLE-BRACKET [ generic-arg-list ] *(type-sep)\n            CLOSE-ANGLE-BRACKET\nfn-like-generics = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN [ RETURN-ARROW arg ]\ngenerics = normal-generics / fn-like-generics\nreturn-args = RETURN-ARROW *(type-sep) nonempty-arg-list\n\nexact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]\ntype-search = [ nonempty-arg-list ]\n\nquery = *WS (exact-search / type-search) *WS\n\ntype-filter = (\n    \"mod\" /\n    \"externcrate\" /\n    \"import\" /\n    \"struct\" /\n    \"enum\" /\n    \"fn\" /\n    \"type\" /\n    \"static\" /\n    \"trait\" /\n    \"impl\" /\n    \"tymethod\" /\n    \"method\" /\n    \"structfield\" /\n    \"variant\" /\n    \"macro\" /\n    \"primitive\" /\n    \"associatedtype\" /\n    \"constant\" /\n    \"associatedconstant\" /\n    \"union\" /\n    \"foreigntype\" /\n    \"keyword\" /\n    \"existential\" /\n    \"attr\" /\n    \"derive\" /\n    \"traitalias\" /\n    \"generic\")\n\nOPEN-ANGLE-BRACKET = \"<\"\nCLOSE-ANGLE-BRACKET = \">\"\nOPEN-SQUARE-BRACKET = \"[\"\nCLOSE-SQUARE-BRACKET = \"]\"\nOPEN-PAREN = \"(\"\nCLOSE-PAREN = \")\"\nCOLON = \":\"\nDOUBLE-COLON = \"::\"\nQUOTE = %x22\nCOMMA = \",\"\nRETURN-ARROW = \"->\"\nEQUAL = \"=\"\nBANG = \"!\"\nAMP = \"&\"\nMUT = \"mut\"\n\nALPHA = %x41-5A / %x61-7A ; A-Z / a-z\nDIGIT = %x30-39\nWS = %x09 / \" \"\n```\n\n----------------------------------------\n\nTITLE: Fixing E0573: Implementing on a struct\nDESCRIPTION: This code snippet shows how to define a struct with a constant value. It shows that `impl` blocks can only be used with types such as structs, enums, or traits, not on constants. Creating a new type such as a struct and implementing on the struct fixes the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0573.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```\nstruct Hobbit(u32); // we create a new type\n\nconst HOBBIT: Hobbit = Hobbit(2);\nimpl Hobbit {} // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Kakoune with kak-lsp (Shell)\nDESCRIPTION: This shell snippet configures Kakoune to use kak-lsp for Rust development, enabling LSP features, auto-formatting on save, and inlay hints. It involves executing kak-lsp within Kakoune, enabling the LSP client for Rust files, setting up hooks for auto-formatting before saving, and configuring inlay hints after saving.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\neval %sh{kak-lsp --kakoune -s $kak_session}  # Not needed if you load it with plug.kak.\nhook global WinSetOption filetype=rust %{\n    # Enable LSP\n    lsp-enable-window\n\n    # Auto-formatting on save\n    hook window BufWritePre .* lsp-formatting-sync\n\n    # Configure inlay hints (only on save)\n    hook window -group rust-inlay-hints BufWritePost .* rust-analyzer-inlay-hints\n    hook -once -always window WinSetOption filetype=.* %{\n        remove-hooks window rust-inlay-hints\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Operator Front Style\nDESCRIPTION: Example showing binary operator placement at the front of continued lines when expressions span multiple lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo\n        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;\n\n    let sum = 123456789012345678901234567890\n        + 123456789012345678901234567890\n        + 123456789012345678901234567890;\n\n    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Alias Feature Usage\nDESCRIPTION: Demonstrates the use of trait aliases (nightly feature) as an alternative to type aliases when working with traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0404.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(trait_alias)]\ntrait Foo = Iterator<Item=String>;\n\nfn bar<T: Foo>(t: T) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Clippy Configuration File\nDESCRIPTION: Example TOML configuration file for customizing Clippy behavior\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\navoid-breaking-exported-api = false\ndisallowed-names = [\"toto\", \"tata\", \"titi\"]\n```\n\n----------------------------------------\n\nTITLE: Resolving Name Conflicts Using Aliases in Rust\nDESCRIPTION: Demonstrates how to fix name conflicts by using the 'as' keyword to create an alias for the imported function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0255.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bar::foo as bar_foo; // ok!\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Snippets in VS Code for Rust\nDESCRIPTION: JSON configuration example for defining a custom snippet in rust-analyzer. This example creates a 'thread spawn' snippet that can be triggered with 'spawn' or 'tspawn' and requires the std::thread module to be in scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.completion.snippets.custom\": {\n    \"thread spawn\": {\n      \"prefix\": [\"spawn\", \"tspawn\"],\n      \"body\": [\n        \"thread::spawn(move || {\",\n        \"\\t$0\",\n        \"});\",\n      ],\n      \"description\": \"Insert a thread::spawn call\",\n      \"requires\": \"std::thread\",\n      \"scope\": \"expr\",\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Dereferencing without Deref Patterns in Rust\nDESCRIPTION: This code shows how nested dereferencing is performed without the `deref_patterns` feature. It manually dereferences the `Vec`, `Box`, and `Option` types using `*` operators to access the underlying value. This approach requires creating temporary variables to hold the dereferenced values and can be more verbose and less readable than using `deref_patterns`.  No specific dependencies are required beyond standard library features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/deref-patterns.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut v = vec![Box::new(Some(0))];\nif let [b] = &mut *v {\n    if let Some(x) = &mut **b {\n        *x += 1;\n    }\n}\nif let [b] = &mut *v {\n    if let opt_x @ Some(1) = &mut **b {\n        opt_x.as_mut().map(|x| *x += 1);\n    }\n}\nassert_eq!(v, [Box::new(Some(2))]);\n```\n\n----------------------------------------\n\nTITLE: Markdown Feature Documentation Header\nDESCRIPTION: Markdown header and description for the extended_varargs_abi_support feature, including tracking issue reference and purpose of the feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/extended-varargs-abi-support.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `extended_varargs_abi_support`\n\nThe tracking issue for this feature is: [#100189]\n\n[#100189]: https://github.com/rust-lang/rust/issues/100189\n\n------------------------\n\nThis feature adds the possibility of using `sysv64`, `win64` or `efiapi` calling\nconventions on functions with varargs.\n```\n\n----------------------------------------\n\nTITLE: Platform Check Helpers in Rust Run Make Support\nDESCRIPTION: Utility functions for checking platform-specific details and performing cross-platform operations in test environments\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/run-make-support/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// Platform check helper functions\nfn is_windows() -> bool;\nfn is_msvc() -> bool;\nfn cygpath_windows(path: &str) -> String;\nfn uname() -> String;\n```\n\n----------------------------------------\n\nTITLE: Trait with Associated Constants Not Being dyn-compatible in Rust\nDESCRIPTION: Demonstrates that traits with associated constants cannot be used as trait objects because constants aren't stored in the method table.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\n----------------------------------------\n\nTITLE: Valid Use of Same Method Names in Non-Overlapping Implementations\nDESCRIPTION: This code demonstrates the valid usage of methods with the same name in different non-overlapping implementations. Here, the 'bar' method is defined for two different generic instantiations of the Foo struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0201.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T>(T);\n\nimpl Foo<u8> {\n    fn bar(&self) -> bool { self.0 > 5 }\n}\n\nimpl Foo<bool> {\n    fn bar(&self) -> bool { self.0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Optimize Attribute Usage in Rust\nDESCRIPTION: Demonstrates correct usage of the #[optimize] attribute with size optimization flag to generate smaller code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0722.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(optimize_attribute)]\n\n#[optimize(size)]\npub fn something() {}\n```\n\n----------------------------------------\n\nTITLE: Parsing Floating Point Literals in Rust\nDESCRIPTION: Test cases for parsing float literals with scientific notation, decimal points, and type suffixes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/numbers.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nFLOAT_NUMBER \"0.\"\nFLOAT_NUMBER \"0.1279\"\nFLOAT_NUMBER \"0e1279\"\nFLOAT_NUMBER \"0E1279\"\nFLOAT_NUMBER \"0e+1\"\nFLOAT_NUMBER \"0.0E-2\"\nFLOAT_NUMBER \"0___0.10000____0000e+111__\"\nFLOAT_NUMBER \"92.0f32\"\n```\n\n----------------------------------------\n\nTITLE: Git Configuration for Pushing over SSH with Bash\nDESCRIPTION: This snippet shows the Git configuration command to use SSH for pushing changes to avoid authentication issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\n[url \"git@github.com:\"]\n    pushInsteadOf = https://github.com/\n```\n\n----------------------------------------\n\nTITLE: Identifying Private Item Error in Rust\nDESCRIPTION: This snippet demonstrates a compilation error when a private method is called outside its scope. It highlights the 'private method' issue during compilation in Rust. No dependencies are involved, and the expected output is a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0624.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // error: method `method` is private\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of 'continue' in Rust Functions\nDESCRIPTION: This code snippet demonstrates the correct usage of the 'continue' keyword in Rust functions. The 'continue' statement is used properly within labeled loops, which will compile successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0696.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn continue_simple() {\n    'b: loop {\n        continue ; // ok!\n    }\n}\nfn continue_labeled() {\n    'b: loop {\n        continue 'b; // ok!\n    }\n}\nfn continue_crossing() {\n    loop {\n        'b: loop {\n            continue; // ok!\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Char Casting and Conversion Methods\nDESCRIPTION: Shows correct ways to convert integers to char using direct casting for u8 and char::from_u32() for checking Unicode Scalar Value compatibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0604.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(86u8 as char, 'V'); // ok!\nassert_eq!(char::from_u32(0x3B1), Some('α')); // ok!\nassert_eq!(char::from_u32(0xD800), None); // not a USV.\n```\n\n----------------------------------------\n\nTITLE: Configuring Self-Contained Linking in Rust\nDESCRIPTION: This example demonstrates how to use fine-grained control for self-contained linking in Rust. It shows how to enable the 'linker' component while using the GNU LLD linker flavor.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/codegen-options.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-Clinker-flavor=gnu-lld-cc -Clink-self-contained=+linker\n```\n\n----------------------------------------\n\nTITLE: Triggering Rust E0161 with Unsized Move\nDESCRIPTION: This Rust code demonstrates the E0161 error. It defines a trait and attempts to call a method `f` on a `Box<dyn Bar>`. The method `f` takes `self` by value, which requires moving the underlying `dyn Bar`. Since `dyn Bar` is a dynamically sized type (unsized), its size is not known at compile time, making it impossible to move, resulting in the E0161 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0161.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Bar {\n    fn f(self);\n}\n\nimpl Bar for i32 {\n    fn f(self) {}\n}\n\nfn main() {\n    let b: Box<dyn Bar> = Box::new(0i32);\n    b.f();\n    // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot\n    //        be statically determined\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Example: Using align representation on a struct with packed field\nDESCRIPTION: This code demonstrates a valid case where an aligned struct contains a field with a packed representation hint, which is allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0588.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\nstruct Packed(i32);\n\n#[repr(align(16))] // ok!\nstruct Aligned(Packed);\n```\n\n----------------------------------------\n\nTITLE: Using rustc to list supported crate types for a target\nDESCRIPTION: Example command showing how to use the `--print=supported-crate-types` option with rustc. This command requires the `-Zunstable-options` flag since this is an unstable feature tracked by issue #138640.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/print-supported-crate-types.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc --print=supported-crate-types -Zunstable-options --target=x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Rust FFI Const Attribute Example\nDESCRIPTION: Example showing the #[ffi_const] attribute syntax used in Rust FFI declarations. This attribute indicates that the function has no side effects and its return value depends only on its parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/ffi-const.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[ffi_const]\n```\n\n----------------------------------------\n\nTITLE: Correcting Lifetime Bounds in Rust\nDESCRIPTION: This code snippet provides a corrected version of the previous example, where the lifetime of `'SnowWhite` is explicitly stated to outlive the lifetime of `'kiss`. This adjustment ensures compliance with Rust’s strict lifetime rules, allowing the code to compile successfully without errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0478.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Wedding<'t>: 't { }\n\nstruct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'SnowWhite\n                                          // must live longer than 'kiss.\n    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n}\n```\n\n----------------------------------------\n\nTITLE: Error Example: Using Undeclared HashMap Type\nDESCRIPTION: Demonstrates the error that occurs when trying to use HashMap without importing it from the standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0433.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Function Calls in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for function calls. Arguments after the first line are aligned with the start of the first argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    lorem(\"lorem\",\n          \"ipsum\",\n          \"dolor\",\n          \"sit\",\n          \"amet\",\n          \"consectetur\",\n          \"adipiscing\",\n          \"elit\");\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Functions with Concatenated Names in Rust\nDESCRIPTION: This example demonstrates using the concat metavariable expression to create test function names that incorporate the tested type and operation. The macro creates multiple test functions for different integer types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(macro_metavar_expr_concat)]\n\nmacro_rules! test_math {\n    ($integer:ident) => {\n        #[test]\n        fn ${ concat(test_, $integer, _, addition) } () {\n            let a: $integer = 73;\n            let b: $integer = 42;\n            assert_eq!(a + b, 115)\n        }\n\n        #[test]\n        fn ${ concat(test_, $integer, _, subtraction) } () {\n            let a: $integer = 73;\n            let b: $integer = 42;\n            assert_eq!(a - b, 31)\n        }\n    }\n}\n\ntest_math!(i32);\ntest_math!(u64);\ntest_math!(u128);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closure Restrictions with Opaque Types in Rust\nDESCRIPTION: This code snippet demonstrates a case where an opaque type with an external lifetime is used within a closure. While this specific example compiles in current nightly, it should be considered an error due to potential issues with member constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x> = impl Sized + 'x;\n\nfn test<'a>() -> Opaque<'a> {\n    let _ = || {\n        // `'a` is external to the closure\n        let _: Opaque<'a> = ();\n        //~^ Should be an error!\n    };\n    ()\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Associated Types in Rust\nDESCRIPTION: Shows the proper formatting for associated types in Rust, specifying to include a space after the colon but not before when adding bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\npub type Foo: Bar;\n```\n\n----------------------------------------\n\nTITLE: Monomorphization Example\nDESCRIPTION: This code demonstrates a simple example used to explain monomorphization collection.  The `banana` function calls the generic `peach` function with a concrete type `u64`. The monomorphization collector identifies `main`, `banana`, and `peach::<u64>` as functions that require machine code generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/monomorph.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn banana() {\n   peach::<u64>();\n}\n\nfn main() {\n    banana();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Documentation Aliases in Rust\nDESCRIPTION: Shows how to add aliases to documentation items in Rust using the `#[doc(alias)]` attribute. This allows improved searchability within the generated documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/advanced-features.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"#[doc(alias = \\\"x\\\")]\\n#[doc(alias = \\\"big\\\")]\\npub struct BigX;\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"#[doc(alias(\\\"x\\\", \\\"big\\\"))]\\npub struct BigX;\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Fields with Generics\nDESCRIPTION: This code snippet demonstrates how to use generic types in structs and access their fields. It shows how to instantiate generic parameters for struct Foo with types u32 and f32, particularly emphasizing how to access the field 'x' which is a vector of type A within Foo. It requires the Rust standard library for managing vectors. The output will be the value of type Vec<u32> that is accessible through 'foo.x'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/early_binder.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<A, B> {\n    x: Vec<A>,\n    ..\n}\n\nfn bar(foo: Foo<u32, f32>) { \n    // the type of `foo`'s `x` field before instantiating it would be:\n    // `EarlyBinder(Vec<A/#0>)`\n    // we then instantiate the binder with `[u32, f32]` as those are the\n    // generic arguments to the `Foo` struct. This results in a type of:\n    // `Vec<u32>`\n    let y = foo.x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Byte String Literals in Rust\nDESCRIPTION: This snippet illustrates how to define byte string literals in Rust, using both standard `b\"\"` and raw `br\"\"` string syntax. It demonstrates creating empty byte strings and byte strings with content.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/byte_strings.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE_STRING \\\"b\\\\\\\"foo\\\\\\\"\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE_STRING \\\"br\\\\\\\"\\\\\\\"\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE_STRING \\\"b\\\\\\\"\\\\\\\"ix\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE_STRING \\\"br\\\\\\\"\\\\\\\"br\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Working Example: Re-exporting Public Module in Rust\nDESCRIPTION: This example shows the correct way to re-export a module by making it public with the pub keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0365.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod foo {\n    pub const X: u32 = 1;\n}\n\npub use foo as foo2;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: String Literal Missing Quote in Rust\nDESCRIPTION: This error message indicates that a string literal is missing its closing quotation mark.  When the Rust compiler encounters an unclosed string, it throws this error to prevent undefined behavior.  Fixing the error involves adding the missing `\"` symbol to properly terminate the string.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_string_with_ascii_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"\\\"\\\\x7f\" error: Missing trailing `\\\"` symbol to terminate the string literal\"\n```\n\n----------------------------------------\n\nTITLE: Fix: Reclaiming Ownership from RefCell in Rust\nDESCRIPTION: This code demonstrates another fix for E0507: reclaiming ownership from the `RefCell` using `into_inner()`. This allows moving the value out of the `RefCell` because we now have ownership of it. This approach is suitable when you need to take ownership of the contained value and no longer need the `RefCell`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Jobserver Warning in Rust Compiler\nDESCRIPTION: Shows how rustc warns when a jobserver is specified but not accessible through MAKEFLAGS environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/jobserver.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ echo 'fn main() {}' | MAKEFLAGS=--jobserver-auth=3,4 rustc -\nwarning: failed to connect to jobserver from environment variable `MAKEFLAGS=\"--jobserver-auth=3,4\"`: cannot open file descriptor 3 from the jobserver environment variable value: Bad file descriptor (os error 9)\n  |\n  = note: the build environment is likely misconfigured\n```\n\n----------------------------------------\n\nTITLE: Using #[autodiff(...)] with Fat-LTO in Rust\nDESCRIPTION: The `#[autodiff(...)]` attribute in Enzyme requires the project to be compiled with Fat-LTO.  This is currently necessary to ensure proper differentiation when the function being differentiated calls functions in other compilation units.  While other solutions are possible, Fat-LTO is the simplest way to get started.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/limitations.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Basic Git Workflow Commands for Contributing to std::simd\nDESCRIPTION: A sequence of Git commands demonstrating the basic workflow for contributing to the std::simd module, including cloning, creating branches, committing changes, and pushing to a remote repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone it\ngit checkout -b my-branch\ncargo test\ngit commit add ./path/to/changes && git commit -m 'Fix some bug'\ngit push --set-upstream origin my-branch\n```\n\n----------------------------------------\n\nTITLE: Rust FileSymbol for Struct\nDESCRIPTION: This snippet shows an example of a `FileSymbol` struct representing a struct named `StructInModB`. It includes the struct's definition (`Adt(Struct(...))`), location in the source file (`DeclarationLocation`), and other flags. The definition provides the struct's ID, and the location specifies the file, node type, and range of the struct's name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{\n    name: \"StructInModB\",\n    def: Adt(\n        Struct(\n            Struct {\n                id: StructId(\n                    4,\n                ),\n            },\n        ),\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                1,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: STRUCT,\n            range: 0..20,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 7..19,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Markdown-After-Content Option with Rustdoc\nDESCRIPTION: Demonstrates how to include rendered Markdown content after the main documentation content. This flag allows inserting extra content before the </body> tag that's processed through a Markdown renderer first.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md\n$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md\n```\n\n----------------------------------------\n\nTITLE: Function Precondition Pattern Example\nDESCRIPTION: Shows the preferred way to handle function preconditions using types rather than runtime checks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn frobnicate(walrus: Walrus) {\n    ...\n}\n\n// BAD\nfn frobnicate(walrus: Option<Walrus>) {\n    let walrus = match walrus {\n        Some(it) => it,\n        None => return,\n    };\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Self-Referential Supertrait Method Example in Rust\nDESCRIPTION: Shows a potential supertrait implementation that, while dyn-compatible on its own, becomes problematic when used with Self as a type parameter because the concrete return type cannot be determined.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Panic Unwind - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `panic_unwind` crate (index 3). It specifies the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate provides the `panic!` implementation that unwinds the stack.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n3: CrateData {\n    root_file_id: FileId(\n        4,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"panic_unwind\",\n            ),\n            canonical_name: \"panic_unwind\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Other,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Converting a Regular String to a Raw String in Rust\nDESCRIPTION: Demonstrates converting a regular string literal to a raw string format by adding r# delimiters. This is useful when dealing with strings containing special characters that would otherwise need escaping.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_78\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    \"Hello,┃ World!\";\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r#\"Hello, World!\"#;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting DWARF Version in Rust\nDESCRIPTION: Controls the DWARF version emitted for debug information. Values include `2`, `3`, `4`, and `5`. DWARF version 1 is not supported.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Block Expression Formatting in Rust\nDESCRIPTION: Guidelines for formatting block expressions, including rules for statement and expression positions, keywords, and single-line vs multi-line blocks\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn block_as_stmt() {\n    a_call();\n\n    {\n        a_call_inside_a_block();\n\n        // a comment in a block\n        the_value\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn block_as_expr() {\n    let foo = {\n        a_call_inside_a_block();\n\n        // a comment in a block\n        the_value\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait on a Generic Type in Rust\nDESCRIPTION: This code demonstrates one way to resolve the E0118 error by implementing a trait for the generic type `T`.  This allows defining methods for `T` without requiring it to be a struct, enum, or union. The `LiveLongAndProsper` trait is defined and then implemented for the generic type `T`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0118.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// we create a trait here\ntrait LiveLongAndProsper {\n    fn get_state(&self) -> String;\n}\n\n// and now you can implement it on T\nimpl<T> LiveLongAndProsper for T {\n    fn get_state(&self) -> String {\n        \"He's dead, Jim!\".to_owned()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Required Arguments in Rust\nDESCRIPTION: This example shows a function definition with two required parameters. This function must always be called with exactly two arguments matching the specified types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0061.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn f(a: u16, b: &str) {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Usage of #[track_caller] with Extern C Function in Rust\nDESCRIPTION: This code snippet shows an erroneous example of using the #[track_caller] attribute with an extern \"C\" function, which is not allowed. The #[track_caller] attribute requires functions to have the \"Rust\" ABI for implicitly receiving caller location.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0737.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[track_caller]\nextern \"C\" fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Filename Data in Rust\nDESCRIPTION: Allows adding extra data to the output filename. It takes a string, to be added as a suffix. See the [`--emit` flag] for more information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Implementing TrustZone-M Secure Entry Function in Rust\nDESCRIPTION: Example of creating a secure entry function using the C-cmse-nonsecure-entry ABI. The function takes a u32 parameter and returns a u32 value. This implementation demonstrates proper usage of the feature flag and required attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/cmse-nonsecure-entry.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n#![feature(cmse_nonsecure_entry)]\n\n#[no_mangle]\npub extern \"C-cmse-nonsecure-entry\" fn entry_function(input: u32) -> u32 {\n    input + 6\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Borrow Method Instead of Taking Ownership in Rust\nDESCRIPTION: This code demonstrates one fix for the E0507 error: changing the method signature to accept a borrow (`&self`) instead of taking ownership of `self`. By accepting a borrow, the method no longer attempts to move the value, resolving the error. This is suitable when the method does not need to consume the `self` value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying a custom output path for coverage data\nDESCRIPTION: Example showing how to use the LLVM_PROFILE_FILE environment variable to specify a custom name for the generated coverage data file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ echo \"{some: 'thing'}\" \\\n    | LLVM_PROFILE_FILE=\"formatjson5.profraw\" target/debug/examples/formatjson5 -\n...\n$ ls formatjson5.profraw\nformatjson5.profraw\n```\n\n----------------------------------------\n\nTITLE: Invalid Loop Break Syntax in Rust\nDESCRIPTION: Demonstrates an incorrect usage of break keyword without a label in a while loop condition, which triggers a compile-time error E0590\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0590.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nwhile break {}\n```\n\n----------------------------------------\n\nTITLE: Adding Configuration Fields to Clippy Lint Struct in Rust\nDESCRIPTION: Example showing how to add configuration values to a lint implementation struct and provide a constructor method that accepts the Clippy configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\npub struct StructName {\n    configuration_ident: Type,\n}\n\n// ...\n\nimpl StructName {\n    pub fn new(conf: &'static Conf) -> Self {\n        Self {\n            configuration_ident: conf.configuration_ident,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting impl Trait to a Named Type Parameter in Rust\nDESCRIPTION: Shows replacing an 'impl Trait' function parameter with a named generic type parameter. This transformation makes the generic type explicitly available throughout the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_75\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(bar: ┃impl Bar) {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<┃B: Bar>(bar: B) {}\n```\n\n----------------------------------------\n\nTITLE: Example Code Demonstrating AST vs Type Checking\nDESCRIPTION: Example Rust code that illustrates the difference between AST-level checking (syntax only) and type-level checking. This code is syntactically correct but has undefined types and methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/lint_passes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = OurUndefinedType;\nx.non_existing_method();\n```\n\n----------------------------------------\n\nTITLE: Showing Moved Lines in Git Diffs Using Color-Moved Option - bash\nDESCRIPTION: This bash snippet demonstrates how to use the git log command with the --color-moved option to visually highlight lines that have been moved within a file during a commit. The flags used include --color-moved=dimmed-zebra to color moved lines distinctively and --color-moved-ws=allow-indentation-change to allow indentation changes while detecting moved code. This helps reviewers better understand large code moves that Git's default diff view does not handle well.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\ngit log -p --color-moved=dimmed-zebra --color-moved-ws=allow-indentation-change\n```\n\n----------------------------------------\n\nTITLE: Creating QEMU Image for Rust Test Environment\nDESCRIPTION: Command to generate a QEMU image with sufficient disk space and inode resources for running Rust test suite\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkqnximage --type=qemu --ssh-ident=$HOME/.ssh/id_ed25519.pub --data-size=5000 --data-inodes=40000\n```\n\n----------------------------------------\n\nTITLE: Merging Import Statements in Rust\nDESCRIPTION: Demonstrates combining multiple import statements that share a common prefix into a single nested import. This reduces code duplication and makes imports more concise.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_80\n\nLANGUAGE: rust\nCODE:\n```\nuse std::┃fmt::Formatter;\nuse std::io;\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{fmt::Formatter, io};\n```\n\n----------------------------------------\n\nTITLE: Retrieving the `Sized` Trait Lang Item in Rust\nDESCRIPTION: This code snippet demonstrates how to retrieve the `sized_trait` lang item using `tcx.lang_items()`. It checks if the trait is available (since it might not be in `#![no_core]` contexts) and proceeds accordingly if found. The code uses the `Option` type to handle cases where the lang item is not present.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/lang-items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Note that in case of `#![no_core]`, the trait is not available.\nif let Some(sized_trait_def_id) = tcx.lang_items().sized_trait() {\n    // do something with `sized_trait_def_id`\n}\n```\n\n----------------------------------------\n\nTITLE: Using arbitrary_self_types_pointers Feature in Rust\nDESCRIPTION: Demonstrates how to use the arbitrary_self_types_pointers feature to allow methods to receive self as a raw pointer. This example shows a method taking self as a constant pointer to Self.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types-pointers.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types_pointers)]\n\nstruct A;\n\nimpl A {\n    fn m(self: *const Self) {}\n}\n\nfn main() {\n    let a = A;\n    let a_ptr: *const A = &a as *const A;\n    a_ptr.m();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Explicit Enum Discriminants in Rust\nDESCRIPTION: This assist adds explicit discriminant values to all enum variants. It automatically assigns incremental values, respecting any existing explicit discriminants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum TheEnum {\n    Foo,\n    Bar,\n    Baz = 42,\n    Quux,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum TheEnum {\n    Foo = 0,\n    Bar = 1,\n    Baz = 42,\n    Quux = 43,\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying a Merge Conflict During Rebase\nDESCRIPTION: Shows the output message from Git indicating that a conflict occurred while trying to reapply a commit during a rebase. It specifies the file where the conflict was detected.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nCONFLICT (content): Merge conflict in file.rs\n```\n\n----------------------------------------\n\nTITLE: Macro Definition Example 1 (Rust)\nDESCRIPTION: This example builds upon the previous one, adding another macro `n` nested inside `m`. It shows how the context of `ident` becomes `ROOT -> id(m) -> id(n)` after both macros are expanded.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmacro m() { macro n() { ident } }\n\nm!();\nn!();\n```\n\n----------------------------------------\n\nTITLE: Linking for Arm64EC Target\nDESCRIPTION: Linker command for creating Arm64EC compatible binaries using the link tool with ARM64EC machine specification\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64ec-pc-windows-msvc.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlink /MACHINE:ARM64EC ...\n```\n\n----------------------------------------\n\nTITLE: Converting Match to let-else in Rust\nDESCRIPTION: Transforms a match statement into a let-else statement, simplifying conditional assignments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(opt: Option<()>) {\n    let Some(val) = opt else { return };\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Self Keyword in Rust Traits\nDESCRIPTION: A demonstration of the correct usage of 'Self' within a trait definition, accessing associated items of a type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0411.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type Bar;\n}\n\ntrait Baz : Foo {\n    fn bar() -> Self::Bar; // like this\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring check-private-items\nDESCRIPTION: Determines whether the lints should also be applied to private items within the codebase. Defaults to `false`.  Enabling this extends linting to private entities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Incorrect Pattern Matching in Rust Loop Variable\nDESCRIPTION: This example demonstrates incorrect pattern matching in a for loop where the pattern is refutable (Some(x)), which would fail when encountering None values. This code produces error E0005.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0297.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\n// This fails because `None` is not covered.\nfor Some(x) in xs {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Example: Re-exporting Private Module in Rust\nDESCRIPTION: This example demonstrates the incorrect attempt to publicly re-export a private module, which results in error E0365.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0365.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub const X: u32 = 1;\n}\n\npub use foo as foo2;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Using Type Parameter in Rust Enum to Resolve E0392 Error\nDESCRIPTION: This code snippet shows how to fix the E0392 error by actually using the declared type parameter in the enum variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0392.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo<T> {\n    Bar(T),\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Raw String Literal in Rust\nDESCRIPTION: This snippet demonstrates how to declare a raw string literal in Rust using `r#\"...\"#` syntax. It shows that raw strings can contain quotes and other characters without needing escapes. Dependencies are minimal, only requiring Rust's standard syntax. The key purpose is to create a raw string with embedded quotes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/raw_strings.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSTRING \"r###\\\"this is a r##\\\"raw\\\"## string\\\"###\"\n```\n\n----------------------------------------\n\nTITLE: Sequential Closure Execution to Avoid Borrow Conflicts\nDESCRIPTION: This code snippet demonstrates how to avoid mutable borrow conflicts by executing closures sequentially within distinct scopes. By dropping the first closure's reference before creating the second, we ensure that there are no overlapping mutable borrows.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0524.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn set(x: &mut isize) {\n    *x += 4;\n}\n\nfn dragoooon(x: &mut isize) {\n    { // This block isn't necessary since non-lexical lifetimes, it's just to\n      // make it more clear.\n        let mut c1 = || set(&mut *x);\n        c1();\n    } // `c1` has been dropped here so we're free to use `x` again!\n    let mut c2 = || set(&mut *x);\n    c2();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Mismatch Errors in Rust\nDESCRIPTION: This code snippet illustrates various scenarios where type mismatches can occur in Rust, triggering the E0308 error. It shows examples of mismatched types in function arguments, conditional statements, and variable assignments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0308.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\n----------------------------------------\n\nTITLE: Incorrect Lifetime Usage in Rust Function\nDESCRIPTION: Example showing incorrect usage of static lifetime annotation that causes a compilation error. The function attempts to return a static reference from a parameter with a shorter lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0312.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n    if maybestr.is_none() {\n        \"(none)\"\n    } else {\n        let s: &'a str = maybestr.as_ref().unwrap();\n        s  // Invalid lifetime!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with Coverage Instrumentation in Rust\nDESCRIPTION: This shell command sets `RUSTFLAGS` to enable code coverage instrumentation during tests, using the `-C instrument-coverage` flag. The command builds and runs Rust test suites, generating `.profraw` files for further analysis. It is important to note the test binary paths for subsequent processing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"-C instrument-coverage\" \\\n    cargo test --tests\n```\n\n----------------------------------------\n\nTITLE: Failure Status Check Implementation in Rust Test Runner\nDESCRIPTION: Implementation of checking test failure status with dynamic error code handling\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/directives.md#2025-04-21_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\nfn check_correct_failure_status(&self, proc_res: &ProcRes) {\n        let expected_status = Some(self.props.failure_status);\n        let received_status = proc_res.status.code();\n\n        if expected_status != received_status {\n            self.fatal_proc_rec(\n                &format!(\"Error: expected failure status ({:?}) but received status {:?}.\",\n                         expected_status,\n                         received_status),\n                proc_res,\n            );\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Using the rustfmt::skip attribute on imports in Rust\nDESCRIPTION: Example of using the rustfmt::skip attribute to prevent formatting of imports.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\n#[rustfmt::skip]\nuse some::long::import::path;\n```\n\n----------------------------------------\n\nTITLE: Disabling Clippy Evaluation for Certain Code\nDESCRIPTION: This snippet shows how to prevent Clippy from evaluating a specific section of code using conditional compilation. It includes an example where a stub is provided to ensure code compiles.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/configuration.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(not(clippy))]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/my_big_function-generated.rs\"));\n\n#[cfg(clippy)]\nfn my_big_function(_input: &str) -> Option<MyStruct> {\n    None\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage Command - Rust Test Report Time\nDESCRIPTION: Shows the basic command to enable test execution time reporting using the unstable options flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/report-time.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./test_executable -Zunstable-options --report-time\n```\n\n----------------------------------------\n\nTITLE: Enabling the profiler feature in bootstrap.toml\nDESCRIPTION: Configuration for enabling the Rust profiler runtime in bootstrap.toml, which is required for using instrument-coverage compiler option when building Rust from source.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Build the profiler runtime (required when compiling with options that depend\n# on this runtime, such as `-C profile-generate` or `-C instrument-coverage`).\nprofiler = true\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Code Models\nDESCRIPTION: Shows how to list available code models using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print code-models a.rs\nAvailable code models:\n    tiny\n    small\n    kernel\n    medium\n    large\n```\n\n----------------------------------------\n\nTITLE: Byte Literals with Suffixes in Rust\nDESCRIPTION: This snippet shows how to define byte literals with suffixes in Rust.  Suffixes are appended directly after the byte literal.  This might affect how the literal is interpreted by subsequent processing steps.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/byte_strings.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b''suf\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'hello'\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Super Trait Implementation\nDESCRIPTION: Shows how to create a new trait with inherited trait bounds using super traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0404.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# trait Foo {}\n# struct Bar;\n# impl Foo for Bar {}\ntrait Qux: Foo {} // Anything that implements Qux also needs to implement Foo\nfn baz<T: Qux>(t: T) {} // also ok!\n```\n\n----------------------------------------\n\nTITLE: Self as Type Parameter in Supertrait Making Trait Non-dyn-compatible in Rust\nDESCRIPTION: Demonstrates a trait that uses Self as a type parameter in its supertrait listing, making it non-dyn-compatible due to the inability to determine the concrete type in trait object contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring enum-variant-size-threshold\nDESCRIPTION: Sets the maximum size of an enum's variant to avoid box suggestions. Defaults to `200`. This helps in optimizing memory usage by suggesting boxing for large enum variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_18\n\n\n\n----------------------------------------\n\nTITLE: Multiple Incorrect Pattern Matching Examples in Rust\nDESCRIPTION: Additional examples of incorrect pattern matching with both too few and too many fields. This demonstrates different ways the E0023 error can be triggered when patterns don't match the declared number of fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0023.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n\nlet x = Fruit::Apple(String::new(), String::new());\n\n// Incorrect.\nmatch x {\n    Fruit::Apple(a) => {},\n    Fruit::Apple(a, b, c) => {},\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Const Generic Parameter Type Example\nDESCRIPTION: Example showing incorrect usage of a non-structural-match type as a const generic parameter, which results in compilation error E0741.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0741.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(adt_const_params)]\n\nstruct A;\n\nstruct B<const X: A>; // error!\n```\n\n----------------------------------------\n\nTITLE: Building LLVM and Enzyme without Rust\nDESCRIPTION: This snippet provides instructions on how to build LLVM and Enzyme independently without the Rust environment, using CMake.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth=1 git@github.com:llvm/llvm-project.git \ncd llvm-project\nmkdir build\ncd build\ncmake -G Ninja ../llvm -DLLVM_TARGETS_TO_BUILD=\"host\" -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_ENABLE_PROJECTS=\"clang;lld\" -DLLVM_ENABLE_RUNTIMES=\"openmp\" -DLLVM_ENABLE_PLUGINS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=.\nninja\nninja install\n```\n\n----------------------------------------\n\nTITLE: Rustfmt Skip Directives Example\nDESCRIPTION: Example showing how to use rustfmt skip directives to prevent formatting of specific macros and attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![rustfmt::skip::attributes(custom_attribute)]\n\n#[custom_attribute(formatting , here , should , be , Skipped)]\n#[rustfmt::skip::macros(html)]\nfn main() {\n    let macro_result1 = html! { <div>\nHello</div>\n    }.to_string();\n```\n\n----------------------------------------\n\nTITLE: Detecting CET-Enabled ELF Binaries\nDESCRIPTION: This command uses the `readelf` utility to check for the presence of IBT and SHSTK tags in an ELF binary, which indicates that it is CET-enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/cf-protection.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ readelf -a target/x86_64-unknown-linux-gnu/debug/example | grep feature:\n      Properties: x86 feature: IBT, SHSTK\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Struct in Rust\nDESCRIPTION: Defines a simple Rust struct `Foo` with a single generic type parameter `T`, used within a `Vec<T>`. This example serves to illustrate how the type parameter `T` is represented internally as `TyKind::Param` with name \"T\" and index 0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/param_ty_const_regions.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T>(Vec<T>);\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function and Instantiating Types\nDESCRIPTION: This snippet demonstrates how to define a generic function 'foo' that takes two parameters of generic types T and U. It shows how to instantiate the generic parameters when calling the function from 'main'. Required dependencies include the Rust standard library for basic function definitions. The expected input is two values of types i32 and u128, and the output is the value of type T, which is i32 in this case.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/early_binder.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T, U>(a: T, _b: U) -> T { a }\n\nfn main() {\n    let c = foo::<i32, u128>(1, 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving E0373 Error with Move Closure in Rust\nDESCRIPTION: This snippet shows the solution to the E0373 error by using a move closure, which takes ownership of the captured variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0373.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Box<dyn Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Opaque Type Alias in Rust\nDESCRIPTION: This snippet demonstrates how to declare an opaque type alias in Rust using the `impl Trait` syntax. It creates a type `Foo` that only exposes the `Bar` trait as its interface.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-type-alias-impl-trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo = impl Bar;\n```\n\n----------------------------------------\n\nTITLE: Passing Options to Test Runner\nDESCRIPTION: This code snippet demonstrates how to use the `--test-args` flag to pass options to the test runner when running documentation tests. This allows customization of the test execution environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --test --test-args ignored\n```\n\n----------------------------------------\n\nTITLE: MIR Assignment and Function Call Example\nDESCRIPTION: This MIR snippet demonstrates an assignment and a function call in MIR, showing how temporary variables are used and how function calls are represented as terminators.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/index.md#2025-04-21_snippet_4\n\nLANGUAGE: mir\nCODE:\n```\nbb2: {\n    StorageLive(_3);\n    _3 = &mut _1;\n    _2 = const <std::vec::Vec<T>>::push(move _3, const 1i32) -> [return: bb3, unwind: bb4];\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing External ClangRT Option in Rust Compiler\nDESCRIPTION: This code snippet shows the markdown syntax for referencing the 'external-clangrt' option in Rust compiler documentation. It explains the purpose of the option and provides links to related documentation on sanitizers and working with other languages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/external-clangrt.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `external-clangrt`\n\nThis option controls whether the compiler links in its own runtime library for\n[sanitizers](./sanitizer.md). Passing this flag makes the compiler *not* link\nits own library. For more information, see the section in the sanitizers doc on\n[working with other languages.](./sanitizer.md#working-with-other-languages)\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Library Features in TOML\nDESCRIPTION: This snippet defines various Rust library features using TOML syntax. It includes features for the standard library, runtime capabilities, and compiler options. Each feature is described with its purpose and configuration details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# These are features which are enabled by default. If you wish to disable one of these\n# features, you must also set `default = false` in addition to setting the feature\n# itself to `false`. This form is necessary because otherwise Cargo will assume\n# `default = true`, which will enable any feature which has not been explicitly\n# disabled.\n[features]\ndefault = []\n\n# Allow the standard library to be compiled with some restrictions\nrestricted-std = []\n\n# Allow the standard library to be built without jemalloc\n#\n# By default jemalloc is used as the global allocator. Disabling this feature\n# removes the dependency on jemalloc, which can be useful in constrained\n# environments.\ndefault-alloc = []\n\n# Allow the standard library to be built without any special panic handling\n#\n# By default the standard library contains special panic handling, but disabling\n# this feature removes it. This can be useful in constrained environments or\n# when you want to provide your own panic handling.\ndefault-panic = []\n\n# Allow the standard library to be built with backtrace support\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove the dependency on the `backtrace` crate.\nbacktrace = []\n\n# Allow the standard library to be built with small string optimizations\n#\n# This feature is enabled by default, but can be disabled to remove the\n# dependency on the `smallvec` crate.\nsmall-string = []\n\n# Allow the standard library to be built with support for 128-bit integers\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for 128-bit integers.\ni128 = []\n\n# Allow the standard library to be built with support for atomic operations\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for atomic operations.\natomic = []\n\n# Allow the standard library to be built with support for thread-local storage\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for thread-local storage.\ntls = []\n\n# Allow the standard library to be built with support for SIMD operations\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for SIMD operations.\nsimd = []\n\n# Allow the standard library to be built with support for compiler-rt builtins\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for compiler-rt builtins.\ncompiler-builtins = []\n\n# Allow the standard library to be built with support for unwinding\n#\n# This feature is enabled by default on most platforms, but can be disabled\n# to remove support for unwinding.\nunwind = []\n\n# Allow the standard library to be built with support for profiling\n#\n# This feature is disabled by default, but can be enabled to add support\n# for profiling.\nprofile = []\n\n# Allow the standard library to be built with support for llvm-tools-preview\n#\n# This feature is disabled by default, but can be enabled to add support\n# for llvm-tools-preview.\nllvm-tools = []\n\n# Allow the standard library to be built with support for sanitizers\n#\n# This feature is disabled by default, but can be enabled to add support\n# for sanitizers.\nsanitizer = []\n\n# Allow the standard library to be built with support for LTO\n#\n# This feature is disabled by default, but can be enabled to add support\n# for LTO.\nlto = []\n\n# Allow the standard library to be built with support for PGO\n#\n# This feature is disabled by default, but can be enabled to add support\n# for PGO.\npgo = []\n\n# Allow the standard library to be built with support for coverage\n#\n# This feature is disabled by default, but can be enabled to add support\n# for coverage.\ncoverage = []\n\n# Allow the standard library to be built with support for fuzzing\n#\n# This feature is disabled by default, but can be enabled to add support\n# for fuzzing.\nfuzzing = []\n\n# Allow the standard library to be built with support for miri\n#\n# This feature is disabled by default, but can be enabled to add support\n# for miri.\nmiri = []\n\n# Allow the standard library to be built with support for rustfmt\n#\n# This feature is disabled by default, but can be enabled to add support\n# for rustfmt.\nrustfmt = []\n\n# Allow the standard library to be built with support for clippy\n#\n# This feature is disabled by default, but can be enabled to add support\n# for clippy.\nclippy = []\n\n# Allow the standard library to be built with support for rls\n#\n# This feature is disabled by default, but can be enabled to add support\n# for rls.\nrls = []\n\n# Allow the standard library to be built with support for rust-analyzer\n#\n# This feature is disabled by default, but can be enabled to add support\n# for rust-analyzer.\nrust-analyzer = []\n```\n\n----------------------------------------\n\nTITLE: Correct Struct Field Definition and Usage in Rust\nDESCRIPTION: This example shows the correct way to define and initialize a struct with multiple fields. Both 'mother' and 'father' fields are properly defined in the Simba struct before being used in the initialization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0560.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n\n----------------------------------------\n\nTITLE: Using Unsound MIR Optimization Flag in Rust\nDESCRIPTION: The -Zunsound-mir-opts flag enables MIR optimization passes that may cause unsound behavior. This flag is restricted to MIR optimization testing within the rustc test suite and should not be used in production code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/unsound-mir-opts.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `unsound-mir-opts`\n```\n\n----------------------------------------\n\nTITLE: Example of Unstable Feature Gate Declaration in Rust Compiler\nDESCRIPTION: Example of how an unstable feature is declared in the compiler's feature gate system. This shows the 'pub_restricted' feature which implements RFC 1422 for restricted visibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// pub(restricted) visibilities (RFC 1422)\n(unstable, pub_restricted, \"CURRENT_RUSTC_VERSION\", Some(32409)),\n```\n\n----------------------------------------\n\nTITLE: Defining Lifetimes in Structs and Traits in Rust\nDESCRIPTION: This code snippet defines a struct and a trait in Rust that use lifetime parameters. It illustrates an erroneous implementation where the lifetime relationship is not enforced, leading to a compilation error. The goal is to show the necessity of lifetime specifications in Rust for safe references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0491.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Foo<'a> {\n    x: fn(&'a i32),\n}\n\ntrait Trait<'a, 'b> {\n    type Out;\n}\n\nimpl<'a, 'b> Trait<'a, 'b> for usize {\n    type Out = &'a Foo<'b>; // error!\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Foo<'a> {\n    x: fn(&'a i32),\n}\n\ntrait Trait<'a, 'b> {\n    type Out;\n}\n\nimpl<'a, 'b: 'a> Trait<'a, 'b> for usize { // we added the lifetime enforcement\n    type Out = &'a Foo<'b>; // it now works!\n}\n```\n\n----------------------------------------\n\nTITLE: Architecture Support Options for Small Data Threshold\nDESCRIPTION: Enum variants representing the different ways target architectures can support small data thresholds. This includes no support, default architecture settings, LLVM module flags, and LLVM arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/small-data-threshold.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nSmallDataThresholdSupport::None\nSmallDataThresholdSupport::DefaultForArch\nSmallDataThresholdSupport::LlvmModuleFlag\nSmallDataThresholdSupport::LlvmArg\n```\n\n----------------------------------------\n\nTITLE: Valid Negative Implementation Example - Rust\nDESCRIPTION: Shows the correct way to implement a negative trait for an auto trait. This example demonstrates a valid negative implementation without the unsafe keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0198.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(auto_traits)]\n\nstruct Foo;\n\nauto trait Enterprise {}\n\nimpl !Enterprise for Foo { }\n```\n\n----------------------------------------\n\nTITLE: Invalid #[repr(C)] on type alias (typedef) in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect usage of the `#[repr(C)]` attribute on a type alias (`type Foo = u8;`).  The `#[repr(C)]` attribute is only applicable to structs and enums. Applying it to a type alias will result in a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0517.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\n#[repr(C)]\ntype Foo = u8;\n\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust staticlib with linker plugin LTO\nDESCRIPTION: This snippet demonstrates how to compile a Rust static library with linker plugin LTO enabled, using `rustc` directly. It sets the `crate-type` to `staticlib`, enables linker plugin LTO (`-Clinker-plugin-lto`), and sets the optimization level to 2 (`-Copt-level=2`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Associated Type Usage in Rust\nDESCRIPTION: Example showing erroneous code that attempts to use an associated type directly from a trait without specifying the implementing type. This code fails to compile with error E0223.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0223.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Implementation for Clone on a List Type\nDESCRIPTION: Implementation of the Clone trait for a recursive List type, which relies on coinduction as cloning a list requires cloning the tail, which is itself a List.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum List<T> {\n    Nil,\n    Succ(T, Box<List<T>>),\n}\n\nimpl<T: Clone> Clone for List<T> {\n    fn clone(&self) -> Self {\n        match self {\n            List::Nil => List::Nil,\n            List::Succ(head, tail) => List::Succ(head.clone(), tail.clone()),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Fail: Moving Member Out of Mutably Borrowed Struct in Rust\nDESCRIPTION: This example shows E0507 occurring when attempting to move a field out of a struct accessed through a mutable borrow. The `nothing_is_true` method takes ownership of `self`, and the code attempts to call it on `borrowed.knight`, which is accessed via a mutable borrow, hence the error because it tries to move out of the borrowed content.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Markdown Bibliography Structure\nDESCRIPTION: A structured markdown document organizing academic papers and research materials related to Rust into categories including type system, concurrency, and papers about Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/bibliography.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Rust Bibliography\n\nThis is a reading list of material relevant to Rust. It includes prior\nresearch that has - at one time or another - influenced the design of\nRust, as well as publications about Rust.\n\n## Type system\n\n* [Alias burying](https://dl.acm.org/doi/10.1002/spe.370) - We tried something similar and abandoned it.\n* [External uniqueness is unique enough](https://lirias.kuleuven.be/retrieve/35835)\n* [Macros that work together](https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf)\n\n## Concurrency\n\n* [A Java fork/join calamity](https://web.archive.org/web/20190904045322/http://www.coopsoft.com/ar/CalamityArticle.html)\n* [Algorithms for scalable synchronization of shared-memory multiprocessors](https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf)\n\n## Others\n\n* [Composing High-Performance Memory Allocators](https://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf)\n* [Crash-only software](https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf)\n\n## Papers *about* Rust\n\n* [GPU Programming in Rust](https://ieeexplore.ieee.org/document/6650903)\n* [RustBelt: Securing the Foundations of the Rust Programming Language](https://plv.mpi-sws.org/rustbelt/popl18/)\n```\n\n----------------------------------------\n\nTITLE: Handling Interior Mutability Errors with Cell Types in Rust\nDESCRIPTION: This snippet addresses errors when using Cell types in constants due to non-thread-safe operations. It reinforces using statics or adapting the design to avoid such borrow errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0492.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\nconst A: Cell<usize> = Cell::new(1);\nconst B: &Cell<usize> = &A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n\n// or:\nstruct C { a: Cell<usize> }\n\nconst D: C = C { a: Cell::new(1) };\nconst E: &Cell<usize> = &D.a; // error\n\n// or:\nconst F: &C = &D; // error\n```\n\n----------------------------------------\n\nTITLE: Incorrect Import Order in Rust Function\nDESCRIPTION: Example showing the incorrect placement of a 'use' import statement after a variable declaration, which previously triggered a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0154.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f() {\n    // Variable declaration before import\n    let x = 0;\n    use std::io::Read;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Crate Not Found Error in Rust\nDESCRIPTION: Example showing how attempting to use an undeclared crate results in compilation error E0463. This occurs when trying to use extern crate without properly linking the crate through Cargo or rustc configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0463.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate foo; // error: can't find crate\n```\n\n----------------------------------------\n\nTITLE: Raw String Literal in Rust\nDESCRIPTION: A raw string literal that disables escape sequence processing, allowing verbatim text representation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/strings.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nr\"world\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0049 Error with Incorrect Trait Implementation in Rust\nDESCRIPTION: An example showing an erroneous trait implementation where a method is implemented with the wrong number of type parameters. The trait defines the method with one type parameter, but the implementation omits it, causing compilation error E0049.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0049.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo<T: Default>(x: T) -> Self;\n}\n\nstruct Bar;\n\n// error: method `foo` has 0 type parameters but its trait declaration has 1\n// type parameter\nimpl Foo for Bar {\n    fn foo(x: bool) -> Self { Bar }\n}\n```\n\n----------------------------------------\n\nTITLE: Normalizing Doc Attributes in Rust\nDESCRIPTION: Shows how the normalize_doc_attributes option converts #![doc] and #[doc] attributes to //! and /// doc comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_57\n\nLANGUAGE: rust\nCODE:\n```\n#![doc = \"Example documentation\"]\n\n#[doc = \"Example item documentation\"]\npub enum Bar {}\n\n/// Example item documentation\npub enum Foo {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n//! Example documentation\n\n/// Example item documentation\npub enum Foo {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incompatible Trait Implementation Bounds in Rust\nDESCRIPTION: This example shows how adding a bound (T: Copy) in a trait implementation that wasn't present in the original trait definition causes a compilation error. The trait requires foo<T> to accept any type T, but the implementation restricts it to Copy types only.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0276.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo<T>(x: T);\n}\n\nimpl Foo for bool {\n    fn foo<T>(x: T) where T: Copy {}\n}\n```\n\n----------------------------------------\n\nTITLE: Primitive and Structural Unsize Implementations\nDESCRIPTION: This part identifies the built-in primitive and structural implementations of the Unsize trait, detailing how types can be transformed into unsized types based on their structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/unsize.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nBuilt-in implementations are provided for:\n* `T` -> `dyn Trait + 'a` when `T: Trait` (and `T: Sized + 'a`, and `Trait`\nis dyn-compatible[^2]).\n* `[T; N]` -> `[T]`\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Programs for Emscripten Target\nDESCRIPTION: This shell example shows how to compile a Rust program using the 'rustc' compiler specifically for the 'wasm32-unknown-emscripten' target. Dependencies include rustc and the target previously added via rustup. It outputs a WebAssembly binary file, which can be checked using a 'file' command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nrustc foo.rs --target wasm32-unknown-emscripten\nfile foo.wasm\n```\n\n----------------------------------------\n\nTITLE: Defining a Fluent Diagnostic Message with Attributes\nDESCRIPTION: This snippet demonstrates how to define a Fluent diagnostic message along with an attribute related to the message. The attribute provides additional context for the user, enhancing the usability of the error message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/translation.md#2025-04-21_snippet_1\n\nLANGUAGE: fluent\nCODE:\n```\ntypeck_address_of_temporary_taken = cannot take address of a temporary\n    .label = temporary value\n```\n\n----------------------------------------\n\nTITLE: Running Lint Check with Cargo - Bash\nDESCRIPTION: Runs Clippy on a predefined set of crates using the cargo lintcheck command. It is used to check and save lint warnings to logs. The examples include using both a direct cargo lintcheck command and a cargo run command with specific target and manifest paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo lintcheck\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --target-dir lintcheck/target --manifest-path lintcheck/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Creating Structural Search Replace Rules as Comments\nDESCRIPTION: Example showing how to use the structural search and replace functionality as an assist by writing the rule in a comment. When placing the cursor on the comment line, an assist will be offered to apply the transformation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// Place the cursor on the line below to see the assist 💡.\n// foo($a, $b) ==>> ($a).foo($b)\n```\n\n----------------------------------------\n\nTITLE: Fixing Closure Mutability with FnMut in Rust\nDESCRIPTION: This code snippet demonstrates how to fix the closure mutability error by changing the 'foo' function to accept an FnMut closure instead of an Fn closure. This allows the closure to capture its environment mutably.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0387.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<F: FnMut()>(f: F) { }\n```\n\n----------------------------------------\n\nTITLE: Let-Else Statement Short Form\nDESCRIPTION: Demonstrates a compact let-else statement for simple pattern matching and early return scenarios\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet Some(1) = opt else { return };\n```\n\n----------------------------------------\n\nTITLE: Reordering Impl Items in Rust\nDESCRIPTION: Demonstrates how the reorder_impl_items option affects the ordering of type, const, macros, and methods within impl blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_60\n\nLANGUAGE: rust\nCODE:\n```\nstruct Dummy;\n\nimpl Iterator for Dummy {\n    fn next(&mut self) -> Option<Self::Item> {\n        None\n    }\n\n    type Item = i32;\n}\n\nimpl Iterator for Dummy {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        None\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Dummy;\n\nimpl Iterator for Dummy {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Trait with Generic Method Parameters in Rust\nDESCRIPTION: Demonstrates a trait with generic method parameters, which can cause dyn-compatibility issues due to the need to create vtable entries for potentially infinite type combinations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unstable Feature Error in Rust\nDESCRIPTION: This code snippet shows an example of using an unstable feature 'repr128' without enabling it, which results in a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0658.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Configuring Rust Repository\nDESCRIPTION: This snippet clones the Rust repository and configures the build environment with appropriate options to enable LLVM, plugins, and assertions for a nightly build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth=1 git@github.com:rust-lang/rust.git\ncd rust\n./configure --enable-llvm-link-shared --enable-llvm-plugins --enable-llvm-enzyme --release-channel=nightly --enable-llvm-assertions --enable-clang --enable-lld --enable-option-checking --enable-ninja --disable-docs\n```\n\n----------------------------------------\n\nTITLE: Invalid Non-Generic Type Alias Impl Trait in Rust\nDESCRIPTION: Example of invalid usage where type_alias_impl_trait is not used fully generically, causing compilation error E0792. This pattern is rejected because the hidden type is only defined for a specific type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0792.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(type_alias_impl_trait)]\n\ntype Foo<T> = impl std::fmt::Debug;\n\n#[define_opaque(Foo)]\nfn foo() -> Foo<u32> {\n    5u32\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Test Suite for Fuchsia\nDESCRIPTION: Example of environment variables to set for running the Rust test suite on Fuchsia.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_22\n\nLANGUAGE: sh\nCODE:\n```\n# TEST_TOOLCHAIN_TMP_DIR can point anywhere, but it:\n#  - must be less than 108 characters, otherwise qemu can't handle the path\n#  - must be consistent across calls to this file (don't use `mktemp -d` here)\nexport TEST_TOOLCHAIN_TMP_DIR=\"/tmp/rust-tmp\"\n```\n\n----------------------------------------\n\nTITLE: Removing Unnecessary Async in Rust Functions\nDESCRIPTION: Removes the async keyword from functions that don't contain any await operations. Also updates call sites to remove .await when calling the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_112\n\nLANGUAGE: rust\nCODE:\n```\npub async fn foo() {}\npub async fn bar() { foo().await }\n```\n\nLANGUAGE: rust\nCODE:\n```\npub fn foo() {}\npub async fn bar() { foo() }\n```\n\n----------------------------------------\n\nTITLE: Ordering Items in Rust Modules\nDESCRIPTION: Illustrates the recommended order of items in a Rust module, placing public items first and organizing structs, enums, functions, and impls in a logical manner.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\npub(crate) fn frobnicate() {\n    Helper::act()\n}\n\n#[derive(Default)]\nstruct Helper { stuff: i32 }\n\nimpl Helper {\n    fn act(&self) {\n\n    }\n}\n\n// BAD\n#[derive(Default)]\nstruct Helper { stuff: i32 }\n\npub(crate) fn frobnicate() {\n    Helper::act()\n}\n\nimpl Helper {\n    fn act(&self) {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Outlives Constraint Example\nDESCRIPTION: Illustrates how outlives constraints, such as `R1: R2`, imply that the value of `R1` must be a superset of the value of `R2`.  The example code showcases a scenario where multiple outlives relationships (e.g., `R1: R2`, `R2: R3`, `R3: R4`, `R4: R1`) lead to the conclusion that all involved regions must be equal (`R1 = R2 = R3 = R4`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md#2025-04-21_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n\nR1: R2\nR2: R3\nR3: R4\nR4: R1\n\n```\n\n----------------------------------------\n\nTITLE: Cache Access Example for Debug Metadata\nDESCRIPTION: Illustrates how to access cached debug metadata for files using the module's internal caching mechanism.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/debuginfo/doc.md#2025-04-21_snippet_0\n\nLANGUAGE: ignore\nCODE:\n```\nlet file_metadata = file_metadata(cx, file);\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting CET-Enabled Builds\nDESCRIPTION: This command demonstrates how to compile Rust code with CET protection and enable reporting of non-CET-enabled modules. It uses custom rustc flags and linker arguments to display warnings for modules missing IBT and SHSTK properties.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/cf-protection.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ RUSTC_LOG=rustc_codegen_ssa::back::link=info rustc-custom -v -Z cf-protection=full -C link-arg=\"-Wl,-z,cet-report=warning\" -o example example.rs\n...\n/usr/bin/ld: /.../build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-d73f7266be14cb8b.rlib(std-d73f7266be14cb8b.std.f7443020-cgu.12.rcgu.o): warning: missing IBT and SHSTK properties\n```\n\n----------------------------------------\n\nTITLE: Building Rust with CET Protection\nDESCRIPTION: This command demonstrates how to build Rust code with full control-flow protection enabled. It uses the nightly toolchain and rebuilds the standard library with CET enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/cf-protection.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ RUSTFLAGS=\"-Z cf-protection=full\" cargo +nightly build -Z build-std --target x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Range Expression Line Breaking - Rust\nDESCRIPTION: Shows proper formatting for range expressions that require line breaks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\na_long_expression\n    ..another_long_expression\n```\n\n----------------------------------------\n\nTITLE: Type-Checking Example with Borrow Trait in Rust\nDESCRIPTION: This example demonstrates how the `Borrow` trait is used in type-checking with inference variables. The initial call to `foo` results in an ambiguous trait query because the types of the vector and option are not yet fully known, while the subsequent assignment to `u` constrains the type variable, leading to a proven trait obligation after refreshing the query.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonical-queries.md#2025-04-21_snippet_1\n\nLANGUAGE: rust,ignore\nCODE:\n```\n\"fn foo<A, B>(a: A, vec_b: Option<B>) where A: Borrow<B> { }\\n\\nfn main() {\\n    let mut t: Vec<_> = vec![]; // Type: Vec<?T>\\n    let mut u: Option<_> = None; // Type: Option<?U>\\n    foo(t, u); // Example 1: requires `Vec<?T>: Borrow<?U>`\\n    ...\\n}\"\n```\n\nLANGUAGE: rust,ignore\nCODE:\n```\n\"fn foo<A, B>(a: A, vec_b: Option<B>) where A: Borrow<B> { }\\n\\nfn main() {\\n    // What we saw before:\\n    let mut t: Vec<_> = vec![]; // Type: Vec<?T>\\n    let mut u: Option<_> = None; // Type: Option<?U>\\n    foo(t, u); // `Vec<?T>: Borrow<?U>` => ambiguous\\n\\n    // New stuff:\\n    u = Some(vec![]); // ?U = Vec<?V>\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Integer Overflow in Rust\nDESCRIPTION: Example program that demonstrates integer overflow in Rust. This program attempts to add 1 to the maximum value of a u8 (255), which would cause an overflow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let u: u8 = 255;\n    println!(\"u: {}\", u + 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Josh Proxy for Rust Syncing with Bash\nDESCRIPTION: This snippet provides the command to install the Josh proxy which handles changes between the rustc and Miri repositories.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\ncargo +stable install josh-proxy --git https://github.com/josh-project/josh --tag r24.10.04\n```\n\n----------------------------------------\n\nTITLE: Deinitializing a Git Submodule\nDESCRIPTION: Removes the local submodule directory and configuration entries for a specific submodule, preventing it from being tracked or updated. The `-f` flag forces the deinitialization even if the submodule is not fully checked out.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule deinit -f src/llvm-project\n```\n\n----------------------------------------\n\nTITLE: Rust First Version of Crate A (a1.rs)\nDESCRIPTION: First version of crate 'a' with a generic function declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0460.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"a\"]\n\npub fn foo<T>() {}\n```\n\n----------------------------------------\n\nTITLE: Reordering Imports in Rust\nDESCRIPTION: Shows how the reorder_imports option affects the alphabetical ordering of import statements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_61\n\nLANGUAGE: rust\nCODE:\n```\nuse dolor;\nuse ipsum;\nuse lorem;\nuse sit;\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse lorem;\nuse ipsum;\nuse dolor;\nuse sit;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Trait Implementation Issues with Async Functions (Rust)\nDESCRIPTION: This code snippet shows how async functions in traits would require support for Generic Associated Types, which is not yet implemented in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0706.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl MyDatabase {\n    async fn get_user(&self) -> User {\n        unimplemented!()\n    }\n}\n\nimpl MyDatabase {\n    fn get_user(&self) -> impl Future<Output = User> + '_ {\n        unimplemented!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Windows System Bindings using x.py\nDESCRIPTION: Command sequence to regenerate windows_sys.rs from bindings.txt and format the code. This should be run after making changes to bindings.txt.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/windows/c/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./x run generate-windows-sys && ./x fmt\n```\n\n----------------------------------------\n\nTITLE: External Link Handler JavaScript\nDESCRIPTION: JavaScript functionality to detect and mark external links in the documentation, adding visual indicators for external references. Includes SVG icon injection and event handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/index.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction isExternalLink(url) {\n  const tmp = document.createElement('a');\n  tmp.href = url;\n  return tmp.host !== window.location.host;\n}\n\nfunction updateExternalAnchors() {\n  const svgText = `<svg\n     class='external-link'\n     xmlns='http://www.w3.org/2000/svg'\n     viewBox='0 -256 1850 1850'\n     width='100%'\n     height='100%'>\n       <g transform='matrix(1,0,0,-1,30,1427)'>\n         <path d='M 1408,608 V 288 Q 1408,169 1323.5,84.5 1239,0 1120,0 H 288 Q 169,0 84.5,84.5 0,169 0,288 v 832 Q 0,1239 84.5,1323.5 169,1408 288,1408 h 704 q 14,0 23,-9 9,-9 9,-23 v -64 q 0,-14 -9,-23 -9,-9 -23,-9 H 288 q -66,0 -113,-47 -47,-47 -47,-113 V 288 q 0,-66 47,-113 47,-47 113,-47 h 832 q 66,0 113,47 47,47 47,113 v 320 q 0,14 9,23 9,9 23,9 h 64 q 14,0 23,-9 9,-9 9,-23 z m 384,864 V 960 q 0,-26 -19,-45 -19,-19 -45,-19 -26,0 -45,19 L 1507,1091 855,439 q -10,-10 -23,-10 -13,0 -23,10 L 695,553 q -10,10 -10,23 0,13 10,23 l 652,652 -176,176 q -19,19 -19,45 0,26 19,45 19,19 45,19 h 512 q 26,0 45,-19 19,-19 19,-45 z' style='fill:currentColor' />\n         </g>\n     </svg>`;\n  let allAnchors = document.getElementsByTagName(\"a\");\n\n  for (var i = 0; i < allAnchors.length; ++i) {\n    let anchor = allAnchors[i];\n    if (isExternalLink(anchor.href)) {\n      anchor.classList.add(\"external\");\n      anchor.innerHTML += svgText;\n    }\n  }\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", updateExternalAnchors);\n```\n\n----------------------------------------\n\nTITLE: Supertrait Deduplication During Elaboration in Rust\nDESCRIPTION: Illustrates deduplication of where clauses in a `ParamEnv` during the elaboration process in Rust. The code shows that duplicate trait bounds, like multiple `T: Trait`, are deduplicated. This is crucial for maintaining a clean and optimized parameter environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {}\n// The unelaborated `ParamEnv` would be:\n// `[T: Sized, T: Trait, T: Trait]`\n// but after elaboration it would be:\n// `[T: Sized, T: Trait]`\nfn foo<T: Trait + Trait>() {}\n```\n\n----------------------------------------\n\nTITLE: Invalid C-cmse-nonsecure-call ABI Usage Example in Rust\nDESCRIPTION: Demonstrates an erroneous attempt to use the C-cmse-nonsecure-call ABI directly with a function definition. This will fail with error E0781 as this ABI is restricted to function pointer usage only.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0781.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_c_cmse_nonsecure_call)]\n\npub extern \"C-cmse-nonsecure-call\" fn test() {}\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Let Statement Formatting\nDESCRIPTION: Shows how to handle let statements that require multiple lines, with block indentation and line-breaking strategies\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet pattern: Type =\n    expr;\n```\n\n----------------------------------------\n\nTITLE: Rustfmt Emit Options Example\nDESCRIPTION: Example command showing how to change Rustfmt's output format using the --emit flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/README.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo fmt -- --emit files\n```\n\n----------------------------------------\n\nTITLE: Try Shorthand Enabled Example in Rust\nDESCRIPTION: Demonstrates formatting when use_try_shorthand is enabled, converting try! macro usage to ? operator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_79\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = ipsum.map(|dolor| dolor.sit())?;\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Rustc Compilation with GCC Backend\nDESCRIPTION: Commands to compile Rust code directly using the rustc compiler with the GCC codegen backend.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh rustc my_crate.rs\n```\n\n----------------------------------------\n\nTITLE: Checking Pointer Alignment in Rust\nDESCRIPTION: This snippet demonstrates how to check the alignment of a pointer in Rust. It uses the align_of function to get the required alignment for a type and compares it with the pointer's address.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\n\nlet mut x = 5;\nlet ptr = &mut x as *mut i32;\nlet address = ptr as usize;\n\nassert!(address % mem::align_of::<i32>() == 0);\n```\n\n----------------------------------------\n\nTITLE: Handling Context Parameters in Rust Functions\nDESCRIPTION: Demonstrates the preferred way of passing context parameters in Rust functions, placing them first and considering packing them into a struct for multiple context parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn dfs(graph: &Graph, v: Vertex) -> usize {\n    let mut visited = FxHashSet::default();\n    return go(graph, &mut visited, v);\n\n    fn go(graph: &Graph, visited: &mut FxHashSet<Vertex>, v: usize) -> usize {\n        ...\n    }\n}\n\n// BAD\nfn dfs(v: Vertex, graph: &Graph) -> usize {\n    fn go(v: usize, graph: &Graph, visited: &mut FxHashSet<Vertex>) -> usize {\n        ...\n    }\n\n    let mut visited = FxHashSet::default();\n    go(v, graph, &mut visited)\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Control Flow Blocks in Rust\nDESCRIPTION: Removes control flow statements (if/else, for, while, loop) and keeps only the body. This simplifies code when the control statement becomes unnecessary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_114\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    if true {\n        println!(\"foo\");\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    println!(\"foo\");\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Enum Pattern Binding Example\nDESCRIPTION: An erroneous code example showing incorrect pattern matching where enum variants are not properly qualified, leading to compilation error E0170.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0170.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![deny(warnings)]\nenum Method {\n    GET,\n    POST,\n}\n\nfn is_empty(s: Method) -> bool {\n    match s {\n        GET => true,\n        _ => false\n    }\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Explicit Lifetime Bounds in Rust\nDESCRIPTION: This snippet demonstrates how to modify a function signature to use explicit lifetime bounds on a boxed trait object, addressing potential issues from the Rust 1.3 changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0398.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# trait SomeTrait {}\nfn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Configuring Clippy Lint Levels via Command Line\nDESCRIPTION: Example of configuring different lint levels using command line flags. Shows how to allow style lints, warn on box_default, and deny performance lints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy -- -Aclippy::style -Wclippy::box_default -Dclippy::perf\n```\n\n----------------------------------------\n\nTITLE: Complex Higher Ranked Where Clause\nDESCRIPTION: Demonstrates nested binders and complex lifetime representations in where clauses\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/instantiating_binders.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>()\nwhere\n    for<'a> T: Trait<'a, for<'b> fn(&'b T, &'a u32)>\n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Defining LateLintPass Trait in Rust\nDESCRIPTION: Basic definition of the LateLintPass trait used for implementing lint passes in Clippy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait LateLintPass<'tcx>: LintPass {\n    // Trait methods\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring cargo-ignore-publish\nDESCRIPTION: For internal testing, this configuration ignores the `publish` settings in the Cargo manifest. It's a boolean flag.  Defaults to `false`. This is typically used for testing and internal development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Setting the Default Theme\nDESCRIPTION: This code snippet demonstrates how to use the `--default-theme` flag to set the default theme for the generated documentation. This influences the initial visual style for users who haven't selected a theme.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --default-theme=ayu\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running Rust Analyzer Documentation Locally with mdbook\nDESCRIPTION: Commands to install mdbook, navigate to the documentation directory, and start the local documentation server. As changes are made to files in the docs/book/src directory, mdbook will automatically rebuild the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook\ncd docs/book\nmdbook serve\n# make changes to documentation files in doc/book/src\n# ...\n```\n\n----------------------------------------\n\nTITLE: Fixing Self-Referential Struct Using Option in Rust\nDESCRIPTION: Demonstrates the correct way to define a potentially self-referential struct using Option<Box<Foo>>, allowing for initialization with None\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0073.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo { x: Option<Box<Foo>> }\n```\n\n----------------------------------------\n\nTITLE: Computing SCC Values with Successors\nDESCRIPTION: Illustrates the process of computing the value of an SCC based on the values of its successors in the DAG of SCCs. The code shows how the value of an SCC (`S1`) is determined by unioning the values of all its successors (`S2`). The successors are mapped to their corresponding `Values`, and the union of these `Values` is assigned to `Values(S1)`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md#2025-04-21_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\nValues(S1) =\n  s1.successors()\n    .map(|s2| Values(s2))\n    .union()\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Function Arguments in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for function arguments. In this style, arguments in multiline functions are aligned as a distinct block with consistent indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {}\n\nfn lorem(ipsum: usize) {}\n\nfn lorem(\n    ipsum: usize,\n    dolor: usize,\n    sit: usize,\n    amet: usize,\n    consectetur: usize,\n    adipiscing: usize,\n    elit: usize,\n) {\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Rustdoc Example Scraping with Cargo\nDESCRIPTION: Command showing how to enable the example scraping feature in Rustdoc using Cargo. This uses unstable options that must be explicitly enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/scrape-examples-help.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo doc -Zunstable-options -Zrustdoc-scrape-examples\n```\n\n----------------------------------------\n\nTITLE: Erroneous Export Name Attribute Usage in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect use of the `export_name` attribute with a null character, resulting in a compilation error (E0648).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0648.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[export_name=\"\\0foo\"] // error: `export_name` may not contain null characters\npub fn bar() {}\n```\n\n----------------------------------------\n\nTITLE: Marking a trait as a notable trait\nDESCRIPTION: This Rust snippet demonstrates how to use the `#[doc(notable_trait)]` attribute to mark a trait as \"notable.\"  Notable traits are highlighted in Rustdoc when a function returns a type that implements them. It requires the `doc_notable_trait` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Adding False Positive Fix Changelog Entry\nDESCRIPTION: Example of how to add a changelog entry for fixing a false positive in an existing lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nchangelog: Fix [`unused_peekable`] false positive when peeked in a closure or called as `f(&mut peekable)`\n```\n\n----------------------------------------\n\nTITLE: Correctly Defining a Feature Attribute in Rust\nDESCRIPTION: This snippet shows the correct way to define a feature attribute in Rust, emphasizing that it should only be used on the nightly version of Rust. It highlights the requirement for proper syntax and context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0556.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"#![feature(flag)]\"\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation with Associated Type in Rust\nDESCRIPTION: This example shows the correct way to implement a trait that requires an associated type. The implementation properly defines 'type N = u32' to match the trait's definition of 'type N'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0323.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    type N;\n}\n\nimpl Foo for Bar {\n    type N = u32; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Prolog-like Logical Representation for Generics - Text\nDESCRIPTION: This snippet introduces a Prolog-style logical representation to express the requirements for type-checking generic functions, incorporating universal quantification and implications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nfooTypeChecks :-\n  // for all types T...\n  forall<T> {\n    // ...if we assume that Eq(T, T) is provable...\n    if (Eq(T, T)) {\n      // ...then we can prove that `barWellFormed(T)` holds.\n      barWellFormed(T)\n    }\n  }.\n```\n\n----------------------------------------\n\nTITLE: Automating Coverage Generation for Rust Tests with Bash\nDESCRIPTION: This bash script snippet automates generating the `llvm-cov` report command by listing test binaries using `cargo test` and `jq`. The script constructs the necessary command to analyze all compiled test binaries using their coverage data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ llvm-cov report \\\n    $( \\\n      for file in \\\n        $( \\\n          RUSTFLAGS=\"-C instrument-coverage\" \\\n            cargo test --tests --no-run --message-format=json \\\n              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n              | grep -v dSYM - \\\n        ); \\\n      do \\\n        printf \"%s %s \" -object $file; \\\n      done \\\n    ) \\\n  --instr-profile=json5format.profdata --summary-only # and/or other options\n```\n\n----------------------------------------\n\nTITLE: Adding `wasm32-unknown-unknown` target via rustup\nDESCRIPTION: This command adds the `wasm32-unknown-unknown` target to the Rust toolchain using rustup. This allows compiling Rust code for this specific WebAssembly target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ rustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Configuring arithmetic-side-effects-allowed-unary\nDESCRIPTION: This setting allows the specification of types where unary arithmetic operations are permitted without triggering the `arithmetic_side_effects` lint. This allows to avoid false positives, e.g. in cases of operators overloading.  It requires a list of type names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\narithmetic-side-effects-allowed-unary = [\"SomeType\", \"AnotherType\"]\n```\n\n----------------------------------------\n\nTITLE: Converting Boolean to Enum in Rust\nDESCRIPTION: This assist converts boolean variables, fields, constants, and statics into a new enum with two variants. It replaces all assignments and usages with the new enum variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let bool = true;\n\n    if bool {\n        println!(\"foo\");\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Eq)]\nenum Bool { True, False }\n\nfn main() {\n    let bool = Bool::True;\n\n    if bool == Bool::True {\n        println!(\"foo\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Minicore Core Stubs in Rust Tests - Rust\nDESCRIPTION: This snippet demonstrates how to configure a codegen or assembly test in Rust to use the minicore auxiliary, which provides core library stubs for cross-compiled targets. It requires the use of specific feature flags (`#![feature(no_core)]`, `#![no_std]`, `#![no_core]`), extern crate declaration of minicore, and the //@ add-core-stubs directive. The test defines a struct that derives Copy provided by minicore, and an unsafe no_mangle function. The test should be compiled with -C panic=abort and -C force-unwind-tables=yes, as unwinding panics are unsupported.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/minicore.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n//@ add-core-stubs\n//@ revisions: meow bark\n//@[meow] compile-flags: --target=x86_64-unknown-linux-gnu\n//@[meow] needs-llvm-components: x86\n//@[bark] compile-flags: --target=wasm32-unknown-unknown\n//@[bark] needs-llvm-components: webassembly\n\n#![crate_type = \"lib\"]\n#![feature(no_core)]\n#![no_std]\n#![no_core]\n\nextern crate minicore;\nuse minicore::*;\n\nstruct Meow;\nimpl Copy for Meow {} // `Copy` here is provided by `minicore`\n\n// CHECK-LABEL: meow\n#[unsafe(no_mangle)]\nfn meow() {}\n\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Unsafe Extern Blocks\nDESCRIPTION: Shows preservation of safe and unsafe keywords in static items within extern blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsafe_extern_blocks)]\n\nunsafe extern \"C\" {\n    safe static TEST1: i32;\n    unsafe static TEST2: i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding PathBuf Initialization in Rust\nDESCRIPTION: The example demonstrates the mangled symbol encoding for `PathBuf::new` within a specific crate, highlighting the structure of the mangled symbol for a function in Rust's standard library and its recommendation for demangling. No dependencies are required, and the inputs and outputs focus on encoding and identifying symbol paths within a crate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstd::path::PathBuf::new();\n```\n\n----------------------------------------\n\nTITLE: Where Clause Formatting in Rust\nDESCRIPTION: Illustrates the rules for formatting `where` clauses in Rust, including placement of the `where` keyword, indentation of components, and use of trailing commas.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nfn function<T, U>(args)\nwhere\n    T: Bound,\n    U: AnotherBound,\n{\n    body\n}\n\nfn foo<T>(\n    args\n) -> ReturnType\nwhere\n    T: Bound,\n{\n    body\n}\n\nfn foo<T, U>(\n    args,\n) where\n    T: Bound,\n    U: AnotherBound,\n{\n    body\n}\n\nfn foo<T, U>(\n    args\n) -> ReturnType\nwhere\n    T: Bound,\n    U: AnotherBound;  // Note, no trailing comma.\n\n// Note that where clauses on `type` aliases are not enforced and should not\n// be used.\ntype Foo<T>\nwhere\n    T: Bound\n= Bar<T>;\n```\n\n----------------------------------------\n\nTITLE: Building Rust for MIPS R6 Target\nDESCRIPTION: Executes the Rust build script for the MIPS R6 target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n./x.py build\n```\n\n----------------------------------------\n\nTITLE: Checking Unsafe Operations in Rust\nDESCRIPTION: This code snippet demonstrates the detection of unsafe operations in Rust. It utilizes an unsafe block and checks for unused unsafe blocks through the lint mechanism. If an unsafe block contains no unsafe operations, it is reported by the lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/unsafety-checking.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"#![deny(unused_unsafe)]\\nlet y = 0;\\nlet x: *const u8 = core::ptr::addr_of!(y);\\nsafe { // lint reported for this block\\n    unsafe {\\n        let z = *x;\\n    }\\n    let safe_expr = 123;\\n}\\nsafe {\\n    unsafe { // lint reported for this block\\n        let z = *x;\\n    }\\n    let unsafe_expr = *x;\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Control Flow in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for control flow statements. In this style, conditions after the first line are aligned with the start of the first condition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if lorem_ipsum\n       && dolor_sit\n       && amet_consectetur\n       && lorem_sit\n       && dolor_consectetur\n       && amet_ipsum\n       && lorem_consectetur\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running ThreadSanitizer with Rust Flags in Shell\nDESCRIPTION: This shell snippet sets environment variables to enable ThreadSanitizer instrumentation when running a Rust project. It sets `RUSTFLAGS` and `RUSTDOCFLAGS` to `-Zsanitizer=thread` and runs the project with `cargo run` while rebuilding the standard library via `-Zbuild-std`. The commands ensure that the Rust code is instrumented for detecting data races at runtime, and the outputs will include warnings about detected data races.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Defining Revisions in Rust Tests\nDESCRIPTION: This snippet illustrates how to define multiple revisions for a single test file using the `//@ revisions:` directive. Each revision allows the test to be compiled with different configuration flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"//@ revisions: foo bar baz\\n\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Mutable Borrow Usage in Rust\nDESCRIPTION: Demonstrates a compile-time error where a value is used after being mutably borrowed, violating Rust's ownership and borrowing rules\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0503.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Iterator::for_each to For Loop in Rust\nDESCRIPTION: Changes an iterator's for_each method to a for loop, eliminating inline closure execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let iter = iter::repeat((9, 2));\n    for (x, y) in iter {\n        println!(\"x: {}, y: {}\", x, y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Travis CI with Clippy for Rust\nDESCRIPTION: Example Travis CI configuration that sets up Clippy linting for Rust projects. Shows how to install Clippy component and run different linting commands, including options for treating warnings as errors and checking all targets and features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/continuous_integration/travis.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlanguage: rust\nrust:\n  - stable\n  - beta\nbefore_script:\n  - rustup component add clippy\nscript:\n  - cargo clippy\n  # if you want the build job to fail when encountering warnings, use\n  - cargo clippy -- -D warnings\n  # in order to also check tests and non-default crate features, use\n  - cargo clippy --all-targets --all-features -- -D warnings\n  - cargo test\n  # etc.\n```\n\n----------------------------------------\n\nTITLE: REUSE Directive Comments\nDESCRIPTION: Special comments indicating sections to be ignored by REUSE license compliance tools\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/fonts/FiraSans-LICENSE.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n// REUSE-IgnoreStart\n\n// REUSE-IgnoreEnd\n```\n\n----------------------------------------\n\nTITLE: Converting Closure to Function in Rust\nDESCRIPTION: This assist converts a closure to a freestanding function, changing all captures to parameters. It extracts the closure body into a separate function and adjusts the call site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut s = String::new();\n    let closure = |a| s.push_str(a);\n    closure(\"abc\");\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut s = String::new();\n    fn closure(a: &str, s: &mut String) {\n        s.push_str(a)\n    }\n    closure(\"abc\", &mut s);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Naked Function Definition in Rust (E0787 Example)\nDESCRIPTION: This Rust code snippet demonstrates an incorrect usage of the `#[unsafe(naked)]` attribute, leading to compile error E0787. Naked functions must contain exactly one `naked_asm!` block as their body and cannot contain standard Rust code like the `42` return value shown here. The execution must explicitly return or diverge within the assembly block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0787.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[unsafe(naked)]\npub extern \"C\" fn f() -> u32 {\n    42\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Granular Runnable Environment Variables (JSON)\nDESCRIPTION: This JSON snippet provides a granular approach to setting environment variables for runnable commands, where specific conditions can apply. This example sets environment variables, optionally using masks to filter applicable runnables.  Requires VS Code and the Rust extension.  The output adds the environment variables during execution. Configurations are placed in settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n\"rust-analyzer.runnables.extraEnv\": [\n    {\n        // \"mask\": null, // null mask means that this rule will be applied for all runnables\n        \"env\": {\n                \"APP_ID\": \"1\",\n                \"APP_DATA\": \"asdf\"\n        }\n    },\n    {\n        \"mask\": \"test_name\",\n        \"env\": {\n                \"APP_ID\": \"2\", // overwrites only APP_ID\n        }\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Using noprelude option with --extern flag in Rust\nDESCRIPTION: This example demonstrates how to use the noprelude option with the --extern flag to use a custom build of the core crate. The -Z unstable-options flag is required as this is an unstable feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/extern-options.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nrustc main.rs -Z unstable-options --extern noprelude:core=libcore.rlib\n```\n\n----------------------------------------\n\nTITLE: Defining a Nested Module with a Function in Rust\nDESCRIPTION: This Rust snippet defines a nested module named 'foo' which contains a function named 'bar'. This representation illustrates how to organize code within modules and demonstrates basic function declaration within a Rust module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    fn bar() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating new Method for Struct in Rust\nDESCRIPTION: This snippet shows how to generate a new method for a struct. It creates an impl block with a new method that takes all fields as parameters and constructs a new instance of the struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_61\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ctx<T: Clone> {\n     data: T,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ctx<T: Clone> {\n     data: T,\n}\n\nimpl<T: Clone> Ctx<T> {\n    fn new(data: T) -> Self {\n        Self { data }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example bootstrap.toml for compiling the Rust toolchain\nDESCRIPTION: This is an example of the `bootstrap.toml` configuration file. It specifies that the profile to be used is `compiler` and includes a `change-id` field. This configuration is necessary when compiling the Rust toolchain for a specific target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\n```toml\nprofile = \"compiler\"\nchange-id = 999999\n```\n```\n\n----------------------------------------\n\nTITLE: Using Custom Sysroot Source Path in Rust Build Process\nDESCRIPTION: Command for building a custom sysroot by specifying the path to custom source during the preparation step using the --sysroot-source flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./y.sh prepare --sysroot-source /path/to/custom/source\n```\n\n----------------------------------------\n\nTITLE: Basic Type and Value Identification in Rust\nDESCRIPTION: Demonstrates name resolution between types and values in separate namespaces, using a Rust program where 'x' is defined as both a type (u32) and a variable. It explains how name resolution differentiates between the two within a single scope. No external dependencies are required, and it involves no parameters. The inputs are simple type definitions and variable declarations, with typical Rust scoping rules applied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/name-resolution.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype x = u32;\nlet x: x = 1;\nlet y: x = 2;\n```\n\n----------------------------------------\n\nTITLE: IntelliJ Trick for Syntax Parsing at Cursor (Rust)\nDESCRIPTION: This code implements the \"IntelliJ Trick\" by inserting a dummy identifier at cursor position and parsing the modified file to obtain a valid syntax tree for completion analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context.rs#L644-L648\n```\n\n----------------------------------------\n\nTITLE: Converting For Loop to Iterator::for_each in Rust\nDESCRIPTION: This assist converts a for loop into a for_each loop on the Iterator. It replaces the traditional for loop syntax with a method call on the iterable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = vec![1, 2, 3];\n    for v in x {\n        let y = v * 2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Stability Attribute Usage in Rust\nDESCRIPTION: This code example provides the correct usage of Rust's stability attributes by including the necessary 'feature' field. The 'unstable' function is annotated with both 'feature' and 'issue', while the 'stable' function includes 'feature' and 'since'. These annotations ensure the code complies with Rust's requirements for staged API features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0546.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"unstable_fn\\\", issue = \\\"none\\\")] // ok!\\nfn unstable_fn() {}\\n\\n#[stable(feature = \\\"stable_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nfn stable_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Compiling for Emscripten Target\nDESCRIPTION: This code snippet demonstrates how to use Rust's conditional compilation attributes to target the Emscripten operating system or WebAssembly family not using Emscripten. The primary dependency is rustc's support for conditional attributes. It helps conditionally include code based on target operating system or family.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n#[cfg(target_os = \"emscripten\")]\n```\n\nLANGUAGE: text\nCODE:\n```\n#[cfg(all(target_family = \"wasm\", not(target_os = \"emscripten)))]\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Arguments Usage in Rust\nDESCRIPTION: Examples of correct generic argument usage in Rust. Shows proper implementation with the exact number of required type arguments for structs and functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0107.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation: Properly Defined Associated Types in Rust Traits\nDESCRIPTION: Example showing the correct way to define and use associated types in Rust traits. Demonstrates proper type declaration and usage in both type aliases and trait methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0220.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Importing and Using HashMap\nDESCRIPTION: Shows the proper way to import and use HashMap from the standard library collections module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0433.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\n----------------------------------------\n\nTITLE: Testing Rust Function Pointer Promotion & Inlining (LLVM IR)\nDESCRIPTION: This LLVM IR snippet, combined with `CHECK` directives, tests indirect call promotion and inlining for function pointers in Rust. The `CHECK`s assert that the compiled code includes a comparison against the most frequent target (`@function_called_always`) and a direct call to the inlined version (`@opaque_f1`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/pgo-indirect-call-promotion/filecheck-patterns.txt#_snippet_0\n\nLANGUAGE: LLVM IR\nCODE:\n```\nCHECK: define void @call_a_bunch_of_functions({{.*}} {\n\n# Make sure that indirect call promotion inserted a check against the most\n# frequently called function.\nCHECK: %{{.*}} = icmp eq ptr %{{.*}}, @function_called_always\n\n# Check that the call to `function_called_always` was inlined, so that we\n# directly call `opaque_f1` from the upstream crate.\nCHECK: call void @opaque_f1()\n```\n\n----------------------------------------\n\nTITLE: Fixing E0621: Modifying Function Body to Match Lifetime\nDESCRIPTION: This code snippet demonstrates an alternative fix for the E0621 error by modifying the function body to ensure that only data borrowed with the specified lifetime is returned.  In this example, the function is modified to always return `x`, thus satisfying the lifetime constraint in the function signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0621.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n    x\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits from std::fmt in Rust\nDESCRIPTION: Demonstrates the preferred way to implement traits from std::fmt, importing the module rather than using fully qualified paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nuse std::fmt;\n\nimpl fmt::Display for RenameError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { .. }\n}\n\n// BAD\nimpl std::fmt::Display for RenameError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { .. }\n}\n\n// BAD\nuse std::ops::Deref;\n\nimpl Deref for Widget {\n    type Target = str;\n    fn deref(&self) -> &str { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Function Public for Documentation\nDESCRIPTION: This snippet demonstrates how to make a function public so that its documentation can be generated by rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n/// foo is a function\npub fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Elevating Clippy Warnings to Errors\nDESCRIPTION: Command to treat all warnings as errors, useful for CI environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy -- -Dwarnings\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Exhaustive Pattern Matching Error in Rust\nDESCRIPTION: This example shows code that will fail to compile due to non-exhaustive pattern matching. The match expression doesn't cover all possible variants of the Terminator enum.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0004.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n    Terminator::TalkToMyHand => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation without Mismatched Associated Type\nDESCRIPTION: This code provides the correct implementation of the `Foo` trait.  The `impl` block does not define any associated types, avoiding the E0437 error because it doesn't attempt to define a type not present on the trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0437.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\ntrait Foo {}\n\nimpl Foo for i32 {}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring rustup for nightly toolchain\nDESCRIPTION: Commands to set up rustup to use the nightly toolchain in the rustc repository directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\ncd <path to rustc repo>\nrustup override set nightly\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0412 Error with Module Imports in Rust\nDESCRIPTION: This snippet shows an example of E0412 error occurring when a type is imported into a parent module but not visible in a child module. The File type from std::fs is not accessible in the foo module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0412.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rustfmt with rustfmt::skip attribute in Rust\nDESCRIPTION: Example of using the rustfmt::skip attribute to prevent Rustfmt from formatting a macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\n#[rustfmt::skip::macros(my_macro)]\n```\n\n----------------------------------------\n\nTITLE: Correct Visibility Restriction in Rust\nDESCRIPTION: This code snippet shows the correct way to specify visibility for a struct within a module using the 'in' keyword. It makes the struct 'Bar' only visible within the 'foo' module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0704.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub(in crate::foo) struct Bar {\n        x: i32\n    }\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching with Sufficient Elements in Rust\nDESCRIPTION: This code snippet demonstrates correct pattern matching in Rust where the array 'r' has a sufficient number of elements to match the pattern. By ensuring the array contains at least the number of elements required by the pattern, the code compiles successfully. The snippet uses '..' to match an arbitrary number of remaining elements, which is a crucial aspect of pattern matching in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0528.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet r = &[1, 2, 3, 4, 5];\nmatch r {\n    &[a, b, c, rest @ ..] => { // ok!\n        // prints `a=1, b=2, c=3 rest=[4, 5]`\n        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Miri with Rustup\nDESCRIPTION: This snippet shows how to install the Miri component using Rustup.  This allows you to use Miri with your nightly Rust toolchain. The nightly toolchain is required to use Miri.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n\"rustup +nightly component add miri\"\n```\n\n----------------------------------------\n\nTITLE: Using return values to prevent optimization in benchmarks\nDESCRIPTION: Shows how to prevent the compiler from optimizing away calculations in benchmarks by returning a value from the closure passed to the iter method, forcing the optimizer to consider the result used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/test.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nb.iter(|| {\n    // Note lack of `;` (could also use an explicit `return`).\n    (0..1000).fold(0, |old, new| old ^ new)\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Borrowing Error with Mutable and Immutable References in Rust\nDESCRIPTION: This snippet showcases an error scenario where a variable is borrowed as immutable and then attempted to be borrowed mutably. The goal is to illustrate the ownership and borrowing rules in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0502.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Function Parameters in Rust\nDESCRIPTION: Eliminates function parameters that are declared but never used in the function body. This refactoring simplifies function signatures by removing superfluous parameters, also adjusting all call sites accordingly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_102\n\nLANGUAGE: rust\nCODE:\n```\nfn frobnicate(x: i32) {}\n\nfn main() {\n    frobnicate(92);\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn frobnicate() {}\n\nfn main() {\n    frobnicate();\n}\n```\n\n----------------------------------------\n\nTITLE: Generating is_empty Method from len in Rust\nDESCRIPTION: This snippet shows how to generate an is_empty implementation based on an existing len method. It creates a new method that checks if the length is zero.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_59\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct { data: Vec<String> }\n\nimpl MyStruct {\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.data.len()\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct { data: Vec<String> }\n\nimpl MyStruct {\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.data.len()\n    }\n\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Mutable Borrowing in Rust\nDESCRIPTION: Shows the correct way to create a mutable reference by declaring the original variable as mutable using the `mut` keyword. This allows subsequent mutable borrowing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0596.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 1;\nlet y = &mut x; // ok!\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Test Example\nDESCRIPTION: Simple example demonstrating how to write a basic test function in Rust using the #[test] attribute and assertion macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/tests/index.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Mutable Borrow by Cloning\nDESCRIPTION: Demonstrates an alternative method of resolving mutable borrow conflicts by creating a clone of the original value\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0503.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of CMSE Nonsecure Entry Attribute in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous use of the #[cmse_nonsecure_entry] attribute on a function without specifying a C ABI. The compiler no longer emits this error, but the example illustrates a previously problematic pattern.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0776.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(cmse_nonsecure_entry)]\n\n#[no_mangle]\n#[cmse_nonsecure_entry]\npub fn entry_function(input: Vec<u32>) {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for x86_64-unknown-linux-none Target\nDESCRIPTION: TOML configuration for enabling the x86_64-unknown-linux-none target during Rust compiler build. This sets the build stage to 1 and specifies the target to build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/x86_64-unknown-linux-none.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-unknown-linux-none\"]\n```\n\n----------------------------------------\n\nTITLE: Defining a Fluent Diagnostic Message\nDESCRIPTION: This snippet shows how to define a simple Fluent diagnostic message that indicates an error related to taking the address of a temporary value. The message identifier is crucial for localization into other languages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/translation.md#2025-04-21_snippet_0\n\nLANGUAGE: fluent\nCODE:\n```\ntypeck_address_of_temporary_taken = cannot take address of a temporary\n```\n\n----------------------------------------\n\nTITLE: Rebuild and Reinstall Rust Analyzer Server\nDESCRIPTION: Commands to check the project and reinstall the server after making changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/setup.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo check\ncargo xtask install --server --code-bin code-insiders --dev-rel\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU for s390x Emulation on Ubuntu\nDESCRIPTION: This snippet shows how to install QEMU, a generic and open source machine emulator and virtualizer, specifically for the s390x architecture on Ubuntu.  This allows you to test cross-compiled s390x binaries on a non-s390x host system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\n\n```bash\napt install qemu-system-s390x\n```\n\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for Rustfmt\nDESCRIPTION: This snippet shows how to run the test suite for Rustfmt using the cargo test command. It covers unit tests, file comparison, idempotence tests, and project bootstrapping.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer from source using cargo\nDESCRIPTION: This snippet demonstrates how to clone the rust-analyzer repository and install it from source using cargo. It requires the latest stable version of the Rust toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/rust_analyzer_binary.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/rust-lang/rust-analyzer.git && cd rust-analyzer\n$ cargo xtask install --server\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer for Visual Studio Code\nDESCRIPTION: This snippet provides the command to copy the rust-analyzer configuration for Visual Studio Code which sets IDE settings for Miri development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nCopy [`etc/rust_analyzer_vscode.json`] to `.vscode/settings.json` in the project root directory.\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks in Miri with Bash\nDESCRIPTION: This snippet outlines the command to run Miri benchmarks, detailing the requirements for installation of 'hyperfine' and saving/loading baseline results.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nrun `./miri bench`\n```\n\nLANGUAGE: sh\nCODE:\n```\nrun `./miri bench --save-baseline=baseline.json`\n```\n\nLANGUAGE: sh\nCODE:\n```\nrun `./miri bench --load-baseline=baseline.json`\n```\n\nLANGUAGE: sh\nCODE:\n```\nrun `./miri bench mse`\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_BOOTSTRAP in UI Tests\nDESCRIPTION: Example showing how to set RUSTC_BOOTSTRAP environment variable in UI tests using rustc-env comments to enable unstable features or force stable compiler behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/misc.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Force unstable features to be usable on stable rustc\n//@ rustc-env:RUSTC_BOOTSTRAP=1\n\n// Or force nightly rustc to pretend it is a stable rustc\n//@ rustc-env:RUSTC_BOOTSTRAP=-1\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation of CoerceUnsized Between Different Structs in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to implement CoerceUnsized between two different struct types, Foo and Bar. The compiler rejects this implementation because CoerceUnsized can only be used for coercion between structures with the same definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0377.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\npub struct Foo<T: ?Sized> {\n    field_with_unsized_type: T,\n}\n\npub struct Bar<T: ?Sized> {\n    field_with_unsized_type: T,\n}\n\n// error: the trait `CoerceUnsized` may only be implemented for a coercion\n//        between structures with the same definition\nimpl<T, U> CoerceUnsized<Bar<U>> for Foo<T> where T: CoerceUnsized<U> {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Variance with #[rustc_variance] in Rust\nDESCRIPTION: This example shows how to use the #[rustc_variance] attribute to display the variance of generic parameters in a type. The attribute is only available with the rustc_attrs feature flag and is intended for testing purposes only.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0208.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// NOTE: this feature is perma-unstable and should *only* be used for\n//       testing purposes.\n#![allow(internal_features)]\n#![feature(rustc_attrs)]\n\n#[rustc_variance]\nstruct Foo<'a, T> { // error: deliberate error to display type's variance\n    t: &'a mut T,\n}\n```\n\n----------------------------------------\n\nTITLE: Disabled Merge Derives in Rust\nDESCRIPTION: Demonstrates the merge_derives setting set to false, which keeps derive attributes separate based on how they were originally grouped.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_49\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Eq, PartialEq, Debug, Copy, Clone)]\npub enum Bar {}\n\n#[derive(Eq, PartialEq)]\n#[derive(Debug)]\n#[derive(Copy, Clone)]\npub enum Foo {}\n```\n\n----------------------------------------\n\nTITLE: Updating Rust Compiler to Nightly Version - Bash\nDESCRIPTION: This bash command updates the Rust compiler to the latest nightly version, which is necessary for enabling certain experimental features like portable SIMD. Users should ensure they have rustup installed before executing this command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup update -- nightly\n```\n\n----------------------------------------\n\nTITLE: Converting Line Comments to Block Comments in Rust\nDESCRIPTION: Shows how single-line comments can be converted to a multi-line block comment. This transformation is useful for maintaining consistent comment style in the codebase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_77\n\nLANGUAGE: rust\nCODE:\n```\n   // Multi-line┃\n   // comment\n```\n\nLANGUAGE: rust\nCODE:\n```\n  /*\n  Multi-line\n  comment\n  */\n```\n\n----------------------------------------\n\nTITLE: Invalid Issue Value in Stability Attributes (Rust)\nDESCRIPTION: Example of code that will fail to compile due to invalid '0' values in the 'issue' field of stability attributes for both regular and const functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0545.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[unstable(feature = \"_unstable_fn\", issue = \"0\")] // invalid\nfn _unstable_fn() {}\n\n#[rustc_const_unstable(feature = \"_unstable_const_fn\", issue = \"0\")] // invalid\nconst fn _unstable_const_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Checking Conditional Configurations with --check-cfg\nDESCRIPTION: Examples of using the --check-cfg flag to validate conditional compilation configurations at compile-time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n--check-cfg 'cfg(verbose)'\n--check-cfg 'cfg(feature, values(\"serde\"))'\n```\n\n----------------------------------------\n\nTITLE: Valid Non-ASCII Identifier Usage in Rust\nDESCRIPTION: Example of valid usage of non-ASCII identifiers in Rust, demonstrating correct inline module declaration with non-ASCII name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0754.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod řųśť { // ok!\n    const IS_GREAT: bool = true;\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Reordering Modules in Rust\nDESCRIPTION: Illustrates how the reorder_modules option affects the alphabetical ordering of mod declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_63\n\nLANGUAGE: rust\nCODE:\n```\nmod a;\nmod b;\n\nmod dolor;\nmod ipsum;\nmod lorem;\nmod sit;\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod b;\nmod a;\n\nmod lorem;\nmod ipsum;\nmod dolor;\nmod sit;\n```\n\n----------------------------------------\n\nTITLE: Making Rust Doc Examples with `?` Testable\nDESCRIPTION: This snippet demonstrates how to make a Rust documentation example using the `?` operator runnable by `rustdoc`'s testing framework. It wraps the core example code within a hidden `main` function (`# fn main() ...`) that returns a `Result`, and includes a hidden `Ok(())` (`#     Ok(())`). These lines starting with `#` are executed during tests but hidden in the generated documentation, keeping the user-facing example clean.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\n/// Example\n/// ```rust\n/// # fn main() -> Result<(), std::num::ParseIntError> {\n/// let fortytwo = \"42\".parse::<u32>()?;\n/// println!(\"{} + 10 = {}\", fortytwo, fortytwo+10);\n/// #     Ok(())\n/// # }\n/// ```\n```\n\n----------------------------------------\n\nTITLE: Setting function alignment with the `repr(align)` attribute in Rust\nDESCRIPTION: Example of using the `#[repr(align(<align>))]` attribute to specify alignment for a specific function. This can be used to set higher alignment than the minimum specified by the `-Zmin-function-alignment` flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/min-function-alignment.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(align(<align>))]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Reference Access to Packed Struct Fields in Rust\nDESCRIPTION: This example demonstrates incorrect ways to access packed struct fields that cause E0793 errors due to unaligned memory access. It shows both direct reference creation and implicit references in format strings that are not allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0793.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling Rust Crate for RISC-V\nDESCRIPTION: Cargo command to build a Rust project targeting RISC-V 64-bit Linux\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target riscv64gc-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Rust Documentation Search Engines\nDESCRIPTION: Explains how to set up a custom search engine for Rust documentation that allows for quick access via browser navigation. It provides example URL templates for searching documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/advanced-features.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n\"https://doc.rust-lang.org/stable/std/?search=%s\"\n```\n\nLANGUAGE: text\nCODE:\n```\n\"https://doc.rust-lang.org/stable/std/?search=%s&go_to_first=true\"\n```\n\n----------------------------------------\n\nTITLE: Updating Git Remote URL\nDESCRIPTION: Changes the URL associated with a specific remote repository (e.g., 'origin'). Useful if a fork is renamed or moved. Replace `<URL>` with the new repository URL.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\ngit remote set-url origin <URL>\n```\n\n----------------------------------------\n\nTITLE: Invalid Lang Attribute Definition in Rust\nDESCRIPTION: Demonstrates an incorrect usage of the lang attribute by defining an unauthorized custom lang item. The lang attribute is reserved for core Rust compiler-specific items and cannot be arbitrarily defined by developers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0522.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items)]\\n\\n#[lang = \"cookie\"]\\nfn cookie() -> ! { // error: definition of an unknown lang item: `cookie`\\n    loop {}\\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Struct Declaration with Unique Fields in Rust\nDESCRIPTION: A valid example showing how to properly declare a struct with uniquely named fields. Each field name must be unique within the struct definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0124.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    field1: i32,\n    field2: i32, // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Install Script Options\nDESCRIPTION: Command to show available installation options and customization parameters for the Rust install script.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/etc/installer/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./install.sh --help\n```\n\n----------------------------------------\n\nTITLE: Specifying MSRV with Custom Inner Attribute in Rust\nDESCRIPTION: Shows how to specify Minimum Supported Rust Version using a custom inner attribute with the clippy::msrv feature, which requires enabling unstable features\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(custom_inner_attributes)]\n#![clippy::msrv = \"1.30.0\"]\n\nfn main() {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Matching on `TyKind` in Rust\nDESCRIPTION: This code snippet demonstrates how to match on the `kind` field of a `Ty` (type) in the Rust compiler.  The `kind` field is of type `TyKind<'tcx>`, which is an enum defining all the different kinds of types in the compiler. Inspecting the `kind` field during type inference can be risky due to inference variables and type unknowns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"fn foo(x: Ty<'tcx>) {\n  match x.kind {\n    ...\n  }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Adding Braces to Lambda and Match Arm Expressions in Rust\nDESCRIPTION: This assist adds braces to lambda and match arm expressions. It wraps single-line expressions in curly braces, improving readability and allowing for multi-line expressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(n: i32) -> i32 {\n    match n {\n        1 => n + 1,\n        _ => 0\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(n: i32) -> i32 {\n    match n {\n        1 => {\n            n + 1\n        },\n        _ => 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Eglot to Enable Clippy in Emacs\nDESCRIPTION: This snippet configures Eglot to pass the `check.command` setting to rust-analyzer, effectively enabling Clippy for Rust code analysis within the Emacs environment. It modifies the `eglot-server-programs` list to include initialization options for the rust-analyzer server.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_1\n\nLANGUAGE: Emacs Lisp\nCODE:\n```\n(add-to-list 'eglot-server-programs\n             '((rust-ts-mode rust-mode) .\n               (\"rust-analyzer\" :initializationOptions (:check (:command \"clippy\")))))\n```\n\n----------------------------------------\n\nTITLE: Adding Return Type to Function or Closure in Rust\nDESCRIPTION: This assist adds the return type to a function or closure inferred from its tail expression. It works on functions or closures without an explicit return type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() { 42i32 }\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 42i32 }\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Doc Example with Error Propagation (`?`)\nDESCRIPTION: This snippet shows a Rust documentation comment containing a code example. The example demonstrates parsing a string to a `u32` using `parse` and the `?` operator for concise error propagation. Note that this specific example, when run by `rustdoc`'s testing harness, might require wrapping in a function returning a `Result` to compile correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n/// Example\n/// ```rust\n/// let fourtytwo = \"42\".parse::<u32>()?;\n/// println!(\"{} + 10 = {}\", fourtytwo, fourtytwo+10);\n/// ```\n```\n\n----------------------------------------\n\nTITLE: Simple Function Addition in Rust\nDESCRIPTION: Demonstrates a basic Rust function that adds one to a given integer with documentation and example\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0107 Error in Rust\nDESCRIPTION: This code snippet illustrates the E0107 error by calling a function with more type arguments than it expects. The function 'foo' is defined with one type parameter, but is called with two type arguments, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0087.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>() {}\n\nfn main() {\n    foo::<f64, bool>(); // error: wrong number of type arguments:\n                        //        expected 1, found 2\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling with Non-Lexical Lifetimes (NLL)\nDESCRIPTION: Command to profile rustc with the MIR-based borrowck enabled, which implements Non-Lexical Lifetimes. This passes the -Z flag to rustc through cargo rustc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntouch src/lib.rs\nCARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib -- -Z borrowck=mir\n```\n\n----------------------------------------\n\nTITLE: Example of incorrect documentation comment usage in Rust\nDESCRIPTION: This code snippet demonstrates the E0585 error, which occurs when a documentation comment doesn't document any item. Here, a doc comment is placed inside a function but isn't attached to any item, causing a compilation failure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0585.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // The following doc comment will fail:\n    /// This is a useless doc comment!\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Implementation (Rust)\nDESCRIPTION: This function implements type inference that runs on a per-function basis, constructing a mapping from expression IDs to their inferred types using the position-independent representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-ty/src/infer.rs#L76-L131\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Lifetime Shadowing in Rust\nDESCRIPTION: This code demonstrates a lifetime shadowing error in Rust. The lifetime `'a` is defined at the `impl` level for `Foo`, and then redefined within the `f` function, causing the compiler to issue an error because the inner `'a` shadows the outer `'a`. The error E0496 is expected during compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0496.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0496\nstruct Foo<'a> {\n    a: &'a i32,\n}\n\nimpl<'a> Foo<'a> {\n    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime\n                           //        name that is already in scope\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Destructuring Struct Binding in Rust\nDESCRIPTION: Rewrites a struct binding to directly destructure its fields, removing the need for separate accessors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    bar: i32,\n    baz: i32,\n}\nfn main() {\n    let Foo { bar, baz } = Foo { bar: 1, baz: 2 };\n    let bar2 = bar;\n    let baz2 = &baz;\n}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Closure with Move Semantics in Rust\nDESCRIPTION: This Rust code shows a closure that takes ownership of a variable through move semantics, as illustrated using the `FnOnce` trait. The closure captures and drops a vector `x`, making it unusable afterwards. This example demonstrates how closure affects ownership and usability of variables in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/closure.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn closure(f: impl FnOnce()) {\n    f();\n}\n\nfn main() {\n    let x = vec![21];\n    closure(|| {\n        drop(x);  // Makes x unusable after the fact.\n    });\n    // println!(\"Value of x after return {:?}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring await-holding-invalid-types\nDESCRIPTION: Specifies a list of types that are disallowed from being held across an `await` point. This setting aids in preventing potential issues related to borrowing and lifetimes in asynchronous code. The default value is an empty list (`[]`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Using Closure for Generic Parameter Access\nDESCRIPTION: Solution using a closure to access outer function's generic parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\n----------------------------------------\n\nTITLE: String Literal Processing Pattern\nDESCRIPTION: Demonstrates the preferred way to handle string literal processing by combining precondition checks with their usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn main() {\n    let s: &str = ...;\n    if let Some(contents) = string_literal_contents(s) {\n\n    }\n}\n\nfn string_literal_contents(s: &str) -> Option<&str> {\n    if s.starts_with('\"') && s.ends_with('\"') {\n        Some(&s[1..s.len() - 1])\n    } else {\n        None\n    }\n}\n\n// BAD\nfn main() {\n    let s: &str = ...;\n    if is_string_literal(s) {\n        let contents = &s[1..s.len() - 1];\n    }\n}\n\nfn is_string_literal(s: &str) -> bool {\n    s.starts_with('\"') && s.ends_with('\"')\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling Rust Compiler with Cachegrind\nDESCRIPTION: Illustrates how to use Cachegrind to generate a detailed simulated trace of the Rust compiler's execution using the 'cachegrind' subcommand of 'x perf'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./x perf cachegrind\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Suggestions in Rust\nDESCRIPTION: This Rust function defines the signature for dynamic suggestions within the suggest-tests tool. Dynamic suggestions take a file path as input and return a vector of suggestions. This allows for greater flexibility and control in generating suggestions based on file modifications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/suggest-tests.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn(&Path) -> Vec<Suggestion>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Scope Error in Rust\nDESCRIPTION: This code snippet shows an example of the E0405 error in Rust, which occurs when trying to implement a trait that is not in scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0405.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n```\n\n----------------------------------------\n\nTITLE: Failing Iteration Example (E0626)\nDESCRIPTION: This code demonstrates another case where E0626 occurs during iteration. The borrow of `v` in the `for` loop persists across the `yield` point.  Iterating by reference is the problem here.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] || {\n  let v = vec![1,2,3];\n  for &x in &v { // <-- borrow of `v` is still in scope...\n    yield x; // ...when this yield occurs.\n  }\n};\nPin::new(&mut b).resume(());\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Associated Type Equality Constraints with `impl Trait`\nDESCRIPTION: This code illustrates how associated type equality constraints for `impl Trait` can be used, as long as the hidden type satisfies the trait bounds on the associated type. The opaque `impl Trait` signature itself does not need to satisfy them, which is a backwards compatibility hack. This is particularly relevant to lazy TAIT implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait Duh {}\n\nimpl Duh for i32 {}\n\ntrait Trait {\n    type Assoc: Duh;\n}\n\n// the fact that `R` is the `::Output` projection on `F` causes\n// an intermediate inference var to be generated which is then later\n// compared against the actually found `Assoc` type.\nimpl<R: Duh, F: FnMut() -> R> Trait for F {\n    type Assoc = R;\n}\n\n// The `impl Send` here is then later compared against the inference var\n// created, causing the inference var to be set to `impl Send` instead of\n// the hidden type. We already have obligations registered on the inference\n// var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n// type does not implement `Duh`, even if its hidden type does.\n// Lazy TAIT would error out, but we inserted a hack to make it work again,\n// keeping backwards compatibility.\nfn foo() -> impl Trait<Assoc = impl Send> {\n    || 42\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Result of make_getter Macro in Rust\nDESCRIPTION: This shows the expanded output of the make_getter macro. The concat metavariable expression has been replaced with the concatenated identifier 'get_description' to create a getter method for the description field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub struct Thing {\n    description: String,\n}\n\nimpl Thing {\n    pub fn get_description(&self) -> &String {\n        &self.description\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rustfmt on Nightly Toolchain\nDESCRIPTION: Commands to install and run Rustfmt using the nightly Rust toolchain for access to the latest features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nrustup component add rustfmt --toolchain nightly\n```\n\nLANGUAGE: sh\nCODE:\n```\ncargo +nightly fmt\n```\n\n----------------------------------------\n\nTITLE: Hiding Items with #[doc(hidden)] in Rust\nDESCRIPTION: This example demonstrates how to hide items from documentation using the `#[doc(hidden)]` attribute. Both the `Hidden` struct and its re-export `InlinedHidden` are hidden from the generated documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// This struct won't be visible.\n#[doc(hidden)]\npub struct Hidden;\n\n// This re-export won't be visible.\npub use self::Hidden as InlinedHidden;\n```\n```\n\n----------------------------------------\n\nTITLE: Collapsible-If Pattern in Current Syntax\nDESCRIPTION: Example of a complex pattern for detecting collapsible if-else statements in Rust. The pattern demonstrates the repetition required in the current pattern syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    pat_if_else: Expr =\n        If(\n            _,\n            _,\n            Block_(\n                Block(\n                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |\n                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n                )#block_inner\n            )#block\n        ) |\n        IfLet(\n            _,\n            Block_(\n                Block(\n                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |\n                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n                )#block_inner\n            )#block\n        )\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Pattern Matching Using Struct Field Index\nDESCRIPTION: Demonstrates an alternative approach to pattern match a tuple variant using struct pattern syntax with numeric field indices.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0769.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# enum E {\n#     A(i32),\n# }\n# let e = E::A(42);\nmatch e {\n    E::A { 0: number } => { // ok!\n        println!(\"{}\", number);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Slice Pattern Matching in Rust\nDESCRIPTION: Alternative solution using a slice reference instead of an array, which allows for flexible pattern matching with rest patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0730.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn is_123(x: &[u32]) -> bool { // We use a slice\n    match x {\n        [1, 2, ..] => true, // ok!\n        _ => false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust If-Else Comment Indentation Example\nDESCRIPTION: Demonstrates how trailing comment indentation is handled within if-else blocks, showing comment association with else blocks versus being part of the if block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n// if comment\nif cond {\n    \"if\"\n// else comment\n} else {\n    \"else\"\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Manual Performance Test Run\nDESCRIPTION: Command to request a performance test run on a PR before merging. This triggers a try build followed by performance benchmarking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/perf.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@bors try @rust-timer queue\n```\n\n----------------------------------------\n\nTITLE: VS Code Settings Configuration for Rust Analyzer\nDESCRIPTION: JSON configuration for setting up the rust-analyzer server path in VS Code User Settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/setup.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"rust-analyzer.server.path\": \"<path-to-rust-analyzer-binary>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Code Generation Instance Function\nDESCRIPTION: Backend-agnostic function for code generation that is parameterized by builder methods trait. Shows how generic backend interfaces are used in practice.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/backend-agnostic.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn codegen_instance<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n    cx: &'a Bx::CodegenCx,\n    instance: Instance<'tcx>\n) {\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Thread-local Variable Borrow in Rust\nDESCRIPTION: Demonstrates an erroneous attempt to borrow a thread-local variable and move it into a new thread. The code fails because the borrow of the thread-local variable FOO outlives the function where it was created, which is not allowed due to thread-local variable lifetime constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0712.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(thread_local)]\n\n#[thread_local]\nstatic FOO: u8 = 3;\n\nfn main() {\n    let a = &FOO; // error: thread-local variable borrowed past end of function\n\n    std::thread::spawn(move || {\n        println!(\"{}\", a);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Enabled Match Block Trailing Comma in Rust\nDESCRIPTION: Demonstrates the match_block_trailing_comma setting set to true, which adds trailing commas after block-based match arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_47\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    match lorem {\n        Lorem::Ipsum => {\n            println!(\"ipsum\");\n        },\n        Lorem::Dolor => println!(\"dolor\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cargo Args Structure in TypeScript\nDESCRIPTION: Details the argument structure required for executing Cargo commands, relevant for tools that interact with Rust projects via shell operations. The configuration set includes environment setups, directory paths, and specific command executions necessary for managing and initiating cargo-based operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    environment?: Record<string, string>;\n    cwd: string;\n    workspaceRoot?: string;\n    cargoArgs: string[];\n    executableArgs: string[];\n    overrideCargo?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer on Arch Linux using pacman\nDESCRIPTION: This snippet demonstrates how to install rust-analyzer on Arch Linux using the pacman package manager. It installs the package from the official repositories.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/rust_analyzer_binary.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ pacman -S rust-analyzer\n```\n\n----------------------------------------\n\nTITLE: Stopping Virtual Machine\nDESCRIPTION: Command to stop the running QEMU virtual machine\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmkqnximage --stop\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Trait Bounds Example in Rust\nDESCRIPTION: Demonstrates an erroneous case where multiple non-auto traits (Read and Write) are used as bounds for a trait object. This code fails to compile with error E0225.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0225.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let _: Box<dyn std::io::Read + std::io::Write>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal Bug Reproduction for Rust Analyzer\nDESCRIPTION: Example shell commands for creating a minimal bug reproduction case for Rust Analyzer issues. Shows how to clone a specific repository commit, check the Rust Analyzer version, and run analysis statistics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/troubleshooting.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone https://github.com/username/repo.git && cd repo && git switch --detach commit-hash\n$ rust-analyzer --version\nrust-analyzer dd12184e4 2021-05-08 dev\n$ rust-analyzer analysis-stats .\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Function Bool Parameters in Rust\nDESCRIPTION: This option defines the maximum number of boolean parameters a function can have before the `fn_params_excessive_bools` lint triggers.  The default value is `3`. This configures the threshold used by the lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_26\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Error E0789: Missing stable Attribute with rustc_allowed_through_unstable_modules\nDESCRIPTION: This code example demonstrates the incorrect usage that triggers error E0789. The rustc_allowed_through_unstable_modules attribute is applied to a struct without the required stable attribute. This is an internal compiler feature used to allow stable items to \"escape\" unstable parent modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0789.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// NOTE: both of these attributes are perma-unstable and should *never* be\n//       used outside of the compiler and standard library.\n#![feature(rustc_attrs)]\n#![feature(staged_api)]\n#![allow(internal_features)]\n\n#![unstable(feature = \"foo_module\", reason = \"...\", issue = \"123\")]\n\n#[rustc_allowed_through_unstable_modules = \"deprecation message\"]\n// #[stable(feature = \"foo\", since = \"1.0\")]\nstruct Foo;\n// ^^^ error: `rustc_allowed_through_unstable_modules` attribute must be\n//            paired with a `stable` attribute\n```\n\n----------------------------------------\n\nTITLE: BuilderMethods Trait Definition\nDESCRIPTION: Core trait defining the interface that all backend builders must implement. Includes methods for basic block creation and control flow operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/backend-agnostic.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub trait BuilderMethods<'a, 'tcx>:\n    HasCodegen<'tcx>\n    + DebugInfoBuilderMethods<'tcx>\n    + ArgTypeMethods<'tcx>\n    + AbiBuilderMethods<'tcx>\n    + IntrinsicCallMethods<'tcx>\n    + AsmBuilderMethods<'tcx>\n{\n    fn new_block<'b>(\n        cx: &'a Self::CodegenCx,\n        llfn: Self::Function,\n        name: &'b str\n    ) -> Self;\n    /* ... */\n    fn cond_br(\n        &mut self,\n        cond: Self::Value,\n        then_llbb: Self::BasicBlock,\n        else_llbb: Self::BasicBlock,\n    );\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying PowerPC SPE Linux Target in Rust\nDESCRIPTION: This code snippet shows the target triple for PowerPC SPE Linux in Rust. It's used to specify the target architecture when compiling Rust code for 32-bit PowerPC processors with SPE.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc-unknown-linux-gnuspe.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# powerpc-unknown-linux-gnuspe\n```\n\n----------------------------------------\n\nTITLE: Using rustc to disable a lint group\nDESCRIPTION: This command demonstrates how to disable the `nonstandard-style` lint group in `rustc`. This will effectively disable all lints that are part of this group, such as `non-camel-case-types`, `non-snake-case`, and `non-upper-case-globals`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/groups.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"$ rustc -D nonstandard-style\"\n```\n\n----------------------------------------\n\nTITLE: Combining Autodiff Flags in Bash for Rust Compilation\nDESCRIPTION: This bash command demonstrates how to combine multiple `autodiff` flags in a single `RUSTFLAGS` environment variable to control Enzyme's debugging and profiling behavior during a Rust build. The example combines `Enable`, `LooseTypes`, and `PrintPerf` flags for a custom build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/flags.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=\\\"-Z autodiff=Enable,LooseTypes,PrintPerf\\\" cargo +enzyme build\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code for Documentation Coverage (Rust)\nDESCRIPTION: This Rust code snippet shows an example of documented and undocumented functions, which can be used to demonstrate the --show-coverage flag in Rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n/// This item has documentation\npub fn foo() {}\n\npub fn no_documentation() {}\n```\n\n----------------------------------------\n\nTITLE: Removing Newlines Between Where Clause Bounds in Rust\nDESCRIPTION: This snippet showcases the rustfmt configuration `version = Two` behavior of removing newlines between where clause bounds. The example function `foo` demonstrates multiple where clause bounds that will be formatted without newlines between them when the specified version is used. This configuration option affects the style of where clauses in Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(_: T)\nwhere\n    T: std::fmt::Debug,\n    T: std::fmt::Display,\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Including HTML Before Content\nDESCRIPTION: This code snippet demonstrates how to use the `--html-before-content` flag to include HTML files before the main content of the generated documentation. This is helpful for adding banners or introductory sections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --html-before-content extra.html\n$ rustdoc README.md --html-before-content extra.html\n```\n\n----------------------------------------\n\nTITLE: Measure Incremental Analysis Time\nDESCRIPTION: These snippets demonstrate how to measure the time it takes for incremental analysis using `cargo run` with the `analysis-bench` subcommand. It includes examples for highlighting and completion operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --release -p rust-analyzer -- analysis-bench ../chalk/ --highlight ../chalk/chalk-engine/src/logic.rs\n```\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --release -p rust-analyzer -- analysis-bench ../chalk/ --complete ../chalk/chalk-engine/src/logic.rs:94:0\n```\n\n----------------------------------------\n\nTITLE: Compiling Test File with Staged Compiler\nDESCRIPTION: Use the newly linked stage1 toolchain to compile a Rust test file\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nrustc +stage1 testfile.rs\n```\n\n----------------------------------------\n\nTITLE: Inlining a Macro Call in Rust\nDESCRIPTION: Demonstrates how a macro invocation can be partially expanded inline, showing one step of the macro's expansion. This example shows expanding a complex nested macro that works with token trees.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_70\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! num {\n    (+$($t:tt)+) => (1 + num!($($t )+));\n    (-$($t:tt)+) => (-1 + num!($($t )+));\n    (+) => (1);\n    (-) => (-1);\n}\n\nfn main() {\n    let number = num┃!(+ + + - + +);\n    println!(\"{number}\");\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! num {\n    (+$($t:tt)+) => (1 + num!($($t )+));\n    (-$($t:tt)+) => (-1 + num!($($t )+));\n    (+) => (1);\n    (-) => (-1);\n}\n\nfn main() {\n    let number = 1+num!(+ + - + +);\n    println!(\"{number}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using rustc_layout Attribute in Rust\nDESCRIPTION: This Rust code example illustrates using the internal rustc_layout attribute to output the memory layout of a specified type. It requires enabling the rustc_attrs feature gate. The output provides detailed information on fields, ABI, alignment, and size of the specified type or reference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n\n#[rustc_layout(debug)]\ntype T<'a> = &'a u32;\n```\n\n----------------------------------------\n\nTITLE: Defining the Step Trait in Rust\nDESCRIPTION: This snippet defines the Step trait in Rust, which encapsulates the logic for building artifacts in a modular manner. The trait requires implementers to define a run method to execute actions and a should_run method to decide when a step is necessary. It also provides a make_run method which is invoked for command line interactions. Dependencies include the Debug, Clone, PartialEq, Eq, and Hash traits, which enable necessary Rust functionalities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/how-bootstrap-does-it.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n    type Output: Clone;\n\n    const DEFAULT: bool = false;\n    const ONLY_HOSTS: bool = false;\n\n    // Required methods\n    fn run(self, builder: &Builder<'_>) -> Self::Output;\n    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_>;\n\n    // Provided method\n    fn make_run(_run: RunConfig<'_>) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unterminated Multi-line Doc Comment in Rust\nDESCRIPTION: This snippet illustrates an unterminated multi-line documentation comment in Rust, which also results in a compilation error (E0758).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0758.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/*! I am not terminated!\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Non-Generic Types in Rust\nDESCRIPTION: This snippet shows the correct way to declare type aliases for `u32` and `bool` by not providing any generic arguments, as these types are not generic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0109.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ntype X = u32; // ok!\ntype Y = bool; // ok!\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic UEFI Hello World in Rust (no_std)\nDESCRIPTION: A minimal UEFI application that prints 'Hello World!' using raw UTF-16 encoding without std library support. Implements panic handler and UEFI entry point with direct system table manipulation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![no_main]\n#![no_std]\n\nuse r_efi::efi;\n\n#[panic_handler]\nfn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n    loop {}\n}\n\n#[export_name = \"efi_main\"]\npub extern \"C\" fn main(_h: efi::Handle, st: *mut efi::SystemTable) -> efi::Status {\n    let s = [\n        0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16,\n        0x0020u16,\n        0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16,\n        0x0021u16,\n        0x000au16,\n        0x0000u16,\n    ];\n\n    let r =\n        unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut efi::Char16) };\n    if r.is_error() {\n        return r;\n    }\n\n    let r = unsafe {\n        let mut x: usize = 0;\n        ((*(*st).boot_services).wait_for_event)(1, &mut (*(*st).con_in).wait_for_key, &mut x)\n    };\n    if r.is_error() {\n        return r;\n    }\n\n    efi::Status::SUCCESS\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Toolchain for powerpc64-unknown-linux-musl\nDESCRIPTION: Specifies compiler, linker, and archiver tools for cross-compilation to powerpc64-unknown-linux-musl target in bootstrap configuration\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64-unknown-linux-musl.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.powerpc64-unknown-linux-musl]\ncc = \"powerpc64-linux-musl-gcc\"\ncxx = \"powerpc64-linux-musl-g++\"\nar = \"powerpc64-linux-musl-ar\"\nlinker = \"powerpc64-linux-musl-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Compile Fail Example: Multiple Main Functions in Rust\nDESCRIPTION: This Rust code snippet demonstrates a compile-time error due to having multiple `main` functions defined within the same scope. Rust requires a single entry point for binary executables, identified by the `main` function. Defining multiple `main` functions will cause the compiler to issue an error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0136.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // ...\n}\n\n// ...\n\nfn main() { // error!\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Into to From Implementation in Rust\nDESCRIPTION: Converts an Into implementation to a From implementation. No additional dependencies are required.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nimpl From<usize> for Thing {\n    fn from(val: usize) -> Self {\n        Thing {\n            b: val.to_string(),\n            a: val\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Complex If-Else Token Handling\nDESCRIPTION: Shows complex if-else block handling with token parsing and comments. Demonstrates how comments within blocks are treated as block members rather than associated with else statements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nif toks.eat_token(Token::Word(\"modify\"))? && toks.eat_token(Token::Word(\"labels\"))? {\n    if toks.eat_token(Token::Colon)? {\n        // ate the token\n    } else if toks.eat_token(Token::Word(\"to\"))? {\n        // optionally eat the colon after to, e.g.:\n        // @rustbot modify labels to: -S-waiting-on-author, +S-waiting-on-review\n        toks.eat_token(Token::Colon)?;\n    } else {\n        // It's okay if there's no to or colon, we can just eat labels\n        // afterwards.\n    }\n    1 + 2;\n    // continue\n} else if toks.eat_token(Token::Word(\"label\"))? {\n    // continue\n} else {\n    return Ok(None);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Rust Code with Single Relaxed Default Bound\nDESCRIPTION: This code shows the proper way to use a relaxed bound, with only one trait (?Sized) being relaxed. This is the correct approach when you need to opt out of a default trait bound in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0203.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Good<T: ?Sized>{\n    inner: T\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading Popular Crates - Bash\nDESCRIPTION: Retrieves the most downloaded crates from crates.io using the cargo lintcheck popular command. The example demonstrates fetching 200 popular crates and saving them to a custom TOML file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo lintcheck popular -n 200 custom.toml\n```\n\n----------------------------------------\n\nTITLE: MIR Basic Block Structure\nDESCRIPTION: Illustrates the structure of a basic block in MIR (Mid-level Intermediate Representation). A basic block consists of a sequence of statements that execute together, culminating in a terminator that dictates the flow of control to other basic blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_0\n\nLANGUAGE: mir\nCODE:\n```\nbb0: {\n    statement0;\n    statement1;\n    statement2;\n    ...\n    terminator;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Lint to Documentation in Clippy Config - Rust\nDESCRIPTION: Shows how to update lint documentation by defining the lint in the lint configuration macro (define_Conf!) within clippy_config/src/conf.rs. Include the new lint name in the #[lints(...)] attribute, and ensure the msrv option is present with its default value. All lints requiring MSRV gating must be documented this way. Dependencies: macro usage and correct lint naming.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\ndefine_Conf! {\n    #[lints(\n        allow_attributes,\n        allow_attributes_without_reason,\n        ..\n        <the newly added lint name>,\n        ..\n        unused_trait_names,\n        use_self,\n    )]\n    msrv: Msrv = Msrv::default(),\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Derive Attribute on Struct in Rust\nDESCRIPTION: This code snippet shows the correct application of the `derive` attribute on a struct in Rust. The `Clone` trait is derived for the `Bar` struct, which is a valid use of the `derive` attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0774.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone)] // ok!\nstruct Bar {\n    field: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Partial Type Annotation with Complex Types in Rust\nDESCRIPTION: This example shows how to use a partial type annotation with a placeholder (_) when dealing with more complex types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Test Function Implementation\nDESCRIPTION: Shows the basic structure of a test function using the #[test] attribute with a simple assertion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn my_test() {\n    assert!(2+2 == 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the MutVisitor Trait in Rust\nDESCRIPTION: This snippet illustrates the implementation of the `MutVisitor` trait for the custom visitor defined earlier. The `visit_foo` method is overridden to provide custom logic when processing a node labeled 'foo', using the `super_foo` method for recursive traversal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/visitor.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<'tcx> MutVisitor<'tcx> for MyVisitor {\n    fn visit_foo(&mut self, ...) {\n        ...\n        self.super_foo(...);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests\nDESCRIPTION: Command to run the test suite for the rustc_codegen_gcc project in release mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh test --release\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Implicit Lifetime Bounds in Rust\nDESCRIPTION: This snippet shows a function definition with implicit lifetime bounds on a boxed trait object. This style may trigger warnings after the Rust 1.3 changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0398.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# trait SomeTrait {}\nfn foo(arg: &Box<SomeTrait>) { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Generating Inherent Impl for Struct in Rust\nDESCRIPTION: This snippet demonstrates how to add a new inherent impl block for a struct. It creates an empty impl block with the correct generic parameters and bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_58\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ctx<T: Clone> {\n    data: T,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ctx<T: Clone> {\n    data: T,\n}\n\nimpl<T: Clone> Ctx<T> {}\n```\n\n----------------------------------------\n\nTITLE: Patching crates - Diff\nDESCRIPTION: This diff demonstrates how to patch a dependency in Cargo's 'Cargo.toml' to use a specific commit of the libc crate from a Git repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 1e83f05e0ca..4d0172071c1 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -113,6 +113,8 @@ cargo-util = { path = \"src/tools/cargo/crates/cargo-util\" }\n [patch.crates-io]\n+libc = { git = \"https://github.com/rust-lang/libc\", rev = \"0bf7ce340699dcbacabdf5f16a242d2219a49ee0\" }\n\n # See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n # here\n rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n```\n\n----------------------------------------\n\nTITLE: Configuring Sysroot Cleaning Behavior in Rust Build System\nDESCRIPTION: Option to disable cleaning of the sysroot directory, which allows reusing old compiled artifacts when the sysroot source hasn't changed. This is useful when the codegen backend remains unmodified.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/config.txt#2025-04-21_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n#keep_sysroot\n```\n\n----------------------------------------\n\nTITLE: Parsing Raw Identifier Token in Rust\nDESCRIPTION: This snippet defines the token type 'IDENT' with the value 'r#raw_ident' to represent a raw identifier in Rust syntax parsing. It also includes a whitespace character, typically used in tokenization or lexing processes, to handle formatting in the source code. The snippet illustrates how raw identifiers are marked and distinguished during parsing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/raw_ident.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nIDENT \"r#raw_ident\"\\nWHITESPACE \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Example of Panic Output with Only Line Information in Rust\nDESCRIPTION: This example demonstrates how panic output appears when using the `-Z location-detail=line` option, which only includes the line number but redacts the file path information. This helps reduce binary size while still providing some location context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/location-detail.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npanicked at 'Process blink had a fault', <redacted>:323:0\n```\n\n----------------------------------------\n\nTITLE: Defining Static String Constant in Rust\nDESCRIPTION: This snippet defines a static string constant with the value 'Hello World!'. It is intended for use as a constant reference within Rust programs. The constant is declared with a static lifetime, ensuring it is available for the duration of the program's runtime. No external dependencies are required.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/import-macro-verbatim/include/include.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstatic TEST: &str = \"Hello World!\";\n```\n\n----------------------------------------\n\nTITLE: Convert Derive Macro to Manual Implementation in Rust\nDESCRIPTION: Transforms a derive macro into its equivalent manual trait implementation. Particularly useful for customizing derived implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_109\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Display)]\nstruct S;\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Display)]\nstruct S;\n\nimpl Debug for S {\n    fn fmt(&self, f: &mut Formatter) -> Result<()> {\n        f.debug_struct(\"S\").finish()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Iterate by Value\nDESCRIPTION: This code fixes the iteration example by iterating by value (using `into_iter()`). This avoids borrowing `v` and moves the values into the loop. Now there are no borrows persisting across the yield.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] || {\n  let v = vec![1,2,3];\n  for x in v { // <-- Take ownership of the values instead!\n    yield x; // <-- Now yield is OK.\n  }\n};\nPin::new(&mut b).resume(());\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Lifetime Bounds Example in Rust\nDESCRIPTION: Demonstrates incorrect code that triggers E0226 error by specifying two lifetime bounds ('a and 'b) on a trait object. This is not allowed in Rust's type system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0226.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\ntype T<'a, 'b> = dyn Foo + 'a + 'b; // error: Trait object `arg` has two\n                                    //        lifetime bound, 'a and 'b.\n```\n\n----------------------------------------\n\nTITLE: Correct Method Call in Rust\nDESCRIPTION: This code snippet shows the correct way to call a method in Rust by adding parentheses after the method name.  The `method` function is called using `f.method()`, which is the correct syntax for invoking methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0615.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n```\n\n----------------------------------------\n\nTITLE: Clang++ Wrapper Script for x86_64-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang++ compiler from the OpenHarmony SDK for the x86_64-unknown-linux-ohos target. It configures the compiler for the target, setting the sysroot and defining the __MUSL__ macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\n  -target x86_64-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol for Constant Generic Parameter\nDESCRIPTION: Shows the mangled symbol for the 'example' function with a constant generic parameter, demonstrating how constant values are encoded in the symbol name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n_RINvCs7qp2U7fqm6G_7mycrate7exampleKy12345678_EB2_\n                                    ││└───┬───┘\n                                    ││    │\n                                    ││    └── const-data 0x12345678\n                                    │└─────── const type u64\n                                    └──────── const generic arg\n```\n\n----------------------------------------\n\nTITLE: Destructuring Tuple Binding in Rust\nDESCRIPTION: Transforms a tuple binding into direct destructuring, enhancing direct variable assignment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let (\\_0, \\_1) = (1,2);\n    let v = \\_0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Erroneous Feature Attributes in Rust\nDESCRIPTION: This snippet exemplifies incorrect usages of the feature attribute, illustrating common errors that could arise when defining feature flags. It serves as a warning to developers regarding malformed feature definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0556.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"#![feature(foo_bar_baz, foo(bar), foo = \\\"baz\\\", foo)] // error!\\n#![feature] // error!\\n#![feature = \\\"foo\\\"] // error!\"\n```\n\n----------------------------------------\n\nTITLE: External Module Declarations in lib.rs\nDESCRIPTION: The three external module declarations found in the lib.rs file. These declarations reference modules a, b, and c which are expected to be resolved through Rust's module resolution system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/tests/mod-resolver/issue-5198/lib/explanation.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nmod a;\nmod b;\nmod c;\n```\n\n----------------------------------------\n\nTITLE: CoroutineState Enum Definition in Rust\nDESCRIPTION: Defines the CoroutineState enum used to represent the yielded or completed state of a coroutine execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coroutines.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub enum CoroutineState<Y, R> {\n    Yielded(Y),\n    Complete(R),\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shadowing with Enum in Rust\nDESCRIPTION: This snippet illustrates a compilation error caused by shadowing an enum variant in Rust when omitting its fields in a match pattern. It shows an enum defined with fields and a match expression that mistakenly tries to reference it with a pattern that doesn't include its fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0530.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"enum Enum {\\n    WithField(i32)\\n}\\n\\nuse Enum::*;\\nmatch WithField(1) {\\n    WithField => {} // error: missing (_)\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping Return Type in Option in Rust Functions\nDESCRIPTION: Wraps a function's return type in an Option and updates the returned value to be wrapped in Some. Useful when adding nullable return support to a function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_118\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 42i32 }\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Option<i32> { Some(42i32) }\n```\n\n----------------------------------------\n\nTITLE: Canonicalizing Query in Rust\nDESCRIPTION: This snippet demonstrates how to transform a trait query with unbound variables and lifetimes into its canonical form. This involves replacing free lifetime variables and inference variables to create a structure that is consistent regardless of the identity of the original variables. It prepares the query for solving by the trait system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n?0: Foo<'?1, ?2>\n```\n\n----------------------------------------\n\nTITLE: Recursive Async Function with Boxed Call\nDESCRIPTION: A correct implementation that boxes the recursive function call using Box::pin() to ensure known size and memory stability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0733.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn foo(n: usize) {\n    if n > 0 {\n        Box::pin(foo(n - 1)).await;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Preferred Method Chain Formatting in Rust\nDESCRIPTION: Examples demonstrating the preferred style for method chains in Rust, favoring consistent multi-line formatting over mixing single and multi-line elements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// Better\nself.pre_comment\n    .as_ref()\n    .map_or(false, |comment| comment.starts_with(\"//\"))\n\n// Worse\nself.pre_comment.as_ref().map_or(\n    false,\n    |comment| comment.starts_with(\"//\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Item Usage in Rust\nDESCRIPTION: This code snippet demonstrates the solution to the ambiguous item usage problem. It modifies the import statements and function calls to use fully qualified paths, resolving the ambiguity and allowing the code to compile successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0659.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Implementation of Foreign Trait with Local Type in Rust\nDESCRIPTION: This example shows a valid implementation of a foreign trait by wrapping the generic type parameter in a local type, adhering to Rust's orphan rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0210.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyType<T>(T);\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n```\n\n----------------------------------------\n\nTITLE: Invalid Lifetime Parameter Name Example in Rust\nDESCRIPTION: Demonstrates an error case where 'static is incorrectly used as a lifetime parameter name. This is invalid because 'static is a special built-in lifetime name that denotes the lifetime of the entire program and cannot be used as a generic lifetime parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0262.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// error, invalid lifetime parameter name `'static`\nfn foo<'static>(x: &'static str) { }\n```\n\n----------------------------------------\n\nTITLE: Handling Specialization Errors in Rust (Rust)\nDESCRIPTION: This Rust code snippet demonstrates an erroneous attempt to specialize trait implementations without marking all necessary parent implementations as default, leading to compilation errors. It shows a baseline trait definition and two implementations where conflicting specializations occur, particularly with the Clone trait and primitive types like i32.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0520.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(specialization)]\n\ntrait SpaceLlama {\n    fn fly(&self);\n}\n\n// applies to all T\nimpl<T> SpaceLlama for T {\n    default fn fly(&self) {}\n}\n\n// non-default impl\n// applies to all `Clone` T and overrides the previous impl\nimpl<T: Clone> SpaceLlama for T {\n    fn fly(&self) {}\n}\n\n// since `i32` is clone, this conflicts with the previous implementation\nimpl SpaceLlama for i32 {\n    default fn fly(&self) {}\n    // error: item `fly` is provided by an `impl` that specializes\n    //        another, but the item in the parent `impl` is not marked\n    //        `default` and so it cannot be specialized.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building Rust Project for x64 UWP using build-std (PowerShell)\nDESCRIPTION: This snippet demonstrates the command to build a Rust project for the x86_64 UWP target using the `cargo` command with the `build-std` option. It allows including specific components for the build, such as `std` and `panic_abort`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/uwp-windows-msvc.md#2025-04-21_snippet_1\n\nLANGUAGE: pwsh\nCODE:\n```\ncargo build -Z build-std=std,panic_abort --target x86_64-uwp-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Configuring Matches for Let Else in Rust\nDESCRIPTION: This option configures whether the matches should be considered by the lint, and whether there should be filtering for common types. The lint affected is `manual_let_else`. The default value is `\"WellKnownTypes\"`. The value should be a string, the meaning of which is not further described.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_25\n\n\n\n----------------------------------------\n\nTITLE: Registering a Renamed Lint\nDESCRIPTION: This Rust snippet demonstrates how to register a renamed lint using the `store.register_renamed` function. It shows the renaming of `single_use_lifetime` to `single_use_lifetimes`, notifying users of the change. This requires access to the `LintStore` and the `rustc_lint` package.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nstore.register_renamed(\"single_use_lifetime\", \"single_use_lifetimes\");\n\n```\n\n----------------------------------------\n\nTITLE: Initial Setup and Building\nDESCRIPTION: The required sequence of commands to set up the environment and build the sysroot for rustc_codegen_gcc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh prepare\n$ ./y.sh build --sysroot\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unknown Feature Error in Rust\nDESCRIPTION: This code snippet showcases the error E0635 in Rust, which arises when an attempt is made to enable a non-existent or unsupported feature using the `#![feature]` attribute. The compiler will flag this as an error, preventing compilation. The error highlights the importance of specifying valid and supported feature flags in Rust projects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0635.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"#![feature(nonexistent_rust_feature)] // error: unknown feature\"\n```\n\n----------------------------------------\n\nTITLE: Example Rust Trait Implementation\nDESCRIPTION: Demonstrates a simple trait implementation that serves as an example for the canonicalization process where Trait<Vec<T>> is implemented for u32.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/canonicalization.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Trait<Vec<T>> for u32\n```\n\n----------------------------------------\n\nTITLE: Nested Module Visibility with Ancestor Reference\nDESCRIPTION: Demonstrates visibility restriction using an ancestor module path in a nested module structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0742.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub mod earth {\n    pub mod sea {\n        pub (in crate::earth) struct Shark; // ok!\n    }\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Props Struct Declaration in Rust\nDESCRIPTION: Implementation of adding a new property to the TestProps struct for tracking test directives in the Rust compiler test suite\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/directives.md#2025-04-21_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n@@ -232,6 +232,7 @@ pub struct TestProps {\n     // customized normalization rules\n     pub normalize_stdout: Vec<(String, String)>,\n     pub normalize_stderr: Vec<(String, String)>,\n+    pub failure_status: i32,\n }\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Compile Toolchain - Shell\nDESCRIPTION: This shell command installs the cross-compile toolchain for the x86_64-unknown-uefi target using rustup, allowing for the compilation of Rust code for UEFI environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# install cross-compile toolchain\nrustup target add x86_64-unknown-uefi\n# target flag may be used with any cargo or rustc command\ncargo build --target x86_64-unknown-uefi\n```\n\n----------------------------------------\n\nTITLE: Changelog Section Structure Template\nDESCRIPTION: A markdown template showing the standard section headers used in the Clippy changelog. This structure organizes changes by type including new lints, moves/deprecations, enhancements, and fixes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/changelog_update.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n### New Lints\n* Added [`LINT`] to `GROUP`\n\n### Moves and Deprecations\n* Moved [`LINT`] to `GROUP` (From `GROUP`, now LEVEL-by-default)\n* Renamed `LINT` to [`LINT`]\n\n### Enhancements\n### False Positive Fixes\n### Suggestion Fixes/Improvements\n### ICE Fixes\n### Documentation Improvements\n### Others\n```\n\n----------------------------------------\n\nTITLE: Using perf-focus with relative percentages for MIR borrowck analysis\nDESCRIPTION: Demonstrates using perf-focus with --relative option to show percentages relative to do_mir_borrowck execution time rather than total program time. Also uses max depth and minimum percentage thresholds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ perf focus '{do_mir_borrowck}' --tree-callees --relative --tree-max-depth 1 --tree-min-percent 5\nMatcher    : {do_mir_borrowck}\nMatches    : 577\nNot Matches: 746\nPercentage : 100%\n\nTree\n| matched `{do_mir_borrowck}` (100% total, 0% self)\n: | rustc_borrowck::nll::compute_regions (47% total, 0% self) [...]\n: | rustc::mir::visit::Visitor::visit_mir (19% total, 15% self) [...]\n: | <rustc_borrowck::MirBorrowckCtxt<'cx, 'tcx> as rustc_mir_dataflow::DataflowResultsConsumer<'cx, 'tcx>>::visit_statement_entry (13% total, 0% self) [...]\n: | rustc_mir_dataflow::do_dataflow (8% total, 1% self) [...]\n```\n\n----------------------------------------\n\nTITLE: Implementing CoerceUnsized on Struct Without Unsized Fields\nDESCRIPTION: Example showing incorrect implementation of CoerceUnsized trait on a struct that doesn't contain any unsized fields. This code fails to compile with error E0374 because the Foo struct has no fields that can be coerced to an unsized type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0374.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo<T: ?Sized> {\n    a: i32,\n}\n\n// error: Struct `Foo` has no unsized fields that need to be coerced.\nimpl<T, U> CoerceUnsized<Foo<U>> for Foo<T>\n    where T: CoerceUnsized<U> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing MirPass Trait for CleanupPostBorrowck in Rust\nDESCRIPTION: Example of implementing the MirPass trait for a pass called CleanupPostBorrowck. This pass walks the MIR and removes all statements that are not relevant to code generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/passes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct CleanupPostBorrowck;\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx> MirPass<'tcx> for CleanupPostBorrowck {\n    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Import of Type from Trait in Rust\nDESCRIPTION: This example demonstrates the E0253 error which occurs when attempting to directly import a type (SomeType) from a trait (MyTrait). In Rust, it's not valid to directly import associated types that belong to traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0253.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub trait MyTrait {\n        type SomeType;\n    }\n}\n\nuse foo::MyTrait::SomeType;\n// error: `SomeType` is not directly importable\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Preprocessor in book.toml for mdBook\nDESCRIPTION: This TOML snippet shows how to configure a custom preprocessor in the book.toml file. It sets up the preprocessor command and specifies extra directories to watch during the build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustbook/README.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[preprocessor.spec]\ncommand = \"cargo run --manifest-path my-cool-extension/Cargo.toml\"\n\n[build]\nextra-watch-dirs = [\"my-cool-extension/src\"]\n```\n\n----------------------------------------\n\nTITLE: Updating Rustup Installation\nDESCRIPTION: Terminal command to update Rustup and ensure latest compiler version\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup update\n```\n\n----------------------------------------\n\nTITLE: Resolving Import Name Conflict Using 'as' Keyword\nDESCRIPTION: Demonstrates the correct way to resolve the naming conflict by using the 'as' keyword to rename the extern crate import, allowing both the extern crate and trait to coexist.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0254.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core as libcore; // ok!\n\nmod foo {\n    pub trait core {\n        fn do_something();\n    }\n}\n\nuse foo::core;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Identifying Incorrect Lifetime Usage in Rust\nDESCRIPTION: This snippet showcases incorrect usage of lifetimes in Rust where a reserved lifetime name `'_` and `&T` without an explicit lifetime name are used. The erroneous usage is annotated, illustrating the compile error caused by these practices.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0637.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0106,E0637\nfn underscore_lifetime<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n                     //^^ `'_` is a reserved lifetime name\n    if str1.len() > str2.len() {\n        str1\n    } else {\n        str2\n    }\n}\n\nfn without_explicit_lifetime<T>()\nwhere\n    T: Iterator<Item = &u32>,\n                     //^ `&` without an explicit lifetime name\n{\n}\n\nfn without_hrtb<T>()\nwhere\n    T: Into<&u32>,\n          //^ `&` without an explicit lifetime name\n{\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declarative Lint Registration in Rust\nDESCRIPTION: This code snippet demonstrates how to declare a lint using the `declare_lint!` macro, which results in a static identifier of type `&rustc_lint_defs::Lint`. This is integral for creating metadata for lints, including its default level. The snippet showcases the typical usage pattern of declaring a lint in the Rust compiler's linting infrastructure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/lintstore.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// Example lint declaration\ndeclare_lint!(MY_LINT);\n```\n\n----------------------------------------\n\nTITLE: Using repr128 Feature with Rust Enum\nDESCRIPTION: Demonstrates how to use the repr128 feature to specify u128 representation for an enum. The example shows a simple enum 'Foo' with a single variant containing a u64 value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/repr128.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr128)]\n\n#[repr(u128)]\nenum Foo {\n    Bar(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Symbol Unmangling by Linker in Rust\nDESCRIPTION: Sets the COLLECT_NO_DEMANGLE environment variable to prevent the linker from unmangling symbols when processing Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCOLLECT_NO_DEMANGLE=1\n```\n\n----------------------------------------\n\nTITLE: Converting Generated Lint Pass to Manual Definition in Rust\nDESCRIPTION: Example showing how to convert a lint pass from using the generated macro to a manual definition struct that can hold configuration values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n// Generated struct definition\ndeclare_lint_pass!(StructName => [\n    LINT_NAME\n]);\n\n// New manual definition struct\npub struct StructName {}\n\nimpl_lint_pass!(StructName => [\n    LINT_NAME\n]);\n```\n\n----------------------------------------\n\nTITLE: Correct Function Trait Specification in Rust\nDESCRIPTION: This code shows the proper way to specify a function trait using angle-bracket notation by wrapping the argument type in a tuple. The comma in (i32,) is necessary to create a 1-tuple, allowing the function to be called with the expected syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0059.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unboxed_closures)]\n\nfn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }\n```\n\n----------------------------------------\n\nTITLE: Using cargo::rustc-check-cfg in Rust Build Scripts\nDESCRIPTION: Example of using the cargo::rustc-check-cfg instruction in a build.rs file to declare expected custom configurations. This works alongside cargo::rustc-cfg for dynamically setting configuration flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg/cargo-specifics.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"cargo::rustc-check-cfg=cfg(has_foo)\");\n    //        ^^^^^^^^^^^^^^^^^^^^^^ new with Cargo 1.80\n    if has_foo() {\n        println!(\"cargo::rustc-cfg=has_foo\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Value to Resolve Borrowing Constraint\nDESCRIPTION: Demonstrates how to resolve borrowing issues by moving the original value and creating a new instance\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0506.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\n----------------------------------------\n\nTITLE: Compiling Static Libraries for KMC Solid Target\nDESCRIPTION: This shell command compiles a Rust program as a static library for the `aarch64-kmc-solid_asp3` target using the `rustc` command. It requires the library artifacts to be available for compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/kmc-solid.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc --target aarch64-kmc-solid_asp3 your-code.rs --crate-type staticlib\n$ ls libyour_code.a\n```\n\n----------------------------------------\n\nTITLE: Correcting Borrowing Errors in Rust\nDESCRIPTION: This code snippet fixes the borrowing error by ensuring that the mutable reference is used before creating an immutable reference. Thus, adhering to Rust's borrowing rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0502.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Union Initialization in Rust\nDESCRIPTION: This example shows two erroneous ways to initialize a union: with no fields specified, and with multiple fields specified. Both cases trigger the E0784 error since unions must be initialized with exactly one field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0784.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunion Bird {\n    pigeon: u8,\n    turtledove: u16,\n}\n\nlet bird = Bird {}; // error\nlet bird = Bird { pigeon: 0, turtledove: 1 }; // error\n```\n\n----------------------------------------\n\nTITLE: Outlives Constraint Cycle Example\nDESCRIPTION: This example demonstrates how outlives constraints can form cycles in a graph representation, indicating that the regions within the cycle must be equivalent. Detecting these cycles through strongly connected components (SCCs) allows the inference process to be more efficient by treating the regions as a single unit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n'a: 'b\n'b: 'c\n'c: 'd\n'd: 'a\n```\n\n----------------------------------------\n\nTITLE: Configuring Bootstrap for VxWorks Targets\nDESCRIPTION: This configuration snippet demonstrates how to modify the `bootstrap.toml` file to include VxWorks targets for Rust compilation. The `target` list in `bootstrap.toml` must be updated to include the desired VxWorks target identifiers, alongside the necessary workbench and wr-cc configurations. This process is crucial for cross-compiling Rust for VxWorks platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/vxworks.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\nbuild-stage = 1\\ntarget = [\\n    \"<HOST_TARGET>\",\\n    \"x86_64-wrs-vxworks\",\\n    \"aarch64-wrs-vxworks\",\\n    \"i686-wrs-vxworks\",\\n    \"armv7-wrs-vxworks-eabihf\",\\n    \"powerpc-wrs-vxworks\",\\n    \"powerpc64-wrs-vxworks\",\\n    \"powerpc-wrs-vxworks-spe\",\\n]\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Variadic C Function in Rust\nDESCRIPTION: This example shows proper usage of C's printf function in Rust with various numbers of arguments. It demonstrates providing the minimum format string argument and additional arguments as needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0060.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use std::os::raw::{c_char, c_int};\n# #[cfg_attr(all(windows, target_env = \"msvc\"),\n#            link(name = \"legacy_stdio_definitions\",\n#                 kind = \"static\", modifiers = \"-bundle\"))]\n# extern \"C\" { fn printf(_: *const c_char, ...) -> c_int; }\n# fn main() {\nunsafe {\n    printf(c\"test\\n\".as_ptr());\n\n    printf(c\"number = %d\\n\".as_ptr(), 3);\n\n    printf(c\"%d, %d\\n\".as_ptr(), 10, 5);\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Breaking from Labeled Block\nDESCRIPTION: Example demonstrating how to break from a labeled block directly, using the block's label in the break statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0695.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    'a: {\n        break 'a;\n    }\n    break;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabled Match Arm Blocks in Rust\nDESCRIPTION: Demonstrates setting match_arm_blocks to false, which allows match arm bodies to continue on the next line without block wrapping when they don't fit on the same line as the match operator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_42\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    match lorem {\n        lorem =>\n            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n        ipsum => println!(\"{}\", sit),\n        sit => foo(\n            \"foooooooooooooooooooooooo\",\n            \"baaaaaaaaaaaaaaaaaaaaaaaarr\",\n            \"baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz\",\n            \"qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx\",\n        ),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Using LoongArch64 Target with Rustup\nDESCRIPTION: This shell command installs the cross-compilation toolchain for LoongArch64 using `rustup` and demonstrates building Rust programs with the specified target. It requires Rust 1.74 or later and the presence of `cargo`, `rustc`, and `rustup` on the system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/loongarch-none.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# install cross-compile toolchain\nrustup target add loongarch64-unknown-none\n# target flag may be used with any cargo or rustc command\ncargo build --target loongarch64-unknown-none\n```\n\n----------------------------------------\n\nTITLE: Using the rustc_const_stable attribute in Rust\nDESCRIPTION: The #[rustc_const_stable] attribute explicitly marks a const fn as having its constness be stable, specifying the feature name and version since which it has been stabilized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stability.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_const_stable(feature = \"foo\", since = \"1.420.69\")]\n```\n\n----------------------------------------\n\nTITLE: Match Arm Body Formatting in Rust\nDESCRIPTION: Guidelines for formatting match arm bodies in Rust. Single, simple expressions can start on the same line, while complex expressions or those with comments must be in blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nmatch foo {\n    // A combinable expression.\n    foo => a_function_call(another_call(\n        argument1,\n        argument2,\n    )),\n    // A non-combinable expression\n    bar => {\n        a_function_call(\n            another_call(\n                argument1,\n                argument2,\n            ),\n            another_argument,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Type Definition in Rust\nDESCRIPTION: Shows the correct way to define multiple distinct types by using different names, avoiding the E0428 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0428.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\nstruct Bar2; // ok!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference Error in Rust\nDESCRIPTION: This code demonstrates the E0282 error that occurs when creating a Vec without specifying its type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Vec::new();\n```\n\n----------------------------------------\n\nTITLE: Configuring LoongArch Target in Bootstrap.toml\nDESCRIPTION: This TOML snippet shows how to configure the `bootstrap.toml` file to enable building for the `loongarch64-unknown-linux-gnu` target. Ensure LoongArch toolchain binaries are reachable through `$PATH` or specified directly in the file. This configuration is necessary for custom Rust builds targeting LoongArch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/loongarch-linux.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[build]\ntarget = [\"loongarch64-unknown-linux-gnu\"]\n```\n\nLANGUAGE: TOML\nCODE:\n```\n[target.loongarch64-unknown-linux-gnu]\n# Adjust the paths to point at your toolchain\n# Suppose the toolchain is placed at /TOOLCHAIN_PATH, and the cross prefix is\n# \"loongarch64-unknown-linux-gnu-\":\ncc = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\"\ncxx = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-g++\"\nar = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ar\"\nranlib = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ranlib\"\nlinker = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Label and Ping Command for WASM Group in Markdown\nDESCRIPTION: This snippet shows the GitHub label and ping command for the WebAssembly notification group. It uses Markdown formatting to display the information clearly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/wasm.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n**Github Label:** [O-wasm] <br>\n**Ping command:** `@rustbot ping wasm`\n\n[O-wasm]: https://github.com/rust-lang/rust/labels/O-wasm\n```\n\n----------------------------------------\n\nTITLE: Building Rust Compiler and Standard Library\nDESCRIPTION: Compile the Rust compiler, standard library, and associated tools using the 'x' build command\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./x build\n```\n\n----------------------------------------\n\nTITLE: External Module Declarations in d.rs\nDESCRIPTION: Lists three external module declarations from the d.rs file that define the module structure\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/tests/mod-resolver/issue-5198/lib/c/d/explanation.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod e;\nmod f;\nmod g;\n```\n\n----------------------------------------\n\nTITLE: Generating Function Stub in Rust\nDESCRIPTION: This snippet shows how to generate a stub function with a signature matching a function call. It creates a new function definition with appropriate parameters and a placeholder return type and body.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_55\n\nLANGUAGE: rust\nCODE:\n```\nstruct Baz;\nfn baz() -> Baz { Baz }\nfn foo() {\n    bar(\"\", baz());\n}\n\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Baz;\nfn baz() -> Baz { Baz }\nfn foo() {\n    bar(\"\", baz());\n}\n\nfn bar(arg: &str, baz: Baz) ${0:-> _} {\n    todo!()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Cranelift Codegen Backend with Cargo\nDESCRIPTION: Command to build a project using the Cranelift codegen backend instead of the default LLVM backend, using the cargo-clif wrapper script.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ $cg_clif_dir/dist/cargo-clif build\n```\n\n----------------------------------------\n\nTITLE: Defining Transparent Unions in Rust\nDESCRIPTION: Demonstrates how to create transparent unions with single and multiple fields. The unions have the same representation as their non-zero-sized field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/transparent-unions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(transparent_unions)]\n\n// This union has the same representation as `f32`.\n#[repr(transparent)]\nunion SingleFieldUnion {\n    field: f32,\n}\n\n// This union has the same representation as `usize`.\n#[repr(transparent)]\nunion MultiFieldUnion {\n    field: usize,\n    nothing: (),\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Error in Rust Closure\nDESCRIPTION: This code snippet shows an erroneous implementation where a closure does not satisfy the 'static lifetime constraint. The closure captures a reference with a non-static lifetime, causing a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0477.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\n\nstruct MyString<'a> {\n    data: &'a str,\n}\n\nfn i_want_static_closure<F>(a: F)\n    where F: Fn() + 'static {}\n\nfn print_string<'a>(s: Mutex<MyString<'a>>) {\n\n    i_want_static_closure(move || {     // error: this closure has lifetime 'a\n                                        //        rather than 'static\n        println!(\"{}\", s.lock().unwrap().data);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Running MDBook with Link Validation\nDESCRIPTION: Command to serve the documentation with link checking enabled via environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nENABLE_LINKCHECK=1 mdbook serve\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function in Rust\nDESCRIPTION: This snippet demonstrates the definition of a generic function `foo` with a type parameter `T`. It shows how the function item type is constructed with a generic type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Sized>(a: T) -> T { \n    # a\n    /* snip */\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0790 Error with Ambiguous Trait Method Call in Rust\nDESCRIPTION: This code snippet shows an error case where the compiler cannot determine which implementation of the Coroutine trait to use when calling the create() method. Multiple implementations exist for different types, causing ambiguity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0790.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Coroutine {\n    fn create() -> u32;\n}\n\nstruct Impl;\n\nimpl Coroutine for Impl {\n    fn create() -> u32 { 1 }\n}\n\nstruct AnotherImpl;\n\nimpl Coroutine for AnotherImpl {\n    fn create() -> u32 { 2 }\n}\n\nlet cont: u32 = Coroutine::create();\n// error, impossible to choose one of Coroutine trait implementation\n// Should it be Impl or AnotherImpl, maybe something else?\n```\n\n----------------------------------------\n\nTITLE: Converting Nested Function to Closure in Rust\nDESCRIPTION: Converts a nested function within another function into a closure, demonstrating inline definition and usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let foo = |label: &str, number: u64| {\n        println!(\"{}: {}\", label, number);\n    };\n\n    foo(\"Bar\", 100);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Name Collision in Rust\nDESCRIPTION: Example showing a name collision error where an attempt is made to import 'Bar' while a type alias and module with the same name already exist in the current scope. This demonstrates why such imports were previously disallowed by the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0256.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::Bar; // error\n\ntype Bar = u32;\n\nmod foo {\n    pub mod Bar { }\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust for WebAssembly Target\nDESCRIPTION: Example command showing how to compile a Rust source file to WebAssembly using rustc's --target flag. This demonstrates cross-compilation to the wasm32-unknown-unknown target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/targets/index.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc src/main.rs --target=wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Incorrect Intrinsic Static Declaration in Rust\nDESCRIPTION: An erroneous example showing an intrinsic declared as a static instead of a function, which is not allowed by the Rust compiler. This code demonstrates the incorrect way to define an intrinsic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0622.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\\n#![allow(internal_features)]\\n\\nextern \"C\" {\\n    #[rustc_intrinsic]\\n    pub static atomic_singlethreadfence_seqcst: unsafe fn();\\n    // error: intrinsic must be a function\\n}\\n\\nfn main() { unsafe { atomic_singlethreadfence_seqcst(); } }\n```\n\n----------------------------------------\n\nTITLE: Raw Byte String Literal Error in Rust\nDESCRIPTION: This snippet showcases an error in Rust related to raw byte string literals. Specifically, it highlights the case where a raw byte string literal is missing its closing delimiter, including the necessary number of '#' symbols.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_with_unicode_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"br##\\\"\\\\u{20AA}\" error: Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Installing MDBook Tools with Cargo\nDESCRIPTION: Command to install required MDBook tools including mdbook, linkcheck2, toc, and mermaid plugins for building the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook mdbook-linkcheck2 mdbook-toc mdbook-mermaid\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Implementation with Extra Associated Constant (E0438)\nDESCRIPTION: Demonstrates incorrect implementation of a trait by adding an associated constant 'BAR' that is not defined in the trait 'Foo'. This code will fail to compile with error E0438.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0438.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nimpl Foo for i32 {\n    const BAR: bool = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Rust Character Literal with Incomplete Syntax\nDESCRIPTION: Demonstrates a syntax error when defining a character literal without a proper closing quote. Rust requires character literals to be enclosed in single quotes with a complete character representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_char_with_slash_single_quote.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n'\\''\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust with Target Support - TOML\nDESCRIPTION: This snippet shows how to configure the Rust build environment to support the armeb-unknown-linux-gnueabi target by modifying the bootstrap.toml file to specify the compiler and build settings, including setting the target architectures and paths for compilers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armeb-unknown-linux-gnueabi.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[llvm]\ndownload-ci-llvm = false\noptimize = true\nninja = true\ntargets = \"ARM;X86\"\nclang = false\n\n[build]\ntarget = [\"x86_64-unknown-linux-gnu\", \"armeb-unknown-linux-gnueabi\"]\ndocs = false\ndocs-minification = false\ncompiler-docs = false\n[install]\nprefix = \"/home/user/x-tools/rust/\"\n\n[rust]\ndebug-logging=true\nbacktrace = true\nincremental = true\n\n[target.x86_64-unknown-linux-gnu]\n\n[dist]\n\n[target.armeb-unknown-linux-gnueabi]\ncc = \"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc\"\ncxx = \"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-g++\"\nar = \"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ar\"\nranlib = \"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ranlib\"\nlinker = \"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc\"\nllvm-config = \"/home/user/x-tools/clang/bin/llvm-config\"\nllvm-filecheck = \"/home/user/x-tools/clang/bin/FileCheck\"\n```\n\n----------------------------------------\n\nTITLE: Using Default for Struct Initialization\nDESCRIPTION: This snippet recommends using the `Default` trait for struct initialization over a zero-argument `new` function, enhancing uniformity and reducing boilerplate code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\n#[derive(Default)]\nstruct Foo {\n    bar: Option<Bar>\n}\n\n// BAD\nstruct Foo {\n    bar: Option<Bar>\n}\n\nimpl Foo {\n    fn new() -> Foo {\n        Foo { bar: None }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating PSEXE Format Binaries with cargo-psx\nDESCRIPTION: Shell command for using cargo-psx to generate binaries in the PSEXE format, which can be run by PlayStation 1 emulators. This requires the cargo-psx tool to be installed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mipsel-sony-psx.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo psx build\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Invalid Match Pattern\nDESCRIPTION: This code demonstrates the E0533 error. It attempts to use the `Tortoise::turtle` method directly as a match pattern, which is invalid because it's not a unit struct, variant, or constant. The code will fail to compile.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0533.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0533\nstruct Tortoise;\n\nimpl Tortoise {\n    fn turtle(&self) -> u32 { 0 }\n}\n\nmatch 0u32 {\n    Tortoise::turtle => {} // Error!\n    _ => {}\n}\nif let Tortoise::turtle = 0u32 {} // Same error!\n```\n```\n\n----------------------------------------\n\nTITLE: Erroneous Nested impl Trait Usage in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect use of impl Trait where it's nested within the generic arguments of another impl Trait. This pattern is not allowed in Rust and will result in a compilation error (E0666).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0666.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyGenericTrait<T> {}\ntrait MyInnerTrait {}\n\nfn foo(\n    bar: impl MyGenericTrait<impl MyInnerTrait>, // error!\n) {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Version Info Generation in build.rs\nDESCRIPTION: Sets up version information generation in the build script using the setup_version_info macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/README.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    rustc_tools_util::setup_version_info!();\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running Rust Programs with C-SKY on QEMU\nDESCRIPTION: Set up a new Rust project, build, and run it using QEMU for the C-SKY architecture. Requires QEMU installation and setting environment variables to link the toolchain and execute binaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/csky-unknown-linux-gnuabiv2.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ncargo new hello_world\ncd hello_world\n```\n\nLANGUAGE: Shell\nCODE:\n```\nCARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_RUNNER=${QEMU_PATH}/bin/qemu-cskyv2 -L ${TOOLCHAIN_PATH}/csky-linux-gnuabiv2/libc \\\nCARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_LINKER=${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc \\\nRUSTFLAGS=\"-C target-feature=+crt-static\" \\\ncargo +stage2 run --target csky-unknown-linux-gnuabiv2\n```\n\n----------------------------------------\n\nTITLE: Illustrating Correct Inner Doc Comment Usage in Rust\nDESCRIPTION: This example demonstrates the proper use of inner doc comments in Rust. Inner doc comments can be applied to modules or used inside function blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0753.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//! A working comment applied to the module!\nfn foo() {\n    //! Another working comment!\n}\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy on a struct with non-Copy field\nDESCRIPTION: An example showing an E0204 error when trying to implement the Copy trait on a struct that contains a Vec<u32> field, which doesn't implement Copy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0204.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    foo: Vec<u32>,\n}\n\nimpl Copy for Foo { } // error!\n```\n\n----------------------------------------\n\nTITLE: Running Error Code Doctests\nDESCRIPTION: This shell command executes the error index generator to test examples added in `rustc_error_codes/src/error_codes`.  It ensures the examples are valid and the error messages are correctly formatted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/error-codes.md#2025-04-21_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n./x test ./src/tools/error_index_generator\n```\n\n----------------------------------------\n\nTITLE: Understanding Unsize Trait in Rust\nDESCRIPTION: This section describes the Unsize trait, its purpose, and its relationship with the unsizing of types. It clarifies that Unsize is not intended for user implementation, but rather defines the types permitted to be unsized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/unsize.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nTo contrast, the `Unsize` trait is concerned the actual types that are allowed to be unsized.\n```\n\n----------------------------------------\n\nTITLE: Correct Label Usage in Rust Loop\nDESCRIPTION: Demonstrates proper usage of a labeled break in Rust where the label is directly accessible within the same scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0767.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n'a: loop {\n    break 'a; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Raw Pointer Assignment from Temporary Value in Rust\nDESCRIPTION: Shows an erroneous example that triggers E0745 error by attempting to take a raw pointer to a temporary value. This is unsafe because the temporary value is destroyed immediately after assignment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0745.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn temp_address() {\n    let ptr = &raw const 2; // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding s390x Target using `rustup`\nDESCRIPTION: This snippet demonstrates how to add the `s390x-unknown-linux-gnu` target to your Rust toolchain using `rustup`. This allows you to cross-compile Rust code for the s390x architecture on a non-s390x host. The command ensures that the necessary libraries and dependencies for the target are available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n\n```bash\nrustup target add s390x-unknown-linux-gnu\n```\n\n```\n\n----------------------------------------\n\nTITLE: Building Rust with C-SKY Target\nDESCRIPTION: Commands to build the Rust compiler targeting C-SKY CPUs using the x.py build system. Requires the toolchain to be properly linked for the build environment within the Rust directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/csky-unknown-linux-gnuabiv2.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# in rust dir\n./x.py build --stage 2\n```\n\n----------------------------------------\n\nTITLE: Rust Link Native Libraries Configuration Options\nDESCRIPTION: Configuration options for the link-native-libraries compiler flag that determines whether native libraries specified in #[link] attributes are passed to the linker. Can be set to 'yes' (default) to pass libraries to the linker or 'no' to ignore them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/link-native-libraries.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[link]\n```\n\n----------------------------------------\n\nTITLE: Customizing Semantic Token Styling for Unsafe Operations (JSON)\nDESCRIPTION: This snippet provides a specific example of customizing the appearance of unsafe operations in the VS Code editor.  It allows you to apply a specific color to `operator.unsafe`, `function.unsafe`, and `method.unsafe`.  Requires VS Code and the Rust extension. The output visually highlights unsafe operations in the editor. Configuration takes place in settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n   \"editor.semanticTokenColorCustomizations\": {\n         \"rules\": {\n             \"operator.unsafe\": \"#ff6600\",\n             \"function.unsafe\": \"#ff6600\",\n             \"method.unsafe\": \"#ff6600\"\n         }\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Empty Function Definition in Rust\nDESCRIPTION: Defines an empty function named 'blah' with line number prefix '4 4 1'\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/tests/writemode/target/modified.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn blah() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Break Within Loop in Rust\nDESCRIPTION: This example shows the proper usage of the 'break' keyword within a loop context. The 'break' statement is used within a 'for' loop, which is a valid context for loop control keywords.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0268.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn some_func() {\n    for _ in 0..10 {\n        break; // ok!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of repr(transparent) in Rust\nDESCRIPTION: This snippet demonstrates the correct way to use the `repr(transparent)` attribute. It should be used alone without other representation hints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0692.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\nstruct Grams(f32);\n```\n\n----------------------------------------\n\nTITLE: Implementing Callbacks trait in Rust\nDESCRIPTION: A trait that allows for custom compiler configuration and running custom code after different phases of compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Callbacks\n```\n\n----------------------------------------\n\nTITLE: Clang++ Wrapper Script for armv7-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang++ compiler from the OpenHarmony SDK for the armv7-unknown-linux-ohos target. It sets the target architecture, sysroot, defines the __MUSL__ macro and specifies ARMv7 architecture options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\n  -target arm-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  -march=armv7-a \\\n  -mfloat-abi=softfp \\\n  -mtune=generic-armv7-a \\\n  -mthumb \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Tracking Down Incorrect Edges in Dependency Graph\nDESCRIPTION: This example demonstrates how to use the `RUST_FORBID_DEP_GRAPH_EDGE` environment variable to identify incorrect edges in the dependency graph by setting specific filters. The backtrace helps in tracking the source of the erroneous edges when running the compiler with debug assertions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nRUST_FORBID_DEP_GRAPH_EDGE='Hir&foo -> Collect&bar'\n```\n\n----------------------------------------\n\nTITLE: Template Modifiers for s390x Architecture in Rust Inline Assembly\nDESCRIPTION: This table describes the template modifiers for the 'vreg' register class in the s390x architecture, showing that no specific modifier is used and providing an example of the output format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-experimental-reg.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Architecture | Register class | Modifier | Example output | LLVM modifier |\n| ------------ | -------------- | -------- | -------------- | ------------- |\n| s390x | `vreg` | None | `%v0` | None |\n```\n\n----------------------------------------\n\nTITLE: Correct Import Order in Rust Function\nDESCRIPTION: Example showing the correct placement of a 'use' import statement at the beginning of a function body, before any non-item statements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0154.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn f() {\n    use std::io::Read;\n    let x = 0;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer VSIX via Command Line (Shell)\nDESCRIPTION: Installs the rust-analyzer VS Code extension from a downloaded .vsix file using the `code` command-line tool. This method is an alternative to installing from the marketplace. Requires the VS Code command-line tool (`code`) to be in the system PATH and the correct path to the downloaded `.vsix` file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ code --install-extension /path/to/rust-analyzer.vsix\n```\n\n----------------------------------------\n\nTITLE: Starting Fuchsia Emulator\nDESCRIPTION: Commands to start a Fuchsia emulator using ffx.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}\n${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless\n```\n\n----------------------------------------\n\nTITLE: Failed Generic Parameter Inheritance in Struct Definition\nDESCRIPTION: Example showing incorrect attempt to use outer function's generic parameter in inner struct definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build Target for RISC-V\nDESCRIPTION: This snippet shows how to specify the RISC-V target in the Rust build configuration. It sets up the target in the `Cargo.toml` file to enable building for RISC-V.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv32imac-unknown-xous-elf.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"riscv32imac-unknown-xous-elf\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Main Function with Generic Parameters in Rust (Error Example)\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to define the main function with generic parameters in Rust. This is not allowed and will result in a compilation error (E0131).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0131.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main<T>() { // error: main function is not allowed to have generic parameters\n}\n```\n\n----------------------------------------\n\nTITLE: Converting From to TryFrom in Rust\nDESCRIPTION: Turns a From implementation into a TryFrom implementation while wrapping returns in Ok. It modifies the error type to use TypeError.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nimpl TryFrom<usize> for Thing {\n    type Error = ${0:()};\n\n    fn try_from(val: usize) -> Result<Self, Self::Error> {\n        Ok(Thing {\n            b: val.to_string(),\n            a: val\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Async Receiver Struct Using Rust Futures\nDESCRIPTION: The snippet defines an AsyncReceiver struct that utilizes Rust's mpsc Receiver. It demonstrates how to create an asynchronous receiver which returns a future when the recv method is called. This structure is crucial for asynchronous programming in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc::Receiver;\n\n/// This is a version of [`Receiver<T>`] with support for [`std::future`].\n///\n/// You can obtain a [`std::future::Future`] by calling [`Self::recv()`].\npub struct AsyncReceiver<T> {\n    sender: Receiver<T>\n}\n\nimpl<T> AsyncReceiver<T> {\n    pub async fn recv() -> T {\n        unimplemented!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Errors Without Line Information in Rust UI Tests\nDESCRIPTION: Demonstrates the //~? idiom for matching errors without specific line information. This is more precise than using error-pattern and should be preferred for diagnostics without spans.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n//@ compile-flags: --print yyyy\n\n//~? ERROR unknown print request: `yyyy`\n```\n\n----------------------------------------\n\nTITLE: Basic Late Bound Lifetime Parameter Example\nDESCRIPTION: Demonstrates the difference between early and late bound lifetime parameters in function definitions and how turbofish syntax interacts with them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(b: &'a u32) -> &'a u32 { b }\n\nlet f /* : FooFnItem<????> */ = foo::<'static>;\n```\n\n----------------------------------------\n\nTITLE: Generating Mutable Getter Method in Rust\nDESCRIPTION: This snippet shows how to generate a mutable getter method for a struct field. It creates an impl block with a method that returns a mutable reference to the field value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_57\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    name: String,\n}\n\nimpl Person {\n    fn name_mut(&mut self) -> &mut String {\n        &mut self.name\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inlining a Local Variable in Rust\nDESCRIPTION: Shows how a local variable can be inlined by replacing references to it with its definition. This example replaces a variable holding a simple expression with the expression itself at its usage site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_69\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x┃ = 1 + 2;\n    x * 4;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    (1 + 2) * 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating FromEnv with a Rust function\nDESCRIPTION: This Rust code snippet demonstrates the `FromEnv(TraitRef)` domain goal, showing how in-scope where clauses are available within a function's body. In this case, the function `loud_clone` has a trait bound `T: Clone`, so `FromEnv(T: Clone)` holds within the function body.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"fn loud_clone<T: Clone>(stuff: &T) -> T {\n    println!(\\\"cloning!\\\");\n    stuff.clone()\n}\"\n```\n\n----------------------------------------\n\nTITLE: Converting Bool Match to matches! Macro in Rust\nDESCRIPTION: Replaces a 2-arm boolean match with the matches! macro for concise conditional expressions in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    matches!(scrutinee, Some(val) if val.cond())\n}\n```\n\n----------------------------------------\n\nTITLE: Example Trait Implementation\nDESCRIPTION: An example Rust trait implementation that may be used in the context of canonicalization and solving trait queries. The implementation specifies a constraint that X must outlive 'a.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a, X> Foo<'a, X> for Vec<X>\nwhere X: 'a\n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Configuring Space Before Colon in Rust\nDESCRIPTION: Demonstrates the 'space_before_colon' option. When false (default), no space is added before colons. When true, a space is added before colons.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_66\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<T: Eq>(t: T) {\n    let lorem: Dolor = Lorem {\n        ipsum: dolor,\n        sit: amet,\n    };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<T : Eq>(t : T) {\n    let lorem : Dolor = Lorem {\n        ipsum : dolor,\n        sit : amet,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Style in Rust\nDESCRIPTION: Shows the recommended way to import and use items from 'hir' and 'ast' modules, emphasizing qualification to avoid name clashes and improve clarity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nuse syntax::ast;\n\nfn frobnicate(func: hir::Function, strukt: ast::Struct) {}\n\n// BAD\nuse hir::Function;\nuse syntax::ast::Struct;\n\nfn frobnicate(func: Function, strukt: Struct) {}\n```\n\n----------------------------------------\n\nTITLE: Allowing Specific Lints in Rust\nDESCRIPTION: Example of using attribute syntax to allow specific lints for a code block or item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lints.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(lintname)]\n```\n\n----------------------------------------\n\nTITLE: Recursive Async Function with Boxed Body\nDESCRIPTION: Alternative implementation that boxes the entire function body, returning a Pin<Box<dyn Future>> for size stability and proper memory management.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0733.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\nuse std::pin::Pin;\nfn foo(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n    Box::pin(async move {\n        if n > 0 {\n            foo(n - 1).await;\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Method Chains in Rust\nDESCRIPTION: Guidelines for formatting chains of field accesses and method calls in Rust. Each element should be on its own line with line breaks before the dot and after any try operator, with block indentation for subsequent lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet foo = bar\n    .baz?\n    .qux();\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Associated Type with Explicit Lifetime in Rust\nDESCRIPTION: This code snippet shows the correct way to use an associated type with a trait that has generic parameters. It demonstrates two valid approaches: one using a concrete lifetime and another using a generic lifetime parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0212.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait Foo<T> {\n    type A;\n\n    fn get(&self, t: T) -> Self::A;\n}\n\nfn foo3<I : for<'x> Foo<&'x isize>>(\n    x: <I as Foo<&isize>>::A) {} // ok!\n\n\nfn foo4<'a, I : for<'x> Foo<&'x isize>>(\n    x: <I as Foo<&'a isize>>::A) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Trait Definition Formatting in Rust\nDESCRIPTION: Shows the formatting for Rust trait definitions, including the use of block-indent for trait items and single-line formatting for traits without items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\npub trait Bar {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced #[rustc_on_unimplemented] with Multiple Error Components\nDESCRIPTION: Shows how to customize different parts of the error message including the main message, label, and additional note using the #[rustc_on_unimplemented] attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_on_unimplemented(\n    message=\"message\",\n    label=\"label\",\n    note=\"note\"\n)]\ntrait MyIterator<A> {\n    fn next(&mut self) -> A;\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Pattern Matching in Rust Enums\nDESCRIPTION: This snippet provides a corrected version of the pattern match for the 'State' enum in Rust. It demonstrates how to correctly match a tuple variant using ref bindings to extract and use the data within the tuple.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0532.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nenum State {\n    Succeeded,\n    Failed(String),\n}\n\nfn print_on_failure(state: &State) {\n    match *state {\n        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n        _ => ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Binding of Struct Fields in Rust\nDESCRIPTION: This example shows the correct way to bind struct fields in a pattern, where each field is bound exactly once. The 'a' field is bound to variable 'x' and the 'b' field is bound to variable 'y'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0025.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: u8,\n    b: u8,\n}\n\nfn main(){\n    let x = Foo { a:1, b:2 };\n\n    let Foo { a: x, b: y } = x; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Struct Update Syntax in Rust\nDESCRIPTION: This example shows the proper way to use struct update syntax by providing a base expression (f1) that will be used to fill the remaining fields not explicitly specified.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0797.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    fizz: u8,\n    buzz: u8\n}\n\nlet f1 = Foo { fizz: 10, buzz: 1};\nlet f2 = Foo { fizz: 10, ..f1 };\n```\n\n----------------------------------------\n\nTITLE: Using Closure to Capture Variables\nDESCRIPTION: Correct implementation using a closure instead of an inner function to capture variables from the containing scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0434.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    let y = 5;\n    let bar = || {\n        y\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Borrow Trait in Rust\nDESCRIPTION: These impls define how types can be borrowed. The first impl defines the reflexive `Borrow` implementation for all types, stating that a type can borrow itself. The second defines that a `Vec<T>` can be borrowed as `[T]` when `T` is sized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonical-queries.md#2025-04-21_snippet_0\n\nLANGUAGE: rust,ignore\nCODE:\n```\n\"impl<T> Borrow<T> for T where T: ?Sized\\nimpl<T> Borrow<[T]> for Vec<T> where T: Sized\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Another Constant in Rust\nDESCRIPTION: In this snippet, a second constant named 'CONST_WITH_INNER' is introduced. Similar to the previous constants, it is defined with specific properties and location. It can be utilized as a part of the Rust module's constant definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"CONST_WITH_INNER\",\n    def: Const(\n        Const {\n            id: ConstId(\n                2,\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: CONST,\n            range: 593..665,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 599..615,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GitLab CI with Clippy for Rust\nDESCRIPTION: This snippet configures a GitLab CI job to run Clippy on a Rust project. It uses the `rust:latest` Docker image and sets the `RUSTFLAGS` environment variable to treat warnings as errors. The job installs Clippy and then runs it on all targets and features of the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/continuous_integration/gitlab.md#2025-04-21_snippet_0\n\nLANGUAGE: yml\nCODE:\n```\n\"# Make sure CI fails on all warnings, including Clippy lints\nvariables:\n  RUSTFLAGS: \\\"-Dwarnings\\\" # Treat warnings as errors\n\nclippy_check:\n  image: rust:latest\n  script:\n    - rustup component add clippy # Install clippy\n    - cargo clippy --all-targets --all-features # Run clippy on all targets and features\"\n```\n\n----------------------------------------\n\nTITLE: Using Clippy Driver Directly\nDESCRIPTION: Example of using clippy-driver directly without cargo\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nclippy-driver --edition 2018 -Cpanic=abort foo.rs\n```\n\n----------------------------------------\n\nTITLE: Character Type Checking Implementation\nDESCRIPTION: Example of implementing a lint pass to check if an expression is of character type\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl LateLintPass<'_> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        // Get type of `expr`\n        let ty = cx.typeck_results().expr_ty(expr);\n\n        // Check if the `Ty` of this expression is of character type\n        if ty.is_char() {\n            println!(\"Our expression is a char!\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Canonicalized Query Result\nDESCRIPTION: Converts a query result into its canonical form, mapping inference and canonical variables accordingly. This step finalizes the canonicalization process and prepares results for application in different contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nCanonical(QR) = for<T, L> {\n    certainty: Proven,\n    var_values: [Vec<?0>, '?1, ?0]\n    region_constraints: [?0: '?1],\n    value: (),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Crate A in Another Library Crate\nDESCRIPTION: This snippet demonstrates how to use the crate named 'a' in another library crate. It highlights the conflict that arises when the crate names are the same, leading to ambiguity in symbol resolution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0519.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"a\"]\n#![crate_type = \"lib\"]\n\n// error: the current crate is indistinguishable from one of its dependencies:\n//        it has the same crate-name `a` and was compiled with the same\n//        `-C metadata` arguments. This will result in symbol conflicts between\n//        the two.\nextern crate a;\n\npub fn foo() {}\n\nfn bar() {\n    a::foo(); // is this calling the local crate or the dependency?\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring LLVM for WebAssembly Target\nDESCRIPTION: This TOML configuration specifies options in bootstrap.toml to ensure LLVM can support the WebAssembly target and build the wasm32-unknown-emscripten target. It sets the 'targets' field to enable building for WebAssembly and configures the build stage. Inputs are the configuration keys and values, and the expected output is a correctly set-up environment for compiling WebAssembly target within Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[llvm]\ntargets = \"WebAssembly\"\n\n[build]\nbuild-stage = 1\ntarget = [\"wasm32-unknown-emscripten\"]\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Parameter Default Using Forward Declaration in Rust\nDESCRIPTION: This code snippet demonstrates an error (E0128) caused by a generic parameter with a default value using a forward-declared identifier. The parameter T has a default value U, but U is declared after T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0128.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T = U, U = ()> {\n    field1: T,\n    field2: U,\n}\n// error: generic parameters with a default cannot use forward declared\n//        identifiers\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Trait Implementation in Rust\nDESCRIPTION: Shows erroneous code examples where traits are implemented redundantly, either through direct implementation or through trait inheritance. Includes cases where a trait is implemented on itself and where supertraits are explicitly implemented despite being automatically available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0371.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo { fn foo(&self) { } }\ntrait Bar: Foo { }\ntrait Baz: Bar { }\n\nimpl Bar for Baz { } // error, `Baz` implements `Bar` by definition\nimpl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\nimpl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\nimpl Baz for Bar { } // Note: This is OK\n```\n\n----------------------------------------\n\nTITLE: Compiling for Specific Instruction Set\nDESCRIPTION: This Bash command customizes the compilation flags to target specific CPU instruction sets, using the `target_cpu` option. Set in `RUSTFLAGS`, the example targets `x86-64-v3` architecture, allowing optimization for specific processors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=\"-C target_cpu=x86-64-v3\" ./x build ...\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation of Trait with Constant as Associated Type in Rust\nDESCRIPTION: This code example demonstrates an erroneous implementation where a trait defines a constant (N) but the implementation incorrectly provides an associated type instead. This causes compiler error E0325.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0325.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    type N = u32;\n    // error: item `N` is an associated type, which doesn't match its\n    //        trait `<Bar as Foo>`\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Unicode Normalization in Trait Names\nDESCRIPTION: Demonstrates handling of non-Unicode Normalization Form C identifiers in trait declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foó: Bar {}\n```\n\n----------------------------------------\n\nTITLE: Displaying target features for wasm32\nDESCRIPTION: This command displays available target features for the `wasm32-unknown-unknown` target using `rustc`. The output can be used to enable or disable specific WebAssembly features during compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc -Ctarget-feature=help --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Clang Wrapper Script for armv7-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang compiler from the OpenHarmony SDK for the armv7-unknown-linux-ohos target. It sets the target architecture, sysroot, defines the __MUSL__ macro, and specifies ARMv7 architecture options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\n  -target arm-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  -march=armv7-a \\\n  -mfloat-abi=softfp \\\n  -mtune=generic-armv7-a \\\n  -mthumb \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Using the reg-struct-return Feature Flag in Rust\nDESCRIPTION: Example of the -Zreg-struct-return compiler flag for Rust which enables returning small structs in registers instead of on the stack for extern \"C\"-like functions. This flag is only supported on x86 architecture and is unsound to mix with code not using this flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/reg-struct-return.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Zreg-struct-return\n```\n\n----------------------------------------\n\nTITLE: Processed Canonical Query Result\nDESCRIPTION: Demonstrates applying the canonical query result in its original context by instantiating and unifying variables with original ones, while capturing region constraints for verification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n{\n      certainty: Proven,\n      var_values: [Vec<?C>, '?D, ?C]\n                       ^^   ^^^ fresh inference variables\n      region_constraints: [?C: '?D],\n      value: (),\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Label Usage in Rust Closure\nDESCRIPTION: Example showing invalid usage of a label break within a closure, resulting in E0767 error. The label 'a is not accessible from within the closure scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0767.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n'a: loop {\n    || {\n        loop { break 'a } // error: use of unreachable label `'a`\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Cranelift Build for Compilation\nDESCRIPTION: Example command to use the custom-built Cranelift backend for compiling other Rust programs. This demonstrates how to leverage the modified compiler in practical scenarios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$RustCheckoutDir/compiler/rustc_codegen_cranelift/dist/cargo-clif build --release\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive List Type in Rust\nDESCRIPTION: Definition of a recursive list structure where each node contains a value and an optional reference to the next node. This type requires coinduction for proving traits like Send.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct List<T> {\n    value: T,\n    next: Option<Box<List<T>>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Direct Access to External Data in Rust Compiler\nDESCRIPTION: This snippet demonstrates the usage of the `-Z direct-access-external-data` option in Rust. It controls whether GOT indirection is used to reference external data symbols. The option accepts 'yes' to disable GOT indirection and 'no' to enable it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/direct-access-external-data.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `direct_access_external_data`\n\nThe tracking issue for this feature is: https://github.com/rust-lang/compiler-team/issues/707\n\n------------------------\n\nOption `-Z direct-access-external-data` controls how to access symbols of\nexternal data.\n\nSupported values for this option are:\n\n- `yes` - Don't use GOT indirection to reference external data symbols.\n- `no` - Use GOT indirection to reference external data symbols.\n\nIf the option is not explicitly specified, different targets have different\ndefault values.\n```\n\n----------------------------------------\n\nTITLE: Initiating FCP (Final Comment Period) for Feature Stabilization\nDESCRIPTION: Command to trigger the RFC bot to start a Final Comment Period for feature stabilization. Team members will review the proposal and decide whether to proceed with stabilization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n@rfcbot fcp merge\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Custom CSS Classes in Rust Doctests\nDESCRIPTION: Shows how to use dot notation as an alternative to 'class=' when adding CSS classes to code blocks in documentation. This is equivalent to the previous example but with a more concise syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n/// ```custom,{.language-c}\n/// int main(void) { return 0; }\n/// ```\npub struct Bar;\n```\n\n----------------------------------------\n\nTITLE: @rustbot Issue Claiming Command - Markdown\nDESCRIPTION: This snippet shows the command used to claim an issue. Contributors can use this command to assign the issue to themselves if it is unassigned.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustbot.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot claim\n```\n\n----------------------------------------\n\nTITLE: Defining Trait Methods Without Patterns in Rust\nDESCRIPTION: This snippet shows the correct way to define a trait method in Rust by using a single name for parameters instead of patterns. By naming the argument with a single identifier, the method adheres to Rust's trait syntax requirements, preventing compile errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0642.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Foo {\n    fn foo(x_and_y: (i32, i32)); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Writing User-Focused Pull Request Descriptions\nDESCRIPTION: Examples of good and bad pull request titles, demonstrating how to write them from a user's perspective rather than implementation details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# GOOD\nMake goto definition work inside macros\n\n# BAD\nUse original span for FileId\n```\n\n----------------------------------------\n\nTITLE: Using expect as a Precondition in Rust\nDESCRIPTION: Demonstrates the 'expect as precondition' style where expect's message describes what should have happened. This approach provides context about the expected state rather than just describing the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/error.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet path = std::env::var(\"IMPORTANT_PATH\")\n    .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n```\n\n----------------------------------------\n\nTITLE: Correct Raw Pointer Type Specification in Rust\nDESCRIPTION: Corrected version of the code that properly specifies the pointer type as *const i32.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0699.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet foo = &1;\nlet bar = foo as *const i32;\nif bar.is_null() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Command Line Example for Retrieving Deployment Target\nDESCRIPTION: Command to check the current default deployment target for rustc\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-darwin.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustc --print=deployment-target\n```\n\n----------------------------------------\n\nTITLE: Using x perf Command for Rust Compiler Profiling\nDESCRIPTION: Demonstrates the usage of the './x perf' command to interact with the rustc-perf benchmarking suite. This command provides various subcommands for benchmarking, comparing results, and profiling the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./x perf <command> [options]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Plugin Implementation in rlib Format\nDESCRIPTION: Example of incorrect plugin implementation using rlib crate type. Shows a plugin registrar function that won't work because it's not in dylib format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0457.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"rlib\"]\n#![feature(rustc_private)]\n\nextern crate rustc_middle;\nextern crate rustc_driver;\n\nuse rustc_driver::plugin::Registry;\n\n#[no_mangle]\nfn __rustc_plugin_registrar(_: &mut Registry) {}\n```\n\n----------------------------------------\n\nTITLE: Using Partial Type Specification with Turbofish in Rust\nDESCRIPTION: This example shows how to use a partial type specification with the turbofish syntax and a placeholder.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\n----------------------------------------\n\nTITLE: Function with Type-Checked Clone Constraint\nDESCRIPTION: Demonstrates type checking with a Clone trait bound, where the parameter environment allows proving the trait constraint\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Clone>(a: T) {\n    requires_clone(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding Lifetime Parameters with Higher Ranked Function Pointers in Rust\nDESCRIPTION: This snippet illustrates how early and late bound parameters function with higher ranked trait bounds. It contrasts `foo`'s early bound lifetime with `bar`'s late bound lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// The `'a: 'a` bound forces this lifetime to be early bound.\nfn foo<'a: 'a>(b: &'a String) -> &'a String { b }\nfnt bar<'a>(b: &'a String) -> &'a String { b }\n\n// Early bound generic parameters are instantiated here when naming\n// the function `foo`. As `'a` is early bound an argument is provided.\nlet f = foo::<'_>;\n\n// Both function arguments are required to have the same lifetime as\n// the lifetime parameter being early bound means that `f` is only\n// callable for one specific lifetime.\n\n// As we call this with borrows of different lifetimes, the borrow checker\n// will error here.\nf(&String::new());\nf(&String::new());\n```\n\n----------------------------------------\n\nTITLE: Thread-Local Static Variable Symbol Example\nDESCRIPTION: Illustrates symbol name generation for a thread-local static variable with a vendor-specific suffix on macOS\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nthread_local! {\n    pub static EXAMPLE: RefCell<u32> = RefCell::new(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Documentation Header for Rust Lints\nDESCRIPTION: Markdown header indicating this is an auto-generated documentation file for allowed-by-default lints in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/listing/allowed-by-default.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Allowed-by-default Lints\\n\\nThis file is auto-generated by the lint-docs script.\n```\n\n----------------------------------------\n\nTITLE: Path Prefix Remapping Example\nDESCRIPTION: Example showing how to use the --remap-path-prefix flag to normalize build output paths by remapping source path prefixes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n--remap-path-prefix foo=bar\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Implementations of an Intrinsic in Rust\nDESCRIPTION: Example showing how to create multiple implementations of the same intrinsic in different modules. Each implementation can have different behavior for backends that don't override the intrinsic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/intrinsics.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nconst unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}\n\nmod foo {\n    #[rustc_intrinsic]\n    const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {\n        panic!(\"noisy const dealloc\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of doc(inline) with Anonymous Import in Rust\nDESCRIPTION: Shows erroneous code where doc(inline) attribute is incorrectly used with an anonymous import. This combination is not allowed as anonymous imports are always rendered with doc(no_inline).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0780.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[doc(inline)] // error: invalid doc argument\npub use foo::Foo as _;\n```\n\n----------------------------------------\n\nTITLE: Printing Debug Representation of a Tree in C\nDESCRIPTION: This function call prints a debug representation of a tree structure in C. It's useful for inspecting complex data structures during debugging of libgccjit-related code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging-libgccjit.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ndebug_tree(expr);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Async Functions in Traits (Rust)\nDESCRIPTION: This code snippet shows examples of async functions in traits, which are currently not supported in Rust. It illustrates both static and instance methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0706.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    // Neither case is currently supported.\n    async fn foo() {}\n    async fn bar(&self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for MIPS R6 Build\nDESCRIPTION: Configures environment variables to use the libc backend for rustix and specify OpenSSL paths for the MIPS R6 target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nexport RUSTFLAGS=\"--cfg rustix_use_libc\"\n\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_DIR=\"/var/ab/cross-root/mips64r6el/usr\"\n\n# Alternative for Debian:\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_LIB_DIR=\"/usr/lib/mipsisa64r6el-linux-gnuabi64/\"\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_INCLUDE_DIR=\"/usr/include\"\n```\n\n----------------------------------------\n\nTITLE: Converting an Into Method Call to a From Call in Rust\nDESCRIPTION: Shows how to transform a method-style .into() call into a fully qualified From::from() call. This preserves the same type conversion behavior while changing the calling style.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_73\n\nLANGUAGE: rust\nCODE:\n```\n//- minicore: from\nstruct B;\nimpl From<i32> for B {\n    fn from(a: i32) -> Self {\n       B\n    }\n}\n\nfn main() -> () {\n    let a = 3;\n    let b: B = a.in┃to();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct B;\nimpl From<i32> for B {\n    fn from(a: i32) -> Self {\n       B\n    }\n}\n\nfn main() -> () {\n    let a = 3;\n    let b: B = B::from(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Windows GNU Target Triples in Markdown\nDESCRIPTION: Defines the available target triples for Windows GNU in Rust, specifying their tier status. This includes both 32-bit and 64-bit architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/windows-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `i686-pc-windows-gnu`: Tier 2\n- `x86_64-pc-windows-gnu`: Tier 1\n```\n\n----------------------------------------\n\nTITLE: Valid SIMD Tuple Struct Implementation\nDESCRIPTION: Correct implementation of a SIMD tuple struct using a machine type (u32). This example properly uses the #[repr(simd)] attribute with an array of unsigned 32-bit integers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0077.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good([u32; 4]); // ok!\n```\n\n----------------------------------------\n\nTITLE: Enabling Code Coverage in Rust\nDESCRIPTION: Enables instrumentation-based code coverage support. Note that the profile data format may change and might not work with coverage tools other than those built and shipped with the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Specifying Nightly Toolchain in Cargo.toml\nDESCRIPTION: This snippet demonstrates how to specify the nightly toolchain required for `clippy-utils`.  It indicates that the crate is guaranteed to build with a specific nightly version. The version is determined with rustc and can be added to the `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/clippy_utils/README.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nclippy_utils = \"0.1.XY\"\n```\n\n----------------------------------------\n\nTITLE: Running Custom LLVM Workflow\nDESCRIPTION: Command to execute a specific LLVM workflow using environment variables and the Docker run script\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/docker/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nDOCKER_SCRIPT=x86_64-gnu-llvm3.sh ./src/ci/docker/run.sh x86_64-gnu-llvm-19\n```\n\n----------------------------------------\n\nTITLE: Creating a Git Release Tag for Rustfmt\nDESCRIPTION: A shell command for creating a signed Git tag for a rustfmt release. This command creates a tag with the version number prefixed with 'v' and includes a release message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Processes.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngit tag -s v1.2.3 -m \"Release 1.2.3\"\n```\n\n----------------------------------------\n\nTITLE: Building Rust Documentation\nDESCRIPTION: Command for building Rust's documentation using x.py.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n./x.py doc\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unintended Side Effects of Representation Attributes in Rust\nDESCRIPTION: This code snippet illustrates potential unintended consequences when introducing additional structs to accommodate multiple representation attributes. The resulting representations may not be equivalent, which can affect the ABI.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0692.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\nstruct Grams(f32);\n\n#[repr(C)]\nstruct Float(f32);\n\n#[repr(transparent)]\nstruct Grams2(Float); // this is not equivalent to `Grams` above\n```\n\n----------------------------------------\n\nTITLE: Using a Newtype Wrapper in Rust\nDESCRIPTION: This code demonstrates another way to resolve the E0118 error by wrapping the generic type `T` in a newtype struct `TypeWrapper`. This allows defining an inherent implementation for the `TypeWrapper` struct, which is a valid nominal type. The `get_state` function is then defined for the `TypeWrapper` struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0118.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct TypeWrapper<T>(T);\n\nimpl<T> TypeWrapper<T> {\n    fn get_state(&self) -> String {\n        \"Fascinating!\".to_owned()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Crate Name via Command Line in rustdoc\nDESCRIPTION: This snippet shows how to specify a custom crate name while running rustdoc, which affects the output HTML structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --crate-name docs\n```\n\n----------------------------------------\n\nTITLE: Recursive Mode Ignored Dependencies - TOML\nDESCRIPTION: Example configuration in a TOML file for using the recursive mode in cargo lintcheck, specifying slow dependencies to be ignored during the lint check.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[crates]\ncargo = {name = \"cargo\", versions = ['0.64.0']}\n\n[recursive]\nignore = [\n    \"unicode-normalization\",\n]\n```\n\n----------------------------------------\n\nTITLE: Function Subtyping Relationship Example\nDESCRIPTION: Text representation showing subtyping relationship between static and placeholder lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nfn(&'static u32) <: for<'a> fn(&'a u32)\n----------------    -------------------\nthe type of `foo`   the type `bar` expects\n```\n\n----------------------------------------\n\nTITLE: Creating xwin-lld-link Script for Cross-Compilation\nDESCRIPTION: This bash script sets up the environment for using lld-link with the Windows SDK for cross-compilation. It specifies the paths to the necessary libraries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/win7-windows-msvc.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/usr/bin/env bash\nset -e\nXWIN=/path/to/winsdk\nlld-link \"$@\" /libpath:$XWIN/crt/lib/x86_64 /libpath:$XWIN/sdk/lib/um/x86_64 /libpath:$XWIN/sdk/lib/ucrt/x86_64\n```\n\n----------------------------------------\n\nTITLE: Configuring Branch Protection for AArch64 in Rust\nDESCRIPTION: Example of how to enable branch protection features for AArch64 architectures in Rust. This snippet demonstrates the syntax for enabling pointer authentication for all functions and branch target identification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/branch-protection.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Z branch-protection=bti,pac-ret,leaf\n```\n\n----------------------------------------\n\nTITLE: Running Rustdoc GUI Tests in Non-Headless Mode\nDESCRIPTION: Command to run rustdoc GUI tests with a visible browser window, which can be helpful for debugging user interface interactions\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/rustdoc-gui/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./x.py test tests/rustdoc-gui --stage 1 --test-args --no-headless\n```\n\n----------------------------------------\n\nTITLE: Defining fastcall Functions in Rust\nDESCRIPTION: This snippet presents function definitions for the fastcall calling convention, which optimizes the calling of functions by using registers for the first few arguments. It includes several variations of function signatures. No external dependencies are needed beyond the Rust environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-import-name-type/output.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_undecorated(7)\nfastcall_fn_undecorated2(17)\nfallback_fn_noprefix(8)\nfallback_fn_decorated(9)\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Pull to Only Fast-Forward\nDESCRIPTION: Sets a local configuration option for the current repository to make `git pull` default to the `--ff-only` behavior. This prevents `git pull` from creating merge commits automatically.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ngit config pull.ff only\n```\n\n----------------------------------------\n\nTITLE: Verifying Custom Rustdoc Themes (Bash)\nDESCRIPTION: This snippet illustrates the use of the --check-theme flag to verify a custom theme against the default 'light' theme. This operation discards all other flags and only performs the CSS rule comparison.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc --check-theme /path/to/your/custom-theme.css\n```\n\n----------------------------------------\n\nTITLE: Linking to Rust Team Repository in Markdown\nDESCRIPTION: This snippet shows how to create a Markdown link to the rust-lang/team repository. It uses a reference-style link format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/arm.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n[rust-lang/team]: https://github.com/rust-lang/team\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee on Enum Type\nDESCRIPTION: Example showing error when attempting to derive CoercePointee on an enum instead of a struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\nenum NotStruct<'a, T: ?Sized> {\n    Variant(&'a T),\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Formatting for Generic Types with Line Breaks in Rust\nDESCRIPTION: This snippet illustrates an alternative way to break lines in generic types, which is less preferred due to reduced readability. It shows the `Baz` type being split across multiple lines within the `Foo` type definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/types.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"Foo<Bar, Baz<\n    Type1,\n    Type2,\n>>\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Closure and Async Block Behavior with Opaque Types\nDESCRIPTION: These examples highlight the difference in behavior between closures and async blocks when dealing with opaque types and lifetimes. The closure case is rejected due to the hidden type definition occurring inside the closure, while the async block case is accepted as the definition happens in the parent function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x> = impl Sized + 'x;\nfn test<'a>() -> impl FnOnce() -> Opaque<'a> {\n    // Output type of the closure is Opaque<'a>\n    // -> hidden type definition happens *inside* the closure\n    // -> rejected.\n    move || {}\n    //~^ ERROR expected generic lifetime parameter, found `'_`\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\ntype Opaque<'x> = impl Sized + 'x;\nfn test<'a>() -> impl Future<Output = Opaque<'a>> {\n    // Output type of the async block is unit `()`\n    // -> hidden type definition happens in the parent fn\n    // -> accepted.\n    async move {}\n}\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_3 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_3` function, passing a floating-point number (3.5) as an argument in Rust. It illustrates a function call with a single floating-point parameter with the `fastcall` calling convention.  The outcome depends on the inner workings of the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_3(3.5)\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee without Generic Type Parameter\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct without generic type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\n#[repr(transparent)]\nstruct NoGeneric<'a>(&'a u8);\n```\n\n----------------------------------------\n\nTITLE: Installing Cranelift Codegen Backend via Rustup\nDESCRIPTION: Command to install the Cranelift codegen backend component using Rustup on the nightly toolchain. This is available for Linux and x86_64 macOS platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustup component add rustc-codegen-cranelift-preview --toolchain nightly\n```\n\n----------------------------------------\n\nTITLE: Correcting Specialization in Rust (Rust)\nDESCRIPTION: This Rust code snippet provides a corrected version of trait specialization implementation. It correctly marks all necessary trait methods as default in earlier implementations, allowing subsequent specializations to safely override them. This resolves the issue of specialization conflicts by ensuring that overridden methods are appropriately defined as defaults in parent implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0520.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(specialization)]\n\ntrait SpaceLlama {\n    fn fly(&self);\n}\n\n// applies to all T\nimpl<T> SpaceLlama for T {\n    default fn fly(&self) {} // This is a parent implementation.\n}\n\n// applies to all `Clone` T; overrides the previous impl\nimpl<T: Clone> SpaceLlama for T {\n    default fn fly(&self) {} // This is a parent implementation but was\n                             // previously not a default one, causing the error\n}\n\n// applies to i32, overrides the previous two impls\nimpl SpaceLlama for i32 {\n    fn fly(&self) {} // And now that's ok!\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Targets for Unikraft in Rust\nDESCRIPTION: This snippet configures the build system to include the Unikraft target `x86_64-unikraft-linux-musl`. It is necessary to do this in order to compile Rust programs that will run on Unikraft environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unikraft-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\"[build]\\nbuild-stage = 1\\ntarget = [\\\"x86_64-unikraft-linux-musl\\\"]\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Transmute Between Different Sized Types\nDESCRIPTION: Demonstrates an erroneous attempt to transmute between u16 and u8 with different memory sizes, which will cause a compile-time error in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0512.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n    // error: cannot transmute between types of different sizes,\n    //        or dependently-sized types\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Type Inference with Full Type Annotation in Rust\nDESCRIPTION: This snippet demonstrates how to resolve the E0283 error by providing a full type annotation for the variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\n----------------------------------------\n\nTITLE: Enabling `missing_doc_code_examples` lint\nDESCRIPTION: This Rust snippet demonstrates how to enable the `missing_doc_code_examples` lint, which warns if an item lacks a code example in its documentation. This lint only works on nightly builds and requires the `rustdoc::missing_doc_code_examples` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore (nightly)\n#![deny(rustdoc::missing_doc_code_examples)]\n```\n```\n\n----------------------------------------\n\nTITLE: Committing Version Changes - Bash\nDESCRIPTION: After bumping the version, this command commits the changes made to the `Cargo.toml` files. It includes a message indicating the new Clippy version. The `XY` placeholder should be replaced with the actual version number.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -m \"Bump Clippy version -> 0.1.XY\" **/*Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Fixing E0621: Matching Lifetimes in Function Signature\nDESCRIPTION: This code snippet demonstrates one way to resolve the E0621 error by modifying the function signature to correctly reflect the lifetime of borrowed data being returned. Here, the lifetime of `y` is changed to `'a`, indicating that the function might return data borrowed from either `x` or `y` with the same lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0621.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n    if x > y { x } else { y }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring a Query in Rust Compiler using rustc_queries! Macro\nDESCRIPTION: Shows how to declare a query using the rustc_queries! macro. The example defines a 'type_of' query with its key type, return type, caching behavior, and user-facing description.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nrustc_queries! {\n    /// Records the type of every item.\n    query type_of(key: DefId) -> Ty<'tcx> {\n        cache_on_disk_if { key.is_local() }\n        desc { |tcx| \"computing the type of `{}`\", tcx.def_path_str(key) }\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Command Wrappers in Rust Run Make Support\nDESCRIPTION: Custom wrapper classes around std::process::Command and std::process::Output to provide more convenient command execution and output handling with added safety and convenience methods\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/run-make-support/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// Custom Command wrapper with added methods\nstruct Command {\n    // Implementation details\n    set_stdin(),\n    run(),\n    run_fail()\n}\n\n// Custom CompletedProcess wrapper\nstruct CompletedProcess {\n    // Added convenience methods\n    stderr_utf8(),\n    stdout_utf8(),\n    status(),\n    assert_stderr_equals(),\n    assert_stdout_contains()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling C code for Rust binary dependency\nDESCRIPTION: This snippet shows how to compile C code with ThinLTO enabled for use as a dependency in a Rust binary. It uses `clang` to compile the C code with the `-flto=thin` flag, creates an object file, and specifies optimization level 2 (`-O2`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n\"clang ./clib.c -flto=thin -c -o ./clib.o -O2\"\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation Example in Rust\nDESCRIPTION: Fixed version of the previous example showing how to properly implement the Foo trait for i32 type, allowing it to be used in the generic function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0277.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: MyStruct Type Alias with Generic Argument\nDESCRIPTION: Shows a simple example of creating a type alias with a concrete type parameter, demonstrating how generic structs are instantiated with specific types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/generic_arguments.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct<T>(T);\ntype Foo = MyStruct<u32>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference Failure in Rust\nDESCRIPTION: This code snippet shows an example that triggers the E0283 error due to ambiguous type inference when using the collect() method on an iterator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"hello\".chars().rev().collect();\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Opaque Types in Rust Traits\nDESCRIPTION: This snippet illustrates how to define associated opaque types within a trait implementation. It shows a trait `Baz` with an associated type `Foo`, and an implementation for `Quux` where `Foo` is defined as an opaque type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-type-alias-impl-trait.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Baz {\n    type Foo;\n    fn foo() -> Self::Foo;\n}\n\nstruct Quux;\n\nimpl Baz for Quux {\n    type Foo = impl Bar;\n    fn foo() -> Self::Foo { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Separate Trait Implementation and Method Definition in Rust\nDESCRIPTION: This example shows how to correctly implement a trait method 'a' and define a separate method 'b' for the struct 'Bar' without including it in the trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0407.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Generated PTX Assembly for Rust Functions\nDESCRIPTION: Shows the PTX assembly output generated by the Rust compiler for both global and device functions. Global functions use the .visible .entry directive, while device functions use the .visible .func directive.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-ptx.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n//\n// Generated by LLVM NVPTX Back-End\n//\n\n.version 3.2\n.target sm_20\n.address_size 64\n\n        // .globl       _ZN6kernel15global_function17h46111ebe6516b382E\n\n.visible .entry _ZN6kernel15global_function17h46111ebe6516b382E()\n{\n\n\n        ret;\n}\n\n        // .globl       _ZN6kernel15device_function17hd6a0e4993bbf3f78E\n.visible .func _ZN6kernel15device_function17hd6a0e4993bbf3f78E()\n{\n\n\n        ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Public Function in a Rust Example\nDESCRIPTION: Example showing how to call a documented function from an example file. Rustdoc will scrape this usage and include it in the documentation for the called function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/scrape-examples-help.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// examples/ex.rs\nfn main() {\n  a_crate::a_func();\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Moving Reference Inside Method in Rust\nDESCRIPTION: This code snippet shows the correct way to implement a method that uses references by moving the reference inside the method signature, rather than implementing on the reference type directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0390.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar(&self, other: &Self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Miri on CI with Rustup\nDESCRIPTION: This snippet shows how to install a nightly toolchain with the Miri component in a CI environment. It then overrides the toolchain to use nightly and runs the tests using `cargo miri test`. This ensures Miri is set up and used correctly within the CI pipeline.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n\"rustup toolchain install nightly --component miri\nrustup override set nightly\n\ncargo miri test\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of RPITIT with `Deref`\nDESCRIPTION: This Rust code demonstrates a simple use case of RPITIT with the `Deref` trait.  It defines a trait `Foo` with a method `bar` that returns `impl Deref<Target = impl Sized>`. The example showcases nested RPITITs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(return_position_impl_trait_in_trait)]\n\nuse std::ops::Deref;\n\ntrait Foo {\n    fn bar() -> impl Deref<Target = impl Sized>;\n             // ^- RPITIT ?0        ^- RPITIT ?1\n}\n\nimpl Foo for () {\n    fn bar() -> Box<String> { Box::new(String::new()) }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Explicit ABI Requirements in Rust Extern Functions\nDESCRIPTION: Example showing how the explicit_extern_abis feature affects extern function declarations. It demonstrates both invalid (without explicit ABI) and valid (with explicit ABI) syntax. The feature requires explicit ABI specification like 'C' or 'aapcs' instead of allowing implicit defaults.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/explicit-extern-abis.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(explicit_extern_abis)]\n\nextern fn function1() {}  // ERROR `extern` declarations without an explicit ABI\n                          // are disallowed\n\nextern \"C\" fn function2() {} // compiles\n\nextern \"aapcs\" fn function3() {} // compiles\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unterminated Byte String Error in Rust\nDESCRIPTION: This code snippet shows an erroneous example of an unterminated byte string in Rust, which will result in a compilation error (E0766).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0766.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet s = b\"; // error!\n```\n\n----------------------------------------\n\nTITLE: Ordering of Imports\nDESCRIPTION: This code example illustrates the proper organization of module declarations and imports in Rust to enhance code readability and maintainability for contributors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nmod x;\nmod y;\n\n// First std.\nuse std::{ ... }\n\n// Second, external crates...\nuse crate_foo::{ ... }\nuse crate_bar::{ ... }\n\n// Then current crate.\nuse crate::{}\n\n// Finally, parent and child modules...\nuse super::{}\n\n// Re-exports are treated as item definitions...\n```\n\n----------------------------------------\n\nTITLE: Configuring cognitive-complexity-threshold\nDESCRIPTION: Sets the maximum allowed cognitive complexity for a function.  Functions exceeding this threshold will trigger a lint warning.  Defaults to 25. This helps to keep function complexity manageable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Running Stack Buffer Overflow Example with ASan (Shell)\nDESCRIPTION: This command sequence compiles and runs the stack buffer overflow example with AddressSanitizer enabled via `RUSTFLAGS`. The output shows the ASan error report identifying the stack-buffer-overflow, including the location and details about the memory access.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\nLANGUAGE: Shell\nCODE:\n```\n==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\nREAD of size 4 at 0x7ffe400e6250 thread T0\n    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n    ...\n\nAddress 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n\n  This frame has 1 object(s):\n    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\nShadow bytes around the buggy address:\n  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==37882==ABORTING\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Traversal Optimization - Rust\nDESCRIPTION: This snippet discusses optimizations for traversing syntax trees by replacing `Arc` with `Rc` for non-thread-safe operations, thereby reducing atomic operations during traversal. It describes alternative methods to maintain thread safety and memory efficiency while dealing with `SyntaxNode` instances.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// To get rid of atomics, `rowan` uses non thread-safe `Rc`.\n// This is OK because trees traversals mostly run on a single thread.\n// Sending a `SyntaxNode` to another thread requires sending a pair of **root**`GreenNode` and a `Range<usize>`.\n// Another thread can restore the `SyntaxNode` by traversing from the root.\n```\n\n----------------------------------------\n\nTITLE: Specifying Minimum Supported Rust Version in Cargo.toml\nDESCRIPTION: Demonstrates how to set the minimum rust version in a project's configuration file using the rust-version key\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\nrust-version = \"1.30\"\n```\n\n----------------------------------------\n\nTITLE: Target Triple Definition for PowerPC64 AIX\nDESCRIPTION: Defines the target triple identifier for PowerPC64 IBM AIX platform in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aix.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\npowerpc64-ibm-aix\n```\n\n----------------------------------------\n\nTITLE: Modifying CI Jobs Configuration in YAML\nDESCRIPTION: Example showing how to modify the PR section of jobs.yml to include additional CI jobs, specifically adding x86_64-msvc Windows testing configuration. Demonstrates proper YAML structure and inheritance using anchors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ci.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npr:\n  ...\n  - image: x86_64-gnu-tools\n    <<: *job-linux-16c\n  # this item was copied from the `auto` section\n  # vvvvvvvvvvvvvvvvvv\n  - image: x86_64-msvc\n    env:\n      RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n      SCRIPT: make ci-msvc\n    <<: *job-windows-8c\n```\n\n----------------------------------------\n\nTITLE: Building Rust in Docker\nDESCRIPTION: This snippet builds the Rust compiler inside a Docker container using specific configuration options tailored for the environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth=1 https://github.com/EnzymeAD/rust.git\ncd rust\n./configure --enable-llvm-link-shared --enable-llvm-plugins --enable-llvm-enzyme --release-channel=nightly --enable-llvm-assertions --enable-clang --enable-lld --enable-option-checking --enable-ninja --disable-docs\n./x dist\n```\n\n----------------------------------------\n\nTITLE: Rust if statement compilation to MIR\nDESCRIPTION: Demonstrates how a simple `if` statement in Rust is compiled down into multiple basic blocks in MIR.  Each block represents a segment of code that executes sequentially, with conditional jumps (goto) at the end of blocks to control the execution path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_1\n\nLANGUAGE: rust,ignore\nCODE:\n```\na = 1;\nif some_variable {\n    b = 1;\n} else {\n    c = 1;\n}\nd = 1;\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer CodeLens Features in JSON\nDESCRIPTION: Controls the display and types of CodeLens in Rust files managed by rust-analyzer. Includes toggling CodeLens globally, enabling debug lenses, implementation lenses, run lenses, update test lenses, and references lenses for different Rust constructs like ADT, enum variants, methods, and traits. These lenses provide inline actionable annotations in supported editors, improving code navigation and usability. Dependencies include an editor with CodeLens support and rust-analyzer enabled. Inputs are boolean values controlling lens visibility, outputs affect in-editor code annotations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.lens.enable\": true,\n  \"rust-analyzer.lens.debug.enable\": true,\n  \"rust-analyzer.lens.implementations.enable\": true,\n  \"rust-analyzer.lens.location\": \"above_name\",\n  \"rust-analyzer.lens.references.adt.enable\": false,\n  \"rust-analyzer.lens.references.enumVariant.enable\": false,\n  \"rust-analyzer.lens.references.method.enable\": false,\n  \"rust-analyzer.lens.references.trait.enable\": false,\n  \"rust-analyzer.lens.run.enable\": true,\n  \"rust-analyzer.lens.updateTest.enable\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Result of create_some_structs Macro in Rust\nDESCRIPTION: This shows the expanded output after the create_some_structs macro is processed. The concat metavariable expressions have been replaced with the concatenated identifiers to create three distinct struct names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct FirstThing;\npub struct SecondThing;\npub struct ThirdThing;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0373 Error in Rust Async Blocks\nDESCRIPTION: This code illustrates the E0373 error occurring in the context of async blocks, where captured variables may not live long enough.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0373.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\n\nasync fn f() {\n    let v = vec![1, 2, 3i32];\n    spawn(async { //~ ERROR E0373\n        println!(\"{:?}\", v)\n    });\n}\n\nfn spawn<F: Future + Send + 'static>(future: F) {\n    unimplemented!()\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Crate Metadata Example in Rust\nDESCRIPTION: Demonstrates a code example that would trigger an invalid metadata error when attempting to use an external crate with corrupted metadata files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0786.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ::foo; // error: found invalid metadata files for crate `foo`\n```\n\n----------------------------------------\n\nTITLE: Opening Generated Documentation Automatically with Cargo\nDESCRIPTION: This snippet illustrates how to use Cargo with a flag to automatically open the generated documentation in a web browser.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo doc --open\n```\n\n----------------------------------------\n\nTITLE: Format String Completion Postfix Snippets\nDESCRIPTION: Provides postfix completions for various formatting and logging macros in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"Result {result} is {2 + 2}\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Visibility Restriction in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect way to specify visibility for a struct within a module. It results in a compile-time error E0704.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0704.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub(foo) struct Bar {\n        x: i32\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive List Type Definition Example\nDESCRIPTION: Example of a recursive type definition showing a singly-linked list structure that demonstrates the need for handling recursive types in debug info generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/debuginfo/doc.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct List {\n    value: i32,\n    tail: Option<Box<List>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Rust Library for Hexagon QuRT OS (Rust)\nDESCRIPTION: Shows a `no_std`, `no_main` Rust library designed for the Hexagon QuRT OS environment. It enables specific nightly features (`lang_items`, `asm_experimental_arch`), uses `extern \"C\"` functions for semihosting (`putchar`, `_exit`), defines a function `hello` callable from C, demonstrates Hexagon-specific inline assembly using `asm!`, includes a panic handler, and provides the required `eh_personality` lang item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n#![no_main]\n#![feature(lang_items)]\n#![feature(asm_experimental_arch)]\n\nuse core::arch::asm;\n\nextern \"C\" {\n    fn putchar(ch: i32);\n    fn _exit(code: i32) -> !;\n}\n\nfn hexagon_specific() {\n    let mut buffer = [0_u8; 128];\n\n    unsafe {\n        let mut x = &buffer;\n        asm!(\n                \"{{\\n\\t\",\n                \"  v0=vmem({addr}+#0)\\n\\t\",\n                \"  {tmp} = and({tmp}, #1)\\n\\t\",\n                \"}}\\n\\t\",\n                addr = in(reg) x,\n                tmp = out(reg) _,\n            );\n    }\n}\n\n#[no_mangle]\nextern \"C\" fn hello() -> i32 {\n    let message = \"Hello, this is Rust!\\n\";\n    for b in message.bytes() {\n        unsafe {\n            putchar(b as i32);\n        }\n    }\n    hexagon_specific();\n    0\n}\n\n#[panic_handler]\nfn panic(_panic: &core::panic::PanicInfo) -> ! {\n    unsafe {\n        _exit(1);\n    }\n}\n\n#[lang = \"eh_personality\"]\nfn rust_eh_personality() {}\n```\n\n----------------------------------------\n\nTITLE: Function Body Lowering to Position-Independent Representation (Rust)\nDESCRIPTION: This module lowers the AST of function bodies into a position-independent representation where each expression has a stable positional ID, enabling incremental analysis of functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/body.rs\n```\n\n----------------------------------------\n\nTITLE: Testing wasm32-wasip2 Target\nDESCRIPTION: This code snippet shows how to run tests for the wasm32-wasip2 target using the wasmtime binary. It is necessary to have the wasmtime binary in the PATH for testing locally.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip2.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./x.py test --target wasm32-wasip2 tests/ui\n```\n\n----------------------------------------\n\nTITLE: Enabling LSP Mode for Rust Mode in Emacs\nDESCRIPTION: This snippet adds a hook to `rust-mode-hook` in Emacs, ensuring that LSP mode is loaded automatically whenever a Rust file is opened.  This automatically starts the LSP client for rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_2\n\nLANGUAGE: Emacs Lisp\nCODE:\n```\n(add-hook 'rust-mode-hook 'lsp-deferred)\n```\n\n----------------------------------------\n\nTITLE: Import Representation in ItemTree (Rust)\nDESCRIPTION: This code defines how imports are represented in the position-independent ItemTree structure, storing them in a form that doesn't change with source code modifications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree.rs#L559-L563\n```\n\n----------------------------------------\n\nTITLE: Completion with Auto Import Example\nDESCRIPTION: Demonstrates automatic import completion for unresolved names and associated items\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pda$0\n}\n# pub mod std { pub mod marker { pub struct PhantomData { } } }\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::marker::PhantomData;\n\nfn main() {\n    PhantomData\n}\n# pub mod std { pub mod marker { pub struct PhantomData { } } }\n```\n\n----------------------------------------\n\nTITLE: Building and Running opt-dist Tool\nDESCRIPTION: The bash commands demonstrate how to build and run the `opt-dist` tool in a local environment for profile-guided optimization (PGO) and post-link binary optimization (BOLT) of the Rust compiler. It includes building the tool and executing it with specific parameters such as target, checkout, and LLVM directories.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./x build tools/opt-dist\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build/host/stage0-tools-bin/opt-dist local \\\n  --target-triple <target> \\ # select target, e.g. \"x86_64-unknown-linux-gnu\"\n  --checkout-dir <path>    \\ # path to rust checkout, e.g. \".\"\n  --llvm-dir <path>        \\ # path to built LLVM toolchain, e.g. \"/foo/bar/llvm/install\"\n  -- python3 x.py dist\n```\n\n----------------------------------------\n\nTITLE: Splitting Bool or Option Parameters into Separate Functions\nDESCRIPTION: This code demonstrates the strategy of splitting functions that have boolean or optional parameters into separate functions to simplify control flow and improve clarity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn caller_a() {\n    foo()\n}\n\nfn caller_b() {\n    foo_with_bar(Bar::new())\n}\n\nfn foo() { ... }\nfn foo_with_bar(bar: Bar) { ... }\n\n// BAD\nfn caller_a() {\n    foo(None)\n}\n\nfn caller_b() {\n    foo(Some(Bar::new()))\n}\n\nfn foo(bar: Option<Bar>) { ... }\n```\n\n----------------------------------------\n\nTITLE: Checking LLVM IR with Opt Tool\nDESCRIPTION: Command to validate LLVM IR using opt tool with Enzyme pass plugin\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n<path/to/opt> out.ll -load-pass-plugin=/path/to/llvmenzyme-19.so -passes=\"enzyme\" -s\n```\n\n----------------------------------------\n\nTITLE: Programmatic Type Creation\nDESCRIPTION: Example of creating a slice type programmatically using Ty::new methods\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_middle::ty::Ty;\n// assume we have access to a LateContext\nlet ty = Ty::new_slice(cx.tcx, Ty::new_u8());\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies in TOML\nDESCRIPTION: This snippet illustrates how to specify crate dependencies in a Cargo.toml file. It adheres to the convention of placing dependency tables on the same line if they fit, otherwise separating them into key-value pairs for clarity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/cargo.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ncrate1 = { path = \"crate1\", version = \"1.2.3\" }\n\n[dependencies.extremely_long_crate_name_goes_here]\npath = \"extremely_long_path_name_goes_right_here\"\nversion = \"4.5.6\"\n```\n\n----------------------------------------\n\nTITLE: Handling Whitespace Characters in Rust\nDESCRIPTION: This snippet depicts how to declare whitespace characters such as newline (`\\n`) within Rust source code. It demonstrates whitespace string literals for purposes like parsing or formatting. Dependencies require standard Rust syntax. The input is a newline character, and the output or usage depends on further code context not provided.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/raw_strings.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nWHITESPACE \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Where Clause Formatting in Rust\nDESCRIPTION: Demonstrates how to format multi-line `where` clauses in Rust, including breaking before each `+` sign and block-indenting the continuation lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T: ?Sized, Idx> IndexRanges<Idx> for T\nwhere\n    T: Index<Range<Idx>, Output = Self::Output>\n        + Index<RangeTo<Idx>, Output = Self::Output>\n        + Index<RangeFrom<Idx>, Output = Self::Output>\n        + Index<RangeInclusive<Idx>, Output = Self::Output>\n        + Index<RangeToInclusive<Idx>, Output = Self::Output>\n        + Index<RangeFull>,\n```\n\n----------------------------------------\n\nTITLE: Hiding Portions of Code in Rust Doctests\nDESCRIPTION: This code snippet illustrates how to use the # character in Rust documentation testing to hide certain lines of code that are necessary for execution but distracting to the reader. Inputs are Rust code blocks, and the output is a cleaner compiled display of the relevant code lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n/// /// Some documentation.\n/// # fn foo() {} // this function will be hidden\n/// println!(\"Hello, World!\");\n/// ```\n# fn f() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = 6;\nprintln!(\"{}\", x + y);\n```\n\n----------------------------------------\n\nTITLE: Incomplete Byte Literal Syntax Error in Rust\nDESCRIPTION: Demonstrates a compilation error caused by an unclosed byte literal. The error occurs when a byte literal starts with 'b'' but is not properly terminated with a matching closing single quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nBYTE \"b'\"\n```\n\n----------------------------------------\n\nTITLE: Correct Break with Value in Loop Statement (Rust)\nDESCRIPTION: This code example shows the correct way to use a break statement with a value in Rust by using a loop statement instead of while, for, or while let loops.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0571.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# let mut i = 1;\n# fn satisfied(n: usize) -> bool { n % 23 == 0 }\nlet result = loop { // This is now a \"loop\" loop.\n    if satisfied(i) {\n        break 2 * i; // ok!\n    }\n    i += 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Using `Rc` and `RefCell` for Shared Mutable Access\nDESCRIPTION: This code snippet demonstrates how to use `Rc` and `RefCell` to allow multiple closures to access and modify the same data. `Rc` provides shared ownership, while `RefCell` enables interior mutability, allowing modification of the wrapped value even when there are immutable references to the `RefCell`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0524.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nfn set(x: &mut isize) {\n    *x += 4;\n}\n\nfn dragoooon(x: &mut isize) {\n    let x = Rc::new(RefCell::new(x));\n    let y = Rc::clone(&x);\n    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n\n    c2();\n    c1();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Query Definition Structure in Rust Compiler\nDESCRIPTION: Illustrates the structural components of a query definition including the query keyword, name, key type, result type, and query modifiers. This shows the syntax for defining queries in the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nquery type_of(key: DefId) -> Ty<'tcx> { ... }\n^^^^^ ^^^^^^^      ^^^^^     ^^^^^^^^   ^^^\n|     |            |         |          |\n|     |            |         |          query modifiers\n|     |            |         result type\n|     |            query key type\n|     name of query\nquery keyword\n```\n\n----------------------------------------\n\nTITLE: Removing a feature gate in Rust\nDESCRIPTION: This code snippet demonstrates how to remove a feature gate by modifying the declaration in the `unstable.rs` and adding a corresponding entry in the `removed.rs` file. It includes the necessary declarations for both the removal process and the reason for the removal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/feature-gates.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"/// description of feature\\n(unstable, $feature_name, \\\"$version\\\", Some($tracking_issue_number))\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"/// description of feature\\n(removed, $old_feature_name, \\\"$version\\\", Some($tracking_issue_number),\\n Some(\\\"$why_it_was_removed\\\"))\"\n```\n\n----------------------------------------\n\nTITLE: Running remote-test-server\nDESCRIPTION: This command starts the `remote-test-server` on the remote machine, binding it to the specified IP address and port. The `-v` flag enables verbose output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n\n$ ./remote-test-server -v --bind 0.0.0.0:12345\nstarting test server\nlistening on 0.0.0.0:12345!\n\n```\n\n----------------------------------------\n\nTITLE: Setting Cross-Compilation Toolchain Path\nDESCRIPTION: Sets an environment variable to specify the path to the cross-compilation toolchain for MIPS R6.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nexport CROSS_COMPILE=\"/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Tab Spaces in Rust\nDESCRIPTION: Demonstrates the 'tab_spaces' option, which sets the number of spaces per tab. The default is 4 spaces, but it can be changed to any positive integer (e.g., 2).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_70\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {\n    let ipsum = dolor();\n    let sit = vec![\n        \"amet consectetur adipiscing elit amet\",\n        \"consectetur adipiscing elit amet consectetur.\",\n    ];\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {\n  let ipsum = dolor();\n  let sit = vec![\n    \"amet consectetur adipiscing elit amet\",\n    \"consectetur adipiscing elit amet consectetur.\",\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for WALI Linker (TOML)\nDESCRIPTION: This snippet describes how to configure the Cargo build tool for linking WALI programs using the LLVM linker. It displays a sample `config.toml` for Cargo where the linker path is directed to lld in the LLVM build within the WALI repo. This setup is necessary for compatibility with the WALI toolchain until LLVM updates are fully integrated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wali-linux.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.wasm32-wali-linux-musl]\nlinker = \"<WALI>/llvm-project/build/bin/lld\"\n```\n\n----------------------------------------\n\nTITLE: Customizing Semantic Token Styling for Specific Themes (JSON)\nDESCRIPTION: This snippet demonstrates how to customize semantic token styling for specific VS Code themes. It overrides the default styling for the `operator.unsafe` token within the \"Ayu Light\" theme.  Requires VS Code and the Rust extension. The output applies the specified color to unsafe operators only within the selected theme. The configuration is applied in settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n   \"editor.semanticTokenColorCustomizations\": {\n         \"rules\": {\n             \"operator.unsafe\": \"#ff6600\"\n         },\n         \"[Ayu Light]\": {\n            \"rules\": {\n               \"operator.unsafe\": \"#572300\"\n            }\n         }\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Usage Commands for CG_CLIF Build System in Bash\nDESCRIPTION: This snippet outlines the main commands available in the cg_clif build system, including prepare, build, test, abi-cafe, and bench. Each command supports various options for customizing the build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/build_system/usage.txt#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./y.sh prepare [--out-dir DIR] [--download-dir DIR]\n./y.sh build [--sysroot none|clif|llvm] [--out-dir DIR] [--download-dir DIR] [--no-unstable-features] [--frozen]\n./y.sh test [--sysroot none|clif|llvm] [--out-dir DIR] [--download-dir DIR] [--no-unstable-features] [--frozen] [--skip-test TESTNAME]\n./y.sh abi-cafe [--sysroot none|clif|llvm] [--out-dir DIR] [--download-dir DIR] [--no-unstable-features] [--frozen]\n./y.sh bench [--sysroot none|clif|llvm] [--out-dir DIR] [--download-dir DIR] [--no-unstable-features] [--frozen]\n```\n\n----------------------------------------\n\nTITLE: THIR Example: Simple Addition Expression\nDESCRIPTION: Demonstrates the THIR representation of a basic arithmetic operation, showing how a simple expression is transformed into a detailed intermediate representation with type and scope information\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/thir.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 1 + 2;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nThir {\n    arms: [],\n    exprs: [\n        // Detailed THIR representation of the expression\n        Expr {\n            ty: i32,\n            temp_lifetime: Some(Node(1)),\n            span: oneplustwo.rs:2:13: 2:14 (#0),\n            kind: Literal {\n                lit: Spanned {\n                    node: Int(1, Unsuffixed),\n                    span: oneplustwo.rs:2:13: 2:14 (#0)\n                },\n                neg: false\n            }\n        },\n        // ... additional expressions ...\n    ],\n    stmts: [\n        // Statement details\n        Stmt {\n            kind: Let {\n                pattern: Pat {\n                    ty: i32,\n                    kind: Binding {\n                        name: \"x\",\n                        var: LocalVarId(...)\n                    }\n                },\n                initializer: Some(e5)\n            }\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Instrument Coverage in Rust\nDESCRIPTION: Demonstrates the usage of the '-C instrument-coverage' flag with the 'all' option. This option is currently an alias for 'yes', but may change in the future if more fine-grained coverage options are added.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n-C instrument-coverage=all\n```\n\n----------------------------------------\n\nTITLE: Auto Import Rust Feature\nDESCRIPTION: Automatic import management for Rust code with configurable grouping and prefix strategies\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nuse itertools::Itertools;\nuse syntax::ast;\n\nuse crate::utils::insert_use;\n\nuse self::auto_import;\n\nuse super::AssistContext;\n```\n\n----------------------------------------\n\nTITLE: Basic Enum Definition\nDESCRIPTION: Simple definition of an enum type with GET and POST variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0170.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Method {\n    GET,\n    POST,\n}\n```\n\n----------------------------------------\n\nTITLE: Testing remote-test-server connection\nDESCRIPTION: This command uses `netcat` to test the connection to the `remote-test-server`. It sends the `ping\\n` command and expects the response `pong`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n\n$ nc $REMOTE_IP 12345\nping\npong\n\n```\n\n----------------------------------------\n\nTITLE: Resolving Name Conflicts Using Parent Reference in Rust\nDESCRIPTION: Shows how to resolve name conflicts by using the parent module path to explicitly reference the desired function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0255.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {\n    bar::foo(); // we get the item by referring to its parent\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Target Specification JSON for a Specific Platform in Rust\nDESCRIPTION: This command demonstrates how to generate the JSON target specification for a specific target platform (WebAssembly in this example). It uses the nightly toolchain with the target flag to specify the desired platform.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/targets/custom.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Lifetime Bounds in Rust Traits\nDESCRIPTION: This code snippet demonstrates how to resolve the E0227 compiler error by providing an explicit lifetime bound in the struct definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0227.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<'foo>: 'foo {}\ntrait Bar<'bar>: 'bar {}\n\ntrait FooBar<'foo, 'bar>: Foo<'foo> + Bar<'bar> {}\n\nstruct Baz<'foo, 'bar, 'baz>\nwhere\n    'baz: 'foo + 'bar,\n{\n    obj: dyn FooBar<'foo, 'bar> + 'baz,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Passes\nDESCRIPTION: This code snippet demonstrates how the `mir_borrowck` query is executed on all functions of a crate. The codegen backend invokes `collect_and_partition_mono_items`, which recursively requests the `optimized_mir` for all reachable functions, which in turn runs `mir_borrowck` for that function and then creates codegen units. This ensures that unreachable functions still have their errors emitted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/overview.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\n[passes]: https://github.com/rust-lang/rust/blob/e69c7306e2be08939d95f14229e3f96566fb206c/compiler/rustc_interface/src/passes.rs#L791\n\n```\n\n----------------------------------------\n\nTITLE: Passing Configuration Flags\nDESCRIPTION: This code snippet demonstrates how to use the `--cfg` flag to pass configuration flags to rustdoc, similar to `rustc --cfg`.  This allows conditional compilation based on feature flags or other configuration options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --cfg feature=\"foo\"\n```\n\n----------------------------------------\n\nTITLE: Executing Fake Linker Command in Rust Build\nDESCRIPTION: Shows the command executed by the Rust compiler (`rustc`) attempting to link an executable using './fake-linker'. It details the various object files (some omitted), static/dynamic libraries, linker flags (`-m64`, `-Wl,--as-needed`, `-pie`, `-lgcc_s`, etc.), library paths (`-L`), and the output file (`-o main`). The command resulted in an exit status of 1 and a specific error message 'baz'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/linker-warning/short-error.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n\"./fake-linker\" \"-m64\" \"/symbols.o\" \"<2 object files omitted>\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libstd-*,libpanic_unwind-*,libobject-*,libmemchr-*,libaddr2line-*,libgimli-*,librustc_demangle-*,libstd_detect-*,libhashbrown-*,librustc_std_workspace_alloc-*,libminiz_oxide-*,libadler2-*,libunwind-*,libcfg_if-*,liblibc-*,liballoc-*,librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-Wl,-Bdynamic\" \"-lgcc_s\" \"-lutil\" \"-lrt\" \"-lpthread\" \"-lm\" \"-ldl\" \"-lc\" \"-L\" \"/raw-dylibs\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"/build-root/test/run-make/linker-warning/rmake_out\" \"-L\" \"<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"main\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n```\n\n----------------------------------------\n\nTITLE: Defining RecursiveMemoryLayoutNode Interface in TypeScript\nDESCRIPTION: TypeScript interface for nodes in the recursive memory layout tree. Each node represents an item in a data type, containing information about size, alignment, offset, and relationships to other nodes in the hierarchy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RecursiveMemoryLayoutNode = {\n    /// Name of the item, or [ROOT], `.n` for tuples\n    item_name: string;\n    /// Full name of the type (type aliases are ignored)\n    typename: string;\n    /// Size of the type in bytes\n    size: number;\n    /// Alignment of the type in bytes\n    alignment: number;\n    /// Offset of the type relative to its parent (or 0 if its the root)\n    offset: number;\n    /// Index of the node's parent (or -1 if its the root)\n    parent_idx: number;\n    /// Index of the node's children (or -1 if it does not have children)\n    children_start: number;\n    /// Number of child nodes (unspecified it does not have children)\n    children_len: number;\n};\n\nexport interface RecursiveMemoryLayout = {\n    nodes: RecursiveMemoryLayoutNode[];\n};\n```\n\n----------------------------------------\n\nTITLE: Running Entire Test Suite\nDESCRIPTION: This command allows running all tests within the Miri test suite, again with the option to specify a target architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n./miri test\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./miri test --target i686-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Erroneous Yield Usage in Async Block (Rust)\nDESCRIPTION: This code snippet demonstrates the incorrect use of `yield` within an `async` block, which is not supported and results in a compilation error (E0727).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0727.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coroutines, stmt_expr_attributes)]\n\nfn main() {\n    let coroutine = #[coroutine] || {\n        async {\n            yield;\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Running x.py Command to Check the Compiler\nDESCRIPTION: This snippet presents the command to run 'check' via the x.py build tool, ensuring that most components compile without issues. It is a quick validation step after making changes in the codebase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./x check\n```\n\n----------------------------------------\n\nTITLE: Adding LoongArch64 Targets to Rust Toolchain Configuration\nDESCRIPTION: This snippet shows how to configure the Rust build system by adding LoongArch64 targets in the `bootstrap.toml` file. It specifies the targets for stages of the build process. No additional dependencies are specified for this configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/loongarch-none.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\n  \"loongarch64-unknown-none\",\n  \"loongarch64-unknown-none-softfloat\",\n]\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Functions with Unicode Identifiers\nDESCRIPTION: Example showing how a function with Unicode characters in its module path would be defined in Rust code. This illustrates the kind of identifiers that would require Punycode encoding in mangled symbols.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nmod gödel {\n  mod escher {\n    fn bach() {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handle Opaque Type Flow\nDESCRIPTION: Mermaid flowchart showing the decision process in the handle_opaque_type function for constraint handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    subgraph typecheck[\"type check comparison routines\"]\n        equate.rs\n        sub.rs\n        lub.rs\n    end\n\n    typecheck --> TwoSimul\n\n    subgraph handleopaquetype[\"infcx.handle_opaque_type\"]\n\n        TwoSimul[\"Defining two opaque types simultaneously?\"]\n\n        TwoSimul -- Yes --> ReportError[\"Report error\"]\n\n        TwoSimul -- No --> MayDefine -- Yes --> RegisterOpaqueType --> AlreadyHasValue\n\n        MayDefine -- No --> ReportError\n\n        MayDefine[\"In defining scope OR in query?\"]\n\n        AlreadyHasValue[\"Opaque type X already has\\na registered value?\"]\n\n        AlreadyHasValue -- No --> Obligations[\"Register opaque type bounds\\nas obligations for hidden type\"]\n\n        RegisterOpaqueType[\"Register opaque type with\\nother type as value\"]\n\n        AlreadyHasValue -- Yes --> EquateOpaqueTypes[\"Equate new hidden type\\nwith old hidden type\"]\n    end\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build Targets\nDESCRIPTION: This TOML snippet specifies the target configuration for building Rust with the `aarch64-kmc-solid_asp3` target in the `rustc` build process. Ensure `aarch64-kmc-elf-gcc` is included in the system's PATH or specify an alternative toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/kmc-solid.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"aarch64-kmc-solid_asp3\"]\n```\n\n----------------------------------------\n\nTITLE: Local Dependency Configuration - TOML\nDESCRIPTION: Specifies a local dependency in a TOML file, allowing the inclusion of local repositories that are not yet published. Requires the crate's name and local path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\nclippy = {name = \"clippy\", path = \"/home/user/clippy\"}\n```\n\n----------------------------------------\n\nTITLE: Workspace Symbols Filtering in TypeScript\nDESCRIPTION: Extends workspace symbol search with optional scope and kind filtering capabilities\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ninterface WorkspaceSymbolParams {\n    searchScope?: WorkspaceSymbolSearchScope;\n    searchKind?: WorkspaceSymbolSearchKind;\n}\n\nconst enum WorkspaceSymbolSearchScope {\n    Workspace = \"workspace\",\n    WorkspaceAndDependencies = \"workspaceAndDependencies\"\n}\n\nconst enum WorkspaceSymbolSearchKind {\n    OnlyTypes = \"onlyTypes\",\n    AllSymbols = \"allSymbols\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting environment variables for cc crate on Windows\nDESCRIPTION: This snippet shows the environment variables that need to be set when using the `cc` crate with clang-cl and LLD on Windows, including setting the C and C++ compilers to clang-cl and specifying linker flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_10\n\nLANGUAGE: bat\nCODE:\n```\n\"set CC=clang-cl\\nset CXX=clang-cl\\nset CFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link\\nset CXXFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link\\nREM Needed because msvc's lib.exe crashes on LLVM LTO .obj files\\nset AR=llvm-lib\"\n```\n\n----------------------------------------\n\nTITLE: Correct Unwind Attribute Usage in Rust\nDESCRIPTION: Shows two valid ways to use the unwind attribute with different behaviors for non-Rust ABI functions. The 'aborts' option is recommended for safety\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0633.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[unwind(aborts)]    // Safer option: abort process on unwind\\n#[unwind(allowed)]  // Potentially unsafe: allow unwinding\n```\n\n----------------------------------------\n\nTITLE: Rust Type Definition Example\nDESCRIPTION: Example showing how type information is stored in memory using DefId and Substs, demonstrating why simple serialization isn't sufficient for cross-session caching\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/incremental-compilation-in-detail.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nTyKind::FnDef(DefId, &'tcx Substs<'tcx>)\n```\n\n----------------------------------------\n\nTITLE: Initializing Rust Enum with Incorrect Field Name\nDESCRIPTION: Demonstrates a compilation error when attempting to use an undefined field in an enum variant. This example shows how Rust's type system prevents incorrect field access at compile-time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0559.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Field {\n    Fool { x: u32 },\n}\n\nlet s = Field::Fool { joke: 0 };\n// error: struct variant `Field::Fool` has no field named `joke`\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of #[ffi_returns_twice] Attribute in Rust\nDESCRIPTION: This code snippet demonstrates the erroneous use of the #[ffi_returns_twice] attribute on a regular Rust function, which is not allowed. The attribute can only be used on foreign function declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0724.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_returns_twice)]\n#![crate_type = \"lib\"]\n\n#[ffi_returns_twice] // error!\npub fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript Dependencies for VSCode Extension\nDESCRIPTION: Command to install the required TypeScript dependencies for the VSCode extension. This should be run in the 'editors/code' directory of the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd editors/code\nnpm ci\n```\n\n----------------------------------------\n\nTITLE: Fluent Message Definition\nDESCRIPTION: This Fluent code snippet defines the localized message for a diagnostic. The slug `hir_analysis_field_already_declared` is followed by error messages and labels which can be used for localization purposes. It requires the associated diagnostic defined in Rust and informs the compiler on how to display errors in different locales with associated variables like `field_name`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_1\n\nLANGUAGE: fluent\nCODE:\n```\nhir_analysis_field_already_declared =\\n    field `{$field_name}` is already declared\\n    .label = field already declared\\n    .previous_decl_label = `{$field_name}` first declared here\n```\n\n----------------------------------------\n\nTITLE: Entering M68K Chroot Environment\nDESCRIPTION: Command to enter the previously created Debian/M68K chroot environment using the standard chroot command and QEMU user emulation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n# chroot /path/to/debian-68k\n```\n\n----------------------------------------\n\nTITLE: Defining stdcall Functions in Rust\nDESCRIPTION: This snippet defines functions with the stdcall calling convention, which is commonly used in Windows API functions. It includes function definitions with and without prefixes and decorations. Requires the Rust standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-import-name-type/output.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_undecorated(4)\nstdcall_fn_undecorated2(14)\nstdcall_fn_noprefix(5)\nstdcall_fn_decorated(6)\n```\n\n----------------------------------------\n\nTITLE: Unconstrained Lifetime Parameter Error Example\nDESCRIPTION: This code demonstrates an E0207 error with a lifetime parameter that is used in an associated type but is not constrained elsewhere in the implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nstruct Bar<'a>;\n\ntrait Contains {\n    type B;\n\n    fn get(&self) -> i32;\n}\n\nimpl<'a> Contains for Foo {\n    type B = Bar<'a>;\n\n    // error: the lifetime parameter `'a` is not constrained by the impl trait,\n    // self type, or predicates [E0207]\n    fn get(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Control Flow Guard in Rust\nDESCRIPTION: This flag controls whether LLVM enables the Windows Control Flow Guard security feature.  It takes values such as `y`, `yes`, `on`, `true`, `checks`, `nochecks`, `n`, `no`, `off`, or `false`.  The `nochecks` option enables metadata without runtime enforcement checks.  This flag is currently ignored for non-Windows targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Running Completion Routines (Rust)\nDESCRIPTION: This code runs a series of independent completion routines that generate completion suggestions based on different aspects of the context, combining their results into the final completion list.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/lib.rs#L157-L226\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer Workspace Discovery Command in JSON\nDESCRIPTION: Defines the workspace discovery command configuration for rust-analyzer using JSON, specifying the command to run, progress label for UI display, and file types to watch for build system integration. This setup enables rust-analyzer to automatically detect projects managed outside Cargo by executing custom commands that return project metadata.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"rust-analyzer.workspace.discoverConfig\": {\n        \"command\": [\n            \"rust-project\",\n            \"develop-json\"\n        ],\n        \"progressLabel\": \"rust-analyzer\",\n        \"filesToWatch\": [\n            \"BUCK\"\n        ]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Module-Level Import Granularity in Rust\nDESCRIPTION: Shows the imports_granularity setting set to Module, which merges imports from the same module while keeping imports from different modules separate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_52\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::b::{f, g};\nuse foo::d::e;\nuse foo::{a, b, c};\nuse qux::{h, i};\n```\n\n----------------------------------------\n\nTITLE: Rust Pattern Matching Fix - Consistent Reference Binding\nDESCRIPTION: Solution showing how to fix the binding inconsistency by using 'ref' consistently across all patterns where the variable appears.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0409.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = (0, 2);\nmatch x {\n    (0, ref y) | (ref y, 0) => { /* use y */}\n    _ => ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Guards as Alternative to Generic Parameters in Pattern Matching\nDESCRIPTION: This code snippet demonstrates the recommended alternative approach using guards in match statements when working with constants that depend on generic parameters or statics. Guards allow conditionally matching values without the compiler needing to prove exhaustiveness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0158.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    const X: char;\n}\n\nstatic FOO: char = 'j';\n\nfn test<A: Trait, const Y: char>(arg: char) {\n    match arg {\n        c if c == A::X => println!(\"A::X\"),\n        c if c == Y => println!(\"Y\"),\n        c if c == FOO => println!(\"FOO\"),\n        _ => ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Macro Expansions\nDESCRIPTION: Example of testing lint behavior with macro expansions using auxiliary crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n//@aux-build:proc_macros.rs\n\nextern crate proc_macros;\n\nfn main() {\n    proc_macros::external!{ code_that_should_trigger_your_lint }\n    proc_macros::with_span!{ span code_that_should_trigger_your_lint }\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with x\nDESCRIPTION: This command builds the stage 1 compiler and executes the entire test suite. It's not recommended for local development due to the time it takes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n./x test\n```\n\n----------------------------------------\n\nTITLE: C Wrapper for Calling Rust Library on QuRT OS (C)\nDESCRIPTION: A minimal C program providing an entry point (`main` function) for a QuRT OS application. It declares the `hello` function (expected to be defined in the linked Rust library) and calls it. This wrapper allows the Rust code, compiled as a library, to be executed within the QuRT environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nint hello();\n\nint main() {\n    hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Function Calls in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for function calls. Each argument in a multiline call is aligned as a block with consistent indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    lorem(\n        \"lorem\",\n        \"ipsum\",\n        \"dolor\",\n        \"sit\",\n        \"amet\",\n        \"consectetur\",\n        \"adipiscing\",\n        \"elit\",\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring ItemLikeMacro in Rust\nDESCRIPTION: This snippet presents a macro definition named 'ItemLikeMacro', illustrating how macros can be specified within a Rust module. The details cover the macro's ID and the declaration location for proper identification when invoked.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"ItemLikeMacro\",\n    def: Macro(\n        Macro {\n            id: Macro2Id(\n                Macro2Id(\n                    0,\n                ),\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: USE_TREE,\n            range: 727..749,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 736..749,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Force Unwind Tables in Rust\nDESCRIPTION: Forces the generation of unwind tables. Takes `y`, `yes`, `on`, `true` (force-enable) or `n`, `no`, `off`, `false` (do not force).  If unwind tables are required by the target, an error will be emitted if they're not generated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Wrapping Attributes in cfg_attr in Rust\nDESCRIPTION: Wraps an attribute into a conditional cfg_attr attribute, allowing for conditional compilation of attributes. This is useful for platform-specific or feature-dependent attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_120\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct S {\n   field: i32\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg_attr(, derive(Debug))]\nstruct S {\n   field: i32\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Implementation with Matching Lifetime Parameters\nDESCRIPTION: Example showing the correct implementation where lifetime parameters and constraints match exactly between trait declaration and implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0195.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Rust Foreign Function Declaration Using Struct Argument\nDESCRIPTION: This snippet shows the correct approach to passing multiple values in FFI by defining a struct and passing it as a parameter. This method avoids pattern destructuring in the argument list, aligning with Rust's FFI constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0130.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct SomeStruct {\n    a: u32,\n    b: u32,\n}\n\nextern \"C\" {\n    fn foo(s: SomeStruct); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Lexical Region Resolution Process in Rust\nDESCRIPTION: This snippet outlines the initial steps for lexical region resolution, where each region variable is assigned an empty value and processes each outlives constraint iteratively. It explains the concept of growing region variables until a fixed-point is achieved using a least-upper-bound relation on the region lattice.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nLexical region resolution is done by initially assigning each region variable to an empty value. We then process each outlives constraint repeatedly, growing region variables until a fixed-point is reached.\n```\n\n----------------------------------------\n\nTITLE: Formatting Float Literals in Rust\nDESCRIPTION: This snippet shows how rustfmt now wraps float literals ending in a dot ('.') with parentheses when calling methods on them. This ensures that code like `0. .to_string()` is formatted as `(0.).to_string()`, preventing potential parsing issues. This change improves the clarity and correctness of formatted Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Configuring Decimal Literal Threshold in Rust\nDESCRIPTION: This option sets the lower bound for linting decimal literals. The lint checks for large or complex literals. This impacts the `decimal_literal_representation` lint. The default value is `16384`. It expects an integer as input.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_24\n\n\n\n----------------------------------------\n\nTITLE: Importing Enum Variants\nDESCRIPTION: Example showing how to import enum variants into scope using the use statement for unqualified access.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0170.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse Method::*;\nenum Method { GET, POST }\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bootstrap.toml for Hexagon Target\nDESCRIPTION: This TOML snippet configures the `bootstrap.toml` file to build Rust with support for the Hexagon target. It defines the necessary compiler and linker tools to be used for cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-linux-musl.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"hexagon-unknown-linux-musl\"]\n\n[target.hexagon-unknown-linux-musl]\n\ncc = \"hexagon-unknown-linux-musl-clang\"\ncxx = \"hexagon-unknown-linux-musl-clang++\"\nlinker = \"hexagon-unknown-linux-musl-clang\"\nar = \"hexagon-unknown-linux-musl-ar\"\nranlib = \"hexagon-unknown-linux-musl-ranlib\"\nmusl-root = \"/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\"\nllvm-libunwind = 'in-tree'\nqemu-rootfs = \"/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\"\n```\n\n----------------------------------------\n\nTITLE: Rust HirId Conceptual Structure\nDESCRIPTION: Explanation of HirId's logical structure as a stable identifier composed of DefPath and LocalId\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/incremental-compilation-in-detail.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nHirId = (DefPath, LocalId)\n```\n\n----------------------------------------\n\nTITLE: Building ELF Binaries with std using cargo build\nDESCRIPTION: This command uses `cargo build` with the `build-std` feature flag to build ELF binaries for the `armv7-sony-vita-newlibeabihf` target, including the `std` library and using `panic_abort` for panic handling. It builds the release version of the crate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n\"cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release\"\n```\n\n----------------------------------------\n\nTITLE: Correct Late-Bound Lifetime Parameter Usage\nDESCRIPTION: Shows the correct way to use a function with late-bound lifetime parameters by omitting explicit lifetime specifications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0794.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(x: &'a str) -> &'a str { x }\nlet _ = foo;\n```\n\n----------------------------------------\n\nTITLE: Structure of a Git Merge Conflict Marker\nDESCRIPTION: Illustrates the standard markers Git inserts into a file to show conflicting changes during a rebase or merge. The section between `<<<<<<< HEAD` and `=======` is the version from the branch being rebased onto (or current branch in merge), and the section between `=======` and `>>>>>>>` is the version from the commit being applied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n<<<<<<< HEAD\nOriginal code\n=======\nYour code\n>>>>>>> 8fbf656... Commit fixes 12345\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Assertions for Rust Compiler\nDESCRIPTION: To enable debug assertions in the Rust compiler, modify the 'bootstrap.toml' configuration. This setting aids in identifying bugs but may slow down fuzzing due to additional processing required per execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/fuzzing.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\ndebug-assertions = true\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait with Generic Parameters\nDESCRIPTION: This snippet exemplifies how to implement a trait for a generic type Vec<T>. It emphasizes obtaining the type of 'Self' within the trait implementation and the use of the 'instantiate_identity' method on EarlyBinder. The Rust standard library is required for the trait and vector functionalities. The outcome is the type of 'b' which aligns with the type of the Vec<T> implementation without modification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/early_binder.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Trait for Vec<T> {\n    fn foo(&self, b: Self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using `doc_cfg_hide` to hide `doc` from `#[doc(cfg)]`\nDESCRIPTION: This Rust snippet shows how to use `doc_cfg_hide` to prevent `doc` from being displayed in the `#[doc(cfg)]` output. This is useful when `doc` is used in `#[cfg(any(...))]` and you don't want it to be shown in the documentation. It requires the `doc_cfg_hide` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(doc_cfg_hide)]\n#![doc(cfg_hide(doc))]\n```\n```\n\n----------------------------------------\n\nTITLE: Building and Running Heap Corruption Example (Debug)\nDESCRIPTION: This command demonstrates building and running the heap corruption example with debug assertions enabled, showing how the allocator detects and reports the issue.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run\n   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n     Running `target/debug/hello-rust-heap`\nfree(): invalid next size (normal)\nAborted\n```\n\n----------------------------------------\n\nTITLE: Removing Obsolete stdarch Submodule Directory\nDESCRIPTION: Removes the `src/stdarch` directory, which might be left over as an untracked directory after repository reorganizations and rebases that don't handle submodule renames correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_10\n\nLANGUAGE: console\nCODE:\n```\nrm -r src/stdarch\n```\n\n----------------------------------------\n\nTITLE: Documenting Rust Crate Abstraction\nDESCRIPTION: This snippet provides an example of how to start the front-page documentation of a Rust crate using module-level documentation comments. It showcases a simple fast and easy queue abstraction with the use of inline module and function level comments. It mentions high-level documentation benefits and references. No specific dependencies other than Rust itself. The inputs and outputs are not specified as this is a structural guideline example.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/how-to-write-documentation.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n//! Fast and easy queue abstraction.\n//!\n//! Provides an abstraction over a queue.  When the abstraction is used\n//! there are these advantages:\n//! - Fast\n//! - [`Easy`]\n//!\n//! [`Easy`]: http://thatwaseasy.example.com\n\n/// This module makes it easy.\npub mod easy {\n\n    /// Use the abstraction function to do this specific thing.\n    pub fn abstraction() {}\n\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Literal Formatting in Rust\nDESCRIPTION: Rules for formatting struct literals, including single-line and multi-line variations, spacing, and trailing commas\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nFoo { field1, field2: 0 }\nlet f = Foo {\n    field1,\n    field2: an_expr,\n};\n```\n\n----------------------------------------\n\nTITLE: Trait Return Types with Explicit Named Lifetimes\nDESCRIPTION: Implementation using explicitly named lifetime parameters to specify lifetime bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0759.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::Debug;\nfn foo<'a>(x: &'a i32) -> impl Debug + 'a {\n    x\n}\nfn bar<'a>(x: &'a i32) -> Box<dyn Debug + 'a> {\n    Box::new(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Usage of instruction_set Attribute in Rust\nDESCRIPTION: This code snippet shows an erroneous use of the `instruction_set` attribute with an unsupported argument 'intel::x64', which triggers the E0779 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0779.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(isa_attribute)]\n\n#[instruction_set(intel::x64)] // error: invalid argument\npub fn something() {}\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Tuple Structs and Variants in Rust\nDESCRIPTION: This snippet shows how to correctly use tuple structs and variants in Rust, avoiding import and typographical issues. It uses the 'use' statement correctly to ensure that the code compiles without errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0531.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Push After Rebase with Lease\nDESCRIPTION: Updates the remote branch to match the local branch after a rebase. `--force-with-lease` is safer than `--force` as it prevents overwriting remote changes if the remote branch has been updated since the last fetch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Defining Modules and Structs in Rust\nDESCRIPTION: This code defines two modules, `sub_module1` and `sub_module2`, each containing a public struct. These structs are intended to be re-exported at the crate root to simplify usage and potentially hide the underlying module structure from users.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\npub mod sub_module1 {\n    pub struct Foo;\n}\npub mod sub_module2 {\n    pub struct AnotherFoo;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Pulling Changes from rustc Repository with Bash\nDESCRIPTION: This snippet explains how to fetch and merge changes from the rustc repository into the Miri repository to keep it up to date.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\n./miri rustc-pull\n```\n\nLANGUAGE: sh\nCODE:\n```\n./miri toolchain && ./miri fmt\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit commit -am \"rustup\"\n```\n\n----------------------------------------\n\nTITLE: CMake 3.28 Jobserver Configuration\nDESCRIPTION: Demonstrates CMake 3.28's JOB_SERVER_AWARE option for proper rustc jobserver integration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/jobserver.md#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.28)\nproject(x)\nadd_custom_target(x\n    JOB_SERVER_AWARE TRUE\n    COMMAND echo 'fn main() {}' | rustc -\n)\n```\n\n----------------------------------------\n\nTITLE: Standard Quoted String Literal in Rust\nDESCRIPTION: A basic string literal with standard quotes, representing simple string text\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/strings.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"hello\"\n```\n\n----------------------------------------\n\nTITLE: Basic Cargo Configuration for s390x-unknown-linux-musl Cross-Compilation\nDESCRIPTION: Configuration for .cargo/config.toml to specify the linker for cross-compiling to s390x-unknown-linux-musl target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-musl.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.s390x-unknown-linux-musl]\nlinker = \"s390x-linux-musl-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Referencing RUSTC_BOOTSTRAP Documentation in Rust\nDESCRIPTION: This snippet provides a markdown link to the RUSTC_BOOTSTRAP documentation, which is related to feature enabling in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/allow-features.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[`RUSTC_BOOTSTRAP`]: ./rustc-bootstrap.html\n```\n\n----------------------------------------\n\nTITLE: Invalid Variadic Parameter Usage in Rust FFI\nDESCRIPTION: Example showing incorrect usage of variadic parameters with non-C ABI function, which results in error E0045.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0045.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern \"Rust\" {\n    fn foo(x: u8, ...); // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Finding name resolution experts in Rust compiler\nDESCRIPTION: This command helps identify recent contributors to the name resolution part of the Rust compiler. It uses `git shortlog` to list commit authors within the `compiler/rustc_resolve/` directory since the 1.68.2 release, excluding rollup merge commits and commits by `@bors`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/getting-started.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"git shortlog -n 1.68.2.. compiler/rustc_resolve/\"\n```\n\n----------------------------------------\n\nTITLE: Re-labeling Pull Requests in Rust\nDESCRIPTION: Use this command to update the label of a pull request in Rust's GitHub repository once merge commits have been resolved. This ensures that the PR status is accurately reflected in the review queue.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n@rustbot label -has-merge-commits\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conflicting Stability Requirements in Rust\nDESCRIPTION: This code snippet illustrates how declaring a feature with conflicting stability requirements leads to compiler error E0711. It shows stable declarations with different versions and an unstable declaration for the same feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0711.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// NOTE: this attribute is perma-unstable and should *never* be used outside of\n//       stdlib and the compiler.\n#![feature(staged_api)]\n\n#![stable(feature = \"...\", since = \"1.0.0\")]\n\n#[stable(feature = \"foo\", since = \"1.0.0\")]\nfn foo_stable_1_0_0() {}\n\n// error: feature `foo` is declared stable since 1.29.0\n#[stable(feature = \"foo\", since = \"1.29.0\")]\nfn foo_stable_1_29_0() {}\n\n// error: feature `foo` is declared unstable\n#[unstable(feature = \"foo\", issue = \"none\")]\nfn foo_unstable() {}\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_4 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_4` function, passing three arguments: two integers (1 and 2) and a floating-point number (3.0). It demonstrates function calls with mixed data types and the `stdcall` calling convention. The behavior of `stdcall_fn_4` determines the output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_4(1, 2, 3.0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deprecated Inline Assembly Error in Rust\nDESCRIPTION: This code snippet demonstrates a previously emitted error when trying to pass an inappropriate value to an inline assembly operand. The error occurred when attempting to pass a value that represents a pair (like a slice) to an input operand expecting a single register value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0669.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(llvm_asm)]\n\nfn main() {\n    unsafe {\n        llvm_asm!(\"\" :: \"r\"(\"\"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Clippy Lint Tool Name\nDESCRIPTION: Examples of incorrectly spelled clippy tool name in lint attributes that will trigger E0710 error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0710.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(clipp::filter_map)] // error!\nfn main() {\n    // business logic\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[warn(clipp::filter_map)] // error!\nfn main() {\n    // business logic\n}\n```\n\n----------------------------------------\n\nTITLE: Building a no-std library for AMD GPU with Rust\nDESCRIPTION: The snippet demonstrates creating a no-std Rust library aimed at AMD GPUs using the 'gpu-kernel' ABI. Dependencies include the Rust compiler configured for specific AMD GPU targets via cross-compilation. The example provides a panic handler and a GPU kernel function as an entry point. Inputs include the target-cpu and necessary feature flags, and the output is a compiled binary suitable for AMD's GPU architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/amdgcn-amd-amdhsa.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_gpu_kernel)]\\n#![no_std]\\n\\n#[panic_handler]\\nfn panic(_: &core::panic::PanicInfo) -> ! {\\n    loop {}\\n}\\n\\n#[no_mangle]\\npub extern \"gpu-kernel\" fn kernel(/* Arguments */) {\\n    // Code\\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Virtual Machine\nDESCRIPTION: Command to launch the QEMU virtual machine for Rust testing\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmkqnximage --run=-h\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_3 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_3` function, passing a floating-point number (3.5) as an argument using the `stdcall` calling convention in Rust. It specifically demonstrates function calls with floating-point parameters. The output of the call depends on what `stdcall_fn_3` is defined to do.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_3(3.5)\n```\n\n----------------------------------------\n\nTITLE: Example GIMPLE Output\nDESCRIPTION: This snippet shows an example of the GIMPLE output generated by the program. It represents the intermediate representation of a function named 'xxx'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n__attribute__((const))\nint xxx ()\n{\n  int D.3394;\n  int sum;\n  int x;\n\n  <D.3377>:\n  x = 45;\n  sum = 0;\n  goto loop_cond;\n  loop_cond:\n  x = x >> 1;\n  if (x != 0) goto after_loop; else goto loop_body;\n  loop_body:\n  _1 = foo (x);\n  _2 = _1 * 2;\n  x = x + _2;\n  goto loop_cond;\n  after_loop:\n  D.3394 = sum;\n  return D.3394;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring External Functions in Rust\nDESCRIPTION: This snippet declares four external functions in Rust, indicating that they are defined outside Rust code, typically in C or another language. These functions may be used for foreign function interface (FFI) purposes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-c/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nextern fn extern_fn_1\n```\n\nLANGUAGE: Rust\nCODE:\n```\nextern fn extern_fn_2; // didn't get the rename\n```\n\nLANGUAGE: Rust\nCODE:\n```\nextern fn extern_fn_3\n```\n\nLANGUAGE: Rust\nCODE:\n```\nextern fn extern_fn_4\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee with Unmarked Multiple Generics\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct with multiple generic parameters but no pointee designation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\n#[repr(transparent)]\nstruct AmbiguousPointee<'a, T1: ?Sized, T2: ?Sized> {\n    a: (&'a T1, &'a T2),\n}\n```\n\n----------------------------------------\n\nTITLE: Generating LateLintPass Boilerplate in Clippy\nDESCRIPTION: Command to generate boilerplate code for a new lint that uses LateLintPass. This is used when the lint needs access to type information and symbol relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/lint_passes.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo dev new_lint --name=<your_new_lint> --pass=late --category=<your_category_choice>\n```\n\n----------------------------------------\n\nTITLE: Deinitializing All Git Submodules - bash\nDESCRIPTION: This command snippet is used to forcibly deinitialize all git submodules in a repository, useful when local submodule metadata is broken or corrupted. The `git submodule deinit -f --all` command removes submodule working directories and configurations, allowing a clean reinitialization later. This helps resolve issues where submodule state prevents normal operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule deinit -f --all\n```\n\n----------------------------------------\n\nTITLE: Detecting Private Intra-Doc Links in Rust\nDESCRIPTION: This snippet shows a public function `public` with a documentation comment linking to a private function `private`. The `private_intra_doc_links` lint issues a warning here, indicating that the link will be unresolved in the documentation model, unless private items are explicitly documented with the `--document-private-items` flag. It demonstrates the importance of ensuring intra-doc links are valid within the visible documentation scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(rustdoc::private_intra_doc_links)] // note: unnecessary - warns by default.\n\n/// [private]\npub fn public() {}\nfn private() {}\n\n```\n\n----------------------------------------\n\nTITLE: Single-Line Struct Variant Formatting in Rust\nDESCRIPTION: Demonstrates how to format small struct variants within enums on a single line. It specifies the use of spaces around braces and the absence of a trailing comma.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum FooBar {\n    Error { err: Box<Error>, line: u32 },\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Precondition Check Pattern\nDESCRIPTION: Shows the preferred way to check boolean preconditions by expressing the invariant directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nif !(idx < len) {\n    return None;\n}\n\n// BAD\nif idx >= len {\n    return None;\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Stack Size Metadata in Object Files\nDESCRIPTION: This console snippet shows how to use objdump to analyze the stack size metadata in the compiled object file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ objdump -d foo.o\n\nfoo.o:     file format elf64-x86-64\n\nDisassembly of section .text._ZN3foo3foo17he211d7b4a3a0c16eE:\n\n0000000000000000 <_ZN3foo3foo17he211d7b4a3a0c16eE>:\n   0:   c3                      retq\n\nDisassembly of section .text._ZN3foo3bar17h1acb594305f70c2eE:\n\n0000000000000000 <_ZN3foo3bar17h1acb594305f70c2eE>:\n   0:   48 83 ec 10             sub    $0x10,%rsp\n   4:   48 8d 44 24 08          lea    0x8(%rsp),%rax\n   9:   48 89 04 24             mov    %rax,(%rsp)\n   d:   48 8b 04 24             mov    (%rsp),%rax\n  11:   48 83 c4 10             add    $0x10,%rsp\n  15:   c3                      retq\n\n$ objdump -s -j .stack_sizes foo.o\n\nfoo.o:     file format elf64-x86-64\n\nContents of section .stack_sizes:\n 0000 00000000 00000000 00                 .........\nContents of section .stack_sizes:\n 0000 00000000 00000000 10                 .........\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Targets for UWP in Rust (TOML)\nDESCRIPTION: This snippet shows how to configure a Rust project to build for specific UWP targets using the build configuration file (`Cargo.toml`). It specifies the build stage and the desired targets for a `rustc` build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/uwp-windows-msvc.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-uwp-windows-msvc\", \"aarch64-uwp-windows-msvc\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Std Detect - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `std_detect` crate (index 7). It includes the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate provides runtime CPU feature detection.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n7: CrateData {\n    root_file_id: FileId(\n        8,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"std_detect\",\n            ),\n            canonical_name: \"std_detect\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Other,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for win7-windows-msvc Target in TOML\nDESCRIPTION: This snippet shows how to add the x86_64-win7-windows-msvc target to the build configuration in bootstrap.toml. It sets the build stage and specifies the target to be built.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/win7-windows-msvc.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-win7-windows-msvc\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0713 Error in Rust\nDESCRIPTION: This code snippet shows an erroneous example that triggers the E0713 error. It defines a struct S with a mutable reference and implements the Drop trait. The demo function attempts to borrow and return the mutable reference, which conflicts with the Drop implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0713.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct S<'a> { data: &'a mut String }\n\nimpl<'a> Drop for S<'a> {\n    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n}\n\nfn demo<'a>(s: S<'a>) -> &'a mut String { let p = &mut *s.data; p }\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Information Using rustc_driver in Rust\nDESCRIPTION: Example showing how to use rustc_driver's after_analysis callback to obtain a TyCtxt instance for type checking. This demonstrates interaction with Rust's compilation process to analyze expression types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/interacting-with-the-ast.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../examples/rustc-driver-interacting-with-the-ast.rs}}\n```\n\n----------------------------------------\n\nTITLE: Disabling Table of Contents in Markdown\nDESCRIPTION: This code snippet demonstrates how to use the `--markdown-no-toc` flag to prevent rustdoc from generating a table of contents when processing a Markdown file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc README.md --markdown-no-toc\n```\n\n----------------------------------------\n\nTITLE: Filtered #[rustc_on_unimplemented] Error Messages for Iterator Trait\nDESCRIPTION: Demonstrates how to create targeted error messages for the Iterator trait using the 'on' filter to provide different guidance based on the specific type that's missing the implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_on_unimplemented(\n    on(\n        _Self=\"&str\",\n        note=\"call `.chars()` or `.as_bytes()` on `{Self}`\"\n    ),\n    message=\"`{Self}` is not an iterator\",\n    label=\"`{Self}` is not an iterator\",\n    note=\"maybe try calling `.iter()` or a similar method\"\n)]\npub trait Iterator {}\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Implementation with Mismatched Lifetime Parameters\nDESCRIPTION: Example showing incorrect implementation where the lifetime constraint 'b:'a is missing in the implementation of the bar() method, causing compilation error E0195.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0195.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inferred Implementation with Static Lifetime in Rust\nDESCRIPTION: Shows how the compiler infers the is_cool implementation with a static lifetime bound on the trait object.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0772.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn is_cool<'a>(self: &'a (dyn Person + 'static)) -> bool {unimplemented!()}\n```\n\n----------------------------------------\n\nTITLE: Non-function Items in Type-Based Search\nDESCRIPTION: This snippet describes how certain non-function items in Rust documentation are treated within type-based searching, emphasizing that struct fields are treated like getter methods, and constants are treated as functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/read-documentation/search.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nFor example, struct fields are treated as though they were getter methods.\nThis means that a search for `CpuidResult -> u32` will show the `CpuidResult::eax` field in the results.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stack Probe in Rust\nDESCRIPTION: This Rust code example demonstrates the stack probe feature by allocating a large array on the stack. It's used to illustrate how stack clashing protection works in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v: [u8; 16384] = [1; 16384];\n    let first = &v[0];\n    println!(\"The first element is: {first}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Function Formatting in rustfmt\nDESCRIPTION: An example showing how rustfmt formats a simple Rust function declaration with parameters, used to illustrate the code formatting workflow of rustfmt where the formatter calculates indentation and width budgets as it traverses the AST.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Design.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(a: A, b: B) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Proper Function Call Without Lifetime Arguments in Rust\nDESCRIPTION: This example shows the correct way to call a function that doesn't expect any lifetime arguments. The function f() is called without any explicit lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0088.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn f() {}\n\nfn main() {\n    f() // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring PTX Global and Device Functions in Rust\nDESCRIPTION: Demonstrates how to declare both global functions (callable from CUDA host code) and device functions (only callable from other device functions) using the abi_ptx feature. Global functions use the \"ptx-kernel\" ABI specifier.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-ptx.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_ptx)]\n#![no_std]\n\npub unsafe extern \"ptx-kernel\" fn global_function() {\n    device_function();\n}\n\npub fn device_function() {\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Small Heuristics Max Example in Rust\nDESCRIPTION: Demonstrates formatting when use_small_heuristics is set to 'Max', where all width settings equal max_width for maximum horizontal formatting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_77\n\nLANGUAGE: rust\nCODE:\n```\nenum Lorem {\n    Ipsum,\n    Dolor(bool),\n    Sit { amet: Consectetur, adipiscing: Elit },\n}\n\nfn main() {\n    lorem(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipiscing\");\n\n    let lorem = Lorem { ipsum: dolor, sit: amet };\n\n    let lorem = if ipsum { dolor } else { sit };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SnippetTextEdit Interface in TypeScript\nDESCRIPTION: Extends the TextEdit interface to add support for snippets with tab stops and placeholders, used in code actions and on-type formatting. This extension allows for more interactive text edits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SnippetTextEdit extends TextEdit {\n    insertTextFormat?: InsertTextFormat;\n    annotationId?: ChangeAnnotationIdentifier;\n}\n```\n\n----------------------------------------\n\nTITLE: Running libgccjit Tests\nDESCRIPTION: Commands to run the libgccjit test suite, including an example of running a specific test with verbose output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cd gcc # from the `gcc-build` folder\n$ make check-jit\n# To run one specific test:\n$ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=jit.dg/test-asm.cc\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closure Arguments in Rust\nDESCRIPTION: This example shows both valid and invalid ways to call a closure in Rust. The error E0057 occurs when a closure is called with an incorrect number of arguments compared to its definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0057.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet f = |x| x * 3;\nlet a = f();        // invalid, too few parameters\nlet b = f(4);       // this works!\nlet c = f(2, 3);    // invalid, too many parameters\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Usage Examples in Rust\nDESCRIPTION: Examples of incorrect type usage showing common mistakes with intrinsics, main function, pattern matching, and self parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0211.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn unreachable(); // error: intrinsic has wrong type\n\n// or:\n\nfn main() -> i32 { 0 }\n// error: main function expects type: `fn() {main}`: expected (), found i32\n\n// or:\n\nlet x = 1u8;\nmatch x {\n    0u8..=3i8 => (),\n    // error: mismatched types in range: expected u8, found i8\n    _ => ()\n}\n\n// or:\n\nuse std::rc::Rc;\nstruct Foo;\n\nimpl Foo {\n    fn x(self: Rc<Foo>) {}\n    // error: mismatched self type: expected `Foo`: expected struct\n    //        `Foo`, found struct `alloc::rc::Rc`\n}\n```\n\n----------------------------------------\n\nTITLE: File System Wrapper Helpers in Rust Run Make Support\nDESCRIPTION: Panic-on-fail helpers for file system operations to reduce boilerplate and improve error handling in test scenarios\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/run-make-support/CHANGELOG.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// File system wrapper module\nmod fs_wrapper {\n    // Panic-on-fail helpers for std::fs operations\n    fn copy_dir_all(src: &Path, dst: &Path);\n    fn path() -> Path; // Relative path creation helper\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript and Running Type Checking\nDESCRIPTION: This snippet provides the commands necessary to install the TypeScript compiler globally and run a type check based on the project's configuration. It requires Node.js and npm to be installed. The expected input is a valid TypeScript project configuration file, and it outputs type checking status. Ensure \"tsconfig.json\" is correctly setup before execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/js/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i -g typescript\ntsc --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Defining extern \"C\" Functions and Structures in Rust\nDESCRIPTION: This Rust code snippet showcases how to define a struct and an extern \"C\" function to demonstrate the ABI issue in the wasm32-unknown-unknown target. The code defines a struct `MyPair` and uses it in a function `take_my_pair`, which illustrates the discrepancy between the Rust and C ABI for WebAssembly targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\nstruct MyPair {\n    a: u32,\n    b: u32,\n}\n\nextern \"C\" {\n    fn take_my_pair(pair: MyPair) -> u32;\n}\n\n#[no_mangle]\npub unsafe extern \"C\" fn call_c() -> u32 {\n    take_my_pair(MyPair { a: 1, b: 2 })\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Custom Rustc to Toolchain\nDESCRIPTION: Command to link the newly built rustc to a custom toolchain named 'stage2' using rustup. This allows for easy switching between the custom and standard Rust compilers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nrustup toolchain link stage2 ./build/host/stage2/\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol for Lifetime References\nDESCRIPTION: Shows the mangled symbol for the 'example' function with lifetime references, demonstrating how lifetimes are encoded using De Bruijn indices in the symbol name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n_RINvCs7qp2U7fqm6G_7mycrate7exampleFG0_RL1_hRL0_tEuEB2_\n                                    │└┬┘│└┬┘││└┬┘││\n                                    │ │ │ │ ││ │ │└── end of input types\n                                    │ │ │ │ ││ │ └─── type u16\n                                    │ │ │ │ ││ └───── lifetime #1 'b\n                                    │ │ │ │ │└─────── reference type\n                                    │ │ │ │ └──────── type u8\n                                    │ │ │ └────────── lifetime #2 'a\n                                    │ │ └──────────── reference type\n                                    │ └────────────── binder with 2 lifetimes\n                                    └──────────────── function type\n```\n\n----------------------------------------\n\nTITLE: Rust Diagnostic Structure for Iterator Method Type Mismatch\nDESCRIPTION: A structured representation of a Rust compiler diagnostic showing error E0053. The error indicates a type mismatch in the 'next' method implementation for a trait, where the method is implemented with a different signature than what the trait expects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_incompatible_type_for_trait.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n[\n    MappedRustDiagnostic {\n        url: Url {\n            scheme: \"file\",\n            cannot_be_a_base: false,\n            username: \"\",\n            password: None,\n            host: None,\n            port: None,\n            path: \"/test/compiler/ty/list_iter.rs\",\n            query: None,\n            fragment: None,\n        },\n        diagnostic: Diagnostic {\n            range: Range {\n                start: Position {\n                    line: 51,\n                    character: 4,\n                },\n                end: Position {\n                    line: 51,\n                    character: 47,\n                },\n            },\n            severity: Some(\n                Error,\n            ),\n            code: Some(\n                String(\n                    \"E0053\",\n                ),\n            ),\n            code_description: Some(\n                CodeDescription {\n                    href: Url {\n                        scheme: \"https\",\n                        cannot_be_a_base: false,\n                        username: \"\",\n                        password: None,\n                        host: Some(\n                            Domain(\n                                \"doc.rust-lang.org\",\n                            ),\n                        ),\n                        port: None,\n                        path: \"/error-index.html\",\n                        query: None,\n                        fragment: Some(\n                            \"E0053\",\n                        ),\n                    },\n                },\n            ),\n            source: Some(\n                \"rustc\",\n            ),\n            message: \"method `next` has an incompatible type for trait\\nexpected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n            related_information: None,\n            tags: None,\n            data: None,\n        },\n        fix: None,\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Different Compare Modes\nDESCRIPTION: This snippet provides the command to run tests in a specific compare mode using the `--compare-mode` CLI flag. It outlines the available compare modes, which can help identify differences in test behavior under various compiler flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n\"./x test tests/ui --compare-mode=chalk\\n\"\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Where Predicates in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for where predicates. Predicates are aligned with the 'where' keyword, which is indented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<Ipsum, Dolor, Sit, Amet>() -> T\n    where Ipsum: Eq,\n          Dolor: Eq,\n          Sit: Eq,\n          Amet: Eq\n{\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Path Handling with Lint Reasons\nDESCRIPTION: Example showing lint attributes with reason parameter for platform-specific code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/levels.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::PathBuf;\npub fn get_path() -> PathBuf {\n    #[allow(unused_mut, reason = \"this is only modified on some platforms\")]\n    let mut file_name = PathBuf::from(\"git\");\n    #[cfg(target_os = \"windows\")]\n    file_name.set_extension(\"exe\");\n    file_name\n}\n```\n\n----------------------------------------\n\nTITLE: Universal Lifetimes Restriction in Opaque Types in Rust\nDESCRIPTION: This snippet covers the restriction on using only universally quantified lifetimes, such as lifetime parameters and placeholders, in opaque type arguments. It explains how the constraint ensures consistency and overcomes technical limitations in the member constraints algorithm.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x> = impl Sized + 'x;\n\nfn test<'a>() -> Opaque<'a> {\n    // `Opaque<'empty> := ()`\n    let _: Opaque<'_> = ();\n    //~^ ERROR\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Library Files Error in Rust\nDESCRIPTION: This code snippet shows a compilation error that occurs when multiple library files with the same crate name are present. It uses auxiliary builds to create the conflict and attempts to use an external crate, resulting in an error due to multiple candidates for the dependency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0464.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// aux-build:crateresolve-1.rs\n// aux-build:crateresolve-2.rs\n// aux-build:crateresolve-3.rs\n\nextern crate crateresolve;\n//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Function Example in Rust\nDESCRIPTION: This snippet gives an example of a Rust function with generic parameters and an example invocation. It is used to demonstrate how types and functions are symbolically represented in Rust mangling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    example::<[u16; 8]>();\n}\n\npub fn example<T>() {}\n```\n\n----------------------------------------\n\nTITLE: Including File Bytes Using include_bytes! in Rust\nDESCRIPTION: This snippet uses the include_bytes! macro to include the contents of a file located at 'relative-dir-empty-file' into a byte array at compile time. It allows the program to access the raw byte data of the file as a static reference during execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/rustdoc-ui/doctest/auxiliary/relative-dir.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = include_bytes!(\"relative-dir-empty-file\");\n```\n\n----------------------------------------\n\nTITLE: Building Rust Core for LynxOS-178\nDESCRIPTION: This command builds the Rust core library for the LynxOS-178 target using Cargo. It uses the nightly version of Cargo and employs the build-std feature to enable building the standard library, albeit only core is supported currently.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/lynxos178.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo +nightly build -Z build-std=core --target x86_64-lynx-lynxos178\n```\n\n----------------------------------------\n\nTITLE: Default Merge Derives Behavior in Rust\nDESCRIPTION: Shows the default merge_derives setting (true), which combines multiple derive attributes into a single attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_48\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Eq, PartialEq, Debug, Copy, Clone)]\npub enum Foo {}\n```\n\n----------------------------------------\n\nTITLE: Cross-compiling Compatible C Code for zkVM\nDESCRIPTION: To create compatible C code for the RISC Zero zkVM, use any compiler supporting the RV32IM target, applying specific LLVM flags as outlined for the target specifications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv32im-risc0-zkvm-elf.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-march=rv32im -mabi=ilp32 -target riscv32-unknown-none\n```\n\n----------------------------------------\n\nTITLE: Running Basic Speedtest for UI Tests\nDESCRIPTION: Command to run speed tests for UI-based lints, specifically for tests named 'allow_attributes'. Executes the test 1000 times by default.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/speedtest.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ SPEEDTEST=ui TESTNAME=\"allow_attributes\" cargo uitest\n```\n\n----------------------------------------\n\nTITLE: Running Clippy with Auto-fix\nDESCRIPTION: Command to run Clippy with automatic fix suggestions applied\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo clippy --fix\n```\n\n----------------------------------------\n\nTITLE: Restricting Mutations in Match Guards in Rust\nDESCRIPTION: Demonstrates the error caused by attempting to mutate a matched variable within a match guard in Rust, leading to potential non-exhaustive matches. Highlights the importance of maintaining immutability within guards and provides a corrected implementation by repositioning value mutation outside of the guard.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0510.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut x = Some(0);\nmatch x {\n    None => {}\n    Some(_) if { x = None; false } => {} // error!\n    Some(_) => {}\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut x = Some(0);\nmatch x {\n    None => {}\n    Some(_) => {\n        x = None; // ok!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking PATH Variable inside Flatpak VS Code (Shell)\nDESCRIPTION: Displays the current `PATH` environment variable as seen from within the terminal of a Flatpak version of VS Code. This is useful for debugging and configuring the environment, particularly when needing to add `~/.cargo/bin` to the path for `rustup` installations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\necho $PATH\n```\n\n----------------------------------------\n\nTITLE: Rust Type Relation Example\nDESCRIPTION: Shows a type relation example using AOutlivesB trait with lifetime parameters to demonstrate region obligations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/canonicalization.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n(): AOutlivesB<'a, 'b>\n```\n\n----------------------------------------\n\nTITLE: Erroneous Structure-literal Syntax with Type Alias in Rust\nDESCRIPTION: This code demonstrates the E0071 error in Rust, which occurs when using structure-literal syntax with a type alias that points to a primitive type rather than a struct or enum variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0071.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype U32 = u32;\nlet t = U32 { value: 4 }; // error: expected struct, variant or union type,\n                          // found builtin type `u32`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0415 Error in Rust Function Parameters\nDESCRIPTION: This code snippet shows an erroneous function declaration where two parameters have the same name 'f', resulting in a compile-time error E0415.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0415.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n                          //        once in this parameter list\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Only the rust-analyzer Server from Source (Shell)\nDESCRIPTION: Compiles and installs only the rust-analyzer Language Server Protocol (LSP) server binary from the source code using `cargo xtask install --server`. This is useful for integration with editors other than VS Code or when managing the server binary separately. Requires Git and Cargo, and assumes the repository has been cloned.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo xtask install --server\n```\n\n----------------------------------------\n\nTITLE: Configuring Panic Abort for Tests\nDESCRIPTION: Additional compiler flags to enable panic=abort mode for test binaries\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_25\n\nLANGUAGE: sh\nCODE:\n```\n    --test-args --target-rustcflags                                           \\\n    --test-args -Cpanic=abort                                                 \\\n    --test-args --target-rustcflags                                           \\\n    --test-args -Zpanic_abort_tests                                           \\\n```\n\n----------------------------------------\n\nTITLE: Example of a Coinductive Goal\nDESCRIPTION: This snippet demonstrates a co-inductive goal using the `Send` trait and a recursive struct `Foo`. It shows how the solver can determine that `Foo` is `Send` even though the check requires recursively proving `Foo` is `Send`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n\"struct Foo {\n    next: Option<Box<Foo>>\n}\"\n```\n\n----------------------------------------\n\nTITLE: Resolving Import Naming Conflict Using Aliases in Rust\nDESCRIPTION: Shows how to fix naming conflicts by using the 'as' keyword to create an alias for one of the imported items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0252.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::baz as foo_baz;\nuse bar::baz; // ok!\n\nfn main() {}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\n----------------------------------------\n\nTITLE: Copying vs Borrowing in Rust Closures\nDESCRIPTION: This snippet illustrates another approach to resolve borrowing issues in Rust by using a cloned copy of the variable. `jon_snow` is cloned into `jon_copy`, which allows the closure `starks` to mutate `jon_snow` without conflict. This approach requires that the type implements the `Clone` trait, and ensures safe borrowing practices.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0500.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let mut jon_copy = jon_snow.clone();\n    let starks = || {\n        *jon_snow = 3;\n    };\n    println!(\"{}\", jon_copy);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Incorrect Self Usage in Associated Function\nDESCRIPTION: Example showing erroneous usage of 'self' keyword in an associated function without a self receiver parameter, which causes compilation error E0424.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0424.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    // `bar` is a method, because it has a receiver parameter.\n    fn bar(&self) {}\n\n    // `foo` is not a method, because it has no receiver parameter.\n    fn foo() {\n        self.bar(); // error: `self` value is a keyword only available in\n                    //        methods with a `self` parameter\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using rustc with -Zwasm-c-abi flag for Correct ABI\nDESCRIPTION: This shell command demonstrates compiling a Rust source file using the nightly compiler and the `-Zwasm-c-abi` flag to conform to the correct C ABI for WebAssembly targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc +nightly -Zwasm-c-abi=spec foo.rs --target wasm32-unknown-unknown --crate-type lib --emit obj -O\n$ wasm-tools print foo.o\n(module\n  (import \"env\" \"take_my_pair\" (func $take_my_pair (param i32) (result i32)))\n  (func $call_c (result i32)\n    ;; ...\n  )\n  ;; ...\n)\n```\n\n----------------------------------------\n\nTITLE: Controlling Documentation Visibility with #[doc(hidden)]\nDESCRIPTION: This code snippet illustrates the use of #[doc(hidden)] to exclude items from documentation, facilitating a cleaner interface for end-users.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#[doc(hidden)]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Constraining Lifetimes in Function Item Implementations\nDESCRIPTION: The following code demonstrates how to configure constrained lifetimes in a struct that represents a function item, showcasing Rust's handling of lifetimes in trait implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nstruct FooFnItem<'a>(PhantomData<fn() -> &'a String>);\n\nimpl<'a> Fn<()> for FooFnItem<'a> {\n    type Output = &'a String;\n    /* fn call(...) -> ... { ... } */\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Trait from Impl in Rust\nDESCRIPTION: This snippet shows how to generate a trait definition from an existing inherent impl and convert the impl to a trait impl. The specific code for this transformation is not provided in the given text.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_63\n\n\n\n----------------------------------------\n\nTITLE: Markdown Template for Rust Feature Tracking\nDESCRIPTION: A markdown template that establishes the structure for tracking Rust language features. It includes a title with the feature name and a reference to the tracking issue on GitHub.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/unstable-book-gen/src/stub-issue.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `{name}`\n\nThe tracking issue for this feature is: [#{issue}]\n\n[#{issue}]: https://github.com/rust-lang/rust/issues/{issue}\n```\n\n----------------------------------------\n\nTITLE: Formatting Python Code Using ruff\nDESCRIPTION: This snippet provides commands for formatting and linting Python code in the Rust repository. It employs the ruff tool and specifies two different commands: one for formatting and another for lint checking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/conventions.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n./x test tidy --extra-checks py:fmt --bless\n```\n\nLANGUAGE: console\nCODE:\n```\n./x test tidy --extra-checks py:lint\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with rustdoc - Bash\nDESCRIPTION: This snippet demonstrates how to build Rust documentation using the rustdoc tool from the beta toolchain. It covers the command for building standard documentation, as well as for CI building to ensure consistency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/compiler-documenting.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./x doc\n```\n\nLANGUAGE: bash\nCODE:\n```\n./x doc --stage 1\n```\n\n----------------------------------------\n\nTITLE: Detecting Data Races with ThreadSanitizer in Rust\nDESCRIPTION: This Rust snippet demonstrates a simple data race scenario by modifying a static mutable variable from multiple threads without synchronization. It exposes how ThreadSanitizer catches violations of safe concurrent access. The example requires enabling ThreadSanitizer instrumentation by passing `-Zsanitizer=thread` in compiler flags and rebuilding the standard library with `-Zbuild-std`. The snippet takes no input and will output a warning about a data race at runtime, helping developers identify unsafe sharing of mutable state across threads.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nstatic mut A: usize = 0;\n\nfn main() {\n    let t = std::thread::spawn(|| {\n        unsafe { A += 1 };\n    });\n    unsafe { A += 1 };\n\n    t.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Markdown-Before-Content Option with Rustdoc\nDESCRIPTION: Demonstrates how to include rendered Markdown content before the main documentation content. This flag allows inserting extra content inside the <body> tag that's processed through a Markdown renderer first.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md\n$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md\n```\n\n----------------------------------------\n\nTITLE: Running Clippy on Specific Workspace Package\nDESCRIPTION: Command to run Clippy on a specific package in a workspace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy -p example\n```\n\n----------------------------------------\n\nTITLE: Defining Parser Token Source and Tree Sink Interfaces in Rust\nDESCRIPTION: Interfaces for managing token input and syntax tree output, providing abstractions for parsing with flexible token handling and tree construction\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub struct Token {\n    pub kind: SyntaxKind,\n    pub is_joined_to_next: bool,\n}\n\npub trait TokenSource {\n    fn current(&self) -> Token;\n    fn lookahead_nth(&self, n: usize) -> Token;\n    fn is_keyword(&self, kw: &str) -> bool;\n\n    fn bump(&mut self);\n}\n\npub trait TreeSink {\n    fn token(&mut self, kind: SyntaxKind, n_tokens: u8);\n\n    fn start_node(&mut self, kind: SyntaxKind);\n    fn finish_node(&mut self);\n\n    fn error(&mut self, error: ParseError);\n}\n\npub fn parse(\n    token_source: &mut dyn TokenSource,\n    tree_sink: &mut dyn TreeSink,\n) { ... }\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Associated Types in Rust Traits\nDESCRIPTION: A solution to the ambiguous associated type problem by explicitly specifying which trait's associated type to use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0411.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type Bar;\n}\n\ntrait Foo2 {\n    type Bar;\n}\n\ntrait Baz : Foo + Foo2 {\n    fn bar() -> <Self as Foo>::Bar; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Temporary Variable in Rust to Illustrate Dropping\nDESCRIPTION: This snippet rewrites the previous example to use an explicit temporary variable, showing more clearly when the temporary is created and dropped. It demonstrates why the borrow fails due to the temporary being freed too soon.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0716.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\n----------------------------------------\n\nTITLE: Small Heuristics Off Example in Rust\nDESCRIPTION: Shows code formatting when use_small_heuristics is set to 'Off', where width settings are disabled and constructs are formatted vertically.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_76\n\nLANGUAGE: rust\nCODE:\n```\nenum Lorem {\n    Ipsum,\n    Dolor(bool),\n    Sit {\n        amet: Consectetur,\n        adipiscing: Elit,\n    },\n}\n\nfn main() {\n    lorem(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipiscing\");\n\n    let lorem = Lorem {\n        ipsum: dolor,\n        sit: amet,\n    };\n\n    let lorem = if ipsum {\n        dolor\n    } else {\n        sit\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Invalid Attributes in Rust Code\nDESCRIPTION: These code snippets show erroneous and corrected examples of using meta-items in Rust attributes. The purpose is to highlight correct key-value syntax in attributes like \"deprecated\", \"unstable\", and \"stable\". Dependencies include enabling features using #![feature(...)] and respecting Rust attribute requirements. Common attributes include \"stable\", \"unstable\", and \"deprecated\" with mandated key-value pairs for functioning properly. Corrected code adheres to attribute syntax such as providing values for keys like \"issue\" and \"since\".\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0539.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[deprecated(note)] // error!\n#[unstable(feature = \"deprecated_fn\", issue = \"123\")]\nfn deprecated() {}\n\n#[unstable(feature = \"unstable_struct\", issue)] // error!\nstruct Unstable;\n\n#[rustc_const_unstable(feature)] // error!\nconst fn unstable_fn() {}\n\n#[stable(feature = \"stable_struct\", since)] // error!\nstruct Stable;\n\n#[rustc_const_stable(feature)] // error!\nconst fn stable_fn() {}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[deprecated(since = \"1.39.0\", note = \"reason\")] // ok!\n#[unstable(feature = \"deprecated_fn\", issue = \"123\")]\nfn deprecated() {}\n\n#[unstable(feature = \"unstable_struct\", issue = \"123\")] // ok!\nstruct Unstable;\n\n#[rustc_const_unstable(feature = \"unstable_fn\", issue = \"124\")] // ok!\nconst fn unstable_fn() {}\n\n#[stable(feature = \"stable_struct\", since = \"1.39.0\")] // ok!\nstruct Stable;\n\n#[stable(feature = \"stable_fn\", since = \"1.39.0\")]\n#[rustc_const_stable(feature = \"stable_fn\", since = \"1.39.0\")] // ok!\nconst fn stable_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Constraint Error in Rust Trait Implementation\nDESCRIPTION: This code snippet demonstrates E0326 error in Rust where a trait implementation uses the wrong type for an associated constant. The trait defines BAR as bool but the implementation uses u32, causing a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0326.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    const BAR: bool;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    const BAR: u32 = 5; // error, expected bool, found u32\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching Types in Rust\nDESCRIPTION: Example of correct type matching in a range pattern, ensuring consistent types throughout the match expression.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0211.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1u8;\n\nmatch x {\n    0u8..=3u8 => (), // ok!\n    _ => ()\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Main Program (main.rs)\nDESCRIPTION: Main program that depends on both crate 'b' and the second version of crate 'a', causing a version conflict.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0460.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nextern crate a; // linked with `a2.rs`\nextern crate b; // error: found possibly newer version of crate `a` which `b`\n                //        depends on\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Observing Integer Overflow Behavior in Release Mode\nDESCRIPTION: Example showing how the Rust compiler handles integer overflow in release mode (with debug assertions disabled). The overflow wraps around to 0 without a panic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --release\n   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n    Finished release [optimized] target(s) in 0.23s\n     Running `target/release/hello-rust-integer`\nu: 0\n```\n\n----------------------------------------\n\nTITLE: Configuring enforced-import-renames\nDESCRIPTION: Specifies a list of imports to always rename. It uses fully qualified paths followed by the rename. Defaults to an empty list (`[]`). Useful for establishing consistent naming conventions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Glob Re-exports and Attribute Inheritance in Rust\nDESCRIPTION: This snippet demonstrates how attributes are inherited with glob re-exports. The `InPrivate` struct will have the `cfg(a)` attribute from its definition within `private_mod`. Due to the glob re-export, the attributes applied to the re-export itself are also considered, resulting in the re-exported item inheriting `cfg(a)` and `cfg(c)`. However, only `cfg(a)` will be displayed in documentation of `InPrivate`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_mod {\n    /// First\n    #[cfg(a)]\n    pub struct InPrivate;\n}\n\n#[cfg(c)]\npub use self::private_mod::*;\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Structural Search Replace in Rust\nDESCRIPTION: An example of how the Structural Search Replace feature transforms code. It shows a before and after state when applying the command 'foo($a, $b) ==>> ($a).foo($b)' to convert a function call syntax to method call syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Using structural search replace command [foo($a, $b) ==>> ($a).foo($b)]\n\n// BEFORE\nString::from(foo(y + 5, z))\n\n// AFTER\nString::from((y + 5).foo(z))\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Tasks in JSON for VS Code\nDESCRIPTION: This JSON configuration defines a build task for Visual Studio Code to run a custom shell command. The task automates running `./x check`, clearing previous outputs, and categorizing it as the default build task. It requires the problem matcher for Rustc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"./x check\",\n            \"command\": \"./x check\",\n            \"type\": \"shell\",\n            \"problemMatcher\": \"$rustc\",\n            \"presentation\": { \"clear\": true },\n            \"group\": { \"kind\": \"build\", \"isDefault\": true }\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0107 Error with Too Few Type Arguments in Rust\nDESCRIPTION: This example shows a function that requires two type parameters (T and U), but only one type argument (f64) is provided when called, resulting in the E0107 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0089.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T, U>() {}\n\nfn main() {\n    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Matching Fn Argument Count in Rust\nDESCRIPTION: This code snippet provides a corrected version of the previous example, resolving the E0593 error. The closure passed to `foo` now takes no arguments (`|| {}`), matching the `Fn()` trait bound expected by the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0593.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    foo(|| { }); // ok!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Cloning Rust Repository in Shell\nDESCRIPTION: Initial step to clone the Rust language repository from GitHub and navigate into the project directory\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/rust-lang/rust.git\ncd rust\n```\n\n----------------------------------------\n\nTITLE: String Comparison using Match Guards in Rust\nDESCRIPTION: This code demonstrates an alternative approach to matching a `String` value against a literal string using match guards, instead of the `string_deref_patterns` feature. The `is_it_the_answer` function checks if the `Value` is equal to \"42\", achieving the comparison by checking if the extracted string `s` is equal to \"42\".\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/string-deref-patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# pub enum Value {\n#    String(String),\n#    Number(u32),\n# }\n#\npub fn is_it_the_answer(value: Value) -> bool {\n    match value {\n        Value::String(s) if s == \"42\" => true,\n        Value::Number(42) => true,\n        _ => false,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Aborting and Restarting Git Rebase\nDESCRIPTION: Aborts an ongoing rebase operation if it was started incorrectly (e.g., against the wrong branch) and then restarts the interactive rebase against the correct 'upstream/master' branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ngit rebase --abort\ngit rebase -i upstream/master\n```\n\n----------------------------------------\n\nTITLE: Failed Copy Derive for Enum with Mutable Reference\nDESCRIPTION: Example demonstrating why deriving Copy fails for an enum containing a mutable reference &mut bool, since mutable references are not Copy even when the referenced type is Copy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0205.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Copy)]\nenum Foo<'a> {\n    Bar(&'a mut bool),\n    Baz,\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unconstrained Type Parameter with PhantomData\nDESCRIPTION: This code demonstrates how to fix the E0207 error by adding a phantom type parameter to the implementing type, which constrains the type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::marker::PhantomData;\n\ntrait Maker {\n    type Item;\n    fn make(&mut self) -> Self::Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\n// Add a type parameter to `FooMaker`\nstruct FooMaker<T> {\n    phantom: PhantomData<T>,\n}\n\nimpl<T: Default> Maker for FooMaker<T> {\n    type Item = Foo<T>;\n\n    fn make(&mut self) -> Foo<T> {\n        Foo {\n            foo: <T as Default>::default(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Lifetime Handling\nDESCRIPTION: Demonstrates a Rust code example with an incompatible lifetime constraint that fails compilation. The code shows a struct and trait with multiple lifetime parameters that cannot be directly used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0623.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a, 'b, T>(std::marker::PhantomData<(&'a (), &'b (), T)>)\nwhere\n    T: Convert<'a, 'b>;\n\ntrait Convert<'a, 'b>: Sized {\n    fn cast(&'a self) -> &'b Self;\n}\nimpl<'long: 'short, 'short, T> Convert<'long, 'short> for T {\n    fn cast(&'long self) -> &'short T {\n        self\n    }\n}\n// error\nfn badboi<'in_, 'out, T>(\n    x: Foo<'in_, 'out, T>,\n    sadness: &'in_ T\n) -> &'out T {\n    sadness.cast()\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Implementation of Foreign Trait with Multiple Type Parameters in Rust\nDESCRIPTION: This code snippet illustrates an invalid implementation of a foreign trait with multiple type parameters, where the first appearance of the type parameter is uncovered.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0210.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Generic Type Parameter in Rust\nDESCRIPTION: This code snippet shows the correct way to achieve the same functionality as the erroneous example. It uses a generic type parameter `T` with an `Iterator` trait bound instead of `impl Trait` in the path parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0667.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn some_fn<T: Iterator>(mut x: T) -> T::Item { // ok!\n    x.next().unwrap()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Analyzer with Proc Macro Support via JSON\nDESCRIPTION: An example JSON configuration for Rust Analyzer that enables proc-macro support and build scripts. This configuration would be passed in the initializationOptions field of the LSP InitializeParams message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cargo\": {\n    \"buildScripts\": {\n      \"enable\": true,\n    },\n  },\n  \"procMacro\": {\n    \"enable\": true,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Nonexistent Struct Field Access in Rust\nDESCRIPTION: This code snippet demonstrates the E0609 error in Rust, which occurs when attempting to access a field that does not exist within a struct. The code defines a struct StructWithFields with a single field x and then tries to access a non-existent field foo, causing a compile-time error. This highlights the importance of verifying field names when accessing struct members.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0609.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Function Type with Unconstrained Lifetime\nDESCRIPTION: Demonstrates an invalid function type declaration where a lifetime appears only in the return type without being constrained by arguments\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0581.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Here, `'a` appears only in the return type:\n    let x: for<'a> fn() -> &'a i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to GCC Linker in Rust Build Process\nDESCRIPTION: Shows how to pass specific arguments (-save-temps -v) to the GCC linker during the Rust compilation process using the CG_RUSTFLAGS environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nCG_RUSTFLAGS=\"-Clink-args=-save-temps -v\" ../y.sh cargo build\n```\n\n----------------------------------------\n\nTITLE: Merging Test Profile Data with llvm-profdata\nDESCRIPTION: This command merges multiple `.profraw` files generated by test runs into a single `.profdata` file using `llvm-profdata`. This indexed file is crucial for generating comprehensive coverage reports. The command assumes a pattern like `default_*.profraw` for input files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Module Visibility Macro Call\nDESCRIPTION: Demonstrates a compilation failure when a macro call prevents proper module resolution and struct visibility definition\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0578.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfoo!();\n\npub (in ::Sea) struct Shark; // error!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Invalid Empty Struct with SIMD Attribute\nDESCRIPTION: Example showing incorrect usage of #[repr(simd)] on an empty struct, which will result in compilation error E0075.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0075.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad; // error!\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build Without Jump Tables\nDESCRIPTION: Command to build a Rust project with disabled jump tables using nightly compiler and custom standard library compilation. This configuration helps protect against JOP attacks by adding the LLVM no-jump-tables=true attribute to every function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/no-jump-tables.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nRUSTFLAGS=\"-Zno-jump-tables\" cargo +nightly build -Z build-std\n```\n\n----------------------------------------\n\nTITLE: Rust Identifier and Whitespace Sequence\nDESCRIPTION: This snippet shows a simple sequence of Rust identifiers (a, b, c, d, e, f) separated by different types of whitespace (spaces, newlines, tabs). It's designed to illustrate how a lexer would identify and separate these tokens.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/whitespace.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"IDENT \\\"a\\\"\\nWHITESPACE \\\" \\\"\\nIDENT \\\"b\\\"\\nWHITESPACE \\\"  \\\"\\nIDENT \\\"c\\\"\\nWHITESPACE \\\"\\n\\\"\\nIDENT \\\"d\\\"\\nWHITESPACE \\\"\\n\\n\\\"\\nIDENT \\\"e\\\"\\nWHITESPACE \\\"\\t\\\"\\nIDENT \\\"f\\\"\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Default Match Block Trailing Comma Behavior in Rust\nDESCRIPTION: Shows the default match_block_trailing_comma setting (false), which omits trailing commas after block-based match arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_46\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    match lorem {\n        Lorem::Ipsum => {\n            println!(\"ipsum\");\n        }\n        Lorem::Dolor => println!(\"dolor\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Stdarch Tests with GDB\nDESCRIPTION: Commands for debugging stdarch tests using GDB. First specifies the executable path to load symbols properly, then connects to the remote debugging port provided by SDE.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngdb /home/user/projects/rustc_codegen_gcc/build/build_sysroot/sysroot_src/library/stdarch/target/debug/deps/core_arch-fd2d75f89baae5c6\n```\n\nLANGUAGE: bash\nCODE:\n```\ntarget remote :51299\n```\n\n----------------------------------------\n\nTITLE: Installing x.py Tool with Cargo\nDESCRIPTION: This snippet outlines the commands necessary to install the x.py tool from its path using Cargo. It allows users to invoke the script from any subdirectory within the Rust project structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/x/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd rust/src/tools/x/\n$ cargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Example Rust Function Parse Tree\nDESCRIPTION: Shows how a simple Rust function 'fn f() { 90 + 2 }' is parsed into a syntax tree structure, demonstrating the hierarchical representation with nodes, tokens, and whitespace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nFN@0..17\n  FN_KW@0..2 \"fn\"\n  WHITESPACE@2..3 \" \"\n  NAME@3..4\n    IDENT@3..4 \"f\"\n  PARAM_LIST@4..6\n    L_PAREN@4..5 \"(\"\n    R_PAREN@5..6 \")\"\n  WHITESPACE@6..7 \" \"\n  BLOCK_EXPR@7..17\n    L_CURLY@7..8 \"{\"\n    WHITESPACE@8..9 \" \"\n    BIN_EXPR@9..15\n      LITERAL@9..11\n        INT_NUMBER@9..11 \"90\"\n      WHITESPACE@11..12 \" \"\n      PLUS@12..13 \"+\"\n      WHITESPACE@13..14 \" \"\n      LITERAL@14..15\n        INT_NUMBER@14..15 \"2\"\n    WHITESPACE@15..16 \" \"\n    R_CURLY@16..17 \"}\"\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Layout - Tall\nDESCRIPTION: Illustrates the 'Tall' layout for function parameters.  Each parameter is placed on the same line if possible, otherwise each parameter gets its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ntrait Lorem {\n    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);\n\n    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {\n        // body\n    }\n\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n        consectetur: Consectetur,\n        adipiscing: Adipiscing,\n        elit: Elit,\n    );\n\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n        consectetur: Consectetur,\n        adipiscing: Adipiscing,\n        elit: Elit,\n    ) {\n        // body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Rust Toolchain with Rustup\nDESCRIPTION: Create a local toolchain linked to the newly built compiler stage for testing and development\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nrustup toolchain link stage1 build/host/stage1\n```\n\n----------------------------------------\n\nTITLE: Deprecated Range Pattern Syntax in Rust\nDESCRIPTION: Example showing the now-invalid use of ... range pattern syntax in a match expression that will fail to compile with error E0783.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0783.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch 2u8 {\n    0...9 => println!(\"Got a number less than 10\"), // error!\n    _ => println!(\"Got a number 10 or more\"),\n}\n```\n\n----------------------------------------\n\nTITLE: @rustbot Ready Shortcut Command - Markdown\nDESCRIPTION: This snippet demonstrates a shortcut command for quickly marking an issue or PR as ready. It serves as an alternative to the full relabeling command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustbot.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot ready\n```\n\n----------------------------------------\n\nTITLE: Configuring unexpected_cfgs Lint with check-cfg in TOML\nDESCRIPTION: Example of using the check-cfg configuration under the lints.rust.unexpected_cfgs section in Cargo.toml. This is useful for statically known custom configurations that aren't dependent on build scripts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg/cargo-specifics.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_foo)'] }\n```\n\n----------------------------------------\n\nTITLE: Handling Const Expression in Where Clause Bounds in Rust\nDESCRIPTION: This snippet demonstrates the fix for rustfmt incorrectly duplicating where clause bounds when using a const expression. The example shows a struct `S` with a const generic parameter and a where clause bound that uses a const expression. This ensures that the where clause is formatted correctly without duplication.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<const C: usize>\nwhere\n    [(); { num_slots!(C) }]:, {\n    // code ...\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Async Main Function Example in Rust\nDESCRIPTION: This example demonstrates incorrect code that will trigger error E0752. The main function is marked as async, which is not allowed as an entry point in Rust programs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0752.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn main() -> Result<(), ()> { // error!\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Setting HTML favicon in Rust Documentation\nDESCRIPTION: This snippet shows how to set the favicon for generated documentation using the #[doc] attribute, specifying a URL for the favicon image.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(html_favicon_url = \\\"https://example.com/favicon.ico\\\")]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Using Standalone Markdown Files with rustdoc\nDESCRIPTION: This snippet shows how to create a Markdown file and generate HTML documentation from it using rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc README.md\n```\n\n----------------------------------------\n\nTITLE: Implicit Discriminant Conflict in Rust Enum\nDESCRIPTION: This code snippet illustrates how implicit discriminant assignment can lead to conflicts. The first variant X is implicitly assigned 0, which conflicts with the explicit assignment of 0 to Y.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0081.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Bad {\n    X,\n    Y = 0, // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rustdoc with Custom Toolchain in Markdown\nDESCRIPTION: Commands for setting up a custom toolchain in rustup to use a locally-compiled version of rustdoc. This allows developers to test their rustdoc changes on any project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./x setup tools\n./x check rustdoc\n./x build library rustdoc\nlibrary/test\nrustup toolchain link stage2 build/host/stage2\ncargo +stage2 doc\n```\n\n----------------------------------------\n\nTITLE: Trait Bounds Formatting in Rust\nDESCRIPTION: Illustrates the formatting of trait bounds in Rust, including spacing around the colon and plus signs. It also covers line breaking within the bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo: Debug + Bar {}\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Hello World Program\nDESCRIPTION: Simple Rust program that prints 'Hello, world!' to demonstrate basic compilation example\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Building the target with riscv32imc-unknown-nuttx-elf\nDESCRIPTION: This snippet configures the Rust build process to target `riscv32imc-unknown-nuttx-elf`. It specifies the target architecture and sets the linker to `riscv-none-elf-gcc` which is required for linking with C or C++ code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nuttx.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\n[build]\ntarget = \"riscv32imc-unknown-nuttx-elf\"\n\n[target.'riscv32imc-unknown-nuttx-elf']\nlinker = \"riscv-none-elf-gcc\"\n\n```\n\n----------------------------------------\n\nTITLE: Building Cranelift Codegen Backend from Source\nDESCRIPTION: Commands to clone the Cranelift codegen backend repository from GitHub and build it from source using the provided build script.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/rust-lang/rustc_codegen_cranelift\n$ cd rustc_codegen_cranelift\n$ ./y.sh build\n```\n\n----------------------------------------\n\nTITLE: JSON Output for Doctest Information (JSON)\nDESCRIPTION: This JSON snippet shows the output format when using --output-format doctest in Rustdoc. It provides detailed information about the doctest, including its location, attributes, and generated code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"format_version\": 1,\n  \"doctests\": [\n    {\n      \"file\": \"foo.rs\",\n      \"line\": 1,\n      \"doctest_attributes\": {\n        \"original\": \"\",\n        \"should_panic\": false,\n        \"no_run\": false,\n        \"ignore\": \"None\",\n        \"rust\": true,\n        \"test_harness\": false,\n        \"compile_fail\": false,\n        \"standalone_crate\": false,\n        \"error_codes\": [],\n        \"edition\": null,\n        \"added_css_classes\": [],\n        \"unknown\": []\n      },\n      \"original_code\": \"let x = 12;\",\n      \"doctest_code\": \"#![allow(unused)]\\nfn main() {\\nlet x = 12;\\n}\",\n      \"name\": \"foo.rs - Trait (line 1)\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Raw Pointer Assignment in Rust\nDESCRIPTION: Demonstrates the correct way to create a raw pointer by first binding the value to a named local variable, ensuring the value exists for the pointer's lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0745.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn temp_address() {\n    let val = 2;\n    let ptr = &raw const val; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Clippy with format_args Attribute in Rust\nDESCRIPTION: The `#[clippy::format_args]` attribute is used to inform Clippy that a macro supports formatting syntax similar to `format!` or `println!`. This allows Clippy to apply relevant lints to the macro's arguments as if they were being passed to a formatting function.  This is particularly useful for custom macros that handle formatting internally.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/attribs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// A macro that prints a message if a condition is true.\n#[macro_export]\n#[clippy::format_args]\nmacro_rules! print_if {\n    ($condition:expr, $($args:tt)+) => {{\n        if $condition {\n            println!($($args)+)\n        }\n    }};\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Struct from Macro in Rust\nDESCRIPTION: This snippet shows a struct named 'StructFromMacro' which is defined in the context of a macro. It involves unique location data relevant for cases where structs are generated through macro invocation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"StructFromMacro\",\n    def: Adt(\n        Struct(\n            Struct {\n                id: StructId(\n                    0,\n                ),\n            },\n        ),\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: MacroFile(\n            0,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: STRUCT,\n            range: 0..22,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 6..21,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Generic Parameters for Inner Function\nDESCRIPTION: Solution showing how to properly define generic parameters for inner function by copying them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with Doctest (Rust)\nDESCRIPTION: This Rust code snippet shows an example of a trait with a doctest. It's used to demonstrate the output of the --output-format doctest flag in Rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n/// let x = 12;\n/// ```\npub trait Trait {}\n```\n\n----------------------------------------\n\nTITLE: Using the rustc_const_unstable attribute in Rust\nDESCRIPTION: The #[rustc_const_unstable] attribute marks a const fn as having unstable constness. It's used for functions that use unstable language features or intrinsics, or when a stable function is not yet intended to be const-stable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stability.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_const_unstable(feature = \"foo\", issue = \"1234\", reason = \"lorem ipsum\")]\n```\n\n----------------------------------------\n\nTITLE: DiscoverArgument Enum for Passing Arguments to Workspace Discovery Command in Rust\nDESCRIPTION: Rust enum representing the argument types that can be passed to the rust-analyzer workspace discovery command. It supports specifying a Path to generate rust-project.json or a Buildfile to update an existing workspace. Serialization uses camelCase for variant names, facilitating JSON communication with the discovery process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Clone, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum DiscoverArgument {\n   Path(AbsPathBuf),\n   Buildfile(AbsPathBuf),\n}\n```\n\n----------------------------------------\n\nTITLE: Measure From-Scratch Analysis Time\nDESCRIPTION: This snippet shows how to measure the time it takes for a from-scratch analysis using `cargo run` with the `analysis-stats` subcommand.  It runs the rust-analyzer on the chalk project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --release -p rust-analyzer -- analysis-stats ../chalk/\n```\n\n----------------------------------------\n\nTITLE: Generating Dataflow Graph Visualizations in Rust Compiler\nDESCRIPTION: This `#[rustc_mir]` attribute, applied to a function, instructs the compiler to generate Graphviz `.dot` files visualizing the MIR control-flow graph annotated with dataflow analysis results (entry state, gen/kill sets). The value provided is a path suffix, and the compiler prepends the analysis name (e.g., 'maybe_init') to this suffix to create output filenames like `/path/to/maybe_init_suffix.dot` for each active analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/mir-dataflow/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[rustc_mir(borrowck_graphviz_postflow=\"/path/to/suffix.dot\")]\n```\n\n----------------------------------------\n\nTITLE: Cross-compiling with cargo\nDESCRIPTION: This command uses cargo and the specified stage1 toolchain to build the current crate for the wasm32-wasip1 target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncargo +stage1 build --target wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Running Customized Speedtest with Specific Iterations\nDESCRIPTION: Command to run speed tests with a custom number of iterations (100) for TOML-based tests, specifically for tests named 'semicolon_block'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/speedtest.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ SPEEDTEST=toml SPEEDTEST_ITERATIONS=100 TESTNAME=\"semicolon_block\" cargo uitest\n```\n\n----------------------------------------\n\nTITLE: Erroneous Manual Implementation of FnOnce Trait in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to manually implement the FnOnce trait for a custom struct. It fails because manual implementation of Fn* traits requires unstable features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0183.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyClosure {\n    foo: i32\n}\n\nimpl FnOnce<()> for MyClosure {  // error\n    type Output = ();\n    extern \"rust-call\" fn call_once(self, args: ()) -> Self::Output {\n        println!(\"{}\", self.foo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing `ty` module in Rust\nDESCRIPTION: This code snippet shows the typical import convention for the `ty` module in the Rust compiler.  It imports the module itself (`ty`), along with the `Ty` and `TyCtxt` types directly. Other types are often referenced with an explicit `ty::` prefix.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"use ty::{self, Ty, TyCtxt};\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Deep Normalization in Rust's Type System\nDESCRIPTION: This code snippet demonstrates how deep normalization is implemented by walking over a type and using structural normalization for each encountered alias. It handles ambiguity by immediately failing if encountered.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/normalization.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Source: generalize-no-alias\nif let Some(alias) = self.var_value(v).as_alias() {\n    let normalized = self.relate_alias_to_var(alias, v)?;\n    self.equate(v, normalized)\n} else {\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Rust FileSymbol for Another Struct\nDESCRIPTION: This snippet showcases another `FileSymbol` instance, this time representing a struct named `ThisStruct`. Similar to the previous struct example, it contains the struct's definition, location, and flags. The `DeclarationLocation` specifies the `USE_TREE` kind and the range of the struct's name within the code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n{\n    name: \"ThisStruct\",\n    def: Adt(\n        Struct(\n            Struct {\n                id: StructId(\n                    4,\n                ),\n            },\n        ),\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                1,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: USE_TREE,\n            range: 85..125,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 115..125,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Imports in a Loop (Rust)\nDESCRIPTION: This code implements name resolution by looping through and resolving all imports until reaching a fixed point. It handles the process of resolving module references incrementally.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres/collector.rs#L404-L437\n```\n\n----------------------------------------\n\nTITLE: Defining wasi-root in bootstrap.toml\nDESCRIPTION: This snippet shows how to specify the `wasi-root` path in `bootstrap.toml` for building the `wasm32-wasip1-threads` target. This setup is required to ensure that the toolchain can locate the WASI libc sysroot. Relevant for users building this target with the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1-threads.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[target.wasm32-wasip1-threads]\nwasi-root = \".../wasi-libc/sysroot\"\n\n```\n\n----------------------------------------\n\nTITLE: Correct Array Pattern Matching in Rust\nDESCRIPTION: Shows the proper way to perform pattern matching on an array, ensuring type consistency between the pattern and the matched expression\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0529.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet r = [1.0, 2.0];\nmatch r {\n    [a, b] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Positioning Error Annotations Above Error Line in Rust UI Tests\nDESCRIPTION: Shows how to use the //~v idiom to indicate errors on lines below the annotation. Particularly useful for lexer or parser errors occurring at the end of a file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// ignore-tidy-trailing-newlines\n//~v ERROR this file contains an unclosed delimiter\nfn main((ۼ\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Input Operand Constraint in llvm_asm Macro (Rust)\nDESCRIPTION: This code snippet shows an erroneous example of using the llvm_asm macro with an invalid input operand constraint. The constraint \"=test\" is not a valid LLVM constraint, causing a compiler error. This error is no longer emitted by the current Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0662.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nllvm_asm!(\"xor %eax, %eax\"\n          :\n          : \"=test\"(\"a\")\n         );\n```\n\n----------------------------------------\n\nTITLE: Basic Self-Profile Events Usage in Rust\nDESCRIPTION: Demonstrates how to enable the self-profiler with specific event types using the -Zself-profile-events flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile-events.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -Zself-profile -Zself-profile-events=default,args\n```\n\n----------------------------------------\n\nTITLE: Declaring a Custom Lint in Rust\nDESCRIPTION: This code declares a custom lint named `WHILE_TRUE` using the `declare_lint!` macro. The lint warns against the use of `while true {}` loops, suggesting `loop {}` instead. It registers the lint with a lint pass struct and implements the `EarlyLintPass` trait to provide custom behavior. The code utilizes dependencies such as `ast::Expr` and `EarlyContext`. This snippet requires familiarity with Rust's AST and lint trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// Declare a lint called `WHILE_TRUE`\ndeclare_lint! {\n    WHILE_TRUE,\n\n    // warn-by-default\n    Warn,\n\n    // This string is the lint description\n    \"suggest using `loop { }` instead of `while true { }`\"\n}\n\n// This declares a struct and a lint pass, providing a list of associated lints. The\n// compiler currently doesn\\'t use the associated lints directly (e.g., to not\n// run the pass or otherwise check that the pass emits the appropriate set of\n// lints). However, it\\'s good to be accurate here as it\\'s possible that we\\'re\n// going to register the lints via the get_lints method on our lint pass (that\n// this macro generates).\ndeclare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n\n// Helper function for `WhileTrue` lint.\n// Traverse through any amount of parenthesis and return the first non-parens expression.\nfn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n    while let ast::ExprKind::Paren(sub) = &expr.kind {\n        expr = sub;\n    }\n    expr\n}\n\n// `EarlyLintPass` has lots of methods. We only override the definition of\n// `check_expr` for this lint because that\\'s all we need, but you could\n// override other methods for your own lint. See the rustc docs for a full\n// list of methods.\nimpl EarlyLintPass for WhileTrue {\n    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n        if let ast::ExprKind::While(cond, ..) = &e.kind\n            && let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind\n            && let ast::LitKind::Bool(true) = lit.kind\n            && !lit.span.from_expansion()\n        {\n            let condition_span = cx.sess.source_map().guess_head_span(e.span);\n            cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                lint.build(fluent::example::use_loop)\n                    .span_suggestion_short(\n                        condition_span,\n                        fluent::example::suggestion,\n                        \"loop\".to_owned(),\n                        Applicability::MachineApplicable,\n                    )\n                    .emit();\n            })\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Macro in Rust\nDESCRIPTION: In this snippet, a macro named 'Macro' is defined with details about its declaration and location. As a macro, this allows for metaprogramming capabilities in Rust, influencing code generation patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"Macro\",\n    def: Macro(\n        Macro {\n            id: Macro2Id(\n                Macro2Id(\n                    0,\n                ),\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: MACRO_DEF,\n            range: 153..168,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 159..164,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust FileSymbol for Macro\nDESCRIPTION: This snippet represents a `FileSymbol` for a macro named `SuperItemLikeMacro`. It shows the macro's definition as `Macro(Macro { id: Macro2Id(...) })` and its location details, including the `USE_TREE` kind and the name's range within the file. The location information describes where the macro is defined within the Rust project's source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{\n    name: \"SuperItemLikeMacro\",\n    def: Macro(\n        Macro {\n            id: Macro2Id(\n                Macro2Id(\n                    0,\n                ),\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                1,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: USE_TREE,\n            range: 35..69,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 51..69,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Type Punctuation Density in Rust\nDESCRIPTION: Shows the effect of the 'type_punctuation_density' option. 'Wide' (default) wraps '+' and '=' in spaces, while 'Compressed' removes these spaces.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_73\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<Ipsum: Dolor + Sit = Amet>() {\n    // body\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<Ipsum: Dolor+Sit=Amet>() {\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Test - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `test` crate (index 8). It includes the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate provides the testing framework.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n8: CrateData {\n    root_file_id: FileId(\n        9,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"test\",\n            ),\n            canonical_name: \"test\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Test,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Should Panic Test Example\nDESCRIPTION: Shows how to write a test that expects a panic using the #[should_panic] attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\n#[should_panic]\nfn foo() {\n    panic!(\"intentional\");\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Rust Hello World Example with MIR Debugging\nDESCRIPTION: Shows a minimal Rust program and how to generate MIR dump files for the `main` function, illustrating the use of `-Z dump-mir` flag and directory contents of generated MIR files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\ncat > foo.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n^D\nrustc -Z dump-mir=main foo.rs\nls mir_dump/* | wc -l\n```\n\n----------------------------------------\n\nTITLE: Installing Rust from Source Using Bash\nDESCRIPTION: This snippet provides the command to install Rust and its associated tools by building from source. The command `./x install` should be executed in a configured environment where the Rust source and build tools are available. Additionally, users can specify a custom installation path using the `DESTDIR` environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/build-install-distribution-artifacts.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./x install\n```\n\n----------------------------------------\n\nTITLE: Converting Tuple Return Type to Struct in Rust\nDESCRIPTION: Replaces a function's tuple return type with a custom struct to enhance clarity and maintainability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nfn bar() {\n    let FooResult(a, b, c) = foo();\n}\n\nstruct FooResult(u32, u32, u32);\n\nfn foo() -> FooResult {\n    FooResult(1, 2, 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Async Function with Elided Lifetime in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous example where an argument lifetime is elided in an async function, causing a compilation error. The struct 'Content' has a lifetime parameter, but the async function 'create' doesn't specify it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0726.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::executor::block_on;\nstruct Content<'a> {\n    title: &'a str,\n    body: &'a str,\n}\nasync fn create(content: Content) { // error: implicit elided\n                                    // lifetime not allowed here\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\nlet content = Content { title: \"Rust\", body: \"is great!\" };\nlet future = create(content);\nblock_on(future);\n```\n\n----------------------------------------\n\nTITLE: Publishing Fuchsia Package to Repository\nDESCRIPTION: Command to publish the Fuchsia package to the created repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx repository publish \\\n    --package pkg/hello_fuchsia_package_manifest \\\n    pkg/repo\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Compiler for OpenBSD Targets in TOML\nDESCRIPTION: This configuration snippet in TOML is used to enable OpenBSD targets for a Rust compiler build. It requires specifying the target architecture in the 'build' section and setting the appropriate C compiler for the target in the corresponding target section. The snippet is crucial for both native compilation and cross-compilation using Rust on OpenBSD platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openbsd.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"$ARCH-unknown-openbsd\"]\n\n[target.$ARCH-unknown-openbsd]\ncc = \"$ARCH-openbsd-cc\"\n```\n\n----------------------------------------\n\nTITLE: Larger Stack Allocation in Rust\nDESCRIPTION: This Rust code example allocates a larger array on the stack to demonstrate how the stack probe mechanism changes for larger allocations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v: [u8; 65536] = [1; 65536];\n    let first = &v[0];\n    println!(\"The first element is: {first}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Visibility Scope using Modules in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to define a visibility scope using a module in Rust. The struct `Shark` is declared within the module `sea`, and its visibility is restricted to the path `crate::sea`. This is valid because `sea` is a module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0577.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```edition2018\npub mod sea {\n    pub (in crate::sea) struct Shark; // ok!\n}\n\nfn main() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Message Structure Example\nDESCRIPTION: This snippet illustrates the structure of a typical diagnostic message in the Rust compiler, including the level, code, message, diagnostic window (with spans and labels), and sub-diagnostics. Understanding this structure is crucial for creating clear and informative error messages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n\"error[E0000]: main error message\n  --> file.rs:LL:CC\n   |\nLL | <code>\n   | -^^^^- secondary label\n   |  |\n   |  primary label\n   |\n   = note: note without a `Span`, created with `.note`\nnote: sub-diagnostic message for `.span_note`\n  --> file.rs:LL:CC\n   |\nLL | more code\n   |      ^^^^\"\n```\n\n----------------------------------------\n\nTITLE: Using Complete Inclusive Range in Rust\nDESCRIPTION: This solution shows how to properly use an inclusive range by specifying both start and end values. The inclusive range operator (..=) includes both the start and end indices in the resulting slice.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0586.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n    let x = &tmp[1..=3]; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Salsa in Rust\nDESCRIPTION: Example of how to import and use Salsa in a Rust project. This code snippet is inferred from the context, as no actual code is provided in the README.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ra-salsa/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse salsa::Database;\n\n// Define your queries here\n\nfn main() {\n    // Initialize and use Salsa database\n}\n```\n\n----------------------------------------\n\nTITLE: Preserve Import Granularity in Rust\nDESCRIPTION: Shows the default imports_granularity setting (Preserve), which maintains the original grouping and structure of import statements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_50\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::b;\nuse foo::b::{f, g};\nuse foo::{a, c, d::e};\nuse qux::{h, i};\n```\n\n----------------------------------------\n\nTITLE: Combining Compiler Lint Passes\nDESCRIPTION: This code snippet describes the registration of multiple lint passes into a single combined lint pass for performance improvements in the Rust compiler. This approach minimizes the overhead of managing numerous individual lint passes while utilizing static dispatch for runtime efficiency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/lintstore.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// Example of combining lint passes\nstruct BuiltinCombinedModuleLateLintPass;\nimpl LintPass for BuiltinCombinedModuleLateLintPass {\n    fn name(&self) -> &'static str {\n        \"CombinedLate\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Partial Reinitialization in Rust\nDESCRIPTION: Shows an invalid attempt to partially reinitialize a structure after it has been dropped. The code fails because it tries to modify a field of an uninitialized structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0383.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x); // `x` is now uninitialized\nx.a = 2; // error, partial reinitialization of uninitialized structure `t`\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Output from Basic #[rustc_on_unimplemented] Example\nDESCRIPTION: Shows the resulting compiler error message when the custom trait with #[rustc_on_unimplemented] is used incorrectly. This demonstrates how the custom error message is integrated into the compiler's output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: the trait bound `&[{integer}]: MyIterator<char>` is not satisfied\n  --> <anon>:14:5\n   |\n14 |     iterate_chars(&[1, 2, 3][..]);\n   |     ^^^^^^^^^^^^^ an iterator over elements of type `char` cannot be built from a collection of type `&[{integer}]`\n   |\n   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n   = note: required by `iterate_chars`\n```\n\n----------------------------------------\n\nTITLE: Extending Rustdoc CSS\nDESCRIPTION: This code snippet shows how to use the `-e` or `--extend-css` flag to extend rustdoc's CSS by including the contents of specified files at the bottom of the `theme.css` file. This enables customization of the documentation's appearance.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -e extra.css\n$ rustdoc src/lib.rs --extend-css extra.css\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Definition with Unique Discriminants in Rust\nDESCRIPTION: This code snippet demonstrates a correct enum definition where each variant has a unique discriminant value, either explicitly assigned or implicitly derived.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0081.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum {\n    P,\n    X = 3, // ok!\n    Y = 5,\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Insufficient Elements in Rust\nDESCRIPTION: This code snippet demonstrates a pattern matching error in Rust, where the pattern requires more elements than are present in the matched array. It highlights the importance of ensuring that an array has enough elements to satisfy the pattern's requirements. The error occurs because the array 'r' has only 2 elements, while the pattern demands at least 3.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0528.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncompile_fail,E0528\nlet r = &[1, 2];\nmatch r {\n    &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\n                               //        elements but array has 2\n        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Constant Public in Rust\nDESCRIPTION: This snippet shows how to modify the visibility of a constant in Rust by using the `pub` keyword, allowing the constant to be accessed outside of its defining module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0603.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Core - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `core` crate (index 1). It specifies the Rust edition (`Edition2021`), compiler configuration flags (`debug_assertions`, `miri`, `true`), and lists no explicit dependencies within this definition. As a fundamental crate, many other crates depend on `core`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n1: CrateData {\n    root_file_id: FileId(\n        2,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"core\",\n            ),\n            canonical_name: \"core\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Core,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Unsafe with Inherent Implementation in Rust\nDESCRIPTION: This code snippet demonstrates an error (E0197) where an inherent implementation is incorrectly marked as unsafe. Inherent implementations cannot be unsafe because they don't implement unsafe traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0197.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nunsafe impl Foo { } // error!\n```\n\n----------------------------------------\n\nTITLE: Cross-Compilation and Simulation Setup for SPARC\nDESCRIPTION: This `.cargo/config.toml` file sets up cross-compilation for the SPARC architecture using the Gaisler BCC2 toolchain and the TSIM Leon3 simulator. The configuration also specifies `libcore` options for adaptability to SPARC V8 instructions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_3\n\nLANGUAGE: TOML\nCODE:\n```\n[target.sparc-unknown-none-elf]\nlinker = \"sparc-gaisler-elf-gcc\"\nrunner = \"tsim-leon3\"\n\n[build]\ntarget = [\"sparc-unknown-none-elf\"]\nrustflags = \"-Ctarget-cpu=leon3\"\n\n[unstable]\nbuild-std = [\"core\"]\n```\n\n----------------------------------------\n\nTITLE: Running Bootstrap with Detailed Logging\nDESCRIPTION: This snippet demonstrates how to invoke the Rust bootstrap process with verbosity using the --dry-run flag. The command initiates bootstrap to run through all recursive dependency calculations, providing detailed logging without executing cargo or the compiler. Requires Rust to be installed with a built bootstrap. Expected output includes internal command run logs and details about different steps.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/debugging-bootstrap.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ./x dist rustc --dry-run -vv\nlearning about cargo\nrunning: RUSTC_BOOTSTRAP=\\\"1\\\" \\\"/home/jyn/src/rust2/build/x86_64-unknown-linux-gnu/stage0/bin/cargo\\\" \\\"metadata\\\" \\\"--format-version\\\" \\\"1\\\" \\\"--no-deps\\\" \\\"--manifest-path\\\" \\\"/home/jyn/src/rust2/Cargo.toml\\\" (failure_mode=Exit) (created at src/bootstrap/src/core/metadata.rs:81:25, executed at src/bootstrap/src/core/metadata.rs:92:50)\nrunning: RUSTC_BOOTSTRAP=\\\"1\\\" \\\"/home/jyn/src/rust2/build/x86_64-unknown-linux-gnu/stage0/bin/cargo\\\" \\\"metadata\\\" \\\"--format-version\\\" \\\"1\\\" \\\"--no-deps\\\" \\\"--manifest-path\\\" \\\"/home/jyn/src/rust2/library/Cargo.toml\\\" (failure_mode=Exit) (created at src/bootstrap/src/core/metadata.rs:81:25, executed at src/bootstrap/src/core/metadata.rs:92:50)\n> Assemble { target_compiler: Compiler { stage: 1, host: x86_64-unknown-linux-gnu } }\n  > Libdir { compiler: Compiler { stage: 1, host: x86_64-unknown-linux-gnu }, target: x86_64-unknown-linux-gnu }\n    > Sysroot { compiler: Compiler { stage: 1, host: x86_64-unknown-linux-gnu }, force_recompile: false }\nRemoving sysroot /home/jyn/src/rust2/build/tmp-dry-run/x86_64-unknown-linux-gnu/stage1 to avoid caching bugs\n    < Sysroot { compiler: Compiler { stage: 1, host: x86_64-unknown-linux-gnu }, force_recompile: false }\n  < Libdir { compiler: Compiler { stage: 1, host: x86_64-unknown-linux-gnu }, target: x86_64-unknown-linux-gnu }\n...\n```\n\n----------------------------------------\n\nTITLE: Invalid SIMD Tuple Struct Implementation\nDESCRIPTION: Example showing incorrect usage of #[repr(simd)] attribute with non-machine type (String). This code fails compilation with error E0077 because SIMD operations require machine types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0077.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad([String; 2]); // error!\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for MIPS R6 in bootstrap.toml\nDESCRIPTION: Disables debug info generation and warnings to work around LLVM bugs and compilation issues for MIPS R6 targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\ndebug = false\ndebug-info-level = 0\n\n[rust]\ndeny-warnings = false\n```\n\n----------------------------------------\n\nTITLE: Observing Integer Overflow Checks with Debug Assertions Enabled\nDESCRIPTION: Example showing how the Rust compiler handles integer overflow when debug assertions are enabled. The program panics with an 'attempt to add with overflow' error when overflow is detected.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run\n   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.23s\n     Running `target/debug/hello-rust-integer`\nthread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n```\n\n----------------------------------------\n\nTITLE: Configuring Clippy Lints in Source Code\nDESCRIPTION: Example of configuring lint levels directly in Rust source code using attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(clippy::style)]\n\n#[warn(clippy::box_default)]\nfn main() {\n    let _ = Box::<String>::new(Default::default());\n    // ^ warning: `Box::new(_)` of default value\n}\n```\n\n----------------------------------------\n\nTITLE: LSP Message Handling in Main Loop (Rust)\nDESCRIPTION: This code handles incoming messages from the language client, forming the entry point for LSP requests including completion. It processes client messages and dispatches them appropriately.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L213\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Program for m68k Linux\nDESCRIPTION: Command to compile a Rust program targeting the m68k-unknown-linux-gnu platform using rustc\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nrustc --target m68k-unknown-linux-gnu your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Starting Local HTTP Server for Rustdoc Testing\nDESCRIPTION: Commands to generate documentation and start a local HTTP server for testing rustdoc HTML features that require local storage across pages. The server allows browsing the documentation as if it were hosted online.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./x doc library\n# The documentation has been generated into `build/[YOUR ARCH]/doc`.\n$ python3 -m http.server -d build/[YOUR ARCH]/doc\n```\n\n----------------------------------------\n\nTITLE: Rust: Inspecting Dataflow Results with ResultsCursor\nDESCRIPTION: This code snippet demonstrates how to inspect the fixpoint state of a dataflow analysis using a `ResultsCursor`. It iterates to fixpoint, creates a `ResultsCursor`, and then seeks to the location immediately before each `Drop` terminator to retrieve and print the corresponding dataflow state.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/dataflow.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nlet mut results = MyAnalysis::new()\n    .into_engine(tcx, body, def_id)\n    .iterate_to_fixpoint()\n    .into_results_cursor(body);\n\n// Inspect the fixpoint state immediately before each `Drop` terminator.\nfor (bb, block) in body.basic_blocks().iter_enumerated() {\n    if let TerminatorKind::Drop { .. } = block.terminator().kind {\n        results.seek_before_primary_effect(body.terminator_loc(bb));\n        let state = results.get();\n        println!(\"state before drop: {:#?}\", state);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Range Expression with Binary Operation\nDESCRIPTION: Shows proper spacing in range expressions when the right-hand side contains a binary expression with trailing period.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet range = 3. / 2. ..4.;\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Return Types Without Static Lifetime\nDESCRIPTION: Examples showing incorrect implementations of functions returning trait objects and impl Trait without proper lifetime bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0759.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Debug;\n\nfn foo(x: &i32) -> impl Debug { // error!\n    x\n}\n\nfn bar(x: &i32) -> Box<dyn Debug> { // error!\n    Box::new(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Tests on Miri\nDESCRIPTION: This snippet demonstrates how to use the `cfg(miri)` conditional compilation flag to ignore tests that are known to fail under Miri.  This is useful when tests rely on features not supported by Miri. This allows running other tests without failures due to unsupported features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"#[test]\n#[cfg_attr(miri, ignore)]\nfn does_not_work_on_miri() {\n    tokio::run(futures::future::ok::<_, ()>(()));\n}\"\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_LOG environment variable for crate/module and function-level tracing\nDESCRIPTION: This bash command sets the `RUSTC_LOG` environment variable to enable tracing for a specific function `do_mir_borrowck` within the `rustc_borrowck` crate/module. This reduces the verbosity of the logs compared to tracing the entire function without the crate/module context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_LOG=rustc_borrowck[do_mir_borrowck]\n```\n\n----------------------------------------\n\nTITLE: Checking LLVM CFI in ELF Binary\nDESCRIPTION: This command uses readelf to check if LLVM Control Flow Integrity (CFI) is enabled in a compiled Rust binary by looking for symbols suffixed with '.cfi'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -s -W target/release/hello-rust | grep \"\\.cfi\"\n     5: 0000000000006480   657 FUNC    LOCAL  DEFAULT   15 _ZN10hello_rust4main17h4e359f1dcd627c83E.cfi\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust for Armv7 Target\nDESCRIPTION: This snippet illustrates the configuration needed in 'bootstrap.toml' to enable the cross-compilation target for Rust. It specifies the target architecture and the C compiler path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabihf.md#2025-04-21_snippet_0\n\nLANGUAGE: Toml\nCODE:\n```\n[build]\ntarget = [\"armv7-unknown-linux-uclibceabihf\"]\nstage = 2\n\ntarget.armv7-unknown-linux-uclibceabihf\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\ncc = \"/TOOLCHAIN_PATH/bin/arm-buildroot-linux-uclibcgnueabihf-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Cloning Element from a Non-Copy Fixed-Size Array in Rust\nDESCRIPTION: This snippet shows how to clone an element from a non-copy fixed-size array if the type implements the `Clone` trait. The `NonCopy` struct is derived from `Clone`, allowing developers to create a separate instance of the value while still adhering to ownership rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0508.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone)]\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    // Now you can clone the array element.\n    let _value = array[0].clone();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Lints in Clippy's Main Module\nDESCRIPTION: Example showing how lints are registered in Clippy's main module. This snippet demonstrates how the 'else_if_without_else' lint is imported and registered with the LintStore using the register_early_pass function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// ./clippy_lints/src/lib.rs\n\n// ...\npub mod else_if_without_else;\n// ...\n\npub fn register_lints(store: &mut rustc_lint::LintStore, conf: &'static Conf) {\n    // ...\n    store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Lifetime Parameter in Rust\nDESCRIPTION: This snippet defines a trait called Trait that has a lifetime parameter 'a. It establishes the structure for implementing traits that require lifetimes for their types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait<'a> {}\n```\n\n----------------------------------------\n\nTITLE: Desugaring a Generic Function with Lifetimes in Rust\nDESCRIPTION: This snippet illustrates how a function `foo` that takes a reference to a type `T` with an associated lifetime parameter `a` is desugared to a function item type. It explains the absence of the lifetime in the item type and its implications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, T: Sized>(a: &'a T) -> &'a T {\n    # a\n    /* snip */\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Patched git-subtree Script for Rust Repository\nDESCRIPTION: This snippet describes how to replace the existing git-subtree script with a patched version to fix bugs when working with large repositories like rust-lang/rust. It includes copying the patched script into the git-core directory, setting proper permissions, and ensuring correct ownership. Additional notes address running the first cache build with increased stack size and modifying scripts for Debian's dash shell environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/sync.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo cp --backup /path/to/patched/git-subtree.sh /usr/lib/git-core/git-subtree\nsudo chmod --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\nsudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\n```\n\n----------------------------------------\n\nTITLE: Pushing Allocations to the Call Site\nDESCRIPTION: This snippet shows how to avoid hidden allocations by allowing callers to handle resource allocation when it's necessary, thus revealing costs and improving efficiency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nfn frobnicate(s: String) {\n    ...\n}\n\n// BAD\nfn frobnicate(s: &str) {\n    let s = s.to_string();\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Generic Parameter Indexing in Rust\nDESCRIPTION: Demonstrates how indices are assigned to generic parameters in Rust, considering parameters defined in outer scopes. Within the `method`'s scope, `X` (from the `impl`) has index 0, `Y` (from the `impl`) has index 1, and `Z` (from the `method`) has index 2, reflecting the cumulative order of parameter declarations starting from the relevant `impl` block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/param_ty_const_regions.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<A, B> {\n  // A would have index 0\n  // B would have index 1\n\n  .. // some fields\n}\nimpl<X, Y> Foo<X, Y> {\n  fn method<Z>() {\n    // inside here, X, Y and Z are all in scope\n    // X has index 0\n    // Y has index 1\n    // Z has index 2\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Stability Attributes - Corrected Example\nDESCRIPTION: This snippet provides the corrected version of the previous example, demonstrating how to declare stability attributes correctly by ensuring that only one stability attribute is applied to the function. It shows the validation of the second stability attribute in the context of the specialty feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0544.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#!['feature(staged_api)']\n#!['allow(internal_features)']\n#!['stable(since = \"1.0.0\", feature = \"rust1\")']\n\n#[stable(feature = \"test\", since = \"2.0.0\")] // ok!\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Capturing Rust Compiler Diagnostics using rustc_interface\nDESCRIPTION: This code demonstrates how to configure rustc_interface to intercept diagnostics that would normally go to stderr. It sets up a compiler session with a custom diagnostic handler that outputs to a buffer, then runs the type checker on each item to generate diagnostics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/getting-diagnostics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../examples/rustc-interface-getting-diagnostics.rs}}\n```\n\n----------------------------------------\n\nTITLE: Building a Rust Binary\nDESCRIPTION: This shell command compiles the Rust project for the x86_64-unknown-fuchsia target, creating a binary in the target directory. Ensure all configurations and dependencies are set up prior to building.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --target x86_64-unknown-fuchsia\n```\n\n----------------------------------------\n\nTITLE: Testing Dependency Graph for Non-Changed Action in Rust\nDESCRIPTION: This snippet illustrates using the `#[rustc_then_this_would_need]` annotation to ensure that if `foo` is changed, then `baz` does not require any changes. The macro should produce an error stating 'no path' if executed correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\nfn baz() { }\n```\n\n----------------------------------------\n\nTITLE: Result of Argument Parsing for Doctest Compilation\nDESCRIPTION: This snippet shows the result of parsing the example argument string for doctest compilation. It demonstrates how arguments are split based on quotes and whitespace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_37\n\nLANGUAGE: text\nCODE:\n```\n[\n    \"hello 'a'\\\" ok\",\n    \"how\",\n    \"are\",\n    \"you today?\",\n]\n```\n\n----------------------------------------\n\nTITLE: Building and running the parameter count mismatch example without CFI\nDESCRIPTION: Shell commands showing how to build and run the parameter count mismatch example without CFI protection. Without CFI, the invalid function call is allowed and produces a result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --release\n   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)\n    Finished release [optimized] target(s) in 0.43s\n     Running `target/release/rust-cfi-2`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nThe next answer is: 14\n$\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Settings for PowerPC64LE Target\nDESCRIPTION: This snippet configures the C compiler and linker settings for the powerpc64le target in the `config.toml` file. It specifies the appropriate tools required for building Rust programs on this architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64le-unknown-linux-gnu.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.powerpc64le-unknown-linux-gnu]\ncc = \"powerpc64le-linux-gnu-gcc\"\ncxx = \"powerpc64le-linux-gnu-g++\"\nar = \"powerpc64le-linux-gnu-ar\"\nlinker = \"powerpc64le-linux-gnu-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Localhost Network Configuration\nDESCRIPTION: Sequence of commands to resolve localhost networking issues by updating /etc/hosts\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nping localhost\necho \"127.0.0.1 localhost\" >> /etc/hosts\nping localhost\n```\n\n----------------------------------------\n\nTITLE: AstIdMap Query Implementation (Rust)\nDESCRIPTION: This function implements the ast_id_map query that produces the mapping from position-independent AstIds to position-dependent syntax nodes during the lowering process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree/lower.rs#L32\n```\n\n----------------------------------------\n\nTITLE: Using error-pattern Directive for Runtime Messages in Rust UI Tests\nDESCRIPTION: Shows how to use the error-pattern directive for testing runtime errors that don't have specific spans. This approach is useful when line annotations cannot be applied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n//@ error-pattern: index out of bounds\nfn main() {\n    let a: *const [_] = &[1, 2, 3];\n    unsafe {\n        let _b = (*a)[3];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Standalone Lint\nDESCRIPTION: This command, run using the Clippy dev tools, is used to create a new standalone lint in a Clippy project.  It sets the lint name, pass type (late), and category (pedantic). The command generates the necessary boilerplate code and modifies relevant project files, and the output files are listed in the comments following the shell script.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/defining_lints.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo dev new_lint --name=lint_name --pass=late --category=pedantic\n```\n\n----------------------------------------\n\nTITLE: Debugging Evaluation Errors in Miri\nDESCRIPTION: This command provides a backtrace for debugging evaluation errors that occur during the running of Miri.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nMIRI_BACKTRACE=1\n```\n\n----------------------------------------\n\nTITLE: Installing Atom-Beautify Package\nDESCRIPTION: Command to install the atom-beautify package in Atom for Rust code formatting functionality\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/atom.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\napm install atom-beautify\n```\n\n----------------------------------------\n\nTITLE: Building and Using Cross-Compiling libgccjit for Rust\nDESCRIPTION: Set of commands to configure rustc_codegen_gcc for cross-compilation, including preparing the sysroot, building for specific targets, and handling custom target specification files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./y.sh prepare --cross\n./y.sh build --sysroot --target-triple m68k-unknown-linux-gnu\nOVERWRITE_TARGET_TRIPLE=m68k-unknown-linux-gnu ../y.sh cargo build --target m68k-unknown-linux-gnu\n\n# For targets not supported by Rust compiler, using a target specification file:\n./y.sh build --sysroot --target-triple m68k-unknown-linux-gnu --target $(pwd)/m68k-unknown-linux-gnu.json\nOVERWRITE_TARGET_TRIPLE=m68k-unknown-linux-gnu ../y.sh cargo build --target path/to/m68k-unknown-linux-gnu.json\n```\n\n----------------------------------------\n\nTITLE: Correct Label Declaration in Rust Loop\nDESCRIPTION: Example showing the correct way to declare and use a label in a Rust loop. The label 'a is properly declared before the loop statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0426.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n'a: loop {\n    break 'a; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Lint Check Conflict Using deny Instead of forbid in Rust\nDESCRIPTION: Demonstrates how to fix the lint check conflict by using deny instead of forbid, which allows the inner lint check attribute to override the outer directive.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0453.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![deny(non_snake_case)]\n\n#[allow(non_snake_case)]\nfn main() {\n    let MyNumber = 2; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Constant Evaluation Functions in Rust Compiler\nDESCRIPTION: Key functions for evaluating constants at compile time, providing different evaluation strategies for type system and runtime optimizations\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/const-eval.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst_eval_global_id_for_typeck\n```\n\nLANGUAGE: rust\nCODE:\n```\nconst_eval_global_id\n```\n\nLANGUAGE: rust\nCODE:\n```\neval_static_initializer\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of + Type Operator in Rust\nDESCRIPTION: Example showing the correct usage of the + type operator with proper parentheses to resolve ambiguity in type declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0178.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nstruct Bar<'a> {\n    x: &'a (Foo + 'a),     // ok!\n    y: &'a mut (Foo + 'a), // ok!\n    z: fn() -> (Foo + 'a), // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Pinging LLVM Icebreakers Group in Rust Project\nDESCRIPTION: Command to ping the LLVM Icebreakers Notification group using rustbot in GitHub issues or pull requests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/llvm.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot ping icebreakers-llvm\n```\n\n----------------------------------------\n\nTITLE: Solution: Declaring a Const Function in Rust\nDESCRIPTION: The correct approach to fix the E0015 error by declaring 'create_some' as a const function using the 'const' keyword before 'fn'. This allows the function to be used in constant expressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0015.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// declared as a `const` function:\nconst fn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // no error!\n```\n\n----------------------------------------\n\nTITLE: Using `#[doc(cfg)]` to specify platform requirements\nDESCRIPTION: This Rust snippet shows how to use `#[doc(cfg(...))]` to specify the platforms on which an item is available. This affects doctest execution and documentation rendering. It requires the `doc_cfg` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(doc_cfg)]\n\n/// Token struct that can only be used on Windows.\n#[cfg(any(windows, doc))]\n#[doc(cfg(windows))]\npub struct WindowsToken;\n\n/// Token struct that can only be used on Unix.\n#[cfg(any(unix, doc))]\n#[doc(cfg(unix))]\npub struct UnixToken;\n\n/// Token struct that is only available with the `serde` feature\n#[cfg(feature = \"serde\")]\n#[doc(cfg(feature = \"serde\"))]\n#[derive(serde::Deserialize)]\npub struct SerdeToken;\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Function Pointer Type Patterns in Rust\nDESCRIPTION: Demonstrates erroneous function pointer type definitions with patterns that are not allowed, such as using mutable parameters or reference patterns\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0561.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype A1 = fn(mut param: u8); // error!\ntype A2 = fn(&param: u32); // error!\n```\n\n----------------------------------------\n\nTITLE: Implementing Diagnostic Trait in Rust\nDESCRIPTION: This code snippet shows an implementation of the `Diagnostic` trait for a struct, used within the Rust compiler to handle diagnostics. The implementation focuses on creating a diagnostic context, setting spans, and labels for detailed error reporting. Dependencies include the `Diagnostic` trait, `EmissionGuarantee`, and associated context objects. Essential functions like `into_diag` create and populate diagnostic messages which can be emitted by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a, G: EmissionGuarantee> Diagnostic<'a> for FieldAlreadyDeclared {\\n    fn into_diag(self, dcx: &'a DiagCtxt, level: Level) -> Diag<'a, G> {\\n        let mut diag = Diag::new(dcx, level, fluent::hir_analysis_field_already_declared);\\n        diag.set_span(self.span);\\n        diag.span_label(\\n            self.span,\\n            fluent::hir_analysis_label\\n        );\\n        diag.span_label(\\n            self.prev_span,\\n            fluent::hir_analysis_previous_decl_label\\n        );\\n        diag\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumeration for AST Variants - Rust\nDESCRIPTION: This snippet illustrates the use of `enum` to model various types of associated items within the AST, such as function definitions, type aliases, and constants. This design allows for dynamic handling of different AST node types while implementing the `AstNode` trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum AssocItem {\n    FnDef(FnDef),\n    TypeAliasDef(TypeAliasDef),\n    ConstDef(ConstDef),\n}\n\nimpl AstNode for AssocItem {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for a Specific Target\nDESCRIPTION: This code snippet illustrates how to use the `--target` flag to generate documentation for a target triple different from the host triple. This is useful for generating documentation for cross-compilation scenarios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --target x86_64-pc-windows-gnu\n```\n\n----------------------------------------\n\nTITLE: Control Flow Pattern Example\nDESCRIPTION: Demonstrates the preferred approach to handling control flow by pushing it to the caller rather than hiding it in functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nif cond {\n    f()\n}\n\n// BAD\nfn f() {\n    if !cond {\n        return;\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Character Literal and Whitespace Token Examples\nDESCRIPTION: This text lists various Rust character literals (simple, numeric, escaped hexadecimal, newline, backslash, single quote) identified by the `CHAR` token type, interspersed with `WHITESPACE` tokens (space and newline). This format likely serves as test input for a component within the Rust compiler, such as the lexer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/chars.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nCHAR \"'x'\"\nWHITESPACE \" \"\nCHAR \"' '\"\nWHITESPACE \" \"\nCHAR \"'0'\"\nWHITESPACE \" \"\nCHAR \"'hello'\"\nWHITESPACE \" \"\nCHAR \"'\\x7f'\"\nWHITESPACE \" \"\nCHAR \"'\\n'\"\nWHITESPACE \" \"\nCHAR \"'\\\\'\"\nWHITESPACE \" \"\nCHAR \"'\\''\"\nWHITESPACE \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: CMake Legacy Jobserver Workaround\nDESCRIPTION: Shows a workaround for CMake versions before 3.28 to enable jobserver support using $(MAKE) variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/jobserver.md#2025-04-21_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.22)\nproject(x)\nadd_custom_target(x\n    COMMAND DUMMY_VARIABLE=$(MAKE) echo 'fn main() {}' | rustc -\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Yeet Expressions in Rust Functions\nDESCRIPTION: This code snippet demonstrates the usage of 'do yeet' expressions in Rust functions. It shows how to use 'do yeet' to return early from functions with Result and Option return types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/yeet-expr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(yeet_expr)]\n\nfn foo() -> Result<String, i32> {\n    do yeet 4;\n}\nassert_eq!(foo(), Err(4));\n\nfn bar() -> Option<String> {\n    do yeet;\n}\nassert_eq!(bar(), None);\n```\n\n----------------------------------------\n\nTITLE: Generating and Using AFDO Profile for Rust Compilation\nDESCRIPTION: This code snippet demonstrates the process of generating an AFDO profile and using it to optimize a Rust binary. It involves compiling with debug info, profiling with perf, converting the profile, and finally recompiling with the profile data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/debug_info_for_profiling.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustc -O -Zdebug-info-for-profiling main.rs -o main\nperf record -b ./main\ncreate_llvm_prof --binary=main --out=code.prof\nrustc -O -Zprofile-sample-use=code.prof main.rs -o main2\n```\n\n----------------------------------------\n\nTITLE: Loading Shell Completions for PowerShell\nDESCRIPTION: This snippet details how to load shell completions for PowerShell specifically for the Rust project's `x.py`. Users need to invoke the script with the provided command to set up the autocompletion functionality. The instruction assumes familiarity with PowerShell commands and assumes the completion script's correct path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n& .\\src\\etc\\completions\\x.py.ps1\n```\n\n----------------------------------------\n\nTITLE: Customizing Directives for Specific Revisions\nDESCRIPTION: This snippet demonstrates how to customize directives and expected error messages for a specific revision using the `//@[revision-name]` syntax. It provides an example of using different compile flags based on the revision context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"// A flag to pass in only for cfg `foo`:\\n//@[foo]compile-flags: -Z verbose-internals\\n\\n#[cfg(foo)]\\nfn test_foo() {\\n    let x: usize = 32_u32; //[foo]~ ERROR mismatched types\\n}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Providers Struct Definition in Rust Compiler\nDESCRIPTION: The structure of the Providers struct which contains function pointers to query provider implementations. This struct is used to register query providers with the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Providers {\n    type_of: for<'tcx> fn(TyCtxt<'tcx>, DefId) -> Ty<'tcx>,\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Clippy from source with Rust toolchain override - Bash\nDESCRIPTION: Command to build Clippy binaries (cargo-clippy and clippy-driver) in release mode and install them into the Rust sysroot bin directory via an unstable cargo option. This installs Clippy into the currently active Rust toolchain override. Subsequent commands show how to run Clippy using the installed toolchain or restore the default Clippy installation if needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/basics.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --release --bin cargo-clippy --bin clippy-driver -Zunstable-options --out-dir \"$(rustc --print=sysroot)/bin\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd my-project\ncargo +nightly-2021-07-01 clippy\n```\n\nLANGUAGE: bash\nCODE:\n```\nclippy-driver +nightly-2021-07-01 <filename>\n```\n\nLANGUAGE: bash\nCODE:\n```\nrustup component remove clippy\nrustup component add clippy\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Accessing Method Like Field in Rust\nDESCRIPTION: This code snippet demonstrates the E0615 error, which occurs when trying to access a method like a field without using parentheses. The struct `Foo` has a field `x` and a method `method`. The error occurs when trying to access `f.method` without calling it as `f.method()`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0615.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n```\n\n----------------------------------------\n\nTITLE: Correctly Providing Multiple Lifetime Arguments in Rust Function Call\nDESCRIPTION: This example shows the correct approach to providing multiple lifetime arguments to a function. The function requires two lifetime parameters, and two are correctly provided in the function call.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0090.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a: 'b, 'b: 'a>() {}\n\nfn main() {\n    foo::<'static, 'static>();\n}\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_4 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_4` function in Rust, passing two integers (1 and 2) and a floating-point number (3.0) as arguments. This shows the `fastcall` calling convention with mixed datatypes.  The functions implementation determines the output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_4(1, 2, 3.0)\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignment in Pattern Guard Example - Rust\nDESCRIPTION: Demonstrates an invalid Rust code example where an assignment is attempted within a pattern guard. This operation is not allowed because it could cause side effects that interfere with match exhaustiveness and pattern matching reliability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0302.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch Some(()) {\n    None => { },\n    option if { option = None; false } => { },\n    Some(_) => { } // When the previous match failed, the option became `None`.\n}\n```\n\n----------------------------------------\n\nTITLE: Using regparm Compiler Option in Rust\nDESCRIPTION: The -Zregparm=N option configures the compiler to pass up to 3 function arguments through registers (EAX, EDX, ECX) instead of the stack for C-style calling conventions. This option is x86-specific and requires careful consideration of linking compatibility between crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/regparm.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Zregparm=N\n```\n\n----------------------------------------\n\nTITLE: Function Call Formatting in Rust\nDESCRIPTION: Comprehensive guidelines for formatting function calls, covering single-line and multi-line call styles, spacing, and argument handling\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfoo(x, y, z)\n\na_function_call(\n    arg1,\n    a_nested_call(a, b),\n)\n```\n\n----------------------------------------\n\nTITLE: Building a VPK with cargo vita\nDESCRIPTION: This command uses `cargo vita build vpk` to build a VPK (Vita Package) file from the Rust project. The `--release` flag indicates that the release profile should be used, resulting in an optimized build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n\"cargo vita build vpk --release\"\n```\n\n----------------------------------------\n\nTITLE: Generating C-like Debug Output for libgccjit Context\nDESCRIPTION: This function call generates a C-like file with debug information for the libgccjit context, including source locations in the IR. It's useful for identifying the exact location of errors in the generated code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging-libgccjit.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ngcc_jit_context_dump_to_file(ctxt, \"/tmp/output.c\", 1 /* update_locations */)\n```\n\n----------------------------------------\n\nTITLE: Cross-compiling for LoongArch using QEMU\nDESCRIPTION: This Shell script configures the environment for cross-compiling a Rust project targeting `loongarch64-unknown-linux-gnu` from a `x86_64-unknown-linux-gnu` host. It exports necessary environment variables for the LoongArch cross-toolchain and uses QEMU for emulation. Ensure your toolchain and QEMU are correctly installed and configured for this setup.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/loongarch-linux.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# Suppose the cross toolchain is placed at $TOOLCHAIN_PATH, with a cross prefix\n# of \"loongarch64-unknown-linux-gnu-\".\nexport CC_loongarch64_unknown_linux_gnu=\"$TOOLCHAIN_PATH\"/bin/loongarch64-unknown-linux-gnu-gcc\nexport CXX_loongarch64_unknown_linux_gnu=\"$TOOLCHAIN_PATH\"/bin/loongarch64-unknown-linux-gnu-g++\nexport AR_loongarch64_unknown_linux_gnu=\"$TOOLCHAIN_PATH\"/bin/loongarch64-unknown-linux-gnu-gcc-ar\nexport CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_LINKER=\"$TOOLCHAIN_PATH\"/bin/loongarch64-unknown-linux-gnu-gcc\n\n# Point qemu-loongarch64 to the LoongArch sysroot.\n# Suppose the sysroot is located at \"sysroot\" below the toolchain root:\nexport CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-loongarch64 -L $TOOLCHAIN_PATH/sysroot\"\n# Or alternatively, if binfmt_misc is set up for running LoongArch binaries\n# transparently:\nexport QEMU_LD_PREFIX=\"$TOOLCHAIN_PATH\"/sysroot\n\ncargo run --target loongarch64-unknown-linux-gnu --release\n```\n\n----------------------------------------\n\nTITLE: Referencing Tracking Issue for F16 Type in Rust\nDESCRIPTION: Provides a link to the GitHub issue tracking the implementation of the f16 type in Rust. This issue contains detailed information about the feature's progress and discussions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/f16.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[#116909]: https://github.com/rust-lang/rust/issues/116909\n```\n\n----------------------------------------\n\nTITLE: Enum definitions with type parameters in Rust\nDESCRIPTION: This code snippet defines three enums, `Option`, `OptionalFn`, and `OptionalMap`, each parameterized by a different type parameter (`A`, `B`, and `C` respectively). These enums are used to illustrate how variance constraints are generated during type checking in Rust, based on the positions of the type parameters within the enum definitions. The `ignore` attribute indicates that the code is for illustrative purposes and should not be compiled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nenum Option<A> { Some(A), None }\nenum OptionalFn<B> { Some(|B|), None }\nenum OptionalMap<C> { Some(|C| -> C), None }\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Main Function for GIMPLE Generation in C\nDESCRIPTION: This snippet shows the implementation of a main function that uses the GCC JIT API to generate GIMPLE output. It sets necessary options and calls the create_code function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nint main() {\n    gcc_jit_context *ctxt = gcc_jit_context_acquire();\n    // To set `-O3`, update it depending on your needs.\n    gcc_jit_context_set_int_option(ctxt, GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n    // Very important option to generate the gimple format.\n    gcc_jit_context_set_bool_option(ctxt, GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);\n    create_code(ctxt, NULL);\n\n    gcc_jit_context_compile(ctxt);\n    // If you want to compile to assembly (or any other format) directly, you can\n    // use the following call instead:\n    // gcc_jit_context_compile_to_file(ctxt, GCC_JIT_OUTPUT_KIND_ASSEMBLER, \"out.s\");\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Toolchain Paths for s390x in Cargo\nDESCRIPTION: This snippet demonstrates how to explicitly configure the paths to the s390x toolchain binaries (compiler, archiver, etc.) in Cargo's configuration file (`.cargo/config.toml`). This is required when the toolchain is not in the system's `PATH` or when a specific version needs to be used. It ensures that the correct tools are used for compiling and linking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_5\n\nLANGUAGE: TOML\nCODE:\n```\n\n```toml\n[target.s390x-unknown-linux-gnu]\n# Adjust the paths to point at your toolchain\ncc = \"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc\"\ncxx = \"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-g++\"\nar = \"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ar\"\nranlib = \"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ranlib\"\nlinker = \"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc\"\n```\n\n```\n\n----------------------------------------\n\nTITLE: Handling Uncommitted Changes Before Rebasing\nDESCRIPTION: Provides a sequence of commands to save local uncommitted changes before a rebase and reapply them afterwards. `git stash` saves the changes, and `git stash pop` restores them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ngit stash\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit stash pop\n```\n\n----------------------------------------\n\nTITLE: Defining Test State Change Structure in TypeScript\nDESCRIPTION: Defines ChangeTestStateParams, which tracks state changes within individual tests using a tag-driven approach. It allows integration environments to monitor and adjust test states facilitating diagnostics and ensuring consistent synchronization with server-side testing mechanisms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntype TestState = { tag: \"passed\" }\n    | {\n        tag: \"failed\";\n        message: string;\n    }\n    | { tag: \"started\" }\n    | { tag: \"enqueued\" }\n    | { tag: \"skipped\" };\n\ninterface ChangeTestStateParams {\n    testId: string;\n    state: TestState;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Function-Specific LLVM IR\nDESCRIPTION: Command to extract LLVM IR for a specific function using llvm-extract tool. Useful for isolating and debugging issues with specific functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./build/$TRIPLE/llvm/bin/llvm-extract \\\n    -func='_ZN11collections3str21_$LT$impl$u20$str$GT$7replace17hbe10ea2e7c809b0bE' \\\n    -S \\\n    < unextracted.ll \\\n    > extracted.ll\n```\n\n----------------------------------------\n\nTITLE: Downloading Nightly Components Locally\nDESCRIPTION: Shell script to download Rust nightly components for local testing and manifest generation. Downloads essential components including rust, rustc, rust-std, rust-docs, and cargo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/build-manifest/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfor component in rust rustc rust-std rust-docs cargo; do\n    wget -P build/dist https://static.rust-lang.org/dist/${component}-nightly-x86_64-unknown-linux-gnu.tar.gz\ndone\n```\n\n----------------------------------------\n\nTITLE: RPITIT Desugared GAT Implementation\nDESCRIPTION: Shows how the compiler desugars RPITIT into an equivalent GAT implementation with explicit lifetime parameters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type Gat<'early, T, 'early_duplicated, 'late>: Sized + Captures<'early_duplicated, 'late>;\n\n    fn method<'early: 'early, 'late, T>() -> Self::Gat<'early, T, 'early, 'late>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using References to Borrow Values in Rust\nDESCRIPTION: This example demonstrates how to use references in Rust to borrow values without changing ownership. It shows a function that calculates the length of a string by taking a reference as an argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0382.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Link Arg Attribute Usage in Rust\nDESCRIPTION: This code snippet shows how to use the `link_arg_attribute` feature to pass arguments to the linker. It demonstrates preserving the order of link attributes within a single extern block, including both link-arg and static link kinds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/link-arg-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(link_arg_attribute)]\n\n#[link(kind = \"link-arg\", name = \"--start-group\")]\n#[link(kind = \"static\", name = \"c\")]\n#[link(kind = \"static\", name = \"gcc\")]\n#[link(kind = \"link-arg\", name = \"--end-group\")]\nextern \"C\" {}\n```\n\n----------------------------------------\n\nTITLE: Markdown CSS HTML Link\nDESCRIPTION: This HTML code snippet shows the generated `<link>` element when using `--markdown-css` flag. The link tag includes the stylesheet.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_20\n\nLANGUAGE: html\nCODE:\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"foo.css\">\n```\n\n----------------------------------------\n\nTITLE: Documenting Struct with Positional Parameters Link\nDESCRIPTION: This snippet shows how to link to a specific section within the standard library documentation using intra-doc links. It uses a defined link for positional parameters to provide context in the documentation for MySpecialFormatter struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// This is a special implementation of [positional parameters].\n///\n/// [positional parameters]: std::fmt#formatting-parameters\nstruct MySpecialFormatter;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Declaration of Atomic Operation Intrinsic in Rust\nDESCRIPTION: Example of erroneous code that triggers E0092 error by declaring an undefined atomic operation function. This demonstrates what not to do when working with Rust intrinsics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0092.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn atomic_foo(); // error: unrecognized atomic operation\n                        //        function\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Result Return Type in Rust Functions\nDESCRIPTION: Removes the Result wrapper from a function's return type and automatically unwraps the returned value. Useful for simplifying function signatures when error handling is no longer needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_116\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Result<i32> { Ok(42i32) }\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 42i32 }\n```\n\n----------------------------------------\n\nTITLE: Using cargo-pgo for Simplified PGO Workflow\nDESCRIPTION: Commands for using the community-maintained cargo-pgo tool, which provides a simplified interface for profile-guided optimization in Rust projects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/profile-guided-optimization.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Install if you haven't already\ncargo install cargo-pgo\n\ncargo pgo build\ncargo pgo optimize\n```\n\n----------------------------------------\n\nTITLE: Implementing CoerceUnsized with Invalid Lifetime Bounds in Rust\nDESCRIPTION: Example demonstrating an E0476 error when implementing CoerceUnsized trait where lifetime 'b of the source pointer does not outlive lifetime 'a of the target type. This code uses unstable features coerce_unsized and unsize.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0476.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\n#![feature(unsize)]\n\nuse std::marker::Unsize;\nuse std::ops::CoerceUnsized;\n\n// error: lifetime of the source pointer does not outlive lifetime bound of the\n//        object type\nimpl<'a, 'b, T, S> CoerceUnsized<&'a T> for &'b S where S: Unsize<T> {}\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Binary Literal\nDESCRIPTION: This snippet shows that `0bnoDigit` gives a `Missing digits after the integer base prefix` error, because it requires digits, but gets a string that isn't a valid digit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0bnoDigit\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unterminated Multi-line Comment in Rust\nDESCRIPTION: This snippet shows an example of an unterminated multi-line comment in Rust, which results in a compilation error (E0758).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0758.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/* I am not terminated!\n```\n\n----------------------------------------\n\nTITLE: Function Item Type for Generic Function with Lifetimes in Rust\nDESCRIPTION: This snippet shows the desugaring of the previous function into its function item type representation. It emphasizes how lifetime parameters are handled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct FooFnItem<T: Sized>(PhantomData<for<'a> fn(&'a T) -> &'a T>);\n\nimpl<'a, T: Sized> Fn<(&'a T,)> for FooFnItem<T> {\n    type Output = &'a T;\n    /* fn call(&self, ...) -> ... { ... } */\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Byte String Literal with Unicode Escape\nDESCRIPTION: Demonstrates an incomplete byte string literal with a Unicode escape sequence that is missing a terminating quote symbol. The `b\"\\u{20AA}\"` requires a closing quote to be valid Rust syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_unicode_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nb\"\\u{20AA}\"\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Program for VisionOS Simulator\nDESCRIPTION: Demonstrates how to compile a Rust program targeting the VisionOS simulator architecture using rustc with explicit target specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-visionos.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --target aarch64-apple-visionos-sim your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Installing Required Rust Components\nDESCRIPTION: Command to install the necessary rustc-dev and llvm-tools components using rustup for rustc_private feature usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/remarks-on-perma-unstable-features.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nrustup component add rustc-dev llvm-tools\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Move Semantics in Rust\nDESCRIPTION: This code snippet illustrates a common error in Rust where a variable is used after its contents have been moved. It shows how assigning a non-Copy type to another variable moves ownership, making the original variable unusable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0382.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Send Implementation for List Structure\nDESCRIPTION: Shows the compiler-generated implementation of the Send auto trait for a generic List structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/auto-traits.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct List<T> {\n  data: T,\n  next: Option<Box<List<T>>>,\n}\n\nunsafe impl<T> Send for List<T>\nwhere\n  T: Send, // from the field `data`\n  Option<Box<List<T>>>: Send, // from the field `next`\n{ }\n```\n\n----------------------------------------\n\nTITLE: Generating HIR Tree Representation in Rust\nDESCRIPTION: This bash command leverages the rustc compiler to generate a high-level intermediate representation tree for Rust code. It requires the cargo build system to be installed and set up properly. The output will provide a visual structure of the HIR representation as understood by rustc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc -- -Z unpretty=hir-tree\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fn Trait Mismatch in Rust\nDESCRIPTION: This code snippet demonstrates a type mismatch error where a closure with a String parameter is passed to a function expecting a closure with a usize parameter. This mismatch triggers the E0281 error, which is no longer emitted by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0281.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<F: Fn(usize)>(x: F) { }\n\nfn main() {\n    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\n    // but the trait `core::ops::Fn<(usize,)>` is required\n    // [E0281]\n    foo(|y: String| { });\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Programs for zkVM using cargo-risczero\nDESCRIPTION: To build programs for the RISC Zero zkVM, users are encouraged to utilize the 'cargo-risczero' utility which facilitates the setup of project templates, tool installations, and builds the binaries appropriately.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv32im-risc0-zkvm-elf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo risczero install\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo risczero new\n```\n\n----------------------------------------\n\nTITLE: Building Rust Core and Alloc Libraries for mipsel-sony-psx\nDESCRIPTION: Shell command for building Rust programs targeting mipsel-sony-psx. It uses the nightly cargo feature 'build-std' to compile the core and alloc libraries for this target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mipsel-sony-psx.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo build -Zbuild-std=core,alloc --target mipsel-sony-psx\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Output for #[rustc_variance] in Rust\nDESCRIPTION: This shows the error output generated by the compiler when using the #[rustc_variance] attribute. The output displays the variance of the type's generic parameters, with [-, o] indicating contravariant lifetime and invariant type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0208.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nerror: [-, o]\n --> <anon>:4:1\n  |\n4 | struct Foo<'a, T> {\n  | ^^^^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Building for Cross-Compilation Targets\nDESCRIPTION: This command builds the compiler with support for cross-compilation targets. The `--target` flag specifies the host and target platforms.  This enables the compiler to build code for other architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./x build --target x86_64-unknown-linux-gnu,wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build Target in bootstrap.toml\nDESCRIPTION: Configuration snippet for building Rust with x86_64-unknown-none target support by adding it to the target list in bootstrap.toml.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/x86_64-unknown-none.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-unknown-none\"]\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Generics in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for generic parameters. Generic parameters after the first line are aligned with the first parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<Ipsum: Eq = usize,\n         Dolor: Eq = usize,\n         Sit: Eq = usize,\n         Amet: Eq = usize,\n         Adipiscing: Eq = usize,\n         Consectetur: Eq = usize,\n         Elit: Eq = usize>(\n    ipsum: Ipsum,\n    dolor: Dolor,\n    sit: Sit,\n    amet: Amet,\n    adipiscing: Adipiscing,\n    consectetur: Consectetur,\n    elit: Elit)\n    -> T {\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Approach for Foreign Items Using Specialized Type Declarations in Rust\nDESCRIPTION: This code snippet shows the proper way to handle different types with extern \"C\" functions by creating separate specialized function declarations for each required type instead of using generics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0044.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" { fn some_func_i32(x: i32); }\nextern \"C\" { fn some_func_i64(x: i64); }\n```\n\n----------------------------------------\n\nTITLE: Configuring Space After Colon in Rust\nDESCRIPTION: Shows the effect of the 'space_after_colon' option on formatting. When true (default), a space is added after colons. When false, no space is added.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_65\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<T: Eq>(t: T) {\n    let lorem: Dolor = Lorem {\n        ipsum: dolor,\n        sit: amet,\n    };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<T:Eq>(t:T) {\n    let lorem:Dolor = Lorem {\n        ipsum:dolor,\n        sit:amet,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Crater Testing\nDESCRIPTION: Comprehensive documentation explaining the Crater testing system, including when to use it, how to request runs, and important caveats about its limitations. Covers different types of test runs and their respective durations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/crater.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Crater\n\n[Crater](https://github.com/rust-lang/crater) is a tool for compiling and\nrunning tests for _every_ crate on [crates.io](https://crates.io) (and a few on\nGitHub). It is mainly used for checking the extent of breakage when implementing\npotentially breaking changes and ensuring lack of breakage by running beta vs\nstable compiler versions.\n\n## When to run Crater\n\nYou should request a crater run if your PR makes large changes to the compiler\nor could cause breakage. If you are unsure, feel free to ask your PR's reviewer.\n\n## Requesting Crater Runs\n\nThe rust team maintains a few machines that can be used for running crater runs\non the changes introduced by a PR. If your PR needs a crater run, leave a\ncomment for the triage team in the PR thread. Please inform the team whether you\nrequire a \"check-only\" crater run, a \"build only\" crater run, or a\n\"build-and-test\" crater run. The difference is primarily in time; the\nconservative (if you're not sure) option is to go for the build-and-test run. If\nmaking changes that will only have an effect at compile-time (e.g., implementing\na new trait) then you only need a check run.\n\nYour PR will be enqueued by the triage team and the results will be posted when\nthey are ready. Check runs will take around ~3-4 days, with the other two taking\n5-6 days on average.\n\nWhile crater is really useful, it is also important to be aware of a few\ncaveats:\n\n- Not all code is on crates.io! There is a lot of code in repos on GitHub and\n  elsewhere. Also, companies may not wish to publish their code. Thus, a\n  successful crater run is not a magically green light that there will be no\n  breakage; you still need to be careful.\n\n- Crater only runs Linux builds on x86_64. Thus, other architectures and\n  platforms are not tested. Critically, this includes Windows.\n\n- Many crates are not tested. This could be for a lot of reasons, including that\n  the crate doesn't compile any more (e.g. used old nightly features), has\n  broken or flaky tests, requires network access, or other reasons.\n\n- Before crater can be run, `@bors try` needs to succeed in building artifacts.\n  This means that if your code doesn't compile, you cannot run crater.\n```\n\n----------------------------------------\n\nTITLE: Private Module Test Implementation\nDESCRIPTION: Demonstrates how tests can be written for private functions within private modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod my_priv_mod {\n    fn my_priv_func() -> bool {}\n\n    #[test]\n    fn test_priv_func() {\n        assert!(my_priv_func());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct SIMD Tuple Struct Implementation in Rust\nDESCRIPTION: Demonstrates proper implementation of a SIMD tuple struct where the field is correctly declared as a single-element array to enable SIMD operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0076.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good([u16; 1]); // ok!\n```\n\n----------------------------------------\n\nTITLE: Correcting Deprecated Attribute Usage in Rust\nDESCRIPTION: The code snippet illustrates an erroneous usage of the #[deprecated] attribute in Rust where the 'note' key is specified twice, which is not allowed. The solution involves removing one of the duplicate meta items to ensure each key is used only once within the attribute. This demonstrates proper usage of attribute meta items, a common task when marking functions as deprecated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0538.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated(\n    since=\"1.0.0\",\n    note=\"First deprecation note.\"\n)]\nfn deprecated_function() {}\n```\n\n----------------------------------------\n\nTITLE: Breaking Control Flow Expressions in Rust\nDESCRIPTION: Rules for breaking long control flow expressions in Rust, showing proper indentation and brace placement for while, for, and if statements with complex conditions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(foo)\n    = a_long_expression\n{\n    ...\n}\n\nfor foo\n    in a_long_expression\n{\n    ...\n}\n\nif a_long_expression\n    && another_long_expression\n    || a_third_long_expression\n{\n    ...\n}\n\nif let Some(a) = b\n    && another_long_expression\n    && a_third_long_expression\n{\n    // ...\n}\n\nif let Some(relatively_long_thing)\n    = a_long_expression\n    && another_long_expression\n    && a_third_long_expression\n{\n    // ...\n}\n\nif some_expr\n    && another_long_expression\n    && let Some(relatively_long_thing) =\n        a_long_long_long_long_long_long_really_reallllllllllyyyyyyy_long_expression\n    && a_third_long_expression\n{\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Tracing Macros in Rust\nDESCRIPTION: This Rust code snippet shows how to use tracing macros and the instrument attribute for structured logging in the bootstrap process. These are gated by the 'tracing' feature and used to provide detailed logging for specific functions. It requires the tracing crate with optional features enabled and involves macros like trace! and the #[instrument] attribute for method tracing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/debugging-bootstrap.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"tracing\")]\nuse tracing::instrument;\n\nstruct Foo;\n\nimpl Step for Foo {\n    type Output = ();\n\n    #[cfg_attr(feature = \"tracing\", instrument(level = \"trace\", name = \"Foo::should_run\", skip_all))]\n    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n        trace!(?run, \"entered Foo::should_run\");\n\n        todo!()\n    }\n\n    #[cfg_attr(\n        feature = \"tracing\",\n        instrument(\n            level = \"trace\",\n            name = \"Foo::run\",\n            skip_all,\n            fields(compiler = ?builder.compiler),\n        ),\n    )]\n    fn run(self, builder: &Builder<'_>) -> Self::Output {\n        trace!(?run, \"entered Foo::run\");\n\n        todo!()\n    }    \n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Heap Corruption in Rust\nDESCRIPTION: This Rust code example demonstrates a potential heap corruption scenario by writing beyond the bounds of an allocated array using unsafe code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = Box::new([0; 1024]);\n\n    for i in 0..1026 {\n        unsafe {\n            let elem = x.get_unchecked_mut(i);\n            *elem = 0x4141414141414141u64;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Clippy MSRV Configuration\nDESCRIPTION: TOML configuration for specifying minimum supported Rust version\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\nmsrv = \"1.30.0\"\n```\n\n----------------------------------------\n\nTITLE: Optimizing Argument Passing in Rust Function\nDESCRIPTION: This diagnostic suggests optimizing a function argument by passing it by value instead of by reference. The change could improve performance for trivially copyable types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/clippy_pass_by_ref.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn some_function(&self) {\n    // Function implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example with Removed Feature\nDESCRIPTION: This Rust code snippet uses the `compile_fail` attribute to demonstrate a compilation error. The error occurs because the code attempts to enable the `managed_boxes` feature, which has been removed from the Rust language. The expected output is a compilation error with code E0557.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0557.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"#![feature(managed_boxes)] // error: feature has been removed\"\n```\n\n----------------------------------------\n\nTITLE: Moving Rust File to mod.rs\nDESCRIPTION: Moves code from a standalone .rs file to a mod.rs file within a directory of the same name. This refactoring converts a file-based module to a directory-based module structure, which can be useful for modules that need to contain submodules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_90\n\nLANGUAGE: rust\nCODE:\n```\n//- /main.rs\nmod a;\n//- /a.rs\nfn t() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn t() {}\n```\n\n----------------------------------------\n\nTITLE: Redirecting control flow to an invalid destination in Rust with CFI protection\nDESCRIPTION: This example demonstrates how CFI prevents control flow hijacking by detecting an indirect call to an invalid destination within a function body. The code attempts to call into the middle of a function's nop padding rather than its entry point.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::naked_asm;\nuse std::mem;\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\n#[unsafe(naked)]\npub extern \"C\" fn add_two(x: i32) {\n    // x + 2 preceded by a landing pad/nop block\n    naked_asm!(\n        \"\n         nop\n         nop\n         nop\n         nop\n         nop\n         nop\n         nop\n         nop\n         nop\n         lea eax, [rdi+2]\n         ret\n        \"\n    );\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n\n    println!(\"With CFI enabled, you should not see the next answer\");\n    let f: fn(i32) -> i32 = unsafe {\n        // Offset 0 is a valid branch/call destination (i.e., the function entry\n        // point), but offsets 1-8 within the landing pad/nop block are invalid\n        // branch/call destinations (i.e., within the body of the function).\n        mem::transmute::<*const u8, fn(i32) -> i32>((add_two as *const u8).offset(5))\n    };\n    let next_answer = do_twice(f, 5);\n\n    println!(\"The next answer is: {}\", next_answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Match Expression with Comments\nDESCRIPTION: Demonstrates formatting of match arms containing comments with arrow symbols.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmatch a {\n    _ =>\n    // comment with =>\n    {\n        println!(\"A\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unreachability with Binding on Empty Types in Unsafe Rust\nDESCRIPTION: This example illustrates how a binding pattern becomes unreachable when matching on a place of an empty type, even in unsafe code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# #[derive(Copy, Clone)]\n# enum Void {}\n# let x: u8 = 0;\n# let ptr: *const Void = &x as *const u8 as *const Void;\n# unsafe {\nmatch *ptr {\n    _a => println!(\"Unreachable!\"),\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Implementation with Method vs Static Function Mismatch in Rust\nDESCRIPTION: This example demonstrates an E0185 error where a trait defines a static function 'foo()' but the implementation incorrectly uses a method signature 'foo(&self)'. The error occurs because the signatures don't match - one is a static function and one is a method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0185.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, method `foo` has a `&self` declaration in the impl, but not in\n    // the trait\n    fn foo(&self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Available Rust Targets in Markdown\nDESCRIPTION: Shows how to use rustc to display all available built-in compilation targets supported by the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/targets/built-in.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc --print target-list\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Alias Implementation Example in Rust\nDESCRIPTION: Shows that using a type alias does not circumvent the restriction on implementing methods for types from external crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0116.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Bytes = Vec<u8>;\n\nimpl Bytes { } // error, same as above\n```\n\n----------------------------------------\n\nTITLE: Correct Binary Assignment on Supported Type in Rust\nDESCRIPTION: This code snippet shows the correct usage of the left shift assignment operator with an unsigned 32-bit integer type, which supports this operation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0368.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n\nx <<= 2; // ok!\n```\n\n----------------------------------------\n\nTITLE: Building Targets in Bootstrap Configuration\nDESCRIPTION: This TOML snippet configures the rustc build system to enable support for specified watchOS targets. It involves modifying the bootstrap.toml file by setting the build stage and listing the target architectures. The primary prerequisite is having Xcode 12 or higher, and access to the corresponding SDKs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-watchos.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\nbuild-stage = 1\\ntarget = [\"aarch64-apple-watchos\", \"aarch64-apple-watchos-sim\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer Procedural Macro Expansion in JSON\nDESCRIPTION: Controls the procedural macro system integration of rust-analyzer, including enabling macro support, attribute macro expansion, ignoring specific macros, and specifying an internal proc-macro server path. These options affect how macros are resolved and expanded in the Rust language server, influencing IDE features like syntax highlighting, code navigation, and code completion. Required prerequisites include a compatible rust-analyzer and Rust project with proc macro dependencies.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.procMacro.enable\": true,\n  \"rust-analyzer.procMacro.attributes.enable\": true,\n  \"rust-analyzer.procMacro.ignored\": {},\n  \"rust-analyzer.procMacro.server\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Public and Private Items\nDESCRIPTION: This Rust code snippet demonstrates public and private items in a module. By default, rustdoc will document `public()`, but not `private` or `unreachable()` unless `--document-private-items` is used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn public() {} // this item is public and will be documented\nmod private { // this item is private and will not be documented\n    pub fn unreachable() {} // this item is public, but unreachable, so it will not be documented\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Default Trait for Rust Enum with Payload\nDESCRIPTION: This code snippet demonstrates how to manually implement the Default trait for a Rust enum when the default variant has a payload. It provides a custom implementation of the default() function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0665.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Food {\n    Sweet(i32),\n    Salty,\n}\n\nimpl Default for Food {\n    fn default() -> Food {\n        Food::Sweet(1)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid #[repr(u8)] on struct in Rust\nDESCRIPTION: This code snippet presents an example of using the `#[repr(u8)]` attribute on a struct, which is incorrect. The `#[repr(u8)]` attribute is intended for specifying the discriminant size of enums, not for structs. Using it on a struct will generate a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0517.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\n#[repr(u8)]\nstruct Foo {bar: bool, baz: bool}\n\n```\n\n----------------------------------------\n\nTITLE: ExprUseVisitor Example in Rust Compiler\nDESCRIPTION: This Rust example highlights how `ExprUseVisitor` in the Rust compiler iterates through a closure's code, identifying variable usage as either shared or mutable borrow. This helps in determining how each variable is captured in closures. Familiarity with Rust's borrowing model and compiler internals is needed to fully understand the implications of these usage patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/closure.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = vec![21];\n    let _cl = || {\n        let y = x[0];  // 1.\n        x[0] += 1;  // 2.\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Interpreting cargo-llvm-lines output for the Rust compiler\nDESCRIPTION: Sample output from cargo-llvm-lines showing the functions that generate the most LLVM IR in the Rust compiler. The output displays lines count, copies count, and function names, highlighting that core::ptr::drop_in_place generates 4.7% of the total LLVM IR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  Lines            Copies          Function name\n  -----            ------          -------------\n  45207720 (100%)  1583774 (100%)  (TOTAL)\n   2102350 (4.7%)   146650 (9.3%)  core::ptr::drop_in_place\n    615080 (1.4%)     8392 (0.5%)  std::thread::local::LocalKey<T>::try_with\n    594296 (1.3%)     1780 (0.1%)  hashbrown::raw::RawTable<T>::rehash_in_place\n    592071 (1.3%)     9691 (0.6%)  core::option::Option<T>::map\n    528172 (1.2%)     5741 (0.4%)  core::alloc::layout::Layout::array\n    466854 (1.0%)     8863 (0.6%)  core::ptr::swap_nonoverlapping_one\n    412736 (0.9%)     1780 (0.1%)  hashbrown::raw::RawTable<T>::resize\n    367776 (0.8%)     2554 (0.2%)  alloc::raw_vec::RawVec<T,A>::grow_amortized\n    367507 (0.8%)      643 (0.0%)  rustc_query_system::dep_graph::graph::DepGraph<K>::with_task_impl\n    355882 (0.8%)     6332 (0.4%)  alloc::alloc::box_free\n    354556 (0.8%)    14213 (0.9%)  core::ptr::write\n    354361 (0.8%)     3590 (0.2%)  core::iter::traits::iterator::Iterator::fold\n    347761 (0.8%)     3873 (0.2%)  rustc_middle::ty::context::tls::set_tlv\n    337534 (0.7%)     2377 (0.2%)  alloc::raw_vec::RawVec<T,A>::allocate_in\n    331690 (0.7%)     3192 (0.2%)  hashbrown::raw::RawTable<T>::find\n    328756 (0.7%)     3978 (0.3%)  rustc_middle::ty::context::tls::with_context_opt\n    326903 (0.7%)      642 (0.0%)  rustc_query_system::query::plumbing::try_execute_query\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of ffi_pure Attribute on Regular Function\nDESCRIPTION: Example showing erroneous usage of the ffi_pure attribute on a non-foreign function, which will result in compilation error E0755.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0755.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_pure)]\n\n#[unsafe(ffi_pure)] // error!\npub fn foo() {}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fuchsia Component for Testing\nDESCRIPTION: Example of a modified CML file to pass arguments for testing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_21\n\nLANGUAGE: txt\nCODE:\n```\n{\n    include: [ \"syslog/client.shard.cml\" ],\n    program: {\n        runner: \"elf\",\n        binary: \"bin/hello_fuchsia\",\n        args: [\"it_works\"],\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Gitignore Extensions for Fuchsia Project\nDESCRIPTION: Suggested .gitignore entries for a Fuchsia project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_20\n\nLANGUAGE: txt\nCODE:\n```\npkg/repo\npkg/meta/hello_fuchsia.cm\npkg/hello_fuchsia_manifest\npkg/hello_fuchsia_package_manifest\n```\n\n----------------------------------------\n\nTITLE: Fluent Translation Strings for Error Messages\nDESCRIPTION: Defines localization strings for error messages and suggestions using the Fluent translation system. Provides translatable text for error messages and their associated help text.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_3\n\nLANGUAGE: fluent\nCODE:\n```\nexample-example-error = oh no! this is an error!\n  .try-qux-suggestion = try using a qux here\n  .qux-suggestion = you could use a qux here instead\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Unsized Expressions in Rust\nDESCRIPTION: This snippet illustrates various invalid uses of unsized types, including unsized statics, struct initialization, return types, and reassignment of unsized variables. It helps clarify the limitations of the unsized_locals feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_locals)]\n\nuse std::any::Any;\n\nstruct MyStruct<T: ?Sized> {\n    content: T,\n}\n\nstruct MyTupleStruct<T: ?Sized>(T);\n\nfn answer() -> Box<dyn Any> {\n    Box::new(42)\n}\n\nfn main() {\n    // You CANNOT have unsized statics.\n    static X: dyn Any = *answer();  // ERROR\n    const Y: dyn Any = *answer();  // ERROR\n\n    // You CANNOT have struct initialized unsized.\n    MyStruct { content: *answer() };  // ERROR\n    MyTupleStruct(*answer());  // ERROR\n    (42, *answer());  // ERROR\n\n    // You CANNOT have unsized return types.\n    fn my_function() -> dyn Any { *answer() }  // ERROR\n\n    // You CAN have unsized local variables...\n    let mut x: dyn Any = *answer();  // OK\n    // ...but you CANNOT reassign to them.\n    x = *answer();  // ERROR\n\n    // You CANNOT even initialize them separately.\n    let y: dyn Any;  // OK\n    y = *answer();  // ERROR\n\n    // Not mentioned in the RFC, but by-move captured variables are also Sized.\n    let x: dyn Any = *answer();\n    (move || {  // ERROR\n        let y = x;\n    })();\n\n    // You CAN create a closure with unsized arguments,\n    // but you CANNOT call it.\n    // This is an implementation detail and may be changed in the future.\n    let f = |x: dyn Any| {};\n    f(*answer());  // ERROR\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bootstrap Build Targets for tvOS\nDESCRIPTION: Configuration for enabling Apple tvOS targets in Rust bootstrap build process using bootstrap.toml file. Specifies build stage and target architectures for tvOS compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-tvos.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"aarch64-apple-tvos\", \"aarch64-apple-tvos-sim\"]\n```\n\n----------------------------------------\n\nTITLE: Showcasing Outer Doc Comment Usage in Rust\nDESCRIPTION: This snippet illustrates how to use outer doc comments in Rust as an alternative to inner doc comments. Outer doc comments can be applied directly to functions or items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0753.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// I am an outer doc comment\n#[doc = \"I am also an outer doc comment!\"]\nfn foo() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Configuration Names Example in Rust\nDESCRIPTION: Shows how multiple configuration names and values are checked in conditional compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(is_embedded)]         \nfn do_embedded() {}\n\n#[cfg(has_feathers)]        \nfn do_features() {}\n\n#[cfg(has_mumble_frotz)]    \nfn do_mumble_frotz() {}\n\n#[cfg(feature = \"lasers\")]  \nfn shoot_lasers() {}\n\n#[cfg(feature = \"monkeys\")] \nfn write_shakespeare() {}\n```\n\n----------------------------------------\n\nTITLE: Creating Types Programmatically for Trait Checking\nDESCRIPTION: Shows how to create types programmatically to check trait implementations for generic traits. Demonstrates creating a slice type and converting it to a GenericArg for trait implementation checking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/trait_checking.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_middle::ty::Ty;\nuse clippy_utils::ty::implements_trait;\nuse rustc_span::symbol::sym;\n\nlet ty = todo!(\"Get the `Foo` type to check for a trait implementation\");\nlet borrow_id = cx.tcx.get_diagnostic_item(sym::Borrow).unwrap(); // avoid unwrap in real code\nlet slice_of_bytes_t = Ty::new_slice(cx.tcx, cx.tcx.types.u8);\nlet generic_param = slice_of_bytes_t.into();\nif implements_trait(cx, ty, borrow_id, &[generic_param]) {\n    todo!(\"Rest of lint implementation\")\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message for Redundant Explicit Links in Rust\nDESCRIPTION: This snippet displays the error message generated when the `redundant_explicit_links` lint is triggered. It shows the location of the redundant link, explains the issue, and provides a suggestion for fixing it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nerror: redundant explicit rustdoc link\n  --> src/lib.rs:3:27\n   |\n3  | /// add takes 2 [`usize`](usize) and performs addition\n   |                           ^^^^^\n   |\n   = note: Explicit link does not affect the original link\nnote: the lint level is defined here\n  --> src/lib.rs:1:9\n   |\n1  | #![deny(rustdoc::redundant_explicit_links)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = help: Remove explicit link instead\n```\n\n----------------------------------------\n\nTITLE: Illustrating Rust E0201 Error with Duplicate Associated Items\nDESCRIPTION: This example demonstrates the E0201 error that occurs when defining duplicate associated functions, methods, or types within the same implementation. The code shows errors when defining a duplicate function 'bar', duplicate method 'baz', and duplicate associated type 'Quux'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0201.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo(u8);\n\nimpl Foo {\n    fn bar(&self) -> bool { self.0 > 5 }\n    fn bar() {} // error: duplicate associated function\n}\n\ntrait Baz {\n    type Quux;\n    fn baz(&self) -> bool;\n}\n\nimpl Baz for Foo {\n    type Quux = u32;\n\n    fn baz(&self) -> bool { true }\n\n    // error: duplicate method\n    fn baz(&self) -> bool { self.0 > 5 }\n\n    // error: duplicate associated type\n    type Quux = u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Manual Implementation of FnOnce Trait in Rust with Feature Flags\nDESCRIPTION: This code snippet shows the correct way to manually implement the FnOnce trait for a custom struct. It uses the unstable features 'fn_traits' and 'unboxed_closures', which are enabled via feature flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0183.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(fn_traits, unboxed_closures)]\n\nstruct MyClosure {\n    foo: i32\n}\n\nimpl FnOnce<()> for MyClosure {  // ok!\n    type Output = ();\n    extern \"rust-call\" fn call_once(self, args: ()) -> Self::Output {\n        println!(\"{}\", self.foo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Coroutine Usage in Rust\nDESCRIPTION: The erroneous code example demonstrates a misuse of the `yield` keyword, which results in a compilation error since `yield` can only be utilized within a coroutine literal. The corrected example fixes this by using the `#[coroutine]` attribute and a coroutine literal, ensuring proper execution. It requires the `coroutines`, `coroutine_trait`, and `stmt_expr_attributes` features to be enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0627.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nfn fake_coroutine() -> &'static str {\n    yield 1;\n    return \"foo\"\n}\n\nfn main() {\n    let mut coroutine = fake_coroutine;\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nfn main() {\n    let mut coroutine = #[coroutine] || {\n        yield 1;\n        return \"foo\"\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Unique Lifetime Declaration in Rust Function\nDESCRIPTION: Corrected example showing proper usage where each lifetime parameter has a unique name in the function signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0263.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b, 'c>(x: &'a str, y: &'b str, z: &'c str) { // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Used as Function Error Example\nDESCRIPTION: Demonstrates incorrect usage of a struct identifier as if it were a function name, which results in E0423 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0423.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo { a: bool };\n\nlet f = Foo();\n// error: expected function, tuple struct or tuple variant, found `Foo`\n// `Foo` is a struct name, but this expression uses it like a function name\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Changelog Entries\nDESCRIPTION: Example showing how to include multiple changelog entries in a single PR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nchangelog: Something 1\nchangelog: Something 2\nchangelog: Something 3\n```\n\n----------------------------------------\n\nTITLE: Drop Check Error Example with Moved Value\nDESCRIPTION: Shows how drop checking requires values to be live even after they've been completely moved, due to MIR building assumptions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/drop_check.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x;\n    {\n        let temp = String::from(\"I am temporary\");\n        x = PrintOnDrop(&temp);\n        drop(x);\n    }\n} //~ ERROR `temp` does not live long enough.\n```\n\n----------------------------------------\n\nTITLE: Correct Module Visibility Inside Target Module\nDESCRIPTION: Shows the correct way to restrict visibility by placing the struct inside the target module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0742.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod sea {\n    pub (in crate::sea) struct Shark; // ok!\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Corrected Rust Module Visibility Definition\nDESCRIPTION: Shows the correct way to define module and struct visibility in Rust, ensuring proper module scoping and macro resolution\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0578.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod Sea {\n    pub (in crate::Sea) struct Shark;\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Valid Intrinsic Function Declaration in Rust\nDESCRIPTION: Example of a correct intrinsic function declaration using a recognized intrinsic atomic_fence_seqcst. Demonstrates proper usage of the rustc_intrinsic attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0093.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn atomic_fence_seqcst(); // ok!\n\nfn main() {\n    unsafe {\n        atomic_fence_seqcst();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Rust Doc Tests in Coverage Analysis\nDESCRIPTION: This bash snippet demonstrates how to include Rust documentation tests when generating coverage data. It modifies `RUSTFLAGS` and `RUSTDOCFLAGS` to ensure that both test and doc binaries are covered, using `llvm-profdata` to merge and `llvm-cov` to report.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ RUSTFLAGS=\"-C instrument-coverage\" \\\n  RUSTDOCFLAGS=\"-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n    cargo test\n$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n```\n\n----------------------------------------\n\nTITLE: Checking for generated profraw coverage data files\nDESCRIPTION: Command to list the automatically generated profraw coverage data files after running an instrumented binary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n...\n$ ls default_*.profraw\ndefault_11699812450447639123_0_20944.profraw\n```\n\n----------------------------------------\n\nTITLE: Configuring ARM64e Target in Rust Bootstrap\nDESCRIPTION: Configuration for enabling the ARM64e Apple Darwin target during Rust build process. Requires adding the target to the bootstrap configuration file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64e-apple-darwin.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"arm64e-apple-darwin\"]\n```\n\n----------------------------------------\n\nTITLE: Basic Building Commands\nDESCRIPTION: Commands to prepare the environment, build the sysroot, and run tests for the rustc_codegen_gcc project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh prepare # download and patch sysroot src and install hyperfine for benchmarking\n$ ./y.sh build --sysroot --release\n```\n\n----------------------------------------\n\nTITLE: Erroneous Closure Trait Implementation in Rust\nDESCRIPTION: Demonstrates a closure that fails compilation due to not implementing the expected Fn trait, causing a type mismatch with the function's trait bound\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0525.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct X;\n\nfn foo<T>(_: T) {}\nfn bar<T: Fn(u32)>(_: T) {}\n\nfn main() {\n    let x = X;\n    let closure = |_| foo(x); // error: expected a closure that implements\n                              //        the `Fn` trait, but this closure only\n                              //        implements `FnOnce`\n    bar(closure);\n}\n```\n\n----------------------------------------\n\nTITLE: Character Literal Syntax Error in Rust\nDESCRIPTION: This error occurs when a character literal is not properly closed with a trailing single quote. In Rust, character literals must be enclosed by single quotes and contain exactly one character.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_char_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nCHAR \"'\"\n```\n\n----------------------------------------\n\nTITLE: Specifying a new LLVM - Rust\nDESCRIPTION: This snippet describes the steps to specify a different LLVM fork for new targets in Rust. It includes shell commands to set up the LLVM fork and commit changes to the Rust repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd src/llvm-project\ngit remote add my-target-llvm some-llvm-repository\ngit checkout my-target-llvm/my-branch\ncd ..\ngit add llvm-project\ngit commit -m 'Use my custom LLVM'\n```\n\n----------------------------------------\n\nTITLE: Setting Up M68K Debian Chroot Environment\nDESCRIPTION: Commands for setting up a Debian/M68K chroot environment using debootstrap. This enables running more complex M68K programs through emulation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# apt install debootstrap debian-ports-archive-keyring\n# debootstrap --keyring=/usr/share/keyrings/debian-ports-archive-keyring.gpg --arch=m68k unstable debian-68k http://ftp.ports.debian.org/debian-ports\n```\n\n----------------------------------------\n\nTITLE: Specifying Package Dependencies with Hashes - Python\nDESCRIPTION: This snippet includes package declarations with specific versions and their respective SHA256 hashes, ensuring secured installations via pip. Dependencies include attrs, binaryornot, boolean-py, and others. Each package entry consists of version information and corresponding hashes for integrity verification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/docker/host-x86_64/mingw-check/reuse-requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# This file is autogenerated by pip-compile with Python 3.10\n# by the following command:\n# pip-compile --allow-unsafe --generate-hashes reuse-requirements.in\nattrs==23.2.0 \\\n    --hash=sha256:935dc3b529c262f6cf76e50877d35a4bd3c1de194fd41f47a2b7ae8f19971f30 \\\n    --hash=sha256:99b87a485a5820b23b879f04c2305b44b951b502fd64be915879d77a7e8fc6f1\n    # via reuse\nbinaryornot==0.4.4 \\\n    --hash=sha256:359501dfc9d40632edc9fac890e19542db1a287bbcfa58175b66658392018061 \\\n    --hash=sha256:b8b71173c917bddcd2c16070412e369c3ed7f0528926f70cac18a6c97fd563e4\n    # via reuse\nboolean-py==4.0 \\\n    --hash=sha256:17b9a181630e43dde1851d42bef546d616d5d9b4480357514597e78b203d06e4 \\\n    --hash=sha256:2876f2051d7d6394a531d82dc6eb407faa0b01a0a0b3083817ccd7323b8d96bd\n    # via\n    #   license-expression\n    #   reuse\nchardet==5.2.0 \\\n    --hash=sha256:1b3b6ff479a8c414bc3fa2c0852995695c4a026dcd6d0633b2dd092ca39c1cf7 \\\n    --hash=sha256:e1cf59446890a00105fe7b7912492ea04b6e6f06d4b742b2c788469e34c82970\n    # via\n    #   binaryornot\n    #   python-debian\njinja2==3.1.4 \\\n    --hash=sha256:4a3aee7acbbe7303aede8e9648d13b8bf88a429282aa6122a993f0ac800cb369 \\\n    --hash=sha256:bc5dd2abb727a5319567b7a813e6a2e7318c39f4f487cfe6c89c6f9c7d25197d\n    # via reuse\nlicense-expression==30.3.0 \\\n    --hash=sha256:1295406f736b4f395ff069aec1cebfad53c0fcb3cf57df0f5ec58fc7b905aea5 \\\n    --hash=sha256:ae0ba9a829d6909c785dc2f0131f13d10d68318e4a5f28af5ef152d6b52f9b41\n    # via reuse\nmarkupsafe==2.1.5 \\\n    --hash=sha256:00e046b6dd71aa03a41079792f8473dc494d564611a8f89bbbd7cb93295ebdcf \\\n    --hash=sha256:075202fa5b72c86ad32dc7d0b56024ebdbcf2048c0ba09f1cde31bfdd57bcfff \\\n    --hash=sha256:0e397ac966fdf721b2c528cf028494e86172b4feba51d65f81ffd65c63798f3f \\\n    --hash=sha256:17b950fccb810b3293638215058e432159d2b71005c74371d784862b7e4683f \\\n    --hash=sha256:1f3fbcb7ef1f16e48246f704ab79d79da8a46891e2da03f8783a5b6fa41a9532 \\\n    --hash=sha256:2174c595a0d73a3080ca3257b40096db99799265e1c27cc5a610743acd86d62f \\\n    --hash=sha256:2b7c57a4dfc4f16f7142221afe5ba4e093e09e728ca65c51f5620c9aaeb9a617 \\\n    --hash=sha256:2d2d793e36e230fd32babe143b04cec8a8b3eb8a3122d2aceb4a371e6b09b8df \\\n    --hash=sha256:30b600cf0a7ac9234b2638fbc0fb6158ba5bdcdf46aeb631ead21248b9affbc4 \\\n    --hash=sha256:397081c1a0bfb5124355710fe79478cdbeb39626492b15d399526ae53422b906 \\\n    --hash=sha256:3a57fdd7ce31c7ff06cdfbf31dafa96cc533c21e443d57f5b1ecc6cdc668ec7f \\\n    --hash=sha256:3c6b973f22eb18a789b1460b4b91bf04ae3f0c4234a0a6aa6b0a92f6f7b951d4 \\\n    --hash=sha256:3e53af139f8579a6d5f7b76549125f0d94d7e630761a2111bc431fd820e163b8 \\\n    --hash=sha256:4096e9de5c6fdf43fb4f04c26fb114f61ef0bf2e5604b6ee3019d51b69e8c371 \\\n    --hash=sha256:4275d846e41ecefa46e2015117a9f491e57a71ddd59bbead77e904dc02b1bed2 \\\n    --hash=sha256:4c31f53cdae6ecfa91a77820e8b151dba54ab528ba65dfd235c80b086d68a465 \\\n    --hash=sha256:4f11aa001c540f62c6166c7726f71f7573b52c68c31f014c25cc7901deea0b52 \\\n    --hash=sha256:5049256f536511ee3f7e1b3f87d1d1209d327e818e6ae1365e8653d7e3abb6a6 \\\n    --hash=sha256:58c98fee265677f63a4385256a6d7683ab1832f3ddd1e66fe948d5880c21a169 \\\n    --hash=sha256:598e3276b64aff0e7b3451b72e94fa3c238d452e7ddcd893c3ab324717456bad \\\n    --hash=sha256:5b7b716f97b52c5a14bffdf688f971b2d5ef4029127f1ad7a513973cfd818df2 \\\n    --hash=sha256:5dedb4db619ba5a2787a94d877bc8ffc0566f92a01c0ef214865e54ecc9ee5e0 \\\n    --hash=sha256:619bc166c4f2de5caa5a633b8b7326fbe98e0ccbfacabd87268a2b15ff73a029 \\\n    --hash=sha256:629ddd2ca402ae6dbedfceeba9c46d5f7b2a61d9749597d4307f943ef198fc1f \\\n    --hash=sha256:656f7526c69fac7f600bd1f400991cc282b417d17539a1b228617081106feb4a \\\n    --hash=sha256:6ec585f69cec0aa07d945b20805be741395e28ac1627333b1c5b0105962ffced \\\n    --hash=sha256:72b6be590cc35924b02c78ef34b467da4ba07e4e0f0454a2c5907f473fc50ce5 \\\n    --hash=sha256:7502934a33b54030eaf1194c21c692a534196063db72176b0c4028e140f8f32c \\\n    --hash=sha256:7a68b554d356a91cce1236aa7682dc01df0edba8d043fd1ce607c49dd3c1edcf \\\n    --hash=sha256:7b2e5a267c855eea6b4283940daa6e88a285f5f2a67f2220203786dfa59b37e9 \\\n    --hash=sha256:823b65d8706e32ad2df51ed89496147a42a2a6e01c13cfb6ffb8b1e92bc910bb \\\n    --hash=sha256:8590b4ae07a35970728874632fed7bd57b26b0102df2d2b233b6d9d82f6c62ad \\\n    --hash=sha256:8dd717634f5a044f860435c1d8c16a270ddf0ef8588d4887037c5028b859b0c3 \\\n    --hash=sha256:8dec4936e9c3100156f8a2dc89c4b88d5c435175ff03413b443469c7c8c5f4d1 \\\n    --hash=sha256:97cafb1f3cbcd3fd2b6fbfb99ae11cdb14deea0736fc2b0952ee177f2b813a46 \\\n    --hash=sha256:a17a92de5231666cfbe003f0e4b9b3a7ae3afb1ec2845aadc2bacc93ff85febc \\\n    --hash=sha256:a549b9c31bec33820e885335b451286e2969a2d9e24879f83fe904a5ce59d70a \\\n    --hash=sha256:ac07bad82163452a6884fe8fa0963fb98c2346ba78d779ec06bd7a6262132aee \\\n    --hash=sha256:ae2ad8ae6ebee9d2d94b17fb62763125f3f374c25618198f40cbb8b525411900 \\\n    --hash=sha256:b91c037585eba9095565a3556f611e3cbfaa42ca1e865f7b8015fe5c7336d5a5 \\\n    --hash=sha256:bc1667f8b83f48511b94671e0e441401371dfd0f0a795c7daa4a3cd1dde55bea \\\n    --hash=sha256:bec0a414d016ac1a18862a519e54b2fd0fc8bbfd6890376898a6c0891dd82e9f \\\n    --hash=sha256:bf50cd79a75d181c9181df03572cdce0fbb75cc353bc350712073108cba98de5 \\\n    --hash=sha256:bff1b4290a66b490a2f4719358c0cdcd9bafb6b8f061e45c7a2460866bf50c2e \\\n    --hash=sha256:c061bb86a71b42465156a3ee7bd58c8c2ceacdbeb95d05a99893e08b8467359a \\\n    --hash=sha256:c8b29db45f8fe46ad280a7294f5c3ec36dbac9491f2d1c17345be8e69cc5928f \\\n    --hash=sha256:ce409136744f6521e39fd8e2a24c53fa18ad67aa5bc7c2cf83645cce5b5c4e50 \\\n    --hash=sha256:d050b3361367a06d752db6ead6e7edeb0009be66bc3bae0ee9d97fb326badc2a \\\n    --hash=sha256:d283d37a890ba4c1ae73ffadf8046435c76e7bc2247bbb63c00bd1a709c6544b \\\n    --hash=sha256:d9fad5155d72433c921b782e58892377c44bd6252b5af2f67f16b194987338a4 \\\n    --hash=sha256:daa4ee5a243f0f20d528d939d06670a298dd39b1ad5f8a72a4275124a7819eff \\\n    --hash=sha256:db0b55e0f3cc0be60c1f19efdde9a637c32740486004f20d1cff53c3c0ece4d2 \\\n    --hash=sha256:e61659ba32cf2cf1481e575d0462554625196a1f2fc06a1c777d3f48e8865d46 \\\n    --hash=sha256:ea3d8a3d18833cf4304cd2fc9cbb1efe188ca9b5efef2bdac7adc20594a0e46b \\\n    --hash=sha256:ec6a563cff360b50eed26f13adc43e61bc0c04d94b8be985e6fb24b81f6dcfdf \\\n    --hash=sha256:f5dfb42c4604dddc8e4305050aa6deb084540643ed5804d7455b5df8fe16f5e5 \\\n    --hash=sha256:fa173ec60341d6bb97a89f5ea19c85c5643c1e7dedebc22f5181eb73573142c5 \\\n    --hash=sha256:fa9db3f79de01457b03d4f01b34cf91bc0048eb2c3846ff26f66687c2f6d16ab \\\n    --hash=sha256:fce659a462a1be54d2ffcacea5e3ba2d74daa74f30f5f143fe0c58636e355fdd \\\n    --hash=sha256:ffee1f21e5ef0d712f9033568f8344d5da8cc2869dbd08d87c84656e6a2d2f68\n    # via jinja2\npython-debian==0.1.49 \\\n    --hash=sha256:880f3bc52e31599f2a9b432bd7691844286825087fccdcf2f6ffd5cd79a26f9f \\\n    --hash=sha256:8cf677a30dbcb4be7a99536c17e11308a827a4d22028dc59a67f6c6dd3f0f58c\n    # via reuse\nreuse==4.0.3 \\\n    --hash=sha256:4f2c3e1213ec644e5febc50d8322d18982e4e1102af8a51d9493bfc2164a0eac \\\n    --hash=sha256:b33e26ec1d105cfcfc2e904d103faec0d758994278feb95a4f4290a864562243\n    # via -r reuse-requirements.in\ntomlkit==0.13.0 \\\n    --hash=sha256:08ad192699734149f5b97b45f1f18dad7eb1b6d16bc72ad0c2335772650d7b72 \\\n    --hash=sha256:7075d3042d03b80f603482d69bf0c8f345c2b30e41699fd8883227f89972b264\n    # via reuse\n```\n\n----------------------------------------\n\nTITLE: Disabling Symbol Mangling Version in Rust Compiler with TOML\nDESCRIPTION: This configuration snippet disables the new symbol mangling version in the Rust compiler's `bootstrap.toml`, which is necessary when using older versions of GDB than 10.2.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\nnew-symbol-mangling = false\n```\n\n----------------------------------------\n\nTITLE: Correct Self Usage in Rust Method\nDESCRIPTION: Corrected example showing proper implementation of a method with self receiver parameter, allowing the use of the 'self' keyword within the method body.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0424.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar(&self) {}\n\n    fn foo(self) { // `foo` is now a method.\n        self.bar(); // ok!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting E0049 Error by Adding Missing Type Parameter in Rust\nDESCRIPTION: A corrected implementation of the Foo trait for Bar struct, where the method signature properly includes the required type parameter T with its Default constraint, matching the trait declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0049.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo<T: Default>(x: T) -> Self;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo<T: Default>(x: T) -> Self { // ok!\n        Bar\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of + Type Operator in Rust\nDESCRIPTION: Example showing erroneous usage of the + type operator without proper parentheses, leading to ambiguous context errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0178.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nstruct Bar<'a> {\n    x: &'a Foo + 'a,     // error!\n    y: &'a mut Foo + 'a, // error!\n    z: fn() -> Foo + 'a, // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Installation Directory\nDESCRIPTION: Commands for configuring custom installation paths using DESTDIR environment variable or configure options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport DESTDIR=<path>\n```\n\nLANGUAGE: sh\nCODE:\n```\n./configure --set install.prefix=<path> --set install.sysconfdir=<path>\n```\n\n----------------------------------------\n\nTITLE: Allocating New Types with Ty\nDESCRIPTION: This example illustrates how to allocate a new type using the `new_*` methods on `Ty` in the Rust compiler. It shows the creation of an array type with a constant length and explains the interning and canonicalization process of types in the Rust type system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet array_ty = Ty::new_array_with_const_len(tcx, ty, count);\n```\n\n----------------------------------------\n\nTITLE: Using Non-Struct Variable as Struct in Rust\nDESCRIPTION: Example showing a compilation error when trying to use a regular variable as if it were a struct. The code defines 'foo' as a number but incorrectly attempts to use it as a struct with fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0422.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Boxed Trait Objects for Multiple Types\nDESCRIPTION: This example shows how to use boxed trait objects (Box<dyn T>) as a return type when multiple types are involved. It allows for dynamic dispatch and polymorphism at the cost of some runtime overhead.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0746.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid 'pub' Usage in Rust Function\nDESCRIPTION: This code snippet shows an erroneous use of the 'pub' keyword inside a function. The compiler would previously emit an error for this case, as visibility modifiers have no effect on items defined within functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0447.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    pub struct Bar; // error: visibility has no effect inside functions\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream LLVM Remote with Git\nDESCRIPTION: Adds a remote named 'upstream' pointing to the official LLVM repository.  This allows fetching the latest changes from upstream to be merged into the Rust fork.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_0\n\nLANGUAGE: git\nCODE:\n```\n\"git remote add upstream https://github.com/llvm/llvm-project.git\"\n```\n\nLANGUAGE: git\nCODE:\n```\n\"git fetch upstream\"\n```\n\n----------------------------------------\n\nTITLE: Valid DispatchFromDyn Implementation with PhantomData\nDESCRIPTION: Shows proper implementation of DispatchFromDyn for a wrapper struct that contains a single field plus PhantomData, which is allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0378.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(dispatch_from_dyn)]\nuse std::{\n    ops::DispatchFromDyn,\n    marker::PhantomData,\n};\n\nstruct Wrapper<T> {\n    ptr: T,\n    _phantom: PhantomData<()>,\n}\n\nimpl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\nwhere\n    T: DispatchFromDyn<U>,\n{}\n```\n\n----------------------------------------\n\nTITLE: Using Rust's Hash Collections\nDESCRIPTION: This snippet advises using `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` for better performance instead of the standard collections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n// Rationale: they use a hasher that's significantly faster and using them consistently will reduce code size by some small amount.\n```\n\n----------------------------------------\n\nTITLE: Configuring avoid-breaking-exported-api\nDESCRIPTION: This setting prevents Clippy from suggesting changes that could break the public API of a crate.  It's a boolean value, defaulting to `true`. When enabled, Clippy will be more conservative in its suggestions to maintain backward compatibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Compiling and Analyzing Rust with Stack Size Metadata\nDESCRIPTION: This console snippet demonstrates compiling Rust code with stack size metadata and analyzing the resulting binary using various tools.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ RUSTFLAGS=\"-Z emit-stack-sizes\" cargo build --release\n\n$ size -A target/release/hello | grep stack_sizes || echo section was not found\nsection was not found\n\n$ RUSTFLAGS=\"-Z emit-stack-sizes\" cargo rustc --release -- \\\n    -C link-arg=-Wl,-Tkeep-stack-sizes.x \\\n    -C link-arg=-N\n\n$ size -A target/release/hello | grep stack_sizes\n.stack_sizes                               90   176272\n\n$ # non-allocatable section (flags don't contain the \"A\" (alloc) flag)\n$ readelf -S target/release/hello\nSection Headers:\n  [Nr]   Name              Type             Address           Offset\n       Size              EntSize            Flags  Link  Info  Align\n(..)\n  [1031] .stack_sizes      PROGBITS         000000000002b090  0002b0f0\n       000000000000005a  0000000000000000   L       5     0     1\n\n$ objdump -s -j .stack_sizes target/release/hello\n\ntarget/release/hello:     file format elf64-x86-64\n\nContents of section .stack_sizes:\n 2b090 c0040000 00000000 08f00400 00000000  ................\n 2b0a0 00080005 00000000 00000810 05000000  ................\n 2b0b0 00000000 20050000 00000000 10400500  .... ........@..\n 2b0c0 00000000 00087005 00000000 00000080  ......p.........\n 2b0d0 05000000 00000000 90050000 00000000  ................\n 2b0e0 00a00500 00000000 0000               ..........\n```\n\n----------------------------------------\n\nTITLE: Basic Check-Cfg Command Syntax in Bash\nDESCRIPTION: Shows the basic command syntax for specifying expected configuration names and values using --check-cfg flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc --check-cfg 'cfg(name, values(\"value1\", \"value2\", ... \"valueN\"))'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Circular Dependency Error in Rust\nDESCRIPTION: Shows an erroneous code example where two traits create a circular dependency. FirstTrait depends on SecondTrait and SecondTrait depends on FirstTrait, which is not allowed in Rust's type system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0391.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait FirstTrait : SecondTrait {\n\n}\n\ntrait SecondTrait : FirstTrait {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Version Info in Rust\nDESCRIPTION: Shows the get_version_info macro usage which has been simplified to not require explicit imports of VersionInfo and std::env.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nget_version_info!()\n```\n\n----------------------------------------\n\nTITLE: Implementing Lint with Suggestions in Rust\nDESCRIPTION: Example of implementing a LateLintPass that provides automatic fix suggestions using span_lint_and_sugg with code formatting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx> LateLintPass<'tcx> for LintName {\n    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)  {\n        // Imagine that `some_lint_expr_logic` checks for requirements for emitting the lint\n        if some_lint_expr_logic(expr) {\n            span_lint_and_sugg( // < Note this change\n                cx,\n                LINT_NAME,\n                span,\n                \"message on why the lint is emitted\",\n                \"use\",\n                format!(\"foo + {} * bar\", snippet(cx, expr.span, \"<default>\")), // < Suggestion\n                Applicability::MachineApplicable,\n            );\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Entering m68k Chroot Environment\nDESCRIPTION: Command to enter the previously created Debian m68k chroot using standard chroot utility\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# chroot /path/to/debian-68k\n```\n\n----------------------------------------\n\nTITLE: Macro Invocation Syntax Error\nDESCRIPTION: Shows the common mistake of forgetting the exclamation mark when calling a macro in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0423.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nprintln(\"\");\n// error: expected function, tuple struct or tuple variant,\n// found macro `println`\n// did you mean `println!(...)`? (notice the trailing `!`)\n```\n\n----------------------------------------\n\nTITLE: Invalid Receiver Type Example in Rust Trait Implementation\nDESCRIPTION: This example shows code that fails to compile with error E0307 because it uses an invalid receiver type (&Bar) when implementing a trait for Foo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0307.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nstruct Bar;\n\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for Foo {\n    fn foo(self: &Bar) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Code for Mac Catalyst\nDESCRIPTION: Example command showing how to compile Rust code targeting the Mac Catalyst platform using rustc with the appropriate target specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-ios-macabi.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --target aarch64-apple-ios-macabi your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Panic Abort - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `panic_abort` crate (index 2). It includes the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate provides the `panic!` implementation that simply aborts the process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n2: CrateData {\n    root_file_id: FileId(\n        3,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"panic_abort\",\n            ),\n            canonical_name: \"panic_abort\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Other,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: LintPass Struct with MSRV Field and Constructor - Rust\nDESCRIPTION: Defines a custom LintPass struct (ManualStrip) holding a msrv field for MSRV validation and a constructor taking a Conf reference. This structure is essential when a lint depends on features stabilized in a minimum Rust version. The msrv value is passed from configuration. Dependencies: Msrv and Conf types from Clippy, field injection in clippy_lints/lib.rs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub struct ManualStrip {\n    msrv: Msrv,\n}\n\nimpl ManualStrip {\n    pub fn new(conf: &'static Conf) -> Self {\n        Self { msrv: conf.msrv }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Salsa's Dependency Graph Structure\nDESCRIPTION: A simplified diagram showing how dependencies work in Salsa. It illustrates how derived values depend on inputs and other derived values, which helps explain how Salsa can determine which computations need to be rechecked when inputs change.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_0\n\nLANGUAGE: ignore\nCODE:\n```\nI <- A <- C ...\n          |\nJ <- B <--+\n```\n\n----------------------------------------\n\nTITLE: Installing Josh Proxy for Repository Synchronization\nDESCRIPTION: Command to install the specific version of josh-proxy tool used for synchronizing with the rust-lang/rust repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo +stable install josh-proxy --git https://github.com/josh-project/josh --tag r24.10.04\n```\n\n----------------------------------------\n\nTITLE: Ignoring Files or Patterns in Git Log Diff - bash\nDESCRIPTION: This command snippet shows how to exclude specific files or directory patterns from git log diffs using the syntax ':!<pattern>'. For example, excluding 'Cargo.lock' or entire directories like 'compiler/*'. This is useful for ignoring changes in autogenerated or large files that clutter diffs, improving review focus. Patterns use .gitignore syntax with a colon prepended to indicate filtering in git log.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\ngit log -p ':!Cargo.lock'\n```\n\n----------------------------------------\n\nTITLE: Using Match Expression Inside Rust Loop\nDESCRIPTION: A corrected version that uses a match expression inside the loop body to handle all possible patterns. This approach properly handles both Some and None variants of the Option type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0297.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\nfor item in xs {\n    match item {\n        Some(x) => {},\n        None => {},\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Names Without Values Example in Rust\nDESCRIPTION: Demonstrates checking configuration names without specific values using values(any()).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(is_embedded)]      \nfn do_embedded() {}\n\n#[cfg(has_feathers)]     \nfn do_features() {}\n\n#[cfg(has_feathers = \"zapping\")] \nfn do_zapping() {}\n\n#[cfg(has_mumble_frotz)] \nfn do_mumble_frotz() {}\n```\n\n----------------------------------------\n\nTITLE: Handling Empty Match Arms in Rust\nDESCRIPTION: Shows the preferred way of handling intentionally empty match arms in Rust using '=> (),' for consistency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nmatch result {\n    Ok(_) => (),\n    Err(err) => error!(\"{}\", err),\n}\n\n// BAD\nmatch result {\n    Ok(_) => {},\n    Err(err) => error!(\"{}\", err),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SsrParams Interface for Structural Search Replace\nDESCRIPTION: Defines the parameters for structural search replace operations, allowing for syntax-tree based transformations. Includes the query, parse mode, document context, position, and selection ranges.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SsrParams {\n    /// Search query.\n    /// The specific syntax is specified outside of the protocol.\n    query: string,\n    /// If true, only check the syntax of the query and don't compute the actual edit.\n    parseOnly: boolean,\n    /// The current text document. This and `position` will be used to determine in what scope\n    /// paths in `query` should be resolved.\n    textDocument: TextDocumentIdentifier;\n    /// Position where SSR was invoked.\n    position: Position;\n    /// Current selections. Search/replace will be restricted to these if non-empty.\n    selections: Range[];\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Constructor Error in Rust\nDESCRIPTION: This code snippet shows an erroneous attempt to construct a struct with a private field, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0451.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod bar {\n    pub struct Foo {\n        pub a: isize,\n        b: isize,\n    }\n}\n\nlet f = bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `bar::Foo`\n                                //        is private\n```\n\n----------------------------------------\n\nTITLE: Invalid Marker Trait Implementation Override Example\nDESCRIPTION: Demonstrates an erroneous attempt to override an associated constant in a marker trait implementation. This generates error E0715 because marker traits cannot have overridden items due to potential ambiguity with multiple implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0715.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(marker_trait_attr)]\n\n#[marker]\ntrait Marker {\n    const N: usize = 0;\n    fn do_something() {}\n}\n\nstruct OverrideConst;\nimpl Marker for OverrideConst { // error!\n    const N: usize = 1;\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating FnOnce Constraint in Async Closures (Rust)\nDESCRIPTION: This example shows how capturing and dropping a variable forces the coroutine-closure to be AsyncFnOnce, requiring all captures to be by-move. It demonstrates the need to analyze the body of the coroutine-closure to determine if upvars are used in a 'consuming' way.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x = String::new();\nlet y = String::new();\nlet c = async move || {\n    drop(y);\n    println!(\"{x}\");\n};\n```\n\n----------------------------------------\n\nTITLE: Using the llvm_module_flag compiler option in Rust\nDESCRIPTION: Shows the syntax for the `-Z llvm_module_flag` compiler flag that allows adding custom metadata to the LLVM module flags. It requires specifying a name, type, value, and behavior, with current support limited to u32 values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/llvm-module-flag.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-Z llvm_module_flag=<name>:<type>:<value>:<behavior>\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata in Rust\nDESCRIPTION: This Rust code snippet defines the structure for crate metadata using the `CrateData` struct. It outlines various crate properties such as the root file ID, edition, and version. The snippet is used to capture metadata information essential for managing Rust projects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    0: CrateData {\n        root_file_id: FileId(\n            1,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello-world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"hello_world\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    1: CrateData {\n        root_file_id: FileId(\n            2,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello-world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"hello_world\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    2: CrateData {\n        root_file_id: FileId(\n            3,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"an_example\",\n                ),\n                canonical_name: \"an-example\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"an_example\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    3: CrateData {\n        root_file_id: FileId(\n            4,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"it\",\n                ),\n                canonical_name: \"it\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"it\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    4: CrateData {\n        root_file_id: FileId(\n            5,\n        ),\n        edition: Edition2015,\n        version: Some(\n            \"0.2.98\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"libc\",\n                ),\n                canonical_name: \"libc\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"feature=default\",\n                \"feature=std\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: Some(\n            CfgOptions(\n                [\n                    \"feature=align\",\n                    \"feature=const-extern-fn\",\n                    \"feature=default\",\n                    \"feature=extra_traits\",\n                    \"feature=rustc-dep-of-std\",\n                    \"feature=std\",\n                    \"feature=use_std\",\n                    \"true\",\n                ],\n            ),\n        ),\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"libc\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n                \"CARGO_PKG_AUTHORS\": \"The Rust Project Developers\",\n                \"CARGO_PKG_DESCRIPTION\": \"Raw FFI bindings to platform libraries like libc.\\n\",\n                \"CARGO_PKG_HOMEPAGE\": \"https://github.com/rust-lang/libc\",\n            },\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Codegen Units in Rust\nDESCRIPTION: This flag controls the maximum number of code generation units the crate is split into. Increasing this number can speed up compile times by enabling more parallelism, but may result in slower code. A value of 1 may improve code performance but might slow down compilation. The default value is 16 for non-incremental builds and 256 for incremental builds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Publishing clippy_utils - Bash\nDESCRIPTION: This command sequence publishes the `clippy_utils` crate to `crates.io`. It first switches to the `master` branch, pulls the latest changes from `upstream`, and then uses `cargo publish` to publish the crate.  It requires the Rustup PR bumping nightly and Clippy versions to be merged first.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit switch master && git pull upstream master\ncargo publish --manifest-path clippy_utils/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Building LLVM within Rust Project\nDESCRIPTION: These commands are used to build LLVM as part of the Rust build process. The first builds only LLVM, while the second builds the entire Rust compiler toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"./x build src/llvm-project\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n\"./x build\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Static Reference Requirements in Rust\nDESCRIPTION: Example showing a type mismatch between a function requiring static reference and one accepting any reference lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(x: &'static u32) { }\n\nfn bar(f: for<'a> fn(&'a u32)) {\n    let x = 22;\n    f(&x);\n}\n\nfn main() {\n    bar(foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code with Stack Size Metadata\nDESCRIPTION: This console snippet demonstrates compiling Rust code with and without the -Z emit-stack-sizes flag, showing the difference in output object file sections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -C opt-level=3 --emit=obj foo.rs\n\n$ size -A foo.o\nfoo.o  :\nsection                                 size   addr\n.text                                      0      0\n.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0\n.text._ZN3foo3bar17h1acb594305f70c2eE     22      0\n.note.GNU-stack                            0      0\n.eh_frame                                 72      0\nTotal                                     95\n\n$ rustc -C opt-level=3 --emit=obj -Z emit-stack-sizes foo.rs\n\n$ size -A foo.o\nfoo.o  :\nsection                                 size   addr\n.text                                      0      0\n.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0\n.stack_sizes                               9      0\n.text._ZN3foo3bar17h1acb594305f70c2eE     22      0\n.stack_sizes                               9      0\n.note.GNU-stack                            0      0\n.eh_frame                                 72      0\nTotal                                    113\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Secure Function Call in Rust for TrustZone-M\nDESCRIPTION: Demonstrates how to create a function that safely calls into non-secure code using the C-cmse-nonsecure-call ABI. The code uses unsafe transmutation to convert a memory address into a function pointer with the appropriate calling convention.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-c-cmse-nonsecure-call.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n#![feature(abi_c_cmse_nonsecure_call)]\n\n#[no_mangle]\npub fn call_nonsecure_function(addr: usize) -> u32 {\n    let non_secure_function =\n        unsafe { core::mem::transmute::<usize, extern \"C-cmse-nonsecure-call\" fn() -> u32>(addr) };\n    non_secure_function()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Version in Cargo.toml for Release\nDESCRIPTION: A diff showing how to update the version number in Cargo.toml when preparing a rustfmt release. The example demonstrates incrementing from version 1.0.0 to 1.0.1.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Processes.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Object Creation with Self-returning Method in Rust\nDESCRIPTION: Demonstrates code that fails to compile because it tries to use a trait with Self-returning methods as a trait object. The compiler cannot determine the concrete return type at the call site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Mismatched Pattern Elements in Rust\nDESCRIPTION: This snippet demonstrates an error when the number of elements in a pattern does not match the elements in the array. It highlights the importance of using patterns that align with the array's size to avoid compile errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0527.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet r = &[1, 2, 3, 4];\nmatch r {\n    &[a, b] => { // error: pattern requires 2 elements but array\n                 //        has 4\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Candidate Stack in Old Rust Trait System\nDESCRIPTION: In the old trait system implementation, candidate selection discards constraints of each candidate, only applying them by reevaluating the candidate after selection. This is due to the lack of canonicalization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/significant-changes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Source: evaluate_stack\nlet candidate = self.evaluate_stack(\n    stack,\n    param_env,\n    obligation,\n    selcx,\n    evaluate_only,\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Variable Binding in Or Pattern - Rust\nDESCRIPTION: This example shows erroneous code where a variable 'y' is not consistently bound across all patterns in an OR pattern match expression. The code fails to compile because 'y' is only bound in the Some variant but not in None.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0408.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch x {\n    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n                                      //        not bound in pattern #2\n    _ => ()\n}\n```\n\n----------------------------------------\n\nTITLE: Listing sysroot libraries - Rust\nDESCRIPTION: This snippet demonstrates how to list the libraries present in the Rust compiler's sysroot directory, which contains necessary runtime dependencies and standard libraries. The command utilizes the output of 'rustc --print sysroot' to point to the correct location.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/what-bootstrapping-does.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ls $(rustc --print sysroot)/lib\nlibchalk_derive-0685d79833dc9b2b.so  libstd-25c6acf8063a3802.so\nlibLLVM-11-rust-1.50.0-nightly.so    libtest-57470d2aa8f7aa83.so\nlibrustc_driver-4f0cc9f50e53f0ba.so  libtracing_attributes-e4be92c35ab2a33b.so\nlibrustc_macros-5f0ec4a119c6ac86.so  rustlib\n```\n\n----------------------------------------\n\nTITLE: Generating MIR for a Simple Rust Program\nDESCRIPTION: This snippet demonstrates a simple Rust program that creates a vector and pushes two integers into it. The MIR output for this program can be viewed in the Rust Playground.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/index.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut vec = Vec::new();\n    vec.push(1);\n    vec.push(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Moving from mod.rs to Parent Rust File\nDESCRIPTION: Moves code from a module's mod.rs file to a corresponding parent .rs file. This refactoring helps flatten the module hierarchy by converting from the older nested mod.rs pattern to a file-based module system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_87\n\nLANGUAGE: rust\nCODE:\n```\n//- /main.rs\nmod a;\n//- /a/mod.rs\nfn t() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn t() {}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple #[doc] Attributes\nDESCRIPTION: This code illustrates how to concatenate multiple #[doc] attributes to form a single documentation comment using the collapse-docs pass in macros.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#[doc = \\\"This is\\\"]\\n#[doc = \\\" a \\\"]\\n#[doc = \\\"doc comment\\\"]\\n# fn f() {}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Not Found Error in Rust\nDESCRIPTION: This code snippet demonstrates the Rust compiler error E0599.  The `Mouth` struct does not initially implement the `chocolate` method, causing a compile error when the method is called on an instance of the `Mouth` struct.  This highlights the importance of implementing methods for structs before they can be called.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0599.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n```\n\n----------------------------------------\n\nTITLE: Using impl Trait as a Solution for Single Type Returns\nDESCRIPTION: This snippet demonstrates how to use `impl Trait` as a return type when there's a single concrete type involved. This allows the function to return a type that implements the trait without boxing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0746.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Optimize Attribute Usage in Rust\nDESCRIPTION: Example of incorrect usage of the #[optimize] attribute that results in error E0722 due to invalid argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0722.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(optimize_attribute)]\n\n#[optimize(something)] // error: invalid argument\npub fn something() {}\n```\n\n----------------------------------------\n\nTITLE: Using PhantomData to Fix Unused Lifetime Parameter in Rust Struct\nDESCRIPTION: This code snippet demonstrates how to use PhantomData to express lifetime constraints and resolve the E0392 error when working with raw pointers and lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0392.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::marker::PhantomData;\n\nstruct Foo<'a, T: 'a> {\n    x: *const T,\n    phantom: PhantomData<&'a T>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Suggestions in Rust Compiler\nDESCRIPTION: Example showing how to create machine-applicable code suggestions using the Diag struct. The code demonstrates error handling with span suggestions and applicability levels.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet mut err = sess.dcx.struct_span_err(sp, fluent::example::message);\n\nif let Ok(snippet) = sess.source_map().span_to_snippet(sp) {\n    err.span_suggestion(\n        suggestion_sp,\n        fluent::example::try_qux_suggestion,\n        format!(\"qux {}\", snippet),\n        Applicability::MachineApplicable,\n    );\n} else {\n    err.span_help(suggestion_sp, fluent::example::qux_suggestion);\n}\n\nerr.emit();\n```\n\n----------------------------------------\n\nTITLE: Rust Types and Data Structures Reference\nDESCRIPTION: Common type definitions and data structures mentioned in the glossary include BodyId, DefId, HirId, and InferCtxt. These are fundamental building blocks used throughout the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/glossary.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nDefId         // An index identifying a definition\nBodyId        // An identifier for a specific body (function/constant)\nHirId         // Identifies a HIR node by combining def-id with offset\nInferCtxt     // Type inference context\nGenericArgs   // Used for substituting early-bound lifetimes\n```\n\n----------------------------------------\n\nTITLE: Incremental Compilation Test Example in Rust\nDESCRIPTION: Demonstrates how to write an incremental compilation test using revisions. The test simulates source code changes across multiple compiler runs using cfg attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n//@ revisions: rpass1 rpass2\n\n#[cfg(rpass1)]\nfn foo() {\n    println!(\"one\");\n}\n\n#[cfg(rpass2)]\nfn foo() {\n    println!(\"two\");\n}\n\nfn main() { foo(); }\n```\n\n----------------------------------------\n\nTITLE: Running Clippy on Package Without Dependencies\nDESCRIPTION: Command to run Clippy on a specific package without checking its dependencies.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy -p example -- --no-deps\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enum Discriminant Overflow Error in Rust\nDESCRIPTION: Example showing how enum discriminant overflow occurs when a variant exceeds the maximum value for the specified representation type (i64).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0370.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(i64)]\nenum Foo {\n    X = 0x7fffffffffffffff,\n    Y, // error: enum discriminant overflowed on value after\n       //        9223372036854775807: i64; set explicitly via\n       //        Y = -9223372036854775808 if that is desired outcome\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Coroutines Usage in Rust\nDESCRIPTION: This code snippet illustrates how to use coroutines, an unstable feature in Rust. It shows the declaration of a coroutine, yielding a value, and resuming execution. The example also demonstrates how to handle different coroutine states.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/the-unstable-book.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nuse std::ops::{Coroutine, CoroutineState};\nuse std::pin::Pin;\n\nfn main() {\n    let mut coroutine = #[coroutine] || {\n        yield 1;\n        return \"foo\"\n    };\n\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Yielded(1) => {}\n        _ => panic!(\"unexpected value from resume\"),\n    }\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Complete(\"foo\") => {}\n        _ => panic!(\"unexpected value from resume\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constructor Grouping and Splitting in Rust Pattern Matching\nDESCRIPTION: This snippet shows how constructors are grouped and split in pattern matching to optimize the exhaustiveness checking process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmatch (0, false) {\n    (0 ..=100, true) => {}\n    (50..=150, false) => {}\n    (0 ..=200, _) => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Function Without Clone Trait Bound\nDESCRIPTION: Example of a function that would fail compilation due to missing Clone trait constraint\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo2<T>(a: T) {\n    requires_clone(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Large List Imports in Rust\nDESCRIPTION: Guidelines for formatting large imports that require multiple lines, showing preferred style with multiple import statements and alternative block-indented format when necessary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n// Prefer\nfoo::{long, list, of, imports};\nfoo::{more, imports};\n\n// If necessary\nfoo::{\n    long, list, of, imports, more,\n    imports,  // Note trailing comma\n};\n```\n\n----------------------------------------\n\nTITLE: Printing \"Hello, world!\" in Rust\nDESCRIPTION: This snippet demonstrates a basic Rust program that prints \"Hello, world!\" to the console. It defines the `main` function, which is the entry point of the program, and uses the `println!` macro to print the message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/include-bytes-deps/input.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"# Hello, world!\"\n```\n\n----------------------------------------\n\nTITLE: Redirecting control flow to a function with different parameter and return types in Rust\nDESCRIPTION: This example demonstrates how CFI prevents calling a function with different parameter and return types than expected at the call site. The code attempts to call a function operating on i64 values through a function pointer type for i32 values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn add_two(x: i64) -> i64 {\n    x + 2\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n\n    println!(\"With CFI enabled, you should not see the next answer\");\n    let f: fn(i32) -> i32 =\n        unsafe { mem::transmute::<*const u8, fn(i32) -> i32>(add_two as *const u8) };\n    let next_answer = do_twice(f, 5);\n\n    println!(\"The next answer is: {}\", next_answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Position and Diagnostic Data Structure in Rust\nDESCRIPTION: This code snippet defines part of a diagnostic data structure that includes position coordinates (line and character), a message field, tags, and data fields. It likely represents compiler or linter output for code analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/clippy_pass_by_ref.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n                                start: Position {\n                                    line: 41,\n                                    character: 23,\n                                },\n                                end: Position {\n                                    line: 41,\n                                    character: 28,\n                                },\n                            },\n                        },\n                        message: \"original diagnostic\",\n                    },\n                ],\n            ),\n            tags: None,\n            data: None,\n        },\n        fix: None,\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Casting Pointer with Unknown Kind - Rust\nDESCRIPTION: This snippet shows an erroneous attempt to cast zero to a pointer type without sufficient type information, which results in a compile-time error. The root cause is the lack of type information that could guide the conversion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0641.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet b = 0 as *const _; // error\n```\n\n----------------------------------------\n\nTITLE: Handling Borrowed Data in Closure with Lifetime Error\nDESCRIPTION: This snippet demonstrates a closure that attempts to borrow data that escapes its scope, which leads to a compilation error in Rust. It highlights the importance of managing lifetimes correctly in closures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0521.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut list: Vec<&str> = Vec::new();\n\nlet _add = |el: &str| {\n    list.push(el); // error: `el` escapes the closure body here\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Object Declaration Without dyn Keyword\nDESCRIPTION: Example showing incorrect trait object declaration without the required 'dyn' keyword, which results in compilation error E0782.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0782.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\nfn test(arg: Box<Foo>) {} // error!\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Unsafe Trait in Rust\nDESCRIPTION: This code snippet shows the correct way to implement an unsafe trait by marking the implementation as unsafe. This resolves the E0200 error and allows the code to compile successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0200.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nunsafe trait Bar { }\n\nunsafe impl Bar for Foo { } // ok!\n```\n\n----------------------------------------\n\nTITLE: Incorrect Manual Destructor Call in Rust\nDESCRIPTION: Example showing an erroneous attempt to manually call a destructor method on a struct. This code fails to compile because explicit destructor calls are not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0040.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n}\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"kaboom\");\n    }\n}\n\nfn main() {\n    let mut x = Foo { x: -7 };\n    x.drop(); // error: explicit use of destructor method\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Rustfmt TOML Configuration\nDESCRIPTION: Example of a basic rustfmt.toml configuration file showing how to set indentation style and import reordering.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nindent_style = \"Block\"\nreorder_imports = false\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code for WASI Target\nDESCRIPTION: Compiles a given Rust source file for the wasm32-wasip1 target. This command employs the Rust compiler with a specific target option, which must be installed beforehand using Rustup. This facilitates building Rust applications to run in WASI-compliant WebAssembly environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nrustc --target wasm32-wasip1 your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Configuring Conditional Code Execution with cfg_sanitize in Rust\nDESCRIPTION: Demonstrates how to use the cfg_sanitize feature to write code that executes differently based on whether thread or leak sanitizers are enabled. Shows both compile-time (#[cfg]) and runtime (cfg!) conditional examples.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/cfg-sanitize.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(cfg_sanitize)]\n\n#[cfg(sanitize = \"thread\")]\nfn a() {\n    // ...\n}\n\n#[cfg(not(sanitize = \"thread\"))]\nfn a() {\n    // ...\n}\n\nfn b() {\n    if cfg!(sanitize = \"leak\") {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust E0618 Error with Non-Callable Items\nDESCRIPTION: This Rust snippet illustrates the E0618 compiler error. It shows two cases where this error occurs: attempting to call a simple enum variant (`X::Entry()`) and attempting to call a primitive integer variable (`x()`) using function call syntax `()`. The comments within the code explicitly state the expected error message for each case.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0618.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Item Usage in Rust\nDESCRIPTION: This code snippet shows an example of ambiguous item usage in Rust. It defines two modules with functions of the same name, imports them into a third module, and attempts to use the ambiguous function, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0659.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\n----------------------------------------\n\nTITLE: Static Library Definition in Rust\nDESCRIPTION: Example of a Rust source file (a.rs) that defines a static library using the staticlib crate type attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0462.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"staticlib\"]\n\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Correcting Type for Variadic Function Call - Rust\nDESCRIPTION: This code snippet presents the corrected version of the previous erroneous example, showing the proper casting of a Rust type to a C-compatible type. It demonstrates how to safely call the C variadic function by ensuring that the types match as per the ABI requirements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0617.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n# use std::os::raw::{c_char, c_int};\n# extern \"C\" {\n#     fn printf(format: *const c_char, ...) -> c_int;\n# }\n\nunsafe {\n    printf(\"%f\\n\\0\".as_ptr() as _, 0f64); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Documentation\nDESCRIPTION: This command builds the standard library documentation for Rust at a specific stage, and opens it automatically in your default browser. It supports documentation development and verification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nx doc --stage 0 library --open\n```\n\n----------------------------------------\n\nTITLE: Failing Trait Implementation with Mismatched Associated Type\nDESCRIPTION: This code demonstrates the E0437 error. The `impl` block defines an associated type `Bar` that is not present in the `Foo` trait definition, leading to a compilation failure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0437.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0437\ntrait Foo {}\n\nimpl Foo for i32 {\n    type Bar = bool;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Associated Item Constraint in Type Parameter Declaration\nDESCRIPTION: This snippet shows the correct way to use associated item constraints by moving them to the type parameter declaration. This resolves the E0229 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0229.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct Bar;\n# trait Foo { type A; }\nfn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Correct Explicit Lifetime Binders Usage in Rust\nDESCRIPTION: This code snippet shows the correct usage of explicit lifetime binders in Rust. It demonstrates proper syntax for function declarations with multiple lifetimes, struct implementations, and impl blocks, avoiding the deprecated in-band lifetimes feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0688.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b>(x: &'a u32, y: &'b u32) {}   // ok!\n\nstruct Foo<'a> { x: &'a u32 }\n\nimpl<'a> Foo<'a> {\n    fn bar<'b,'c>(x: &'a u32, y: &'b u32, z: &'c u32) {}    // ok!\n}\n\nimpl<'a> Foo<'a> {  // ok!\n    fn baz() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Blank Lines Formatting Applied\nDESCRIPTION: Example showing how blank lines are formatted with a minimum of 1 blank line between items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n\n    println!(\"a\");\n}\n\nfn bar() {\n\n    println!(\"b\");\n\n    println!(\"c\");\n}\n```\n\n----------------------------------------\n\nTITLE: Adding RISC-V Target for Cross-Compilation\nDESCRIPTION: Command to add the RISC-V target using rustup for cross-compilation purposes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add riscv64gc-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Template for Rust Function\nDESCRIPTION: This snippet shows how to add a documentation template above a function definition or declaration. It includes sections for description, errors, and safety considerations, tailored to the function's signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_47\n\nLANGUAGE: rust\nCODE:\n```\npub struct S;\nimpl S {\n    pub unsafe fn set_len(&mut self, len: usize) -> Result<(), std::io::Error> {\n        /* ... */\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub struct S;\nimpl S {\n    /// Sets the length of this [`S`].\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if .\n    ///\n    /// # Safety\n    ///\n    /// .\n    pub unsafe fn set_len(&mut self, len: usize) -> Result<(), std::io::Error> {\n        /* ... */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid C-cmse-nonsecure-call Function with Too Many Arguments\nDESCRIPTION: Example showing incorrect usage where function has too many u32 arguments (5) which exceeds the 4 available 32-bit registers limitation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0798.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_c_cmse_nonsecure_call)]\n\n#[no_mangle]\npub fn test(\n    f: extern \"C-cmse-nonsecure-call\" fn(u32, u32, u32, u32, u32) -> u32,\n) -> u32 {\n    f(1, 2, 3, 4, 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Working Generic Trait Implementation Usage\nDESCRIPTION: Demonstrates successful usage of a generically implemented trait on a specific type, showing how the generic implementation applies to all types in scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0119.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GNU Linker for Cross-Compilation\nDESCRIPTION: Configuration to specify the GNU linker for a specific Arm target in Cargo's configuration file\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm-none-eabi.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.<your-target>]\nlinker = \"arm-none-eabi-ld\"\n```\n\n----------------------------------------\n\nTITLE: Receiver Type Steps Example\nDESCRIPTION: Illustrates the progressive dereferencing and potential unsizing steps for method lookup with a complex receiver type\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/method-lookup.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Receiver type: Rc<Box<[T; 3]>>\n// Lookup steps:\n1. Rc<Box<[T; 3]>>\n2. Box<[T; 3]>\n3. [T; 3]\n4. [T]\n```\n\n----------------------------------------\n\nTITLE: Determining Expected Type at Cursor Position (Rust)\nDESCRIPTION: This code determines the expected type at the cursor position during completion, enabling type-directed completion suggestions that match the expected type in the context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L467\n```\n\n----------------------------------------\n\nTITLE: Defining Byte Literals in Rust\nDESCRIPTION: This snippet shows how to define byte literals in Rust using the `b''` syntax. It includes examples with empty byte literals, byte literals with a character, and byte literals with escape sequences.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/byte_strings.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b''\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'x'\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'\\\\n'\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'\\\\\\\\'\\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'\\\\'\\''\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Basic perf Command for Profiling\nDESCRIPTION: The fundamental perf command for recording performance data with call graph information using DWARF debugging format. This samples at 99 Hz to avoid generating excessive data while maintaining accuracy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nperf record -F99 --call-graph dwarf XXX\n```\n\n----------------------------------------\n\nTITLE: Building AVR Project\nDESCRIPTION: Console command for building a Rust project targeting AVR microcontrollers with release configuration\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/avr-none.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build --release\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for pthread Functions in Rust\nDESCRIPTION: This snippet defines DFSan behavior for various pthread functions, marking most as 'discard' to ignore them during data flow analysis. It includes thread management, mutex operations, and attribute handling functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfun:__pthread_register_cancel=discard\nfun:__pthread_unregister_cancel=discard\nfun:pthread_attr_destroy=discard\nfun:pthread_attr_getaffinity_np=discard\nfun:pthread_attr_getdetachstate=discard\nfun:pthread_attr_getguardsize=discard\nfun:pthread_attr_getinheritsched=discard\nfun:pthread_attr_getschedparam=discard\nfun:pthread_attr_getschedpolicy=discard\nfun:pthread_attr_getscope=discard\nfun:pthread_attr_getstack=discard\nfun:pthread_attr_getstackaddr=disacrd\nfun:pthread_attr_getstacksize=discard\nfun:pthread_attr_init=discard\nfun:pthread_attr_setaffinity_np=discard\nfun:pthread_attr_setdetachstate=discard\nfun:pthread_attr_setguardsize=discard\nfun:pthread_attr_setinheritsched=discard\nfun:pthread_attr_setschedparam=discard\nfun:pthread_attr_setschedpolicy=discard\nfun:pthread_attr_setscope=discard\nfun:pthread_attr_setstack=discard\nfun:pthread_attr_setstackaddr=discard\nfun:pthread_attr_setstacksize=discard\nfun:pthread_equal=discard\nfun:pthread_getschedparam=discard\nfun:pthread_getspecific=discard\nfun:pthread_key_create=discard\nfun:pthread_key_delete=discard\nfun:pthread_mutex_destroy=discard\nfun:pthread_mutex_init=discard\nfun:pthread_mutex_lock=discard\nfun:pthread_mutex_trylock=discard\nfun:pthread_mutex_unlock=discard\nfun:pthread_mutexattr_destroy=discard\nfun:pthread_mutexattr_init=discard\nfun:pthread_mutexattr_settype=discard\nfun:pthread_rwlock_destroy=discard\nfun:pthread_rwlock_init=discard\nfun:pthread_rwlock_rdlock=discard\nfun:pthread_rwlock_timedrdlock=discard\nfun:pthread_rwlock_timedwrlock=discard\nfun:pthread_rwlock_tryrdlock=discard\nfun:pthread_rwlock_trywrlock=discard\nfun:pthread_rwlock_wrlock=discard\nfun:pthread_rwlock_unlock=discard\nfun:pthread_setschedparam=discard\nfun:pthread_setname_np=discard\nfun:pthread_once=discard\nfun:pthread_self=discard\nfun:pthread_setspecific=discard\n```\n\n----------------------------------------\n\nTITLE: Installing s390x Cross-Toolchain on Ubuntu\nDESCRIPTION: This snippet demonstrates how to install a s390x cross-toolchain on Ubuntu using `apt`. This toolchain includes the GCC compiler, C++ compiler, and necessary development libraries for cross-compiling C and C++ code for the `s390x-unknown-linux-gnu` target. Installing these packages allows you to build C/C++ dependencies required by Rust crates targeting s390x.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n\n```bash\napt install gcc-s390x-linux-gnu g++-s390x-linux-gnu libc6-dev-s390x-cross\n```\n\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for Fuchsia Targets\nDESCRIPTION: This TOML configuration specifies native library paths in .cargo/config.toml needed for linking Fuchsia libraries during compilation. Update <SDK_PATH> with the actual path to the Fuchsia SDK.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_3\n\nLANGUAGE: txt\nCODE:\n```\n[target.x86_64-unknown-fuchsia]\n\nrustflags = [\n    \"-Lnative=<SDK_PATH>/arch/x64/lib\",\n    \"-Lnative=<SDK_PATH>/arch/x64/sysroot/lib\"\n]\n```\n\n----------------------------------------\n\nTITLE: Usefulness Checking in Various Rust Pattern Matching Contexts\nDESCRIPTION: This snippet demonstrates where usefulness checking occurs in Rust, including match expressions, if let, while let, destructuring let, and function arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// `match`\n// Usefulness can detect unreachable branches and forbid non-exhaustive matches.\nmatch foo() {\n    Ok(x) => x,\n    Err(_) => panic!(),\n}\n\n// `if let`\n// Usefulness can detect unreachable branches.\nif let Some(x) = foo() {\n    // ...\n}\n\n// `while let`\n// Usefulness can detect infinite loops and dead loops.\nwhile let Some(x) = it.next() {\n    // ...\n}\n\n// Destructuring `let`\n// Usefulness can forbid non-exhaustive patterns.\nlet Foo::Bar(x, y) = foo();\n\n// Destructuring function arguments\n// Usefulness can forbid non-exhaustive patterns.\nfn foo(Foo { x, y }: Foo) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Auto Trait Implementation Syntax in Rust\nDESCRIPTION: Shows the syntax for explicit positive and negative implementations of auto traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/auto-traits.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl<...> AutoTrait for StructName<..> { }\nimpl<...> !AutoTrait for StructName<..> { }\n```\n\n----------------------------------------\n\nTITLE: Test Harness Generation\nDESCRIPTION: Illustrates the test harness code generated by the compiler to run the tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[main]\npub fn main() {\n    extern crate test;\n    test::test_main_static(&[&path::to::test1, /*...*/]);\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Multiple Candidates Error in Rust\nDESCRIPTION: This Rust snippet demonstrates a scenario where the compiler encounters multiple library files with the same crate name, leading to an error. It requires multiple auxiliary build files defining the same `crateresolve` crate. The code highlights the importance of specifying crate paths or cleaning the build directory to avoid such conflicts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0523.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// aux-build:crateresolve-1.rs\\n// aux-build:crateresolve-2.rs\\n// aux-build:crateresolve-3.rs\\n\\nextern crate crateresolve;\\n//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found\\n\\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Using c++filt with perf-focus\nDESCRIPTION: Command to pipe perf script output through c++filt to decode C++ mangled names before analyzing with perf-focus. This improves readability of function names in the analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nperf script | c++filt | perf focus --from-stdin ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unreachable Match Arms in Rust\nDESCRIPTION: This code snippet illustrates a match expression with unreachable arms. The last arm (_ => {...}) will never be executed because all possible cases are handled by the preceding patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0001.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch Some(0) {\n    Some(bar) => {/* ... */}\n    x => {/* ... */} // This handles the `None` case\n    _ => {/* ... */} // All possible cases have already been handled\n}\n```\n\n----------------------------------------\n\nTITLE: Interpreting Placeholders Syntax in Rust Compiler\nDESCRIPTION: Describes the syntax for placeholders in the Rust compiler. The format is !{id} or !{id}_{universe}, representing a unique type in the specified universe. The universe is often omitted when it is 0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n!x\n```\n\nLANGUAGE: rust\nCODE:\n```\n!0\n```\n\nLANGUAGE: rust\nCODE:\n```\n!x_2\n```\n\nLANGUAGE: rust\nCODE:\n```\n!0_2\n```\n\n----------------------------------------\n\nTITLE: Setting Codegen Units for Rust Compiler\nDESCRIPTION: This TOML configuration sets the number of codegen units for both `rustc` and `libstd` to one. Modifying the codegen units can lead to faster compiler builds, as it affects how the work of code generation is divided and parallelized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\ncodegen-units = 1\ncodegen-units-std = 1\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Representation of DiscoverProjectData::Finished for rust-analyzer\nDESCRIPTION: Example JSON showing the serialized form of the DiscoverProjectData::Finished variant. It indicates successful workspace discovery with the buildfile path and a project JSON containing sysroot and crate list fields. This example illustrates the expected JSON structure returned by the custom workspace discovery command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"kind\": \"finished\",\n    \"buildfile\": \"rust-analyzer/BUILD\",\n    \"project\": {\n        \"sysroot\": \"foo\",\n        \"crates\": []\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Making the Type Public\nDESCRIPTION: Demonstrates fixing the privacy error by making the private type public, allowing it to be used in the public trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0446.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct Bar; // we set the Bar trait public\n\npub trait PubTr {\n    type Alias;\n}\n\nimpl PubTr for u8 {\n    type Alias = Bar;\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Crate-Level Import Granularity in Rust\nDESCRIPTION: Demonstrates the imports_granularity setting set to Crate, which merges imports from the same crate while keeping imports from different crates separate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_51\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::{\n    a, b,\n    b::{f, g},\n    c,\n    d::e,\n};\nuse qux::{h, i};\n```\n\n----------------------------------------\n\nTITLE: Rust: Inspecting Dataflow Results with ResultsVisitor\nDESCRIPTION: This code snippet illustrates how to inspect the fixpoint state of a dataflow analysis using a `ResultsVisitor`.  It assumes that `MyVisitor` implements the `ResultsVisitor` trait, iterates to fixpoint using `MyAnalysis`, and then visits every location within every block to inspect the state.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/dataflow.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\n// Assuming `MyVisitor` implements `ResultsVisitor<FlowState = MyAnalysis::Domain>`...\nlet mut my_visitor = MyVisitor::new();\n\n// inspect the fixpoint state for every location within every block in RPO.\nlet results = MyAnalysis::new()\n    .iterate_to_fixpoint(tcx, body, None);\nresults.visit_with(body, &mut my_visitor);`\n```\n```\n\n----------------------------------------\n\nTITLE: Basic PGO Workflow with rustc\nDESCRIPTION: Complete 4-step workflow for profile-guided optimization using rustc directly. Includes compiling with instrumentation, running the instrumented binary, merging profile data, and final optimized compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/profile-guided-optimization.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# STEP 1: Compile the binary with instrumentation\nrustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs\n\n# STEP 2: Run the binary a few times, maybe with common sets of args.\n#         Each run will create or update `.profraw` files in /tmp/pgo-data\n./main mydata1.csv\n./main mydata2.csv\n./main mydata3.csv\n\n# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data\nllvm-profdata merge -o ./merged.profdata /tmp/pgo-data\n\n# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`\n#         flags have to be the same.\nrustc -Cprofile-use=./merged.profdata -O ./main.rs\n```\n\n----------------------------------------\n\nTITLE: Markdown Reference Links\nDESCRIPTION: Reference-style links in markdown defining URLs for the rustc development guide and rustc book source repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/contributing.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[rustc_dev_guide]: https://rustc-dev-guide.rust-lang.org/\n[rustc_book]: https://github.com/rust-lang/rust/tree/master/src/doc/rustc\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Rust Compiler Feature: fmt_internals\nDESCRIPTION: This code snippet defines an internal feature of the Rust compiler named 'fmt_internals'. It explicitly states that this feature is not meant for general use and is restricted to the compiler's internal operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/fmt-internals.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# `fmt_internals`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unknown External Lang Item Error in Rust\nDESCRIPTION: This code example shows the error that occurs when using an undefined external lang item 'cake'. External lang items must be from the approved list in the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0264.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items)]\n#![allow(internal_features)]\n\nextern \"C\" {\n    #[lang = \"cake\"] // error: unknown external lang item: `cake`\n    fn cake();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0572 Error: Return Outside Function in Rust\nDESCRIPTION: This snippet demonstrates the E0572 error in Rust, which occurs when a `return` statement is placed outside the context of a function. The `const FOO` declaration attempts to assign the result of a `return` statement, leading to the compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0572.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0572\nconst FOO: u32 = return 0; // error: return statement outside of function body\n\nfn main() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Enum Definition Formatting in Rust\nDESCRIPTION: Illustrates the preferred formatting for enum definitions in Rust, including placing each variant on its own line with block indentation. It also covers different enum variant types such as struct variants, tuple struct variants, and identifiers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum FooBar {\n    First(u32),\n    Second,\n    Error {\n        err: Box<Error>,\n        line: u32,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Static in Rust\nDESCRIPTION: This snippet defines a static item named 'STATIC', providing key details about its ID and location. It plays a crucial role in ensuring efficiency and memory management within the Rust program.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"STATIC\",\n    def: Static(\n        Static {\n            id: StaticId(\n                0,\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: STATIC,\n            range: 435..469,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 442..448,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Linker Errors with libgccijt in Rust\nDESCRIPTION: When compiling an executable with libgccijt and setting *LIBRARY_PATH variables to the install directory, linker errors may occur. The solution is to set these variables to 'gcc-build/build/gcc'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/errors.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nld: cannot find crtbegin.o: No such file or directory\nld: cannot find -lgcc: No such file or directory\nld: cannot find -lgcc: No such file or directory\nlibgccjit.so: error: error invoking gcc driver\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running ARM Program with QEMU\nDESCRIPTION: This shell command sets environment variables to configure the cargo build and run command for executing the Rust program using QEMU for ARM emulation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabihf.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_RUNNER=\"qemu-arm -L ${TOOLCHAIN}/arm-buildroot-linux-uclibcgnueabihf/sysroot/\" \\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_LINKER=${TOOLCHAIN}/bin/arm-buildroot-linux-uclibcgnueabihf-gcc \\\ncargo +stage2 run --target armv7-unknown-linux-uclibceabihf\n```\n\n----------------------------------------\n\nTITLE: Initializing Crate Metadata Structures in Rust\nDESCRIPTION: This code snippet initializes `CrateData` structures, detailing crate-specific information such as edition, version, and dependencies. Each `CrateData` contains environment variables essential for the Rust build process. Key parameters include `root_file_id`, `edition`, `dependencies`, and `env`. This setup is crucial for compiling and running Rust projects correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model_with_wildcard_overrides.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    0: CrateData {\n        root_file_id: FileId(\n            1,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello-world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"hello_world\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    1: CrateData {\n        root_file_id: FileId(\n            2,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello-world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"hello_world\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    2: CrateData {\n        root_file_id: FileId(\n            3,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"an_example\",\n                ),\n                canonical_name: \"an-example\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"an_example\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    3: CrateData {\n        root_file_id: FileId(\n            4,\n        ),\n        edition: Edition2018,\n        version: Some(\n            \"0.1.0\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"it\",\n                ),\n                canonical_name: \"it\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"it\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n                \"CARGO_PKG_AUTHORS\": \"\",\n                \"CARGO_PKG_DESCRIPTION\": \"\",\n                \"CARGO_PKG_HOMEPAGE\": \"\",\n                \"CARGO_PKG_LICENSE\": \"\",\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"hello-world\",\n                \"CARGO_PKG_README\": \"\",\n                \"CARGO_PKG_REPOSITORY\": \"\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"hello_world\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"libc\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello-world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$hello-world\",\n            ),\n        ),\n    },\n    4: CrateData {\n        root_file_id: FileId(\n            5,\n        ),\n        edition: Edition2015,\n        version: Some(\n            \"0.2.98\",\n        ),\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"libc\",\n                ),\n                canonical_name: \"libc\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"feature=default\",\n                \"feature=std\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: Some(\n            CfgOptions(\n                [\n                    \"feature=align\",\n                    \"feature=const-extern-fn\",\n                    \"feature=default\",\n                    \"feature=extra_traits\",\n                    \"feature=rustc-dep-of-std\",\n                    \"feature=std\",\n                    \"feature=use_std\",\n                    \"true\",\n                ],\n            ),\n        ),\n        env: Env {\n            entries: {\n                \"CARGO\": \"$CARGO$\",\n                \"CARGO_CRATE_NAME\": \"libc\",\n                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n                \"CARGO_PKG_AUTHORS\": \"The Rust Project Developers\",\n                \"CARGO_PKG_DESCRIPTION\": \"Raw FFI bindings to platform libraries like libc.\\n\",\n                \"CARGO_PKG_HOMEPAGE\": \"https://github.com/rust-lang/libc\",\n                \"CARGO_PKG_LICENSE\": \"MIT OR Apache-2.0\",\n            },\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the Clippy Book Locally with mdBook\nDESCRIPTION: Command to run the mdBook serve feature which creates a local web server that automatically updates as changes are made to the book content. The --open flag automatically opens the book in your default web browser.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/book.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmdbook serve book --open\n```\n\n----------------------------------------\n\nTITLE: Fixing Erroneous Deprecated Meta Item in Rust\nDESCRIPTION: This snippet demonstrates an erroneous Rust function attribute that uses an unknown meta item, leading to a compilation error. It explains how to correct the mistake by using valid meta item keys specified for the 'deprecated' attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0541.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated(\n    since=\"1.0.0\",\n    // error: unknown meta item\n    reason=\"Example invalid meta item. Should be 'note'\"\n)]\nfn deprecated_function() {}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Enum Variant in Rust\nDESCRIPTION: This snippet shows how to add a new variant to an existing enum. It demonstrates the process of updating the enum definition to include the missing variant that is being used in the code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_51\n\nLANGUAGE: rust\nCODE:\n```\nenum Countries {\n    Ghana,\n}\n\nfn main() {\n    let country = Countries::Lesotho;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Countries {\n    Ghana,\n    Lesotho,\n}\n\nfn main() {\n    let country = Countries::Lesotho;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Interior Mutability in Constants Using Rust\nDESCRIPTION: This snippet demonstrates an error when attempting to borrow a Rust constant containing interior mutability. It highlights the importance of using statics instead of constants when dealing with types like AtomicUsize to avoid mutability errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0492.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::atomic::AtomicUsize;\n\nconst A: AtomicUsize = AtomicUsize::new(0);\nconst B: &'static AtomicUsize = &A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n```\n\n----------------------------------------\n\nTITLE: Rust 2015 External Crate Import\nDESCRIPTION: Demonstrates how to import from external crates in Rust 2015 using extern crate declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0432.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Information in Cargo.toml\nDESCRIPTION: TOML configuration to enable debug information for the LSP server build. This should be added to the Cargo.toml file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev]\ndebug = 2\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Optimization in Cargo.toml\nDESCRIPTION: TOML configuration to disable optimizations for specific crates to improve rebuild times during development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release.package.rustc_mir_build]\nopt-level = 0\n[profile.release.package.rustc_driver]\nopt-level = 0\n```\n\n----------------------------------------\n\nTITLE: Error Demonstration for Unary Operator on Non-Trait Type in Rust\nDESCRIPTION: This snippet demonstrates an error scenario where a unary operator is incorrectly applied to an enum that does not implement the Not trait. It serves as an example of what happens when an operation is attempted on a type lacking the necessary implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0600.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nenum Question {\n    Yes,\n    No,\n}\n\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\n```\n\n----------------------------------------\n\nTITLE: Testing Debugging Output with LLDB - Rust\nDESCRIPTION: This code snippet demonstrates a simple Rust program used to validate the debugging output when using the LLDB debugger. It sets a breakpoint, runs the program, and checks the expected output from the debugger, confirming the value of 'foo'. It requires specific compile flags to generate debug information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//@ compile-flags: -g\n\n//@ lldb-command: run\n//@ lldb-command: print foo\n//@ lldb-check: $0 = 123\n\nfn main() {\n    let foo = 123;\n    b(); // #break\n}\n\nfn b() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of ffi_pure Attribute on Foreign Function\nDESCRIPTION: Demonstrates the proper usage of the ffi_pure attribute on a foreign function (strlen) declared in an extern block, which is the intended use case for this attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0755.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_pure)]\n\nextern \"C\" {\n    #[unsafe(ffi_pure)] // ok!\n    pub fn strlen(s: *const i8) -> isize;\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Array Pattern Matching with Incompatible Type\nDESCRIPTION: Demonstrates a compile-time error when attempting to match an f32 value with an array pattern, which is not allowed in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0529.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet r: f32 = 1.0;\nmatch r {\n    [a, b] => { // error: expected an array or slice, found `f32`\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Type Inference Context in Rust\nDESCRIPTION: Shows how to create an inference context using the type checking context (tcx) with a builder pattern for configuration\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet infcx = tcx.infer_ctxt().build();\n// Use the inference context `infcx` here.\n```\n\n----------------------------------------\n\nTITLE: Coercing a Function Item to a Function Pointer\nDESCRIPTION: This code shows how a function item can be coerced to a function pointer. The coercion allows the use of the function as a pointer type, showcasing Rust's type system capabilities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0591.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# struct S;\n# fn foo(_: S) {}\nlet x: fn(S) = foo; // OK, coerces\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Plugin Attribute in Rust\nDESCRIPTION: This snippet demonstrates the correct usage of the `#[plugin]` attribute with a single argument representing the plugin name, e.g., `foo`. It requires the feature to be enabled via the `#![feature(plugin)]` directive and proper plugin name specification without additional arguments. No outputs specified, usage limited by the need for proper plugin crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0498.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(plugin)]\n#![plugin(foo)] // ok!\n```\n\n----------------------------------------\n\nTITLE: Analyzing Profiling Data with measureme Summarize Tool\nDESCRIPTION: Shows how to use the summarize tool from the measureme repository to get a summary of compiler time usage from profiling data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ ../measureme/target/release/summarize summarize foo-1234\n```\n\n----------------------------------------\n\nTITLE: Impl Line Breaking Before `for` in Rust\nDESCRIPTION: Demonstrates how to break a non-inherent impl signature when a line break is required. Break immediately before `for`, block indent the concrete type, and put the opening brace on its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl Bar\n    for Foo\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Function Item Implementation Concerning Lifetimes\nDESCRIPTION: This code demonstrates an implementation of a function item type that has a lifetime parameter and illustrates how to avoid unconstrained lifetimes in function traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nstruct FooFnItem;\n\nimpl<'a> Fn<()> for FooFnItem {\n    type Output = &'a String;\n    /* fn call(...) -> ... { ... } */\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Type Description Call Stack\nDESCRIPTION: Illustrative example showing how a naive depth-first traversal algorithm would handle recursive type descriptions, demonstrating the potential infinite loop problem.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/debuginfo/doc.md#2025-04-21_snippet_2\n\nLANGUAGE: ignore\nCODE:\n```\ndescribe(t = List)\n  describe(t = i32)\n  describe(t = Option<Box<List>>)\n    describe(t = Box<List>)\n      describe(t = List) // at the beginning again...\n      ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Cranelift Codegen Backend in Cargo.toml\nDESCRIPTION: Configuration for enabling the Cranelift codegen backend by adding settings directly to the project's Cargo.toml file. This explicitly enables the unstable codegen-backend cargo feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# This line needs to come before anything else in Cargo.toml\ncargo-features = [\"codegen-backend\"]\n\n[profile.dev]\ncodegen-backend = \"cranelift\"\n```\n\n----------------------------------------\n\nTITLE: Structuring Runnable Entity in TypeScript\nDESCRIPTION: The Runnable interface defines the necessary components of a runnable item in a rust-analyzer. This includes its label, location, kind, and arguments required for execution. It's integral for tooling in TypeScript that handles Rust languages, aiding the execution or testing processes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Runnable {\n    label: string;\n    location?: LocationLink;\n    kind: string;\n    args: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in Rust\nDESCRIPTION: This snippet defines a simple function `foo` that takes a `String` as an argument and returns a `u8`. It serves as an introductory example without generics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(a: String) -> u8 {\n    # 1\n    /* snip */\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Field Missing Example in Rust\nDESCRIPTION: Example showing a diagnostic trigger when a struct initialization is missing required fields. This demonstrates the missing-fields diagnostic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/diagnostics_generated.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct A { a: u8, b: u8 }\n\nlet a = A { a: 10 };\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Binding in Rust\nDESCRIPTION: Demonstrates the correct way to bind multiple values in a pattern using unique identifiers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0416.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmatch (1, 2) {\n    (x, y) => {} // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying C Test File for GIMPLE Generation\nDESCRIPTION: This snippet shows the modifications made to a C test file to prepare it for GIMPLE generation. It removes unnecessary content and test-specific code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- /* { dg-do compile { target x86_64-*-* } } */\n...\n- /* We don't want set_options() in harness.h to set -O3 to see that the const\n-    attribute affects the optimizations. */\n- #define TEST_ESCHEWS_SET_OPTIONS\n- static void set_options (gcc_jit_context *ctxt, const char *argv0)\n- {\n-   // Set \"-O3\".\n-   gcc_jit_context_set_int_option(ctxt, GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n- }\n-\n- #define TEST_COMPILING_TO_FILE\n- #define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER\n- #define OUTPUT_FILENAME  \"output-of-test-const-attribute.c.s\"\n- #include \"harness.h\"\n...\n- /* { dg-final { jit-verify-output-file-was-created \"\" } } */\n- /* Check that the loop was optimized away */\n- /* { dg-final { jit-verify-assembler-output-not \"jne\" } } */\n```\n\n----------------------------------------\n\nTITLE: Installing Miri for Cargo\nDESCRIPTION: This command installs Miri in a way that makes it accessible as part of the cargo toolchain, facilitating testing when a crate is involved.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n./miri install\n```\n\n----------------------------------------\n\nTITLE: Triggering Rust for Linux CI Job\nDESCRIPTION: Instructions on how to trigger the Rust for Linux job in the CI system. This command is used in a PR description to run a specific job for testing the integration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ecosystem-test-jobs/rust-for-linux.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n\"> try-job: x86_64-rust-for-linux\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Double Move in Rust Match Pattern\nDESCRIPTION: This code snippet illustrates an erroneous attempt to move an Option<String> into two different bindings simultaneously in a match arm. It violates Rust's ownership rules and would have previously triggered a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0007.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(bindings_after_at)]\n\nlet x = Some(\"s\".to_string());\n\nmatch x {\n    op_string @ Some(s) => {}, // error: use of moved value\n    None => {},\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Not cfg-Predicate in Rust\nDESCRIPTION: This snippet shows the correct usage of the 'not' cfg-predicate, demonstrating how to specify a valid cfg-pattern. This allows for conditional compilation based on the target operating system, hence ensuring the function is compiled on any OS that is not Linux.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0536.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(not(target_os = \"linux\"))] // ok!\npub fn something() {}\n\npub fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Including README Doctests in Test Suite with Conditional Compilation\nDESCRIPTION: Shows how to include a README file's contents as doctests without adding them to the main documentation, using #[cfg(doctest)] and include_str! to conditionally include the tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[doc = include_str!(\"../README.md\")]\n#[cfg(doctest)]\npub struct ReadmeDoctests;\n```\n\n----------------------------------------\n\nTITLE: Multi-line Pattern Formatting - Rust\nDESCRIPTION: Demonstrates formatting for multi-line patterns in match expressions, with and without if clauses.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n    a_very_long_pattern\n    | another_pattern\n    | yet_another_pattern\n    | a_forth_pattern => {\n        ...\n    }\n    a_very_long_pattern\n    | another_pattern\n    | yet_another_pattern\n    | a_forth_pattern\n        if expr =>\n    {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Rust Lint Expectation Example\nDESCRIPTION: Demonstrates the use of expect lint level for unused variables, showing both fulfilled and unfulfilled expectations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/levels.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    #[expect(unused_variables)]\n    let unused = \"Everyone ignores me\";\n\n    #[expect(unused_variables)] // `unused_variables` lint is not emitted\n    let used = \"I'm useful\";    // the expectation is therefore unfulfilled\n    println!(\"The `used` value is equal to: {:?}\", used);\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Dereferencing u32 in Rust\nDESCRIPTION: This code snippet demonstrates an example of a compile-time error E0614 in Rust, where a `u32` variable is directly dereferenced using the `*` operator.  Since `u32` does not implement the `Deref` trait, this operation is invalid. The code will fail to compile.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0614.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0614\nlet y = 0u32;\n*y; // error: type `u32` cannot be dereferenced\n```\n```\n\n----------------------------------------\n\nTITLE: Using Static and Const Variables in Inner Functions\nDESCRIPTION: Alternative solution using static and const variables which can be accessed from inner functions. Includes unsafe code for static mut manipulation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0434.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    static mut X: u32 = 4;\n    const Y: u32 = 5;\n    fn bar() -> u32 {\n        unsafe {\n            X = 3;\n        }\n        Y\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Adding Variants to an Enum with Integer Representation in Rust\nDESCRIPTION: This solution addresses the E0084 error by adding variants to the enum, making the integer representation valid since there are now actual values to represent.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0084.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(i32)]\nenum NightsWatch {\n    JonSnow,\n    Commander,\n}\n```\n\n----------------------------------------\n\nTITLE: Using ADTs as Const Parameters in Rust\nDESCRIPTION: Demonstrates how to use structs and enums as const parameters in generic functions using the `adt_const_params` feature. The example defines a custom enum `Foo` and struct `Bar` that implement `ConstParamTy`, then uses them as const parameters in a function that pattern matches on their values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/adt-const-params.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(adt_const_params)]\n#![allow(incomplete_features)]\n\nuse std::marker::ConstParamTy;\n\n#[derive(ConstParamTy, PartialEq, Eq)]\nenum Foo {\n    A,\n    B,\n    C,\n}\n\n#[derive(ConstParamTy, PartialEq, Eq)]\nstruct Bar {\n    flag: bool,\n}\n\nfn is_foo_a_and_bar_true<const F: Foo, const B: Bar>() -> bool {\n    match (F, B.flag) {\n        (Foo::A, true) => true,\n        _ => false,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Trait on the Custom Enum\nDESCRIPTION: This code shows how to implement the original trait on the custom enum. This allows callers to use trait methods directly on the returned enum without needing to match on its variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0746.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Assembly for TrustZone-M Non-Secure Call\nDESCRIPTION: Assembly output generated for thumbv8m.main-none-eabi target showing the implementation of secure to non-secure transition including register clearing and use of BLXNS instruction.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-c-cmse-nonsecure-call.md#2025-04-21_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\ncall_nonsecure_function:\n        .fnstart\n        .save   {r7, lr}\n        push    {r7, lr}\n        .setfp  r7, sp\n        mov     r7, sp\n        .pad    #16\n        sub     sp, #16\n        str     r0, [sp, #12]\n        ldr     r0, [sp, #12]\n        str     r0, [sp, #8]\n        b       .LBB0_1\n.LBB0_1:\n        ldr     r0, [sp, #8]\n        push.w  {r4, r5, r6, r7, r8, r9, r10, r11}\n        bic     r0, r0, #1\n        mov     r1, r0\n        mov     r2, r0\n        mov     r3, r0\n        mov     r4, r0\n        mov     r5, r0\n        mov     r6, r0\n        mov     r7, r0\n        mov     r8, r0\n        mov     r9, r0\n        mov     r10, r0\n        mov     r11, r0\n        mov     r12, r0\n        msr     apsr_nzcvq, r0\n        blxns   r0\n        pop.w   {r4, r5, r6, r7, r8, r9, r10, r11}\n        str     r0, [sp, #4]\n        b       .LBB0_2\n.LBB0_2:\n        ldr     r0, [sp, #4]\n        add     sp, #16\n        pop     {r7, pc}\n```\n\n----------------------------------------\n\nTITLE: Generating LLVM IR with Autodiff Flag\nDESCRIPTION: Command to generate LLVM IR with autodiff flag, capturing module details and enabling debugging\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustflags=\"-z autodiff=enable,printmodbefore\" cargo +enzyme build --release &> out.ll\n```\n\n----------------------------------------\n\nTITLE: Starting Fuchsia Test Environment\nDESCRIPTION: Shell script to initialize and start the Fuchsia test environment using configuration and SDK paths\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_23\n\nLANGUAGE: sh\nCODE:\n```\n( \\\n    source config-env.sh &&                                                   \\\n    src/ci/docker/scripts/fuchsia-test-runner.py start                        \\\n    --rust-build ${RUST_SRC_PATH}/build                                       \\\n    --sdk ${SDK_PATH}                                                         \\\n    --target {x86_64-unknown-fuchsia|aarch64-unknown-fuchsia}                 \\\n    --verbose                                                                 \\\n)\n```\n\n----------------------------------------\n\nTITLE: Formatting Control Flow with Multi-line Initial Clauses in Rust\nDESCRIPTION: When a control flow expression's initial clause spans multiple lines and ends with closing brackets, place the opening brace of the block on the same line with proper spacing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nif !self.config.file_lines().intersects(\n    &self.codemap.lookup_line_range(\n        stmt.span,\n    ),\n) {  // Opening brace on same line as initial clause.\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MSP430 Interrupt Handlers in Rust\nDESCRIPTION: This snippet demonstrates how to define an interrupt handler for MSP430 architecture using the \"msp430-interrupt\" ABI. It shows how to place the handler at the appropriate memory address (using link_section) and how to implement the interrupt handler function with the correct calling convention.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-msp430-interrupt.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_msp430_interrupt)]\n#![no_std]\n\n// Place the interrupt handler at the appropriate memory address\n// (Alternatively, you can use `#[used]` and remove `pub` and `#[no_mangle]`)\n#[link_section = \"__interrupt_vector_10\"]\n#[no_mangle]\npub static TIM0_VECTOR: extern \"msp430-interrupt\" fn() = tim0;\n\n// The interrupt handler\nextern \"msp430-interrupt\" fn tim0() {\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Float Literal with Missing Exponent Digits in Rust Lexer\nDESCRIPTION: Demonstrates the Rust lexer's behavior when encountering a valid floating-point part (`42.2`) followed by an exponent symbol (`e` or `E`) and an optional sign (`+` or `-`) but lacking the necessary digits after the exponent. This results in a `FLOAT_NUMBER` token with an error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_exponent.txt#_snippet_3\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2e+\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2e-\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2E+\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2E-\" error: Missing digits after the exponent symbol\n```\n\n----------------------------------------\n\nTITLE: SCC Example with Outlives Constraints\nDESCRIPTION: This example illustrates how outlives constraints can create strongly connected components (SCCs).  SCCs are groups of regions that are mutually outlived by each other. The code demonstrates how constraints like `'a: 'b` and `'b: 'a` form an SCC containing `'a` and `'b`, while `'c: 'd` and `'d: 'c` form another SCC.  The constraint `'a: 'c` creates a dependency between these two SCCs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n'a: 'b\n'b: 'a\n\n'a: 'c\n\n'c: 'd\n'd: 'c\n```\n\n----------------------------------------\n\nTITLE: Accessing env-set Value with env! Macro\nDESCRIPTION: Rust code showing how to access an environment variable that was set with the --env-set flag. The example demonstrates how the compile-time value takes precedence over the system environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/env-set.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(env!(\"PATH\"), \"env\");\n```\n\n----------------------------------------\n\nTITLE: Specifying Generic Type Parameter in Rust's collect() Method\nDESCRIPTION: This snippet illustrates how to resolve type inference issues by specifying the generic type parameter directly in the collect() method call.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\n----------------------------------------\n\nTITLE: Generating Profiling Data with rustc\nDESCRIPTION: Demonstrates running the rustc compiler with the `-Zself-profile` flag to enable internal profiler and generate profiling data files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --crate-name foo -Zself-profile\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Named Subpatterns in Rust\nDESCRIPTION: This code defines named subpatterns using the `pattern!` macro to match specific elements in a syntax tree. It allows users to retrieve matched nodes based on the pattern outlined. Key elements involve the use of the macro `pattern!` for defining patterns that include named parts, which can be accessed during syntax checking. Dependencies include Rust's syntax parsing libraries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    // matches character literals\n    my_pattern: Expr =\n        Lit(Char(_#val_inner)#val)#val_outer\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n...\nfn check_expr(expr: &syntax::ast::Expr) {\n    if let Some(result) = my_pattern(expr) {\n        result.val_inner  // type: &char\n        result.val        // type: &syntax::ast::Lit\n        result.val_outer  // type: &syntax::ast::Expr\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    // matches arrays of character literals\n    my_pattern_seq: Expr =\n        Array( Lit(_)*#foo )\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n...\nif let Some(result) = my_pattern_seq(expr) {\n    result.foo        // type: Vec<&syntax::ast::Expr>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    // matches if expression is a boolean or integer literal\n    my_pattern_alt: Expr =\n        Lit( Bool(_#bar) | Int(_) )\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n...\nif let Some(result) = my_pattern_alt(expr) {\n    result.bar        // type: Option<&bool>\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n...\nif let Some(result) = my_pattern_mult(expr) {\n    result.baz        // type: &syntax::ast::Lit\n}\n```\n\n----------------------------------------\n\nTITLE: Solution: Removing Over-Aligned Zero-Sized Field in Rust\nDESCRIPTION: This code snippet demonstrates a solution to the error by removing the over-aligned zero-sized field from the transparent struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0691.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\nstruct Wrapper(f32);\n```\n\n----------------------------------------\n\nTITLE: Correct Use of Link Annotations in Rust\nDESCRIPTION: This snippet illustrates the correct usage of the link attribute in Rust by providing a valid library name, allowing the Rust compiler to link it properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0454.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[link(name = \"some_lib\")] extern \"C\" {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Item-Level Import Granularity in Rust\nDESCRIPTION: Demonstrates the imports_granularity setting set to Item, which flattens all imports so that each item has its own use statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_53\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::a;\nuse foo::b;\nuse foo::b::f;\nuse foo::b::g;\nuse foo::c;\nuse foo::d::e;\nuse qux::h;\nuse qux::i;\n```\n\n----------------------------------------\n\nTITLE: Enabling Per-Target Ignores in Rustdoc (Bash)\nDESCRIPTION: This command demonstrates how to use the --enable-per-target-ignores flag in Rustdoc to allow ignore-foo style filters for doctests. It's useful for selectively running doctests based on target triples.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --enable-per-target-ignores\n```\n\n----------------------------------------\n\nTITLE: Installing libgccjit-12-dev\nDESCRIPTION: This command installs the `libgccjit-12-dev` package using `apt`. This package is required for `rustc_codegen_gcc`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n\napt install libgccjit-12-dev\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Call Ambiguity in Rust\nDESCRIPTION: This code snippet shows an erroneous example where two traits define the same method name, causing a compiler error when trying to call the method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0034.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\n----------------------------------------\n\nTITLE: Running Rust Compiler UI Tests\nDESCRIPTION: Execute UI tests for the Rust compiler using the 'x' test command, focusing on specific test directories\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n./x test tests/ui\n```\n\n----------------------------------------\n\nTITLE: Implementing Opaque Type with Concrete Type in Rust\nDESCRIPTION: This example shows how to implement an opaque type `Foo` with a concrete type `Struct`. It defines the `Struct`, implements the `Bar` trait for it, and creates a function `foo()` that returns the opaque type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-type-alias-impl-trait.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Struct;\nimpl Bar for Struct { /* stuff */ }\nfn foo() -> Foo {\n    Struct\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Malformed Not cfg-Predicate in Rust\nDESCRIPTION: This code snippet demonstrates a malformed 'not' cfg-predicate. The predicate is incorrect as it doesn't specify a cfg-pattern, which leads to a compilation error. It indicates the expected format for using 'not' in Rust conditional compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0536.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(not())] // error: expected 1 cfg-pattern\npub fn something() {}\n\npub fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Generic Argument Order in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous declaration of generic arguments where the type argument is provided before the lifetime argument, which does not match the order in the struct definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0747.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<'a, T>(&'a T);\n\ntype X = S<(), 'static>; // error: the type argument is provided before the\n                         // lifetime argument\n```\n\n----------------------------------------\n\nTITLE: Macro Statement Formatting\nDESCRIPTION: Illustrates the recommended formatting for macro invocations in statement position\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\na_macro!(...);\n```\n\n----------------------------------------\n\nTITLE: Compiled Caller Location Example in Rust\nDESCRIPTION: Demonstrates how the compiler transforms tracked caller code into actual implementation with location parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/implicit-caller-location.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(panic_internals)]\nuse std::panic::Location;\n\nfn print_caller(caller: &Location) {\n    println!(\"called from {}\", caller);\n}\n\nfn main() {\n    print_caller(&Location::internal_constructor(file!(), line!(), column!()));\n}\n```\n\n----------------------------------------\n\nTITLE: Method Shadowing Error Example with Pin in Rust\nDESCRIPTION: Demonstrates a method shadowing error that occurs when a method exists both on a smart pointer and its referent type. This example shows a compile error due to multiple applicable items in scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::pin::pin;\n\nstruct A;\n\nimpl A {\n    fn get_ref(self: Pin<&A>) {}\n}\n\nfn main() {\n    let pinned_a: Pin<&A> = pin!(A).as_ref();\n    let pinned_a: Pin<&A> = pinned_a.as_ref();\n    pinned_a.get_ref(); // error[E0034]: multiple applicable items in scope\n}\n```\n\n----------------------------------------\n\nTITLE: Example ELF Section Naming in Rust\nDESCRIPTION: Demonstrates how a function named 'func' would generate different section names in object files depending on whether the no-unique-section-names flag is used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/no-unique-section-names.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`.text.func`\n`.gcc_except_table.func`\n```\n\n----------------------------------------\n\nTITLE: Specifying Benchmark Flags for Enzyme Autodiff in Text\nDESCRIPTION: This snippet lists the benchmark flags supported by the Enzyme `autodiff` feature for performance experiments. These flags allow disabling post-optimization of LLVM-IR, enabling runtime activity features, and maximizing inlining.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/flags.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nNoPostopt // We won\\'t optimize the LLVM-IR Module after AD\nRuntimeActivity // Enables the runtime activity feature from Enzyme\nInline // Instructs Enzyme to maximize inlining as far as possible, beyond LLVM\\'s default\n```\n\n----------------------------------------\n\nTITLE: Using Static for Thread-Safe Mutability in Rust\nDESCRIPTION: This example shows the correct approach to avoid borrow errors by using statics instead of constants. It ensures that memory locations are immutable when shared but can be altered via known controlled methods when necessary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0492.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::atomic::AtomicUsize;\n\nstatic A: AtomicUsize = AtomicUsize::new(0);\nstatic B: &'static AtomicUsize = &A; // ok!\n```\n\n----------------------------------------\n\nTITLE: RPITIT Basic Example in Rust Trait\nDESCRIPTION: Example showing how a trait method with an impl Trait return type captures lifetimes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn method<'early: 'early, 'late, T>() -> impl Sized + Captures<'early, 'late>;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Rust Compilation Commands for WebAssembly Targets\nDESCRIPTION: Demonstrates the difference between compiling for wasm32-unknown-unknown and wasm32v1-none targets. The wasm32v1-none target requires fewer configurations and works with stable Rust toolchains, whereas wasm32-unknown-unknown needs nightly builds and custom RUSTFLAGS to disable post-MVP proposals.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32v1-none.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --target wasm32-unknown-unknown -Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --target wasm32v1-none\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ export RUSTFLAGS=\"-Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals\"\n$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Implementing Cross-Crate Opt-Out Traits on Non-Struct Types in Rust\nDESCRIPTION: This example demonstrates an invalid implementation of the Send trait for a reference type. In Rust, cross-crate traits with default implementations (like Send and Sync) can only be implemented for struct or enum types that are local to the current crate, not for reference types or other non-struct/enum types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0321.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(auto_traits)]\n\nstruct Foo;\n\nimpl !Sync for Foo {}\n\nunsafe impl Send for &'static Foo {}\n// error: cross-crate traits with a default impl, like `core::marker::Send`,\n//        can only be implemented for a struct/enum type, not\n//        `&'static Foo`\n```\n\n----------------------------------------\n\nTITLE: Using Unsupported repr Attribute in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous usage of an unsupported repr attribute 'D'. The repr attribute is used to specify how structs and enums are laid out in memory. Using an unrecognized representation hint will result in a compile error. Supported representations must be used to ensure correct memory layout.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0552.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(D)] // error: unrecognized representation hint\nstruct MyStruct {\n    my_field: usize\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Imports in Rust\nDESCRIPTION: Demonstrates different strategies for grouping consecutive imports using the group_imports option.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_62\n\nLANGUAGE: rust\nCODE:\n```\nuse super::update::convert_publish_payload;\nuse chrono::Utc;\n\nuse alloc::alloc::Layout;\nuse juniper::{FieldError, FieldResult};\nuse uuid::Uuid;\n\nuse std::sync::Arc;\n\nuse broker::database::PooledConnection;\n\nuse super::schema::{Context, Payload};\nuse crate::models::Event;\nuse core::f32;\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse alloc::alloc::Layout;\nuse core::f32;\nuse std::sync::Arc;\n\nuse broker::database::PooledConnection;\nuse chrono::Utc;\nuse juniper::{FieldError, FieldResult};\nuse uuid::Uuid;\n\nuse super::schema::{Context, Payload};\nuse super::update::convert_publish_payload;\nuse crate::models::Event;\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse super::schema::{Context, Payload};\nuse super::update::convert_publish_payload;\nuse crate::models::Event;\nuse alloc::alloc::Layout;\nuse broker::database::PooledConnection;\nuse chrono::Utc;\nuse core::f32;\nuse juniper::{FieldError, FieldResult};\nuse std::sync::Arc;\nuse uuid::Uuid;\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust code for `wasm32-unknown-unknown`\nDESCRIPTION: This command compiles a Rust source file (`foo.rs`) to WebAssembly using the `wasm32-unknown-unknown` target. It then uses `file` to verify the output is a WebAssembly binary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc foo.rs --target wasm32-unknown-unknown\n$ file foo.wasm\n```\n\n----------------------------------------\n\nTITLE: Handling Raw String Literal Termination Error in Rust\nDESCRIPTION: This snippet shows an incorrect raw string literal in Rust where the required trailing combination of quotation marks and hash symbols is missing, causing a compilation error. It demonstrates the importance of closing raw strings correctly when using multiple `#` symbols. The snippet includes the start of a raw string literal and highlights the missing terminating characters, which are necessary to avoid syntax errors when embedding special characters such as newlines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_with_slash_n.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSTRING \"r##\\\"\\\\n\" error: Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Mutable Borrow in Pattern Guard - Rust\nDESCRIPTION: Example showing why mutable borrows are not allowed in pattern guards. The code attempts to use option.take() in a guard clause, which would modify the matched value and break the match exhaustiveness guarantee.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0301.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch Some(()) {\n    None => { },\n    option if option.take().is_none() => {\n        /* impossible, option is `Some` */\n    },\n    Some(_) => { } // When the previous match failed, the option became `None`.\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving E0228 Error by Explicitly Specifying Trait Object Lifetime in Rust\nDESCRIPTION: This code snippet shows how to resolve the E0228 error by explicitly specifying the lifetime for the trait object in the type alias. It demonstrates the correct way to use trait objects with multiple lifetime bounds in generic structs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0228.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { }\n\nstruct TwoBounds<'a, 'b, T: Sized + 'a + 'b> {\n    x: &'a i32,\n    y: &'b i32,\n    z: T,\n}\n\ntype Foo<'a, 'b> = TwoBounds<'a, 'b, dyn Trait + 'b>;\n```\n\n----------------------------------------\n\nTITLE: Correct Syntax for Public Enum in Rust\nDESCRIPTION: This code snippet shows the correct way to define a public enum in Rust without unnecessary `pub` keywords on its variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0448.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub enum Foo {\n    Bar, // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Casting to Unsized Type Reference in Rust\nDESCRIPTION: This snippet demonstrates the correct way to cast to an unsized type in Rust by using a reference. Unlike the error example, this approach uses a reference to ensure that the size of the type can be managed properly at runtime. This allows the Rust compiler to handle the size-related constraints correctly, demonstrating a seamless transition from an array to a slice reference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0620.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = &[1_usize, 2] as &[usize]; // ok!\n```\n\n----------------------------------------\n\nTITLE: Using Partial Type Annotation in Rust\nDESCRIPTION: This example shows how to use a partial type annotation, allowing the compiler to infer the rest of the type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\n----------------------------------------\n\nTITLE: Using std::env::args() Function in Rust\nDESCRIPTION: This snippet illustrates the use of the std::env::args() function to retrieve command-line arguments in Rust. It explains the purpose of the function and provides an example of iterating over the arguments. It highlights that the first element, typically the executable path, may vary, and potential panics are noted if arguments are not valid Unicode. Recommended to use args_os() if Unicode issues are a concern.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/how-to-write-documentation.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\n// Prints each argument on a separate line\nfor argument in env::args() {\n    println!(\"{argument}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Code for iOS Target\nDESCRIPTION: Example command showing how to compile Rust code for a specific iOS target using rustc with the --target flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-ios.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --target aarch64-apple-ios your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Context and Initiating Type Checking in Rust Compiler\nDESCRIPTION: Example showing how the compiler driver creates a query context (tcx) and initiates the type checking process by invoking the type_check_crate query from outside the query system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/query-evaluation-model-in-detail.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn compile_crate() {\n    let cli_options = ...;\n    let hir_map = ...;\n\n    // Create the query context `tcx`\n    let tcx = TyCtxt::new(cli_options, hir_map);\n\n    // Do type checking by invoking the type check query\n    tcx.type_check_crate();\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking a Clippy Pull Request using Git and Lintcheck (Bash)\nDESCRIPTION: This Bash script outlines the workflow for benchmarking a specific Clippy pull request (PR) against the master branch. It fetches the PR branch, runs the Lintcheck benchmark using `cargo lintcheck --perf`, identifies the last common commit with master, checks out that commit, runs the benchmark again, and finally uses `perf diff` to compare the two performance data files (`perf.data` and `perf.data.0`) generated in the `target/lintcheck/sources/CRATE/` directory. Requires Git, `cargo lintcheck`, and the Linux `perf` tool.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/benchmarking.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngit fetch upstream pull/<PR_NUMBER>/head:<BRANCH_NAME>\ngit switch BRANCHNAME\n\n# Bench\ncargo lintcheck --perf\n\n# Get last common commit, checkout that\nLAST_COMMIT=$(git log BRANCHNAME..master --oneline | tail -1 | cut -c 1-11)\ngit switch -c temporary $LAST_COMMIT\n\n# We're now on master\n\n# Bench\ncargo lintcheck --perf\nperf diff ./target/lintcheck/sources/CRATE/perf.data ./target/lintcheck/sources/CRATE/perf.data.0\n```\n\n----------------------------------------\n\nTITLE: Valid DispatchFromDyn Implementation for Pointer Type\nDESCRIPTION: Demonstrates correct implementation of DispatchFromDyn for a custom pointer type struct containing only a single pointer field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0378.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(dispatch_from_dyn, unsize)]\nuse std::{\n    marker::Unsize,\n    ops::DispatchFromDyn,\n};\n\nstruct Ptr<T: ?Sized>(*const T);\n\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\nwhere\n    T: Unsize<U>,\n{}\n```\n\n----------------------------------------\n\nTITLE: Defining Keyword Patterns in a Rust Lexer\nDESCRIPTION: The snippet defines a series of Rust language keywords and maps each to a corresponding token representation. This is likely used for lexical analysis in a Rust compiler or interpreter. The snippet handles common Rust keywords like 'async', 'fn', 'use', 'struct', and others, which are essential for language parsing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/keywords.txt#2025-04-21_snippet_0\n\nLANGUAGE: Regex\nCODE:\n```\nASYNC_KW \"async\"\nWHITESPACE \" \"\nFN_KW \"fn\"\nWHITESPACE \" \"\nUSE_KW \"use\"\nWHITESPACE \" \"\nSTRUCT_KW \"struct\"\nWHITESPACE \" \"\nTRAIT_KW \"trait\"\nWHITESPACE \" \"\nENUM_KW \"enum\"\nWHITESPACE \" \"\nIMPL_KW \"impl\"\nWHITESPACE \" \"\nTRUE_KW \"true\"\nWHITESPACE \" \"\nFALSE_KW \"false\"\nWHITESPACE \" \"\nAS_KW \"as\"\nWHITESPACE \" \"\nEXTERN_KW \"extern\"\nWHITESPACE \" \"\nCRATE_KW \"crate\"\nWHITESPACE \"\\n\"\nMOD_KW \"mod\"\nWHITESPACE \" \"\nPUB_KW \"pub\"\nWHITESPACE \" \"\nSELF_KW \"self\"\nWHITESPACE \" \"\nSUPER_KW \"super\"\nWHITESPACE \" \"\nIN_KW \"in\"\nWHITESPACE \" \"\nWHERE_KW \"where\"\nWHITESPACE \" \"\nFOR_KW \"for\"\nWHITESPACE \" \"\nLOOP_KW \"loop\"\nWHITESPACE \" \"\nWHILE_KW \"while\"\nWHITESPACE \" \"\nIF_KW \"if\"\nWHITESPACE \" \"\nMATCH_KW \"match\"\nWHITESPACE \" \"\nCONST_KW \"const\"\nWHITESPACE \"\\n\"\nSTATIC_KW \"static\"\nWHITESPACE \" \"\nMUT_KW \"mut\"\nWHITESPACE \" \"\nTYPE_KW \"type\"\nWHITESPACE \" \"\nREF_KW \"ref\"\nWHITESPACE \" \"\nLET_KW \"let\"\nWHITESPACE \" \"\nELSE_KW \"else\"\nWHITESPACE \" \"\nMOVE_KW \"move\"\nWHITESPACE \" \"\nRETURN_KW \"return\"\nWHITESPACE \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: VSCode Keybinding for On Enter Feature\nDESCRIPTION: Configure keyboard shortcut for rust-analyzer's enhanced Enter key behavior in VSCode, supporting both standard and Vim plugin modes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features_generated.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"key\": \"Enter\",\n  \"command\": \"rust-analyzer.onEnter\",\n  \"when\": \"editorTextFocus && !suggestWidgetVisible && editorLangId == rust\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"key\": \"Enter\",\n  \"command\": \"rust-analyzer.onEnter\",\n  \"when\": \"editorTextFocus && !suggestWidgetVisible && editorLangId == rust && vim.mode == 'Insert'\"\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Rules Formatting with Different Options\nDESCRIPTION: Illustrates macro rules formatting variations using rustfmt configuration settings\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! foo {\n    ($a: ident : $b: ty) => {\n        $a(42): $b;\n    };\n    ($a: ident $b: ident $c: ident) => {\n        $a = $b + $c;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Rules Definition Formatting in Rust\nDESCRIPTION: Demonstrates the use of `{}` for the full definition of macros in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! foo {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for Hexagon Target\nDESCRIPTION: This TOML snippet configures `.cargo/config` to build Rust programs for the Hexagon Linux target. It sets the linker and runner for executing compiled binaries using QEMU.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-linux-musl.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"hexagon-unknown-linux-musl\"\n\n[target.hexagon-unknown-linux-musl]\nlinker = \"hexagon-unknown-linux-musl-clang\"\nar = \"hexagon-unknown-linux-musl-ar\"\nrunner = \"qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Implementation Symbol Mangling in Rust\nDESCRIPTION: Shows how a trait implementation for a struct is mangled, including the trait-impl indicator, impl path, Self type, and trait path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Example;\ntrait Trait {\n    fn foo();\n}\nimpl Trait for Example {\n    fn foo() {}\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNvXCs15kBYyAo9fc_7mycrateNtB2_7ExampleNtB2_5Trait3foo\n    │└─────────┬──────────┘└─────┬─────┘└────┬────┘\n    │          │                 │           │\n    │          │                 │           └── path to the trait \"Trait\"\n    │          │                 └────────────── Self type \"Example\"\n    │          └──────────────────────────────── path to the impl's parent \"mycrate\"\n    └─────────────────────────────────────────── trait-impl\n```\n\n----------------------------------------\n\nTITLE: Simple Rust Function Example\nDESCRIPTION: A basic Rust function that adds two 32-bit integers, marked with no_mangle for direct assembly output viewing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/verbose-asm.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub fn foo(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Emscripten Target to Rust\nDESCRIPTION: This shell command utilizes 'rustup' to add the 'wasm32-unknown-emscripten' target, allowing Rust to compile programs to this WebAssembly target. The 'rustup' tool must be installed prior to execution. It outputs a confirmation of the successful addition of the target, allowing further compilation to WebAssembly using this target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nrustup target add wasm32-unknown-emscripten\n```\n\n----------------------------------------\n\nTITLE: Usage of Crate Root Lint Levels Command\nDESCRIPTION: Demonstrates how to use the rustc command with the crate-root-lint-levels print option alongside the unstable options flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/print-crate-root-lint-levels.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustc --print=crate-root-lint-levels -Zunstable-options lib.rs\n```\n\n----------------------------------------\n\nTITLE: Updating Test Data using Environment Variables in Bash\nDESCRIPTION: This snippet shows how to update test data by setting the `UPDATE_EXPECT` environment variable to 1 and running the `cargo qt` command. This is useful for incorporating changes made to the parser or grammar into the test suite.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/architecture.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nenv UPDATE_EXPECT=1 cargo qt\n```\n\n----------------------------------------\n\nTITLE: Identifying Duplicate Deprecated Attributes in Rust\nDESCRIPTION: This snippet shows an erroneous use of multiple `deprecated` attributes on a single function, which results in a compiler error. The purpose is to demonstrate how not to use deprecated attributes in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0550.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated(note = \\\"because why not?\\\")]\n#[deprecated(note = \\\"right?\\\")] // error!\nfn the_banished() {}\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee without Transparent Representation\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct without repr(transparent).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\nstruct NotTransparent<'a, #[pointee] T: ?Sized> {\n    ptr: &'a T,\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in Arrays with Rust Macros\nDESCRIPTION: Demonstrates a conceptual approach for matching array patterns using Rust macros, discussing possible matches and handling multiple matches within array expressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    my_pattern: Expr =\n        Array( _* Lit(_)+#literals)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Rust Programs with Hexagon Toolchain\nDESCRIPTION: This snippet provides the command to add the Hexagon toolchain to the PATH and execute Rust programs using Cargo run. It mentions the requirement to have the QEMU in the system's PATH.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-linux-musl.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nexport PATH=/path/to/my/inst/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/:$PATH\ncargo run -Zbuild-std -Zbuild-std-features=llvm-libunwind\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Naming Conflict Error in Rust\nDESCRIPTION: Shows an erroneous code example where two items with the same name 'baz' are imported, resulting in a compilation error E0252.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0252.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::baz;\nuse bar::baz; // error, do `use bar::baz as quux` instead\n\nfn main() {}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\n----------------------------------------\n\nTITLE: Running rustc_codegen_gcc tests\nDESCRIPTION: This command runs the `rustc_codegen_gcc` tests using the `./x test` command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n\n./x test compiler/rustc_codegen_gcc/\n\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for Building Rust Programs - TOML\nDESCRIPTION: This snippet demonstrates the necessary .cargo/config settings for projects aimed at the armeb-unknown-linux-gnueabi target, defining the target architecture and the linker to be used for compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armeb-unknown-linux-gnueabi.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"armeb-unknown-linux-gnueabi\"\n\ntarget.armeb-unknown-linux-gnueabi]\nlinker = \"armeb-unknown-linux-gnueabi-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Installing and Building for x86_64-unknown-none Target\nDESCRIPTION: Commands for installing the x86_64-unknown-none target via rustup and using it with cargo build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/x86_64-unknown-none.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# install cross-compile toolchain\nrustup target add x86_64-unknown-none\n# target flag may be used with any cargo or rustc command\ncargo build --target x86_64-unknown-none\n```\n\n----------------------------------------\n\nTITLE: Package Requirements with Hashes\nDESCRIPTION: Specifies exact versions and SHA-256 hashes for required Python packages clang-format and ruff. Generated automatically by pip-compile from a source requirements file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/tidy/config/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nclang-format==18.1.7 \\\n    --hash=sha256:035204410f65d03f98cb81c9c39d6d193f9987917cc88de9d0dbd01f2aa9c302 \\\n    --hash=sha256:05c482a854287a5d21f7567186c0bd4b8dbd4a871751e655a45849185f30b931 \\\n    --hash=sha256:0b352ec51b291fe04c25a0f0ed15ba1a55b9c9c8eaa7fdf14de3d3585aef4f72 \\\n    --hash=sha256:217526c8189c18fd175e19bb3e4da2d1bdf14a2bf79d97108c9b6a98d9938351 \\\n    --hash=sha256:42d0b580ab7a45348155944adebe0bef53d1de9357b925830a59bbc351a25560 \\\n    --hash=sha256:57090c40a8f0a898e0db8be150a19be2551302d5f5620d2a01de07e7c9220a53 \\\n    --hash=sha256:607772cf474c1ebe0de44f44c1324e57a2d5b45a1d96d4aff166645532d99b43 \\\n    --hash=sha256:a49c44d7cc00431be8285aa120a7a21fa0475786c03c53b04a26882c4e626a43 \\\n    --hash=sha256:a62fca204293893badde0ab004df8b6df1d13eac4d452051554d9684d0a8254e \\\n    --hash=sha256:a914592a51f77c3563563c7a8970f19bc1ed59174ab992f095a78f4e142382ac \\\n    --hash=sha256:b3a0a09428cdd656ed87074543222a80660bc506407ed21b8e4bcb3d6d3a5a3c \\\n    --hash=sha256:c151d42e6ac7c3cc03d7fec61bed3211ce8f75528e1efd8fc64bdb33840987b2 \\\n    --hash=sha256:d6a2f051124d6ae506ba2a68accfe4ea4c8cb90d13b422c3131bb124413bac32 \\\n    --hash=sha256:f4f77ac0f4f9a659213fedda0f2d216886c410132e6e7dd4b13f92b34e925554 \\\n    --hash=sha256:f935d34152a2e11e55120eb9182862f432bc9789ab819f680c9f6db4edebf9e3\n    # via -r src/tools/tidy/config/requirements.in\nruff==0.4.9 \\\n    --hash=sha256:06b60f91bfa5514bb689b500a25ba48e897d18fea14dce14b48a0c40d1635893 \\\n    --hash=sha256:0e8e7b95673f22e0efd3571fb5b0cf71a5eaaa3cc8a776584f3b2cc878e46bff \\\n    --hash=sha256:2d45ddc6d82e1190ea737341326ecbc9a61447ba331b0a8962869fcada758505 \\\n    --hash=sha256:4555056049d46d8a381f746680db1c46e67ac3b00d714606304077682832998e \\\n    --hash=sha256:5d5460f789ccf4efd43f265a58538a2c24dbce15dbf560676e430375f20a8198 \\\n    --hash=sha256:673bddb893f21ab47a8334c8e0ea7fd6598ecc8e698da75bcd12a7b9d0a3206e \\\n    --hash=sha256:732dd550bfa5d85af8c3c6cbc47ba5b67c6aed8a89e2f011b908fc88f87649db \\\n    --hash=sha256:784d3ec9bd6493c3b720a0b76f741e6c2d7d44f6b2be87f5eef1ae8cc1d54c84 \\\n    --hash=sha256:78de3fdb95c4af084087628132336772b1c5044f6e710739d440fc0bccf4d321 \\\n    --hash=sha256:8064590fd1a50dcf4909c268b0e7c2498253273309ad3d97e4a752bb9df4f521 \\\n    --hash=sha256:88bffe9c6a454bf8529f9ab9091c99490578a593cc9f9822b7fc065ee0712a06 \\\n    --hash=sha256:8c1aff58c31948cc66d0b22951aa19edb5af0a3af40c936340cd32a8b1ab7438 \\\n    --hash=sha256:98ec2775fd2d856dc405635e5ee4ff177920f2141b8e2d9eb5bd6efd50e80317 \\\n    --hash=sha256:b262ed08d036ebe162123170b35703aaf9daffecb698cd367a8d585157732991 \\\n    --hash=sha256:e0a22c4157e53d006530c902107c7f550b9233e9706313ab57b892d7197d8e52 \\\n    --hash=sha256:e91175fbe48f8a2174c9aad70438fe9cb0a5732c4159b2a10a3565fea2d94cde \\\n    --hash=sha256:f1cb0828ac9533ba0135d148d214e284711ede33640465e706772645483427e3\n    # via -r src/tools/tidy/config/requirements.in\n```\n\n----------------------------------------\n\nTITLE: Testing Rust Binary with QEMU for Armv7\nDESCRIPTION: This command provides a script to test cross-compiled Rust binaries using QEMU. It sets environment variables and specifies the runner for QEMU. Requires QEMU and the Tomatoware toolchain to be installed on the host system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabi.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nCC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\nCXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \\\nAR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \\\nCFLAGS_armv7_unknown_linux_uclibceabi=\\\"-march=armv7-a -mtune=cortex-a9\\\" \\\nCXXFLAGS_armv7_unknown_linux_uclibceabi=\\\"-march=armv7-a -mtune=cortex-a9\\\" \\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUNNER=\\\"qemu-arm-static -L /opt/tomatoware/arm-soft-mmc/arm-tomatoware-linux-uclibcgnueabi/sysroot/\\\" \\\ncargo +stage2 \\\nrun \\\n--target armv7-unknown-linux-uclibceabi \\\n--release\n```\n\n----------------------------------------\n\nTITLE: Creating Structs with Concatenated Names Using macro_metavar_expr_concat in Rust\nDESCRIPTION: This example demonstrates how to use the concat metavariable expression to create multiple structs with prefixed names based on a provided identifier. The macro generates FirstThing, SecondThing, and ThirdThing structs from a single macro invocation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(macro_metavar_expr_concat)]\n\nmacro_rules! create_some_structs {\n    ($name:ident) => {\n        pub struct ${ concat(First, $name) };\n        pub struct ${ concat(Second, $name) };\n        pub struct ${ concat(Third, $name) };\n    }\n}\n\ncreate_some_structs!(Thing);\n```\n\n----------------------------------------\n\nTITLE: Invalid Variable Capture in Inner Function\nDESCRIPTION: Example showing erroneous code where an inner function attempts to capture a variable from its containing scope, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0434.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    let y = 5;\n    fn bar() -> u32 {\n        y // error: can't capture dynamic environment in a fn item; use the\n          //        || { ... } closure form instead.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lowering Invariants and Requirements\nDESCRIPTION: Critical rules and constraints for maintaining AST to HIR conversion integrity, ensuring proper node ID handling and scope management\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ast-lowering.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n1. A `HirId` must be used if created\n2. Lowering a `HirId` must be done in the scope of the *owning* item\n3. A `NodeId` placed into a HIR structure must be lowered\n4. New nodes must have new ids created via `next_id` method\n```\n\n----------------------------------------\n\nTITLE: Implementing C-Variadic Function in Rust\nDESCRIPTION: Demonstrates how to create a C-style variadic function that sums up a variable number of usize arguments. The function takes a count parameter followed by the variadic arguments, accessed using the args.arg() method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/c-variadic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(c_variadic)]\n\npub unsafe extern \"C\" fn add(n: usize, mut args: ...) -> usize {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum += args.arg::<usize>();\n    }\n    sum\n}\n```\n\n----------------------------------------\n\nTITLE: Basic AST Pattern Matching in Rust\nDESCRIPTION: Example showing current complex pattern matching approach for checking boolean literals in AST nodes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nif let ast::ExprKind::Lit(lit) = &expr.node {\n    if let ast::LitKind::Bool(_) = &lit.node {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting bool::then to If Expression in Rust\nDESCRIPTION: This assist converts a `bool::then` method call to an equivalent if expression. It replaces the method call with a more explicit conditional structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    (0 == 0).then(|| val)\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if 0 == 0 {\n        Some(val)\n    } else {\n        None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Where Clause Usage with Concrete Type in Rust\nDESCRIPTION: This example demonstrates incorrect usage of a where clause with a concrete type Wrapper<u32>. Since we know that Wrapper<u32> implements Clone (due to the derive attribute), specifying it in a where clause is redundant and incorrect.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0193.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n#[derive(Copy,Clone)]\nstruct Wrapper<T> {\n    Wrapped: T\n}\n\nimpl Foo for Wrapper<u32> where Wrapper<u32>: Clone {\n    fn bar(&self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Rust Move Size Limit Compiler Flag\nDESCRIPTION: Demonstrates the syntax for the experimental compiler flag that warns when moving objects larger than N bytes. The flag enables the 'large_assignments' lint which only triggers for functions participating in code generation, making it ineffective for metadata-only compilation like 'cargo check'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/move-size-limit.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Zmove-size-limit=N\n```\n\n----------------------------------------\n\nTITLE: Using Field Initialization Shorthand in Rust\nDESCRIPTION: Demonstrates the 'use_field_init_shorthand' option. When false (default), full field initialization is used. When true, shorthand initialization is used where possible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_74\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: u32,\n    y: u32,\n    z: u32,\n}\n\nfn main() {\n    let x = 1;\n    let y = 2;\n    let z = 3;\n    let a = Foo { x, y, z };\n    let b = Foo { x: x, y: y, z: z };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: u32,\n    y: u32,\n    z: u32,\n}\n\nfn main() {\n    let x = 1;\n    let y = 2;\n    let z = 3;\n    let a = Foo { x, y, z };\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Definition with Associated Type in Rust\nDESCRIPTION: This code defines a trait named `Identity` with an associated type `Out` and a method `foo`.  The associated type allows the trait to define a type that is related to the implementing type. The ellipsis represents the missing implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n\"trait Identity { type Out; fn foo(&self); }\"\n```\n\n----------------------------------------\n\nTITLE: Collapsing Macro Debug Info in Rust\nDESCRIPTION: Controls whether code locations from a macro definition are collapsed into a single location at the macro call site for debuginfo.  Valid values are `y`, `yes`, `on`, `true`, `n`, `no`, `off`, `false`, and `external`.  The option overrides default behavior and `#[collapse_debuginfo]` attributes. The `external` value only collapses if the macro comes from a different crate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Running Local CI Job with citool\nDESCRIPTION: Command to execute a specific CI job locally using the citool Rust crate\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/docker/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --manifest-path src/ci/citool/Cargo.toml run-local <job-name>\n```\n\n----------------------------------------\n\nTITLE: Rustdoc Command Invocation with Cargo\nDESCRIPTION: This snippet shows the underlying rustdoc command invoked by Cargo with detailed parameters for documentation generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc --crate-name docs src/lib.rs -o <path>/docs/target/doc -L dependency=<path>/docs/target/debug/deps\n```\n\n----------------------------------------\n\nTITLE: Invalid #[repr(packed)] on enum in Rust\nDESCRIPTION: This code snippet shows an invalid usage of the `#[repr(packed)]` attribute on an enum. The `#[repr(packed)]` attribute is designed to remove padding in structs and is not applicable to enums. Attempting to use it on an enum will lead to a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0517.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\n#[repr(packed)]\nenum Foo {Bar, Baz}\n\n```\n\n----------------------------------------\n\nTITLE: Checking Expressions with Pattern Lints\nDESCRIPTION: This snippet demonstrates checking an expression with a pattern lint in Rust using procedural blocks such as if_chain!. It leverages Rust's AST structures for pattern matching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n    if let Some(result) = pat_if_without_else(expr) {\n        if !block_starts_with_comment(cx, result.then) {\n            ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GNU Make Shell Command with Disabled Jobserver\nDESCRIPTION: Shows how to disable jobserver for rustc calls within $(shell ...) in recursive Make by clearing MAKEFLAGS.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/jobserver.md#2025-04-21_snippet_2\n\nLANGUAGE: make\nCODE:\n```\nS := $(shell MAKEFLAGS= rustc --print sysroot)\n\nx:\n\t@$(MAKE) y\n\ny:\n\t@echo $(S)\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Exception Handling for Emscripten Target\nDESCRIPTION: This snippet provides instructions for enabling WebAssembly exception handling when targeting wasm32-unknown-emscripten. It specifies the required linker flag for emcc and the compiler flag for C/C++ files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emscripten-wasm-eh.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# `emscripten-wasm-eh`\n\nUse the WebAssembly exception handling ABI to unwind for the\n`wasm32-unknown-emscripten`. If compiling with this setting, the `emcc` linker\nshould be invoked with `-fwasm-exceptions`. If linking with C/C++ files, the\nC/C++ files should also be compiled with `-fwasm-exceptions`.\n```\n\n----------------------------------------\n\nTITLE: Clang Wrapper Script for aarch64-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang compiler from the OpenHarmony SDK for the aarch64-unknown-linux-ohos target. It sets the target architecture, sysroot, and defines the __MUSL__ macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\n  -target aarch64-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Imports Granularity Configuration Example\nDESCRIPTION: Example configuration for the new imports_granularity option that replaces merge_imports. This option allows merging imports at different levels and flattening imports to have single use statements per item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\nimports_granularity = \"Crate\" # Or \"Module\" or \"Item\"\n```\n\n----------------------------------------\n\nTITLE: Fixing Stability Attribute for Deprecated Function in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous usage of the stability attribute where the 'note' field is missing in a deprecated function declaration. It includes the original code that results in an error along with the corrected version that complies with Rust's requirements by providing a 'note' explaining the deprecation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0543.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[stable(since = \"0.1.0\", feature = \"_deprecated_fn\")]\n#[deprecated(\n    since = \"1.0.0\"\n)] // invalid\nfn _deprecated_fn() {}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[stable(since = \"0.1.0\", feature = \"_deprecated_fn\")]\n#[deprecated(\n    since = \"1.0.0\",\n    note = \"explanation for deprecation\"\n)] // ok!\nfn _deprecated_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer Performance and Project Settings in JSON\nDESCRIPTION: Includes settings controlling performance-related limits and project discovery for rust-analyzer. Covers linked projects to override auto-discovery, number of worker threads for the main loop, LRU cache capacities for stored syntax trees and queries, and notification settings for certain warnings like missing Cargo.toml files. Such tuning helps optimize resource usage and control project scopes in editor environments committing Rust source. Inputs are null, integer, boolean, or array values, altering internal rust-analyzer behavior and memory consumption.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.linkedProjects\": [],\n  \"rust-analyzer.lru.capacity\": null,\n  \"rust-analyzer.lru.query.capacities\": {},\n  \"rust-analyzer.notifications.cargoTomlNotFound\": true,\n  \"rust-analyzer.numThreads\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Compiling Code for wasm32-wasip2\nDESCRIPTION: This Rust code snippet explains how to conditionally compile Rust code to target the wasm32-wasip2 environment. This is useful for ensuring compatibility within the right execution context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip2.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(all(target_os = \"wasi\", target_env = \"p2\"))]\n```\n\n----------------------------------------\n\nTITLE: Emitting a Lint with span_lint_and_help in EarlyLintPass - Rust\nDESCRIPTION: Shows how to use span_lint_and_help inside check_fn to emit a lint diagnostic for every function definition encountered by the FooFunctions EarlyLintPass. The function emits a message for functions named 'foo', offering an extra help message but no direct suggestion. Required dependencies are Clippy's diagnostics utilities and the definition of FOO_FUNCTIONS. Inputs include the lint context, lint ID, span, main and help messages, and an optional suggestion (None). Use in unit/UI-tested lint passes; message style should follow rustc's conventions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl EarlyLintPass for FooFunctions {\n    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n        span_lint_and_help(\n            cx,\n            FOO_FUNCTIONS,\n            span,\n            \"function named `foo`\",\n            None,\n            \"consider using a more meaningful name\"\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for Other Sanitizer Functions in Rust\nDESCRIPTION: This snippet marks various other sanitizer functions as uninstrumented and discarded for DFSan. It includes coverage, death callback, counter, and memory allocation tracking functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfun:__sanitizer_cov=uninstrumented\nfun:__sanitizer_cov=discard\nfun:__sanitizer_cov_module_init=uninstrumented\nfun:__sanitizer_cov_module_init=discard\nfun:__sanitizer_cov_with_check=uninstrumented\nfun:__sanitizer_cov_with_check=discard\nfun:__sanitizer_set_death_callback=uninstrumented\nfun:__sanitizer_set_death_callback=discard\nfun:__sanitizer_update_counter_bitset_and_clear_counters=uninstrumented\nfun:__sanitizer_update_counter_bitset_and_clear_counters=discard\nfun:__sanitizer_cov_trace_pc*=uninstrumented\nfun:__sanitizer_cov_trace_pc*=discard\nfun:__sanitizer_cov_pcs_init=uninstrumented\nfun:__sanitizer_cov_pcs_init=discard\n\nfun:__sanitizer_get_current_allocated_bytes=uninstrumented\nfun:__sanitizer_get_current_allocated_bytes=discard\nfun:__sanitizer_get_heap_size=uninstrumented\nfun:__sanitizer_get_heap_size=discard\nfun:__sanitizer_get_free_bytes=uninstrumented\nfun:__sanitizer_get_free_bytes=discard\nfun:__sanitizer_get_unmapped_bytes=uninstrumented\nfun:__sanitizer_get_unmapped_bytes=discard\nfun:__sanitizer_get_estimated_allocated_size=uninstrumented\nfun:__sanitizer_get_estimated_allocated_size=discard\nfun:__sanitizer_get_ownership=uninstrumented\nfun:__sanitizer_get_ownership=discard\nfun:__sanitizer_get_allocated_begin=uninstrumented\nfun:__sanitizer_get_allocated_begin=discard\nfun:__sanitizer_get_allocated_size=uninstrumented\nfun:__sanitizer_get_allocated_size=discard\nfun:__sanitizer_get_allocated_size_fast=uninstrumented\nfun:__sanitizer_get_allocated_size_fast=discard\nfun:__sanitizer_print_stack_trace=uninstrumented\nfun:__sanitizer_print_stack_trace=discard\n```\n\n----------------------------------------\n\nTITLE: Valid Concrete Const Parameter - Rust\nDESCRIPTION: Shows the correct way to define a const parameter by using a concrete type (usize) instead of referencing another generic type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0770.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T, const N: usize>() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Assignment Operations in Rust\nDESCRIPTION: This code snippet showcases various incorrect uses of the assignment operator in Rust, including attempts to assign values to constants, literals, functions, and structure names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0070.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\n\nconst SOME_CONST: i32 = 12;\n\nfn some_other_func() {}\n\nfn some_function() {\n    SOME_CONST = 14; // error: a constant value cannot be changed!\n    1 = 3; // error: 1 isn't a valid place!\n    some_other_func() = 4; // error: we cannot assign value to a function!\n    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used\n                        //        like a variable!\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Pattern Matching Error - Inconsistent Variable Binding\nDESCRIPTION: Example showing erroneous code where variable 'y' is bound inconsistently across patterns - by-value in one pattern and by-reference in another, causing compile error E0409.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0409.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = (0, 2);\nmatch x {\n    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n                                          //        different mode in pattern #2\n                                          //        than in pattern #1\n    _ => ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using fixed-x18 flag with shadow-call-stack sanitizer in Rust on aarch64\nDESCRIPTION: Example showing how to use the `-Zfixed-x18` flag alongside the shadow call stack sanitizer on aarch64 targets. This ensures the x18 register is reserved for the shadow stack pointer, which is essential for the sanitizer to work correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/fixed-x18.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-Zsanitizer=shadow-call-stack -Zfixed-x18\n```\n\n----------------------------------------\n\nTITLE: Invalid Self-Referential Struct Definition in Rust\nDESCRIPTION: Shows an invalid struct definition where Foo contains a Box<Foo>, creating an impossible initialization scenario\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0073.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo { x: Box<Foo> } // error\n```\n\n----------------------------------------\n\nTITLE: Calling Generic Function with Explicit Type Parameters in Rust\nDESCRIPTION: This code snippet shows how to call the `convertAll` function with explicit type parameters.  It creates a vector of string slices and attempts to call `convertAll` with `i32` as `A` and `String` as `T`. This is to illustrate how the trait bounds and variance rules apply when using generic functions with specific type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"let mut vector = vec![\"string\", ...];\nconvertAll::<i32, String>(vector);\"\n```\n\n----------------------------------------\n\nTITLE: Correct Drop Implementation Using Wrapper Type in Rust\nDESCRIPTION: This example demonstrates the correct way to implement Drop for generic types by using a wrapper struct that enforces the trait bound. The wrapper approach allows for proper specialization of Drop.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0367.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo{}\n\nstruct MyStruct<T> {\n    t: T\n}\n\nstruct MyStructWrapper<T: Foo> {\n    t: MyStruct<T>\n}\n\nimpl <T: Foo> Drop for MyStructWrapper<T> {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Types with `+` Operator in Rust\nDESCRIPTION: This snippet demonstrates how to properly break types that use the `+` operator (e.g., trait bounds). It advises breaking before each `+` and block-indenting the subsequent lines for enhanced readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/types.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"impl Clone\n    + Copy\n    + Debug\"\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Hexadecimal Underscore and Character Error (uppercase)\nDESCRIPTION: This snippet demonstrates an error where a hexadecimal integer literal (0x_) contains an underscore followed by invalid character 'G'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0x_G\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Array Pattern Matching in Rust\nDESCRIPTION: Example showing erroneous pattern matching on an array without a fixed length, which triggers compiler error E0730.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0730.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn is_123<const N: usize>(x: [u32; N]) -> bool {\n    match x {\n        [1, 2, ..] => true, // error: cannot pattern-match on an\n                            //        array without a fixed length\n        _ => false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Small Heuristics Example in Rust\nDESCRIPTION: Demonstrates the default formatting behavior when use_small_heuristics is set to 'Default', showing how different code constructs are formatted based on calculated width ratios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_75\n\nLANGUAGE: rust\nCODE:\n```\nenum Lorem {\n    Ipsum,\n    Dolor(bool),\n    Sit { amet: Consectetur, adipiscing: Elit },\n}\n\nfn main() {\n    lorem(\n        \"lorem\",\n        \"ipsum\",\n        \"dolor\",\n        \"sit\",\n        \"amet\",\n        \"consectetur\",\n        \"adipiscing\",\n    );\n\n    let lorem = Lorem {\n        ipsum: dolor,\n        sit: amet,\n    };\n    let lorem = Lorem { ipsum: dolor };\n\n    let lorem = if ipsum { dolor } else { sit };\n}\n```\n\n----------------------------------------\n\nTITLE: Shallow Clone of the Rust Repository\nDESCRIPTION: This snippet shows how to perform a shallow clone of the Rust repository to limit the history fetched from the server. This method is suitable for users looking to browse the source code without needing the full history.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth 1 https://github.com/rust-lang/rust.git\ncd rust\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol with Placeholders\nDESCRIPTION: Shows the mangled symbol for a static variable that uses placeholders for generic parameters. The placeholders indicate that the static is not monomorphized by the type or const parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_18\n\nLANGUAGE: text\nCODE:\n```\n_RNvNvMCsd9PVOYlP1UU_7mycrateINtB4_7ExamplepKpE3foo14EXAMPLE_STATIC\n                              │             │││\n                              │             ││└── const placeholder\n                              │             │└─── const generic argument\n                              │             └──── type placeholder\n                              └────────────────── generic-args\n```\n\n----------------------------------------\n\nTITLE: Opaque Types and Variances\nDESCRIPTION: This Rust code showcases how regular opaque types handle variances. Even though the lifetimes are unrelated, the opaque type bivariance allow the comparison without errors\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(return_position_impl_trait_in_trait)]\n\nfn bar<'lt: 'lt>() -> impl Eq {\n    ()\n}\n\nfn test<'a, 'b>() -> bool {\n    bar::<'a>() == bar::<'b>()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Usage of #[cmse_nonsecure_entry] Attribute in Rust\nDESCRIPTION: This code snippet shows an erroneous example of using the #[cmse_nonsecure_entry] attribute. The attribute is applied to a function with the 'C-cmse-nonsecure-entry' calling convention, which is only valid for TrustZone-M targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0775.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(cmse_nonsecure_entry)]\n\npub extern \"C-cmse-nonsecure-entry\" fn entry_function() {}\n```\n\n----------------------------------------\n\nTITLE: Specifying Output Directory\nDESCRIPTION: This code snippet demonstrates how to use the `-o` or `--out-dir` flag to specify the output directory for rustdoc's generated documentation.  This allows users to control where the documentation files are placed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -o target/doc\n$ rustdoc src/lib.rs --out-dir target/doc\n```\n\n----------------------------------------\n\nTITLE: Combining All Source Files\nDESCRIPTION: This CMake command sets the variable `SOURCES` to a list containing all source files defined previously (C, C++, and Assembly). This combined list is used to build the library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES\n    ${C_SOURCES}\n    ${CXX_SOURCES}\n    ${ASM_SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Disabling CI LLVM Download in bootstrap.toml\nDESCRIPTION: This configuration snippet in `bootstrap.toml` prevents the build system from downloading a pre-built LLVM from CI, forcing it to build from source. This is required to test local LLVM changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n\"[llvm]\\ndownload-ci-llvm = false\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stability Attribute Error in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous use of the stability attribute outside of the standard library. It illustrates how the compiler will emit an error when attempting to compile such code, indicating that stability attributes are restricted to the standard library scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0497.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"#[stable] // error: stability attributes may not be used outside of the\\n          //        standard library\\nfn foo() {}\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating FromEnv with a Rust Struct\nDESCRIPTION: This Rust code snippet shows the interaction between a `struct` with a `where` clause and the `FromEnv(Type)` domain goal inside of a function. The `loud_insert` function has a `HashSet<K>` as input which will assume `FromEnv(HashSet<K>)` inside the body of our function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"struct HashSet<K> where K: Hash { ... }\n\nfn loud_insert<K>(set: &mut HashSet<K>, item: K) {\n    println!(\\\"inserting!\\\");\n    set.insert(item);\n}\"\n```\n\n----------------------------------------\n\nTITLE: Partial Drop Example with PrintOnDrop\nDESCRIPTION: Demonstrates how types without explicit Drop implementations can be partially moved before dropping the remaining parts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/drop_check.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = (PrintOnDrop(\"third\"), PrintOnDrop(\"first\"));\n    drop(x.1);\n    println!(\"second\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Internal Change Changelog Entry\nDESCRIPTION: Example of how to add a changelog entry for an internal change that doesn't affect users.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nchangelog: none\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Trailing Quote in Raw Byte String Literal - Rust\nDESCRIPTION: This snippet highlights an error condition in Rust where a raw byte string literal is not properly terminated. The compiler detects the missing trailing double quote (`\"`) when using `#` symbols to create a raw byte string (e.g., `br##\"🦀`). The error message 'Missing trailing `\"` with `#` symbols to terminate the raw byte string literal' is generated when the closing quote is missing or misplaced. The primary dependency is the Rust compiler itself, and this functionality is intrinsic to the language's lexical analysis. The expected input is a raw byte string literal, and the output is a compile-time error message. There are no runtime behaviors as it is a compile time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_with_ferris.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nBYTE_STRING \"br##\\\"🦀\" error: Missing trailing `\"` with `#` symbols to terminate the raw byte string literal\n```\n\n----------------------------------------\n\nTITLE: Minimizing LLVM IR with LLVMExtract\nDESCRIPTION: Command to extract and minimize LLVM IR to create a minimal working example\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n<path/to/llvm-extract> -s --func=<name> --recursive --rfunc=\"enzyme_autodiff*\" --rfunc=\"enzyme_fwddiff*\" --rfunc=<fnc_called_by_enzyme> out.ll -o mwe.ll\n```\n\n----------------------------------------\n\nTITLE: Emscripten Ping Command for Github\nDESCRIPTION: Github command to notify the Emscripten support group for assistance with Emscripten-related issues in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/emscripten.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n@rustbot ping emscripten\n```\n\n----------------------------------------\n\nTITLE: JSON Output for Documentation Coverage (JSON)\nDESCRIPTION: This JSON snippet shows the output format when using --output-format json with the --show-coverage option in Rustdoc. It displays coverage information for a file with one documented and one undocumented item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_22\n\nLANGUAGE: json\nCODE:\n```\n{\"no_std.rs\":{\"total\":3,\"with_docs\":1,\"total_examples\":3,\"with_examples\":0}}\n```\n\n----------------------------------------\n\nTITLE: Impl Definition Formatting in Rust\nDESCRIPTION: Shows the formatting for Rust impl definitions, including the use of block-indent for impl items and single-line formatting for impls without items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nimpl Foo {}\n\nimpl Bar for Foo {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Packed Representation with Size in Rust\nDESCRIPTION: This code shows the proper way to specify packing to a given size by providing a size parameter to the `packed` representation hint instead of using both `packed` and `align`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0587.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed(8))] // ok!\nstruct Umbrella(i32);\n```\n\n----------------------------------------\n\nTITLE: Formatting Let-Else Statements in Rust\nDESCRIPTION: Demonstrates different formatting options for let-else statements based on the 'single_line_let_else_max_width' setting. Shows examples with default (50), minimum (0), and maximum (100) values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_64\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Some(w) = opt else { return Ok(()) };\n\n    let Some(x) = opt else { return };\n\n    let Some(y) = opt else {\n        return;\n    };\n\n    let Some(z) = some_very_very_very_very_long_name else {\n        return;\n    };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Some(w) = opt else {\n        return Ok(());\n    };\n\n    let Some(x) = opt else {\n        return;\n    };\n\n    let Some(y) = opt else {\n        return;\n    };\n\n    let Some(z) = some_very_very_very_very_long_name else {\n        return;\n    };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Some(w) = opt else { return Ok(()) };\n\n    let Some(x) = opt else { return };\n\n    let Some(y) = opt else {\n        return;\n    };\n\n    let Some(z) = some_very_very_very_very_long_name else { return };\n}\n```\n\n----------------------------------------\n\nTITLE: Normalizing Comments in Rust\nDESCRIPTION: Illustrates the effect of the normalize_comments option on converting block comments to line comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_56\n\nLANGUAGE: rust\nCODE:\n```\n// Lorem ipsum:\nfn dolor() -> usize {}\n\n/* sit amet: */\nfn adipiscing() -> usize {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n// Lorem ipsum:\nfn dolor() -> usize {}\n\n// sit amet:\nfn adipiscing() -> usize {}\n```\n\n----------------------------------------\n\nTITLE: Using Valid External Lang Item in Rust\nDESCRIPTION: This code demonstrates the correct usage of an external lang item, specifically 'panic_impl' which is recognized by the Rust compiler. Valid lang items can be found in the compiler's weak_lang_items.rs file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0264.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items)]\n#![allow(internal_features)]\n\nextern \"C\" {\n    #[lang = \"panic_impl\"] // ok!\n    fn cake();\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Doer Objects\nDESCRIPTION: This code demonstrates avoiding the creation of 'doer' objects, advocating for functional programming styles that promote simplicity in API design by directly invoking functions instead.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\ndo_thing(arg1, arg2);\n\n// BAD\nThingDoer::new(arg1, arg2).do();\n\npub fn do_thing(arg1: Arg1, arg2: Arg2) -> Res {\n    let mut ctx = Ctx { arg1, arg2 };\n    ctx.run()\n}\n\nstruct Ctx {\n    arg1: Arg1, arg2: Arg2\n}\n\nimpl Ctx {\n    fn run(self) -> Res {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol for Unicode Identifier Example\nDESCRIPTION: Shows how the Unicode identifiers from the previous Rust function example would be mangled in the compiled output. The example illustrates the use of Punycode encoding for the 'gödel' module name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n_RNvNtNtCsgOH4LzxkuMq_7mycrateu8gdel_5qa6escher4bach\n                              ││└───┬──┘\n                              ││    │\n                              ││    └── gdel_5qa translates to gödel\n                              │└─────── 8 is the length\n                              └──────── `u` indicates it is a Unicode identifier\n```\n\n----------------------------------------\n\nTITLE: Converting Lint Warning to Error in Rust\nDESCRIPTION: This code snippet illustrates how to change a lint warning into a hard error using the Rust compiler's `struct_span_code_err!` macro. It replaces the previous `add_lint` call and assigns a new error code. This requires knowledge of Rust linting and diagnostic systems.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/bug-fix-procedure.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nself.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n                       node_id,\n                       self.tcx.span_of_impl(item1).unwrap(),\n                       msg);\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct_span_code_err!(self.dcx(), self.tcx.span_of_impl(item1).unwrap(), E0592, msg)\n    .emit();\n```\n\n----------------------------------------\n\nTITLE: Specifying Dlltool Path in Rust\nDESCRIPTION: On windows-gnu targets, this flag specifies the path to the dlltool executable used for generating import libraries for raw-dylib link kinds. It takes a path to the dlltool executable. If this flag is not specified, a dlltool executable will be inferred.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Applying De Morgan's Law in Rust\nDESCRIPTION: This assist applies De Morgan's law to boolean expressions. It transforms expressions of the form `!l || !r` into `!(l && r)`, and vice versa.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if x != 4 || y < 3.14 {}\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if !(x == 4 && y >= 3.14) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Rewriting Pattern Without Sub-binding in Rust\nDESCRIPTION: This code snippet demonstrates how to rewrite the previous pattern without using sub-bindings, ensuring memory safety. It separates the ref binding into a separate let statement inside the match arm.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0303.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmatch Some(\"hi\".to_string()) {\n    Some(ref s) => {\n        let op_string_ref = &Some(s);\n        // ...\n    },\n    None => {},\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for Redox OS Targets in TOML\nDESCRIPTION: This TOML configuration snippet shows how to set up the Rust build process to include Redox OS targets. It specifies the build stage and lists the target architectures to be included, including the host target and the three Redox OS targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/redox.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\n    \"<HOST_TARGET>\",\n    \"x86_64-unknown-redox\",\n    \"aarch64-unknown-redox\",\n    \"i586-unknown-redox\",\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Nix Shell with Custom Bootstrap Settings\nDESCRIPTION: Nix configuration example showing how to manage bootstrap.toml settings within a nix shell.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  config = pkgs.writeText \"rustc-config\" ''\n    # Your bootstrap.toml content goes here\n  ''\npkgs.mkShell {\n  /* ... */\n  # This environment variable tells bootstrap where our bootstrap.toml is.\n  RUST_BOOTSTRAP_CONFIG = config;\n}\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Platform Support Table\nDESCRIPTION: CSS style rule to prevent code elements in table cells from wrapping, improving readability of target triples in the platform support tables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support.md#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\ntd code {\n        white-space: nowrap;\n    }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Use of Break in Closures (Rust Error E0267)\nDESCRIPTION: This code demonstrates the incorrect usage of a 'break' statement inside a closure but outside of any loop, which causes compilation error E0267. Loop keywords like 'break' and 'continue' must be used within a loop even when inside closures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0267.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet w = || { break; }; // error: `break` inside of a closure\n```\n\n----------------------------------------\n\nTITLE: Configuring Linting of Collapsible If Chains in Rust\nDESCRIPTION: This setting determines if collapsible `if` chains are linted when they contain comments inside the parts that would be collapsed.  It affects the `collapsible_if` lint. The default value is `false`, meaning commented-out code within `if` chains won't be checked. This configuration uses a boolean value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Feature Configuration Example in Rust\nDESCRIPTION: Demonstrates usage of feature flags with conditional compilation and their validation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"lion\")]     \nfn tame_lion(lion: Lion) {}\n\n#[cfg(feature = \"zebra\")]    \nfn ride_zebra(z: Zebra) {}\n\n#[cfg(feature = \"platypus\")] \nfn poke_platypus() {}\n\n#[cfg(feechure = \"lion\")]    \nfn tame_lion() {}\n\n#[cfg(windows = \"unix\")]     \nfn tame_windows() {}\n```\n\n----------------------------------------\n\nTITLE: Matching Exclusive Ranges in Rust\nDESCRIPTION: This snippet demonstrates an erroneous use of an exclusive range pattern in Rust, which results in a compile-time error due to an invalid range definition. The snippet illustrates how the Rust compiler checks that the range is non-empty, enforcing that the start of the range must be less than the end.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0579.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"compile_fail,E0579\\n\\nfn main() {\\n    match 5u32 {\\n        // This range is ok, albeit pointless.\\n        1..2 => {}\\n        // This range is empty, and the compiler can tell.\\n        5..5 => {} // error!\\n    }\\n}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Small vs Normal Struct Formatting in Rust\nDESCRIPTION: Shows two ways to format struct literals in Rust based on their size/complexity. The normal formatting uses multiple lines with fields on separate lines, while the 'small' format combines fields on a single line for more compact representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Normal formatting\nFoo {\n    f1: an_expression,\n    f2: another_expression(),\n}\n\n// \"small\" formatting\nFoo { f1, f2 }\n```\n\n----------------------------------------\n\nTITLE: Plain Listing Example\nDESCRIPTION: This snippet shows a plain text listing. It is extracted to show how this differs from code blocks with specified languages. It provides a means to include blocks of unformatted text in the changelog.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/xtask/test_data/expected.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nThis is a plain listing.\n```\n\n----------------------------------------\n\nTITLE: Using perf-focus with tree-callees to analyze MIR borrowck performance\nDESCRIPTION: Shows how to use perf-focus to analyze the call tree of do_mir_borrowck with minimum percentage threshold of 3%. Displays total and self percentages for each function in the call hierarchy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ perf focus '{do_mir_borrowck}' --tree-callees --tree-min-percent 3\nMatcher    : {do_mir_borrowck}\nMatches    : 577\nNot Matches: 746\nPercentage : 43%\n\nTree\n| matched `{do_mir_borrowck}` (43% total, 0% self)\n: | rustc_borrowck::nll::compute_regions (20% total, 0% self)\n: : | rustc_borrowck::nll::type_check::type_check_internal (13% total, 0% self)\n: : : | core::ops::function::FnOnce::call_once (5% total, 0% self)\n: : : : | rustc_borrowck::nll::type_check::liveness::generate (5% total, 3% self)\n: : : | <rustc_borrowck::nll::type_check::TypeVerifier<'a, 'b, 'tcx> as rustc::mir::visit::Visitor<'tcx>>::visit_mir (3% total, 0% self)\n: | rustc::mir::visit::Visitor::visit_mir (8% total, 6% self)\n: | <rustc_borrowck::MirBorrowckCtxt<'cx, 'tcx> as rustc_mir_dataflow::DataflowResultsConsumer<'cx, 'tcx>>::visit_statement_entry (5% total, 0% self)\n: | rustc_mir_dataflow::do_dataflow (3% total, 0% self)\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build Targets for VisionOS\nDESCRIPTION: Enables VisionOS targets in bootstrap configuration for Rust compiler build process. Demonstrates how to specify multiple targets for cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-visionos.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"aarch64-apple-visionos\", \"aarch64-apple-visionos-sim\"]\n```\n\n----------------------------------------\n\nTITLE: Invalid Raw Pointer Method Call in Rust\nDESCRIPTION: Example of incorrect code that triggers the error by calling is_null() on a raw pointer with an unspecified type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0699.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![deny(warnings)]\n# fn main() {\nlet foo = &1;\nlet bar = foo as *const _;\nif bar.is_null() {\n    // ...\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Incorrect Private Item Re-export in Rust\nDESCRIPTION: Example showing erroneous code that attempts to publicly re-export a private function, which results in error E0364.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0364.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    fn foo() {}\n\n    mod a {\n        pub use super::foo; // error!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Server Initialization with Wait Loop\nDESCRIPTION: Rust code snippet demonstrating a wait loop for debugging server initialization. This allows attaching a debugger at the very beginning of the server's execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/debugging.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet mut d = 4;\nwhile d == 4 { // set a breakpoint here and change the value\n    d = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Byte Literal Syntax Error Demonstration\nDESCRIPTION: Demonstrates an incomplete byte literal syntax where the closing single quote is missing, causing a compilation error in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_slash_n.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nb'\\n\n```\n\n----------------------------------------\n\nTITLE: Running Rustdoc in Check-Only Mode\nDESCRIPTION: Shows how to use Rustdoc to only check documentation without generating it. This flag performs type checking and linting but skips documentation generation and doctests, useful for quick validation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nrustdoc -Z unstable-options --check src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Multiline String Literal in Rust\nDESCRIPTION: A string literal containing a newline character, demonstrating multiline string support\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/strings.txt#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"multi\nline\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Inclusive Range with No End in Rust\nDESCRIPTION: This example shows code that fails to compile because it uses an inclusive range operator (..=) without specifying an end value. The compiler raises error E0586.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0586.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n    let x = &tmp[1..=]; // error: inclusive range was used with no end\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AST Node Trait - Rust\nDESCRIPTION: This snippet defines the `AstNode` trait for concrete nodes in the AST layer, providing methods for casting syntax nodes and accessing them. It establishes the framework for concrete syntax nodes like function definitions (FnDef) and demonstrates type-safe handling of AST nodes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub trait AstNode {\n    fn cast(syntax: SyntaxNode) -> Option<Self>\n    where\n        Self: Sized;\n\n    fn syntax(&self) -> &SyntaxNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Import Ordering Example in Rust\nDESCRIPTION: Demonstrates the rules for import ordering in Rust, where imports within a group must be version-sorted while preserving group separation with blank lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nuse d;\nuse c;\n\nuse b;\nuse a;\n```\n\n----------------------------------------\n\nTITLE: Configuration management in Rustfmt using macros and enums\nDESCRIPTION: This snippet explains how Rustfmt handles user configuration options through a dedicated module. It highlights the use of the `create_config!` macro to define options, the handling of various enums for configuration parameters, and the process of parsing configuration files. Functions access config values via methods like `config.max_width()` to customize formatting behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nRustfmt strives to be highly configurable. Often the first part of a patch is creating a configuration option for the feature you are implementing. All handling of configuration options is done in [src/config/mod.rs](src/config/mod.rs). Look for the `create_config!` macro at the end of the file for all the options. The rest of the file defines a bunch of enums used for options, and the machinery to produce the config struct and parse a config file, etc. Checking an option is done by accessing the correct field on the config struct, e.g., `config.max_width()`. Most functions have a `Config`, or one can be accessed via a visitor or context of some kind.\n```\n\n----------------------------------------\n\nTITLE: De Bruijn Index Example for Closures\nDESCRIPTION: Illustrates how de Bruijn indices could theoretically be used to represent variable bindings within closures (although rustc doesn't actually implement it this way for closures). The example demonstrates how the index corresponds to the number of levels up the variable is bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_6\n\nLANGUAGE: rust,ignore\nCODE:\n```\n|x| {\n    f(x) // de Bruijn index of `x` is 1 because `x` is bound 1 level up\n\n    |y| {\n        g(x, y) // index of `x` is 2 because it is bound 2 levels up\n                // index of `y` is 1 because it is bound 1 level up\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-fail doctest with error number\nDESCRIPTION: This Markdown snippet shows how to add an error number to a `compile_fail` doctest in Rust. This allows for verification that the code emits a specific error code. It's only functional on nightly builds of Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n``````markdown\n```compile_fail,E0044\nextern { fn some_func<T>(x: T); }\n```\n``````\n```\n\n----------------------------------------\n\nTITLE: Move Item Request in TypeScript\nDESCRIPTION: Defines an experimental request for moving code items up or down within a document\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MoveItemParams {\n    textDocument: TextDocumentIdentifier,\n    range: Range,\n    direction: Direction\n}\n\nexport const enum Direction {\n    Up = \"Up\",\n    Down = \"Down\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Feature Array in TOML\nDESCRIPTION: This snippet shows how to define an array of features in a Cargo.toml file, adhering to the specified formatting rules. Each feature is listed on the same line if it fits; otherwise, it utilizes block indentation for better readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/cargo.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nsome_feature = [\n    \"another_feature\",\n    \"yet_another_feature\",\n    \"some_dependency?/some_feature\",\n]\n```\n\n----------------------------------------\n\nTITLE: Querying Dataflow State via Intrinsic in Rust Compiler\nDESCRIPTION: The `rustc_peek` intrinsic is used within dataflow unit tests to query the computed dataflow state for a specific Lvalue. Its presence, when paired with a relevant `#[rustc_mir]` attribute, causes the compiler to check the dataflow bit; a set bit allows compilation to proceed, while an unset bit triggers an error message 'rustc_peek: bit not set'. It requires specific `#[rustc_mir]` attributes on the containing function to activate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/mir-dataflow/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nrustc_peek\n```\n\n----------------------------------------\n\nTITLE: Rustdoc Version Output\nDESCRIPTION: This is an example output of rustdoc's version information when using `-V` or `--version`. The output includes the version number, commit hash, date, and other relevant build details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nrustdoc 1.17.0 (56124baa9 2017-04-24)\n```\n\n----------------------------------------\n\nTITLE: Rust Raw String Literal Error\nDESCRIPTION: This code snippet demonstrates a common error in Rust when working with raw string literals. The error \"Missing trailing `\"` with `#` symbols to terminate the raw string literal\" arises when the number of `#` symbols preceding the closing quote of a raw string does not match the number of `#` symbols preceding the opening quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_with_space.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"r##\\\" \\\" error: Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Representation in Binder\nDESCRIPTION: This snippet shows an example of an incorrectly formed representation within a `Binder`, illustrating the issues that arise with escaping bound variables. It highlights how the Rust compiler can identify such erroneous structures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/binders.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nBinder(\n    fn(&'^1_0 &'^1 T/#0),\n    &[BoundVariableKind::Region(...)],\n)\n```\n\n----------------------------------------\n\nTITLE: Byte String Error: Missing Trailing Quote\nDESCRIPTION: This snippet demonstrates the error message produced when a byte string literal is not properly terminated with a closing double quote. The error occurs during compilation and prevents the program from running.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"BYTE_STRING \\\"b\\\"\\\" error: Missing trailing `\\\"` symbol to terminate the byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Conditionally Emitting Lint for Functions Named 'foo' - Rust\nDESCRIPTION: Updates the EarlyLintPass implementation to only emit a lint if the function being checked is named 'foo'. The added is_foo_fn function encapsulates the name matching logic, improving code clarity and potential testability. Dependencies include the is_foo_fn utility and span_lint_and_help. Parameters are the same as the base check_fn, and an ident.name comparison is used for detection. Limitations: this approach ignores closures and other item kinds by design.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nimpl EarlyLintPass for FooFunctions {\n    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n        if is_foo_fn(fn_kind) {\n            span_lint_and_help(\n                cx,\n                FOO_FUNCTIONS,\n                span,\n                \"function named `foo`\",\n                None,\n                \"consider using a more meaningful name\"\n            );\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Type Aliases with Unused Type Parameters in Rust\nDESCRIPTION: Examples of Rust code that will trigger the E0091 compiler error due to having unused type parameters in type alias declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0091.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo<T> = u32; // error: type parameter `T` is never used\n// or:\ntype Foo<A, B> = Box<A>; // error: type parameter `B` is never used\n```\n\n----------------------------------------\n\nTITLE: Configuring Paths for Interior Mutability in Rust\nDESCRIPTION: This configuration option specifies a list of paths to types that should be treated as if they do not contain interior mutability.  This affects lints related to mutable consts within types. The default value is `[\"bytes::Bytes\"]`. The input is a list of strings representing paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_21\n\n\n\n----------------------------------------\n\nTITLE: AstId Definition for Position-Independent References (Rust)\nDESCRIPTION: This code defines the AstId structure that provides position-independent references to AST nodes, which is key to the source map pattern implementation in Rust Analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/ast_id_map.rs#L29\n```\n\n----------------------------------------\n\nTITLE: Using Qualified Paths in Pattern Matching - Rust\nDESCRIPTION: Demonstrates how to use qualified paths in pattern matching with the more_qualified_paths feature. Shows destructuring through a qualified path using trait associated types and struct patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/more-qualified-paths.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(more_qualified_paths)]\n\nfn main() {\n    // destructure through a qualified path\n    let <Foo as A>::Assoc { br } = StructStruct { br: 2 };\n}\n\nstruct StructStruct {\n    br: i8,\n}\n\nstruct Foo;\n\ntrait A {\n    type Assoc;\n}\n\nimpl A for Foo {\n    type Assoc = StructStruct;\n}\n```\n\n----------------------------------------\n\nTITLE: Indexing with Vec: Implementing std::ops::Index in Rust\nDESCRIPTION: This example showcases the correct way to index into a `Vec` type in Rust. The `Vec` type implements the `std::ops::Index` trait, allowing you to access elements using the indexing operator ([]).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0608.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"let v: Vec<u8> = vec![0, 1, 2, 3];\\n\\n// The `Vec` type implements the `Index` trait so you can do:\\nprintln!(\"{}\", v[2]);\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating compile_fail E0573\nDESCRIPTION: This code snippet shows examples that cause the `E0573` compile error in Rust. The error happens when a specific enum variant or a constant is used where a type is required, such as in a function return type or an `impl` block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0573.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0573\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon::Born { // error!\n    Dragon::Born\n}\n\nconst HOBBIT: u32 = 2;\nimpl HOBBIT {} // error!\n\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(_: Wizard::Saruman); // error!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Incorrect Access of Associated Constant in Rust Trait\nDESCRIPTION: This code snippet demonstrates an invalid attempt to access an associated constant through a generic type parameter in a Rust trait. This approach is not supported and would previously trigger a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0329.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    const BAR: f64;\n}\n\nstruct MyStruct;\n\nimpl Foo for MyStruct {\n    const BAR: f64 = 0f64;\n}\n\nfn get_bar_bad<F: Foo>(t: F) -> f64 {\n    F::BAR\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Solution: Using PhantomData in Rust\nDESCRIPTION: This code snippet shows an alternative solution using PhantomData<T>, which has an alignment of 1 for all T, allowing the field to be kept without causing alignment issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0691.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_align)]\n\nuse std::marker::PhantomData;\n\n#[repr(align(32))]\nstruct ForceAlign32;\n\n#[repr(transparent)]\nstruct Wrapper(f32, PhantomData<ForceAlign32>);\n```\n\n----------------------------------------\n\nTITLE: Moving Inline Module to Separate File in Rust\nDESCRIPTION: Extracts an inline module's contents to a separate file. This refactoring improves code organization by converting module definitions from inline blocks to file-based modules, following Rust's module system conventions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_89\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    fn t() {}\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod foo;\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Parameter Naming - Duplicate Parameters\nDESCRIPTION: Example showing incorrect usage where the same type parameter name T is used twice in a function signature, resulting in error E0403.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0403.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f<T, T>(s: T, u: T) {}\n```\n\n----------------------------------------\n\nTITLE: Defining Future Compatibility Lint in Rust\nDESCRIPTION: This snippet defines a future compatibility lint entry in the Rust compiler. It references the lint ID and associated issue. This context is necessary for maintaining and updating the list of future compatibility concerns within the Rust source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/bug-fix-procedure.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nFutureIncompatibleInfo {\n    id: LintId::of(OVERLAPPING_INHERENT_IMPLS),\n    reference: \"issue #36889 <https://github.com/rust-lang/rust/issues/36889>\",\n},\n```\n\n----------------------------------------\n\nTITLE: Valid Type Placeholder Usage in Rust Expressions\nDESCRIPTION: Example demonstrating valid usage of type placeholder (_) in method chaining and type inference contexts, specifically with Vec collection.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0121.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"a4a\".split('4')\n    .collect::<Vec<_>>(); // No need to precise the Vec's generic type.\n```\n\n----------------------------------------\n\nTITLE: Erroneous Lifetime Binding in Function\nDESCRIPTION: Demonstrates a compilation error where a lifetime is used in a return type without being present in input types, causing type resolution issues\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0582.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn bar<F>(t: F)\n    where F: for<'a> Fn(i32) -> Option<&'a i32>\n{\n}\n\nfn main() { }\n```\n\n----------------------------------------\n\nTITLE: Incorrect Drop Implementation for Generic Type in Rust\nDESCRIPTION: This example shows an erroneous attempt to implement the Drop trait for a specialized generic type. The code fails because Drop cannot be specialized for only a subset of type implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0367.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\nstruct MyStruct<T> {\n    t: T\n}\n\nimpl<T: Foo> Drop for MyStruct<T> {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Rust Compiler Diagnostic Output\nDESCRIPTION: This code snippet shows the structure of a MappedRustDiagnostic object, which contains detailed information about a Rust compiler error. It includes the file location, error severity, error code, and a descriptive message about the missing main function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/reasonable_line_numbers_from_empty_file.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nMappedRustDiagnostic {\n    url: Url {\n        scheme: \"file\",\n        cannot_be_a_base: false,\n        username: \"\",\n        password: None,\n        host: None,\n        port: None,\n        path: \"/test/src/bin/current.rs\",\n        query: None,\n        fragment: None,\n    },\n    diagnostic: Diagnostic {\n        range: Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 0,\n                character: 0,\n            },\n        },\n        severity: Some(\n            Error,\n        ),\n        code: Some(\n            String(\n                \"E0601\",\n            ),\n        ),\n        code_description: Some(\n            CodeDescription {\n                href: Url {\n                    scheme: \"https\",\n                    cannot_be_a_base: false,\n                    username: \"\",\n                    password: None,\n                    host: Some(\n                        Domain(\n                            \"doc.rust-lang.org\",\n                        ),\n                    ),\n                    port: None,\n                    path: \"/error-index.html\",\n                    query: None,\n                    fragment: Some(\n                        \"E0601\",\n                    ),\n                },\n            },\n        ),\n        source: Some(\n            \"rustc\",\n        ),\n        message: \"`main` function not found in crate `current`\\nconsider adding a `main` function to `src/bin/current.rs`\",\n        related_information: None,\n        tags: None,\n        data: None,\n    },\n    fix: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Negative Trait Implementation in Rust\nDESCRIPTION: Example showing how to use the negative_impls feature gate to explicitly declare that a reference type does not implement the DerefMut trait. This demonstrates the basic syntax for negative implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/negative-impls.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(negative_impls)]\ntrait DerefMut { }\nimpl<T: ?Sized> !DerefMut for &T { }\n```\n\n----------------------------------------\n\nTITLE: Suggesting Variable Name Change in Rust\nDESCRIPTION: This snippet shows a compiler hint suggesting to change the unused variable 'foo' to '_foo'. It includes a code action to automatically make this change.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_unused_variable.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n_foo\n```\n\n----------------------------------------\n\nTITLE: Multiline Blocks - True\nDESCRIPTION: Demonstrates how closures and match arm bodies are formatted when `force_multiline_blocks` is set to `true`. They are forced to be wrapped in blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    result.and_then(|maybe_value| {\n        match maybe_value {\n            None => foo(),\n            Some(value) => bar(),\n        }\n    });\n\n    match lorem {\n        None => {\n            |ipsum| {\n                println!(\"Hello World\");\n            }\n        }\n        Some(dolor) => foo(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exported Function in Rust Module\nDESCRIPTION: Defines an exported function in Rust, indicating it is publicly accessible outside the module or crate. This function likely performs a specific operation, though the implementation details are not provided here.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-link-ordinal/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nexported_function\n```\n\n----------------------------------------\n\nTITLE: Formatting Basic Imports in Rust\nDESCRIPTION: Demonstrates the basic formatting rules for import (use) statements in Rust, including single line usage and handling of multiple items from the same module.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nuse a::b::c;\nuse a::b::d::*;\nuse a::b::{foo, bar, baz};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Normalization of Alias Types in Rust\nDESCRIPTION: This code snippet illustrates the importance of unique normalization results for alias types and constants. It shows a generic function that relies on the normalization of associated types to maintain type safety.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/invariants.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Trait>(\n    x: <T as Trait>::Assoc\n) -> <T as Trait>::Assoc {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_5 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_5` function in Rust, passing a struct `S` with integer members and an integer argument (16). It illustrates a function call with a user-defined struct and integer parameters.  The output of the call depends on the definition of the function and the structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_5(S { x: 1, y: 2 }, 16)\n```\n\n----------------------------------------\n\nTITLE: Copying Build Dist from Docker\nDESCRIPTION: This snippet details how to copy the build output tarball from the Docker container to the host system for further usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker cp <dockerid>:/rust/build/dist/rust-nightly-x86_64-unknown-linux-gnu.tar.gz rust-nightly-x86_64-unknown-linux-gnu.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Handling Implied Bounds with Late-Bound Lifetimes\nDESCRIPTION: This code illustrates using implied bounds with a function that accepts a reference containing a lifetime parameter, demonstrating Rust's behavior regarding late-bound lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, T>(_: &'a T) {}\n\nlet f = foo;\nf(&String::new());\nf(&String::new());\n```\n\n----------------------------------------\n\nTITLE: Type Outlives Examples\nDESCRIPTION: Demonstrates how type outlives bounds interact with function item types that have early bound parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(_: T) {}\n\nfn requires_static<T: 'static>(_: T) {}\n\nfn bar<T>() {\n    let f /* : FooFnItem<T> */ = foo::<T>;\n    requires_static(f);\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Error E0592 in Rust Definitions\nDESCRIPTION: This Rust snippet shows an example of error E0592, which occurs when two methods are defined with the same name within separate impl blocks for the same struct. The purpose is to demonstrate the issue of duplicated method names, leading to compilation failure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0592.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0592\nstruct Foo;\n\nimpl Foo {\n    fn bar() {} // previous definition here\n}\n\nimpl Foo {\n    fn bar() {} // duplicate definition here\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing the Not Trait for an Enum in Rust\nDESCRIPTION: This snippet showcases the implementation of the Not trait for the Question enum, allowing the use of the unary 'not' operator. The implementation maps Yes to false and No to true, satisfying the required trait contract. The code also includes assertions to test the implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0600.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::ops::Not;\n\nenum Question {\n    Yes,\n    No,\n}\n\n// We implement the `Not` trait on the enum.\nimpl Not for Question {\n    type Output = bool;\n\n    fn not(self) -> bool {\n        match self {\n            Question::Yes => false, // If the `Answer` is `Yes`, then it\n                                    // returns false.\n            Question::No => true, // And here we do the opposite.\n        }\n    }\n}\n\nassert_eq!(!Question::Yes, false);\nassert_eq!(!Question::No, true);\n```\n\n----------------------------------------\n\nTITLE: Correct Single Lifetime Bound Example in Rust\nDESCRIPTION: Shows the correct way to specify a single lifetime bound on a trait object, which is the valid approach in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0226.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\n\ntype T<'a> = dyn Foo + 'a;\n```\n\n----------------------------------------\n\nTITLE: Erroneous Usage of Break Outside Loop in Rust\nDESCRIPTION: This example demonstrates the incorrect usage of the 'break' keyword outside of a loop context, which results in the E0268 compilation error. Loop keywords can only be used within loops.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0268.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn some_func() {\n    break; // error: `break` outside of a loop\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Nested Imports in Rust\nDESCRIPTION: Guidelines for formatting imports with nested components, showing how to structure multi-line imports with proper indentation and line breaks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nuse a::b::{\n    x, y, z,\n    u::{...},\n    w::{...},\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Unwrap Panic Example in Rust\nDESCRIPTION: Demonstrates how unwrap() panic messages display caller location information differently between Rust versions 1.41 and 1.42.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/implicit-caller-location.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let foo: Option<()> = None;\n    foo.unwrap(); // this should produce a useful panic message!\n}\n```\n\n----------------------------------------\n\nTITLE: Opting out of unstable features in Rust with a crate-level attribute\nDESCRIPTION: Using the #![forbid(unstable_features)] attribute at the crate root to prevent usage of unstable features, providing a way for crates to opt out of unstable features even if RUSTC_BOOTSTRAP is set.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/rustc-bootstrap.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![forbid(unstable_features)]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lint Check Conflict with forbid Directive in Rust\nDESCRIPTION: Shows an example of code that fails to compile due to an allow attribute conflicting with a forbid directive for non_snake_case lints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0453.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![forbid(non_snake_case)]\n\n#[allow(non_snake_case)]\nfn main() {\n    // error: allow(non_snake_case) incompatible with previous forbid\n    let MyNumber = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0407 Error in Rust Trait Implementation\nDESCRIPTION: This code snippet shows an erroneous trait implementation where a method 'b' is defined in the implementation but not in the trait 'Foo', resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0407.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\n----------------------------------------\n\nTITLE: Inlining a Constant as a Literal in Rust\nDESCRIPTION: Shows how a constant string reference can be inlined by replacing the constant identifier with its actual string value. This eliminates the indirection while preserving the original constant definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_67\n\nLANGUAGE: rust\nCODE:\n```\nconst STRING: &str = \"Hello, World!\";\n\nfn something() -> &'static str {\n    STRING┃\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nconst STRING: &str = \"Hello, World!\";\n\nfn something() -> &'static str {\n    \"Hello, World!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using JSON Output Format in Rustdoc (Bash)\nDESCRIPTION: This command demonstrates how to use the --output-format json flag in Rustdoc to emit documentation in the experimental JSON format. It's useful for tooling and automated processing of documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nrustup component add --toolchain nightly rust-docs-json\n```\n\n----------------------------------------\n\nTITLE: Attribute Inheritance with Inlining in Rust\nDESCRIPTION: This code illustrates how attributes are inherited when an item is inlined.  The `Visible` re-export will inherit the documentation and `cfg` attributes from `InPrivate` and `Second`. The documentation will be concatenated, and the `cfg` attributes will be combined using `#[cfg(a, b, c)]`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_mod {\n    /// First\n    #[cfg(a)]\n    pub struct InPrivate;\n    /// Second\n    #[cfg(b)]\n    pub use self::InPrivate as Second;\n}\n\n/// Third\n#[doc(inline)]\n#[cfg(c)]\npub use self::private_mod::Second as Visible;\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stack Buffer Overflow (Rust)\nDESCRIPTION: This Rust code snippet shows a simple program designed to cause a stack buffer overflow. It declares a small array on the stack and then attempts to read beyond its bounds using unsafe pointer arithmetic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let xs = [0, 1, 2, 3];\n    let _y = unsafe { *xs.as_ptr().offset(4) };\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Trait Implementation\nDESCRIPTION: Shows the basic structure of implementing a trait generically for all types T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0119.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Enum Pattern Matching in Rust\nDESCRIPTION: Example of code that triggers E0023 error by attempting to extract only one field from an enum variant that has two fields. The pattern in the match statement doesn't account for all fields in the Apple variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0023.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n\nlet x = Fruit::Apple(String::new(), String::new());\n\nmatch x {\n    Fruit::Apple(a) => {}, // error!\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0033 Error When Dereferencing Trait Objects in Rust\nDESCRIPTION: This code example demonstrates the E0033 error that occurs when attempting to implicitly dereference a trait object. The error occurs because trait objects have no fixed size at compile time, so they must be accessed through pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0033.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }\n# impl<T> SomeTrait for T {}\nlet trait_obj: &SomeTrait = &\"some_value\";\n\n// This tries to implicitly dereference to create an unsized local variable.\nlet &invalid = trait_obj;\n\n// You can call methods without binding to the value being pointed at.\ntrait_obj.method_one();\ntrait_obj.method_two();\n```\n\n----------------------------------------\n\nTITLE: Removing Mutable References in Rust Methods\nDESCRIPTION: Removes the `mut` keyword from method references when mutability is not required. This refactoring helps express the intent of the code more accurately by removing unnecessary mutability annotations from method signatures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_99\n\nLANGUAGE: rust\nCODE:\n```\nimpl Walrus {\n    fn feed(&mut self, amount: u32) {}\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl Walrus {\n    fn feed(&self, amount: u32) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Inlining All Uses of a Type Alias in Rust\nDESCRIPTION: Demonstrates replacing all occurrences of a type alias with its concrete type throughout the codebase. This refactoring helps eliminate an unnecessary type alias while preserving program behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_72\n\nLANGUAGE: rust\nCODE:\n```\ntype ┃A = i32;\nfn id(x: A) -> A {\n    x\n};\nfn foo() {\n    let _: A = 3;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n\nfn id(x: i32) -> i32 {\n    x\n};\nfn foo() {\n    let _: i32 = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Glob Re-exports in Rust\nDESCRIPTION: Expands non-private glob re-exports (pub use foo::*) into explicit item re-exports. Makes the public API more explicit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub struct Bar;\n    pub struct Baz;\n}\n\npub use foo::*;\n```\n\n----------------------------------------\n\nTITLE: Defining Traits Foo and Bar with Impl in Rust\nDESCRIPTION: This snippet defines two traits, `Foo` and `Bar`, and provides a blanket implementation of `Foo` for any type `F` that implements `Bar`. This demonstrates how trait bounds can be used in generic implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/hrtb.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<X> {\n    fn foo(&self, x: X) { }\n}\n\ntrait Bar<X> {\n    fn bar(&self, x: X) { }\n}\n\nimpl<X,F> Foo<X> for F\n    where F : Bar<X>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Static-Const Reference Pattern in Rust\nDESCRIPTION: Demonstrates an erroneous pattern where a const variable attempts to reference a static variable, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0013.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstatic X: i32 = 42;\nconst Y: i32 = X;\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Target for i686-apple-darwin in Rust\nDESCRIPTION: This snippet shows the configuration required in the `bootstrap.toml` file to build Rust for the `i686-apple-darwin` target. Ensure you have the macOS 10.13 SDK from Xcode 9, and set `SDKROOT` accordingly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/i686-apple-darwin.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"i686-apple-darwin\"]\n```\n\n----------------------------------------\n\nTITLE: Correcting Byte Constant Syntax in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to declare a byte constant in Rust. The byte constant is properly terminated with a closing single quote, resolving the compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0763.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet c = b'a'; // ok!\n```\n\n----------------------------------------\n\nTITLE: Correct Inherent Implementation in Rust\nDESCRIPTION: This code snippet shows the correct way to create an inherent implementation without the unsafe keyword. Inherent implementations are always safe by definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0197.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo { } // ok!\n```\n\n----------------------------------------\n\nTITLE: Expression ID for Position-Independent References (Rust)\nDESCRIPTION: This code defines the expression ID structure used to reference expressions in a position-independent manner during type inference, enabling stable references across source modifications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/hir.rs#L37\n```\n\n----------------------------------------\n\nTITLE: Defining DiscoverProjectData Enum for Workspace Discovery in Rust\nDESCRIPTION: Rust enum representing possible outputs of the workspace discovery command for rust-analyzer. The enum variants include Finished (providing buildfile path and project data), Error (error message and optional source), and Progress (status message). It is serialized/deserialized using serde with a 'kind' tag. Provides structured communication between the discovery command and rust-analyzer's workspace handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"kind\")]\n#[serde(rename_all = \"snake_case\")]\nenum DiscoverProjectData {\n    Finished { buildfile: Utf8PathBuf, project: ProjectJsonData },\n    Error { error: String, source: Option<String> },\n    Progress { message: String },\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Let Statement with Type and Expression Line Breaking\nDESCRIPTION: Illustrates advanced formatting for let statements with complex types and multi-line expressions\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet Foo {\n    f: abcd,\n    g: qwer,\n}: Foo<Bar> =\n    Foo { f, g };\n```\n\n----------------------------------------\n\nTITLE: Debugging Stdarch Tests with SDE Debug Flag\nDESCRIPTION: Command to run the stdarch test binary directly with SDE's debug flag enabled. This provides more detailed debugging information when tests crash with signals like SIGSEGV.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsde -debug -future -rtm_mode full -- /home/user/projects/rustc_codegen_gcc/build/build_sysroot/sysroot_src/library/stdarch/target/debug/deps/core_arch-fd2d75f89baae5c6\n```\n\n----------------------------------------\n\nTITLE: Referencing C's unsigned long long Type in Rust\nDESCRIPTION: Demonstrates the usage and platform-specific considerations of C's unsigned long long type in Rust context. While typically equivalent to u64, the actual size depends on the platform's long long implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_ulonglong.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nc_longlong\n```\n\nLANGUAGE: c\nCODE:\n```\nunsigned long long\n```\n\n----------------------------------------\n\nTITLE: Invalid Async Usage in Const Context - Rust\nDESCRIPTION: Demonstrates an erroneous attempt to use an async/await expression inside a const context. This pattern is not currently supported in Rust's const evaluation system and will result in a compiler error. The feature may be supported in the future as tracked by issue #69431.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0744.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst _: i32 = {\n    async { 0 }.await\n};\n```\n\n----------------------------------------\n\nTITLE: Constant Generic Parameter Example\nDESCRIPTION: Example Rust function using a constant generic parameter. This demonstrates how constant values are used in generic type arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    example::<0x12345678>();\n}\n\npub fn example<const N: u64>() {}\n```\n\n----------------------------------------\n\nTITLE: Invalid Nested C-Variadic Type Example in Rust\nDESCRIPTION: Demonstrates incorrect usage of C-variadic type by nesting it inside a reference type. This code fails to compile because C-variadic types can only be used directly in foreign function declarations, not nested within other types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0743.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo2(x: u8, y: &...) {} // error!\n```\n\n----------------------------------------\n\nTITLE: Cleaning the Build Directory\nDESCRIPTION: This command cleans the build directory, removing all built artifacts.  This is useful for starting a fresh build, but should be avoided unless necessary, as it can be time-consuming.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./x clean\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching Implementation in Rust\nDESCRIPTION: This example demonstrates two correct ways to implement pattern matching: explicitly covering all enum variants, or using the wildcard pattern (_) to catch any remaining cases.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0004.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    Terminator::HastaLaVistaBaby => {}\n}\n\n// or:\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example of JSON5 output from the instrumented binary\nDESCRIPTION: Sample output from running the instrumented JSON5 formatter binary, showing the formatted JSON5 result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_5\n\nLANGUAGE: json5\nCODE:\n```\n{\n    some: \"thing\",\n}\n```\n\n----------------------------------------\n\nTITLE: Candidate Example with Different Self Types\nDESCRIPTION: Demonstrates multiple method candidates with different self type requirements for the same method on a complex receiver type\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/method-lookup.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Method candidates for foo() on Rc<Box<[T; 3]>>:\n// 1. &Rc<U> as extension candidate\n// 2. &mut Box<U> as inherent candidate\n```\n\n----------------------------------------\n\nTITLE: Invalid Module Visibility Example in Rust\nDESCRIPTION: Demonstrates incorrect usage of pub(in path) visibility modifier where the target module is not an ancestor of the current item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0742.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub mod sea {}\n\npub (in crate::sea) struct Shark; // error!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Syntax in llvm_asm Macro (Rust)\nDESCRIPTION: This code snippet demonstrates the invalid syntax that would have previously triggered the deprecated error code. It attempts to use the llvm_asm macro with incorrect syntax in the second argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0661.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet a;\nllvm_asm!(\"nop\" : \"r\"(a));\n```\n\n----------------------------------------\n\nTITLE: Cross Compilation Command for Rust using Tomatoware\nDESCRIPTION: This text snippet provides the complete shell command to cross-compile Rust programs for armv7-unknown-linux-uclibceabi. It sets environment variables for the C compiler and linker and uses Cargo for the build process. Ensure the Tomatoware toolchain is correctly installed and available in the PATH.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabi.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nCC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\nCXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \\\nAR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \\\nCFLAGS_armv7_unknown_linux_uclibceabi=\\\"-march=armv7-a -mtune=cortex-a9\\\" \\\nCXXFLAGS_armv7_unknown_linux_uclibceabi=\\\"-march=armv7-a -mtune=cortex-a9\\\" \\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUSTFLAGS='-Clink-arg=-s -Clink-arg=-Wl,--dynamic-linker=/mmc/lib/ld-uClibc.so.1 -Clink-arg=-Wl,-rpath,/mmc/lib' \\\ncargo +stage2 \\\nbuild \\\n--target armv7-unknown-linux-uclibceabi \\\n--release\n```\n\n----------------------------------------\n\nTITLE: Failure Status Parsing Implementation in Rust\nDESCRIPTION: Rust implementation for parsing and handling the failure status directive in test configurations\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/directives.md#2025-04-21_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\nfn parse_failure_status(&self, line: &str) -> Option<i32> {\n        match self.parse_name_value_directive(line, \"failure-status\") {\n            Some(code) => code.trim().parse::<i32>().ok(),\n            _ => None,\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Analyzing Rust Raw String Literal Error\nDESCRIPTION: This snippet demonstrates a Rust lexer error where a raw string literal starts with `r##` but does not have the matching closing quote and `#` symbols. The error message \"error: Missing `\\\"` symbol after `#` symbols to begin the raw string literal\" indicates that the compiler expects a closing delimiter with the same number of `#` characters as the opening delimiter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unstarted_raw_string_with_ascii.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"STRING \\\"r## \\\" error: Missing `\\\"` symbol after `#` symbols to begin the raw string literal\"\n\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Type Declaration in Rust\nDESCRIPTION: Example showing correct syntax using angle brackets for generic type Vec.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0214.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec<&str> = vec![\"foo\"];\n```\n\n----------------------------------------\n\nTITLE: Adding Nested Goals in Rust Trait Solver\nDESCRIPTION: Instead of directly calling compute_goal for nested goals, the solver uses add_goal to handle inference constraints from later goals. This allows for better handling of ambiguous cases that may be resolved by later constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/the-solver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nEvalCtxt::add_goal\n```\n\n----------------------------------------\n\nTITLE: Using Non-static Lifetime in Const Generic Parameter (Error Example)\nDESCRIPTION: This code demonstrates an erroneous attempt to use a non-static lifetime ('a) in a const generic parameter. This pattern is not allowed in Rust and would trigger error E0770.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0771.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(adt_const_params, unsized_const_params)]\n\nfn function_with_str<'a, const STRING: &'a str>() {} // error!\n```\n\n----------------------------------------\n\nTITLE: Defining PatternTree with Traits in Rust\nDESCRIPTION: This snippet outlines the PatternTree structure used for matching patterns against Rust syntax trees. The implementation involves enums for expressions, literals, statements, and block types, with specialized structures to handle alternatives, sequences, and optionals. This is critical for pattern parsers to define pattern representations and matching rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub enum Expr {\n    Lit(Alt<Lit>),\n    Array(Seq<Expr>),\n    Block_(Alt<BlockType>),\n    If(Alt<Expr>, Alt<BlockType>, Opt<Expr>),\n    IfLet(\n        Alt<BlockType>,\n        Opt<Expr>,\n    ),\n}\n\npub enum Lit {\n    Char(Alt<char>),\n    Bool(Alt<bool>),\n    Int(Alt<u128>),\n}\n\npub enum Stmt {\n    Expr(Alt<Expr>),\n    Semi(Alt<Expr>),\n}\n\npub enum BlockType {\n    Block(Seq<Stmt>),\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Git Status with Submodule Changes\nDESCRIPTION: Shows the output of `git status` when submodules have been updated upstream. It indicates which submodules have 'new commits' that are not reflected in the local repository's tracked commit hash for that submodule.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   src/llvm-project (new commits)\n\tmodified:   src/tools/cargo (new commits)\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n----------------------------------------\n\nTITLE: Encoding Function Example in Crate Root as Rust Symbol\nDESCRIPTION: This snippet showcases the mangled symbol for the function `example` within a Rust crate named `mycrate`, detailing the crate-root and path encoding. It provides an example of how to produce a human-readable form of Rust symbols for functions declared at the crate level.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn example() {}\n```\n\n----------------------------------------\n\nTITLE: Binary Operator Back Style\nDESCRIPTION: Example showing binary operator placement at the end of lines when expressions span multiple lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||\n        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;\n\n    let sum = 123456789012345678901234567890 +\n        123456789012345678901234567890 +\n        123456789012345678901234567890;\n\n    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..\n        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n}\n```\n\n----------------------------------------\n\nTITLE: Future-incompatible Lint Example in Rust\nDESCRIPTION: Demonstrates a future-incompatible lint warning about unsafe packed field borrowing. Shows how the compiler warns about code that will become invalid in future Rust versions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/index.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nwarning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n  --> lint_example.rs:11:13\n   |\n11 |     let y = &x.data.0;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(safe_packed_borrows)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n```\n\n----------------------------------------\n\nTITLE: Usage of transmute for FFI in Rust\nDESCRIPTION: This snippet demonstrates the unsafe use of transmute to convert a function item into a function pointer type within Foreign Function Interface (FFI) contexts. It warns against incorrect use due to the type differences between function items and function pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0591.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" fn foo(userdata: Box<i32>) {\n    /* ... */ \n}\n\n# fn callback(_: extern \"C\" fn(*mut i32)) {}\n# use std::mem::transmute;\nunsafe {\n    let f: extern \"C\" fn(*mut i32) = transmute(foo);\n    callback(f);\n}\n```\n\n----------------------------------------\n\nTITLE: Extending CodeAction Interface for Grouping\nDESCRIPTION: Adds a 'group' field to the CodeAction interface to support grouping related code actions in the lightbulb menu, allowing for better organization of similar actions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CodeAction {\n    title: string;\n    group?: string;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust with GNULLVM Target in MSYS2\nDESCRIPTION: Command for building and installing Rust with the x86_64-pc-windows-gnullvm target using MSYS2 MINGW64 shell. This command cross-compiles Rust using the x86_64-pc-windows-gnu build toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/windows-gnullvm.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./x.py install --host x86_64-pc-windows-gnullvm --target x86_64-pc-windows-gnullvm\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Byte Constant Syntax Error in Rust\nDESCRIPTION: This code snippet shows an incorrect way of declaring a byte constant in Rust, resulting in a compilation error (E0763). The byte constant is not properly terminated with a closing single quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0763.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet c = b'a; // error!\n```\n\n----------------------------------------\n\nTITLE: Single Line Functions - True\nDESCRIPTION: Demonstrates the formatting of single-expression functions when `fn_single_line` is `true`. Single expression functions are placed on a single line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() -> usize { 42 }\n\nfn lorem() -> usize {\n    let ipsum = 42;\n    ipsum\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Inherent Implementation on Generic Type\nDESCRIPTION: This code snippet demonstrates the E0118 error. It attempts to define an inherent implementation for a generic type `T`, which is not allowed in Rust because `T` could represent any type, not necessarily a struct, enum, or union. The compiler expects an inherent implementation to be associated with a concrete nominal type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0118.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> T { // error: no nominal type found for inherent implementation\n    fn get_state(&self) -> String {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Source Files\nDESCRIPTION: This CMake command sets the variable `CXX_SOURCES` to a list of C++ source files. These files will be compiled as part of the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CXX_SOURCES\n    src/foo_cxx.cpp\n    )\n```\n\n----------------------------------------\n\nTITLE: Comparing type_alias_impl_trait with Argument-Position impl Trait\nDESCRIPTION: This snippet illustrates the difference between using a type alias with `impl Trait` and using argument-position `impl Trait`. It shows that the type alias refers to a unique type, while argument-position `impl Trait` allows the caller to choose the concrete type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/type-alias-impl-trait.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(type_alias_impl_trait)]\n# #![allow(unused_variables)]\n# pub mod x {\n# pub trait Trait {}\n#\n# struct MyType;\n#\n# impl Trait for MyType {}\n#\n# pub type Alias = impl Trait;\n#\n# #[define_opaque(Alias)]\n# pub fn new() -> Alias {\n#     MyType\n# }\n# }\n# use x::*;\n// this...\npub fn take_alias(x: Alias) {\n    // ...\n}\n\n// ...is *not* the same as\npub fn take_impl(x: impl Trait) {\n    // ...\n}\n# fn main(){}\n```\n\n----------------------------------------\n\nTITLE: Example of Join Lines in Rust\nDESCRIPTION: Demonstrates the Join Lines operation in Rust code, showing how the extension can transform code with nested blocks into a simpler, single-line form by intelligently handling braces and whitespace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    /*cursor here*/let x = {\n        92\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0746 Error with Unboxed Trait Object Return\nDESCRIPTION: This code snippet illustrates the E0746 error by attempting to return an unboxed trait object. It defines a trait T and a struct S that implements T, then tries to return a dyn T from a function, which is not allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0746.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Bootstrap for x86_64-fortanix-unknown-sgx Target\nDESCRIPTION: This TOML configuration snippet sets up the Rust bootstrap to build the x86_64-fortanix-unknown-sgx target. It specifies the build stage and the target to be built.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/x86_64-fortanix-unknown-sgx.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-fortanix-unknown-sgx\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Syntax Tree Structure in Rust\nDESCRIPTION: Demonstrates the conceptual structure of syntax nodes using basic Rust structs. Shows how nodes and tokens are represented with SyntaxKind identifiers and child relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Eq, Clone, Copy)]\nstruct SyntaxKind(u16);\n\n#[derive(PartialEq, Eq, Clone)]\nstruct Node {\n    kind: SyntaxKind,\n    text_len: usize,\n    children: Vec<Arc<Either<Node, Token>>>,\n}\n\n#[derive(PartialEq, Eq, Clone)]\nstruct Token {\n    kind: SyntaxKind,\n    text: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using rustc to disable individual lints\nDESCRIPTION: This command shows how to disable individual lints separately, achieving the same effect as disabling the `nonstandard-style` lint group. It disables `non-camel-case-types`, `non-snake-case`, and `non-upper-case-globals`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/groups.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals\"\n```\n\n----------------------------------------\n\nTITLE: Formatting Type Aliases in Rust\nDESCRIPTION: Guidelines for formatting type aliases in Rust. Includes examples of single-line format and rules for breaking lines with proper indentation when necessary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\npub type Foo = Bar<T>;\n\n// If multi-line is required\ntype VeryLongType<T, U: SomeBound>\n    = AnEvenLongerType<T, U, Foo<T>>;\n```\n\n----------------------------------------\n\nTITLE: Markdown Navigation Structure\nDESCRIPTION: Hierarchical markdown document structure defining the table of contents for the Rustc book, including links to various sections covering compiler features, platform support, and implementation details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/SUMMARY.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# The Rustc Book\n\n- [What is rustc?](what-is-rustc.md)\n- [Command-line Arguments](command-line-arguments.md)\n    - [Print Options](command-line-arguments/print-options.md)\n    - [Codegen Options](codegen-options/index.md)\n[...additional navigation items...]\n```\n\n----------------------------------------\n\nTITLE: Conflicting Packed Attributes - Compile Fail\nDESCRIPTION: This code snippet demonstrates the E0634 error, which occurs when conflicting `packed` attributes are used on the same struct. The compiler will fail to compile this code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0634.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0634\n#[repr(packed, packed(2))] // error!\nstruct Company(i32);\n\n#[repr(packed(2))] // error!\n#[repr(packed)]\nstruct Company(i32);\n```\n```\n\n----------------------------------------\n\nTITLE: Correct usage of instruction_set with arm::a32 in Rust\nDESCRIPTION: This example shows the proper way to apply the instruction_set attribute with arm::a32 parameter for ARM architecture. It uses cfg_attr to conditionally apply the attribute only on ARM targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0778.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(isa_attribute)]\n\n#[cfg_attr(target_arch=\"arm\", instruction_set(arm::a32))]\nfn something() {}\n```\n\n----------------------------------------\n\nTITLE: Console Output Example for Multi-line Suggestions\nDESCRIPTION: Example console output demonstrating how multiple or multi-line suggestions are displayed separately from the main error message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_6\n\nLANGUAGE: console\nCODE:\n```\nerror[E0999]: oh no! this is an error!\n --> mycode.rs:3:5\n  |\n3 |     sad()\n  |     ^\nhelp: try using a qux here:\n  |\n3 |     qux sad()\n  |     ^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0999`.\n```\n\n----------------------------------------\n\nTITLE: Defining Test Execution Parameters in TypeScript\nDESCRIPTION: Describes RunTestParams, used to manage test execution through inclusive and exclusive clauses for filtering test runs in Rust projects. It streamlines executing comprehensive or selective test collections within integrated TypeScript tools and APIs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RunTestParams {\n    include?: string[] | undefined;\n    exclude?: string[] | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Crate Version in Rustdoc Output (Bash)\nDESCRIPTION: This example demonstrates how to use the --crate-version flag to specify a version number that will be displayed in the sidebar of the crate root's documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --crate-version 1.3.37\n```\n\n----------------------------------------\n\nTITLE: Erroneous Implementation on Reference Type in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to implement methods directly on a reference type (&Foo), which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0390.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl &Foo { // error: no nominal type found for inherent implementation\n    fn bar(self, other: Self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Coroutine Control Flow Example in Rust\nDESCRIPTION: Shows control flow through a coroutine with multiple yield points, demonstrating how execution can be suspended and resumed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coroutines.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nuse std::ops::Coroutine;\nuse std::pin::Pin;\n\nfn main() {\n    let mut coroutine = #[coroutine] || {\n        println!(\"2\");\n        yield;\n        println!(\"4\");\n    };\n\n    println!(\"1\");\n    Pin::new(&mut coroutine).resume(());\n    println!(\"3\");\n    Pin::new(&mut coroutine).resume(());\n    println!(\"5\");\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Crate B Definition (b.rs)\nDESCRIPTION: Crate 'b' that depends on the first version of crate 'a'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0460.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"b\"]\n\nextern crate a; // linked with `a1.rs`\n\npub fn foo() {\n    a::foo::<isize>();\n}\n```\n\n----------------------------------------\n\nTITLE: Discarding Impl Candidates in New Rust Trait Solver\nDESCRIPTION: In the new trait solver, if there is at least one ParamEnv or AliasBound candidate to prove a Trait goal, all impl candidates for both Trait and Projection goals are discarded.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/significant-changes.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Source: discard-from-env\nif !env_candidates.is_empty() {\n    candidates.retain(|c| matches!(c, Candidate::ParamEnv(_) | Candidate::AliasBound(_)));\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Standalone Crate Doctest Declaration in Rust\nDESCRIPTION: An example showing how to declare a doctest that checks line information and requires a standalone environment to maintain consistent line numbers. The standalone_crate attribute prevents the doctest from being merged with others.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n//! ```standalone_crate\n//! let location = std::panic::Location::caller();\n//! assert_eq!(location.line(), 4);\n//! ```\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer for Helix with Bash\nDESCRIPTION: This snippet contains the command for copying the rust-analyzer configuration for Helix and describes the requirement for managing the custom toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nCopy [`etc/rust_analyzer_helix.toml`] to `.helix/languages.toml` in the project root directory.\n```\n\nLANGUAGE: sh\nCODE:\n```\nrun `./miri toolchain -c rust-analyzer`\n```\n\n----------------------------------------\n\nTITLE: Allowing and Denying Rustdoc Lints in Rust\nDESCRIPTION: This snippet demonstrates how to enable, warn, or deny the `broken_intra_doc_links` lint using the `#![allow]`, `#![warn]`, and `#![deny]` attributes in a Rust file. It requires the `rustdoc` tool to process these lints, as they are not available through `rustc`. The toggles govern whether missing intra-doc links in the documentation will be reported as warnings or errors, or not reported at all. This helps maintain link validity in documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(rustdoc::broken_intra_doc_links)] // allows the lint, no diagnostics will be reported\n#![warn(rustdoc::broken_intra_doc_links)] // warn if there are broken intra-doc links\n#![deny(rustdoc::broken_intra_doc_links)] // error if there are broken intra-doc links\n\n```\n\n----------------------------------------\n\nTITLE: Default Inline Attribute Width in Rust\nDESCRIPTION: Shows how attributes are displayed with the default inline_attribute_width of 0, which keeps attributes on separate lines from their items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"alloc\")]\nuse core::slice;\n```\n\n----------------------------------------\n\nTITLE: Empty Item Single Line - True Example\nDESCRIPTION: Example showing how rustfmt handles empty functions and impls when `empty_item_single_line` is set to `true`. With this option enabled, empty functions and impls are formatted on a single line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {}\n\nimpl Lorem {}\n```\n\n----------------------------------------\n\nTITLE: Using the Rust logo as the crate logo\nDESCRIPTION: This Rust snippet demonstrates how to use the `#[doc(rust_logo)]` attribute to set the crate logo to the Rust logo. This attribute is intended for use by official Rust projects. It requires the `rustdoc_internals` feature and `internal_features` to be allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(rustdoc_internals)]\n#![allow(internal_features)]\n#![doc(rust_logo)]\n//! This crate has the Rust(tm) branding on it.\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Fuchsia Component Manifest\nDESCRIPTION: CML file defining the component structure for the Fuchsia package.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_11\n\nLANGUAGE: txt\nCODE:\n```\n{\n    include: [ \"syslog/client.shard.cml\" ],\n    program: {\n        runner: \"elf\",\n        binary: \"bin/hello_fuchsia\",\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Non-exhaustive Structs in Rust\nDESCRIPTION: This snippet shows an example of a non-exhaustive struct in Rust, meaning it cannot be instantiated outside its defining crate. The struct and its fields are public, but it is meant to be extended in the future, potentially introducing changes that could break existing code. As a workaround, developers should search for a constructor function, often named 'new', within the crate's documentation. This pattern enforces encapsulation and allows for safe evolution of the struct's structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0639.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[non_exhaustive]\npub struct NormalStruct {\n    pub first_field: u16,\n    pub second_field: u16,\n}\n\nlet ns = NormalStruct { first_field: 640, second_field: 480 }; // error!\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for LynxOS-178 Cross-Compilation\nDESCRIPTION: This snippet configures Cargo to use a specific linker for the host when building procedural macros for programs targeting the LynxOS-178 platform. The configuration involves modifying the .cargo/config.toml file to specify the host GCC as the linker.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/lynxos178.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[target.x86_64-unknown-linux-gnu]\nlinker = \"lynx-host-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Resetting Git Submodules Hard to Resolve Update Errors - bash\nDESCRIPTION: This bash snippet provides a solution for resolving git submodule update errors related to modified or new commits inside submodules, such as failed fetches or detached HEAD state. Running `git submodule foreach git reset --hard` traverses all submodules and performs a hard reset to discard any local changes, restoring the submodules to their pinned commits, and enabling a subsequent successful update.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n$ git submodule foreach git reset --hard\n```\n\n----------------------------------------\n\nTITLE: Error When Implementing Drop Trait in Const Context in Rust\nDESCRIPTION: This Rust snippet demonstrates an error where a structure with a type implementing the Drop trait cannot initialize a static variable due to const-eval restrictions. The enum DropType, with a custom Drop implementation, is used within a struct Foo, and an error is shown when trying to initialize a static variable with a dropped value in a const context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0493.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum DropType {\n    A,\n}\n\nimpl Drop for DropType {\n    fn drop(&mut self) {}\n}\n\nstruct Foo {\n    field1: DropType,\n}\n\nstatic FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!\n```\n\n----------------------------------------\n\nTITLE: Inferred Function Signature with Lifetime Parameter in Rust\nDESCRIPTION: Demonstrates how the compiler infers the get_is_cool function signature with explicit lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0772.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn get_is_cool<'p, R: BooleanLike>(person: &'p (dyn Person + 'p)) -> R {\n    unimplemented!()\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Inline Attribute Hint\nDESCRIPTION: Shows the minimal inline attribute usage, which provides a hint to the compiler about potential inlining without specifying a specific behavior\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0534.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[inline]\nfn something() {}\n```\n\n----------------------------------------\n\nTITLE: Feature Documentation\nDESCRIPTION: Markdown documentation for the asm_unwind feature, referencing tracking issue #93334. The feature enables assembly blocks to unwind the stack through the may_unwind option in the asm! macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-unwind.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `asm_unwind`\n\nThe tracking issue for this feature is: [#93334]\n\n[#93334]: https://github.com/rust-lang/rust/issues/93334\n```\n\n----------------------------------------\n\nTITLE: Including Markdown CSS Files\nDESCRIPTION: This code snippet demonstrates how to use the `--markdown-css` flag to include additional CSS files when rendering Markdown files with rustdoc.  This enables custom styling of Markdown-based documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc README.md --markdown-css foo.css\n```\n\n----------------------------------------\n\nTITLE: Using Custom Test Builder with Rustdoc\nDESCRIPTION: This snippet shows how to use the --test-builder flag to specify a custom rustc-like program for building tests instead of the default compiler from the sysroot.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc --test-builder /path/to/rustc src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Displaying Rustdoc Help\nDESCRIPTION: This code snippet shows how to use the `-h` or `--help` flag to display rustdoc's built-in help, which lists available command-line flags. This is helpful for understanding the options available for generating documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc -h\n$ rustdoc --help\n```\n\n----------------------------------------\n\nTITLE: Generic Struct with Placeholder Example\nDESCRIPTION: Example Rust code showing a generic struct with type and const parameters, and a static variable that uses placeholder values for the generic parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\npub struct Example<T, const N: usize>([T; N]);\n\nimpl<T, const N: usize> Example<T, N> {\n    pub fn foo() -> &'static () {\n        static EXAMPLE_STATIC: () = ();\n        &EXAMPLE_STATIC\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Declaration of simd_shuffle Function in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect way of declaring the `simd_shuffle` platform-intrinsic function, which previously resulted in a compiler error. The error occurred because the length of the shuffle wasn't specified in the function name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0439.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(platform_intrinsics)]\n\nextern \"platform-intrinsic\" {\n    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Missing Trailing Quote in Raw Byte String\nDESCRIPTION: This error message indicates that a raw byte string literal is missing its closing delimiter. The literal begins with `br##\"` but lacks a corresponding `\"##` to terminate the string. The number of `#` symbols must match between the opening and closing delimiters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"BYTE_STRING \\\"br##\\\\\\\"\\\" error: Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Handling Doctest Injections in Rust\nDESCRIPTION: The #[doc(test(no_crate_inject))] attribute is demonstrated here to prevent the automatic injection of the crate in doctests, providing more control over the test environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(test(no_crate_inject))]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Basic Default Field Values Usage in Rust Structs\nDESCRIPTION: Demonstrates basic usage of default field values in a struct definition with derive(Default) implementation. Shows how fields can be omitted during initialization and how default values are used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/default-field-values.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(default_field_values)]\n\n#[derive(Default)]\nstruct Pet {\n    name: Option<String>, // impl Default for Pet will use Default::default() for name\n    age: i128 = 42, // impl Default for Pet will use the literal 42 for age\n}\n\nfn main() {\n    let a = Pet { name: Some(String::new()), .. }; // Pet { name: Some(\"\"), age: 42 }\n    let b = Pet::default(); // Pet { name: None, age: 42 }\n    assert_eq!(a.age, b.age);\n    // The following would be a compilation error: `name` needs to be specified\n    // let _ = Pet { .. };\n}\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Struct Literals in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for struct literals. Fields are aligned as a block with consistent indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = Lorem {\n        ipsum: dolor,\n        sit: amet,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Comments to Documentation in Rust\nDESCRIPTION: This assist converts regular comments to documentation comments. It changes the comment style to create module or item documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n// Wow what a nice module\n// I sure hope this shows up when I hover over it\n```\n\nLANGUAGE: rust\nCODE:\n```\n//! Wow what a nice module\n//! I sure hope this shows up when I hover over it\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Public Visibility in Private Rust Enum\nDESCRIPTION: This code snippet demonstrates another incorrect usage of the `pub` keyword inside a private enum, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0448.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    pub Bar, // not ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling with coverage using a specific rustc path\nDESCRIPTION: Example command for compiling a Cargo example with coverage instrumentation, specifying a custom path to the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n    RUSTFLAGS=\"-C instrument-coverage\" \\\n    cargo build --example formatjson5\n```\n\n----------------------------------------\n\nTITLE: Building Rust toolchain for QNX with environment variables\nDESCRIPTION: This bash snippet shows how to build the Rust toolchain for a QNX target using environment variables to specify the correct tools and compiler flags. It defines the `CC`, `CFLAGS`, `CXX`, and `AR` variables for the target architecture, and then executes the `x.py build` script with the specified targets, which includes the standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n```bash\nexport build_env='\\\n    CC_aarch64_unknown_nto_qnx710=qcc \\\n    CFLAGS_aarch64_unknown_nto_qnx710=-Vgcc_ntoaarch64le_cxx \\\n    CXX_aarch64_unknown_nto_qnx710=qcc \\\n    AR_aarch64_unknown_nto_qnx710=ntoaarch64-ar \\\n    '\n\nenv $build_env \\\n    ./x.py build \\\n        --target x86_64-unknown-linux-gnu,aarch64-unknown-nto-qnx710 \\\n        rustc library/core library/alloc library/std\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-Exhaustive Enum in Rust\nDESCRIPTION: This code snippet demonstrates the definition of a non-exhaustive enum named `Error`. The `#[non_exhaustive]` attribute marks the enum as non-exhaustive, requiring downstream crates to handle potential future variants. The `Display` trait implementation shows exhaustively matching within the defining crate, while the example below demonstrates non-exhaustive matching in downstream crates. Dependencies include `std::fmt` and the `String` type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0638.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```rust,ignore (pseudo-Rust)\n#[non_exhaustive]\npub enum Error {\n    Message(String),\n    Other,\n}\n\nimpl Display for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        // This will not error, despite being marked as non_exhaustive, as this\n        // enum is defined within the current crate, it can be matched\n        // exhaustively.\n        let display = match self {\n            Message(s) => s,\n            Other => \"other or unknown error\",\n        };\n        formatter.write_str(display)\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Aligning Struct Fields in Rust\nDESCRIPTION: Demonstrates the 'struct_field_align_threshold' option. When set to 0 (default), no alignment is applied. When set to a non-zero value (e.g., 20), fields are aligned if their width difference is within the threshold.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_68\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: u32,\n    yy: u32,\n    zzz: u32,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x:   u32,\n    yy:  u32,\n    zzz: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Changing Integer Literal Base in Rust\nDESCRIPTION: Converts an integer literal from decimal to binary format. This example requires knowledge of Rust's constant definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nconst _: i32 = 0b1010;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Const Parameter Dependency on Type Parameter in Rust\nDESCRIPTION: This code snippet shows an example of invalid Rust code where a const parameter 'N' depends on a type parameter 'T'. This would have previously resulted in compiler error E0770, but this error is no longer emitted by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0671.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn const_id<T, const N: T>() -> T { // error\n    N\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Match Expression with Inner Attributes\nDESCRIPTION: Shows correct indentation of inner attributes in match expressions when using version=Two.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub fn main() {\n    match x {\n        #![attr1]\n        #![attr2]\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arc for Reference Counting in Rust Threads\nDESCRIPTION: This snippet utilizes Arc to safely share ownership of a variable across threads, giving it a 'static' lifetime and allowing concurrent access without ownership violations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0504.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `'static` lifetime\n        println!(\"child thread: {}\", fancy_ref1.num);\n    });\n\n    x.join().expect(\"child thread should finish\");\n    println!(\"main thread: {}\", fancy_ref2.num);\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced MIR Filtering with Multiple Conditions\nDESCRIPTION: Demonstrates complex MIR filtering using `&` and `|` operators to select specific functions and compilation passes for detailed debugging and analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustc -Z dump-mir='main & CleanEndRegions | main & NoLandingPads' foo.rs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Macro Import Error in Rust\nDESCRIPTION: This code snippet shows an erroneous attempt to import macros 'drink' and 'be_merry' from the 'alloc' crate, which will result in an E0469 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0469.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use(drink, be_merry)] // error: imported macro not found\nextern crate alloc;\n\nfn main() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Auto Trait with Super Trait in Rust\nDESCRIPTION: This snippet defines an auto trait 'Bound' that incorrectly attempts to include a super trait 'Copy'. This leads to a compilation error since very few existing types could implement 'Bound' if it requires 'Copy'. The code demonstrates the failure mode and highlights the limitation in Rust's trait system when super traits are used with auto traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0568.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(auto_traits)]\n\nauto trait Bound : Copy {} // error!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Running GCC JIT Test for Function Attributes\nDESCRIPTION: Command to run a specific GCC JIT test for function attributes in your gcc-build folder. This example shows how to test the 'nonnull' attribute implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/add-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=jit.dg/test-nonnull.c\"\n```\n\n----------------------------------------\n\nTITLE: Example Linker Error for Missing LLVM Libraries\nDESCRIPTION: An example of the linking error that may occur when the llvm-tools component is not installed or LLVM libraries are not properly configured in the library search paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/rustc-private.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note: rust-lld: error: unable to find library -lLLVM-{version}\n```\n\n----------------------------------------\n\nTITLE: Formatting Zulip Stream Link in Markdown\nDESCRIPTION: This snippet demonstrates how to create a Markdown link to the ARM-specific Zulip stream. It uses a reference-style link format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/arm.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[`#t-compiler/arm`]: https://rust-lang.zulipchat.com/#narrow/stream/242906-t-compiler.2Farm\n```\n\n----------------------------------------\n\nTITLE: Defining Remote for Clippy Repository - Bash\nDESCRIPTION: This command adds a remote named `upstream` pointing to the rust-clippy GitHub repository. This simplifies future commands by allowing the use of `upstream` instead of the full URL.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream git@github.com:rust-lang/rust-clippy\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Coroutine Projection with AsyncFn\nDESCRIPTION: This Rust code snippet illustrates the delay in projecting the call of an AsyncFn trait to a coroutine, highlighting an issue where the returned async closure type remains unconstrained without proper inference. The alias used in Rust helps delay the computation of tupled upvars while still allowing rigid type return and confirms built-in traits such as Future.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet c = async || -> String { .. };\nlet s = c().await;\n// ^^^ If we can't project `<{c} as AsyncFn>::call()` to a coroutine, then the `IntoFuture::into_future` call inside of the `.await` stalls, and the type of `s` is left unconstrained as an infer var.\ns.as_bytes();\n// ^^^ That means we can't call any methods on the awaited return of a coroutine-closure, like... at all!\n```\n\n----------------------------------------\n\nTITLE: Version Configuration Example in TOML\nDESCRIPTION: Shows how to configure the deprecated version option in TOML format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_80\n\nLANGUAGE: toml\nCODE:\n```\nversion = \"Two\"\n```\n\n----------------------------------------\n\nTITLE: Correctly Returning Owned Data Instead of References in Rust\nDESCRIPTION: This code snippet demonstrates returning owned values instead of references from a function to ensure memory safety. By taking ownership of the data, the function can return the value directly, avoiding errors related to dangling references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0515.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::vec::IntoIter;\n\nfn get_integer() -> i32 {\n    let x = 0;\n    x\n}\n\nfn get_owned_iterator() -> IntoIter<i32> {\n    let v = vec![1, 2, 3];\n    v.into_iter()\n}\n```\n\n----------------------------------------\n\nTITLE: Example Output of 'x build --dry-run' Command in Rust Compiler Build Process\nDESCRIPTION: Sample output showing the stages of the Rust compiler build process when running the 'x build --dry-run' command. It illustrates the sequence of building and copying artifacts for stage0 and stage1, including library components, compiler artifacts, and tools like rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/what-bootstrapping-does.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nBuilding stage0 library artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\nCopying stage0 library from stage0 (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\nBuilding stage0 compiler artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\nCopying stage0 rustc from stage0 (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\nAssembling stage1 compiler (x86_64-unknown-linux-gnu)\nBuilding stage1 library artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\nCopying stage1 library from stage1 (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\nBuilding stage1 tool rust-analyzer-proc-macro-srv (x86_64-unknown-linux-gnu)\nBuilding rustdoc for stage1 (x86_64-unknown-linux-gnu)\n```\n\n----------------------------------------\n\nTITLE: Tokenizing Integer, Dot, and Non-Numeric Exponent Parts in Rust Lexer\nDESCRIPTION: Shows how the Rust lexer tokenizes sequences like `integer.e+` or `integer.E-` when they don't form a valid floating-point literal. Instead of a single number token, it produces separate tokens for the integer (`INT_NUMBER`), dot (`DOT`), identifier (`IDENT` for 'e'/'E'), and operator (`PLUS`/`MINUS`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_exponent.txt#_snippet_2\n\nLANGUAGE: Lexer Output Block\nCODE:\n```\nINT_NUMBER \"42\"\nDOT \".\"\nIDENT \"e\"\nPLUS \"+\"\n```\n\nLANGUAGE: Lexer Output Block\nCODE:\n```\nINT_NUMBER \"42\"\nDOT \".\"\nIDENT \"e\"\nMINUS \"-\"\n```\n\nLANGUAGE: Lexer Output Block\nCODE:\n```\nINT_NUMBER \"42\"\nDOT \".\"\nIDENT \"E\"\nPLUS \"+\"\n```\n\nLANGUAGE: Lexer Output Block\nCODE:\n```\nINT_NUMBER \"42\"\nDOT \".\"\nIDENT \"E\"\nMINUS \"-\"\n```\n\n----------------------------------------\n\nTITLE: Fix: Iterate using Indices\nDESCRIPTION: This code fixes the iteration example by iterating using indices. This avoids borrowing the entire vector, resolving E0626. The code uses temporaries that are currently required (see issue 43122).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] || {\n  let v = vec![1,2,3];\n  let len = v.len(); // (*)\n  for i in 0..len {\n    let x = v[i]; // (*)\n    yield x; // <-- Now yield is OK.\n  }\n};\nPin::new(&mut b).resume(());\n\n// (*) -- Unfortunately, these temporaries are currently required.\n// See <https://github.com/rust-lang/rust/issues/43122>.\n```\n\n----------------------------------------\n\nTITLE: Completion Request Handler (Rust)\nDESCRIPTION: This function handles completion requests by deserializing LSP requests into rust-analyzer specific data types, requesting completions from the analysis engine, and serializing results back to LSP format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/handlers/request.rs#L850-L876\n```\n\n----------------------------------------\n\nTITLE: Output of Filtered Error Messages for Different Types\nDESCRIPTION: Shows how the filtered error messages appear when applied to different types, demonstrating how the 'on' condition causes different notes to be displayed for &str versus other types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_20\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: `Foo` is not an iterator\n --> src/main.rs:4:16\n  |\n4 |     for foo in Foo {}\n  |                ^^^ `Foo` is not an iterator\n  |\n  = note: maybe try calling `.iter()` or a similar method\n  = help: the trait `std::iter::Iterator` is not implemented for `Foo`\n  = note: required by `std::iter::IntoIterator::into_iter`\n\nerror[E0277]: `&str` is not an iterator\n --> src/main.rs:5:16\n  |\n5 |     for foo in \"\" {}\n  |                ^^ `&str` is not an iterator\n  |\n  = note: call `.chars()` or `.bytes() on `&str`\n  = help: the trait `std::iter::Iterator` is not implemented for `&str`\n  = note: required by `std::iter::IntoIterator::into_iter`\n```\n\n----------------------------------------\n\nTITLE: Beta Backport PR Template\nDESCRIPTION: Template for creating a backport pull request description in the Rust repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/backport.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n[beta] Clippy backports\n\nr? @Mark-Simulacrum\n\nBackports:\n- <Link to the Clippy PR>\n- ...\n\n<Short summary of what is backported and why>\n```\n\n----------------------------------------\n\nTITLE: Gating Formatting Changes with style_edition\nDESCRIPTION: This code snippet shows how to conditionally apply formatting changes based on the `style_edition` configuration setting, ensuring backwards compatibility and adhering to the Style Edition process in Rustfmt.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// if the current stable Style Edition is Edition 2024\nif config.style_edition() <= StyleEdition::Edition2024 {\n    // current formatting\n} else {\n    // new formatting\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0719 Error in Rust\nDESCRIPTION: This code snippet shows an erroneous example where the associated type 'Item' in trait 'Iterator' is specified twice for struct 'Foo', leading to a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0719.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait FooTrait {}\ntrait BarTrait {}\n\n// error: associated type `Item` in trait `Iterator` is specified twice\nstruct Foo<T: Iterator<Item: FooTrait, Item: BarTrait>> { f: T }\n```\n\n----------------------------------------\n\nTITLE: Using a Modified Standard Library\nDESCRIPTION: This snippet sets the MIRI_LIB_SRC environment variable so that Miri can use a custom standard library for testing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nexport MIRI_LIB_SRC=<path_to_library>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Label Usage in Rust Loop\nDESCRIPTION: Example showing incorrect usage of an undeclared label that results in compile error E0426. The code attempts to break to a label 'a' that hasn't been declared.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0426.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    break 'a; // error: use of undeclared label `'a`\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Code with Multiple Relaxed Default Bounds\nDESCRIPTION: This code demonstrates the incorrect use of multiple relaxed bounds (?Sized and ?Send) on a generic type parameter, which triggers compiler error E0203. Multiple relaxed default bounds on a single type parameter are not supported in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0203.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bad<T: ?Sized + ?Send>{\n    inner: T\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function with Config Attributes in Rust\nDESCRIPTION: Defines the main function with a cfg attribute specifying configuration options 'a' and 'b', prefixed with line numbers '10 5 2'\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/tests/writemode/target/modified.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(a, b)]\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Example Macro Expansion\nDESCRIPTION: Shows an example of code that expands to '1 + 0' in both EarlyLintPass and LateLintPass stages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// The following code expands to `1 + 0` for both `EarlyLintPass` and `LateLintPass`\n1 + mac!()\n```\n\n----------------------------------------\n\nTITLE: Annotating Types with significant_drop Attribute in Rust\nDESCRIPTION: The `#[clippy::has_significant_drop]` attribute is used to mark types whose `Drop` implementations have important side effects, such as unlocking a mutex. This helps users understand the lifetimes of these types accurately, especially when dealing with temporary values in match scrutinees. The attribute signals to Clippy that the drop implementation has a notable impact and should be carefully considered.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/attribs.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[clippy::has_significant_drop]\nstruct CounterWrapper<'a> {\n    counter: &'a Counter,\n}\n\nimpl<'a> Drop for CounterWrapper<'a> {\n    fn drop(&mut self) {\n        self.counter.i.fetch_sub(1, Ordering::Relaxed);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Fuchsia Component Manifest\nDESCRIPTION: Command to compile the CML file into a component manifest.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/cmc compile \\\n    pkg/hello_fuchsia.cml \\\n    --includepath ${SDK_PATH}/pkg \\\n    -o pkg/meta/hello_fuchsia.cm\n```\n\n----------------------------------------\n\nTITLE: Converting While to Loop in Rust\nDESCRIPTION: Refactors a while loop into a loop with a break condition for improved flexibility and readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        if !cond {\n            break;\n        }\n        foo();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Re-Exporting Items with Additional Documentation\nDESCRIPTION: This snippet explains how to re-export a function and add additional documentation, ensuring that links resolve correctly even when items are re-exported from different modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n/// See also [foo()]\npub use std::process::Command;\n\npub fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0322 Error: Explicit Implementation of Sized Trait in Rust\nDESCRIPTION: This code snippet demonstrates the E0322 error that occurs when attempting to explicitly implement the Sized trait for a struct. The Sized trait is automatically implemented by the compiler and cannot be manually implemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0322.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Sized for Foo {} // error!\n```\n\n----------------------------------------\n\nTITLE: Main Program Using External Crate\nDESCRIPTION: Example of a main program attempting to use the library crate defined in a.rs\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0461.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate a;\n\nfn main() {\n    a::foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Inline Never Attribute Usage\nDESCRIPTION: Demonstrates using the inline attribute with the 'never' parameter, which prevents the compiler from inlining the function\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0534.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[inline(never)]\nfn something() {}\n```\n\n----------------------------------------\n\nTITLE: Creating a Free-Standing Rust Crate with no_std Attribute\nDESCRIPTION: This snippet shows how to build a free-standing crate by adding the #![no_std] attribute, which is necessary when implementing lang items outside the standard library, such as for kernel development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0152.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n```\n\n----------------------------------------\n\nTITLE: Instrumenting a function for debugging with tracing in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `#[instrument]` attribute from the `tracing` crate to automatically generate log messages for function calls, including arguments and return values.  The `level` specifies the logging level, and `skip` allows excluding specific arguments from being logged.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\n#[instrument(level = \"debug\", skip(self))]\nfn foo(&self, bar: Type) {}\n\n```\n\n----------------------------------------\n\nTITLE: Attempting to Link Static Library in Rust\nDESCRIPTION: Example of a Rust main file attempting to link with the static library, which will result in a linking error due to incompatible crate types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0462.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate a;\n\nfn main() {\n    a::foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Error Example: Undefined Associated Types in Rust Traits\nDESCRIPTION: Example showing compilation errors when trying to use undefined associated types in traits. This demonstrates two common mistakes: referencing a non-existent associated type in a type alias and using an undeclared associated type in a trait method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0220.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Alias Impl Trait with Linked Generic Parameters in Rust\nDESCRIPTION: Example showing how to link the generic parameter to the hidden type in type_alias_impl_trait. This implementation uses the generic parameter U in the returned vector, creating a relationship between the generic parameter and the hidden type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0792.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(type_alias_impl_trait)]\n\nuse std::fmt::Debug;\n\ntype Foo<T: Debug> = impl Debug;\n\n#[define_opaque(Foo)]\nfn foo<U: Debug>() -> Foo<U> {\n    Vec::<U>::new()\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring array-size-threshold\nDESCRIPTION: Sets the maximum allowed size for arrays on the stack. This setting helps to control potential stack overflows by limiting the size of arrays.  The default value is 16384.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Trait Implementation with Track Caller in Rust\nDESCRIPTION: Comprehensive example showing various ways to use #[track_caller] with traits, including blanket implementations and overrides.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/implicit-caller-location.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(track_caller)]\n\nmacro_rules! assert_tracked {\n    () => {{\n        let location = std::panic::Location::caller();\n        assert_eq!(location.file(), file!());\n        assert_ne!(location.line(), line!(), \"line should be outside this fn\");\n        println!(\"called at {}\", location);\n    }};\n}\n\ntrait TrackedFourWays {\n    /// All implementations inherit `#[track_caller]`.\n    #[track_caller]\n    fn blanket_tracked();\n\n    /// Implementors can annotate themselves.\n    fn local_tracked();\n\n    /// This implementation is tracked (overrides are too).\n    #[track_caller]\n    fn default_tracked() {\n        assert_tracked!();\n    }\n\n    /// Overrides of this implementation are tracked (it is too).\n    #[track_caller]\n    fn default_tracked_to_override() {\n        assert_tracked!();\n    }\n}\n\n/// This impl uses the default impl for `default_tracked` and provides its own for\n/// `default_tracked_to_override`.\nimpl TrackedFourWays for () {\n    fn blanket_tracked() {\n        assert_tracked!();\n    }\n\n    #[track_caller]\n    fn local_tracked() {\n        assert_tracked!();\n    }\n\n    fn default_tracked_to_override() {\n        assert_tracked!();\n    }\n}\n\nfn main() {\n    <() as TrackedFourWays>::blanket_tracked();\n    <() as TrackedFourWays>::default_tracked();\n    <() as TrackedFourWays>::default_tracked_to_override();\n    <() as TrackedFourWays>::local_tracked();\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Fail Example: Moving Out of Borrowed Content in Rust\nDESCRIPTION: This code snippet demonstrates a common scenario that triggers the E0507 error in Rust: attempting to move a value out of borrowed content. Specifically, it tries to call a method that takes ownership of `self` on a value obtained via `RefCell::borrow()`, which only provides a borrow. This fails because the method attempts to move `self`, which is not allowed with a borrowed value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Windows Error Code Constants List\nDESCRIPTION: A list of Windows system error codes that represent various error conditions and states in the Windows operating system. These constants are commonly used in system programming and error handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/windows/c/bindings.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nERROR_BAD_VALIDATION_CLASS\nERROR_BADDB\nERROR_BADKEY\nERROR_BADSTARTPOSITION\nERROR_BEGINNING_OF_MEDIA\nERROR_BEYOND_VDL\nERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT\nERROR_BLOCK_SHARED\nERROR_BLOCK_SOURCE_WEAK_REFERENCE_INVALID\nERROR_BLOCK_TARGET_WEAK_REFERENCE_INVALID\nERROR_BLOCK_TOO_MANY_REFERENCES\nERROR_BLOCK_WEAK_REFERENCE_INVALID\nERROR_BLOCKED_BY_PARENTAL_CONTROLS\nERROR_BOOT_ALREADY_ACCEPTED\nERROR_BROKEN_PIPE\nERROR_BUFFER_ALL_ZEROS\nERROR_BUFFER_OVERFLOW\nERROR_BUS_RESET\nERROR_BUSY\nERROR_BUSY_DRIVE\n```\n\n----------------------------------------\n\nTITLE: Function Type Example\nDESCRIPTION: Example showing the difference between HIR and ty::Ty type representations\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(x: u32) -> u32 { x }\n```\n\n----------------------------------------\n\nTITLE: Setting Static Root Path in Rustdoc (Bash)\nDESCRIPTION: This command demonstrates how to use the --static-root-path flag in Rustdoc to control how static files are loaded in HTML output. It's useful for caching static files when hosting multiple crates' docs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --static-root-path '/cache/'\n```\n\n----------------------------------------\n\nTITLE: Debugging GCC LTO Using Command Line Options\nDESCRIPTION: A technique for debugging GCC LTO by running the command with verbose flags and saving temporary files. This allows extracting the lto1 process command for running under a debugger.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-v -save-temps\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of if let with Irrefutable Pattern in Rust\nDESCRIPTION: This example demonstrates the incorrect use of `if let` with an irrefutable pattern. The pattern `Irrefutable(x)` will always match the value `irr`, making the condition redundant, which is why the compiler would flag this as an error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0162.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\n// This fails to compile because the match is irrefutable.\nif let Irrefutable(x) = irr {\n    // This body will always be executed.\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using as-needed Link Modifier in Rust\nDESCRIPTION: Demonstrates the usage of as-needed modifier for library linking. Compatible only with dynamic and framework linking kinds. Translates to --as-needed for ld-like linkers and -dead_strip_dylibs/-needed_library/-needed_framework for ld64.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/native-link-modifiers-as-needed.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(native_link_modifiers_as_needed)]\n```\n\n----------------------------------------\n\nTITLE: Checking Read-only Relocations in ELF Binary\nDESCRIPTION: This command uses readelf to check if read-only relocations (RELRO) are enabled in a compiled Rust binary by looking for the GNU_RELRO segment in the program header table.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -l target/release/hello-rust | grep GNU_RELRO\n  GNU_RELRO      0x000000000002ee00 0x000000000002fe00 0x000000000002fe00\n```\n\n----------------------------------------\n\nTITLE: Syntax Tree and View Requests in TypeScript\nDESCRIPTION: Defines TypeScript interfaces for requesting syntax tree representations and views for debugging Rust Analyzer\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SyntaxTreeParams {\n    textDocument: TextDocumentIdentifier,\n    range?: Range,\n}\n\ninterface ViewSyntaxTreeParams {\n    textDocument: TextDocumentIdentifier,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Raw String Literals in Rust with Proper Delimiters\nDESCRIPTION: Demonstrates how to correctly use raw string literals in Rust, which require matching pairs of `#` symbols to delineate the string boundaries. The snippet emphasizes the importance of including a trailing `\"#` sequence to terminate the literal properly, avoiding syntax errors. No additional dependencies are needed other than the Rust compiler. The key input is a raw string delimited by `r##\"` and a closing `\"##` sequence, with the error occurring when the closing delimiter is missing or incomplete.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_with_slash.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nr##\"\\\n```\n\n----------------------------------------\n\nTITLE: Specifying Alternative C Compiler for Target\nDESCRIPTION: This TOML configuration sets `arm-none-eabi-gcc` as the C compiler for the `aarch64-kmc-solid_asp3` target within `bootstrap.toml`. This is useful when using the GNU Arm Embedded Toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/kmc-solid.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.aarch64-kmc-solid_asp3]\ncc = \"arm-none-eabi-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Updating Submodules Automatically with x\nDESCRIPTION: Executes the project's build script with the help flag. This command is mentioned as a method to automatically update local submodules referenced by the rust-lang/rust project, resolving the 'modified' status shown by `git status`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./x --help\n```\n\n----------------------------------------\n\nTITLE: Setting Up Nix Development Environment\nDESCRIPTION: Commands to configure direnv for Nix development environment using either flake or nix-shell.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nln -s ./src/tools/nix-dev-shell/envrc-flake ./.envrc # Use flake\n```\n\n----------------------------------------\n\nTITLE: Handling list-like expressions in Rust formatting\nDESCRIPTION: This snippet describes the generic processing of list syntax elements such as argument lists, field lists, and array elements in Rust code. It discusses spacing, indentation, comment placement, and separator management using functions like `write_list` and structures like `ListFormatting`. Usually, `itemize_list` prepares the input data for formatting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nMuch of the syntax in Rust is lists: lists of arguments, lists of fields, lists of array elements, etc. We have some generic code to handle lists, including how to space them in horizontal and vertical space, indentation, comments between items, trailing separators, etc. However, since there are so many options, the code is a bit complex. Look in [src/lists.rs](src/lists.rs). `write_list` is the key function, and `ListFormatting` the key structure for configuration. You'll need to make a `ListItems` for input, this is usually done using `itemize_list`.\n```\n\n----------------------------------------\n\nTITLE: Defining Goals and Clauses Meta Structure\nDESCRIPTION: This snippet defines the meta-structure of Goals and Clauses in Rust's solver, including DomainGoal, logical operators (AND, OR), quantifiers (exists, forall), implication, and boolean values (true, ambiguous). It describes the recursive relationship between Goals and Clauses and how they are used in the trait solving process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"Goal = DomainGoal           // defined in the section below\n        | Goal && Goal\n        | Goal || Goal\n        | exists<K> { Goal }   // existential quantification\n        | forall<K> { Goal }   // universal quantification\n        | if (Clause) { Goal } // implication\n        | true                 // something that's trivially true\n        | ambiguous            // something that's never provable\n\nClause = DomainGoal\n        | Clause :- Goal     // if can prove Goal, then Clause is true\n        | Clause && Clause\n        | forall<K> { Clause }\n\nK = <type>     // a \\\"kind\\\"\n    | <lifetime>\"\n```\n\n----------------------------------------\n\nTITLE: Handling Compile Failures due to Dangling Iterators in Rust\nDESCRIPTION: This snippet demonstrates the error of returning an iterator over a vector that is local to the function. Once the function scope ends, the vector is dropped, leaving the iterator pointing to invalid memory. The Rust compiler prevents this unsafe behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0515.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::slice::Iter;\nfn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n    let v = vec![1, 2, 3];\n    v.iter()\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Return Type in Result in Rust Functions\nDESCRIPTION: Wraps a function's return type in a Result and updates the returned value to be wrapped in Ok. Useful when adding error handling to a function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_119\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 42i32 }\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n```\n\n----------------------------------------\n\nTITLE: Handling Trailing Commas in Rust Lists\nDESCRIPTION: Shows different options for the 'trailing_comma' setting. 'Vertical' (default) adds commas only in vertical lists, 'Always' adds commas to all lists, and 'Never' removes all trailing commas.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_71\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Lorem { ipsum, dolor, sit } = amet;\n    let Lorem {\n        ipsum,\n        dolor,\n        sit,\n        amet,\n        consectetur,\n        adipiscing,\n    } = elit;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Lorem { ipsum, dolor, sit, } = amet;\n    let Lorem {\n        ipsum,\n        dolor,\n        sit,\n        amet,\n        consectetur,\n        adipiscing,\n    } = elit;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let Lorem { ipsum, dolor, sit } = amet;\n    let Lorem {\n        ipsum,\n        dolor,\n        sit,\n        amet,\n        consectetur,\n        adipiscing\n    } = elit;\n}\n```\n\n----------------------------------------\n\nTITLE: Version-Specific UI Test Cases for MSRV-Dependent Lints - Rust\nDESCRIPTION: Illustrates how to write UI tests for MSRV-dependent lints by using the #[clippy::msrv = 'version'] attribute on test functions. Each function should trigger the lint if the applicable version requirements are met. This setup is needed for verifying correct lint gating in Clippy's test suite. Place the tests in the lint-specific file under tests/ui. No dependencies beyond standard Clippy testing conventions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[clippy::msrv = \"1.44\"]\nfn msrv_1_44() {\n    /* something that would trigger the lint */\n}\n\n#[clippy::msrv = \"1.45\"]\nfn msrv_1_45() {\n    /* something that would trigger the lint */\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Replacing Member Before Moving in Rust\nDESCRIPTION: This example fixes the previous E0507 error by using `mem::replace` to replace the field before moving its original value. This ensures that the borrowed struct always contains a valid value, satisfying Rust's ownership rules. The `mem::replace` function takes a mutable reference and replaces the value at that location with a new value, returning the original value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0507.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifetime Cleaning Function in Rust\nDESCRIPTION: Function that converts HIR lifetime representations into Rustdoc's clean structure. It handles various types of lifetime bounds including early bound, late bound, and free lifetimes, with special processing for named bound variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n    if let Some(\n        rbv::ResolvedArg::EarlyBound(did)\n        | rbv::ResolvedArg::LateBound(_, _, did)\n        | rbv::ResolvedArg::Free(_, did),\n    ) = cx.tcx.named_bound_var(lifetime.hir_id)\n        && let Some(lt) = cx.args.get(&did).and_then(|arg| arg.as_lt())\n    {\n        return lt.clone();\n    }\n    Lifetime(lifetime.ident.name)\n}\n```\n\n----------------------------------------\n\nTITLE: URL Fragment Extraction Function in JavaScript\nDESCRIPTION: Extracts and processes URL fragments, filtering out HTML and anchor elements\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/not_found.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction get_url_fragments() {\n    var last = document.URL.split(\"/\").pop();\n    var tokens = last.split(\".\");\n    var op = [];\n    for (var i=0; i < tokens.length; i++) {\n        var t = tokens[i];\n        if (t == 'html' || t.indexOf(\"#\") != -1) {\n            // no html or anchors\n        } else {\n            op.push(t);\n        }\n    }\n    return op;\n}\n```\n\n----------------------------------------\n\nTITLE: Incomplete Character Literal - Error Example\nDESCRIPTION: Shows incorrect syntax for a character literal where the closing quote is missing, resulting in error E0762.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0762.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstatic C: char = '●; // error!\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Binary Digits Error\nDESCRIPTION: This snippet demonstrates an error case where a binary integer literal (0b) is defined without any digits following the prefix. This results in a compiler error indicating missing digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0b\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Async Function Return Type with Self Reference\nDESCRIPTION: Example showing incorrect usage of Self as return type in an async function when dealing with lifetime parameters. This pattern is not currently supported by the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0760.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<'a>(&'a i32);\n\nimpl<'a> S<'a> {\n    async fn new(i: &'a i32) -> Self {\n        S(&22)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Representation Hints in Rust Structs\nDESCRIPTION: This code demonstrates the incorrect usage of combining both `packed` and `align` representation hints on a single struct, which results in a compilation error (E0587).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0587.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(packed, align(8))] // error!\nstruct Umbrella(i32);\n```\n\n----------------------------------------\n\nTITLE: Adding Label to Loop in Rust\nDESCRIPTION: This assist adds a label to a loop. It inserts a label before the loop and updates break and continue statements to use the label.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        break;\n        continue;\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    'l: loop {\n        break 'l;\n        continue 'l;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Where Clause Default Format Example in Rust\nDESCRIPTION: Demonstrates the default multi-line formatting of where clauses when where_single_line is false.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_81\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Lorem for T\nwhere\n    Option<T>: Ipsum,\n{\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of #[link] Attribute in Rust\nDESCRIPTION: This code snippet shows the correct way to use the #[link] attribute by including both the 'kind' and 'name' parameters. This allows the Rust compiler to find the specified library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0459.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[link(kind = \"dylib\", name = \"some_lib\")] extern \"C\" {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Building with Debug Assertions for Wait Loop Debugging\nDESCRIPTION: Command to build the project with debug assertions enabled, which is necessary for the wait loop debugging technique to work.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/debugging.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS='--cfg debug_assertions' cargo build --release\n```\n\n----------------------------------------\n\nTITLE: Setting VITASDK Environment Variable\nDESCRIPTION: This command sets the `VITASDK` environment variable, which specifies the location of the VITASDK toolchain. This is required for `cargo-vita` to find the necessary tools for building Vita-compatible executables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n\"export VITASDK=/opt/vitasdk\"\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Section for Vita Metadata\nDESCRIPTION: This section defines metadata specific to the Vita application, such as the title ID and title name. This information is used when creating the VPK package for the application.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n\"[package.metadata.vita]\\n# A unique 9 character alphanumeric identifier of the app.\\ntitle_id = \\\"RUSTAPP01\\\"\\n# A title that will be used for the app. Optional, name will be used if not defined\\ntitle_name = \\\"My application\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Alternative GIMPLE Generation Option in C\nDESCRIPTION: This snippet shows an alternative way to generate GIMPLE output by using a different GCC JIT API option. It adds a command-line option instead of setting a boolean option.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_5\n\nLANGUAGE: C\nCODE:\n```\ngcc_jit_context_add_command_line_option(ctxt, \"-fdump-tree-gimple\");\n```\n\n----------------------------------------\n\nTITLE: Building Custom GCC for libgccjit\nDESCRIPTION: Commands to clone the Rust-patched GCC repository and build it with libgccjit support. This enables the necessary backend functionality for the Rust GCC codegen.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/rust-lang/gcc\n$ sudo apt install flex libmpfr-dev libgmp-dev libmpc3 libmpc-dev\n$ mkdir gcc-build gcc-install\n$ cd gcc-build\n$ ../gcc/configure \\\n    --enable-host-shared \\\n    --enable-languages=jit \\\n    --enable-checking=release \\ # it enables extra checks which allow to find bugs\n    --disable-bootstrap \\\n    --disable-multilib \\\n    --prefix=$(pwd)/../gcc-install\n$ make -j4 # You can replace `4` with another number depending on how many cores you have.\n```\n\n----------------------------------------\n\nTITLE: Incorrect Pattern Matching of Tuple Variant (Error E0769)\nDESCRIPTION: Demonstrates incorrect usage of struct pattern syntax when matching a tuple variant, resulting in compilation error E0769.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0769.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum E {\n    A(i32),\n}\n\nlet e = E::A(42);\n\nmatch e {\n    E::A { number } => { // error!\n        println!(\"{}\", number);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Signed Char Type Reference Demonstration\nDESCRIPTION: Shows the type equivalence between Rust's signed char type and C's signed char. This type is always i8 in Rust but is included for C compatibility and completeness in FFI contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_schar.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ni8\n```\n\nLANGUAGE: c\nCODE:\n```\nsigned char\n```\n\n----------------------------------------\n\nTITLE: Cloning and updating Rust Clippy repository using Git - Bash\nDESCRIPTION: Commands to clone the Clippy repository from a forked version and to update an existing clone with the latest changes from the upstream repository. It demonstrates setting up the upstream remote, fetching updates, rebasing onto upstream master, and pushing updates to the fork's master branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/basics.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:<your-username>/rust-clippy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# If the upstream remote has not been added yet\ngit remote add upstream https://github.com/rust-lang/rust-clippy\ngit fetch upstream\ngit checkout master\ngit rebase upstream/master\ngit push\n```\n\n----------------------------------------\n\nTITLE: Obtaining Address Using `&v as *const _ as usize` in Rust\nDESCRIPTION: This snippet demonstrates casting a reference to a value `v` to a raw pointer `*const _`, then converting it to a `usize`. It shows how this method derives a variable's address representation for comparison. The approach is straightforward but can obscure pointer provenance and lead to compiler confusion when comparing addresses from different allocations. Dependencies include the core Rust language and standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/codegen/equal-pointers-unequal/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n&v as *const _ as usize\n```\n\n----------------------------------------\n\nTITLE: Correcting Lifetime Mismatch in Rust Function\nDESCRIPTION: This snippet demonstrates an error due to mismatched lifetimes in a Rust function. The erroneous function attempts to assign a lifetime that does not last long enough, which is resolved by either adjusting the lifetime parameters to enforce that one lives at least as long as the other or by unifying them to the same lifetime. This illustrates Rust's strict compile-time checks to ensure memory safety.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0495.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n    match (&t,) { // error!\n        ((u,),) => u,\n    }\n}\n\nlet y = Box::new((42,));\nlet x = transmute_lifetime(&y);\n```\n\n----------------------------------------\n\nTITLE: Elaborating Supertraits in Rust\nDESCRIPTION: Demonstrates how to construct a `ParamEnv` in Rust by explicitly adding where clauses for supertraits within a function. This aids in proving trait bounds like `T: Clone` and `T: SuperSuperTrait`. Key dependencies include the `Copy`, `Clone`, and `SuperSuperTrait` traits. Inputs are trait bounds in the function signature; outputs are an enriched parameter environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/typing_parameter_envs.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait: SuperTrait {}\ntrait SuperTrait: SuperSuperTrait {}\n\n// `bar`'s unelaborated `ParamEnv` would be:\n// `[T: Sized, T: Copy, T: Trait]`\nfn bar<T: Copy + Trait>(a: T) {\n    requires_impl(a);\n}\n\nfn requires_impl<T: Clone + SuperSuperTrait>(a: T) {}\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for Fuzzer Sanitizer Functions in Rust\nDESCRIPTION: This snippet defines custom handling and uninstrumented status for various sanitizer functions used in fuzzing. It includes trace comparison and switch operations, replacing some with DFSan-specific versions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfun:__sanitizer_cov_trace_cmp1=custom\nfun:__sanitizer_cov_trace_cmp1=uninstrumented\nfun:__sanitizer_cov_trace_cmp2=custom\nfun:__sanitizer_cov_trace_cmp2=uninstrumented\nfun:__sanitizer_cov_trace_cmp4=custom\nfun:__sanitizer_cov_trace_cmp4=uninstrumented\nfun:__sanitizer_cov_trace_cmp8=custom\nfun:__sanitizer_cov_trace_cmp8=uninstrumented\nfun:__sanitizer_cov_trace_const_cmp1=custom\nfun:__sanitizer_cov_trace_const_cmp1=uninstrumented\nfun:__sanitizer_cov_trace_const_cmp2=custom\nfun:__sanitizer_cov_trace_const_cmp2=uninstrumented\nfun:__sanitizer_cov_trace_const_cmp4=custom\nfun:__sanitizer_cov_trace_const_cmp4=uninstrumented\nfun:__sanitizer_cov_trace_const_cmp8=custom\nfun:__sanitizer_cov_trace_const_cmp8=uninstrumented\nfun:__sanitizer_cov_trace_switch=custom\nfun:__sanitizer_cov_trace_switch=uninstrumented\n```\n\n----------------------------------------\n\nTITLE: Configuring bootstrap.toml for armv6k-nintendo-3ds Target\nDESCRIPTION: Configuration settings to add to bootstrap.toml when building Rust with support for the armv6k-nintendo-3ds target, specifying the build stage, target, and paths to the devkitARM toolchain executables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv6k-nintendo-3ds.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"armv6k-nintendo-3ds\"]\n\n[target.armv6k-nintendo-3ds]\ncc = \"/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc\"\ncxx = \"/opt/devkitpro/devkitARM/bin/arm-none-eabi-g++\"\nar = \"/opt/devkitpro/devkitARM/bin/arm-none-eabi-ar\"\nranlib = \"/opt/devkitpro/devkitARM/bin/arm-none-eabi-ranlib\"\nlinker = \"/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Struct Pattern Field Access in Rust\nDESCRIPTION: This example demonstrates a compile error (E0026) that occurs when attempting to extract a nonexistent field 'z' from the 'Thing' struct during pattern matching. The struct only has 'x' and 'y' fields, causing the compiler to raise an error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0026.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Thing {\n    x: u32,\n    y: u32,\n}\n\nlet thing = Thing { x: 0, y: 0 };\n\nmatch thing {\n    Thing { x, z } => {} // error: `Thing::z` field doesn't exist\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trait Object Lifetime Error in Rust\nDESCRIPTION: Example showing erroneous code where a trait object with specific lifetime is used in a context requiring 'static lifetime. The code fails to compile due to lifetime mismatch between person parameter and trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0772.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait BooleanLike {}\ntrait Person {}\n\nimpl BooleanLike for bool {}\n\nimpl dyn Person {\n    fn is_cool(&self) -> bool {\n        // hey you, you're pretty cool\n        true\n    }\n}\n\nfn get_is_cool<'p>(person: &'p dyn Person) -> impl BooleanLike {\n    // error: `person` has an anonymous lifetime `'p` but calling\n    //        `print_cool_fn` introduces an implicit `'static` lifetime\n    //        requirement\n    person.is_cool()\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Expression Type in Rustc Lint Pass - Rust\nDESCRIPTION: Demonstrates how to retrieve the type (`Ty`) of an expression (`Expr`) within a Rust lint pass by using the `expr_ty()` method from the `TypeckResults` struct accessed through the lint context (`LateContext`). It matches on the kind of the type to determine further properties like whether it corresponds to a struct. This snippet requires the Rustc compiler internals crates and focuses on compiling with type information available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl LateLintPass<'_> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        // Get type of `expr`\n        let ty = cx.typeck_results().expr_ty(expr);\n        // Match its kind to enter its type\n        match ty.kind() {\n            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n            _ => ()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incompatible Representation Hints in Rust\nDESCRIPTION: This code snippet shows an erroneous use of multiple, incompatible representation hints. The `repr(transparent)` attribute cannot be combined with other representation hints like `repr(C)`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0692.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent, C)] // error: incompatible representation hints\nstruct Grams(f32);\n```\n\n----------------------------------------\n\nTITLE: Defining Typing Context in Rust Compiler\nDESCRIPTION: This Rust snippet illustrates how the type context (`tcx`) is defined within the compiler, demonstrating its role as a central data structure interfacing with arena-allocated data. The `TyCtxt` struct includes a lifetime parameter, an essential aspect in the memory management of arena-allocated data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/memory.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntcx: TyCtxt<'tcx>\n//          ----\n//          |\n//          arena lifetime\n```\n\n----------------------------------------\n\nTITLE: Hover Actions Extension in TypeScript\nDESCRIPTION: Defines an experimental extension for hover actions, allowing additional command links to be displayed with hover information\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Hover {\n    actions?: CommandLinkGroup[];\n}\n\ninterface CommandLink extends Command {\n    tooltip?: string;\n}\n\ninterface CommandLinkGroup {\n    title?: string;\n    commands: CommandLink[];\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Generic Argument Order in Rust\nDESCRIPTION: This code snippet shows the correct way to declare generic arguments, matching the order of the parameters in the struct definition. The lifetime argument is provided before the type argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0747.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<'a, T>(&'a T);\n\ntype X = S<'static, ()>; // ok\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU User Emulation for m68k\nDESCRIPTION: Command to install QEMU user emulation package, enabling execution of static m68k binaries on host systems\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# apt install qemu-user-static\n```\n\n----------------------------------------\n\nTITLE: Running an instrumented binary to generate coverage data\nDESCRIPTION: Example of running a coverage-instrumented binary, which will generate raw profiling data in a file with an auto-generated name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C signed short type equivalence in Rust\nDESCRIPTION: Shows equivalent type definitions between C's signed short and Rust's typically i16 type. Notes that while usually equivalent to i16, the actual size may vary on some systems as C only requires it to be at least 16 bits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_short.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsigned short\n```\n\nLANGUAGE: rust\nCODE:\n```\ni16\n```\n\n----------------------------------------\n\nTITLE: Obtaining Address Using `addr_of!(v).addr()` in Rust\nDESCRIPTION: This snippet utilizes the `addr_of!` macro combined with `.addr()` to retrieve the address of `v` as a `usize`. It preserves the honest provenance of the address within Rust's safety system yet can lead to situations where addresses are equal in value but originate from distinct allocations, causing logical ambiguities. Dependencies include the `addr_of!` macro available in Rust nightly or with unstable features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/codegen/equal-pointers-unequal/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\naddr_of!(v).addr()\n```\n\n----------------------------------------\n\nTITLE: Using References in Match Expressions for Drop Trait in Rust\nDESCRIPTION: This snippet showcases how to correctly use references in match expressions when dealing with types that implement the Drop trait. It ensures that fields are not moved out of the enum while still allowing safe access to their values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0509.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n```\nstruct FancyNum {\n    num: usize\n}\n\nenum DropEnum {\n    Fancy(FancyNum)\n}\n\nimpl Drop for DropEnum {\n    fn drop(&mut self) {\n        // Destruct DropEnum, possibly using FancyNum\n    }\n}\n\nfn main() {\n    // Creates and enum of type `DropEnum`, which implements `Drop`\n    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n    match drop_enum {\n        // Creates a reference to the inside of `DropEnum::Fancy`\n        DropEnum::Fancy(ref fancy_field) => // No error!\n            println!(\"It was fancy-- {}!\", fancy_field.num),\n    }\n    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Printing Crate Name in Rust\nDESCRIPTION: Demonstrates how to print the name of a Rust crate using rustc's --print flag with crate-name option.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print crate-name --crate-name my_crate a.rs\nmy_crate\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript Lints and Tests (bash)\nDESCRIPTION: This workflow snippet demonstrates the procedure for setting up and testing VS Code extension modifications using npm. After navigating to the 'editors/code' directory, 'npm ci' installs project dependencies, while 'npm run lint' runs ESLint or another configured linter. Requires Node.js and npm to be installed. Used specifically for contributors modifying or testing the TypeScript-based VS Code client component.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd editors/code\nnpm ci\nnpm run lint\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Package Metadata for libc Library\nDESCRIPTION: This code snippet defines various package metadata for the 'libc' Rust library, including version information, license details, and repository URL. It also specifies dependencies and origin information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model.txt#2025-04-21_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"CARGO_PKG_LICENSE\": \"MIT OR Apache-2.0\",\n    \"CARGO_PKG_LICENSE_FILE\": \"\",\n    \"CARGO_PKG_NAME\": \"libc\",\n    \"CARGO_PKG_README\": \"README.md\",\n    \"CARGO_PKG_REPOSITORY\": \"https://github.com/rust-lang/libc\",\n    \"CARGO_PKG_RUST_VERSION\": \"\",\n    \"CARGO_PKG_VERSION\": \"0.2.98\",\n    \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n    \"CARGO_PKG_VERSION_MINOR\": \"2\",\n    \"CARGO_PKG_VERSION_PATCH\": \"98\",\n    \"CARGO_PKG_VERSION_PRE\": \"\",\n    \"dependencies\": [],\n    \"origin\": {\n        \"repo\": \"https://github.com/rust-lang/libc\",\n        \"name\": \"libc\"\n    },\n    \"is_proc_macro\": false,\n    \"proc_macro_cwd\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\"\n}\n```\n\n----------------------------------------\n\nTITLE: Matching a Non-Exhaustive Enum Non-Exhaustively in Rust\nDESCRIPTION: This snippet provides an example of matching a non-exhaustive enum with a wildcard pattern `_`.  It simulates how downstream crates must handle the `Error` enum defined above to avoid errors. This pattern ensures that any new variants added in the future do not break existing code in downstream crates. Requires a dependency on the crate where the enum is defined (`mycrate`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0638.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```rust,ignore (pseudo-Rust)\nuse mycrate::Error;\n\n// This will not error as the non_exhaustive Error enum has been matched with a\n// wildcard.\nmatch error {\n    Message(s) => ...,\n    Other => ...,\n    _ => ...,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Delegating Completion to Analysis Engine (Rust)\nDESCRIPTION: This function delegates completion requests from the LSP handler to the analysis engine, forming the bridge between the protocol layer and the semantic analysis infrastructure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide/src/lib.rs#L605-L615\n```\n\n----------------------------------------\n\nTITLE: Encoding Inherent Implementation in Rust\nDESCRIPTION: The example outlines how the symbol for a method (`foo`) in an inherent implementation (impl) block of the `Example` struct is mangled in Rust. It systematically explains the inherent-impl encoding details necessary to identify such symbols within crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Example;\nimpl Example {\n    fn foo() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Else Block Error Example in Rust\nDESCRIPTION: Example of incorrect Rust code that triggers the E0317 error by omitting an else block in an if expression where a value is expected.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0317.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet a = if x == 5 {\n    1\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Info Level in Rust\nDESCRIPTION: Controls the generation of debug information. Values include `0` or `none` (no debug info), `line-directives-only`, `line-tables-only`, `1` or `limited`, and `2` or `full`. The `-g` flag is an alias for `-C debuginfo=2`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Setting Interposable Visibility in Rust Compilation\nDESCRIPTION: Uses the `-Zdefault-visibility=interposable` flag to set symbols to default visibility, allowing symbol interposition on supported platforms. This enables symbol overriding by the executable or earlier shared objects in the load order.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/default-visibility.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n-Zdefault-visibility=interposable\n```\n\n----------------------------------------\n\nTITLE: Correct Associated Item Constraint in Where-Clause\nDESCRIPTION: This snippet demonstrates another correct way to use associated item constraints by placing them in the where-clause. This is an alternative solution to resolve the E0229 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0229.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# struct Bar;\n# trait Foo { type A; }\nfn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom CSS Class to Code Blocks in Rust Documentation\nDESCRIPTION: Example showing how to apply custom CSS classes to code blocks in Rust documentation to enable specialized language highlighting. The 'custom' attribute with class specification prevents it from being treated as Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n/// ```custom,{class=language-c}\n/// int main(void) { return 0; }\n/// ```\npub struct Bar;\n```\n\n----------------------------------------\n\nTITLE: Printing Debug Information in GDB for libgccjit Errors\nDESCRIPTION: These GDB commands print the line number and filename of the error location when debugging libgccjit issues. They should be used after setting a breakpoint on the 'add_error' function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging-libgccjit.md#2025-04-21_snippet_1\n\nLANGUAGE: gdb\nCODE:\n```\np loc->m_line\np loc->m_filename->m_buffer\n```\n\n----------------------------------------\n\nTITLE: Correct SIMD Intrinsic Monomorphization in Rust\nDESCRIPTION: Shows the proper way to use the simd_add intrinsic function with a custom SIMD type that has the #[repr(simd)] attribute\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0511.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n#![feature(intrinsics)]\n\n#[repr(simd)]\n#[derive(Copy, Clone)]\nstruct i32x2([i32; 2]);\n\n#[rustc_intrinsic]\nunsafe fn simd_add<T>(a: T, b: T) -> T;\n\nunsafe { simd_add(i32x2([0, 0]), i32x2([1, 2])); } // ok!\n```\n\n----------------------------------------\n\nTITLE: Generic List Structure Definition in Rust\nDESCRIPTION: Defines a generic recursive List structure used to demonstrate auto trait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/auto-traits.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct List<T> {\n  data: T,\n  next: Option<Box<List<T>>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Prohibited Pattern Usage in Rust Trait Methods\nDESCRIPTION: This snippet demonstrates an incorrect way of defining a trait method in Rust where patterns are used in the parameter list. Patterns in trait methods are not allowed, leading to a compile error. The example shows a tuple pattern trying to be destructured in the method signature, which results in the error E0642.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0642.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Foo {\n    fn foo((x, y): (i32, i32)); // error: patterns aren\\'t allowed\n                                //        in trait methods\n}\n```\n\n----------------------------------------\n\nTITLE: Module Definition Formatting in Rust\nDESCRIPTION: Shows the formatting for module definitions in Rust, including spacing around keywords and the opening brace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod foo;\n```\n\n----------------------------------------\n\nTITLE: Rust Code Using C Library via FFI\nDESCRIPTION: This Rust code defines a `do_twice` function and two other functions, `add_one` and `add_two`, which are called by `do_twice`. It showcases how to call C code from Rust using the FFI. Specifically, `do_twice` is imported from a C library, and function pointers are passed to and from the C function.  It attempts to demonstrate Control Flow Integrity (CFI) by transmuting `add_two` to the same signature as `add_one` and then passing it to the `do_twice` function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::mem;\n\n#[link(name = \"foo\")]\nextern \"C\" {\n    fn do_twice(f: unsafe extern \"C\" fn(i32) -> i32, arg: i32) -> i32;\n}\n\nunsafe extern \"C\" fn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nunsafe extern \"C\" fn add_two(x: i64) -> i64 {\n    x + 2\n}\n\nfn main() {\n    let answer = unsafe { do_twice(add_one, 5) };\n\n    println!(\"The answer is: {}\", answer);\n\n    println!(\"With CFI enabled, you should not see the next answer\");\n    let f: unsafe extern \"C\" fn(i32) -> i32 = unsafe {\n        mem::transmute::<*const u8, unsafe extern \"C\" fn(i32) -> i32>(add_two as *const u8)\n    };\n    let next_answer = unsafe { do_twice(f, 5) };\n\n    println!(\"The next answer is: {}\", next_answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark affected by compiler optimizations\nDESCRIPTION: Demonstrates a benchmark that can be affected by compiler optimizations. The example shows how the compiler might completely optimize away the calculation being measured, resulting in misleading benchmark results.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/test.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(test)]\n\nextern crate test;\nuse test::Bencher;\n\n#[bench]\nfn bench_xor_1000_ints(b: &mut Bencher) {\n    b.iter(|| {\n        (0..1000).fold(0, |old, new| old ^ new);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Intermediate Collections in Recursion\nDESCRIPTION: This code illustrates an accumulator approach in recursively obtaining nodes, promoting efficiency by avoiding the creation of unnecessary intermediate collections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\npub fn reachable_nodes(node: Node) -> FxHashSet<Node> {\n    let mut res = FxHashSet::default();\n    go(&mut res, node);\n    res\n}\nfn go(acc: &mut FxHashSet<Node>, node: Node) {\n    acc.insert(node);\n    for n in node.neighbors() {\n        go(acc, n);\n    }\n}\n\n// BAD\npub fn reachable_nodes(node: Node) -> FxHashSet<Node> {\n    let mut res = FxHashSet::default();\n    res.insert(node);\n    for n in node.neighbors() {\n        res.extend(reachable_nodes(n));\n    }\n    res\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Example in Rust\nDESCRIPTION: This code demonstrates how to achieve a similar result using type inference in Rust. Instead of explicitly specifying the type with `typeof`, the compiler infers the type based on the value assigned to the variable `x`. In this case, `x` will be inferred as `i32`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0516.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn main() {\n    let x = 92;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Function Invocation with Early and Late Bound Parameters in Rust\nDESCRIPTION: This snippet demonstrates the invocation of the `foo` function, distinguishing between early bound type parameters and late bound lifetimes. It shows how type arguments are supplied at different stages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, T: Sized>(a: &'a T) -> &'a T {\n    # a\n    /* snip */\n}\n\n// Here we provide a type argument `String` to the\n// type parameter `T` on the function item type\nlet my_func = foo::<String>;\n\n// Here (implicitly) a lifetime argument is provided\n// to the lifetime parameter `'a` on the builtin impl.\nmy_func(&String::new());\n```\n\n----------------------------------------\n\nTITLE: Match Arm Pattern Formatting in Rust\nDESCRIPTION: Guidelines for formatting match arm patterns in Rust. Never start patterns with vertical bars; instead, use them between alternatives, and use trailing commas for non-block arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nmatch foo {\n    // Don't do this.\n    | foo => bar,\n    // Or this.\n    | a_very_long_pattern\n    | another_pattern\n    | yet_another_pattern\n    | a_fourth_pattern => {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Field Values in Rust Enums\nDESCRIPTION: Shows how default field values work with enum variants when using derive(Default). The default variant must be marked with #[default] and all its fields must have default values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/default-field-values.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(default_field_values)]\n\n#[derive(Default)]\nenum A {\n    #[default]\n    B {\n        x: i32 = 0,\n        y: i32 = 0,\n    },\n    C,\n}\n```\n\n----------------------------------------\n\nTITLE: Block Indentation Example in Rust\nDESCRIPTION: Demonstrates preferred block indentation technique for function calls with multiple arguments, emphasizing readability and minimizing diff changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Block indent\na_function_call(\n    foo,\n    bar,\n);\n```\n\n----------------------------------------\n\nTITLE: Match Pattern Breaking with If Clause - Rust\nDESCRIPTION: Shows the proper formatting when breaking a match pattern with an if clause, using block indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n    a_very_long_pattern | another_pattern\n        if expr =>\n    {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Valid Empty Match Expression with Empty Type in Rust\nDESCRIPTION: This code demonstrates a valid use case for an empty match expression. Since the matched value 'x' is of an empty type (enum Empty), having no match arms is acceptable because there are no possible values to match against.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0002.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Empty {}\n\nfn foo(x: Empty) {\n    match x {\n        // empty\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0158 Error with Generic Parameter in Pattern Matching\nDESCRIPTION: This code snippet demonstrates the E0158 error by attempting to match against a constant that depends on a generic parameter. The compiler cannot prove exhaustiveness in this case because the generic implementation could be arbitrary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0158.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    One,\n    Two\n}\n\ntrait Bar {\n    const X: Foo;\n}\n\nfn test<A: Bar>(arg: Foo) {\n    match arg {\n        A::X => println!(\"A::X\"), // error: E0158: constant pattern depends\n                                  //        on a generic parameter\n        Foo::Two => println!(\"Two\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Function Without Warnings\nDESCRIPTION: Example of code that violates missing_docs lint but produces no warnings by default.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/levels.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of #[link] Attribute in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous use of the #[link] attribute without specifying the 'name' parameter. This will result in a compilation error E0459.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0459.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[link(kind = \"dylib\")] extern \"C\" {}\n// error: `#[link(...)]` specified without `name = \"foo\"`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Constraints with type_alias_impl_trait\nDESCRIPTION: This code snippet shows how `type_alias_impl_trait` enforces type constraints. It demonstrates that a user-defined type implementing the trait cannot be used where the opaque type is expected, but can be used with argument-position `impl Trait`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/type-alias-impl-trait.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(type_alias_impl_trait)]\n# #![allow(unused_variables)]\n# pub mod x {\n# pub trait Trait {}\n#\n# struct MyType;\n#\n# impl Trait for MyType {}\n#\n# pub type Alias = impl Trait;\n#\n# #[define_opaque(Alias)]\n# pub fn new() -> Alias {\n#     MyType\n# }\n# }\n# use x::*;\n# pub fn take_alias(x: Alias) {\n#     // ...\n# }\n#\n# pub fn take_impl(x: impl Trait) {\n#    // ...\n# }\n#\n// a user's crate using the trait and type alias\nstruct UserType;\nimpl Trait for UserType {}\n\n# fn main(){\nlet x = UserType;\ntake_alias(x);\n// ERROR expected opaque type, found `UserType`\n// this function *actually* takes a `MyType` as is constrained in `new`\n\nlet x = UserType;\ntake_impl(x);\n// OK\n\nlet x = new();\ntake_alias(x);\n// OK\n\nlet x = new();\ntake_impl(x);\n// OK\n# }\n```\n\n----------------------------------------\n\nTITLE: Correcting ABI Usage with Predefined ABI in Rust\nDESCRIPTION: This code snippet demonstrates the correct usage of a predefined ABI ('Rust') in an external function declaration, which compiles successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0703.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"Rust\" fn foo() {} // ok!\n# fn main() { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsized Locals and Arguments in Rust\nDESCRIPTION: This snippet shows how to use unsized local variables and function arguments with the unsized_locals and unsized_fn_params features. It demonstrates creating and using unsized Box<dyn Any> types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(incomplete_features)]\n#![feature(unsized_locals, unsized_fn_params)]\n\nuse std::any::Any;\n\nfn main() {\n    let x: Box<dyn Any> = Box::new(42);\n    let x: dyn Any = *x;\n    //  ^ unsized local variable\n    //               ^^ unsized temporary\n    foo(x);\n}\n\nfn foo(_: dyn Any) {}\n//     ^^^^^^ unsized argument\n```\n\n----------------------------------------\n\nTITLE: Default Self-Profile Events Configuration\nDESCRIPTION: Shows two equivalent ways to enable the profiler with default event settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile-events.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -Zself-profile\n$ rustc -Zself-profile -Zself-profile-events=default\n```\n\n----------------------------------------\n\nTITLE: Command Line Options for Crate - TOML\nDESCRIPTION: Allows the specification of command line options for a crate within a TOML configuration file. This enables the customization of how crates are built, allowing features to be enabled or disabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\nclap = {name = \"clap\", versions = ['4.5.8'], options = ['-Fderive']}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition and Drop Implementation - Rust\nDESCRIPTION: This snippet defines different structs with and without Drop implementations, illustrating the concept of drop obligations based on struct field characteristics. It showcases how a custom Drop trait can dictate drop behavior in complex types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/drop-elaboration.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct NoDrop(u8); // No `Drop` impl. No fields with `Drop` impls.\n\nstruct NeedsDrop(Vec<u8>); // No `Drop` impl but has fields with `Drop` impls.\n\nstruct ThinVec(*const u8); // Custom `Drop` impl. Individual fields cannot be moved from.\n\nimpl Drop for ThinVec {\n    fn drop(&mut self) { /* ... */ }\n}\n\nenum MaybeDrop {\n    Yes(NeedsDrop),\n    No(NoDrop),\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Match Expression Formatting in Rust\nDESCRIPTION: Detailed examples of match expression formatting in Rust, showing various arm types including single expressions, blocks with comments, statements, and empty blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nmatch foo {\n    foo => bar,\n    a_very_long_pattern | another_pattern if an_expression() => {\n        no_room_for_this_expression()\n    }\n    foo => {\n        // A comment.\n        an_expression()\n    }\n    foo => {\n        let a = statement();\n        an_expression()\n    }\n    bar => {}\n    // Trailing comma on last item.\n    foo => bar,\n    baz => qux!(),\n    lorem => {\n        ipsum!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Rust Example: Accessing Field on Primitive Type\nDESCRIPTION: This code demonstrates the error that occurs when trying to access a field on a primitive type (u32). The compiler will report an error because primitive types do not have fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0610.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Drop Implementation on Reference (Rust)\nDESCRIPTION: This code shows an invalid attempt to implement the Drop trait on a reference to a concrete type. Drop can only be implemented on the actual type, not on references to it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0120.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Concrete {}\n\nimpl Drop for &'_ mut Concrete  {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Unnecessary Let Binding in Rust\nDESCRIPTION: This snippet demonstrates an unnecessary let binding in Rust code. Clippy suggests returning the expression directly instead of binding it to a variable and then returning the variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/snap_multi_line_fix.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet x = (0..10).collect();\nx\n```\n\n----------------------------------------\n\nTITLE: Correcting Function Parameters with Unique Names in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to declare function parameters with unique names, avoiding the E0415 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0415.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(f: i32, g: i32) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Erroneous Lifetime Capture in impl Trait Return Type (Rust)\nDESCRIPTION: This code snippet demonstrates an incorrect implementation where the `impl Trait` return type fails to capture the lifetime `'x` which is referenced in the returned value. This results in a compilation error (E0700).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0700.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\ntrait Trait<'a> { }\n\nimpl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n\nfn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\nwhere 'x: 'y\n{\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Alignment Syntax Example in Rust\nDESCRIPTION: Demonstrates the correct syntax for specifying alignment using the repr attribute. Shows proper parenthetical notation for alignment value specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0693.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(align(8))] // ok!\nstruct Align8(i8);\n```\n\n----------------------------------------\n\nTITLE: Using Static Lifetime in Const Generic Parameter (Correct Example)\nDESCRIPTION: This code demonstrates the correct approach to using string references in const generic parameters by explicitly using the 'static lifetime. This resolves the E0770 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0771.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(adt_const_params, unsized_const_params)]\n\nfn function_with_str<const STRING: &'static str>() {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Rustfmt Ignore Configuration\nDESCRIPTION: Shows how to configure file and directory ignore patterns in rustfmt.toml\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_24\n\nLANGUAGE: toml\nCODE:\n```\nignore = [\n    \"src/types.rs\",\n    \"src/foo/bar.rs\",\n]\n```\n\n----------------------------------------\n\nTITLE: Invalid Primitive Type Cast to Non-Primitive Collection\nDESCRIPTION: Demonstrates an erroneous type cast attempt from a primitive u8 to a Vec<u8>, which is not allowed in Rust. Non-primitive casts are prohibited.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0605.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 0u8;\nx as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n```\n\n----------------------------------------\n\nTITLE: Target feature attribute in Rust (incorrect)\nDESCRIPTION: This Rust code snippet shows how target features are enabled on a per-function level with the `#[target_feature]` attribute (not recommended). Here, the \"simd128\" feature is enabled for the `foo` function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[target_feature(enable = \"simd128\")]\nfn foo() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Const Trait Method Declaration Error in Rust\nDESCRIPTION: This code snippet illustrates the error that occurs when attempting to declare a trait method as const. It shows both the incorrect trait declaration and implementation, which will result in compilation errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0379.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    const fn bar() -> u32; // error!\n}\n\nimpl Foo for () {\n    const fn bar() -> u32 { 0 } // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Profiler Builtins - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `profiler_builtins` crate (index 5). It includes the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate contains built-in profiling tools.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n5: CrateData {\n    root_file_id: FileId(\n        6,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"profiler_builtins\",\n            ),\n            canonical_name: \"profiler_builtins\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Other,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Example Output of `cargo doc` with Missing Documentation Warning\nDESCRIPTION: This text output shows a sample result from running `cargo doc` on a Rust project where the `#![warn(missing_docs)]` attribute is used and the crate itself lacks top-level documentation. It highlights the specific warning and points to the location of the lint definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n Documenting docdemo v0.1.0 (/Users/username/docdemo)\nwarning: missing documentation for the crate\n --> src/main.rs:1:1\n  |\n1 | / #![warn(missing_docs)]\n2 | |\n3 | | fn main() {\n4 | |     println!(\"Hello, world!\");\n5 | | }\n  | |_^\n  |\nnote: the lint level is defined here\n --> src/main.rs:1:9\n  |\n1 | #![warn(missing_docs)]\n  |         ^^^^^^^^^^^^\n\nwarning: 1 warning emitted\n\n    Finished dev [unoptimized + debuginfo] target(s) in 2.96s\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Layout - Vertical\nDESCRIPTION: Illustrates the 'Vertical' layout for function parameters.  Each parameter is placed on a separate line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\ntrait Lorem {\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n    );\n\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n    ) {\n        // body\n    }\n\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n        consectetur: Consectetur,\n        adipiscing: Adipiscing,\n        elit: Elit,\n    );\n\n    fn lorem(\n        ipsum: Ipsum,\n        dolor: Dolor,\n        sit: Sit,\n        amet: Amet,\n        consectetur: Consectetur,\n        adipiscing: Adipiscing,\n        elit: Elit,\n    ) {\n        // body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Type Alias in Rust\nDESCRIPTION: This snippet declares a type alias named 'Alias' with a specific location and definition details. Dependencies are based on Rust's module and type declaration requirements. The expected inputs relate to type aliasing within Rust's module system, and outputs include the recognized type alias for compilation and reference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"Alias\",\n    def: TypeAlias(\n        TypeAlias {\n            id: TypeAliasId(\n                0,\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: TYPE_ALIAS,\n            range: 470..490,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 475..480,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compile Error with Trait Parameter Mismatch in Rust\nDESCRIPTION: This Rust code snippet demonstrates a compile error that occurs when a trait function signature uses 'impl Trait' but the implementing function uses a named generic type. The trait 'Foo' has a function 'foo' which expects an 'impl Iterator', while its implementation has a method 'foo' that takes a generic type 'U' constrained by 'Iterator'. This mismatch leads to a compile error 'E0643'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0643.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n```compile_fail,E0643\ntrait Foo {\n    fn foo(&self, _: &impl Iterator);\n}\nimpl Foo for () {\n    fn foo<U: Iterator>(&self, _: &U) { } // error method `foo` has incompatible\n                                          // signature for trait\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Let-Else Statement\nDESCRIPTION: Shows formatting for more complex let-else statements with multi-line initializers and else blocks\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/statements.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet Some(x) = some_really_really_long_name\nelse {\n    return;\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Binary Number Declaration in Rust\nDESCRIPTION: Example showing invalid syntax where a binary number literal has a prefix (0b) but no digits, resulting in compilation error E0768.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0768.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet s: i32 = 0b; // error!\n```\n\n----------------------------------------\n\nTITLE: Interpreting Generic Parameters Syntax in Rust Compiler\nDESCRIPTION: Explains the syntax used for generic parameters in the Rust compiler's internal representation. The format is {name}/#{index}, where index corresponds to the parameter's position in the list of generic parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nT/#0\n```\n\n----------------------------------------\n\nTITLE: Failed Copy Implementation for Enum with Vec\nDESCRIPTION: Example showing why implementing Copy fails for an enum containing Vec<u32>, since Vec<T> does not implement Copy for any type T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0205.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    Bar(Vec<u32>),\n    Baz,\n}\n\nimpl Copy for Foo { }\n```\n\n----------------------------------------\n\nTITLE: Checking Method Invocation in Rust Lints\nDESCRIPTION: Demonstrates how to check if an expression calls a specific method using pattern matching on ExprKind. Includes verification of method name and trait implementation using the LateContext.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/method_checking.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_hir as hir;\nuse rustc_lint::{LateContext, LateLintPass};\nuse rustc_span::sym;\nuse clippy_utils::is_trait_method;\n\nimpl<'tcx> LateLintPass<'tcx> for OurFancyMethodLint {\n    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n        // Check our expr is calling a method with pattern matching\n        if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind\n            // Check if the name of this method is `our_fancy_method`\n            && path.ident.name.as_str() == \"our_fancy_method\"\n            // We can check the type of the self argument whenever necessary.\n            // (It's necessary if we want to check that method is specifically belonging to a specific trait,\n            // for example, a `map` method could belong to user-defined trait instead of to `Iterator`)\n            // See the next section for more information.\n            && is_trait_method(cx, self_arg, sym::OurFancyTrait)\n        {\n            println!(\"`expr` is a method call for `our_fancy_method`\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Inline Assembly on SPARC64\nDESCRIPTION: Example showing how inline assembly fails on unsupported targets like SPARC64. The code demonstrates the use of the asm! macro which generates an error on unsupported platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0472.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// compile-flags: --target sparc64-unknown-linux-gnu\n#![no_std]\n\nuse core::arch::asm;\n\nfn main() {\n    unsafe {\n        asm!(\"\"); // error: inline assembly is not supported on this target\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing warnings in bootstrap - Toml\nDESCRIPTION: This configuration in 'bootstrap.toml' disables warnings for local path dependencies during bootstrap, allowing for smoother local development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\ndeny-warnings = false\n```\n\n----------------------------------------\n\nTITLE: Desugaring Closure with Mutable Reference in Rust\nDESCRIPTION: This Rust snippet illustrates a closure that modifies the value of a captured variable. The compiler adjusts the borrow type to mutable (`FnMut`). The MIR output confirms that `x` is borrowed mutably. Understanding of Rust borrowing semantics is required to comprehend how closures affect variable mutability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/closure.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn closure(mut f: impl FnMut()) {\n    f();\n}\n\nfn main() {\n    let mut x: i32 = 10;\n    closure(|| {\n        x += 10;  // The closure mutates the value of x\n        println!(\"Hi {}\", x)\n    });\n    println!(\"Value of x after return {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Rust Byte Literal with Unicode Escape\nDESCRIPTION: An example of an invalid byte literal syntax that requires a closing single quote to properly terminate the literal\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_unicode_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nBYTE \"b'\\u{20AA}\"\n```\n\n----------------------------------------\n\nTITLE: Fixing Rust Lifetime Elision Error\nDESCRIPTION: Corrected version of the code that explicitly names the elided lifetime and adds the necessary outlives bound for the generic parameter T. This version properly establishes the relationship between the lifetime and type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0311.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn no_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n    with_restriction::<T>(x)\n}\n\nfn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Console Output of Failed Doctest Compilation\nDESCRIPTION: This console output shows what happens when a doctest fails compilation due to using a stable feature with a feature flag. The example demonstrates why custom compiler arguments might be needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_34\n\nLANGUAGE: console\nCODE:\n```\nrunning 1 test\ntest foo.rs - Bar (line 1) ... FAILED\n\nfailures:\n\n---- foo.rs - Bar (line 1) stdout ----\nerror: the feature `async_await` has been stable since 1.39.0 and no longer requires an attribute to enable\n --> foo.rs:2:12\n  |\n3 | #![feature(async_await)]\n  |            ^^^^^^^^^^^\n  |\nnote: the lint level is defined here\n --> foo.rs:1:9\n  |\n2 | #![deny(warnings)]\n  |         ^^^^^^^^\n  = note: `#[deny(stable_features)]` implied by `#[deny(warnings)]`\n\nerror: aborting due to 1 previous error\n\nCouldn't compile the test.\n\nfailures:\n    foo.rs - Bar (line 1)\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeLLDB for Rust Compiler\nDESCRIPTION: This JavaScript snippet represents a launch configuration for using the CodeLLDB extension in VSCode to debug the Rust compiler rustc. Important settings include the program path, the workspace directory, and specifying Rust as the source language. Additional configurations are present for Windows environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n      {\n        \"type\": \"lldb\",\n        \"request\": \"launch\",\n        \"name\": \"Launch\",\n        \"args\": [],  // array of string command-line arguments to pass to compiler\n        \"program\": \"${workspaceFolder}/build/host/stage1/bin/rustc\",\n        \"windows\": {  // applicable if using windows\n            \"program\": \"${workspaceFolder}/build/host/stage1/bin/rustc.exe\"\n        },\n        \"cwd\": \"${workspaceFolder}\",  // current working directory at program start\n        \"stopOnEntry\": false,\n        \"sourceLanguages\": [\"rust\"]\n      }\n    ]\n  }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Higher-Ranked Lifetime Capture in impl Trait (Rust)\nDESCRIPTION: This code snippet shows an erroneous attempt to use `impl Trait` with a higher-ranked lifetime. It defines a `BorrowInto` trait and its implementation, then tries to create a function `opaque()` that returns an `impl Trait` type with a higher-ranked lifetime, which is not supported in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0657.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait BorrowInto<'a> {\n    type Target;\n\n    fn borrow_into(&'a self) -> Self::Target;\n}\n\nimpl<'a> BorrowInto<'a> for () {\n    type Target = &'a ();\n\n    fn borrow_into(&'a self) -> Self::Target {\n        self\n    }\n}\n\nfn opaque() -> impl for<'a> BorrowInto<'a, Target = impl Sized + 'a> {\n    ()\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing an External Crate - Rust\nDESCRIPTION: This snippet demonstrates how to declare an external dependency using `extern crate a;`. It showcases how one Rust crate can depend on another. The purpose is to utilize functionalities provided by the 'a' crate, though in this specific scenario, compilation will fail if crates are compiled using different `rustc` versions. This requires the referenced crate to be available during the compilation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0514.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// compiled with nightly `rustc`\n\n#[crate_type = \"lib\"]\n\nextern crate a; // error: found crate `a` compiled by an incompatible version\n                //        of rustc\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Unwind - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `unwind` crate (index 9). It includes the Rust edition (`Edition2021`) and standard compiler configuration flags (`debug_assertions`, `miri`, `true`), with no dependencies listed. This crate provides stack unwinding capabilities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n9: CrateData {\n    root_file_id: FileId(\n        10,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"unwind\",\n            ),\n            canonical_name: \"unwind\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [],\n    origin: Lang(\n        Other,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Printing with Closing Brace on Next Line\nDESCRIPTION: This code snippet demonstrates a simple conditional statement.  The formatting of the closing brace is determined by other rustfmt settings, but this example shows its placement on a new line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if lorem {\n        println!(\"ipsum!\");\n    }\n    else {\n        println!(\"dolor!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Ambiguous Intra-Doc Link in Rust\nDESCRIPTION: This snippet defines a function and an enum both named `Foo`, demonstrating the `broken_intra_doc_links` lint's warning about ambiguities in link resolution. It provides suggestions on how to disambiguate the reference by explicitly mentioning the type of item being linked. The lint helps clarify links in documentation comments when there are multiple items with the same name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// [`Foo`]\npub fn function() {}\n\npub enum Foo {}\n\npub fn Foo(){}\n\n```\n\n----------------------------------------\n\nTITLE: Compiling a Cargo project with coverage instrumentation\nDESCRIPTION: Shell commands to compile a Cargo project with coverage instrumentation enabled using the RUSTFLAGS environment variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cd your-project\n$ cargo clean\n$ RUSTFLAGS=\"-C instrument-coverage\" cargo build\n```\n\n----------------------------------------\n\nTITLE: Call-site Hierarchy Example (Rust)\nDESCRIPTION: This example demonstrates the call-site hierarchy with nested macro invocations. It clarifies the difference between expansion-order and call-site hierarchies.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmacro bar($i: ident) { $i }\nmacro foo($i: ident) { $i }\n\nfoo!(bar!(baz));\n```\n\n----------------------------------------\n\nTITLE: Collapsible-If Pattern with Functional Composition\nDESCRIPTION: Example of how the collapsible-if pattern could be simplified using proposed functional composition for patterns. This approach allows defining reusable subpatterns that can be shared between different lints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    fn expr_or_semi(expr: Expr) -> Stmt {\n        Expr(expr) | Semi(expr)\n    }\n    fn if_or_if_let(then: Block, else: Opt<Expr>) -> Expr {\n        If(_, then, else) | IfLet(then, else)\n    }\n    pat_if_else: Expr =\n        if_or_if_let(\n            _,\n            Block_(\n                Block(\n                    expr_or_semi( if_or_if_let(_, _?)#else_ )\n                )#block_inner\n            )#block\n        )\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Structure\nDESCRIPTION: Hierarchical table of contents for Rust project documentation, organized into major sections including installation, configuration, features, and contributing guidelines. Links to individual markdown files for each topic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/SUMMARY.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Summary\n\n- [Introduction](README.md)\n- [Installation](installation.md)\n  - [VS Code](vs_code.md)\n  - [rust-analyzer Binary](rust_analyzer_binary.md)\n  - [Other Editors](other_editors.md)\n- [Troubleshooting](troubleshooting.md)\n- [Configuration](configuration.md)\n  - [Non-Cargo Based Projects](non_cargo_based_projects.md)\n- [Security](security.md)\n- [Privacy](privacy.md)\n- [Features](features.md)\n  - [Assists (Code Actions)](assists.md)\n  - [Diagnostics](diagnostics.md)\n- [Editor Features](editor_features.md)\n- [Contributing](contributing/README.md)\n  - [Architecture](contributing/architecture.md)\n  - [Debugging](contributing/debugging.md)\n  - [Guide](contributing/guide.md)\n  - [LSP Extensions](contributing/lsp-extensions.md)\n  - [Setup](contributing/setup.md)\n  - [Style](contributing/style.md)\n  - [Syntax](contributing/syntax.md)\n```\n\n----------------------------------------\n\nTITLE: Defining MSRV Aliases with msrv_aliases Macro - Rust\nDESCRIPTION: Shows usage of the msrv_aliases! macro to register a minimum supported Rust version (MSRV) alias for a lint. Here, the Sintax 1,45,0 { STR_STRIP_PREFIX } establishes STR_STRIP_PREFIX as a constant referencing Rust 1.45.0, to be used for feature gating lint suggestions. Place this in clippy_utils::msrvs for project-wide access. Dependencies: macro provided by Clippy utilities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nmsrv_aliases! {\n    ..\n    1,45,0 { STR_STRIP_PREFIX }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-vita tool\nDESCRIPTION: This command installs the `cargo-vita` tool, which is used for building and packaging Rust applications for the PlayStation Vita. This tool simplifies the process of creating VPK files from Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n\"cargo install cargo-vita\"\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee on Empty Struct\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct with no fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\n#[repr(transparent)]\nstruct NoField<'a, #[pointee] T: ?Sized> {}\n```\n\n----------------------------------------\n\nTITLE: Using Test Builder Wrappers with Rustdoc\nDESCRIPTION: These examples demonstrate how to use the --test-builder-wrapper flag to wrap calls to the test builder, similar to cargo's build.rustc-wrapper option. The flag can be used multiple times to nest wrappers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc -Zunstable-options --test-builder-wrapper /path/to/rustc-wrapper src/lib.rs\n$ rustdoc -Zunstable-options \\\n    --test-builder-wrapper rustc-wrapper1 \\\n    --test-builder-wrapper rustc-wrapper2 \\\n    --test-builder rustc \\\n    src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Rust Library for Hexagon QuRT OS (Shell)\nDESCRIPTION: Shell script to build a shared object (`.so`) for the Hexagon QuRT OS. It compiles a C wrapper (`wrap.c`) and links it with the pre-compiled Rust library (`.rlib`), core/compiler builtins, and the Hexagon SDK's shared C library (`libc.so`) using `clang` (or `hexagon-unknown-none-elf-clang`). Linker flags like `-fPIC`, `-shared`, `-nostdlib`, and symbol wrapping for memory allocation functions are used. Finally, it demonstrates running the shared object in emulation using `qemu-system-hexagon` with the QuRT `runelf.pbn` loader and `run_main_on_hexagon_sim`. Requires setting paths for Hexagon SDK (`hex_sdk_root`), toolchain (`hex_toolchain`), and the compiler (`cc`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n# Hexagon SDK, required for target libraries:\nhex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0\nhex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06\n\nsdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib\nq6_arch=v65\ng0_lib_path=${sdk_libs}/${q6_arch}/G0\npic_lib_path=${sdk_libs}/${q6_arch}/G0/pic\nrunelf=${hex_sdk_root}/rtos/qurt/computev65/sdksim_bin/runelf.pbn\nrmohs=${hex_sdk_root}/libs/run_main_on_hexagon/ship/hexagon_toolv86_${q6_arch}/run_main_on_hexagon_sim\n\n# Builds a library suitable for loading into \"run_main_on_hexagon_sim\" for\n# emulation or frpc shell on real target:\n${cc} --target=hexagon-unknown-none-elf -o testit.so \\\n    -fuse-ld=lld \\\n    -fPIC -shared \\\n    -nostdlib \\\n    -Wl,-Bsymbolic \\\n      -Wl,--wrap=malloc \\\n      -Wl,--wrap=calloc \\\n      -Wl,--wrap=free \\\n      -Wl,--wrap=realloc \\\n      -Wl,--wrap=memalign \\\n    -m${q6_arch} \\\n    wrap.c \\\n    target/hexagon-unknown-none-elf/${build_cfg}/libdemo2_hexagon.rlib \\\n    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \\\n    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \\\n    -Wl,-soname=testit \\\n    ${pic_lib_path}/libc.so\n\n# -Bsymbolic above for memory alloc funcs is necessary to access the heap on\n# target, but otherwise not required.\n\n# multi-stage loader: runelf => run_main_on_hexagon_sim => testit.so{`main`}\n${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon \\\n    -monitor none \\\n    -display none \\\n    -kernel ${runelf} \\\n    -append \"${rmohs} -- ./testit.so\"\n```\n\n----------------------------------------\n\nTITLE: Updating PR for Rust Style Compliance\nDESCRIPTION: Use this command to ensure that your pull request conforms to Rust's style guidelines before submission. It involves running the 'tidy' check, which is a part of the continuous integration process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./x test tidy --bless\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0689 Error with Numeric Literal in Rust\nDESCRIPTION: This code snippet shows an erroneous example that triggers the E0689 error by calling the 'neg()' method on an ambiguous floating-point literal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0689.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n2.0.neg(); // error!\n```\n\n----------------------------------------\n\nTITLE: Configuring disallowed-macros\nDESCRIPTION: Defines a list of macros that are disallowed in the code, specified as fully qualified paths. Defaults to an empty list (`[]`). Useful for enforcing coding standards and preventing the use of specific macros.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Fixed Trait Object Implementation with Explicit Type Parameter in Rust\nDESCRIPTION: Corrected example showing proper usage of trait objects by explicitly specifying the type parameter instead of relying on Self default. This resolves the E0393 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0393.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait A<T = Self> {}\n\nfn together_we_will_rule_the_galaxy(son: &dyn A<i32>) {} // Ok!\n```\n\n----------------------------------------\n\nTITLE: Defining an Exported Function in Rust\nDESCRIPTION: Example Rust code showing how to define a function that will be exported when using the -Zexport-executable-symbols flag. The #[no_mangle] attribute is essential to prevent name mangling and ensure the symbol is exported with its original name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/export-executable-symbols.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\nfn my_function() -> usize {\n    return 42;\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Artifact Notifications in JavaScript\nDESCRIPTION: This snippet defines the JSON structure emitted when the `--json=artifacts` flag is used, indicating that a file artifact has been generated during the Rust compilation process. The structure includes the type of message, the generated filename, and the kind of artifact produced. Dependencies include the Rust build tools that emit this JSON information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/json.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    /* Type of this message */\n    \"$message_type\": \"artifact\",\n    /* The filename that was generated. */\n    \"artifact\": \"libfoo.rlib\",\n    /* The kind of artifact that was generated. Possible values:\n       - \"link\": The generated crate as specified by the crate-type.\n       - \"dep-info\": The `.d` file with dependency information in a Makefile-like syntax.\n       - \"metadata\": The Rust `.rmeta` file containing metadata about the crate.\n       - \"asm\": The `.s` file with generated assembly\n       - \"llvm-ir\": The `.ll` file with generated textual LLVM IR\n       - \"llvm-bc\": The `.bc` file with generated LLVM bitcode\n       - \"mir\": The `.mir` file with rustc's mid-level intermediate representation.\n       - \"obj\": The `.o` file with generated native object code\n    */\n    \"emit\": \"link\"\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Hexadecimal Digits Error\nDESCRIPTION: This snippet shows an error situation where a hexadecimal integer literal (0x) is defined without any digits following the prefix. This should result in a compiler error indicating missing digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0x\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Span Contexts in Rust\nDESCRIPTION: This snippet illustrates how to compare the contexts of two spans using `span.ctxt()`. It checks if the contexts are equal to determine if the code is generated from the same macro expansion, enabling precise analysis.  The goal is to prevent linting code modified by the user. The code requires two valid spans, `left.span` and `right.span` and checks their context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nif left.span.ctxt() != right.span.ctxt() {\n    // the coder most likely cannot modify this expression\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Job for Miri\nDESCRIPTION: This snippet demonstrates a GitHub Actions job configuration for running Miri. It checks out the code, installs Miri, sets up the environment, and then runs the tests using `cargo miri test`. The explicit `cargo miri setup` command helps to maintain clean test output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n\"miri:\n    name: \\\"Miri\\\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install Miri\n        run: |\n          rustup toolchain install nightly --component miri\n          rustup override set nightly\n          cargo miri setup\n      - name: Test with Miri\n        run: cargo miri test\"\n```\n\n----------------------------------------\n\nTITLE: Configuring ALE for Rust Analyzer\nDESCRIPTION: This Vim script configures the ALE plugin to use the rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_8\n\nLANGUAGE: Vim Script\nCODE:\n```\nlet g:ale_linters = {'rust': ['analyzer']}\n```\n\n----------------------------------------\n\nTITLE: Exploring Semantic Lifetime Equality in Rust Opaque Types\nDESCRIPTION: These examples cover semantic lifetime equality where two lifetimes may be syntactically different but semantically equal. The first and second functions highlight invalid lifetime setups due to semantic analysis, which causes errors in the uniqueness constraint enforcement of opaque type definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// This is also invalid because `'a` is *semantically* equal to `'static`.\nfn still_bad_1<'a: 'static>() -> Opaque<'a> {}\n//~^ Should error!\n\n// This is also invalid because `'a` and `'b` are *semantically* equal.\nfn still_bad_2<'a: 'b, 'b: 'a>() -> Opaque<'a, 'b> {}\n//~^ Should error!\n\n```\n\n----------------------------------------\n\nTITLE: Verbose Assembly Output\nDESCRIPTION: Enhanced assembly output with LLVM's contextual comments enabled via -Zverbose-asm flag, providing additional information about basic blocks and instructions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/verbose-asm.md#2025-04-21_snippet_2\n\nLANGUAGE: asm\nCODE:\n```\nfoo:                                    # @foo\n# %bb.0:\n        push    rax\n        add     edi, esi\n        mov     dword ptr [rsp + 4], edi        # 4-byte Spill\n        seto    al\n        jo      .LBB0_2\n# %bb.1:\n        mov     eax, dword ptr [rsp + 4]        # 4-byte Reload\n        pop     rcx\n        ret\n.LBB0_2:\n        lea     rdi, [rip + .L__unnamed_1]\n        mov     rax, qword ptr [rip + core::panicking::panic_const::panic_const_add_overflow::h9c85248fe0d735b2@GOTPCREL]\n        call    rax\n                                        # -- End function\n.L__unnamed_2:\n        .ascii  \"/app/example.rs\"\n\n.L__unnamed_1:\n        .quad   .L__unnamed_2\n        .asciz  \"\\017\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\005\\000\\000\"\n\n                                        # DW_AT_external\n```\n\n----------------------------------------\n\nTITLE: Handling Closure Mutability in Rust\nDESCRIPTION: This code snippet demonstrates an error where a closure attempts to mutate an immutable variable, which is not allowed in Rust. The corrected version modifies the variable binding to be mutable, allowing the closure to function correctly. No specific dependencies are required, but understanding of Rust's mutability rules is essential. The expected outcome is a successfully compiled program without mutability errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0595.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet x = 3; // error: closure cannot assign to immutable local variable `x`\nlet mut c = || { x += 1 };\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut x = 3; // ok!\nlet mut c = || { x += 1 };\n```\n\n----------------------------------------\n\nTITLE: Final Report Generation with Doc Tests Support\nDESCRIPTION: This enhanced `llvm-cov` reporting includes documentation tests by processing doc test binaries located in a specific output directory. The bash snippet ensures only executable binaries are included in the report command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ llvm-cov report \\\n    $( \\\n      for file in \\\n        $( \\\n          RUSTFLAGS=\"-C instrument-coverage\" \\\n          RUSTDOCFLAGS=\"-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n            cargo test --no-run --message-format=json \\\n              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n              | grep -v dSYM - \\\n        ) \\\n        target/debug/doctestbins/*/rust_out; \\\n      do \\\n        [[ -x $file ]] && printf \"%s %s \" -object $file; \\\n      done \\\n    ) \\\n  --instr-profile=json5format.profdata --summary-only # and/or other options\n```\n\n----------------------------------------\n\nTITLE: Syncing Changes from rust-lang/rust to Clippy using git subtree\nDESCRIPTION: This snippet outlines the command to push updates from the rust-lang/rust repository’s source subtree of Clippy to a local Clippy fork. It emphasizes the importance of using a separate branch for the operation and ensures changes are correctly integrated. Additional commands for creating a merge commit in the Clippy repository are provided to resolve conflicts during the sync process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/sync.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit subtree push -P src/tools/clippy clippy-local rustup\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch upstream\ngit switch rustup\ngit merge upstream/master --no-ff\n```\n\n----------------------------------------\n\nTITLE: Handling Canceled Errors in Request Processing (Rust)\nDESCRIPTION: This code catches canceled errors that occur when a client sends modifications immediately after completion requests, ensuring graceful handling of interruptions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/dispatch.rs#L292\n```\n\n----------------------------------------\n\nTITLE: Building Rust Programs for M68K Target\nDESCRIPTION: Command to build Rust programs for the M68K target using Cargo. This uses the cross-compilation setup specified in the Cargo configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --target m68k-unknown-none-elf\n```\n\n----------------------------------------\n\nTITLE: PrintOnDrop Type Definition for Drop Check Examples\nDESCRIPTION: Definition of a type that requires its region parameter to be live, used to demonstrate drop checking behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/drop_check.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct PrintOnDrop<'a>(&'a str);\nimpl<'a> Drop for PrintOnDrop<'_> {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Generic SIMD Struct Implementation in Rust\nDESCRIPTION: Example showing incorrect usage of #[repr(simd)] with generic type parameter T, which is not allowed because SIMD operations require concrete types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0074.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad<T>([T; 4]);\n```\n\n----------------------------------------\n\nTITLE: Correct Main Function Declaration in Rust\nDESCRIPTION: This snippet shows the correct way to declare the `main` function in Rust. It accepts no arguments. The program's entry point is the `main` function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0580.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nfn main() {\n    // your code\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Internal Representation of a Generic Reference Type\nDESCRIPTION: Illustrates the Rust compiler's internal pseudo-code representation for the type `&'a Vec<T>` within a generic function `fn foo<'a, T>`. It demonstrates the use of `RegionKind::LateParam` for the late-bound lifetime parameter `'a` and `TyKind::Param` for the type parameter `T`, which is assigned index 0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/param_ty_const_regions.md#_snippet_0\n\nLANGUAGE: Pseudo-code\nCODE:\n```\nTyKind::Ref(\n  RegionKind::LateParam(DefId(foo), DefId(foo::'a), \"'a\"),\n  TyKind::Adt(Vec, &[TyKind::Param(\"T\", 0)])\n)\n```\n\n----------------------------------------\n\nTITLE: Correcting Cast: Dereferencing &u8 in Rust\nDESCRIPTION: Shows the proper way to cast a `&u8` to `u32` by first dereferencing the reference to access the underlying value. This example highlights a common pattern of dereferencing before casting to ensure type compatibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0606.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"let x = &0u8;\\nlet y: u32 = *x as u32; // We dereference it first and then cast it.\\n\"\n```\n\n----------------------------------------\n\nTITLE: Updating nightly version in Clippy repository\nDESCRIPTION: This snippet demonstrates how to bump the nightly Rust version within the Clippy repository. It includes running a cargo command to update the version, followed by committing the changes to relevant files like rust-toolchain.toml and README.md. This process ensures Clippy remains compatible with the latest nightly Rust updates before submitting a pull request.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/sync.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev sync update_nightly\ngit commit -m \"Bump nightly version -> YYYY-MM-DD\" rust-toolchain.toml clippy_utils/README.md\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_8 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_8` function in Rust, passing two instances of the struct `S3`. Each struct `S3` contains an array of integers. This example shows how structs containing arrays can be passed. `stdcall` convention is used, and the expected output will depend on the definition of `stdcall_fn_8`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Borrowing in Async Closures (Rust)\nDESCRIPTION: This example illustrates how mutable borrowing in a coroutine affects the lifetime of the borrow. It shows that when mutably borrowing from a parent capture, the borrow cannot live longer than either the parent or the original upvar borrow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 1i32;\nlet c = async || {\n    x = 1;\n    // The parent borrows `x` for some `&'1 mut i32`.\n    // However, when we call `c()`, we implicitly autoref for the signature of\n    // `AsyncFnMut::async_call_mut`. Let's call that lifetime `'call`. Since\n    // the maximum that `&'call mut &'1 mut i32` can be reborrowed is `&'call mut i32`,\n    // the inner coroutine should capture w/ the lifetime of the coroutine-closure.\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust libc Package Metadata and Dependencies\nDESCRIPTION: A JSON object containing the configuration for the Rust libc crate, including package metadata variables, version information, repository details, dependencies, and path settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model_with_wildcard_overrides.txt#2025-04-21_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n                \"CARGO_PKG_LICENSE_FILE\": \"\",\n                \"CARGO_PKG_NAME\": \"libc\",\n                \"CARGO_PKG_README\": \"README.md\",\n                \"CARGO_PKG_REPOSITORY\": \"https://github.com/rust-lang/libc\",\n                \"CARGO_PKG_RUST_VERSION\": \"\",\n                \"CARGO_PKG_VERSION\": \"0.2.98\",\n                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n                \"CARGO_PKG_VERSION_PRE\": \"\",\n            },\n        },\n        dependencies: [],\n        origin: Library {\n            repo: Some(\n                \"https://github.com/rust-lang/libc\",\n            ),\n            name: \"libc\",\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: Some(\n            AbsPathBuf(\n                \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n            ),\n        ),\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring Discovered Tests in TypeScript\nDESCRIPTION: Describes TestItem structure, which encapsulates ID, location, hierarchy, and execution details for discovered test items in Rust projects. This layout aids in visualizing and managing test trees and executes within IDE environments that support Rust analysis via TypeScript.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TestItem {\n    id: string;\n    textDocument?: lc.TextDocumentIdentifier | undefined;\n    range?: lc.Range | undefined;\n    label: string;\n    kind: \"package\" | \"module\" | \"test\";\n    canResolveChildren: boolean;\n    parent?: string | undefined;\n    runnable?: Runnable | undefined;\n};\n\ninterface DiscoverTestResults {\n    tests: TestItem[];\n    scope: string[] | undefined;\n    scopeFile: lc.TextDocumentIdentifier[] | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: MIR Representation of Variable Declarations\nDESCRIPTION: This MIR snippet shows how variable declarations are represented in MIR, including the return place, user-defined variables, and temporary values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/index.md#2025-04-21_snippet_1\n\nLANGUAGE: mir\nCODE:\n```\nlet mut _0: ();                      // return place\nlet mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:16\nlet mut _2: ();\nlet mut _3: &mut std::vec::Vec<i32>;\nlet mut _4: ();\nlet mut _5: &mut std::vec::Vec<i32>;\n```\n\n----------------------------------------\n\nTITLE: Profiling with RA_PROFILE\nDESCRIPTION: This snippet shows how to use the `RA_PROFILE` environment variable to enable hierarchical profiling in rust-analyzer. It allows filtering by entry name, specifying depth, and setting a minimum execution time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nRA_PROFILE=*             // dump everything\nRA_PROFILE=foo|bar|baz   // enabled only selected entries\nRA_PROFILE=*@3>10        // dump everything, up to depth 3, if it takes more than 10 ms\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to rustc Fork with Bash\nDESCRIPTION: This snippet details how to push Miri changes back to the rustc fork, setting up a new branch for those changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n./miri rustc-push YOUR_NAME miri\n```\n\n----------------------------------------\n\nTITLE: Implementing AliasRelate for Structural Normalization in Rust\nDESCRIPTION: This code snippet shows how AliasRelate is implemented to structurally normalize both the left-hand side and right-hand side, then relate the resulting rigid types or inference variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/normalization.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Source: structural-relate\nlet lhs = self.structural_norm(lhs)?;\nlet rhs = self.structural_norm(rhs)?;\n\nlet lhs_is_alias = lhs.is_alias();\nlet rhs_is_alias = rhs.is_alias();\n\nif lhs_is_alias || rhs_is_alias {\n    self.evaluator.equate(lhs, rhs);\n    Ok(())\n} else {\n    self.evaluator.relate(Variance::Invariant, lhs, rhs)\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Duplicate Method Names in Rust\nDESCRIPTION: This Rust snippet resolves error E0592 by providing two impl blocks for struct Foo, where each block contains methods with distinct names. The example illustrates how to define methods properly to avoid naming conflicts, where 'bar' and 'baz' are unique method names within the same implementation scope.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0592.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar() {}\n}\n\nimpl Foo {\n    fn baz() {} // define with different name\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Module Symbol Metadata Structure\nDESCRIPTION: Detailed representation of module symbols with associated metadata, tracking file-level information and struct definitions\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_doc_alias.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nModule {\n    id: ModuleId {\n        krate: Idx::<CrateData>(0),\n        block: None,\n        local_id: Idx::<ModuleData>(0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Char Casting from u32\nDESCRIPTION: Demonstrates an incorrect attempt to cast a u32 to char, which is not allowed in Rust. Only u8 can be directly cast to char.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0604.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n0u32 as char; // error: only `u8` can be cast as `char`, not `u32`\n```\n\n----------------------------------------\n\nTITLE: Single Line Functions - False\nDESCRIPTION: Demonstrates the default behavior for single-expression functions when `fn_single_line` is `false`.  Functions are formatted on multiple lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() -> usize {\n    42\n}\n\nfn lorem() -> usize {\n    let ipsum = 42;\n    ipsum\n}\n```\n\n----------------------------------------\n\nTITLE: Watching Fuchsia Emulator Logs\nDESCRIPTION: Command to watch logs from the Fuchsia emulator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx log \\\n    --since now\n```\n\n----------------------------------------\n\nTITLE: QEMU Execution Command for ARM RTEMS Binary\nDESCRIPTION: Shell command to execute a compiled binary on QEMU emulator for Xilinx Zynq A9 architecture with specific hardware configuration parameters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-rtems-eabihf.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nqemu-system-arm -no-reboot -serial null -serial mon:stdio -net none -nographic -M xilinx-zynq-a9 -m 512M -kernel <binary file>\n```\n\n----------------------------------------\n\nTITLE: Configuring disallowed-names\nDESCRIPTION: Specifies a list of names (variables, functions, etc.) that are disallowed. Defaults to `[\"foo\", \"baz\", \"quux\"]`. The special value \"..\" allows appending to the default list.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Building and Running Example (CFI Enabled)\nDESCRIPTION: This shell script compiles the C library and the Rust code, then executes the compiled Rust binary. The key difference from the previous script is the inclusion of `-fsanitize=cfi` and other CFI-related flags in the C compilation step and the `RUSTFLAGS`.  This enables Control Flow Integrity during compilation and linking. The expectation is that when CFI is enabled, the second call to `do_twice` with the transmuted function should lead to program termination due to a violation of CFI rules, which is confirmed by the \"Illegal instruction\" output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\n$ make\nmkdir -p target/release\nclang -I. -Isrc -Wall -flto -fsanitize=cfi -fsanitize-cfi-icall-experimental-normalize-integers -fvisibility=hidden -c -emit-llvm src/foo.c -o target/release/libfoo.bc\nllvm-ar rcs target/release/libfoo.a target/release/libfoo.bc\nRUSTFLAGS=\"-L./target/release -Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers\" cargo build -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu\n   ...\n   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)\n    Finished release [optimized] target(s) in 1m 06s\n$ ./target/x86_64-unknown-linux-gnu/release/rust-cfi-4\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nIllegal instruction\n$\n```\n\n----------------------------------------\n\nTITLE: Associated Type Defaults vs RPITIT\nDESCRIPTION: This Rust code demonstrates a scenario where using associated type defaults instead of RPITIT fails. The core issue is that associated type defaults can't be assumed inside the trait defining them, leading to type mismatches if the impl doesn't provide a specific implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(impl_trait_in_assoc_type)]\n#![feature(associated_type_defaults)]\n\ntrait Foo {\n    type RPITIT = impl Sized;\n\n    fn bar() -> Self::RPITIT {\n        01i32\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Unconstrained Type Parameter in Trait Implementation Error Example\nDESCRIPTION: This code shows another E0207 error example where a type parameter T is used in a trait implementation but isn't constrained by the implementing type or trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Maker {\n    type Item;\n    fn make(&mut self) -> Self::Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl<T: Default> Maker for FooMaker {\n// error: the type parameter `T` is not constrained by the impl trait, self\n// type, or predicates [E0207]\n    type Item = Foo<T>;\n\n    fn make(&mut self) -> Foo<T> {\n        Foo { foo: <T as Default>::default() }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Drop-Check Rules Example in Rust\nDESCRIPTION: Demonstrates an invalid recursive enum definition that causes the E0320 compiler error. The example shows how recursive type definitions can create impossible drop-check scenarios where dropping a value would lead to infinite recursion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0320.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum A<T> {\n    B,\n    C(T, Box<A<(T, T)>>)\n}\n\nfn foo<T>() {\n    A::<T>::B; // error: overflow while adding drop-check rules for A<T>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom XRay Instrumentation Settings in Rust\nDESCRIPTION: Customize XRay instrumentation settings by specifying options after the -Z instrument-xray flag. Multiple settings can be separated by commas.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/instrument-xray.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n-Z instrument-xray=skip-exit\n```\n\nLANGUAGE: rust\nCODE:\n```\n-Z instrument-xray=ignore-loops,instruction-threshold=300\n```\n\n----------------------------------------\n\nTITLE: Profiling Cargo Check Performance\nDESCRIPTION: Command to profile the performance of cargo check on a specific crate by touching a source file to force recompilation and using perf to record execution data. This focuses on just the target crate's compilation time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntouch src/lib.rs\nCARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib\n```\n\n----------------------------------------\n\nTITLE: Erroneous Implementation with Mismatched Associated Const in Rust\nDESCRIPTION: This example shows the error E0323 that occurs when implementing a trait with an associated const (N) when the trait actually defines it as an associated type. The compiler will raise an error because the item types don't match.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0323.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type N;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    const N : u32 = 0;\n    // error: item `N` is an associated const, which doesn't match its\n    //        trait `<Bar as Foo>`\n}\n```\n\n----------------------------------------\n\nTITLE: String and Byte String Literal Patterns with Deref Patterns\nDESCRIPTION: This code demonstrates the use of string and byte string literal patterns within `deref!(_)` patterns when `deref_patterns` is enabled. It showcases how string literals can be matched against `String` types and byte string literals against `Vec<u8>` types, simplifying pattern matching. It also shows how string literals can be used directly in match statements due to the implicit deref coercion behavior. Requires `deref_patterns` and `incomplete_features` feature flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/deref-patterns.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(deref_patterns)]\n# #![allow(incomplete_features)]\nmatch (\"test\".to_string(), b\"test\".to_vec()) {\n    (deref!(\"test\"), deref!(b\"test\")) => {}\n    _ => panic!(),\n}\n\n// Matching on slices and arrays using literals is possible elsewhere as well:\nmatch *\"test\" {\n    \"test\" => {}\n    _ => panic!(),\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Static Closure Usage in Rust\nDESCRIPTION: This code snippet shows an erroneous attempt to use a closure as a static element. Closures cannot be static because they capture their environment, which would be limited to only static variables if allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0697.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    static || {}; // used as `static`\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Enum Field Offsets in Rust\nDESCRIPTION: Demonstrates how to use the offset_of! macro with the offset_of_enum feature to calculate memory offsets of fields within enum variants. Shows examples with both tuple-style and struct-style enum variants, as well as Option types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/offset-of-enum.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(offset_of_enum)]\nuse std::mem;\n\n#[repr(u8)]\nenum Enum {\n    A(u8, u16),\n    B { one: u8, two: u16 },\n}\n\nassert_eq!(mem::offset_of!(Enum, A.0), 1);\nassert_eq!(mem::offset_of!(Enum, B.two), 2);\n\nassert_eq!(mem::offset_of!(Option<&u8>, Some.0), 0);\n```\n\n----------------------------------------\n\nTITLE: Setting Up for Benchmark Profiling\nDESCRIPTION: Commands to prepare a specific benchmark (clap-rs) for profiling by cleaning previous builds and checking dependencies. This ensures a clean environment for accurate profiling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo +<toolchain> clean\nCARGO_INCREMENTAL=0 cargo +<toolchain> check\n```\n\n----------------------------------------\n\nTITLE: Fixing 'Not a Git Repository' Submodule Errors by Removing Git Metadata - text/bash\nDESCRIPTION: This multi-step process addresses errors caused by broken or missing git submodule metadata, typically 'fatal: not a git repository' errors referencing .git/modules paths. The steps involve removing the submodule's internal .git directory, deleting the corresponding module config directory in .git/modules, and removing orphaned .gitconfig lock files. After cleanup, the repository can be bootstrapped again to fix submodule states.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\n1. rm -rf <submodule_path>/.git\n2. rm -rf .git/modules/<submodule_path>/config\n3. rm -rf .gitconfig.lock\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Parameter Shadowing in Traits\nDESCRIPTION: Example demonstrating incorrect shadowing of trait type parameters in associated functions, which results in error E0403.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0403.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<T> {\n    fn do_something(&self) -> T;\n    fn do_something_else<T: Clone>(&self, bar: T);\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround: Drop Implementation Using Trait Object Wrapper Struct (Rust)\nDESCRIPTION: This code shows an alternative valid workaround for implementing Drop where the wrapper struct contains a trait object reference. This approach works with dynamic trait objects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0120.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {}\n\n// or Box<dyn MyTrait>, if you wanted an owned trait object\nstruct MyWrapper<'a> { foo: &'a dyn MyTrait }\n\nimpl <'a> Drop for MyWrapper<'a> {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Item Single Line - False Example\nDESCRIPTION: Example showing how rustfmt handles empty functions and impls when `empty_item_single_line` is set to `false`. With this option disabled, empty functions and impls are formatted with braces on separate lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {\n}\n\nimpl Lorem {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Package Metadata for libc Crate in Rust\nDESCRIPTION: This snippet defines various Cargo package metadata fields for the libc crate, including license, version, and repository information. It's typically used in Cargo.toml or generated during the build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model_with_selective_overrides.txt#2025-04-21_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"CARGO_PKG_LICENSE\": \"MIT OR Apache-2.0\",\n    \"CARGO_PKG_LICENSE_FILE\": \"\",\n    \"CARGO_PKG_NAME\": \"libc\",\n    \"CARGO_PKG_README\": \"README.md\",\n    \"CARGO_PKG_REPOSITORY\": \"https://github.com/rust-lang/libc\",\n    \"CARGO_PKG_RUST_VERSION\": \"\",\n    \"CARGO_PKG_VERSION\": \"0.2.98\",\n    \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n    \"CARGO_PKG_VERSION_MINOR\": \"2\",\n    \"CARGO_PKG_VERSION_PATCH\": \"98\",\n    \"CARGO_PKG_VERSION_PRE\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Dataflow State Peeking for Uninitialization in Rust Compiler\nDESCRIPTION: This `#[rustc_mir]` attribute applied to a function enables the `rustc_peek` intrinsic calls within that function to query the dataflow state specifically related to the 'maybe uninitialized' analysis. Similar to `rustc_peek_maybe_init`, it triggers an error if the relevant dataflow bit for the Lvalue is not set at the peek point, supporting unit tests for uninitialization analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/mir-dataflow/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[rustc_mir(rustc_peek_maybe_uninit)]\n```\n\n----------------------------------------\n\nTITLE: Using type_alias_impl_trait with #[define_opaque]\nDESCRIPTION: This example demonstrates how to use `type_alias_impl_trait` with the `#[define_opaque]` attribute to create a type alias for an `impl Trait` type. It shows how the same concrete type is used across multiple functions while keeping it hidden.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/type-alias-impl-trait.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(type_alias_impl_trait)]\n# #![allow(unused_variables, dead_code)]\ntrait Trait {}\n\nstruct MyType;\n\nimpl Trait for MyType {}\n\ntype Alias = impl Trait;\n\n#[define_opaque(Alias)] // To constrain the type alias to `MyType`\nfn new() -> Alias {\n    MyType\n}\n\n#[define_opaque(Alias)] // So we can name the concrete type inside this item\nfn main() {\n    let thing: MyType = new();\n}\n\n// It can be a part of a struct too\nstruct HaveAlias {\n    stuff: String,\n    thing: Alias,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Generic Arguments Usage in Rust\nDESCRIPTION: Examples of incorrect generic argument usage that will fail to compile. Shows common mistakes like providing too few or too many type arguments for structs and functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0107.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for Tcmalloc Slab Functions in Rust\nDESCRIPTION: This snippet marks Tcmalloc slab-related functions as uninstrumented and discarded for DFSan. These functions handle internal memory management operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfun:TcmallocSlab_Internal_PushBatch_FixedShift=uninstrumented\nfun:TcmallocSlab_Internal_PushBatch_FixedShift=discard\nfun:TcmallocSlab_Internal_PushBatch_FixedShift_VCPU=uninstrumented\nfun:TcmallocSlab_Internal_PushBatch_FixedShift_VCPU=discard\nfun:TcmallocSlab_Internal_PerCpuCmpxchg64=uninstrumented\nfun:TcmallocSlab_Internal_PerCpuCmpxchg64=discard\nfun:TcmallocSlab_Internal_PerCpuCmpxchg64_VCPU=uninstrumented\nfun:TcmallocSlab_Internal_PerCpuCmpxchg64_VCPU=discard\nfun:TcmallocSlab_Internal_PopBatch_FixedShift=uninstrumented\nfun:TcmallocSlab_Internal_PopBatch_FixedShift=discard\nfun:TcmallocSlab_Internal_PopBatch_FixedShift_VCPU=uninstrumented\nfun:TcmallocSlab_Internal_PopBatch_FixedShift_VCPU=discard\n```\n\n----------------------------------------\n\nTITLE: Casting to Unsized Type in Rust\nDESCRIPTION: This snippet illustrates an error when attempting to cast to an unsized type in Rust. An error occurs because Rust requires that such types be handled through references. The erroneous example attempts to cast an array directly, which results in a compile-time error due to the unknown size of the target type. The correct approach involves casting to a reference instead.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0620.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = &[1_usize, 2] as [usize]; // error: cast to unsized type: `&[usize; 2]`\n                                  //        as `[usize]`\n```\n\n----------------------------------------\n\nTITLE: Setting Platform-Specific Runnable Environment Variables (JSON)\nDESCRIPTION: This example sets different environment variables based on the operating system platform. It allows users to specify platform-specific environment variables.  Requires VS Code and the Rust extension. The output defines the environment variables dependent on the platform specified.  The configuration is performed in settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n\"rust-analyzer.runnables.extraEnv\": [\n    {\n        \"platform\": \"win32\", // windows only\n        \"env\": {\n                \"APP_DATA\": \"windows specific data\"\n        }\n    },\n    {\n        \"platform\": [\"linux\"],\n        \"env\": {\n                \"APP_DATA\": \"linux data\",\n        }\n    },\n    { // for all platforms\n        \"env\": {\n                \"APP_COMMON_DATA\": \"xxx\",\n        }\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Correct Enum with Discriminants and Repr Attribute in Rust\nDESCRIPTION: This code snippet shows the correct implementation of an enum with discriminants, using the #[repr(u8)] attribute. It includes a function to extract the discriminant from a value, demonstrating how the attribute ensures a well-defined way to access the discriminant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0732.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(u8)]\nenum Enum {\n    Unit = 3,\n    Tuple(u16) = 2,\n    Struct {\n        a: u8,\n        b: u16,\n    } = 1,\n}\n\nfn discriminant(v : &Enum) -> u8 {\n    unsafe { *(v as *const Enum as *const u8) }\n}\n\nfn main() {\n    assert_eq!(3, discriminant(&Enum::Unit));\n    assert_eq!(2, discriminant(&Enum::Tuple(5)));\n    assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Matching Method Return Value\nDESCRIPTION: This code shows the correct way to match against the return value of a method. It first binds the matched value to a variable (e.g., `x`) and then uses a guard to compare the bound value with the result of calling the method. This allows for a valid match expression.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0533.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nstruct Tortoise;\n\nimpl Tortoise {\n    fn turtle(&self) -> u32 { 0 }\n}\n\nmatch 0u32 {\n    x if x == Tortoise.turtle() => {} // Bound into `x` then we compare it!\n    _ => {}\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running CI Jobs with Cargo Tool\nDESCRIPTION: Uses the Rust cargo tool to execute CI jobs locally in Docker containers, providing a way to run tests that closely matches the CI environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/docker.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --manifest-path src/ci/citool/Cargo.toml run-local <job-name>\n# For example:\ncargo run --manifest-path src/ci/citool/Cargo.toml run-local dist-x86_64-linux-alt\n```\n\n----------------------------------------\n\nTITLE: Correct Export Name Attribute Usage in Rust\nDESCRIPTION: This code snippet shows the correct way to use the `export_name` attribute without null characters, resolving the E0648 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0648.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[export_name=\"foo\"] // ok!\npub fn bar() {}\n```\n\n----------------------------------------\n\nTITLE: Breaking Boxed Types with `+` Operator in Rust\nDESCRIPTION: This snippet demonstrates breaking types that are boxed (`Box<...>`) and use the `+` operator (e.g., trait bounds). It advises breaking before each `+` and block-indenting the subsequent lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/types.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"Box<\n    Clone\n    + Copy\n    + Debug\n>\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Inline Attribute Syntax\nDESCRIPTION: Demonstrates an erroneous use of the inline attribute with empty parentheses, which causes a compilation error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0534.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[inline()] // error: expected one argument\npub fn something() {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Printing Rust TLS Models\nDESCRIPTION: Demonstrates how to list available Thread Local Storage models using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print tls-models a.rs\nAvailable TLS models:\n    global-dynamic\n    local-dynamic\n    initial-exec\n    local-exec\n    emulated\n```\n\n----------------------------------------\n\nTITLE: Cargo Build Output for Macro Tracing\nDESCRIPTION: This snippet shows the output of `cargo build` when using the `trace_macros` feature. It displays the expansion of the `println!` macro, including intermediate steps and the final expanded form.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/trace-macros.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nnote: trace_macro\n --> src/main.rs:5:5\n  |\n5 |     println!(\"Hello, Rust!\");\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: expanding `println! { \"Hello, Rust!\" }`\n  = note: to `print ! ( concat ! ( \"Hello, Rust!\" , \"\\n\" ) )`\n  = note: expanding `print! { concat ! ( \"Hello, Rust!\" , \"\\n\" ) }`\n  = note: to `$crate :: io :: _print ( format_args ! ( concat ! ( \"Hello, Rust!\" , \"\\n\" ) )\n          )`\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs\n```\n\n----------------------------------------\n\nTITLE: Unsound Example of Type Alias Impl Trait in Rust\nDESCRIPTION: Demonstration of why non-generic type alias impl trait implementations are rejected, showing potential unsoundness. This example would allow creating incompatible types if it were accepted.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0792.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(type_alias_impl_trait)]\n\ntype Foo<T> = impl Default;\n\n#[define_opaque(Foo)]\nfn foo() -> Foo<u32> {\n    5u32\n}\n\nfn main() {\n    let x = Foo::<&'static mut String>::default();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Alloc - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `alloc` crate (index 0). It specifies the Rust edition (`Edition2021`), compiler configuration flags (`debug_assertions`, `miri`, `true`), and its dependency on the `core` crate (index 1). This data is used to model the crate's properties and its position within the dependency graph.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n0: CrateData {\n    root_file_id: FileId(\n        1,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"alloc\",\n            ),\n            canonical_name: \"alloc\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [\n        Dependency {\n            crate_id: Idx::<CrateData>(1),\n            name: CrateName(\n                \"core\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n    ],\n    origin: Lang(\n        Alloc,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Manage Representation Hints in Rust Enum Using cfg_attr\nDESCRIPTION: This snippet resolves conflicting representation hints in a Rust enum by employing conditional compilation with cfg_attr. It ensures the enum uses the appropriate representation based on the target architecture. There are no dependencies outside of standard Rust. The input is platform architecture, and output is an enum definition with a specific representation, either u32 or u64.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0566.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg_attr(linux, repr(u32))]\n#[cfg_attr(not(linux), repr(u64))]\nenum Repr { A }\n```\n\n----------------------------------------\n\nTITLE: Implementing One-step Normalization with NormalizesTo Goals in Rust\nDESCRIPTION: This code snippet shows how NormalizesTo goals are evaluated in the new solver. It demonstrates the special handling of these goals, where they are tracked separately from other goals and their ambiguous nested goals are returned to the caller.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/normalization.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Source: try-eval-norm\nif let Some(goal) = self.pending_norms.pop() {\n    let NormalizesTo { alias, ty } = goal.goal;\n    match self.evaluate_norm(alias, ty) {\n        Ok(()) => (),\n        Err(NoSolution) => return Ok(StepResult::NoSolution),\n        Err(Ambiguous(mut goals)) => {\n            self.ambiguous_goals.append(&mut goals);\n            return Ok(StepResult::Continues);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Clippy's custom cargo dev tools - Bash\nDESCRIPTION: Various cargo dev commands to facilitate development on Clippy, such as formatting code, managing lints, creating new lints, deprecating lints, setting up git hooks and IDE integration, and running dogfood tests. Each command helps with specific development and maintenance tasks related to Clippy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/basics.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev fmt\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev update_lints\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev new_lint\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev deprecate\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev setup git-hook\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev setup intellij\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev dogfood\n```\n\n----------------------------------------\n\nTITLE: Fixing Deprecated Attribute in Rust Code\nDESCRIPTION: This snippet demonstrates the improper use of deprecated attributes without pairing them with stable or unstable attributes in Rust. The error arises when staged API features are enabled. The snippet shows both erroneous and corrected code examples. Dependencies include enabling `#![feature(staged_api)]`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0549.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[deprecated(\\n    since = \\\"1.0.1\\\",\\n    note = \\\"explanation for deprecation\\\"\\n)] // invalid\\nfn _deprecated_fn() {}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(staged_api)]\\n#![allow(internal_features)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n#[deprecated(\\n    since = \\\"1.0.1\\\",\\n    note = \\\"explanation for deprecation\\\"\\n)] // ok!\\nfn _deprecated_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Building and running CFI-enabled code in Rust\nDESCRIPTION: Shell commands demonstrating how to build and run the example with CFI protection enabled. With CFI, the invalid control flow attempt is detected and the program terminates with an 'Illegal instruction' error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi\" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu\n   ...\n   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)\n    Finished release [optimized] target(s) in 1m 08s\n     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-1`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nIllegal instruction\n$\n```\n\n----------------------------------------\n\nTITLE: Defining Domain Goals\nDESCRIPTION: This snippet defines the structure of a DomainGoal, which includes Holds(WhereClause), FromEnv(TraitRef), FromEnv(Type), WellFormed(TraitRef), WellFormed(Type), and Normalize(Projection -> Type). It defines the WhereClause which can be Implemented(TraitRef), ProjectionEq(Projection = Type), Outlives(Type: Region), or Outlives(Region: Region).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n\"DomainGoal = Holds(WhereClause)\n            | FromEnv(TraitRef)\n            | FromEnv(Type)\n            | WellFormed(TraitRef)\n            | WellFormed(Type)\n            | Normalize(Projection -> Type)\n\nWhereClause = Implemented(TraitRef)\n            | ProjectionEq(Projection = Type)\n            | Outlives(Type: Region)\n            | Outlives(Region: Region)\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference Error Demonstration in Rust\nDESCRIPTION: This snippet shows an example of an erroneous Rust code where the type inference mechanism fails, causing a compilation error. It demonstrates the situation where the type checker cannot resolve a method call due to the unknown type of a variable. The erroneous behavior is highlighted to emphasize the need for type annotations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0619.md#2025-04-21_snippet_0\n\nLANGUAGE: compile_fail\nCODE:\n```\nlet mut x = vec![];\nmatch x.pop() {\n    Some(v) => {\n        // Here, the type of `v` is not (yet) known, so we\n        // cannot resolve this method call:\n        v.to_uppercase(); // error: the type of this value must be known in\n                          //        this context\n    }\n    None => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Coroutine with Multiple Parameters - Rust\nDESCRIPTION: This snippet shows an erroneous implementation of a coroutine in Rust with two parameters. It demonstrates that Rust currently restricts coroutines to accept either zero or one parameter. The code yields the first parameter, causing a compile-time error due to the violation of the coroutine parameter rule.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0628.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#!\\[feature(coroutines, coroutine_trait, stmt_expr_attributes)\\]\\n\\nfn main() {\\n    let coroutine = \\#\\[coroutine\\] |a: i32, b: i32| {\\n        // error: too many parameters for a coroutine\\n        // Allowed only 0 or 1 parameter\\n        yield a;\\n    };\\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ownership Error with Non-Copy Type in Rust\nDESCRIPTION: This snippet illustrates the error encountered when attempting to move a value from a non-copy fixed-size array. The type `NonCopy` does not implement the `Copy` trait, resulting in a compilation error when trying to move the element out of the array. It is important for developers to understand this limitation to avoid ownership issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0508.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n                           //        a non-copy fixed-size array\n}\n```\n\n----------------------------------------\n\nTITLE: Building and testing Clippy with cargo commands - Bash\nDESCRIPTION: Commands to build and test the Clippy project using cargo. It includes running the full build and test suites as well as filtering tests to run only UI tests or dogfood tests. Additionally, it explains how to update UI test reference files with `cargo bless` after test output changes to keep tests consistent.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/basics.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo build  # builds Clippy\ncargo test   # tests Clippy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# only run UI tests\ncargo uitest\n```\n\nLANGUAGE: bash\nCODE:\n```\n# only run UI tests starting with `test_`\nTESTNAME=\"test_\" cargo uitest\n```\n\nLANGUAGE: bash\nCODE:\n```\n# only run dogfood tests\ncargo dev dogfood\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo bless\n```\n\n----------------------------------------\n\nTITLE: Handling Thin and Wide Pointer Casting Error in Rust\nDESCRIPTION: This code snippet showcases an erroneous attempt to cast a thin pointer to a wide pointer. Thin pointers are simple references to memory addresses, while wide pointers relate to Dynamically Sized Types (DSTs) which require additional size information. The example demonstrates the compiler error E0607, indicating that such a cast is invalid.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0607.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"let v = core::ptr::null::<u8>();\\nv as *const [u8];\"\n```\n\n----------------------------------------\n\nTITLE: Correcting Type Inference with Annotations in Rust\nDESCRIPTION: This code snippet provides a corrected example by specifying the type of elements in the vector. By declaring the type explicitly, the Rust compiler can infer the method calls correctly, allowing the program to compile and execute without errors. This highlights the importance of type annotations in resolving type inference issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0619.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nlet mut x: Vec<String> = vec![]; // We precise the type of the vec elements.\nmatch x.pop() {\n    Some(v) => {\n        v.to_uppercase(); // Since rustc now knows the type of the vec elements,\n                          // we can use `v`'s methods.\n    }\n    None => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rustdoc Search Index JSON Structure\nDESCRIPTION: This JSON snippet illustrates the structure of the Rustdoc search index. It includes various fields like names, types, parent modules, function signatures, and other metadata for documenting Rust crates and their contents.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n    [ \"crate_name\", {\n        \"n\": [\"function_name\", \"Data\"],\n        \"t\": \"HF\",\n        \"q\": [[0, \"crate_name\"]],\n        \"i\": [2, 0],\n        \"p\": [[1, \"i32\"], [1, \"str\"], [5, \"Data\", 0]],\n        \"f\": \"{{gb}{d}}`\",\n        \"b\": [],\n        \"c\": \"OjAAAAAAAAA=\",\n        \"e\": \"OjAAAAAAAAA=\",\n        \"a\": [[\"get_name\", 0]],\n        \"D\": \"g\",\n        \"r\": []\n    }]\n]\n```\n\n----------------------------------------\n\nTITLE: Defining Rust File Symbols\nDESCRIPTION: This code snippet defines various Rust symbols including functions, structs, traits, and macros. It includes detailed metadata for each symbol such as its name, type, location, and container information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"generic_impl_fn\",\n    def: Function(\n        Function {\n            id: FunctionId(\n                2,\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: FN,\n            range: 307..330,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 310..325,\n            },\n        ),\n    },\n    container_name: Some(\n        \"StructT<T>\",\n    ),\n    is_alias: false,\n    is_assoc: true,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Macro with Kleene Operator in Rust\nDESCRIPTION: This code snippet demonstrates the definition of a macro in Rust using the `?` Kleene operator. The macro `foo` takes one required identifier argument and one optional identifier argument. It prints the value of both arguments using `println!` if they are provided.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/walkthrough.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! foo {\n    ($arg:ident $(, $optional_arg:ident)?) => {\n        println!(\"{}\", $arg);\n\n        $(\n            println!(\"{}\", $optional_arg);\n        )?\n    }\n}\n\nfn main() {\n    let x = 0;\n    foo!(x); // ok! prints \"0\"\n    foo!(x, x); // ok! prints \"0 0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Keybindings for Rust Projects (JSON)\nDESCRIPTION: This snippet configures a keybinding that is active only within Rust projects. The example defines a keybinding (Ctrl+Alt+D) to trigger the `rust-analyzer.openDocs` command. Requires VS Code and the Rust extension. The output activates the defined command when the specified key combination is pressed within a Rust project. The configuration happens within the `keybindings.json` file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"key\": \"ctrl+alt+d\",\n    \"command\": \"rust-analyzer.openDocs\",\n    \"when\": \"inRustProject\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_BOOTSTRAP in Run-Make Tests\nDESCRIPTION: Example demonstrating how to set RUSTC_BOOTSTRAP environment variable in run-make tests using the rustc() builder pattern to modify compiler behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/misc.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse run_make_support::rustc;\n\nfn main() {\n    rustc()\n        // Pretend that I am very stable\n        .env(\"RUSTC_BOOTSTRAP\", \"-1\")\n        //...\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Type Parameter Usage in Rust\nDESCRIPTION: Example showing incorrect usage of type parameters where a struct Foo with no type parameters is incorrectly used with type parameters S and T in another struct Bar. This code will fail to compile.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0244.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo { x: bool }\n\nstruct Bar<S, T> { x: Foo<S, T> }\n```\n\n----------------------------------------\n\nTITLE: Running Rustdoc GUI Tests in Debug Mode\nDESCRIPTION: Command to execute rustdoc GUI tests with detailed debugging output, running at stage 1 of the build process\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/rustdoc-gui/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ./x.py test tests/rustdoc-gui --stage 1 --test-args --debug\n```\n\n----------------------------------------\n\nTITLE: Converting let-else to Match Expression in Rust\nDESCRIPTION: Replaces let-else statement with a let statement and a match expression. Requires understanding of Rust's pattern matching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = match f() {\n        Ok(x) => x,\n        _ => return,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Compile-Fail Tests with Conditional Compilation in Rust\nDESCRIPTION: Demonstrates how to use #[cfg(doctest)] to add doctests that only appear when collecting tests but not in documentation. This example tests that a struct rejects negative numbers through a compile_fail test.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n/// We have a struct here. Remember it doesn't accept negative numbers!\npub struct MyStruct(pub usize);\n\n/// ```compile_fail\n/// let x = my_crate::MyStruct(-5);\n/// ```\n#[cfg(doctest)]\npub struct MyStructOnlyTakesUsize;\n```\n\n----------------------------------------\n\nTITLE: Correct Transparent Struct Definition with PhantomData in Rust\nDESCRIPTION: This code snippet shows the correct way to implement a transparent struct with generic types using `PhantomData` to avoid the E0690 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0690.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::marker::PhantomData;\n\n#[repr(transparent)]\nstruct LengthWithUnit<U> {\n    value: f32,\n    unit: PhantomData<U>,\n}\n```\n\n----------------------------------------\n\nTITLE: Refreshing Coverage Test Results\nDESCRIPTION: Shell commands to regenerate expected results for coverage-related test suites in the Rust compiler\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/llvm-coverage-instrumentation.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./x test coverage --bless\n./x test coverage-run-rustdoc --bless\n./x test tests/mir-opt --bless\n```\n\n----------------------------------------\n\nTITLE: FileCheck Prefix-Based Expectations in Rust\nDESCRIPTION: Shows how to define test expectations using custom prefixes for different test revisions, including SAME and NOT conditions\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/codegen/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// CHECK: expected code\n// aaa-SAME: emitted-only-for-aaa\n// aaa-NOT:                        emitted-only-for-bbb\n// bbb-NOT:  emitted-only-for-aaa\n// bbb-SAME:                       emitted-only-for-bbb\n```\n\n----------------------------------------\n\nTITLE: Handling Float Literal with Suffix and Missing Exponent in Rust Lexer\nDESCRIPTION: Illustrates how the Rust lexer processes floating-point literals that include a type suffix (like `f32`), an exponent symbol (`e` or `E`), and an optional sign (`+` or `-`) but are missing the required digits after the exponent. The lexer produces a `FLOAT_NUMBER` token with an error message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_exponent.txt#_snippet_4\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2e+f32\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2e-f32\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2E+f32\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42.2E-\" error: Missing digits after the exponent symbol\n```\n\n----------------------------------------\n\nTITLE: Error Example: Using packed representation on a struct with aligned field\nDESCRIPTION: This code demonstrates an erroneous case where a packed struct contains a field with an align representation hint, which is not allowed in Rust and will trigger error E0588.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0588.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(align(16))]\nstruct Aligned(i32);\n\n#[repr(packed)] // error!\nstruct Packed(Aligned);\n```\n\n----------------------------------------\n\nTITLE: Example Test File for foo_functions Lint in Rust\nDESCRIPTION: A UI test file for the 'foo_functions' lint that checks function names. It includes test cases for implementations, trait methods, and plain functions with annotations to mark expected lint triggers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(unused)]\n#![warn(clippy::foo_functions)]\n\n// Impl methods\nstruct A;\nimpl A {\n    pub fn fo(&self) {}\n    pub fn foo(&self) {}\n    //~^ foo_functions\n    pub fn food(&self) {}\n}\n\n// Default trait methods\ntrait B {\n    fn fo(&self) {}\n    fn foo(&self) {}\n    //~^ foo_functions\n    fn food(&self) {}\n}\n\n// Plain functions\nfn fo() {}\nfn foo() {}\n//~^ foo_functions\nfn food() {}\n\nfn main() {\n    // We also don't want to lint method calls\n    foo();\n    let a = A;\n    a.foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Turbo Fish to Generic Function Call in Rust\nDESCRIPTION: This assist adds `::<_>` to a call of a generic method or function. It inserts the turbo fish syntax with a placeholder for the type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn make<T>() -> T { todo!() }\nfn main() {\n    let x = make();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn make<T>() -> T { todo!() }\nfn main() {\n    let x = make::<${0:_}>();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Compile Failures with repr Attribute in Rust\nDESCRIPTION: This snippet demonstrates an incorrect use of a literal in a built-in attribute in Rust, resulting in a compilation error. It highlights the need to use identifiers instead of literals in certain attributes. The erroneous use of a quoted string in a repr attribute is specifically showcased, expecting to cause an error message. The main function acts as a simple entry point for the compilation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0565.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(\"C\")] // error: meta item in `repr` must be an identifier\nstruct Repr {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Module Error in Rust\nDESCRIPTION: This snippet demonstrates a Rust compile-time error indicating that a module file could not be found. It serves as an example for Rust developers to learn how to handle module imports correctly, specifically pointing out the need for accompanying file structure when declaring modules. The key parameters involve the module declaration and the main function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0583.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"compile_fail,E0583\\nmod file_that_doesnt_exist; // error: file not found for module\\n\\nfn main() {}\\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Custom Normalization Directives\nDESCRIPTION: This code snippet demonstrates the usage of custom normalization directives in UI tests. These directives allow you to define regular expression replacements to normalize the compiler output, ensuring consistency across different platforms and environments. This helps to avoid false positives due to platform-specific variations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//@ normalize-stdout: \"foo\" -> \"bar\"\n//@ normalize-stderr: \"foo\" -> \"bar\"\n//@ normalize-stderr-32bit: \"fn\\(\\) \\(32 bits\\)\" -> \"fn\\(\\) \\($$PTR bits\\)\"\n//@ normalize-stderr-64bit: \"fn\\(\\) \\(64 bits\\)\" -> \"fn\\(\\) \\($$PTR bits\\)\"\n```\n\n----------------------------------------\n\nTITLE: Correct Use of repr Attribute in Rust\nDESCRIPTION: This snippet demonstrates the correct use of the repr attribute in Rust, where an identifier is used instead of a literal. This approach is supported and compiles successfully, showcasing the necessary technique for using built-in attributes correctly without causing errors. The main function is included to complete the program structure, though it has no operational code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0565.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)] // ok!\nstruct Repr {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correcting Lifetime Usage in Rust\nDESCRIPTION: This snippet provides the corrected version of the previous code, appropriately assigning explicit lifetime names as identifiers. The corrections involve changing the lifetime identifier to a named lifetime such as `'a` or using a higher-ranked lifetime with `for` to resolve the compile failures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0637.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n```\nfn underscore_lifetime<'a>(str1: &'a str, str2: &'a str) -> &'a str {\n    if str1.len() > str2.len() {\n        str1\n    } else {\n        str2\n    }\n}\n\nfn without_explicit_lifetime<'a, T>()\nwhere\n    T: Iterator<Item = &'a u32>,\n{\n}\n\nfn without_hrtb<T>()\nwhere\n    T: for<'foo> Into<&'foo u32>,\n{\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Detailed Version Information Override in Rust Console\nDESCRIPTION: Shows a more detailed example using rustc -vV command with RUSTC_OVERRIDE_VERSION_STRING, demonstrating how the release version is overridden while maintaining original system information like commit hash and date.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/rustc-override-version-string.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ RUSTC_OVERRIDE_VERSION_STRING=\"1.81.0-nightly (aaaaaaaaa 2025-03-22)\" rustc -vV\nrustc 1.81.0-nightly (aaaaaaaaa 2025-03-22)\nbinary: rustc\ncommit-hash: 43f0014ef0f242418674f49052ed39b70f73bc1c\ncommit-date: 2025-03-25\nhost: x86_64-unknown-linux-gnu\nrelease: 1.81.0-nightly (aaaaaaaaa 2025-03-22)\nLLVM version: 20.1.1\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Stability Attributes - Erroneous Example\nDESCRIPTION: This snippet demonstrates an incorrect declaration of multiple stability attributes on a single function item in Rust. It illustrates the compiler error E0544, which arises when more than one stability attribute is applied to the same item. The faulty line is marked for clarity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0544.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#!['feature(staged_api)']\n#!['allow(internal_features)']\n#!['stable(since = \"1.0.0\", feature = \"rust1\")']\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[stable(feature = \"test\", since = \"2.0.0\")] // invalid\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for libffi/libgo Assembly Functions in Rust\nDESCRIPTION: This snippet marks various libffi and libgo functions as uninstrumented and discarded for DFSan. These functions are typically written in assembly or called from assembly code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfun:ffi_call_unix64=uninstrumented\nfun:ffi_call_unix64=discard\nfun:ffi_closure_unix64_inner=uninstrumented\nfun:ffi_closure_unix64_inner=discard\nfun:ffi_closure_unix64=uninstrumented\nfun:ffi_closure_unix64=discard\nfun:__go_get_closure=uninstrumented\nfun:__go_get_closure=discard\nfun:__go_makefunc_can_recover=uninstrumented\nfun:__go_makefunc_can_recover=discard\nfun:__go_makefunc_returning=uninstrumented\nfun:__go_makefunc_returning=discard\nfun:reflect.MakeFuncStubGo=uninstrumented\nfun:reflect.MakeFuncStubGo=discard\nfun:reflect.makeFuncStub=uninstrumented\nfun:reflect.makeFuncStub=discard\n```\n\n----------------------------------------\n\nTITLE: Automatic Lifetime Inference in Rust Methods\nDESCRIPTION: This example demonstrates how the Rust compiler can automatically infer lifetimes in many cases. It shows two equivalent method implementations: one with explicitly annotated lifetimes and one where the lifetimes are inferred by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0088.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    value: String\n}\n\nimpl Foo {\n    // it can be written like this\n    fn get_value<'a>(&'a self) -> &'a str { &self.value }\n    // but the compiler works fine with this too:\n    fn without_lifetime(&self) -> &str { &self.value }\n}\n\nfn main() {\n    let f = Foo { value: \"hello\".to_owned() };\n\n    println!(\"{}\", f.get_value());\n    println!(\"{}\", f.without_lifetime());\n}\n```\n\n----------------------------------------\n\nTITLE: Shell Functions for JIT Execution\nDESCRIPTION: Convenience shell functions for executing Rust code directly from the command line using JIT mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/usage.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfunction jit_naked() {\n    echo \"$@\" | $cg_clif_dir/dist/rustc-clif - -Zunstable-options -Cllvm-args=jit-mode-Cprefer-dynamic\n}\n\nfunction jit() {\n    jit_naked \"fn main() { $@ }\"\n}\n\nfunction jit_calc() {\n    jit 'println!(\"0x{:x}\", ' $@ ');';\n}\n```\n\n----------------------------------------\n\nTITLE: Macro By Example Usage (Rust)\nDESCRIPTION: This example demonstrates how to invoke the `printer` macro defined previously. It illustrates how the metavariable `$mvar` is replaced with the provided identifier.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nprinter!(print foo); // `foo` is a variable\n```\n\n----------------------------------------\n\nTITLE: Building and Running Heap Corruption Example (Release)\nDESCRIPTION: This command demonstrates building and running the heap corruption example in release mode, showing that the allocator still detects and reports the issue even with optimizations enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --release\n   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n    Finished release [optimized] target(s) in 0.25s\n     Running `target/release/hello-rust-heap`\nfree(): invalid next size (normal)\nAborted\n```\n\n----------------------------------------\n\nTITLE: Declaring and Removing a Lint in Rust Compiler\nDESCRIPTION: This snippet shows how to declare a lint using the `declare_lint!` macro in Rust and instructions to remove it from the codebase. It includes removing definitions from lint arrays and updates to future compatibility information. This requires Rust compiler knowledge and access to the Rust compiler's source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/bug-fix-procedure.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub OVERLAPPING_INHERENT_IMPLS,\n    Deny, // this may also say Warning\n    \"two overlapping inherent impls define an item with the same name were erroneously allowed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a Reference Type in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to dereference a value in Rust using a reference (`&`). A `u32` variable `y` is created, and then a reference `x` to `y` is created using `&y`. The reference `x` (of type `&u32`) can be dereferenced using the `*` operator to access the underlying `u32` value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0614.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\nlet y = 0u32;\nlet x = &y;\n// So here, `x` is a `&u32`, so we can dereference it:\n*x; // ok!\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Outlives Constraints\nDESCRIPTION: This snippet shows how to process subtyping constraints to create outlives constraints in Rust's region inference. It highlights the growth of region values based on established relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nVs = { CFG; end('static) }\nV1 = { CFG; end('static), placeholder(1) }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Auto Trait Casting Example in Rust\nDESCRIPTION: This example demonstrates code that will not compile due to error E0804, where an attempt is made to add the Send auto trait to a dyn Any trait object via pointer cast. This operation is not allowed because it could create invalid vtables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0804.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet ptr: *const dyn core::any::Any = &();\n_ = ptr as *const (dyn core::any::Any + Send);\n```\n\n----------------------------------------\n\nTITLE: Invalid Generic Const Parameter Reference - Rust\nDESCRIPTION: Demonstrates incorrect usage of const parameters referencing other generic type parameters, which results in compiler error E0770.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0770.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T, const N: T>() {}\n```\n\n----------------------------------------\n\nTITLE: String Deref Pattern Matching in Rust\nDESCRIPTION: This code demonstrates pattern matching on a `String` value using the `string_deref_patterns` feature. The `Value` enum can hold either a `String` or a `Number`, and the `is_it_the_answer` function checks if the value is equal to \"42\", leveraging the `Deref` implementation to treat the `String` as a `&str` in the pattern.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/string-deref-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(string_deref_patterns)]\n\npub enum Value {\n    String(String),\n    Number(u32),\n}\n\npub fn is_it_the_answer(value: Value) -> bool {\n    match value {\n        Value::String(\"42\") => true,\n        Value::Number(42) => true,\n        _ => false,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Unresolved Intra-Doc Link in Rust\nDESCRIPTION: The function `foo` in this snippet contains a documentation comment attempting to link to a non-existent item `Nonexistent`. It demonstrates how the `broken_intra_doc_links` lint identifies unresolved links, emitting a warning message pointing to the exact location of the unresolved reference. This snippet is intended to illustrate the necessity of correcting broken links in documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// I want to link to [`Nonexistent`] but it doesn't exist!\npub fn foo() {}\n\n```\n\n----------------------------------------\n\nTITLE: Listing rustlib libraries - Rust\nDESCRIPTION: This snippet shows how to list the libraries located in the 'lib/rustlib/' directory of the Rust compiler's sysroot. These libraries are used to implement the standard library but are not part of its public API.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/what-bootstrapping-does.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ls $(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/lib | head -n 5\nlibaddr2line-6c8e02b8fedc1e5f.rlib\nlibadler-9ef2480568df55af.rlib\nliballoc-9c4002b5f79ba0e1.rlib\nlibcfg_if-512eb53291f6de7e.rlib\nlibcompiler_builtins-ef2408da76957905.rlib\n```\n\n----------------------------------------\n\nTITLE: Passing Codegen Options\nDESCRIPTION: This code snippet demonstrates how to use the `-C` or `--codegen` flag to pass codegen options to the rust compiler used by rustdoc when generating documentation or running documentation tests. This is useful for enabling target features or other compiler options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -C target_feature=+avx\n$ rustdoc src/lib.rs --codegen target_feature=+avx\n\n$ rustdoc --test src/lib.rs -C target_feature=+avx\n$ rustdoc --test src/lib.rs --codegen target_feature=+avx\n\n$ rustdoc --test README.md -C target_feature=+avx\n$ rustdoc --test README.md --codegen target_feature=+avx\n```\n\n----------------------------------------\n\nTITLE: Warning for Missing Function Documentation in Rust\nDESCRIPTION: This snippet illustrates the use of the `missing_docs` lint, which flags items lacking documentation. By toggling this lint with `#![warn(missing_docs)]`, the function `undocumented` will cause a warning mentioning the absence of a docstring. The `missing_docs` lint is crucial for encouraging comprehensive documentation and is available directly in `rustc` as well as `rustdoc`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(missing_docs)]\n\npub fn undocumented() {}\n# fn main() {}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using doc_notable_trait in Rust\nDESCRIPTION: This code snippet demonstrates how to use the doc_notable_trait feature to mark a trait as notable and create a function that returns a type implementing that trait. The #[doc(notable_trait)] attribute is applied to the trait, and rustdoc will display a dialog about the trait implementation for the returned type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/doc-notable-trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(doc_notable_trait)]\n\n#[doc(notable_trait)]\npub trait MyTrait {}\n\npub struct MyStruct;\nimpl MyTrait for MyStruct {}\n\n/// The docs for this function will have a button that displays a dialog about\n/// `MyStruct` implementing `MyTrait`.\npub fn my_fn() -> MyStruct { MyStruct }\n```\n\n----------------------------------------\n\nTITLE: Creating a Salsa Derived Query Group in Rust\nDESCRIPTION: Example of defining a Salsa derived query group that depends on the previously defined input query group. This shows how to specify dependencies between query groups using supertraits and how to declare derived queries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// This query group is going to contain queries that depend on derived values.\n/// A query group can access another query group's queries by specifying the\n/// dependency as a supertrait. Query groups can be stacked as much as needed using\n/// that pattern.\n#[salsa::query_group(ParserStorage)]\npub trait Parser: Inputs {\n    /// This query `ast` is not an input query, it's a derived query this means\n    /// that a definition is necessary.\n    fn ast(&self, name: String) -> String;\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Visibility Qualifier Usage in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to structure the same code without using visibility qualifiers where they are not allowed. It shows proper implementation for enum variants, impl blocks, and trait implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0449.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    fn foo();\n}\n\nenum Baz {\n    // Enum variants share the visibility of the enum they are in, so\n    // `pub` is not allowed here\n    Qux,\n}\n\n// Directly implemented methods share the visibility of the type itself,\n// so `pub` is not allowed here\nimpl Bar {}\n\n// Trait methods share the visibility of the trait, so `pub` is not\n// allowed in either case\nimpl Foo for Bar {\n    fn foo() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Re-export Attributes in Rust\nDESCRIPTION: This code shows that when re-exporting an item explicitly without `#[doc(inline)]` or glob re-exports, the attributes on the re-export itself are ignored. `InPrivate` will only display its own attributes, and not the attributes of its re-export. The result is that `cfg(c)` from the re-export will not be displayed in the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_mod {\n    /// First\n    #[cfg(a)]\n    pub struct InPrivate;\n}\n\n#[cfg(c)]\npub use self::private_mod::InPrivate;\n```\n```\n\n----------------------------------------\n\nTITLE: Tracing Bootstrap with Environment Variables\nDESCRIPTION: This snippet shows how to use the BOOTSTRAP_TRACING environment variable to enable structured tracing in the Rust bootstrap. By setting this variable, you can control the level of tracing and target specific log outputs during the bootstrap process. It requires the tracing crate as a dependency. Outputs include structured logs for different stages of the bootstrap process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/debugging-bootstrap.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ BOOTSTRAP_TRACING=bootstrap=TRACE ./x build library --stage 1\n```\n\n----------------------------------------\n\nTITLE: Resolution Example 3: Implement Copy Trait in Rust\nDESCRIPTION: This Rust code snippet resolves the error by implementing the `Copy` trait for `Value`, allowing `x` to be copied rather than moved when `eat` is called. This ensures that borrowing and moving operations can occur seamlessly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0505.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating MIR from Rust Expressions\nDESCRIPTION: This snippet defines a function in Rust that generates MIR by appending statements onto a given basic block and returning a result. The function requires access to MIR-related Rust libraries and the `BasicBlock` type, returning a specified `ResultType`. The input is a mutable reference to a basic block, and the output is the generated MIR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/construction.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn generate_some_mir(&mut self, block: BasicBlock) -> ResultType {\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Thread-Local Static Variable Assignment in Rust\nDESCRIPTION: This code snippet shows the corrected approach to using thread-local static variables in Rust by utilizing a separate const variable. It extracts the value into a const variable 'C', which can then be safely used to initialize the thread-local static variable 'X'. The const variable 'Y' correctly references 'C' without compile-time errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0625.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(thread_local)]\n\nconst C: usize = 12;\n\n#[thread_local]\nstatic X: usize = C;\n\nconst Y: usize = 2 * C;\n```\n\n----------------------------------------\n\nTITLE: Preventing ICE in Empty Macro Rules in Rust\nDESCRIPTION: This snippet demonstrates a fix for a previous issue where rustfmt would cause an Internal Compiler Error (ICE) when formatting an empty `macro_rules!` branch. The provided macro definition showcases the scenario that triggered the ICE, now resolved by the fix. This ensures stability when formatting macro definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! statement {\n    () => {;};\n}\n```\n\n----------------------------------------\n\nTITLE: Raw Byte String Literal Error in Rust\nDESCRIPTION: This snippet demonstrates a compiler error in Rust that occurs when a raw byte string literal is not properly terminated with the same number of `#` symbols used at the beginning. The error message \"Missing trailing `\"` with `#` symbols to terminate the raw byte string literal\" indicates that the compiler expects a closing delimiter with the correct number of `#` symbols.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_with_slash_n.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"br##\\\"\\\\n\" error: Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Defining and Accessing Struct Fields\nDESCRIPTION: This code shows how to define a struct with fields and access those fields in Rust.  It declares a struct called `Foo` with two fields, `x` and `y`, and then creates an instance of the struct and accesses its fields using the dot operator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0610.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Required Dependencies for Clippy Lint in Rust\nDESCRIPTION: Initial imports needed to create a new lint for Clippy. These include the necessary types for implementing an early lint pass in the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_lint::{EarlyLintPass, EarlyContext};\nuse rustc_session::declare_lint_pass;\nuse rustc_ast::ast::*;\n```\n\n----------------------------------------\n\nTITLE: Higher Ranked Function Trait Bound Acceptance in Rust\nDESCRIPTION: This code snippet demonstrates the acceptance of higher ranked function pointers and ensures that late bound parameters can be called with different borrow lifetimes in Rust functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn accepts_hr_fn(_: impl for<'a> Fn(&'a String) -> &'a String) {}\n\nfn higher_ranked_trait_bound() {\n    let bar_fn_item = bar;\n    accepts_hr_fn(bar_fn_item);\n\n    let foo_fn_item = foo::<'_>;\n    // errors\n    accepts_hr_fn(foo_fn_item);\n}\n\nfn higher_ranked_fn_ptr() {\n    let bar_fn_item = bar;\n    let fn_ptr: for<'a> fn(&'a String) -> &'a String = bar_fn_item;\n    \n    let foo_fn_item = foo::<'_>;\n    // errors\n    let fn_ptr: for<'a> fn(&'a String) -> &'a String = foo_fn_item;\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced MIR Cursor Management\nDESCRIPTION: Demonstrates advanced cursor management when generating MIR in Rust. It introduces a pattern where a local cursor variable is updated after calling a function that generates MIR, executed through a manual match statement. The cursor represents the state of MIR generation and is updated to point at subsequent instructions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/construction.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut block;\nlet v = match self.generate_more_mir(..) {\n    BlockAnd { block: new_block, value: v } => {\n        block = new_block;\n        v\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Building Rust Programs for SPARC\nDESCRIPTION: This command builds a Rust project with the specified SPARC target using Cargo. It requires a cross-compilation toolchain compatible with SPARC.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_1\n\nLANGUAGE: Console\nCODE:\n```\ncargo build --target sparc-unknown-none-elf\n```\n\n----------------------------------------\n\nTITLE: Installing RISC-V Toolchain on Ubuntu\nDESCRIPTION: Command to install RISC-V cross-compilation toolchain and development libraries\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\napt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross\n```\n\n----------------------------------------\n\nTITLE: Preserving `for<T>` in Rust with `non_lifetime_binders`\nDESCRIPTION: This snippet showcases a fix for rustfmt removing `for<T>` when using the `non_lifetime_binders` feature. The example demonstrates a trait definition where `for<T>` is used in a where clause bound, ensuring it is correctly preserved after formatting. This resolves an issue when using advanced features in Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(non_lifetime_binders)]\n#![allow(incomplete_features)]\n\ntrait Other<U: ?Sized> {}\n\ntrait Trait<U>\nwhere\n    for<T> U: Other<T> {}\n```\n\n----------------------------------------\n\nTITLE: Using cfg_version Feature for Version-Dependent Code in Rust\nDESCRIPTION: Demonstrates how to use the cfg_version feature to write version-specific code implementations. The example shows both attribute-based configuration (#[cfg]) and runtime checking (cfg!) based on compiler version.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/cfg-version.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(cfg_version)]\n\n#[cfg(version(\"1.42\"))] // 1.42 and above\nfn a() {\n    // ...\n}\n\n#[cfg(not(version(\"1.42\")))] // 1.41 and below\nfn a() {\n    // ...\n}\n\nfn b() {\n    if cfg!(version(\"1.42\")) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol Representation for PathBuf in Rust\nDESCRIPTION: This text details the mangled symbol for `PathBuf::new` within the crate `mycrate`, illustrating the different components used to encode symbol paths in Rust, and includes the recommendation for human-readable demangling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n_RNvMsr_NtCs3ssYzQotkvD_3std4pathNtB5_7PathBuf3newCs15kBYyAo9fc_7mycrate\n```\n\n----------------------------------------\n\nTITLE: Description of the run-make Test Suite Infrastructure\nDESCRIPTION: This snippet provides an overview of the roles and structure of the run-make test suite in Rust, including how test recipes are organized and integrated within the testing framework. It highlights the use of `rmake.rs` files and the support library, explaining the three-stage setup process comprising library building, recipe compilation, and test execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/README.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# The `run-make` test suite\n\nThe `run-make` test suite contains tests which are the most flexible out of all the [rust-lang/rust](https://github.com/rust-lang/rust) test suites. `run-make` tests can basically contain arbitrary code, and are supported by the [`run_make_support`] library.\n\n## Infrastructure\n\nA `run-make` test is a test recipe source file `rmake.rs` accompanied by its parent directory (e.g. `tests/run-make/foo/rmake.rs` is the `foo` `run-make` test).\n\nThe implementation for collecting and building the `rmake.rs` recipes are in [`src/tools/compiletest/src/runtest.rs`](../../src/tools/compiletest/src/runtest.rs), in `run_rmake_test`.\n\nThe setup for the `rmake.rs` can be summarized as a 3-stage process:\n\n1. First, we build the [`run_make_support`] library in bootstrap as a tool lib.\n2. Then, we compile the `rmake.rs` \"recipe\" linking the support library and its dependencies in, and provide a bunch of env vars. We setup a directory structure within `build/<target>/test/run-make/`\n\n   ```\n   <test-name>/\n       rmake.exe              # recipe binary\n       rmake_out/             # sources from test sources copied over\n   ```\n\n   and copy non-`rmake.rs` input support files over to `rmake_out/`. The support library is made available as an [*extern prelude*][extern_prelude].\n3. Finally, we run the recipe binary and set `rmake_out/` as the working directory.\n\n[`run_make_support`]: ../../src/tools/run-make-support\n[extern_prelude]: https://doc.rust-lang.org/reference/names/preludes.html#extern-prelude\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform-Specific Documentation with doc_cfg in Rust\nDESCRIPTION: This snippet demonstrates how to use the doc_cfg feature to document a Windows-specific struct. It shows the usage of #[doc(cfg)] attribute and the #[cfg(doc)] conditional compilation flag for platform-specific documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/doc-cfg.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(doc_cfg)]\n\n#[cfg(any(windows, doc))]\n#[doc(cfg(windows))]\n/// The application's icon in the notification area (a.k.a. system tray).\n///\n/// # Examples\n///\n/// ```no_run\n/// extern crate my_awesome_ui_library;\n/// use my_awesome_ui_library::current_app;\n/// use my_awesome_ui_library::windows::notification;\n///\n/// let icon = current_app().get::<notification::Icon>();\n/// icon.show();\n/// icon.show_message(\"Hello\");\n/// ```\npub struct Icon {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unused Lifetime Parameter Error in Rust Struct\nDESCRIPTION: This code snippet illustrates an erroneous example where a lifetime parameter 'a is declared in a struct but not used, resulting in the E0392 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0392.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a, T> {\n    x: *const T,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Missing Docs in Crate Items in Rust\nDESCRIPTION: This option controls whether to check for missing documentation **only** in items visible within the current crate (e.g., `pub(crate)` items). It affects the `missing_docs_in_private_items` lint. The default value is `false`, meaning all documentation will be checked by default. The input is a boolean.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_32\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Use of Self in Type Parameter Default for Rust Struct\nDESCRIPTION: This code snippet shows an erroneous attempt to use `Self` in a type parameter default for a struct named `Foo`. The compiler will reject this code with error E0735, as type parameters cannot use `Self` in their defaults for structs, enums, or unions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0735.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<X = Box<Self>> {\n    field1: Option<X>,\n    field2: Option<X>,\n}\n// error: type parameters cannot use `Self` in their defaults.\n```\n\n----------------------------------------\n\nTITLE: Calculating Documentation Coverage in Rustdoc (Bash)\nDESCRIPTION: This command demonstrates how to use the --show-coverage flag in Rustdoc to calculate the percentage of items with documentation. It generates a table showing documentation and examples coverage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --show-coverage\n```\n\n----------------------------------------\n\nTITLE: Configuring doc-valid-idents\nDESCRIPTION: This setting defines a list of words that the `doc_markdown` lint should not consider as identifiers that need to be enclosed in backticks.  The special value `..` appends values to the default list. The default is a long list of common terms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Correct Transmute Between Same-Sized Types\nDESCRIPTION: Shows two valid ways to use transmute or directly pass values when type sizes are compatible in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0512.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n    // or:\n    unsafe { takes_u8(0u8); } // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Using ffi_pure Attribute in Rust\nDESCRIPTION: Example demonstrating the syntax for applying the #[ffi_pure] attribute to foreign function declarations in Rust. Pure functions must have no effects except for their return value, which must remain consistent across calls with the same parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/ffi-pure.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[ffi_pure]\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Tuple Struct Definition in Rust\nDESCRIPTION: Demonstrates the formatting of multi-line tuple struct definitions in Rust, including block formatting with a field on each line and a trailing comma.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub struct Foo(\n    String,\n    u8,\n);\n```\n\n----------------------------------------\n\nTITLE: Calling the panic_impl Function from Core's Panic Macro Implementation\nDESCRIPTION: This snippet shows how core's panic! macro eventually calls the panic_impl function, which is a lang item that will be resolved at link time. The function takes a PanicInfo struct and is marked as a function that never returns (!).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/panic-implementation.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\nextern \"Rust\" {\n    #[lang = \"panic_impl\"]\n    fn panic_impl(pi: &PanicInfo<'_>) -> !;\n}\n\nlet pi = PanicInfo::internal_constructor(Some(&fmt), location);\nunsafe { panic_impl(&pi) }\n```\n\n----------------------------------------\n\nTITLE: Keeping Local Branches Up-to-Date\nDESCRIPTION: A sequence of commands to update the local master branch from the upstream repository and then rebase a feature branch onto the newly updated master. Includes checking out master, pulling with --ff-only to prevent merges, rebasing the feature branch, and force-pushing the feature branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout master\ngit pull upstream master --ff-only\ngit rebase master feature_branch\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Range Pattern Error with Strings in Rust\nDESCRIPTION: This code example shows the E0029 error that occurs when trying to use string literals with range patterns in match expressions. The compiler cannot evaluate string ordering at compile time, so a guard condition must be used instead.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0029.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet string = \"salutations !\";\n\n// The ordering relation for strings cannot be evaluated at compile time,\n// so this doesn't work:\nmatch string {\n    \"hello\" ..= \"world\" => {}\n    _ => {}\n}\n\n// This is a more general version, using a guard:\nmatch string {\n    s if s >= \"hello\" && s <= \"world\" => {}\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Type Assignments in Rust\nDESCRIPTION: This snippet demonstrates common mistakes when declaring a variable with a type, where an enum variant and a trait method are incorrectly used as types. This incorrect usage causes compilation errors in Rust. It requires the Rust compiler to check for errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0575.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenum Rick { Morty }\n\nlet _: <u8 as Rick>::Morty; // error!\n\ntrait Age {\n    type Empire;\n    fn Mythology() {}\n}\n\nimpl Age for u8 {\n    type Empire = u16;\n}\n\nlet _: <u8 as Age>::Mythology; // error!\n```\n\n----------------------------------------\n\nTITLE: Inlining Hidden Items with #[doc(inline)] in Rust\nDESCRIPTION: This snippet showcases how to make a re-export visible in the documentation even when the underlying item is hidden. The `Hidden` struct is marked with `#[doc(hidden)]`, but the re-export `InlinedHidden` is marked with `#[doc(inline)]`, which causes the re-export to be visible, though without a link to the `Hidden` item.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n// This struct won't be visible.\n#[doc(hidden)]\npub struct Hidden;\n\n#[doc(inline)]\npub use self::Hidden as InlinedHidden;\n```\n```\n\n----------------------------------------\n\nTITLE: Using Doctest Compilation Arguments with Rustdoc\nDESCRIPTION: This snippet shows how to use the --doctest_compilation_args flag to pass custom compiler options when compiling doctests. In this example, it limits lint levels to warnings to prevent the test from failing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_35\n\nLANGUAGE: console\nCODE:\n```\n$ rustdoc --test --doctest_compilation_args=--cap-lints=warn file.rs\n\nrunning 1 test\ntest tests/rustdoc-ui/doctest/rustflags.rs - Bar (line 5) ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.06s\n```\n\n----------------------------------------\n\nTITLE: Struct definition with where clauses in Rust\nDESCRIPTION: This code defines a struct `Foo` with a type parameter `T` constrained by a `Bar` trait. This example is used to discuss the relationship between variance of `T` with respect to `Bar` and `T` with respect to `Foo`. The `ignore` attribute suggests the code isn't meant to be compiled directly and is for illustrative purposes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nstruct Foo<T: Bar> { ... }\n```\n```\n\n----------------------------------------\n\nTITLE: Alternative Canonical Form with For Syntax\nDESCRIPTION: This snippet shows an alternative way to represent the canonicalized query, using 'for<>' to provide information about variable types. 'T' indicates type variables and 'L' indicates lifetime variables. This form also prepares the query for solving by the trait system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nfor<T,L,T> { ?0: Foo<'?1, ?2> }\n```\n\n----------------------------------------\n\nTITLE: Default Trait Body with RPITIT\nDESCRIPTION: This Rust code showcases a trait with a default method implementation using RPITIT.  It defines a trait `Foo` with a default implementation for `bar` that returns `impl Sized`.  The text mentions a hack involving installing a projection predicate into the param-env of `Foo::bar`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait Foo {\n    fn bar() -> impl Sized {\n        1i32\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using embed-metadata Flag with rustc\nDESCRIPTION: Example of how to use the embed-metadata flag to control metadata inclusion in compiled libraries. When set to 'no', it reduces file size by including only stub metadata in rlib and dylib files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/embed-metadata.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## `embed-metadata`\n\nThis option instructs `rustc` to include the full metadata in `rlib` and `dylib` crate types. The default value is `yes` (enabled). If disabled (`no`), only stub metadata will be stored in these files, to reduce their size on disk. When using `-Zembed-metadata=no`, you will probably want to use `--emit=metadata` to produce the full metadata into a separate `.rmeta` file.\n```\n\n----------------------------------------\n\nTITLE: Configuring bootstrap.toml for s390x-unknown-linux-musl Support\nDESCRIPTION: Configuration for adding s390x-unknown-linux-musl to the target list in bootstrap.toml to enable support for this target when building Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-musl.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"s390x-unknown-linux-musl\"]\n```\n\n----------------------------------------\n\nTITLE: Enabling Control Flow Guard for Rust Standard Library (PowerShell)\nDESCRIPTION: This PowerShell script demonstrates how to enable Control Flow Guard for the Rust standard library using cargo's build-std functionality. It installs the nightly toolchain, adds the rust-src component, sets the RUSTFLAGS environment variable, and builds the project with CFG enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/control-flow-guard.md#2025-04-21_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nrustup toolchain install --force nightly\nrustup component add rust-src\n$Env:RUSTFLAGS = \"-Z control-flow-guard\"\ncargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Conceptual Example of Variable Length Arrays in Rust\nDESCRIPTION: This snippet demonstrates a potential future syntax for variable length arrays in Rust. It shows how dynamic stack allocation could be used in algorithms like mergesort. Note that this syntax is not yet implemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_locals)]\n\nfn mergesort<T: Ord>(a: &mut [T]) {\n    let mut tmp = [T; dyn a.len()];\n    // ...\n}\n\nfn main() {\n    let mut a = [3, 1, 5, 6];\n    mergesort(&mut a);\n    assert_eq!(a, [1, 3, 5, 6]);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Arm64EC Target in Bootstrap Configuration\nDESCRIPTION: Configuration for enabling Arm64EC target support in Rust build process using bootstrap.toml configuration file. Requires adding the target to the build configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64ec-pc-windows-msvc.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"arm64ec-pc-windows-msvc\"]\n```\n\n----------------------------------------\n\nTITLE: Fixed Trait Return Types with Static Lifetime\nDESCRIPTION: Corrected implementations using 'static lifetime bounds for trait object and impl Trait return types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0759.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::Debug;\nfn foo(x: &'static i32) -> impl Debug + 'static { // ok!\n    x\n}\n\nfn bar(x: &'static i32) -> Box<dyn Debug + 'static> { // ok!\n    Box::new(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Small Pattern Clauses - Rust\nDESCRIPTION: Demonstrates formatting for multiple small pattern clauses that don't fit on a single line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n    foo | bar | baz\n    | qux => {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Rust Pattern Matching Alternative - Split Patterns\nDESCRIPTION: Alternative solution that splits the 'or' pattern into separate match arms, allowing different binding modes for each case.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0409.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = (0, 2);\nmatch x {\n    (y, 0) => { /* use y */ }\n    (0, ref y) => { /* use y */}\n    _ => ()\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Hexadecimal Character Error\nDESCRIPTION: This snippet demonstrates an error where a hexadecimal integer literal (0x) contains an invalid character 'G'. Valid hexadecimal characters are 0-9 and A-F (or a-f).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0xG\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Rust Lifetime Resolution with Subtyping\nDESCRIPTION: Resolves the lifetime mismatch by ensuring the input lifetime ('in_) is at least as long as the output lifetime ('out). This approach allows the function to compile by establishing a lifetime relationship.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0623.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a, 'b, T>(std::marker::PhantomData<(&'a (), &'b (), T)>)\nwhere\n    T: Convert<'a, 'b>;\n\ntrait Convert<'a, 'b>: Sized {\n    fn cast(&'a self) -> &'b Self;\n}\nimpl<'long: 'short, 'short, T> Convert<'long, 'short> for T {\n    fn cast(&'long self) -> &'short T {\n        self\n    }\n}\nfn badboi<'in_: 'out, 'out, T>(\n    x: Foo<'in_, 'out, T>,\n    sadness: &'in_ T\n) -> &'out T {\n    sadness.cast()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reborrowing in Async Closures (Rust)\nDESCRIPTION: This snippet shows a case where the inner coroutine can reborrow data from a by-move capture in the parent closure. It illustrates how deref projections allow reborrowing of references captured by-move.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = &1i32; // Let's call this lifetime `'1`.\nlet c = async move || {\n    println!(\"{:?}\", *x);\n    // Even though the inner coroutine borrows by ref, we're only capturing `*x`,\n    // not `x`, so the inner closure is allowed to reborrow the data for `'1`.\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Macro Import in Non-Root Module (Rust)\nDESCRIPTION: Example showing incorrect placement of macro imports within a non-root module, which will result in compilation error E0468.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0468.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    #[macro_use(debug_assert)]  // error: must be at crate root to import\n    extern crate core;          //        macros from another crate\n    fn run_macro() { debug_assert!(true); }\n}\n```\n\n----------------------------------------\n\nTITLE: Apache License 2.0 Header Template\nDESCRIPTION: Standard header text for Apache License 2.0 that should be included at the top of source files. Includes placeholder for copyright year and owner name, along with the standard Apache license terms and conditions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/LICENSE-APACHE.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Enabling Control Flow Guard for Rust Standard Library (CMD)\nDESCRIPTION: This CMD script demonstrates how to enable Control Flow Guard for the Rust standard library using cargo's build-std functionality. It installs the nightly toolchain, adds the rust-src component, sets the RUSTFLAGS environment variable, and builds the project with CFG enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/control-flow-guard.md#2025-04-21_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\nrustup toolchain install --force nightly\nrustup component add rust-src\nSET RUSTFLAGS=-Z control-flow-guard\ncargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Manual Transmutation Using Pointers in Rust\nDESCRIPTION: An alternative approach to transmutation using raw pointers with `ptr::read`. This method allows transmutation without moving the original value, but may require additional memory management like calling `mem::forget()` to prevent destructors from running.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0139.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use std::ptr;\n# let v = Some(\"value\");\n# type SomeType = &'static [u8];\nunsafe {\n    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n}\n# ;\n```\n\n----------------------------------------\n\nTITLE: Registering a Late Lint Pass\nDESCRIPTION: This Rust code snippet demonstrates how to manually register a late lint pass within the `register_lints` function in `clippy_lints/src/lib.rs`. This is required if a lint is declared manually instead of generated by the dev tools. Without a call to `register_early_pass` or `register_late_pass`, the lint pass in question will not be run.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/defining_lints.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstore.register_late_pass(|_| Box::new(foo_functions::FooFunctions));\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Items Ordering Within Groupings in Rust\nDESCRIPTION: This setting determines whether the items within module groups should be ordered alphabetically.  It affects the `arbitrary_source_item_ordering` lint. The default value is `\"none\"`, meaning items are not checked for alphabetical order.  The value can be \"all\", \"none\", or a list of specific grouping names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_34\n\n\n\n----------------------------------------\n\nTITLE: Registering rust-analyzer with vim-lsp\nDESCRIPTION: This Vim script snippet registers the `rust-analyzer` binary with the vim-lsp plugin, allowing it to be used as the language server for Rust files.  It checks if the binary is executable and then registers the server with its name, command, and whitelist of file types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_6\n\nLANGUAGE: Vim Script\nCODE:\n```\nif executable('rust-analyzer')\n  au User lsp_setup call lsp#register_server({\n        \\   'name': 'Rust Language Server',\n        \\   'cmd': {server_info->['rust-analyzer']},\n        \\   'whitelist': ['rust'],\n        \\ })\nendif\n```\n\n----------------------------------------\n\nTITLE: Setting Up Docker Environment for Compiler Explorer\nDESCRIPTION: This snippet outlines the steps to set up a Docker environment to build Rust in a container, installing necessary packages for compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it ubuntu:22.04\nexport CC=clang CXX=clang++\napt update\napt install wget vim python3 git curl libssl-dev pkg-config lld ninja-build cmake clang build-essential\n```\n\n----------------------------------------\n\nTITLE: Erroneous Multi-binding of Struct Fields in Rust (E0025)\nDESCRIPTION: This code demonstrates the error that occurs when attempting to bind the same struct field multiple times in a pattern. The compiler raises E0025 when the field 'a' is bound to both 'x' and 'y' variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0025.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: u8,\n    b: u8,\n}\n\nfn main(){\n    let x = Foo { a:1, b:2 };\n\n    let Foo { a: x, a: y } = x;\n    // error: field `a` bound multiple times in the pattern\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Error Handling with Formatter\nDESCRIPTION: Documents the error handling behavior for string formatting operations. Specifies that Err should only be returned when the provided Formatter returns Err, as string formatting itself is infallible. Errors typically occur only due to underlying stream writing failures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/fmt/fmt_trait_method_doc.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Errors\\n\\nThis function should return [`Err`] if, and only if, the provided [`Formatter`] returns [`Err`].\\nString formatting is considered an infallible operation; this function only\\nreturns a [`Result`] because writing to the underlying stream might fail and it must\\nprovide a way to propagate the fact that an error has occurred back up the stack.\n```\n\n----------------------------------------\n\nTITLE: Checking Drop Trait Implementation Using Lang Items\nDESCRIPTION: Shows how to verify if an expression implements the Drop trait using lang items. Utilizes the LateContext's TyCtxt to access language items and the implements_trait utility function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/trait_checking.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::implements_trait;\nuse rustc_hir::Expr;\nuse rustc_lint::{LateContext, LateLintPass};\n\nimpl LateLintPass<'_> for CheckDropTraitLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        let ty = cx.typeck_results().expr_ty(expr);\n        if cx.tcx.lang_items()\n            .drop_trait()\n            .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n                println!\"`expr` implements `Drop` trait!\");\n            }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arbitrary Self Types Feature in Rust\nDESCRIPTION: This example demonstrates the nightly feature 'arbitrary_self_types' which allows using any type that implements the Receiver trait as a method receiver. It shows how a type Bar that dereferences to Foo can be used as the receiver.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0307.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types)]\n\nstruct Foo;\nstruct Bar;\n\n// Because you can dereference `Bar` into `Foo`...\nimpl std::ops::Deref for Bar {\n    type Target = Foo;\n\n    fn deref(&self) -> &Foo {\n        &Foo\n    }\n}\n\nimpl Foo {\n    fn foo(self: Bar) {}\n//         ^^^^^^^^^ ...it can be used as the receiver type\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Code Missing Lifetime Bound\nDESCRIPTION: This example fails to compile because the struct Foo doesn't have a where clause requiring T to outlive 'a, which is needed by the associated type used in the struct field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0309.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Missing Trailing Quote\nDESCRIPTION: This code snippet illustrates a Rust compiler error. The error \"Missing trailing `'` symbol to terminate the byte literal\" occurs when defining a byte literal (starting with `b'`) without a closing single quote. This often happens when escape sequences are used without proper termination.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_ascii_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'\\\\x7f\\\" error: Missing trailing `'` symbol to terminate the byte literal\"\n```\n\n----------------------------------------\n\nTITLE: Subsetting Nanum Barun Gothic Font for Korean Characters using pyftsubset\nDESCRIPTION: This command uses pyftsubset to create a subset of the Nanum Barun Gothic font containing only the Korean character ranges. The output is generated as a WOFF2 file which is more compact for web usage in rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/fonts/README.txt#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npyftsubset NanumBarunGothic.ttf \\\n--unicodes=U+AC00-D7AF:U+1100-11FF,U+3130-318F,U+A960-A97F,U+D7B0-D7FF \\\n--output-file=NanumBarunGothic.ttf.woff2 --flavor=woff2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shared Inference Variables in `impl Debug` Return Type\nDESCRIPTION: This code snippet demonstrates how all return sites in a function returning `impl Debug` share the same inference variable. Consequently, a return site might only compile if another return site uses a concrete type. This is a backwards compatibility hack in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> impl Debug {\n    if false {\n        return std::iter::empty().collect();\n    }\n    vec![42]\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring External Variables in Rust\nDESCRIPTION: This snippet declares external variables with specified values, which can be referenced from other parts of the program or from FFI (Foreign Function Interface) calls. Required dependencies are the Rust standard library and a suitable environment for executing Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-import-name-type/output.txt#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nextern_variable_undecorated value: 42\nextern_variable_noprefix value: 43\nextern_variable_decorated value: 44\n```\n\n----------------------------------------\n\nTITLE: Conflict Detection with arbitrary_self_types in Rust\nDESCRIPTION: Shows how arbitrary_self_types detects method conflicts when using reference to smart pointers as receiver types. This example prevents potential confusion between methods of the referent and the smart pointer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types)]\n\nuse std::pin::Pin;\nuse std::pin::pin;\n\nstruct A;\n\nimpl A {\n    fn get_ref(self: &Pin<&A>) {}  // note &Pin\n}\n\nfn main() {\n    let pinned_a: Pin<&mut A> = pin!(A);\n    let pinned_a: Pin<&A> = pinned_a.as_ref();\n    pinned_a.get_ref();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Structural Normalization in Rust's Trait Solver\nDESCRIPTION: This code snippet demonstrates the implementation of structural normalization in the new solver. It repeatedly applies one-step normalization until reaching a rigid alias, ambiguity, or overflow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/normalization.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Source: structural_norm\nfn structural_norm(\n    &mut self,\n    mut ty: Ty<I>,\n) -> Result<Ty<I>, Ambiguous> {\n    let mut overflow = false;\n    loop {\n        match self.evaluator.eval_alias_goal(NormalizesTo {\n            alias: ty.clone(),\n            ty: self.evaluator.tcx().mk_ty_var(self.evaluator.next_ty_var()),\n        }) {\n            Ok(ty2) => ty = ty2,\n            Err(NoSolution) => return Ok(ty),\n            Err(Ambiguous(goals)) if overflow => return Err(Ambiguous(goals)),\n            Err(Ambiguous(_)) => {\n                overflow = true;\n                continue;\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Query Dependency Pattern in Rust\nDESCRIPTION: This code snippet illustrates how queries can depend on each other conditionally, showing why preserving the execution order is important for the incremental compilation system. It demonstrates a main query that executes different subqueries based on the result of an initial condition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/incremental-compilation.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main_query(tcx) {\n    if tcx.subquery1() {\n        tcx.subquery2()\n    } else {\n        tcx.subquery3()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Main Function Rust\nDESCRIPTION: This snippet defines a basic main function in Rust necessary for a binary crate. It serves as the entry point of the program and uses println! macro to output 'Hello world!' to the console. This snippet assumes the user is familiar with basic Rust syntax. External dependencies include Rust standard library for standard input/output operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0601.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Array to Move Values in Rust\nDESCRIPTION: This snippet demonstrates how to move values out of an array by using destructuring. By pattern matching on the array with `let [_value] = array;`, developers effectively move the value out while adhering to Rust's ownership rules. This method is useful for when it is acceptable to move values directly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0508.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    // Destructuring the array\n    let [_value] = array;\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Getter Function in Rust\nDESCRIPTION: This snippet demonstrates the use of a getter function to access a private field in Rust. A method 'get_x' is implemented to return a reference to 'x', thus allowing controlled access to the field without changing its visibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0616.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n\n----------------------------------------\n\nTITLE: Register Class Supported Types for s390x Architecture in Rust Inline Assembly\nDESCRIPTION: This table outlines the supported types for the 'vreg' register class in the s390x architecture, specifying the required target feature and allowed data types for use with these registers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-experimental-reg.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Architecture | Register class | Target feature | Allowed types |\n| ------------ | -------------- | -------------- | ------------- |\n| s390x | `vreg` | `vector` | `i32`, `f32`, `i64`, `f64`, `i128`, `f128`, `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n```\n\n----------------------------------------\n\nTITLE: Using try-job PR description directives for custom CI builds\nDESCRIPTION: This example shows how to specify custom CI jobs to run in a try build by adding try-job directives to a PR description. Each pattern can be an exact job name or a glob pattern matching multiple jobs, and must be on its own line.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ci.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nThis PR fixes #123456.\n\ntry-job: x86_64-msvc\ntry-job: test-various\ntry-job: `*-alt`\n```\n\n----------------------------------------\n\nTITLE: Failing Auto Trait with Generics in Rust\nDESCRIPTION: This code snippet demonstrates an attempt to define an auto trait with a generic type parameter in Rust.  This is not allowed because the compiler cannot infer the generic type for an auto trait, as it is automatically implemented for all existing types. This code will result in a compile error E0567.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0567.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0567\n#![feature(auto_traits)]\n\nauto trait Generic<T> {} // error!\n# fn main() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Compiling for minimal WebAssembly MVP\nDESCRIPTION: These commands compile Rust code for the minimal WebAssembly MVP (Minimum Viable Product) by disabling all supported features by default.  `RUSTFLAGS` is set to specify the target CPU as `mvp`. Cargo's `-Zbuild-std` feature is used to recompile the standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ export RUSTFLAGS=-Ctarget-cpu=mvp\n$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Documenting Deprecated Rust Compiler Error Code\nDESCRIPTION: This markdown snippet explains that a specific error code is no longer emitted by the Rust compiler. It describes the previous condition that triggered the error: multiple macro definitions using the same `#[rustc_builtin_macro(..)]` attribute. The snippet clarifies that this is no longer considered an error in the current version of Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0773.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n#### this error code is no longer emitted by the compiler.\n\nThis was triggered when multiple macro definitions used the same\n`#[rustc_builtin_macro(..)]`. This is no longer an error.\n```\n\n----------------------------------------\n\nTITLE: Calling the public function in an example\nDESCRIPTION: This snippet demonstrates how to call the `a_func` function from an example file. It resides in the `examples/` directory. The `main` function calls `a_crate::a_func()` illustrating how the function can be used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/scraped-examples.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"// a_crate/examples/ex.rs\nfn main() {\n  a_crate::a_func();\n}\"\n```\n\n----------------------------------------\n\nTITLE: Running CI Docker Containers for Testing\nDESCRIPTION: These commands execute various Docker containers used in the Rust CI system to test the changes on different platforms and configurations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n\"./src/ci/docker/run.sh wasm32\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n\"./src/ci/docker/run.sh arm-android\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n\"./src/ci/docker/run.sh dist-various-1\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n\"./src/ci/docker/run.sh dist-various-2\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n\"./src/ci/docker/run.sh armhf-gnu\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Alignment Syntax Examples in Rust\nDESCRIPTION: Examples of incorrect syntax for the align representation hint that will result in compilation error E0693. Shows two invalid ways of specifying alignment: using equals sign and using string literals.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0693.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(align=8)] // error!\nstruct Align8(i8);\n\n#[repr(align=\"8\")] // error!\nstruct Align8(i8);\n```\n\n----------------------------------------\n\nTITLE: Issuing New Rust Error\nDESCRIPTION: This Rust code shows how to issue a new error using the `struct_span_code_err!` macro. It requires a `DiagCtxt`, a span indicating the location of the error, the error code, and a fluent key for the error message. The `.emit()` call actually issues the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/error-codes.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct_span_code_err!(self.dcx(), // some path to the `DiagCtxt` here\n                 span, // whatever span in the source you want\n                 E0592, // your new error code\n                 fluent::example::an_error_message)\n    .emit() // actually issue the error\n\n```\n\n----------------------------------------\n\nTITLE: Public Enum Variant Export\nDESCRIPTION: Example demonstrating how to make enum variants publicly available for external use with pub use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0170.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub use Method::*;\npub enum Method { GET, POST }\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Formatting Type Aliases with Trailing Where Clauses in Rust\nDESCRIPTION: Shows how to format type aliases with a trailing where clause. The code breaks before the equals sign and indents, then breaks before the where keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n// With only a trailing where clause\ntype VeryLongType<T, U>\n    = AnEvenLongerType<T, U, Foo<T>>\nwhere\n    T: U::AnAssociatedType,\n    U: SomeBound;\n```\n\n----------------------------------------\n\nTITLE: Assessing Function Return Types in Rust\nDESCRIPTION: This snippet extends the previous subtyping relationship by adding a return type, demonstrating how type-checking operates under different constraints and ultimately leading to the identification of an error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfor<'a> fn(&'a u32, &'a u32) -> &'a u32\n    <: fn(&'!1 u32, &'!2 u32) -> &'!1 u32\n```\n\n----------------------------------------\n\nTITLE: Unterminated Rust String Literal with Unicode Escape\nDESCRIPTION: This snippet shows an invalid Rust string literal construct often found in test cases or examples (indicated by the `STRING` prefix). The literal `\"\\u{20AA}\"` is missing its closing double quote after the Unicode escape sequence `\\u{20AA}`. This results in a compile-time error from the Rust compiler indicating that the string literal was not properly terminated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_string_with_unicode_escape.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nSTRING \"\\\"\\\\u{20AA}\"\n```\n\n----------------------------------------\n\nTITLE: Trait Definition with RPITIT\nDESCRIPTION: This Rust code defines a trait `Foo` with a method `iter` that returns an `impl Iterator` using RPITIT. It illustrates how the return type captures a lifetime and type parameter, which is important for well-formedness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait Foo {\n    fn iter<'a, T>(x: &'a [T]) -> impl Iterator<Item = &'a T>;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating External Crate Naming Conflict in Rust\nDESCRIPTION: This code snippet shows an erroneous example where the 'std' crate is imported with an alias that conflicts with the 'core' crate. This will result in a compilation error (E0259).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0259.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core;\nextern crate std as core;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Trait Bounds in Rust\nDESCRIPTION: This setting configures the maximum number of bounds a trait can have before the `type_repetition_in_bounds` lint is triggered.  The default is `3`.  This setting determines the threshold used by the lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_30\n\n\n\n----------------------------------------\n\nTITLE: If Chain Macro Pattern Matching\nDESCRIPTION: Using if_chain macro to improve readability of nested pattern matching\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nif_chain! {\n    if let ast::ExprKind::If(check, then, None) = &expr.node;\n    if then.stmts.len() == 1;\n    if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node;\n    if let ast::ExprKind::If(check_inner, content, None) = &inner.node;\n    then {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stack Use After Scope (Rust)\nDESCRIPTION: This Rust program demonstrates the 'use after scope' bug. It captures a mutable pointer to a stack variable within a temporary scope and then attempts to write to that pointer after the scope (and the variable's lifetime) has ended, resulting in undefined behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nstatic mut P: *mut usize = std::ptr::null_mut();\n\nfn main() {\n    unsafe {\n        {\n            let mut x = 0;\n            P = &mut x;\n        }\n        std::ptr::write_volatile(P, 123);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for wasm32-wasip1-threads\nDESCRIPTION: This code snippet is an example of how to use conditional compilation in Rust for the `wasm32-wasip1-threads` target. The code is compiled only when the target OS is 'wasi', the environment is 'p1', and atomics are enabled. This is useful for writing portable Rust code that adapts to different target environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1-threads.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n#[cfg(all(target_os = \"wasi\", target_env = \"p1\", target_feature = \"atomics\"))]\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Strict Provenance Lints in Rust\nDESCRIPTION: Example showing how to enable the strict_provenance_lints feature and fuzzy_provenance_casts lint. The code demonstrates a case where casting from an integer to a pointer triggers a warning under the strict provenance model.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/strict-provenance-lints.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(strict_provenance_lints)]\n#![warn(fuzzy_provenance_casts)]\n\nfn main() {\n    let _dangling = 16_usize as *const u8;\n    //~^ WARNING: strict provenance disallows casting integer `usize` to pointer `*const u8`\n}\n```\n\n----------------------------------------\n\nTITLE: Type Signature Search Queries in Rustdoc\nDESCRIPTION: This snippet explains how to perform searches based on function type signatures, allowing for parameter and return value matching. It outlines the syntax for multiple parameters and provides typical search examples with expected results.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/read-documentation/search.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n| Query | Results |\n|-------|---------|\n| [`usize -> vec`][] | `slice::repeat` and `Vec::with_capacity` |\n| [`vec, vec -> bool`][] | `Vec::eq` |\n| [`option<T>, fnonce -> option<U>`][] | `Option::map` and `Option::and_then` |\n| [`option<T>, (fnonce (T) -> bool) -> option<T>`][optionfilter] | `Option::filter` |\n| [`option<T>, (T -> bool) -> option<T>`][optionfilter2] | `Option::filter` |\n| [`option -> default`][] | `Option::unwrap_or_default` |\n| [`stdout, [u8]`][stdoutu8] | `Stdout::write` |\n| [`any -> !`][] | `panic::panic_any` |\n| [`vec::intoiter<T> -> [T]`][iterasslice] | `IntoIter::as_slice` and `IntoIter::next_chunk` |\n| [`iterator<T>, fnmut -> T`][iterreduce] | `Iterator::reduce` and `Iterator::find` |\n```\n\n----------------------------------------\n\nTITLE: Correct Inline Attribute Usage in Rust\nDESCRIPTION: Shows the proper way to use the `inline` attribute with its two supported arguments: 'always' and 'never'\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0535.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[inline(never)] // ok!\npub fn something() {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Generic Parameters with Foreign Items in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to use generic type parameters with an extern \"C\" function declaration, which is not allowed in Rust and will produce error E0044.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0044.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" { fn some_func<T>(x: T); }\n```\n\n----------------------------------------\n\nTITLE: Enabling Build Standard Library for Bare-Metal Targets\nDESCRIPTION: Cargo configuration to use the nightly build-std feature for compiling core library on Tier 3 Arm targets\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm-none-eabi.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\nbuild-std = [\"core\"]\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Unterminated Byte String Literal\nDESCRIPTION: This error indicates that a byte string literal is missing its closing double quote (\"). The compiler expects byte string literals to be enclosed in double quotes, starting with `b\"`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_ascii_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"BYTE_STRING \\\"b\\\\\"\\\\x7f\" error: Missing trailing `\\\"` symbol to terminate the byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Generic Type Declaration in Rust\nDESCRIPTION: Example showing incorrect syntax using parentheses for generic type Vec. This code will fail to compile with error E0214.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0214.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec(&str) = vec![\"foo\"];\n```\n\n----------------------------------------\n\nTITLE: Byte Literal Error: Missing Trailing Quote\nDESCRIPTION: This error message indicates that the byte literal is missing a closing single quote ('). The compiler expects a single quote to terminate the byte literal, but it is not found. This typically happens when the programmer forgets to close the literal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_space.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"BYTE \\\"b' \\\" error: Missing trailing `'` symbol to terminate the byte literal\"\n```\n\n----------------------------------------\n\nTITLE: Correct Anonymous Import in Rust Documentation\nDESCRIPTION: Demonstrates the correct way to write an anonymous import without the doc(inline) attribute, which is the proper syntax for documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0780.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub use foo::Foo as _;\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Procedural Macros\nDESCRIPTION: This Rust snippet shows procedural macro pattern syntax for matching if expressions without else blocks, used in Clippy lints. Inputs include AST nodes with special conditions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    pat_if_without_else: Expr =\n        If(\n            _,\n            Block(\n                Expr( If(_, _, ())#inner )\n                | Semi( If(_, _, ())#inner )\n            )#then,\n            ()\n        )\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Basic perf Report\nDESCRIPTION: Simple command to display the interactive TUI report of the collected perf data. This provides a basic analysis of where time was spent during execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nperf report\n```\n\n----------------------------------------\n\nTITLE: Two-Phase Borrows Example in Rust\nDESCRIPTION: This example demonstrates the use of two-phase borrows in Rust. It showcases scenarios where these borrows are automatically generated, such as in method calls with mutable reference receivers, mutable reborrows in function arguments, and overloaded compound assignment operators.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/two_phase_borrows.md#2025-04-21_snippet_0\n\nLANGUAGE: rust2018\nCODE:\n```\n// In the source code\n\n// Case 1:\nlet mut v = Vec::new();\nv.push(v.len());\nlet r = &mut Vec::new();\nr.push(r.len());\n\n// Case 2:\nstd::mem::replace(r, vec![1, r.len()]);\n\n// Case 3:\nlet mut x = std::num::Wrapping(2);\nx += x;\n```\n\n----------------------------------------\n\nTITLE: Obtaining Address Using `addr_of!(v).expose_provenance()` in Rust\nDESCRIPTION: This snippet employs the `addr_of!` macro combined with `.expose_provenance()` to extract the address *along with* detailed provenance information, making the address's origin explicit. This method can distinguish addresses that appear identical in value but differ in their provenance, impacting equality comparisons. Dependencies include features from nightly Rust related to pointer provenance exposure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/codegen/equal-pointers-unequal/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\naddr_of!(v).expose_provenance()\n```\n\n----------------------------------------\n\nTITLE: Compiled WebAssembly module from C\nDESCRIPTION: This WebAssembly module shows the C ABI implementation of the `take_my_pair` function, emphasizing the single i32 parameter load, illustrating the ABI difference between Rust and C.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_10\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (import \"env\" \"__linear_memory\" (memory 0))\n  (func $take_my_pair (param i32) (result i32)\n    local.get 0\n    i32.load offset=4\n    local.get 0\n    i32.load\n    i32.add\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Correct Lifetime Capture in impl Trait Return Type (Rust)\nDESCRIPTION: This code snippet shows the correct implementation where the `impl Trait` return type properly captures both lifetimes `'x` and `'y`. The return type is changed to `impl Trait<'y> + 'x` to explicitly capture the `'x` lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0700.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\ntrait Trait<'a> { }\n\nimpl<'a,'b> Trait<'b> for Cell<&'a u32> { }\n\nfn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\nwhere 'x: 'y\n{\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling C code with LTO for Rust staticlib dependency\nDESCRIPTION: This snippet demonstrates how to compile C code with ThinLTO enabled, which is a prerequisite for linking with Rust static libraries compiled with linker plugin LTO. It uses `clang` to compile the C code with the `-flto=thin` flag and optimization level 2 (`-O2`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"clang -c -O2 -flto=thin -o cmain.o ./cmain.c\"\n```\n\n----------------------------------------\n\nTITLE: Line Breaking in Match Arms - Rust\nDESCRIPTION: Demonstrates proper line breaking techniques for match arms with long patterns. Shows preference for block form on right-hand side to avoid breaking patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n    // Assuming the following line does not fit in the max width\n    a_very_long_pattern | another_pattern => ALongStructName {\n        ...\n    },\n    // Prefer this\n    a_very_long_pattern | another_pattern => {\n        ALongStructName {\n            ...\n        }\n    }\n    // To splitting the pattern.\n```\n\n----------------------------------------\n\nTITLE: Dereferencing Raw Pointers in Rust\nDESCRIPTION: This snippet demonstrates how to safely dereference raw pointers in Rust using unsafe blocks. It shows the process for both mutable and immutable pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n\nunsafe {\n    println!(\"{}, {}\", *r1, *r2);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Unsafe Implementation of Safe Trait in Rust\nDESCRIPTION: Shows erroneous code where a safe trait implementation is incorrectly marked as unsafe, resulting in compiler error E0199. This is not allowed in Rust as safe traits should not have unsafe implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0199.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\ntrait Bar { }\n\nunsafe impl Bar for Foo { } // error!\n```\n\n----------------------------------------\n\nTITLE: Invalid Async Non-Move Closure Example\nDESCRIPTION: Demonstrates an erroneous implementation of an async closure without move semantics. This pattern is not supported in the current version of Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0708.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let add_one = async |num: u8| {\n        num + 1\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Use of impl Trait in Path Parameters in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect usage of `impl Trait` in a path parameter, which is not allowed in Rust. The function attempts to use `impl Iterator` as a return type in a path parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0667.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn some_fn(mut x: impl Iterator) -> <impl Iterator>::Item { // error!\n    x.next().unwrap()\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Field Type Line Breaking in Rust\nDESCRIPTION: Demonstrates how to handle struct field types that do not fit on a single line. This involves pulling the type down to its own line and indenting it further.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    a: A,\n    long_name:\n        LongType,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Max Error Size for Result Types in Rust\nDESCRIPTION: This option sets the maximum size of the `Err`-variant in a `Result` returned from a function. This controls the `result_large_err` lint, which warns when error variants are too large. The default value is `128`.  This takes an integer representing the maximum size in bytes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_22\n\n\n\n----------------------------------------\n\nTITLE: Listing Git Remotes\nDESCRIPTION: Displays the configured remote repositories along with their URLs, showing both fetch and push URLs. Typically includes 'origin' (fork) and 'upstream' (main repository). The output shown is an example.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ git remote -v\norigin  git@github.com:jyn514/rust.git (fetch)\norigin  git@github.com:jyn514/rust.git (push)\nupstream        https://github.com/rust-lang/rust (fetch)\nupstream        https://github.com/rust-lang/rust (fetch)\n```\n\n----------------------------------------\n\nTITLE: Implementing Drop for Generic Type with May Dangle\nDESCRIPTION: Shows an erroneous implementation of Drop trait for a generic type that requires marking as unsafe when using #[may_dangle] attribute. The attribute indicates that the destructor will not access the generic type's data, which must be manually verified by the programmer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0569.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(dropck_eyepatch)]\n\nstruct Foo<X>(X);\nimpl<#[may_dangle] X> Drop for Foo<X> {\n    fn drop(&mut self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Links in HTML Warning Blocks\nDESCRIPTION: This example demonstrates adding a link inside an HTML warning block within a Markdown file. An empty line should separate HTML tags from Markdown content to allow proper rendering of Markdown syntax inside HTML. Ensure that your Markdown parser supports this feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/how-to-write-documentation.md#2025-04-21_snippet_3\n\nLANGUAGE: Markdown\nCODE:\n```\n/// documentation\n///\n/// <div class=\"warning\">\n///\n/// Go to [this link](https://rust-lang.org)!\n///\n/// </div>\n///\n/// more documentation\n```\n\n----------------------------------------\n\nTITLE: Drop Elaboration Mechanism - Rust\nDESCRIPTION: This code illustrates the concept of drop elaboration, which involves managing 'drop flags' for variables to ensure effective drop operations at runtime. It highlights the transformation of MIR to include conditions around drop behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/drop-elaboration.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nOne valid model for these rules is to keep a boolean flag (a \"drop flag\") for every structural path that is used at any point in the function. This flag is set when its path is initialized and is cleared when the path is moved from. When a `Drop` occurs, we check the flags for every obligation associated with the target of the `Drop` and call the associated `Drop` impl for those that are still applicable.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0228 Error with Trait Objects and Multiple Lifetimes in Rust\nDESCRIPTION: This code snippet illustrates the E0228 error that occurs when a trait object is used as a type argument in a generic struct with multiple lifetime bounds. The compiler cannot infer the lifetime for the trait object in this context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0228.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { }\n\nstruct TwoBounds<'a, 'b, T: Sized + 'a + 'b> {\n    x: &'a i32,\n    y: &'b i32,\n    z: T,\n}\n\ntype Foo<'a, 'b> = TwoBounds<'a, 'b, dyn Trait>;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0109 Error in Rust\nDESCRIPTION: This snippet shows incorrect usage of generic arguments with non-generic types, triggering the E0109 error. It demonstrates providing a type parameter `i32` to `u32` and a lifetime parameter `'static` to `bool`, neither of which are generic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0109.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ntype X = u32<i32>; // error: type arguments are not allowed for this type\ntype Y = bool<'static>; // error: lifetime parameters are not allowed on\n                        //        this type\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy and Clone Traits in Rust\nDESCRIPTION: This example demonstrates how to implement Copy and Clone traits for a custom type in Rust. It shows a Point struct that can be implicitly copied because it only contains Copy types (integers).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0382.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Using `doc_auto_cfg` to automatically generate `#[doc(cfg)]`\nDESCRIPTION: This Rust snippet shows how to use `doc_auto_cfg`, which automatically generates `#[doc(cfg)]` attributes based on `#[cfg]` attributes. This reduces boilerplate in the code.  It requires the `doc_auto_cfg` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(doc_auto_cfg)]\n\n/// Token struct that can only be used on Windows.\n#[cfg(any(windows, doc))]\npub struct WindowsToken;\n\n/// Token struct that can only be used on Unix.\n#[cfg(any(unix, doc))]\npub struct UnixToken;\n\n/// Token struct that is only available with the `serde` feature\n#[cfg(feature = \"serde\")]\n#[derive(serde::Deserialize)]\npub struct SerdeToken;\n```\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Multiple Mutable Borrows in Rust\nDESCRIPTION: This code snippet demonstrates the E0499 error, which occurs when attempting to create multiple mutable references to the same variable ('i') at the same time. The Rust compiler prevents this to avoid data races and ensure memory safety.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0499.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\n----------------------------------------\n\nTITLE: Configuring Base-Sysroot Test Suite in Rust Build System\nDESCRIPTION: Configuration section for test suite components that require a base sysroot. Lists various test targets including AOT compilation tests, JIT execution tests, and general sysroot tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/config.txt#2025-04-21_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\ntestsuite.base_sysroot\naot.arbitrary_self_types_pointers_and_wrappers\naot.issue_91827_extern_types\njit.std_example\naot.std_example\naot.dst_field_align\naot.subslice-patterns-const-eval\naot.track-caller-attribute\naot.float-minmax-pass\naot.issue-72793\naot.issue-59326\naot.neon\naot.gen_block_iterate\naot.raw-dylib\ntest.sysroot\n```\n\n----------------------------------------\n\nTITLE: Conditionally Compiling for wasm32v1-none in Rust\nDESCRIPTION: Uses Rust's conditional compilation attributes to specify compiling conditions for the wasm32v1-none target, ensuring code is compiled only for WebAssembly targets without operating system support. This method relies on the target family and target OS being set to 'wasm' and 'none,' respectively.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32v1-none.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n#[cfg(all(target_family = \"wasm\", target_os = \"none\"))]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Code Generation Backend in Rust\nDESCRIPTION: Example of how to implement a custom codegen backend for rustc. The implementation requires creating a struct that implements the CodegenBackend trait and exposing a function named __rustc_codegen_backend that returns the backend instance as a boxed trait object.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/codegen-backend.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_codegen_ssa::traits::CodegenBackend;\n\nstruct MyBackend;\n\nimpl CodegenBackend for MyBackend {\n   // Implement codegen methods\n}\n\n#[no_mangle]\npub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n    Box::new(MyBackend)\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Borrowing Scope to Fix Lifetime Error in Rust\nDESCRIPTION: This snippet resolves the lifetime error by altering the scope of the borrowed value. By keeping the scope of `y` outside of any inner blocks, the referenced value remains valid until it is no longer needed, thus preventing the borrowing error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0597.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\n\nlet y = 0;\nx.x = Some(&y);\n\nprintln!(\"{:?}\", x.x);\n```\n\n----------------------------------------\n\nTITLE: Adding WASM Target with Rustup\nDESCRIPTION: Installs the wasm32-wasip1 target using Rustup, which is equipped with necessary tooling for building Rust programs that target the WASI standard through WebAssembly. This is essential for developers looking to compile their Rust code to WebAssembly for use in environments supporting the WASI syscalls.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Lint Emission in Rust\nDESCRIPTION: Example implementation of a LateLintPass that checks expressions and emits a lint with a helpful message using span_lint_and_help.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx> LateLintPass<'tcx> for LintName {\n    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)  {\n        // Imagine that `some_lint_expr_logic` checks for requirements for emitting the lint\n        if some_lint_expr_logic(expr) {\n            span_lint_and_help(\n                cx, // < The context\n                LINT_NAME, // < The name of the lint in ALL CAPS\n                expr.span, // < The span to lint\n                \"message on why the lint is emitted\",\n                None, // < An optional help span (to highlight something in the lint)\n                \"message that provides a helpful suggestion\",\n            );\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating #[rustc_on_unimplemented] Attribute Usage in Rust\nDESCRIPTION: This code snippet demonstrates how to use the #[rustc_on_unimplemented] attribute to specify a custom error message. It shows the syntax for including type parameters and the {Self} placeholder. The code will fail to compile, producing the specified custom error message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0230.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n#![allow(internal_features)]\n\n#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{B}>`\"] // error\ntrait BadAnnotation<A> {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Use of repr(transparent) on Enum in Rust\nDESCRIPTION: This code snippet illustrates an erroneous use of the repr(transparent) attribute on an enum with multiple variants, which triggers the E0731 error. The enum 'Status' has two variants, violating the requirement for transparent enums to have exactly one variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0731.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\nenum Status { // error: transparent enum needs exactly one variant, but has 2\n    Errno(u32),\n    Ok,\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Variadic Function Call - Rust\nDESCRIPTION: This snippet demonstrates an erroneous call to a C variadic function, using an invalid Rust type. It illustrates the requirement to convert Rust types into corresponding C types to comply with the ABI rules before passing them to the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0617.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n# use std::os::raw::{c_char, c_int};\nextern \"C\" {\n    fn printf(format: *const c_char, ...) -> c_int;\n}\n\nunsafe {\n    printf(\"%f\\n\\0\".as_ptr() as _, 0f32);\n    // error: cannot pass an `f32` to variadic function, cast to `c_double`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for Hermit Targets - TOML\nDESCRIPTION: This configuration specifies the build stages and target triplets for Rust when preparing to compile applications for the Hermit unikernel. It includes setting the host target as well as enabling the use of LLVM tools and the Rust linker.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hermit.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\n    \"<HOST_TARGET>\",\n    \"x86_64-unknown-hermit\",\n    \"aarch64-unknown-hermit\",\n    \"riscv64gc-unknown-hermit\",\n]\n\n[rust]\nlld = true\nllvm-tools = true\n```\n\n----------------------------------------\n\nTITLE: Defining a Coroutine with a Single Parameter - Rust\nDESCRIPTION: This snippet provides a corrected implementation of a coroutine in Rust with a single parameter, adhering to the language's parameter restrictions. It illustrates the proper way to define a coroutine, allowing the code to compile successfully and yield the specified parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0628.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#!\\[feature(coroutines, coroutine_trait, stmt_expr_attributes)\\]\\n\\nfn main() {\\n    let coroutine = \\#\\[coroutine\\] |a: i32| {\\n        yield a;\\n    };\\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Visibility Scope in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous visibility declaration in Rust. It attempts to restrict the visibility of a struct `Shark` to a path `crate::Sea`, where `Sea` is an enum, which is not allowed. The compiler will raise an error because visibility scopes can only apply to modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0577.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0577,edition2018\npub enum Sea {}\n\npub (in crate::Sea) struct Shark; // error!\n\nfn main() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Using References in Rust Closures\nDESCRIPTION: This snippet shows how to use a reference in a closure instead of moving a borrowed variable. This approach avoids conflicts with Rust's borrow rules, allowing the closure to execute without moving the variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0504.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn't move `fancy_num`\n        println!(\"child function: {}\", fancy_ref.num);\n    };\n\n    x();\n\n    println!(\"main function: {}\", fancy_num.num);\n}\n```\n\n----------------------------------------\n\nTITLE: Using offset_of_slice Feature with Struct Fields\nDESCRIPTION: Demonstrates how to use the offset_of_slice feature to calculate the byte offset of a slice field within a struct. The example shows a struct with a u32 head field and a dynamically sized [u8] tail field, calculating the offset of the tail field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/offset-of-slice.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(offset_of_slice)]\n\n#[repr(C)]\npub struct Struct {\n    head: u32,\n    tail: [u8],\n}\n\nfn main() {\n    assert_eq!(std::mem::offset_of!(Struct, tail), 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Function with Region Parameter\nDESCRIPTION: Example showing a basic function with a lifetime parameter 'a used to demonstrate region analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(x: &'a u32) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Future Incompatibility Reports in JavaScript\nDESCRIPTION: This snippet outlines the JSON structure emitted when the `--json=future-incompat` flag is used, providing diagnostic information for warnings that may become hard errors in future Rust versions. The structure includes the message type and an array of diagnostics with potential issues. Required dependencies include Rust's compilation diagnostics documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/json.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    /* Type of this message */\n    \"$message_type\": \"future_incompat\",\n    /* An array of objects describing a warning that will become a hard error\n       in the future.\n    */\n    \"future_incompat_report\":\n    [\n        {\n            /* A diagnostic structure as defined in\n               https://doc.rust-lang.org/rustc/json.html#diagnostics\n            */\n            \"diagnostic\": {...},\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Scraping Examples for Documentation with Rustdoc\nDESCRIPTION: This snippet demonstrates how to use rustdoc to collect code examples from a crate and its reverse-dependencies, then include those examples in the documentation. It shows the two-step process with the required command-line options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc examples/ex.rs -Z unstable-options \\\n    --extern foobar=target/deps/libfoobar.rmeta \\\n    --scrape-examples-target-crate foobar \\\n    --scrape-examples-output-path output.calls\n$ rustdoc src/lib.rs -Z unstable-options --with-examples output.calls\n```\n\n----------------------------------------\n\nTITLE: Error Annotation with Multiple Lines\nDESCRIPTION: This example shows how to annotate errors spanning multiple lines or associated with previous comments, using `~^` and `~|`. This provides finer control over the location of the error, especially when it spans several lines or relates to a previous statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet _ = same_line; //~ ERROR undeclared variable\nfn meow(_: [u8]) {}\n//~^ ERROR unsized\n//~| ERROR anonymous parameters\n```\n\n----------------------------------------\n\nTITLE: Fix: Static Coroutine\nDESCRIPTION: This code fixes the E0626 error by marking the coroutine as `static`. This makes the coroutine not movable, allowing borrows to persist across yield points.  Note the `static` keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0626.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n# use std::ops::Coroutine;\n# use std::pin::Pin;\nlet mut b = #[coroutine] static || { // <-- note the static keyword\n    let a = &String::from(\"hello, world\");\n    yield ();\n    println!(\"{}\", a);\n};\nlet mut b = std::pin::pin!(b);\nb.as_mut().resume(());\n```\n\n----------------------------------------\n\nTITLE: Caller Location Usage Example in Rust\nDESCRIPTION: Shows implementation of a function that prints its caller's location using the #[track_caller] attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/implicit-caller-location.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(track_caller)]\nuse std::panic::Location;\n\n#[track_caller]\nfn print_caller() {\n    println!(\"called from {}\", Location::caller());\n}\n\nfn main() {\n    print_caller();\n}\n```\n\n----------------------------------------\n\nTITLE: Test a Specific MIR Pass - Rust\nDESCRIPTION: This code snippet specifies a particular MIR optimization pass to be tested. By adding this to the top of the test file, only the specified pass will be executed, ensuring predictable input and preventing breakage due to changes in other passes. It is useful for isolating and testing individual optimization behaviors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n//@ test-mir-pass: PassName\n```\n\n----------------------------------------\n\nTITLE: Defining Types in Modules\nDESCRIPTION: This snippet defines two modules with functions that demonstrate different type aliases in Rust. It highlights how `rustc_hir::Ty` views type definitions as aliases, while `ty::Ty` expands them to their actual underlying types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    type X = u32;\n    pub fn foo(x: X) -> u32 { 22 }\n}\nmod b {\n    type X = i32;\n    pub fn foo(x: X) -> i32 { x }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Cargo Configuration for s390x-unknown-linux-musl Cross-Compilation\nDESCRIPTION: Comprehensive configuration for .cargo/config.toml specifying all toolchain components for cross-compiling to s390x-unknown-linux-musl when the toolchain is in a custom location.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-musl.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[target.s390x-unknown-linux-musl]\n# Adjust the paths to point at your toolchain\ncc = \"/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc\"\ncxx = \"/TOOLCHAIN_PATH/bin/s390x-linux-musl-g++\"\nar = \"/TOOLCHAIN_PATH/bin/s390x-linux-musl-ar\"\nranlib = \"/TOOLCHAIN_PATH/bin/s390x-linux-musl-ranlib\"\nlinker = \"/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Force Pushing with Lease after Rebase in Git\nDESCRIPTION: Forcefully updates the remote branch with the local branch's state, typically used after rebasing. The `--force-with-lease` option adds a safety check, preventing the push if the remote branch has been updated by someone else since the last fetch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Using -Zfunction-return option in Rust\nDESCRIPTION: The -Zfunction-return compiler option controls how function returns are converted, with support for 'keep' (default behavior) and 'thunk-extern' (convert ret to jmp instructions). Only supported on x86 architectures with non-large code models.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/function-return.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n  - `keep`: do not convert function returns.\n  - `thunk-extern`: convert function returns (`ret`) to jumps (`jmp`)\n    to an external symbol called `__x86_return_thunk`.\n```\n\n----------------------------------------\n\nTITLE: Correct Async Function with Anonymous Lifetime in Rust\nDESCRIPTION: This code snippet shows the correct way to handle lifetimes in an async function by using an anonymous lifetime. The 'Content' struct is given an anonymous lifetime '_', which tells the Rust compiler that 'content' is only needed until the 'create' function finishes execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0726.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn create(content: Content<'_>) { // ok!\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fuchsia Notification Group in Markdown\nDESCRIPTION: This snippet defines the Fuchsia notification group, including the GitHub label, ping command, and a brief description of its purpose. It also includes a link to the Fuchsia ecosystem test job.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/fuchsia.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Fuchsia notification group\n\n**Github Label:** [O-fuchsia] <br>\n**Ping command:** `@rustbot ping fuchsia`\n\n[O-fuchsia]: https://github.com/rust-lang/rust/labels/O-fuchsia\n\nThis list will be used to notify [Fuchsia][fuchsia] maintainers\nwhen the compiler or the standard library changes in a way that would\nbreak the Fuchsia integration.\n\n[fuchsia]: ../tests/ecosystem-test-jobs/fuchsia.md\n```\n\n----------------------------------------\n\nTITLE: Error Message Text Style Example\nDESCRIPTION: This snippet provides an example of how error messages should be written: in plain, simple English, starting with a lowercase letter, and without ending punctuation unless multiple sentences are necessary. Code and identifiers should be surrounded by backticks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n\"error: the fobrulator needs to be krontrificated\"\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Box<T> in Rust\nDESCRIPTION: Demonstrates how to use box patterns to match and destructure Box<T> values in a match expression. The example shows matching on Some(Box<T>) variants and accessing the contained value using the box keyword pattern.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/box-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(box_patterns)]\n\nfn main() {\n    let b = Some(Box::new(5));\n    match b {\n        Some(box n) if n < 0 => {\n            println!(\"Box contains negative number {n}\");\n        },\n        Some(box n) if n >= 0 => {\n            println!(\"Box contains non-negative number {n}\");\n        },\n        None => {\n            println!(\"No box\");\n        },\n        _ => unreachable!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom Theme to `rustdoc` Output (Bash)\nDESCRIPTION: This bash command executes `rustdoc` on a source file (`src/lib.rs`), replacing the default theme with a custom one defined in `awesome.css` using the `--theme` flag. This allows for complete visual overhaul of the generated HTML documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/what-to-include.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nrustdoc --theme awesome.css src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Invalid Functional Record Update on Enum\nDESCRIPTION: Example showing incorrect usage of functional record update syntax on an enum variant, which results in compilation error E0436. The code attempts to use the .. syntax to update an enum variant field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0436.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum PublicationFrequency {\n    Weekly,\n    SemiMonthly { days: (u8, u8), annual_special: bool },\n}\n\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\n                     -> PublicationFrequency {\n    match competitor_frequency {\n        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n            days: (1, 15), annual_special: false\n        },\n        c @ PublicationFrequency::SemiMonthly{ .. } =>\n            PublicationFrequency::SemiMonthly {\n                annual_special: true, ..c // error: functional record update\n                                          //        syntax requires a struct\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Unterminated Character Literal\nDESCRIPTION: This Rust compiler error indicates that a character literal is missing its closing single quote.  The error message includes the specific character literal causing the issue (e.g., '\\x7f). Ensure that all character literals are properly enclosed within single quotes to resolve this error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_char_with_ascii_escape.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"'\\\\x7f\" error: Missing trailing `'` symbol to terminate the character literal\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Negative Default Implementation in Rust\nDESCRIPTION: This code example shows an invalid attempt to combine a negative trait implementation with a default implementation. The code fails to compile because negative impls (which declare no other implementations exist) are incompatible with default impls (which provide default values for other implementations).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0750.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(negative_impls)]\n# #![feature(specialization)]\ntrait MyTrait {\n    type Foo;\n}\n\ndefault impl !MyTrait for u32 {} // error!\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Use of Enums and Trait-associated Types in Rust\nDESCRIPTION: This snippet provides correct examples of how to use an enum directly and a trait's associated type in Rust. The first example shows using the enum 'Rick' directly instead of a variant, and the second example demonstrates using a trait's associated type 'Empire' as a type. It requires knowledge of Rust enums and traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0575.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nenum Rick { Morty }\n\nlet _: Rick; // ok!\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Age {\n    type Empire;\n    fn Mythology() {}\n}\n\nimpl Age for u8 {\n    type Empire = u16;\n}\n\nlet _: <u8 as Age>::Empire; // ok!\n```\n\n----------------------------------------\n\nTITLE: Suppressing Unexpected cfg Warning in Cargo.toml\nDESCRIPTION: This snippet shows how to prevent warnings related to the cfg(bootstrap) condition in Rust by updating the Cargo.toml configuration. By adding specific lint configurations, developers can safely use cfg(bootstrap) without facing unexpected warnings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/bootstrapping/bootstrap-in-dependencies.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(bootstrap)'] }\n```\n\n----------------------------------------\n\nTITLE: Invalid #[repr(C)] on impl block in Rust\nDESCRIPTION: This snippet illustrates an invalid attempt to apply the `#[repr(C)]` attribute to an `impl` block. The `#[repr(C)]` attribute is used to specify the data layout of structs and enums, and is not applicable to implementation blocks.  Trying to use it on an `impl` block will result in a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0517.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\n#[repr(C)]\nimpl Foo {\n    // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Cast: &u8 to u32 in Rust\nDESCRIPTION: Demonstrates the error encountered when attempting to cast a reference of type `&u8` directly to `u32`. This example illustrates the type-safety of casting in Rust, which prevents incompatible types from being cast without dereferencing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0606.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"let x = &0u8; // Here, `x` is a `&u8`.\\nlet y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid\\n\"\n```\n\n----------------------------------------\n\nTITLE: Combining #[doc(hidden)] with Re-exports in Rust\nDESCRIPTION: This example illustrates how `#[doc(hidden)]` interacts with multiple re-exports. `InPrivate` is re-exported as `Hidden` with `#[doc(hidden)]` and then as `Visible`. Only `Visible` appears in the documentation, with its documentation including the documentation from `InPrivate` and its own.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_mod {\n    /// First\n    pub struct InPrivate;\n}\n\n/// Second\n#[doc(hidden)]\npub use self::private_mod::InPrivate as Hidden;\n/// Third\npub use self::Hidden as Visible;\n```\n```\n\n----------------------------------------\n\nTITLE: Building Distribution Artifacts Using Bash\nDESCRIPTION: This snippet demonstrates how to build distribution artifacts for the Rust compiler using a Bash command. It requires a properly configured environment where the command `./x dist` can be executed to compile and package the Rust compiler for distribution. This utility helps in preparing the compiler for release or deployment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/build-install-distribution-artifacts.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./x dist\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_6 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_6` function in Rust, passing a struct `S` with integer members as an argument. It shows how to pass a struct when using the `fastcall` calling convention. The output will depend on the function's specific code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_6(S { x: 10, y: 12 })\n```\n\n----------------------------------------\n\nTITLE: Demonstrating VFE Limitation with Trait Implementation in Rust\nDESCRIPTION: Code example showing a limitation of Virtual Function Elimination where private trait functions might be incorrectly optimized out when they could be called from outside the crate through public interfaces.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/virtual-function-elimination.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo { fn foo(&self) { println!(\"foo\") } }\n\nimpl Foo for usize {}\n\npub struct FooBox(Box<dyn Foo>);\n\npub fn make_foo() -> FooBox { FooBox(Box::new(0)) }\n\n#[inline]\npub fn f(a: FooBox) { a.0.foo() }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Irrefutable Pattern in While-Let Expression (Rust)\nDESCRIPTION: This code snippet shows an example of an irrefutable pattern in a while-let expression, which would have triggered the deprecated compiler error. It defines a struct 'Irrefutable' and attempts to use it in a while-let loop, which fails to compile.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0165.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\n// This fails to compile because the match is irrefutable.\nwhile let Irrefutable(x) = irr {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Package Dependencies and Origin for libc Crate in Rust\nDESCRIPTION: This snippet shows the dependency configuration and origin information for the libc crate. It includes the repository URL, crate name, and specifies that it's not a procedural macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model_with_selective_overrides.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\ndependencies: [],\norigin: Library {\n    repo: Some(\n        \"https://github.com/rust-lang/libc\",\n    ),\n    name: \"libc\",\n},\nis_proc_macro: false,\nproc_macro_cwd: Some(\n    AbsPathBuf(\n        \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n    ),\n),\n```\n\n----------------------------------------\n\nTITLE: Representing Higher Ranked Types with Binder in Rust\nDESCRIPTION: This snippet illustrates how a higher ranked function type, using a generic lifetime, is represented in the Rust compiler as a `Binder` instance. It captures the function type along with the associated lifetimes and kind of bound variables used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/binders.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nBinder(\n    fn(&RegionKind::Bound(DebruijnIndex(0), BoundVar(0)) u32) -> (),\n    &[BoundVariableKind::Region(...)],\n)\n```\n\n----------------------------------------\n\nTITLE: Building and running the type mismatch example without CFI\nDESCRIPTION: Shell commands showing how to build and run the type mismatch example without CFI protection. Without CFI, the invalid function call with mismatched types is allowed and produces a result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --release\n   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)\n    Finished release [optimized] target(s) in 0.44s\n     Running `target/release/rust-cfi-3`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nThe next answer is: 14\n$\n```\n\n----------------------------------------\n\nTITLE: Configuring TCP Stack Parallel Connections\nDESCRIPTION: Modifying startup script to increase maximum TCP threads for better network performance\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nio-pkt-v6-hc -U 33:33 -d e1000 -ptcpip threads_max=300\n```\n\n----------------------------------------\n\nTITLE: Incorrect Function Trait Specification in Rust\nDESCRIPTION: This code demonstrates the incorrect way to specify a function trait using angle-bracket notation without wrapping the argument type in a tuple. This will result in an E0059 compilation error because it doesn't follow the required tuple format for function traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0059.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unboxed_closures)]\n\nfn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Associated Type Mismatch in Rust Trait Implementation\nDESCRIPTION: This code snippet shows an example that triggers the E0271 error in Rust. It defines a trait with an associated type, a function with a trait bound specifying the associated type, and an implementation that doesn't match the specified type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0271.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n----------------------------------------\n\nTITLE: Inlining a Function Call in Rust\nDESCRIPTION: Demonstrates inlining a function call by replacing it with its implementation. This example shows how Option::unwrap() gets expanded into its actual match expression implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_66\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(name: Option<&str>) {\n    let name = name.unwrap┃();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(name: Option<&str>) {\n    let name = match name {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Const Function with Trait Bounds in Rust\nDESCRIPTION: Here, the function 'foo' is defined as a const function in Rust with a trait bound using the 'maybe' const qualifier. The snippet illustrates how const conditions are checked in conjunction with traits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/effects.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst fn foo<T>() where T: ~const Default {}\n```\n\n----------------------------------------\n\nTITLE: Rust Comment Formatting\nDESCRIPTION: Shows examples of comment styles, including line comments, inline comments, and guidelines for writing clear, complete sentence comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// A comment on an item.\nstruct Foo { ... }\n\nfn foo() {} // A comment after an item.\n\npub fn foo(/* a comment before an argument */ x: T) {...}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Rust Executable for Hexagon Standalone OS (Shell)\nDESCRIPTION: Shell script that compiles a Rust project for the `hexagon-unknown-none-elf` target using `cargo build` with `build-std`, then links the resulting Rust library (`.rlib`), core/compiler builtins, and Hexagon SDK C runtime objects (`crt0_standalone.o`, `libc.a`, etc.) using `clang` (or `hexagon-unknown-none-elf-clang`) to create a standalone executable (`testit`). Finally, it runs the executable using `qemu-system-hexagon`. Requires setting paths for the Hexagon SDK (`hex_sdk_root`), toolchain (`hex_toolchain`), and specifying the compiler (`cc`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# Hexagon SDK, required for target libraries:\nhex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0\nhex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06\n\nsdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib\nq6_arch=v65\ng0_lib_path=${sdk_libs}/${q6_arch}/G0\npic_lib_path=${sdk_libs}/${q6_arch}/G0/pic\n\nbuild_cfg=release\ncargo build --target=hexagon-unknown-none-elf -Zbuild-std --release\n\n# Builds an executable against \"hexagon standalone OS\" suitable for emulation:\n${cc} --target=hexagon-unknown-none-elf -o testit \\\n    -fuse-ld=lld \\\n    -m${q6_arch} \\\n    -nodefaultlibs \\\n    -nostartfiles \\\n    ${g0_lib_path}/crt0_standalone.o \\\n    ${g0_lib_path}/crt0.o \\\n    ${g0_lib_path}/init.o \\\n    -L${sdk_libs}/${q6_arch}/ \\\n    -L${sdk_libs}/ \\\n    wrap.c \\\n    target/hexagon-unknown-none-elf/${build_cfg}/libdemo1_hexagon.rlib \\\n    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \\\n    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \\\n    -Wl,--start-group \\\n    -Wl,--defsym,_SDA_BASE_=0,--defsym,__sbss_start=0,--defsym,__sbss_end=0 \\\n    ${g0_lib_path}/libstandalone.a \\\n    ${g0_lib_path}/libc.a \\\n    -lgcc \\\n    -lc_eh \\\n    -Wl,--end-group \\\n    ${g0_lib_path}/fini.o \\\n\n${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon -monitor none -display none -kernel ./testit\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Naming Conflict in Rust\nDESCRIPTION: This code snippet illustrates a naming conflict that occurs when importing two items with the same name 'baz' from different modules. The error is triggered by the wildcard import from 'bar', which conflicts with the explicit import of 'baz' from 'foo'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0251.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::baz;\nuse bar::*; // error, do `use foo::baz as quux` instead on the previous line\n\nfn main() {}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Rust Foreign Function Declaration Using Tuple Argument\nDESCRIPTION: This example demonstrates passing a tuple directly as an argument to a foreign function, which is valid in Rust FFI. It provides an alternative to pattern destructuring, ensuring compatibility with external linkage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0130.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"C\" {\n    fn foo(a: (u32, u32)); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Struct Bool Fields in Rust\nDESCRIPTION: This option configures the maximum number of boolean fields a struct can have before the `struct_excessive_bools` lint is triggered.  The default is `3`. This controls how many boolean fields are allowed before triggering the lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_28\n\n\n\n----------------------------------------\n\nTITLE: Including Config Extensions in TOML\nDESCRIPTION: This snippet demonstrates including additional TOML configuration files into a primary file, showing how to manage layered configurations. Inclusions are processed in right-to-left order for overriding settings, and parent files override the included ones in conflicts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\ninclude = [\"cross.toml\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Item Ordering Groupings in Rust\nDESCRIPTION: This option specifies the named groupings of different source item kinds within modules. This influences the `arbitrary_source_item_ordering` lint. The default value is a nested array of strings representing module groupings and their respective item types. This configuration allows to specify the module item order.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_33\n\n\n\n----------------------------------------\n\nTITLE: Running Graphviz for Rust Debugging Output\nDESCRIPTION: This Bash snippet demonstrates how to convert a Graphviz .dot file into a PDF using the 'dot' command. It requires an installed Graphviz package and outputs the rendered graph as a PDF, viewable with any PDF reader.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ dot -T pdf maybe_init_suffix.dot > maybe_init_suffix.pdf\n$ firefox maybe_init_suffix.pdf # Or your favorite pdf viewer\n```\n\n----------------------------------------\n\nTITLE: Basic Coroutine Usage Example in Rust\nDESCRIPTION: Demonstrates basic coroutine functionality with yield and resume operations. Shows how to create a coroutine that yields a value and returns a final result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coroutines.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nuse std::ops::{Coroutine, CoroutineState};\nuse std::pin::Pin;\n\nfn main() {\n    let mut coroutine = #[coroutine] || {\n        yield 1;\n        return \"foo\"\n    };\n\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Yielded(1) => {}\n        _ => panic!(\"unexpected value from resume\"),\n    }\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Complete(\"foo\") => {}\n        _ => panic!(\"unexpected value from resume\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a Type is a Diagnostic Item in Rust\nDESCRIPTION: This snippet shows a function that checks if a given type (`ty`) is of type `HashMap` by leveraging the `TyCtxt::is_diagnostic_item()` method within Rust's compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-items.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse rustc_span::symbol::sym;\n\n/// This example checks if the given type (`ty`) has the type `HashMap` using\n/// `TyCtxt::is_diagnostic_item()`\nfn example_1(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n    match ty.kind() {\n        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::HashMap, adt.did()),\n        _ => false,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rebasing Feature Branch on Master\nDESCRIPTION: Pulls the latest changes from the specified remote URL and branch (`https://github.com/rust-lang/rust.git master`) and reapplies the commits from the current branch on top of the fetched commits. This is the standard way to rebase a feature branch on the main project branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ngit pull --rebase https://github.com/rust-lang/rust.git master\n```\n\n----------------------------------------\n\nTITLE: Defining Subdiagnostic Enum in Rust\nDESCRIPTION: Example of using #[derive(Subdiagnostic)] to define an enum representing different types of expected return type labels. It demonstrates the use of #[label] attributes and #[primary_span] for specifying diagnostic details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-structs.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Subdiagnostic)]\npub enum ExpectedReturnTypeLabel<'tcx> {\n    #[label(hir_analysis_expected_default_return_type)]\n    Unit {\n        #[primary_span]\n        span: Span,\n    },\n    #[label(hir_analysis_expected_return_type)]\n    Other {\n        #[primary_span]\n        span: Span,\n        expected: Ty<'tcx>,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Borrowing Element from a Non-Copy Fixed-Size Array in Rust\nDESCRIPTION: This snippet demonstrates how to properly borrow an element from a non-copy fixed-size array. By using a reference (`&array[0]`), developers can access the element without violating ownership rules, allowing for safe usage of non-copy types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0508.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n}\n```\n\n----------------------------------------\n\nTITLE: Error Example: Too Many Lifetime Arguments in Rust Function Call\nDESCRIPTION: This example demonstrates the E0107 error, which occurs when providing lifetime arguments to a function that doesn't expect any. The function f() takes no lifetime parameters, but is incorrectly called with 'static as a lifetime argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0088.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f() {}\n\nfn main() {\n    f::<'static>() // error: wrong number of lifetime arguments:\n                   //        expected 0, found 1\n}\n```\n\n----------------------------------------\n\nTITLE: Promoting Local Variables to Constants in Rust\nDESCRIPTION: Converts a local variable to a const item, changing its name to SCREAMING_SNAKE_CASE convention. This refactoring is applicable when the variable is initialized with a constant expression and improves code clarity by making immutability explicit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_92\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let foo = true;\n\n    if foo {\n        println!(\"It's true\");\n    } else {\n        println!(\"It's false\");\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    const FOO: bool = true;\n\n    if FOO {\n        println!(\"It's true\");\n    } else {\n        println!(\"It's false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Analysis for Semantic Information in Rust\nDESCRIPTION: This snippet explains how to retrieve analysis instances using the analysis method from the AnalysisHost. It is essential for extracting semantic information during the development process, enabling IDE features like autocompletion and definition lookup.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Getting an instance of Analysis from the host\nlet analysis_instance = analysis_host.analysis();\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Unterminated Byte Literal\nDESCRIPTION: This snippet showcases a Rust compiler error message indicating a missing closing single quote for a byte literal. The error message points out that the byte literal is not terminated properly, causing a syntax error during compilation. The fix is to add the missing single quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_ferris.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"BYTE \\\"b'🦀\\\" error: Missing trailing `'` symbol to terminate the byte literal\"\n```\n\n----------------------------------------\n\nTITLE: Compiling with rustc for Fuchsia\nDESCRIPTION: This shell command compiles a Rust file for Fuchsia using rustc with specified target and library paths. Customize <SDK_PATH>, <ARCH>, and <TARGET_ARCH> according to the target architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n# Configure these for the Fuchsia target of your choice\nTARGET_ARCH=\"<x86_64-unknown-fuchsia|aarch64-unknown-fuchsia>\"\nARCH=\"<x64|aarch64>\"\n\nrustc \\\n    --target ${TARGET_ARCH} \\\n    -Lnative=${SDK_PATH}/arch/${ARCH}/lib \\\n    -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib \\\n    --out-dir bin src/hello_fuchsia.rs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Module Name Ambiguity Error in Rust\nDESCRIPTION: Shows an example of a module naming conflict where both ambiguous_module.rs and ambiguous_module/mod.rs exist in the same project. This causes a compilation error as Rust cannot determine which file to use for the module definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0761.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// file: ambiguous_module/mod.rs\n\nfn foo() {}\n\n// file: ambiguous_module.rs\n\nfn foo() {}\n\n// file: lib.rs\n\nmod ambiguous_module; // error: file for module `ambiguous_module`\n                      // found at both ambiguous_module.rs and\n                      // ambiguous_module/mod.rs\n```\n\n----------------------------------------\n\nTITLE: Setting linking arguments via RUSTFLAGS for cargo\nDESCRIPTION: This snippet demonstrates how to set linking arguments via the `RUSTFLAGS` environment variable when using `cargo`. It includes `-Clinker-plugin-lto`, `-Clinker=clang`, and `-Clink-arg=-fuse-ld=lld` flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n\"RUSTFLAGS=\\\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld\\\" cargo build --release\"\n```\n\n----------------------------------------\n\nTITLE: Defining vectorcall Functions in Rust\nDESCRIPTION: This snippet defines functions utilizing the vectorcall calling convention, which is designed for performance in scenarios with SIMD (Single Instruction, Multiple Data) operations. The snippet provides multiple function definitions. Requires Rust standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-import-name-type/output.txt#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nvectorcall_fn_undecorated(10)\nvectorcall_fn_undecorated2(20)\nvectorcall_fn_noprefix(11)\nvectorcall_fn_decorated(12)\n```\n\n----------------------------------------\n\nTITLE: Building and running CFI-disabled code in Rust\nDESCRIPTION: Shell commands showing how to build and run the above example without CFI protection. Without CFI, the invalid control flow is allowed and the program executes without errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --release\n   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)\n    Finished release [optimized] target(s) in 0.42s\n     Running `target/release/rust-cfi-1`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nThe next answer is: 14\n$\n```\n\n----------------------------------------\n\nTITLE: Compile-Fail Example: Invalid Indexing in Rust\nDESCRIPTION: This code snippet demonstrates an example that fails to compile because it attempts to index into a `u8` type, which does not implement the `std::ops::Index` trait. This results in the E0608 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0608.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"0u8[2]; // error: cannot index into a value of type `u8`\"\n```\n\n----------------------------------------\n\nTITLE: Attempting to Access Private Field in Rust Struct\nDESCRIPTION: This code snippet demonstrates an error in Rust when trying to access a private field of a struct. The field 'x' in struct 'Foo' is private and accessing it from outside the module results in a compile error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0616.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0069 Error with Invalid Return Statement in Rust\nDESCRIPTION: This code snippet demonstrates erroneous Rust code that causes compiler error E0069. The function `foo()` declares a return type of `u8` but uses an empty return statement (`return;`), which implicitly returns `()`, causing a type mismatch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0069.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// error\nfn foo() -> u8 {\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting keywords using `#[doc(keyword = \"...\")]`\nDESCRIPTION: This Rust snippet demonstrates how to document Rust keywords using the `#[doc(keyword = \"...\")]` attribute. This attribute is intended for internal use by the Rust compiler and standard library. It requires the `rustdoc_internals` feature and `internal_features` to be allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![feature(rustdoc_internals)]\n#![allow(internal_features)]\n\n/// Some documentation about the keyword.\n#[doc(keyword = \"break\")]\nmod empty_mod {}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Mutable References in Rust Constant Functions\nDESCRIPTION: This code snippet demonstrates the correct usage of mutable references within a constant function in Rust. It shows how to modify a value using a mutable reference inside a const fn, which is then used to initialize a constant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0764.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst fn foo(x: usize) -> usize {\n    let mut y = 1;\n    let z = &mut y;\n    *z += x;\n    y\n}\n\nfn main() {\n    const FOO: usize = foo(10); // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fluent Diagnostic Message with Arguments\nDESCRIPTION: Here is a Fluent diagnostic message that includes an argument, allowing for dynamic content in the message. This example shows how the message can be tailored based on context, such as the specific item being referenced.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/translation.md#2025-04-21_snippet_2\n\nLANGUAGE: fluent\nCODE:\n```\ntypeck_struct_expr_non_exhaustive =\n    cannot create non-exhaustive {$what} using struct expression\n```\n\n----------------------------------------\n\nTITLE: Valid Self Parameter Examples in Rust Methods\nDESCRIPTION: Examples of valid self parameter usage in Rust methods, including both the standard form and a more advanced form using a concrete smart pointer type that would be allowed with the Arbitrary Self Types feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0801.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn foo(self) {}\n    fn foo2(self: std::rc::Rc<Self>) {} // or some other similar\n        // smart pointer if you enable arbitrary self types and\n        // the pointer implements Deref<Target=Self>\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Changelog - Markdown\nDESCRIPTION: These markdown snippets describe changes that need to be applied to the `CHANGELOG.md` file when a new stable version is released.  It involves removing the `(beta)` tag from the new stable version header, updating release dates for both the new and previous stable versions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n## Rust 1.XX (beta) -> ## Rust 1.XX\n```\n\nLANGUAGE: markdown\nCODE:\n```\nCurrent beta, release 20YY-MM-DD -> Current stable, released 20YY-MM-DD\n```\n\nLANGUAGE: markdown\nCODE:\n```\nCurrent stable, released 20YY-MM-DD -> Released 20YY-MM-DD\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Associated Type Error in Rust\nDESCRIPTION: This example shows code that produces the E0221 error due to ambiguous associated type definitions between two traits. The trait Bar inherits from Foo but redefines the same associated type name 'A' with a different bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0221.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait T1 {}\ntrait T2 {}\n\ntrait Foo {\n    type A: T1;\n}\n\ntrait Bar : Foo {\n    type A: T2;\n    fn do_something() {\n        let _: Self::A;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CoerceUnsized Incorrectly in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous implementation of CoerceUnsized trait for a struct Foo<T>. The error occurs because the trait is implemented for a generic type U, which is not guaranteed to be a struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0376.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo<T: ?Sized> {\n    a: T,\n}\n\n// error: The type `U` is not a struct\nimpl<T, U> CoerceUnsized<U> for Foo<T> {}\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation with Associated Type Definition in Rust\nDESCRIPTION: This code implements the `Identity` trait for all types `T`, defining the associated type `Out` as `T` itself.  The ellipsis signifies the omitted implementation details. This shows a generic implementation of a trait where the associated type is the implementing type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n\"impl<T> Identity for T { type Out = T; ... }\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deprecated LLVM Assembly Macro Error in Rust\nDESCRIPTION: This code snippet shows an example of incorrectly using the llvm_asm macro, which would have previously triggered a compiler error. The macro is called with two separate string literals instead of a single, properly formatted string.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0660.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nllvm_asm!(\"nop\" \"nop\");\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_6 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_6` function in Rust, passing a struct `S` with integer members as the argument. It demonstrates passing a struct as a function argument using the `stdcall` calling convention. The expected output depends on the implementation of `stdcall_fn_6`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_6(S { x: 10, y: 12 })\n```\n\n----------------------------------------\n\nTITLE: Invalid Region Outlives Example\nDESCRIPTION: Example demonstrating an invalid function where lifetime 'a doesn't necessarily outlive 'b, used to illustrate region inference errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b>(x: &'a usize) -> &'b usize {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Struct and Function Definition with Generic Parameters\nDESCRIPTION: Example showing how universes work with generic lifetime and type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo { }\n\nfn bar<'a, T>(t: &'a T) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for M68K Target\nDESCRIPTION: Recommended Cargo configuration (.cargo/config.toml) for building Rust programs targeting M68K bare metal. Includes settings for the build standard library and linker configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\nbuild-std = [\"panic_abort\", \"core\", \"alloc\"]\n\n[target.m68k-unknown-none-elf]\n# as we're building for ELF, the m68k-linux linker should be adequate\nlinker = \"m68k-linux-gnu-ld\"\n\n# the mold linker also supports m68k, remove the above line and uncomment the\n# following ones to use that instead\n# linker = \"clang\"\n# rustflags = [\"-C\", \"link-arg=-fuse-ld=/path/to/mold/binary\"]\n```\n\n----------------------------------------\n\nTITLE: Correctly Renaming Struct Fields in Pattern Matching\nDESCRIPTION: This example shows the correct way to rename a struct field during pattern matching in Rust. To refer to the struct field by a different name, you must explicitly rename it using the 'field: new_name' syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0026.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Thing {\n    x: u32,\n    y: u32,\n}\n\nlet thing = Thing { x: 0, y: 0 };\n\nmatch thing {\n    Thing { x, y: z } => {} // we renamed `y` to `z`\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Let-Chain Control Lines in Rust\nDESCRIPTION: Guidelines for formatting let-chain expressions in Rust. Single-line formatting is allowed for simple cases with specific constraints; otherwise, multi-line formatting with proper indentation is required.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nif a && let Some(b) = foo() {\n    // ...\n}\n\nif true && let Some(b) = foo() {\n    // ...\n}\n\nlet operator = if !from_hir_call && let Some(p) = parent {\n    // ...\n};\n\nif let Some(b) = foo()\n    && a\n{\n    // ..\n}\n\nif foo()\n    && let Some(b) = bar\n{\n    // ...\n}\n\nif gen_pos != GenericArgPosition::Type\n    && let Some(b) = gen_args.bindings.first()\n{\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Elision Errors in Rust Functions\nDESCRIPTION: This code snippet illustrates examples of lifetime elision errors in Rust function signatures. It shows cases where the lifetime elision rules are not satisfied, leading to compilation errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0106.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// error, no input lifetimes\nfn foo() -> &str { }\n\n// error, `x` and `y` have distinct lifetimes inferred\nfn bar(x: &str, y: &str) -> &str { }\n\n// error, `y`'s lifetime is inferred to be distinct from `x`'s\nfn baz<'a>(x: &'a str, y: &str) -> &str { }\n```\n\n----------------------------------------\n\nTITLE: Checking rustc and clang versions\nDESCRIPTION: This snippet shows how to check the versions of `rustc` and `clang-cl` to ensure compatibility for cross-language LTO on Windows.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_9\n\nLANGUAGE: bat\nCODE:\n```\n\"rustc -V --verbose\\nclang-cl --version\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust for UEFI Targets - TOML\nDESCRIPTION: This configuration allows building Rust for the x86_64-unknown-uefi target. It specifies the build stage and target architecture required for Rust compilation for UEFI.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-unknown-uefi\"]\n```\n\n----------------------------------------\n\nTITLE: Correcting Trait Implementation with Matching Parameters in Rust\nDESCRIPTION: This code snippet demonstrates the correct implementation of the 'Foo' trait for 'Bar' struct. The 'foo' method in the implementation now has the same number of parameters as specified in the trait, resolving the compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0050.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo(&self, x: u8) -> bool;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo(&self, x: u8) -> bool { // ok!\n        true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Shell Args Structure in TypeScript\nDESCRIPTION: Outlines the essential shell argument configurations for executing shell commands. This TypeScript structure supports environment setups and command organization necessary for executing related Rust projects within a shell environment, maintaining consistency in operation flows.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    environment?: Record<string, string>;\n    cwd: string;\n    kind: string;\n    program: string;\n    args: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Methods Through Trait Interfaces to Resolve Ambiguity\nDESCRIPTION: This code snippet demonstrates how to call methods through trait interfaces when a struct implements multiple traits with the same method name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0034.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Compilation Targets in bootstrap.toml\nDESCRIPTION: This snippet shows how to configure cross-compilation targets in the `bootstrap.toml` file.  The `target` key in the `[build]` section specifies a list of target platforms to always build for.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"x86_64-unknown-linux-gnu\", \"wasm32-wasip1\"]\n```\n\n----------------------------------------\n\nTITLE: Invalid Struct Field Usage in Rust\nDESCRIPTION: This example demonstrates the E0560 error that occurs when attempting to use a field that doesn't exist in a struct definition. The error is triggered when 'father' is used in the struct initialization despite not being defined in the Simba struct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0560.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\n----------------------------------------\n\nTITLE: Eager Nested Goal Evaluation in Old Rust Trait System\nDESCRIPTION: In the old trait system, nested goals are eagerly handled during evaluation, while in fulfillment they are returned for later processing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/significant-changes.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Source: eval-nested\nlet (predicate, candidate) = self.infcx.probe(|_| {\n    match candidate.kind {\n        BuiltinCandidate(predicate) => (predicate, candidate),\n        ProjectionCandidate => {\n            let result = self.evaluate_projection_candidate(\n                stack,\n                candidate,\n                param_env,\n                obligation,\n            );\n            (result.predicate, result.candidate)\n        }\n        // ... (other cases)\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Using Half-Open Range Patterns in Rust Slices\nDESCRIPTION: Demonstrates the usage of half-open range patterns directly in slice patterns with the half_open_range_patterns_in_slices feature flag. Shows multiple range pattern types including inclusive ranges, exclusive ranges, and binding to variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/half-open-range-patterns-in-slices.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(half_open_range_patterns_in_slices)]\n\nfn main() {\n    let xs = [13, 1, 5, 2, 3, 1, 21, 8];\n    let [a @ 3.., b @ ..3, c @ 4..6, ..] = xs else { return; };\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Where Clause Usage with Generic Type in Rust\nDESCRIPTION: This example shows the correct way to use where clauses with generic type parameters. The implementation of Foo for Wrapper<T> is conditional on T implementing Clone, which is a valid use case for where clauses.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0193.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n#[derive(Copy,Clone)]\nstruct Wrapper<T> {\n    Wrapped: T\n}\nimpl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {\n    fn bar(&self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Object-Safe Traits with Unsized Self in Rust\nDESCRIPTION: This snippet shows how traits with by-value self can be object-safe when using the unsized_fn_params feature. It illustrates creating and using trait objects with unsized types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_fn_params)]\n\ntrait Foo {\n    fn foo(self) {}\n}\n\nimpl<T: ?Sized> Foo for T {}\n\nfn main () {\n    let slice: Box<dyn Foo> = Box::new([1, 2, 3]);\n    // doesn't compile yet\n    <dyn Foo as Foo>::foo(*slice);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FetchDependencyList Parameters Interface in TypeScript\nDESCRIPTION: TypeScript interface for the request parameters of the 'rust-analyzer/fetchDependencyList' method. This method takes no parameters, so the interface is empty.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FetchDependencyListParams {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Usage of Visibility Qualifiers in Rust\nDESCRIPTION: This code snippet shows erroneous examples of using visibility qualifiers where they are not permitted in Rust. It includes incorrect usage in enum variants, impl blocks, and trait implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0449.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    fn foo();\n}\n\nenum Baz {\n    pub Qux, // error: visibility qualifiers are not permitted here\n}\n\npub impl Bar {} // error: visibility qualifiers are not permitted here\n\npub impl Foo for Bar { // error: visibility qualifiers are not permitted here\n    pub fn foo() {} // error: visibility qualifiers are not permitted here\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Rust Code With Explicit Lifetime Bound\nDESCRIPTION: The corrected version adds a where clause to the struct definition specifying that T must outlive 'a, which satisfies the requirements of the SomeTrait implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0309.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Unnamed Function Type Alias in Rust\nDESCRIPTION: This snippet shows how to generate a type alias for a function with unnamed parameters. It creates a new type alias that matches the function's signature, including safety qualifiers and return type, but omits parameter names.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_53\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn foo(n: i32) -> i32 { 42i32 }\n```\n\nLANGUAGE: rust\nCODE:\n```\ntype ${0:FooFn} = unsafe fn(i32) -> i32;\n\nunsafe fn foo(n: i32) -> i32 { 42i32 }\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_9 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_9` function in Rust, passing an integer (1) and a floating-point number (3.0) as arguments. This showcases the `fastcall` convention being used. The outcome is determined by how the called function is implemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_9(1, 3.0)\n```\n\n----------------------------------------\n\nTITLE: Rust example for dataflow analysis\nDESCRIPTION: Presents a Rust function `foo` with an uninitialized variable `x` that might lead to a compilation error. The example is used to illustrate how dataflow analysis can be used to determine if `x` is initialized before being used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_3\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo() {\n    let mut x;\n\n    if some_cond {\n        x = 1;\n    }\n\n    dbg!(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Time in Trait Solver with perf-focus\nDESCRIPTION: Example of using perf-focus with a complex regex to determine how much time the MIR borrowchecker spends in the trait solver. This demonstrates advanced perf-focus usage with path matching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ perf focus '{do_mir_borrowck}..{^rustc::traits}'\nMatcher    : {do_mir_borrowck},..{^rustc::traits}\nMatches    : 12\nNot Matches: 1311\nPercentage : 0%\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Opaque Type Inference in Rust\nDESCRIPTION: Example showing how opaque types are defined and used across module boundaries, including trait bounds and type inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod m {\n    pub type Seq<T> = impl IntoIterator<Item = T>;\n\n    pub fn produce_singleton<T>(t: T) -> Seq<T> {\n        vec![t]\n    }\n\n    pub fn produce_doubleton<T>(t: T, u: T) -> Seq<T> {\n        vec![t, u]\n    }\n}\n\nfn is_send<T: Send>(_: &T) {}\n\npub fn main() {\n    let elems = m::produce_singleton(22);\n\n    is_send(&elems);\n\n    for elem in elems {\n        println!(\"elem = {:?}\", elem);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Missing Trailing Quote in Byte Literal\nDESCRIPTION: This error indicates that a byte literal (denoted by `b'...'`) is missing its closing single quote. The Rust compiler requires that all byte literals be properly terminated to be parsed correctly. The user needs to add the missing quote to resolve the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_with_slash.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"BYTE \\\"b'\\\\\\\" error: Missing trailing `'` symbol to terminate the byte literal\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Suggestions with Macros in Rust\nDESCRIPTION: This Rust snippet defines how static suggestions are implemented in the suggest-tests tool using a macro. Static suggestions utilize globs that map directly to specific commands, making them straightforward and easy to implement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/suggest-tests.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nmacro_rules! static_suggestion { /* macro implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Using remap-cwd-prefix Flag with Rust Compiler (sh)\nDESCRIPTION: This example demonstrates using the -Z remap-cwd-prefix flag to replace absolute paths to main.rs with a relative path in build outputs. This helps produce deterministic build outputs by removing machine-specific working directory references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/remap-cwd-prefix.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# This would produce an absolute path to main.rs in build outputs of\n# \"./main.rs\".\nrustc -Z remap-cwd-prefix=. main.rs\n```\n\n----------------------------------------\n\nTITLE: Invalid Pattern Matching in Rust - Error E0164\nDESCRIPTION: This example demonstrates incorrect usage of a method as a pattern in a match expression, which results in compilation error E0164. The code attempts to match against A::new() which is a method, not a tuple struct or variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0164.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum A {\n    B,\n    C,\n}\n\nimpl A {\n    fn new() {}\n}\n\nfn bar(foo: A) {\n    match foo {\n        A::new() => (), // error!\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Examples Pre-processing in rustdoc\nDESCRIPTION: This section details how rustdoc preprocesses examples before test execution. No code snippets were provided for preprocessing directly. It involves adding common `allow` attributes, handling crate declarations, and wrapping code in a main function if necessary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Updating Beta Branch - Bash\nDESCRIPTION: This command sequence updates the `beta` branch in the Clippy repository to match the specified commit hash (`SHA`). It checks out the `beta` branch, resets it to the desired commit, and then pushes the updated branch to the `upstream` remote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout beta\ngit reset --hard $SHA\ngit push upstream beta\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Fork in Git\nDESCRIPTION: Illustrates different ways to push changes to the 'origin' remote (fork). `--set-upstream` is used for the initial push, `git push` for subsequent pushes, and `git push --force-with-lease` after rebasing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n# Initial push\ngit push --set-upstream origin issue-12345-fix\n\n# Subsequent pushes after adding commits\ngit push\n\n# Pushing after rebasing\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Trait Implementation in Rust\nDESCRIPTION: This code snippet shows an erroneous implementation of the 'Foo' trait for 'Bar' struct. The 'foo' method in the implementation has fewer parameters than specified in the trait, causing a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0050.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo(&self, x: u8) -> bool;\n}\n\nstruct Bar;\n\n// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n// has 2\nimpl Foo for Bar {\n    fn foo(&self) -> bool { true }\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Struct Field Public in Rust\nDESCRIPTION: This code snippet illustrates how to access a struct's field by setting it public in Rust. By declaring 'x' as 'pub', it allows access from outside the module, resolving the previous access error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0616.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n----------------------------------------\n\nTITLE: Interactively Rebasing onto Upstream Master in Git\nDESCRIPTION: Starts an interactive rebase session to re-apply commits from the current branch onto the latest 'upstream/master'. This is used to maintain a linear history and incorporate upstream changes, or fix accidental merge commits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ngit rebase -i upstream/master\n```\n\n----------------------------------------\n\nTITLE: Updating Stable Branch - Bash\nDESCRIPTION: This command sequence updates the `stable` branch in the Clippy repository to match the specified commit hash (`SHA`). It checks out the `stable` branch, resets it to the desired commit, and then pushes the updated branch to the `upstream` remote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout stable\ngit reset --hard $SHA\ngit push upstream stable\n```\n\n----------------------------------------\n\nTITLE: Qualifying Method Calls in Rust\nDESCRIPTION: Converts an object method call to a fully qualified function call notation. This refactoring makes the implementation being called more explicit, which can be helpful for clarity or disambiguating between trait implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_94\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nimpl Foo {\n    fn foo(&self) {}\n}\nfn main() {\n    let foo = Foo;\n    foo.foo();\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nimpl Foo {\n    fn foo(&self) {}\n}\nfn main() {\n    let foo = Foo;\n    Foo::foo(&foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Making Methods Conditionally Available for Sized Types in Rust\nDESCRIPTION: Shows how to use a `where Self: Sized` bound to make specific methods unavailable for trait objects while keeping them available for concrete types. This enables creating trait objects while restricting certain methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring check-inconsistent-struct-field-initializers\nDESCRIPTION: This configures whether to suggest reordering constructor fields when initializers are present. Warnings produced by this configuration aren't necessarily fixed by just reordering the fields, as the order may change semantics if the initializer expressions have side effects. It is a boolean value and defaults to false.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Defining Tuple Structs and Variants in Rust\nDESCRIPTION: This snippet defines a tuple struct and a tuple variant in Rust, and demonstrates their usage. It includes the necessary 'use' statement to import the variant directly and emphasizes the proper structure for using tuple structs and variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0531.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\n----------------------------------------\n\nTITLE: Checking Method Predicate Entailment in Rust\nDESCRIPTION: The snippet presents a trait 'Foo' with a method 'hi' and its implementation for 'Vec'. It illustrates how the method's trait bounds are compared to ensure compatibility with the original trait method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/effects.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[const_trait]\ntrait Foo {\n    fn hi<T: ~const Default>();\n}\n\nimpl<T: ~const Clone> Foo for Vec<T> {\n    fn hi<T: ~const PartialEq>();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Zero with Missing Exponent in Rust Lexer\nDESCRIPTION: Demonstrates how the Rust lexer processes zero followed by an exponent symbol (`e` or `E`) but missing the required digits after the symbol. This results in a `FLOAT_NUMBER` token with an error indicating the missing digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_exponent.txt#_snippet_0\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"0e\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"0E\" error: Missing digits after the exponent symbol\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Redundant Explicit Links in Rust Documentation\nDESCRIPTION: This code snippet shows an example of redundant explicit links in Rust documentation. The `add` function is documented with an unnecessary explicit link to `usize`, which triggers the `redundant_explicit_links` lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/lints.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(rustdoc::redundant_explicit_links)] // note: unnecessary - warns by default.\n\n/// add takes 2 [`usize`](usize) and performs addition\n/// on them, then returns result.\npub fn add(left: usize, right: usize) -> usize {\n    left + right\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Markdown Playground URL\nDESCRIPTION: This code snippet demonstrates how to use the `--markdown-playground-url` flag to control the base URL of the Rust Playground for generating `Run` buttons in Markdown files. This is useful when a custom Rust Playground instance is being used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc README.md --markdown-playground-url https://play.rust-lang.org/\n```\n\n----------------------------------------\n\nTITLE: Binary Operation Formatting in Rust\nDESCRIPTION: Styling rules for binary operations, including spacing, line-breaking, and precedence handling\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfoo_bar\n    + bar\n    + baz\n    + qux\n    + whatever\n```\n\n----------------------------------------\n\nTITLE: Viewing LLVM IR for Sysroot Crate in Rust\nDESCRIPTION: Two-step process to view the LLVM IR for a sysroot crate: first run cargo build with specific flags to get the command, then add --emit=llvm-ir to that command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build -v --target x86_64-unknown-linux-gnu -Zbuild-std\n# Take the command from the output and add --emit=llvm-ir\n```\n\n----------------------------------------\n\nTITLE: Formatting Empty Code Blocks in Doc Comments in Rust\nDESCRIPTION: This snippet shows how rustfmt now handles empty code blocks within doc comments with `format_code_in_doc_comments = true` without panicking. The example demonstrates a doc comment with an empty code block that previously caused rustfmt to fail, but now formats correctly. This improves the tool's robustness when handling doc comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\n///\n/// ```\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining JoinLinesParams Interface for Join Lines Operation\nDESCRIPTION: Defines the parameters for the joinLines request, which handles combining multiple lines of code. It includes the text document identifier and an array of ranges to support multiple cursors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface JoinLinesParams {\n    textDocument: TextDocumentIdentifier,\n    /// Currently active selections/cursor offsets.\n    /// This is an array to support multiple cursors.\n    ranges: Range[],\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Quote in Raw Byte String Literal in Rust\nDESCRIPTION: This snippet identifies a syntax error in a Rust program.  The error occurs when a raw byte string literal, which is defined using `br##\"...\"`, is missing the closing double quote. The compiler will report this as an issue because the string is not properly terminated. The example provided, `BYTE_STRING \"br##` represents the issue.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unstarted_raw_byte_string_at_eof.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nBYTE_STRING \"br##\" error: Missing `\"` symbol after `#` symbols to begin the raw byte string literal\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Duplicate Type Definition Error in Rust\nDESCRIPTION: Shows an erroneous code example where a struct type 'Bar' is defined twice, triggering compiler error E0428.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0428.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\nstruct Bar; // error: duplicate definition of value `Bar`\n```\n\n----------------------------------------\n\nTITLE: Rust Raw String Literal Error\nDESCRIPTION: This Rust compiler error occurs when a raw string literal is not properly terminated with a closing delimiter that includes the correct number of '#' symbols. The compiler expects the same number of '#' symbols at the end as there are at the beginning of the raw string literal before the quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"r##\\\"\" error: Missing trailing `\"` with `#` symbols to terminate the raw string literal\n```\n\n----------------------------------------\n\nTITLE: Adding wasm32-wasip1-threads Target\nDESCRIPTION: This command demonstrates how to add the `wasm32-wasip1-threads` target using Rust's toolchain with the rustup command. This operation requires the nightly toolchain and is used to prepare the environment for building Rust programs for the specified target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1-threads.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrustup target add wasm32-wasip1-threads --toolchain nightly\n\n```\n\n----------------------------------------\n\nTITLE: Example of Using Binder in Where Clauses\nDESCRIPTION: This snippet demonstrates a mixture of higher ranked lifetimes in a where clause and how it is represented as a `Binder`. The example shows the association of lifetimes with correct Debruijn indices and bound variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/binders.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nBinder(\n    Foo<Binder(\n        fn(&'^1_0 &'^0 T/#0),\n        [BoundVariableKind::Region(...)]\n    )>: Trait,\n    [BoundVariableKind::Region(...)]\n)\n```\n\n----------------------------------------\n\nTITLE: Enum Discriminant Alignment - Threshold Set\nDESCRIPTION: Demonstrates enum discriminant alignment when `enum_discrim_align_threshold` is set to 20.  Variants with names shorter than the threshold are aligned.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    A   = 0,\n    Bb  = 1,\n    RandomLongVariantGoesHere = 10,\n    Ccc = 2,\n}\n\nenum Bar {\n    VeryLongVariantNameHereA = 0,\n    VeryLongVariantNameHereBb = 1,\n    VeryLongVariantNameHereCcc = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unconstrained Lifetime Parameter by Implementing on Borrowed Type\nDESCRIPTION: This code shows a solution for the E0207 error with lifetime parameters by implementing the trait on a borrowed type, which properly constrains the lifetime.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo(i32);\n\ntrait Contents {\n    type Item;\n\n    fn get(&self) -> Self::Item;\n}\n\n// Note the lifetime `'a` is used both for the self type...\nimpl<'a> Contents for &'a Foo {\n    // ...and the associated type.\n    type Item = &'a i32;\n\n    fn get(&self) -> Self::Item {\n        &self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Match Arm Leading Pipes with Preserve Setting in Rust\nDESCRIPTION: Shows the match_arm_leading_pipes setting set to Preserve, which maintains the original presence or absence of leading pipe characters on match arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_45\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    match foo {\n        | \"foo\" | \"bar\" => {},\n        | \"baz\"\n        | \"something relatively long\"\n        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n        | \"qux\" => println!(\"y\"),\n        _ => {}\n    }\n\n    match baz {\n        \"qux\" => {},\n        \"foo\" | \"bar\" => {},\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Example for Variable Shadowing with Static in Rust\nDESCRIPTION: This snippet provides a corrected version of the previous error involving a match binding and a static variable in Rust. It replaces the conflicting match arm with an arbitrary variable name demonstrating valid usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0530.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n\"static TEST: i32 = 0;\\n\\nlet r = 123;\\nmatch r {\\n    some_value => {} // ok!\\n}\"\n```\n\n----------------------------------------\n\nTITLE: CompletionContext Structure Definition (Rust)\nDESCRIPTION: This code defines the CompletionContext structure that describes cursor position in terms of Rust syntax and semantics, containing both syntactic and semantic information about the completion site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context.rs#L407-L441\n```\n\n----------------------------------------\n\nTITLE: Entry Point for No-Std Binaries in Miri\nDESCRIPTION: Defines a custom entry point function for no-standard library Rust binaries to enable Miri interpretation. Used to specify the start of program execution when standard library is not available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/README.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(miri)]\n#[no_mangle]\nfn miri_start(argc: isize, argv: *const *const u8) -> isize {\n    // Call the actual start function that your project implements, based on your target's conventions.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Trait Without AddAssign in Rust\nDESCRIPTION: This code demonstrates implementing the Add trait for a custom type Foo, but failing to use the += operator because AddAssign is not automatically implemented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0368.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\n\nstruct Foo(u32);\n\nimpl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, rhs: Foo) -> Foo {\n        Foo(self.0 + rhs.0)\n    }\n}\n\nfn main() {\n    let mut x: Foo = Foo(5);\n    x += Foo(7); // error, `+=` cannot be applied to the type `Foo`\n}\n```\n\n----------------------------------------\n\nTITLE: Example of a debug statement in Rust\nDESCRIPTION: This Rust code snippet demonstrates using the `debug!` macro with field recording syntax. It logs the value of `random_operation(tcx)` and assigns it to the field `x` in the log output.  This allows structured logging of complex values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\ndebug!(x = ?random_operation(tcx));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Compiler Error E0284 with Type Inference\nDESCRIPTION: This code snippet shows an example that triggers the E0284 error. It attempts to add a u32 value converted to an unknown type to a u64 value, causing ambiguity in type inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0284.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    d = d + n.into();\n}\n```\n\n----------------------------------------\n\nTITLE: Struct and Function Example in Rust\nDESCRIPTION: This snippet defines a Rust function and a struct, showcasing how generic functions can take multiple types and how these are represented in Rust symbols. The function `example` is invoked with two instances of the `Example` struct type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    example::<Example, Example>();\n}\n\nstruct Example;\n\npub fn example<T, U>() {}\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Changes in Git\nDESCRIPTION: Shows how to stage specific files for commit using `git add` and how to record those changes using `git commit`. Also includes `git status` to check the state of the repository. Avoid using `git add .`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit add src/changed/file.rs src/another/change.rs\ngit commit\n# Use git status to check for unstaged files\n```\n\n----------------------------------------\n\nTITLE: Incorrect Module and Type Instantiation in Rust\nDESCRIPTION: Demonstrates an erroneous attempt to instantiate a module directly, which is not possible in Rust. Shows how modules cannot be used as types for creating instances.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0574.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod mordor {}\n\nlet sauron = mordor { x: () }; // error!\n\nenum Jak {\n    Daxter { i: isize },\n}\n\nlet eco = Jak::Daxter { i: 1 };\nmatch eco {\n    Jak { i } => {} // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lang Item Redefinition Error in Rust\nDESCRIPTION: This example shows a case where the 'owned_box' lang item is redefined, causing a compilation error. Lang items are already implemented in the standard library and should not be redefined in normal code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0152.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items)]\n\n#[lang = \"owned_box\"]\nstruct Foo<T>(T); // error: duplicate lang item found: `owned_box`\n```\n\n----------------------------------------\n\nTITLE: Setting PGO Instrumentation Use Path in LLVM PassManager (C)\nDESCRIPTION: This code snippet demonstrates how rustc tells the LLVM PassManagerBuilder where to find the profiling data for use in optimizations during the final compilation step of the PGO workflow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profile-guided-optimization.md#2025-04-21_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n    unwrap(PMBR)->PGOInstrUse = PGOUsePath;\n```\n\n----------------------------------------\n\nTITLE: Implementing C2Rust Tool Attributes in Rust\nDESCRIPTION: Demonstrates using register_tool to enable C2Rust attributes for marking C header file sources and source line locations in generated Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/register-tool.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(register_tool)]\n#![register_tool(c2rust)]\n\n// Mark which C header file this module was generated from.\n#[c2rust::header_src = \"operations.h\"]\npub mod operations_h {\n    use std::ffi::c_int;\n\n    // Mark which source line this struct was generated from.\n    #[c2rust::src_loc = \"11:0\"]\n    pub struct Point {\n        pub x: c_int,\n        pub y: c_int,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Erroneous Thread-Local Static Variable in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to define a const variable that refers to a thread-local static variable in Rust. A const variable cannot reference a thread-local static variable during compilation. The provided code triggers a compile-time error E0625 due to this limitation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0625.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(thread_local)]\n\n#[thread_local]\nstatic X: usize = 12;\n\nconst Y: usize = 2 * X;\n```\n\n----------------------------------------\n\nTITLE: Correcting E0412 Errors in Rust\nDESCRIPTION: This snippet demonstrates how to fix the E0412 errors from the previous example. It shows proper struct declaration, correct use of associated types in traits, and proper generic type parameter declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0412.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Testing Incremental Name Resolution (Rust)\nDESCRIPTION: This test validates that typing inside function bodies does not invalidate name resolution results, confirming the effectiveness of the position-independent representation approach.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres/tests/incremental.rs#L31\n```\n\n----------------------------------------\n\nTITLE: Invalid Copy and Drop Trait Implementation Example in Rust\nDESCRIPTION: Example demonstrating an invalid attempt to implement both Copy and Drop traits on the same struct. This code fails to compile because simultaneous implementation of these traits is currently disallowed due to potential memory safety issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0184.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Copy)]\nstruct Foo; // error!\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RPITIT Lifetime Constraints Example\nDESCRIPTION: Demonstrates how lifetime constraints are enforced between original and duplicated lifetimes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<'a> {\n    fn bar() -> impl Sized + 'a;\n}\n\n// Desugars into...\n\ntrait Foo<'a> {\n    type Gat<'a_duplicated>: Sized + 'a\n    where\n        'a: 'a_duplicated,\n        'a_duplicated: 'a;\n    //~^ Specifically, we should be able to assume that the\n    // duplicated `'a_duplicated` lifetime always stays in\n    // sync with the `'a` lifetime.\n\n    fn bar() -> Self::Gat<'a>;\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Dead Code in Rust\nDESCRIPTION: Tries to generate and link dead code that would otherwise not be generated or linked. Takes `y`, `yes`, `on`, `true` (try to keep) or `n`, `no`, `off`, `false` (remove, default). Its use is not recommended.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_17\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Rust Lint Usage - Shell\nDESCRIPTION: This snippet shows an erroneous command to the Rust compiler where an invalid lint is specified. The lint name may be misspelled or deprecated, causing a compilation error. Users should ensure the lint names are valid to avoid such errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0602.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustc -D bogus rust_file.rs\n```\n\n----------------------------------------\n\nTITLE: Lowering Source Code to Position-Independent Representation (Rust)\nDESCRIPTION: This code lowers the source code of modules into a position-independent representation that remains stable across item body modifications. This approach enables efficient incremental analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree.rs#L110-L154\n```\n\n----------------------------------------\n\nTITLE: Adding ctru-rs Dependency in Cargo.toml\nDESCRIPTION: Cargo.toml snippet showing how to add the ctru-rs dependency to a Rust project, which provides access to 3DS-specific APIs and ensures that all necessary symbols are available at link time.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv6k-nintendo-3ds.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nctru-rs = { git = \"https://github.com/rust3ds/ctru-rs.git\" }\n```\n\n----------------------------------------\n\nTITLE: Using Const to Prevent Shadowing in Rust\nDESCRIPTION: This snippet shows a corrected match binding where a const variable is used instead of a static variable. This demonstrates that using a const allows for a match arm to reference it without causing shadowing issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0530.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n\"const TEST: i32 = 0; // const, not static\\n\\nlet r = 123;\\nmatch r {\\n    TEST => {} // const is ok!\\n    other_values => {}\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of await Within async Context in Rust\nDESCRIPTION: This code snippet shows the correct usage of the `await` keyword within an `async` function and an `async` block, demonstrating how to properly use `await` in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0728.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn foo() {\n    wake_and_yield_once().await // `await` is used within `async` function\n}\n\nfn bar(x: u8) -> impl Future<Output = u8> {\n    async move {\n        wake_and_yield_once().await; // `await` is used within `async` block\n        x\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Fuchsia Targets with rustup\nDESCRIPTION: This shell snippet demonstrates how to add Fuchsia targets using rustup, which simplifies Rust binary compilation for Fuchsia by managing toolchain installations automatically. Ensure rustup is installed and configured correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustup target add x86_64-unknown-fuchsia\nrustup target add aarch64-unknown-fuchsia\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Suggested Slice Pattern Length in Rust\nDESCRIPTION: This option controls the maximum number of elements allowed in a slice pattern suggested by the `index_refutable_slice` lint.  If the pattern has more elements, the lint is suppressed. The default value is `3`. The input is an integer representing the maximum length.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_29\n\n\n\n----------------------------------------\n\nTITLE: Providing Insufficient Lifetime Arguments in Rust Function Call\nDESCRIPTION: This example demonstrates an error when providing too few lifetime arguments to a function that requires multiple lifetimes. The function expects two lifetime parameters, but only one is provided in the function call.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0090.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a: 'b, 'b: 'a>() {}\n\nfn main() {\n    foo::<'static>(); // error: wrong number of lifetime arguments:\n                      //        expected 2, found 1\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting C++ Code Using clang-format\nDESCRIPTION: This snippet demonstrates how to format C++ code in the Rust repository using a pinned version of clang-format. It involves executing a specific command that utilizes the tidy script with extra checks for C++ formatting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/conventions.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n./x test tidy --extra-checks cpp:fmt --bless\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Async UI Test in Rust\nDESCRIPTION: Example of a UI test that tests the compiler's error message when using await outside of an async function. The test demonstrates proper test structure including explanatory comments and edition directives.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/adding.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Provide diagnostics when the user writes `await` in a non-`async` function.\n//@ edition:2018\n\nasync fn foo() {}\n\nfn bar() {\n    foo().await\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Meta-Item Usage in Rust Deprecated Attribute (Error E0539)\nDESCRIPTION: This code example shows an invalid use of the deprecated attribute where 'note' is provided without a value, which previously triggered error E0539. The compiler expects key-value pairs in attribute meta-items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0551.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[deprecated(note)] // error!\nfn i_am_deprecated() {}\n```\n\n----------------------------------------\n\nTITLE: Using cfg Revisions for Conditional Error Checking in Rust UI Tests\nDESCRIPTION: Demonstrates how to conditionally check different error messages based on revision configurations. This allows testing different compiler behavior across various compilation configurations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n//@ edition:2018\n//@ revisions: mir thir\n//@[thir] compile-flags: -Z thir-unsafeck\n\nasync unsafe fn f() {}\n\nasync fn g() {\n    f(); //~ ERROR call to unsafe function is unsafe\n}\n\nfn main() {\n    f(); //[mir]~ ERROR call to unsafe function is unsafe\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Toolchain for TEEOS in toml Configuration\nDESCRIPTION: This snippet configures the Rust build system for targeting TEEOS via the 'bootstrap.toml' file. Key configurations include setting the target to 'aarch64-unknown-teeos', enabling sanitizers and profilers, and specifying the usage of custom Clang wrappers and tools from the OpenHarmony SDK. The configuration involves setting the cc, cxx, and linker tools to the shell scripts that wrap clang for cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-unknown-teeos.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nprofile = \"compiler\"\nchange-id = 115898\n\n[build]\nsanitizers = true\nprofiler = true\ntarget = [\"x86_64-unknown-linux-gnu\", \"aarch64-unknown-teeos\"]\nsubmodules = false\ncompiler-docs = false\nextended = true\n\n[install]\nbindir = \"bin\"\nlibdir = \"lib\"\n\n[target.aarch64-unknown-teeos]\ncc = \"/path/to/scripts/aarch64-unknown-teeos-clang.sh\"\ncxx = \"/path/to/scripts/aarch64-unknown-teeos-clang.sh\"\nlinker = \"/path/to/scripts/aarch64-unknown-teeos-clang.sh\"\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nranlib = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\"\nllvm-config = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-config\"\n```\n\n----------------------------------------\n\nTITLE: Using the deprecated attribute in Rust\nDESCRIPTION: The #[deprecated] attribute marks items as deprecated in the standard library. It must be used with either stable or unstable attributes and can include since version, explanation note, and optional suggestion for replacement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stability.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[deprecated(\n    since = \"1.38.0\",\n    note = \"explanation for deprecation\",\n    suggestion = \"other_function\"\n)]\n```\n\n----------------------------------------\n\nTITLE: Building Semantic Model for Completion (Rust)\nDESCRIPTION: This code builds a semantic model for the function containing the completion site, providing access to type information and other semantic details needed for intelligent code completion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L466\n```\n\n----------------------------------------\n\nTITLE: Rust function with existential quantification\nDESCRIPTION: Demonstrates existential quantification in Rust, where the function is well-typed if there exists a type `T` that satisfies certain conditions. In this example, there must exist a type `T` that implements the `Debug` trait for the function to be well-typed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_5\n\nLANGUAGE: rust,ignore\nCODE:\n```\nfn foo(_: dyn Debug)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Usage of Associated Type with Uninferred Generic Parameters in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect usage of an associated type with a trait that has uninferred generic parameters. The error occurs because the lifetime 'x cannot be inferred in the function signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0212.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Foo<T> {\n    type A;\n\n    fn get(&self, t: T) -> Self::A;\n}\n\nfn foo2<I : for<'x> Foo<&'x isize>>(\n    field: I::A) {} // error!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Error E0800 - Using Undeclared Type Parameter\nDESCRIPTION: This code fails to compile because it attempts to use a type parameter 'T' that has not been declared in the function's generic parameter list. The 'use<T>' expression references an undefined type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0800.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn missing() -> impl Sized + use<T> {}\n```\n\n----------------------------------------\n\nTITLE: Emit MIR Before a Specific Optimization - Rust\nDESCRIPTION: This code snippet emits the MIR state before a specific optimization pass is executed. The output is saved to the specified `.before.mir` file. Although available, it is less frequently used compared to emitting the diff or the 'after' state.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// EMIT_MIR $file_name_of_some_mir_dump.before.mir\n```\n\n----------------------------------------\n\nTITLE: Defining Generic CodegenCx and Builder Structures\nDESCRIPTION: Core structures for code generation that are parameterized by lifetime parameters. CodegenCx handles compilation of codegen-units while Builder compiles individual basic blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/backend-agnostic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct CodegenCx<'ll, 'tcx> {\n  /* ... */\n}\n\nstruct Builder<'a, 'll, 'tcx> {\n  cx: &'a CodegenCx<'ll, 'tcx>,\n  /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Patched Git-Subtree\nDESCRIPTION: Commands to clone, build, and install a patched version of git-subtree required for working with rustc. Uses a specific fork that includes necessary fixes for subtree operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/subtree.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:tqc/git.git\ncd git\ngit checkout tqc/subtree\nmake\nmake install\ncd contrib/subtree\nmake\ncp git-subtree ~/bin\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for Special pthread Functions in Rust\nDESCRIPTION: This snippet defines custom handling for pthread_create and pthread_join functions. pthread_create takes a callback and requires manual wrapping, while pthread_join's output doesn't depend on input and needs manual shadow zeroing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfun:pthread_create=custom\nfun:pthread_join=custom\n```\n\n----------------------------------------\n\nTITLE: Correctly Initializing Struct with All Fields in Rust\nDESCRIPTION: This code snippet shows the correct way to initialize a struct by providing all required fields. Both 'x' and 'y' fields are specified, resulting in a valid initialization.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0063.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: MIR Representation of User Variable Debug Info\nDESCRIPTION: This MIR snippet demonstrates how user-defined variables are associated with debug information in MIR, showing the mapping between variable names and their corresponding places.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/index.md#2025-04-21_snippet_2\n\nLANGUAGE: mir\nCODE:\n```\nscope 1 {\n    debug vec => _1;                 // in scope 1 at src/main.rs:2:9: 2:16\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Default Implementation with Default Field Values\nDESCRIPTION: Demonstrates the correct way to implement Default trait manually for a type with default field values using the functional update syntax to avoid the default_overrides_default_fields lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/default-field-values.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(default_field_values)]\n\nstruct Pet {\n    name: String,\n    age: i128 = 42, // impl Default for Pet will use the literal 42 for age\n}\n\nimpl Default for Pet {\n    fn default() -> Pet {\n        Pet {\n            name: \"no-name\".to_string(),\n            ..\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mixed Late-Bound and Early-Bound Lifetime Parameters\nDESCRIPTION: Illustrates the usage of both late-bound and early-bound lifetime parameters in a complex example with traits and function pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0794.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait BarTrait<'a> {}\n\nstruct Bar<'a> {\n    s: &'a str\n}\n\nimpl<'a> BarTrait<'a> for Bar<'a> {}\n\nfn bar<'a, 'b, T>(x: &'a str, _t: T) -> &'a str\nwhere T: BarTrait<'b>\n{\n    x\n}\n\nlet bar_fn: for<'a> fn(&'a str, Bar<'static>) -> &'a str = bar; // OK\nlet bar_fn2 = bar::<'static, Bar>; // Not allowed\nlet bar_fn3 = bar::<Bar>; // OK\n```\n\n----------------------------------------\n\nTITLE: Identifying Rust Tokens After Error\nDESCRIPTION: This snippet showcases the Rust tokens that the lexer identifies after encountering the raw string literal error. The tokens include identifiers (IDENT), whitespace (WHITESPACE), and a bang operator (BANG).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unstarted_raw_string_with_ascii.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"IDENT \\\"I\\\"\\nWHITESPACE \\\" \\\"\\nIDENT \\\"lack\\\"\\nWHITESPACE \\\" \\\"\\nIDENT \\\"a\\\"\\nWHITESPACE \\\" \\\"\\nIDENT \\\"quote\\\"\\nBANG \\\"!\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Constructor Method for Struct with Private Fields in Rust\nDESCRIPTION: This solution shows how to create a constructor method to instantiate a struct with private fields, maintaining encapsulation while allowing creation of instances.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0451.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod bar {\n    pub struct Foo {\n        pub a: isize,\n        b: isize, // still private\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { // we create a method to instantiate `Foo`\n            Foo { a: 0, b: 0 }\n        }\n    }\n}\n\nlet f = bar::Foo::new(); // ok!\n```\n\n----------------------------------------\n\nTITLE: Renaming a feature gate in Rust\nDESCRIPTION: This snippet outlines the procedure for renaming a feature gate. It involves removing the existing feature gate declaration, adding it to the removed gates with a note on renaming, and finally declaring the feature with its new name in `unstable.rs`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/feature-gates.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"/// description of feature\\n(unstable, $old_feature_name, \\\"$version\\\", Some($tracking_issue_number))\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"/// description of feature\\n/// Renamed to \\\"$new_feature_name\\\"\\n(removed, $old_feature_name, \\\"$version\\\", Some($tracking_issue_number),\\n Some(\\\"renamed to \\\"$new_feature_name\\\"\\\"))\"\n```\n\nLANGUAGE: rust\nCODE:\n```\n\"/// description of feature\\n(unstable, $new_feature_name, \\\"$version\\\", Some($tracking_issue_number))\"\n```\n\n----------------------------------------\n\nTITLE: Using Backreferences in Rust Pattern Matching\nDESCRIPTION: Example of a proposed backreference syntax for Rust pattern matching. This pattern detects assignments of the form 'a = a op b' where both occurrences of 'a' must be identical, allowing for conversion to compound assignment operators.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    assign_op_pattern: Expr =\n        Assign(_#target, Binary(_, =#target, _)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Coverage Attribute Usage in Foreign Function Declaration\nDESCRIPTION: Demonstrates an erroneous usage of #[coverage(off)] attribute on a foreign function declaration within an extern block, which is not allowed. Coverage attributes can only be applied to function declarations with bodies, closures, impl blocks, and modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0788.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunsafe extern \"C\" {\n    #[coverage(off)]\n    fn foreign_fn();\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying External Dependency Location\nDESCRIPTION: This code snippet demonstrates how to use the `--extern` flag to specify the exact location of a dependency.  Unlike `--library-path`, which provides directories to search, `--extern` directly specifies the path to a specific dependency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --extern lazy-static=/path/to/lazy-static\n```\n\n----------------------------------------\n\nTITLE: Finding Parent Function Node for Completion (Rust)\nDESCRIPTION: This code finds the parent function node in the syntax tree during completion context construction, which is necessary for determining the semantic context of the completion site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L463\n```\n\n----------------------------------------\n\nTITLE: Syncing Rust Compiler Changes\nDESCRIPTION: Commands to push changes from the main Rust repository to the rustc_codegen_gcc repository using git-subtree. Includes steps for checkout, merging, and branch management.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/subtree.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nPATH=\"$HOME/bin:$PATH\" ~/bin/git-subtree push -P compiler/rustc_codegen_gcc/ ../rustc_codegen_gcc/ sync_branch_name\ncd ../rustc_codegen_gcc\ngit checkout master\ngit pull\ngit checkout sync_branch_name\ngit merge master\n```\n\n----------------------------------------\n\nTITLE: Error Example for Feature Attributes in Rust Nightly\nDESCRIPTION: Demonstrates an erroneous use of feature attributes in Rust that is only allowed on the nightly release channel. The example shows how an attempt to use a feature in a stable channel results in a compile-time error, emphasizing the need for a nightly compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0554.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"#![feature(lang_items)] // error: `#![feature]` may not be used on the\\n                        //        stable release channel\"\n```\n\n----------------------------------------\n\nTITLE: Formatting Generic Types with Line Breaks in Rust\nDESCRIPTION: This snippet illustrates the preferred way to break lines in generic types for better readability. It suggests breaking at the outermost scope and provides an example of a `Foo` type with multiple generic parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"Foo<\n    Bar,\n    Baz<Type1, Type2>,\n>\"\n```\n\n----------------------------------------\n\nTITLE: Output Filename Structure\nDESCRIPTION: This code snippet illustrates the structure of the output filenames used in UI tests. The filename consists of the test name, revision (if applicable), compare mode (if applicable), and extension, allowing for flexible output management and comparison.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n*test-name*`.`*revision*`.`*compare_mode*`.`*extension*\n```\n\n----------------------------------------\n\nTITLE: Overriding the System Root\nDESCRIPTION: This code snippet demonstrates how to use the `--sysroot` flag to override the system root used by rustdoc when compiling code. This is analogous to `rustc --sysroot` and is useful for specifying a custom system root for compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --sysroot /path/to/sysroot\n```\n\n----------------------------------------\n\nTITLE: Rust Range Syntax Types\nDESCRIPTION: Demonstrates the three primary range syntax patterns in Rust: open-ended range (a..), exclusive range (a..b), and inclusive range (a..=b). These syntax forms are being switched to resolve to new range types as part of issue #123741.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/new-range.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\na..   // Open-ended range\na..b  // Exclusive range\na..=b // Inclusive range\n```\n\n----------------------------------------\n\nTITLE: Running Build Commands with Custom Toolchain\nDESCRIPTION: Series of commands to run the build system using the custom stage2 toolchain. These commands prepare, build, and optionally test the Cranelift backend with local rustc changes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nrustup run stage2 ./y.sh prepare\nrustup run stage2 ./y.sh build\nrustup run stage2 ./y.sh test\n```\n\n----------------------------------------\n\nTITLE: Function with Early-Bound Lifetime Parameter in Rust\nDESCRIPTION: The function foo defines a syntax for accepting a reference to a String and a type T that implements Trait with the same lifetime 'a. It illustrates the concept of early bounding in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, T: Trait<'a>>(_: &'a String, _: T) {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Where Clause on Main Function in Rust\nDESCRIPTION: This code snippet shows an erroneous attempt to define the main function with a where clause, which is not allowed in Rust. The compiler will raise an E0646 error for this code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0646.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() where i32: Copy { // error: main function is not allowed to have\n                            // a where clause\n}\n```\n\n----------------------------------------\n\nTITLE: Emit MIR Diff for a Specific Optimization - Rust\nDESCRIPTION: This code snippet instructs the test runner to emit a diff of the MIR before and after a specified optimization. The diff is saved to the specified file. This is the most common approach for observing the effect of an optimization pass on the MIR code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// EMIT_MIR $file_name_of_some_mir_dump.diff\n```\n\n----------------------------------------\n\nTITLE: Request Scheduling on Threadpool (Rust)\nDESCRIPTION: This code schedules LSP requests on a threadpool for processing, enabling asynchronous handling of client requests like code completion while maintaining responsiveness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/dispatch.rs#L197-L211\n```\n\n----------------------------------------\n\nTITLE: Invalid Break with Value in While Loop (Rust)\nDESCRIPTION: This code example demonstrates the erroneous usage of a break statement with a value inside a while loop, which triggers compilation error E0571 in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0571.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# let mut i = 1;\n# fn satisfied(n: usize) -> bool { n % 23 == 0 }\nlet result = while true {\n    if satisfied(i) {\n        break 2 * i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Valid Auto Trait in Rust\nDESCRIPTION: This snippet shows the corrected definition of an auto trait 'Bound' without any super traits. By removing the super trait 'Copy', it becomes valid and can be implemented by existing types, demonstrating the correct usage of auto traits in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0568.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(auto_traits)]\n\nauto trait Bound {} // ok!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Local Helper Functions in Rust\nDESCRIPTION: Demonstrates the proper placement of nested helper functions at the end of enclosing functions with return statements. Helper functions should not be nested more than one level deep.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nfn dfs(graph: &Graph, v: Vertex) -> usize {\n    let mut visited = FxHashSet::default();\n    return go(graph, &mut visited, v);\n\n    fn go(graph: &Graph, visited: &mut FxHashSet<Vertex>, v: usize) -> usize {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Closure Self-Reference in Rust\nDESCRIPTION: Demonstrates an invalid attempt to pass a closure that references its own type as an argument. Rust prevents closures from directly referencing their own type to maintain tractable closure inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0644.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn fix<F>(f: &F)\n  where F: Fn(&F)\n{\n    f(&f);\n}\n\nfn main() {\n    fix(&|y| {\n        // Here, when `x` is called, the parameter `y` is equal to `x`.\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing E0310 Error by Adding Proper Lifetime Constraint in Rust\nDESCRIPTION: This example shows the correct implementation that will compile successfully. The struct Foo has a type parameter T with a 'static lifetime constraint, which matches the lifetime of the reference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0310.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T: 'static> {\n    foo: &'static T\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Hexadecimal Literal\nDESCRIPTION: This snippet shows that `0xnoDigit` gives a `Missing digits after the integer base prefix` error, because it requires digits, but gets a string that isn't a valid digit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0xnoDigit\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Nested Lifetime Quantification in Rust Where Clause\nDESCRIPTION: Example showing incorrect usage of nested lifetime quantification that results in error E0316. The code attempts to use both trait-bound and whole-clause quantification in the same where clause.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0316.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Tr<'a, 'b> {}\n\nfn foo<T>(t: T)\nwhere\n    for<'a> &'a T: for<'b> Tr<'a, 'b>, // error: nested quantification\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodiff Compiler Flag in Rust\nDESCRIPTION: Sets the -Zautodiff compiler flag with various options to control the behavior of the automatic differentiation feature. Options can be combined using commas.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/autodiff.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Zautodiff=<options>\n```\n\n----------------------------------------\n\nTITLE: Failing Trait Object with Self Default Parameter in Rust\nDESCRIPTION: Example showing incorrect usage of Self as default type parameter in a trait object, which triggers compiler error E0393. The type parameter T must be explicitly specified when used with trait objects.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0393.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait A<T = Self> {}\n\nfn together_we_will_rule_the_galaxy(son: &dyn A) {}\n// error: the type parameter `T` must be explicitly specified\n```\n\n----------------------------------------\n\nTITLE: Setting Language Properties for C++ Sources\nDESCRIPTION: This CMake command sets the `LANGUAGE` property to `CXX` for the files listed in `CXX_SOURCES`. This ensures that the CMake build system treats them as C++ source files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset_source_files_properties(${CXX_SOURCES}\n                            PROPERTIES\n                            LANGUAGE CXX)\n```\n\n----------------------------------------\n\nTITLE: Failed Constant Evaluation Example in Rust Enums\nDESCRIPTION: Example showing invalid enum discriminant values that cause compile-time evaluation errors. The first variant attempts an integer overflow with a large shift operation, while the second attempts division by zero.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0080.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum {\n    X = (1 << 500),\n    Y = (1 / 0),\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Inlining with #[doc(no_inline)] in Rust\nDESCRIPTION: This example shows how to prevent an item from being inlined using the `#[doc(no_inline)]` attribute. The `Public` struct from `private_mod` will not be inlined at the crate root, and a re-export link will be displayed instead.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nmod private_mod {\n    pub struct Public;\n}\n#[doc(no_inline)]\npub use self::private_mod::Public;\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Early Filtering in Rust Pattern Matching\nDESCRIPTION: Example of early filtering in pattern matching that evaluates conditions as soon as a pattern part is matched. This demonstrates filtering an if-without-else pattern by checking if it's not within a macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    pat_if_without_else: Expr =\n        If(\n            _,\n            Block(\n                Expr( If(_, _, ())#inner )\n                | Semi( If(_, _, ())#inner )\n            )#then,\n            ()\n        )\n    where\n        !in_macro(#then.span);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a New Diagnostic Item in Rust\nDESCRIPTION: This snippet demonstrates how to add a new diagnostic item to a struct in Rust using the `rustc_diagnostic_item` attribute, ensuring that it does not cause compilation errors during tests by using `cfg_attr`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/diagnostic-items.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This will be the new diagnostic item        vvv\n#[cfg_attr(not(test), rustc_diagnostic_item = \"Cat\")]\nstruct Cat;\n```\n\n----------------------------------------\n\nTITLE: Enabling Eglot for Rust Mode in Emacs\nDESCRIPTION: This snippet adds a hook to `rust-mode-hook` in Emacs, ensuring that Eglot is loaded automatically whenever a Rust file is opened.  This automatically starts the LSP client for rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_0\n\nLANGUAGE: Emacs Lisp\nCODE:\n```\n(add-hook 'rust-mode-hook 'eglot-ensure)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid and Invalid Range Patterns in Rust\nDESCRIPTION: Example of valid and invalid range patterns in Rust match expressions. The first range (1 ..= 1) is valid but pointless as it only matches a single value. The second range (1000 ..= 5) is invalid because it's empty (start > end), which will cause the compiler to throw error E0030.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0030.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch 5u32 {\n    // This range is ok, albeit pointless.\n    1 ..= 1 => {},\n    // This range is empty, and the compiler can tell.\n    1000 ..= 5 => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Discovery Parameters in TypeScript\nDESCRIPTION: DiscoverTestParams enables test exploration by allowing specification of test IDs for resolving nested tests. It ensures focused or complete discovery of test hierarchies within Rust projects and serves as a predecessor to test execution in TypeScript tools.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DiscoverTestParams {\n    testId?: string | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Reordering Struct Fields in Rust\nDESCRIPTION: Rearranges fields in struct literals and patterns to match the order of the struct definition. This refactoring improves code consistency by ensuring field initialization order follows the same pattern as the type declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_103\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {foo: i32, bar: i32};\nconst test: Foo = Foo {bar: 0, foo: 1}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {foo: i32, bar: i32};\nconst test: Foo = Foo {foo: 1, bar: 0}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Trait in Rust\nDESCRIPTION: This snippet defines a basic trait `Foo` in Rust with a single method `foo` that takes a generic type `X` as input. The purpose is to illustrate a simple trait that can be used in higher-ranked trait bounds examples.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/hrtb.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo<X> {\n    fn foo(&self, x: X) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring future-size-threshold\nDESCRIPTION: Sets the maximum byte size a `Future` can have, before the `clippy::large_futures` lint is triggered. Defaults to `16384`. This helps to control the size of futures to avoid performance problems.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_20\n\n\n\n----------------------------------------\n\nTITLE: Unwrapping Tuple Assignment in Rust\nDESCRIPTION: Converts a tuple destructuring assignment into individual variable assignments. This can make the code more explicit and easier to understand.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_117\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let (foo, bar) = (\"Foo\", \"Bar\");\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let foo = \"Foo\";\n    let bar = \"Bar\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function Declarations in Rust\nDESCRIPTION: This snippet demonstrates various declarations of a function `foo` and highlights that the type of `foo` is not `fn(S)` but a unique zero-sized marker type `typeof(foo)`, which can be coerced to a function pointer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0591.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct S;\n\n// For the purposes of this explanation, all of these\n// different kinds of `fn` declarations are equivalent:\n\nfn foo(x: S) { /* ... */ }\n# #[cfg(for_demonstration_only)]\nextern \"C\" {\n    fn foo(x: S);\n}\n# #[cfg(for_demonstration_only)]\nimpl S {\n    fn foo(self) { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Version Info Macro in Rust\nDESCRIPTION: Demonstrates the usage of setup_version_info macro for automated version information handling in Rust projects. This macro simplifies version info setup and no longer requires manual imports.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nsetup_version_info!();\n```\n\n----------------------------------------\n\nTITLE: Formatting Small Struct Literals in Rust\nDESCRIPTION: Shows the effect of the 'struct_lit_single_line' option. When true (default), small struct literals are put on a single line. When false, they are always formatted over multiple lines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_69\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = Lorem { foo: bar, baz: ofo };\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = Lorem {\n        foo: bar,\n        baz: ofo,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Rust Compiler with Check-CFG Print Option\nDESCRIPTION: Example showing how to use the rustc compiler with --print=check-cfg flag to display configuration settings. This requires unstable options to be enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/print-check-cfg.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc --print=check-cfg -Zunstable-options lib.rs\n```\n\n----------------------------------------\n\nTITLE: Multiline Blocks - False\nDESCRIPTION: Demonstrates how closures and match arm bodies are formatted when `force_multiline_blocks` is set to `false`. They are not forced to be wrapped in blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    result.and_then(|maybe_value| match maybe_value {\n        None => foo(),\n        Some(value) => bar(),\n    });\n\n    match lorem {\n        None => |ipsum| {\n            println!(\"Hello World\");\n        },\n        Some(dolor) => foo(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Configuration Flags\nDESCRIPTION: This code snippet demonstrates how to use the `--check-cfg` flag to check configuration flags to rustdoc, similar to `rustc --check-cfg`.  This allows checking of configuration flags and their values during the documentation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --check-cfg='cfg(my_cfg, values(\"foo\", \"bar\"))'\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Assertions in Rust\nDESCRIPTION: Enables or disables `cfg(debug_assertions)` conditional compilation.  Accepts `y`, `yes`, `on`, `true` to enable, or `n`, `no`, `off`, `false` to disable. If not specified, debug assertions are enabled only if the opt-level is 0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Cycle Fixpoint Algorithm in New Rust Trait Solver\nDESCRIPTION: The new trait solver implementation uses a fixpoint algorithm when encountering cycles during trait solving. This is necessary due to the use of canonicalization during goal evaluation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/significant-changes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Source: cycle-fixpoint\nwhile !worklist.is_empty() {\n    let goal = worklist.pop().unwrap();\n    let response = self.evaluate_goal(goal, &mut worklist);\n    // ... (rest of the fixpoint algorithm)\n}\n```\n\n----------------------------------------\n\nTITLE: Subtyping Relationships in Rust Functions\nDESCRIPTION: This snippet exemplifies replacing bound regions with placeholders in a subtyping relationship within Rust's type system. This is done to analyze function types across different lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfor<'a> fn(&'a u32, &'a u32)\n    <: for<'b, 'c> fn(&'b u32, &'c u32)\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Run Directory\nDESCRIPTION: This code snippet demonstrates how to use the `--test-run-directory` flag to specify the working directory for running documentation tests. This ensures that tests are executed in a controlled environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --test --test-run-directory=/path/to/working/directory\n```\n\n----------------------------------------\n\nTITLE: Demonstrating 'async fn' Error in Rust 2015\nDESCRIPTION: This code snippet shows an example of using 'async fn' in Rust 2015, which is not permitted and results in a compilation error (E0670). The function 'foo' is declared as async, which is incompatible with Rust 2015 edition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0670.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Using Double Quotes with CSS Classes in Rust Documentation\nDESCRIPTION: Demonstrates how to use double quotes in code block attributes for non-Rust code with custom CSS classes. This provides more flexibility when specifying language identifiers with spaces.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n/// ```\"not rust\" {.\"hello everyone\"}\n/// int main(void) { return 0; }\n/// ```\npub struct Bar;\n```\n\n----------------------------------------\n\nTITLE: Correct Type Parameter Default in Rust\nDESCRIPTION: This code snippet shows the corrected version of the Foo struct where type parameters are properly ordered. U is declared before T, allowing T to use U as its default value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0128.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<U = (), T = U> {\n    field1: T,\n    field2: U,\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Arithmetic with Wrapping Operations in Rust\nDESCRIPTION: Transforms standard arithmetic operations into their wrapping counterparts that explicitly specify two's complement wrapping behavior. This refactoring makes overflow behavior explicit when wrap-around semantics are desired.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_107\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1 + 2;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1.wrapping_add(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Associated Type Mismatch by Changing Function Constraint\nDESCRIPTION: This solution resolves the E0271 error by modifying the associated type constraint in the function declaration to match the implementation. The function now expects &'static str as the associated type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0271.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n----------------------------------------\n\nTITLE: Generating Target Specification JSON for Host Platform in Rust\nDESCRIPTION: This command shows how to generate the JSON target specification for the host platform using rustc. It requires the nightly toolchain and uses the unstable-options flag to access the target-spec-json printing feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/targets/custom.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc +nightly -Z unstable-options --print target-spec-json\n```\n\n----------------------------------------\n\nTITLE: Forcing Unstable Attributes for Unmarked Crates in Rustdoc\nDESCRIPTION: Demonstrates an internal flag used by the standard library and compiler to apply an #[unstable] attribute to dependent crates without stability attributes. This helps generate documentation for compiler crates and standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z force-unstable-if-unmarked\n```\n\n----------------------------------------\n\nTITLE: Including HTML in Header\nDESCRIPTION: This code snippet demonstrates how to use the `--html-in-header` flag to include HTML files in the `<head>` section of the generated documentation. This is useful for adding custom metadata or scripts to the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --html-in-header header.html\n$ rustdoc README.md --html-in-header header.html\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Fn Trait Constraint in Rust\nDESCRIPTION: This example demonstrates a generic function that accepts any closure implementing the Fn() trait. The closure must be called with zero arguments to match its definition, as specified by the trait bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0057.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<F: Fn()>(f: F) {\n    f(); // this is valid, but f(3) would not work\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Named Function Type Alias in Rust\nDESCRIPTION: This snippet demonstrates how to generate a type alias for a function with named parameters. It creates a new type alias that matches the function's signature, including safety qualifiers and return type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_52\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn foo(n: i32) -> i32 { 42i32 }\n```\n\nLANGUAGE: rust\nCODE:\n```\ntype ${0:FooFn} = unsafe fn(n: i32) -> i32;\n\nunsafe fn foo(n: i32) -> i32 { 42i32 }\n```\n\n----------------------------------------\n\nTITLE: Setting Correct File Paths in GDB for libgccjit Debugging\nDESCRIPTION: This GDB command sets up path substitution to ensure correct file paths are displayed during debugging. It replaces the default debug paths with the actual source paths from the GCC repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging-libgccjit.md#2025-04-21_snippet_4\n\nLANGUAGE: gdb\nCODE:\n```\nset substitute-path /usr/src/debug/gcc /path/to/gcc-repo/gcc\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Rust Compiler Feature in Markdown\nDESCRIPTION: This snippet provides documentation for an internal Rust compiler feature named 'c_void_variant'. It explicitly states that the feature is not intended for general use, indicating it is a specialized component of the compiler's internal workings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/c-void-variant.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# `c_void_variant`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Trait Bounds Formatting in Rust\nDESCRIPTION: Demonstrates how to format multi-line trait bounds in Rust. It includes putting each bound on its own block-indented line and breaking before the `+` symbol.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\npub trait IndexRanges:\n    Index<Range<usize>, Output=Self>\n    + Index<RangeTo<usize>, Output=Self>\n    + Index<RangeFrom<usize>, Output=Self>\n    + Index<RangeFull, Output=Self>\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing with Static in Rust\nDESCRIPTION: This snippet illustrates a compilation error caused by a match binding attempting to shadow a static variable in Rust. It shows how the variable name conflicts with the name of a static variable, leading to a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0530.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"static TEST: i32 = 0;\\n\\nlet r = 123;\\nmatch r {\\n    TEST => {} // error: name of a static\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Framework Linking in Rust for macOS\nDESCRIPTION: This code snippet shows how to use conditional compilation to link a framework only when targeting macOS. It uses the cfg_attr attribute to apply the link attribute conditionally based on the target platform.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0455.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg_attr(target=\"macos\", link(name = \"FooCoreServices\", kind = \"framework\"))]\nextern \"C\" {}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unconstrained Type Parameter by Using Input Type Parameter\nDESCRIPTION: This code shows another solution for the E0207 error by replacing the associated type with a type parameter in the trait definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Use a type parameter instead of an associated type here\ntrait Maker<Item> {\n    fn make(&mut self) -> Item;\n}\n\nstruct Foo<T> {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl<T: Default> Maker<Foo<T>> for FooMaker {\n    fn make(&mut self) -> Foo<T> {\n        Foo { foo: <T as Default>::default() }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Concrete SIMD Struct Implementation in Rust\nDESCRIPTION: Example showing correct usage of #[repr(simd)] with a concrete u32 type array, which is allowed because the compiler can determine SIMD operations for specific numeric types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0074.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good([u32; 4]);\n```\n\n----------------------------------------\n\nTITLE: Defining a Debug-Enabled Enum in Rust\nDESCRIPTION: This code snippet demonstrates how to define a Rust enum called 'Foo' with a single variant 'Bar'. The enum is derived with Debug, PartialEq, and Clone traits, and includes documentation comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_errors/src/markdown/tests/input.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// A rust enum\n#[derive(Debug, PartialEq, Clone)]\nenum Foo {\n    /// Start of line\n    Bar\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Field in Rust\nDESCRIPTION: This code snippet shows how to access a field of a struct in Rust. The field `x` of the struct `Foo` is accessed using `f.x`. The `println!` macro is used to print the value of the field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0615.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of #[ffi_returns_twice] Attribute in Rust Foreign Function Declaration\nDESCRIPTION: This code snippet shows the correct usage of the #[ffi_returns_twice] attribute within an extern block, applied to a foreign function declaration. This is the proper way to use the attribute in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0724.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_returns_twice)]\n\nextern \"C\" {\n   #[ffi_returns_twice] // ok!\n   pub fn foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Implementation of Auto Trait for Dyn Object\nDESCRIPTION: Demonstrates an erroneous implementation where an inherent impl is attempted on a dyn auto trait without a principal trait. This code fails because dyn objects require at most one non-auto (principal) trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0785.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(auto_traits)]\n\nauto trait AutoTrait {}\n\nimpl dyn AutoTrait {}\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_10 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_10` function, passing an integer argument (19). This demonstrates calling a function with the `stdcall` calling convention using a single integer parameter. The output is dependent on the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_10(19)\n```\n\n----------------------------------------\n\nTITLE: Checking Position-Independent Executable Status in Rust Using ELF Headers\nDESCRIPTION: Example showing how to check if a Rust executable is compiled as a position-independent executable by examining its ELF header. A position-independent executable has object type ET_DYN rather than ET_EXEC.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -h target/release/hello-rust | grep Type:\n  Type:                              DYN (Shared object file)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Pattern Binding in Rust\nDESCRIPTION: Shows erroneous code that attempts to mix by-move and by-ref bindings in the same pattern, which was previously disallowed by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0009.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(move_ref_pattern)]\n\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n                            //        same pattern\n    None => panic!()\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Octal Digits with Underscore Error\nDESCRIPTION: This snippet shows an error case where an octal integer literal (0o_) is defined with only an underscore after the prefix, but no digits. This results in a 'missing digits' compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0o_\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Valid Deprecated Meta Items in Rust\nDESCRIPTION: This snippet shows the corrected version of the 'deprecated' attribute by replacing the erroneous meta item with a valid one. It clarifies the appropriate usage of valid meta items for attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0541.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated(\n    since=\"1.0.0\",\n    note=\"This is a valid meta item for the deprecated attribute.\"\n)]\nfn deprecated_function() {}\n\n```\n\n----------------------------------------\n\nTITLE: RPITIT Query Detection Example\nDESCRIPTION: Shows how the compiler detects synthetic associated types during query execution\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/return-position-impl-trait-in-trait.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ... {\n    if let Some(rpitit_info) = tcx.opt_rpitit_info(def_id) {\n        // Do something special for RPITITs...\n        return ...;\n    }\n\n    // The regular computation which relies on access to the HIR of `def_id`.\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Type Bounds to Where Clause in Rust\nDESCRIPTION: Relocates inline type bounds to a where clause. This refactoring improves readability by separating type parameter declarations from their constraints, especially useful for complex generic signatures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_85\n\nLANGUAGE: rust\nCODE:\n```\nfn apply<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U {\n    f(x)\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n    f(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Tuple Struct and Variant Errors in Rust\nDESCRIPTION: This Rust code snippet demonstrates incorrect usage of a tuple struct and a tuple variant, leading to compiler errors. It highlights a common issue related to forgotten imports or typographical errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0531.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to wasm32-wasip1-threads\nDESCRIPTION: This command shows how to compile Rust code targeting the `wasm32-wasip1-threads` architecture using the `rustc` command, suitable for producing WebAssembly binaries with Rust's native features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1-threads.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nrustc --target wasm32-wasip1-threads your-code.rs\n\n```\n\n----------------------------------------\n\nTITLE: Error: Using Struct Update Syntax Without Base Expression in Rust\nDESCRIPTION: This example demonstrates the E0797 error that occurs when struct update syntax (with '..') is used without providing a base expression to fill the remaining fields.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0797.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    fizz: u8,\n    buzz: u8\n}\n\nlet f1 = Foo { fizz: 10, buzz: 1};\nlet f2 = Foo { fizz: 10, .. }; // error\n```\n\n----------------------------------------\n\nTITLE: Formatting Multi-line Elements in Method Chains in Rust\nDESCRIPTION: When any element in a method chain spans multiple lines, each element from that point forward should be on its own line with proper block indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\na.b.c()?\n    .foo(\n        an_expr,\n        another_expr,\n    )\n    .bar\n    .baz\n```\n\n----------------------------------------\n\nTITLE: Invalid Empty Match Expression with Non-Empty Type in Rust\nDESCRIPTION: This code example shows an invalid empty match expression. Since Option<String> is a non-empty type (it can be Some or None), an empty match is not allowed as it fails to handle possible values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0002.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(x: Option<String>) {\n    match x {\n        // empty\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting E0719 Error in Rust\nDESCRIPTION: This code snippet demonstrates the correct way to specify multiple trait bounds for an associated type by creating a new combined trait and using it in the generic parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0719.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait FooTrait {}\ntrait BarTrait {}\ntrait FooBarTrait: FooTrait + BarTrait {}\n\nstruct Foo<T: Iterator<Item: FooBarTrait>> { f: T } // ok!\n```\n\n----------------------------------------\n\nTITLE: Defining MatchingBraceParams Interface for Matching Brace Operation\nDESCRIPTION: Defines the parameters for finding matching braces, supporting multiple cursor positions. This extension helps navigate between paired delimiters in code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MatchingBraceParams {\n    textDocument: TextDocumentIdentifier,\n    /// Position for each cursor\n    positions: Position[],\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving E0283 Error by Specifying Trait's Type Parameter in Rust\nDESCRIPTION: This snippet demonstrates how to resolve the E0283 error in the context of trait implementation by explicitly specifying the trait's type parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n\n----------------------------------------\n\nTITLE: Erroneous Direct Implementation of Unsize Trait in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to directly implement the Unsize trait. The compiler will reject this implementation with error E0328, as Unsize implementations are provided automatically by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0328.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsize)]\n\nuse std::marker::Unsize;\n\npub struct MyType;\n\nimpl<T> Unsize<T> for MyType {}\n```\n\n----------------------------------------\n\nTITLE: Indented Code Block Example in Markdown Documentation\nDESCRIPTION: Shows the alternative syntax for code blocks in Rust documentation using indentation (four or more spaces) instead of backticks. However, this approach doesn't support doctest attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n    let foo = \"foo\";\n    assert_eq!(foo, \"foo\");\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Derive Attribute on Trait in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous application of the `derive` attribute on a trait's associated type, which is not allowed in Rust. The `derive` attribute can only be used on structs, unions, or enums.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0774.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    #[derive(Clone)] // error!\n    type Bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guards in Rust\nDESCRIPTION: Shows how to use pattern guards to check for equality between values while avoiding multiple bindings of the same identifier.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0416.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# let (A, B, C) = (1, 2, 3);\nmatch (A, B, C) {\n    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n    (y, z, see) => { /* A and B not equal; do another thing */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Shell-Style Argfiles in Rust Compiler\nDESCRIPTION: The -Zshell-argfiles flag enables POSIX shell-style argument parsing for argfiles. Arguments must be specified using @shell:<path> syntax, and the flag must precede the argument file specification. The compiler uses shlex for parsing the arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/shell-argfiles.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-Zshell-argfiles @shell:<path>\n```\n\n----------------------------------------\n\nTITLE: Setting AMD GPU target and generation in Cargo configuration\nDESCRIPTION: The snippet provides a `.cargo/config.toml` configuration that specifies the target architecture for AMD GPUs and sets the rustflags to optimize for a particular GPU generation, such as gfx1100. The optional 'build-std' flag includes necessary libraries like 'core', and the setup is required for robust compilation targeting AMD GPUs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/amdgcn-amd-amdhsa.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\ntarget = \"amdgcn-amd-amdhsa\"\\nrustflags = [\"-Ctarget-cpu=gfx1100\"]\\n\\n[unstable]\\nbuild-std = [\"core\"] # Optional: \"alloc\"\n```\n\n----------------------------------------\n\nTITLE: Preferred Match Pattern Formatting in Rust\nDESCRIPTION: The recommended way to format match patterns in Rust, showing proper vertical bar placement between pattern alternatives and correct indentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nmatch foo {\n    foo => bar,\n    a_very_long_pattern\n    | another_pattern\n    | yet_another_pattern\n    | a_fourth_pattern => {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tokenizing source code\nDESCRIPTION: Lexing transforms source code strings into a stream of tokens. This involves identifying keywords, operators, identifiers, and other syntactic elements. The `rustc_lexer` crate is responsible for the tokenization process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/the-parser.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n\"foo.bar + buz\"\n```\n\n----------------------------------------\n\nTITLE: Using rustc with env-set Flag for PATH Variable\nDESCRIPTION: Example showing how to use the `--env-set` flag to override the PATH environment variable at compile time with rustc. The value specified will be available through the env! macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/env-set.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc --env-set PATH=env\n```\n\n----------------------------------------\n\nTITLE: Unterminated character literal in Rust\nDESCRIPTION: This code snippet demonstrates a syntax error in Rust where a character literal starting with a single quote is not terminated with a matching single quote. The specific example uses the crab emoji ('🦀) but is missing the closing quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_char_with_ferris.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n'🦀\n```\n\n----------------------------------------\n\nTITLE: Initializing Struct with Missing Field in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to initialize a struct with a missing field, which results in a compilation error. The 'y' field is not provided, leading to an E0063 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0063.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Definition Example 2 (Rust)\nDESCRIPTION: This example illustrates that `ExpnId` is not isomorphic to `SyntaxContext`. After all expansions, `foo` has context `ROOT -> id(n)` and `bar` has context `ROOT -> id(m) -> id(n)`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmacro m($i: ident) { macro n() { ($i, bar) } }\n\nm!(foo);\n```\n\n----------------------------------------\n\nTITLE: Implementing Decodable for Arena-allocated Types\nDESCRIPTION: Example showing how to implement the Decodable trait for types that contain arena-allocated values, using the TyDecoder trait which provides access to the TyCtxt context needed for arena allocation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/serialization.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for MyStruct<'tcx> {\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Evolving best practices for unsafe code within unsafe functions in Rust\nDESCRIPTION: This example illustrates the changing conventions for unsafe code within unsafe functions, showing both the currently accepted approach and the recommended approach using explicit unsafe blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0133.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\n----------------------------------------\n\nTITLE: Skip FileCheck Verification - Rust\nDESCRIPTION: This comment instructs the test runner to skip FileCheck verification for the current test file. This can be useful in cases where FileCheck is not applicable or when the MIR output is too complex to verify with FileCheck.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n// skip-filecheck\n```\n\n----------------------------------------\n\nTITLE: Invalid Drop Implementation for Generic Type Specialization\nDESCRIPTION: Demonstrates an illegal attempt to implement the Drop trait specifically for Foo<u32>. This fails because Rust does not allow implementing Drop for specific type parameters of generic types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0366.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<T> {\n    t: T\n}\n\nimpl Drop for Foo<u32> {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example output of supported crate types for x86_64-unknown-linux-gnu\nDESCRIPTION: Sample output showing the supported crate types for the x86_64-unknown-linux-gnu target. The output is a newline-delimited list of crate type strings that correspond to values accepted by the `--crate-type` flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/print-supported-crate-types.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nbin\ncdylib\ndylib\nlib\nproc-macro\nrlib\nstaticlib\n```\n\n----------------------------------------\n\nTITLE: Persisting Doctest Executables in Rustdoc (Bash)\nDESCRIPTION: This command shows how to use the --persist-doctests flag in Rustdoc to keep doctest executables after they're compiled or run. This is useful for further testing of the binaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdoctest\n```\n\n----------------------------------------\n\nTITLE: Generating 'is_' Method for Enum Variant in Rust\nDESCRIPTION: This snippet shows how to generate an 'is_' method for an enum variant. It creates an impl block with a method that returns a boolean indicating whether the enum instance matches the specified variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_49\n\nLANGUAGE: rust\nCODE:\n```\nenum Version {\n Undefined,\n Minor,\n Major,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Version {\n Undefined,\n Minor,\n Major,\n}\n\nimpl Version {\n    /// Returns `true` if the version is [`Minor`].\n    ///\n    /// [`Minor`]: Version::Minor\n    #[must_use]\n    fn is_minor(&self) -> bool {\n        matches!(self, Self::Minor)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround: Drop Implementation Using Generic Wrapper Struct (Rust)\nDESCRIPTION: This code demonstrates a valid workaround for implementing Drop behavior for trait types by creating a generic wrapper struct with a trait bound and implementing Drop on that wrapper.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0120.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {}\nstruct MyWrapper<T: MyTrait> { foo: T }\n\nimpl <T: MyTrait> Drop for MyWrapper<T> {\n    fn drop(&mut self) {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Bash Script: Rustup Update\nDESCRIPTION: This snippet shows a bash command used to update the nightly build of Rustup.  It's a common command for developers using nightly Rust features. The command ensures that the user is using the most recent nightly version.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/xtask/test_data/expected.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup update nightly\n```\n\n----------------------------------------\n\nTITLE: Invalid Recursive impl Trait Example in Rust\nDESCRIPTION: Shows an invalid attempt to create a recursive type using impl Trait where the function returns a type that contains itself. This is not allowed as impl Trait must be expandable to a concrete type without impl Trait types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0720.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn make_recursive_type() -> impl Sized {\n    [make_recursive_type(), make_recursive_type()]\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Issues in Rust Documentation\nDESCRIPTION: This snippet shows how to provide a base URL for issue tracking in Rust documentation when features are unstable. The #[doc] attribute is utilized for this purpose.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(issue_tracker_base_url = \\\"https://github.com/rust-lang/rust/issues/\\\")]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Playground URL in Documentation\nDESCRIPTION: Here, the #[doc] attribute is used to set a custom URL that documentation 'run' buttons will make requests to, enhancing user interaction with the code examples.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(html_playground_url = \\\"https://playground.example.com/\\\")]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for Rustfmt 0.2.5\nDESCRIPTION: Documents fixes and additions in version 0.2.5 including attribute preservation and span field access improvements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_25\n\nLANGUAGE: markdown\nCODE:\n```\n## [0.2.5] 2017-08-31\n\n### Added\n\n- Format and preserve attributes on statements (#1933).\n\n### Fixed\n\n- Use getters to access `Span` fields (#1899).\n```\n\n----------------------------------------\n\nTITLE: Merging Match Arms with Identical Bodies in Rust\nDESCRIPTION: Shows combining multiple match arms that have identical execution bodies using the OR pattern syntax. This refactoring reduces duplication in pattern matching code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_81\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        ┃Action::Move(..) => foo(),\n        Action::Stop => foo(),\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move(..) | Action::Stop => foo(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Async Function Return Type Implementation\nDESCRIPTION: Fixed version of the code that explicitly specifies the type S<'a> instead of using Self as the return type, which is the currently supported approach.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0760.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<'a>(&'a i32);\n\nimpl<'a> S<'a> {\n    async fn new(i: &'a i32) -> S<'a> {\n        S(&22)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AST Structural Transformations\nDESCRIPTION: Key structural changes during AST to HIR conversion, including removal of parentheses, loop transformations, and type representation modifications\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ast-lowering.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n* Parenthesis\n    * Removed without replacement, the tree structure makes order explicit\n* `for` loops and `while (let)` loops\n    * Converted to `loop` + `match` and some `let` bindings\n* `if let`\n    * Converted to `match`\n* Universal `impl Trait`\n    * Converted to generic arguments\n* Existential `impl Trait`\n    * Converted to a virtual `existential type` declaration\n```\n\n----------------------------------------\n\nTITLE: Setting Language Properties for C Sources\nDESCRIPTION: This CMake command sets the `LANGUAGE` property to `C` for the files listed in `C_SOURCES`.  This ensures that the CMake build system treats them as C source files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset_source_files_properties(${C_SOURCES}\n                            PROPERTIES\n                            LANGUAGE C)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Framework Linking in Rust for Non-macOS Platforms\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to link a framework on a non-macOS platform, which will result in a compilation error. It's used to illustrate the platform-specific nature of framework linking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0455.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[link(name = \"FooCoreServices\", kind = \"framework\")] extern \"C\" {}\n```\n\n----------------------------------------\n\nTITLE: Applying De Morgan's Law to Iterator Methods in Rust\nDESCRIPTION: This assist applies De Morgan's law to `Iterator::all` and `Iterator::any` methods. It transforms `!iter.any(|x| predicate(x))` into `iter.all(|x| !predicate(x))` and vice versa.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let arr = [1, 2, 3];\n    if !arr.into_iter().any(|num| num == 4) {\n        println!(\"foo\");\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let arr = [1, 2, 3];\n    if arr.into_iter().all(|num| num != 4) {\n        println!(\"foo\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating NRO Format Binaries Using cargo-nx\nDESCRIPTION: This command utilizes the cargo-nx tool to generate NRO format binaries from Rust code for easy execution on the Nintendo Switch. It specifies the target triple for the compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-nintendo-switch-freestanding.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ncargo nx --triple=aarch64-nintendo-switch-freestanding\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Rust Compiler Feature in Markdown\nDESCRIPTION: This snippet provides a brief description of the 'derive_clone_copy' feature, emphasizing its internal nature and restrictions on general use. It uses Markdown formatting for the heading.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/derive-clone-copy.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `derive_clone_copy`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Adding a target specification - Diff\nDESCRIPTION: This diff shows how to modify the Cargo.toml file to include a new target architecture in the Rust standard library configuration by adjusting the cfg settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n  [lints.rust.unexpected_cfgs]\n  level = \"warn\"\n  check-cfg = [\n      'cfg(bootstrap)',\n-      'cfg(target_arch, values(\"xtensa\"))',\n+      # #[cfg(bootstrap)] NEW_TARGET_ARCH\n+      'cfg(target_arch, values(\"xtensa\", \"NEW_TARGET_ARCH\"))',\n```\n\n----------------------------------------\n\nTITLE: Trailing Commas in Rust Lists\nDESCRIPTION: Shows the recommended use of trailing commas in function calls and array declarations when items are followed by a newline, which simplifies code modification and reduces diff complexity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfunction_call(\n    argument,\n    another_argument,\n);\n\nlet array = [\n    element,\n    another_element,\n    yet_another_element,\n];\n```\n\n----------------------------------------\n\nTITLE: Staging Files After Resolving Conflicts\nDESCRIPTION: Stages the specified file, indicating that the conflicts within it have been resolved and the desired changes are ready to be committed or continued in the rebase/merge process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ngit add\n```\n\n----------------------------------------\n\nTITLE: Disabling LLD Linker\nDESCRIPTION: Example command showing how to explicitly disable LLD linker usage in Rust, which would opt out of using LLD even if the current target had self-contained linking enabled by default.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/linker-features.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-Clinker-features=-lld\n```\n\n----------------------------------------\n\nTITLE: Prolog Mapping for Trait Implementations - Text\nDESCRIPTION: This snippet provides a representation of the Rust trait implementation in Prolog-like notation, showcasing how traits can be inferred through logic clauses.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nClone(usize).\nClone(Vec<?T>) :- Clone(?T).\n\n// The notation `A :- B` means \"A is true if B is true\".\n// Or, put another way, B implies A.\n```\n\n----------------------------------------\n\nTITLE: Example of Early-Bound Lifetimes in Functions\nDESCRIPTION: This code demonstrates the use of early-bound lifetimes with two functions, foo and bar, which illustrate how Rust handles lifetime parameters in type contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a: 'a>(_: &'a String) {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn bar<'a, T: 'a>(_: &'a T) {}\n```\n\n----------------------------------------\n\nTITLE: Running Cargotest in Rust CI\nDESCRIPTION: Command to execute the cargotest tool which runs cargo test on sample projects like servo, ripgrep, and tokei as part of Rust's CI process to check for regressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ecosystem.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n./x test src/tools/cargotest\n```\n\n----------------------------------------\n\nTITLE: Configuring Clippy Lints in TOML\nDESCRIPTION: This snippet demonstrates how to configure lints in Clippy using a TOML configuration file. It illustrates the basic variable assignment mapping and how to extend default values for list-type configurations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/configuration.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\navoid-breaking-exported-api = false\ndisallowed-names = [\"toto\", \"tata\", \"titi\"]\n```\n\nLANGUAGE: toml\nCODE:\n```\n# default of disallowed-names is [\"foo\", \"baz\", \"quux\"]\ndisallowed-names = [\"bar\", \"..\"] # -> [\"bar\", \"foo\", \"baz\", \"quux\"]\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee without ?Sized Bound\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct with a pointee type parameter that isn't marked as ?Sized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\n#[repr(transparent)]\nstruct NoMaybeSized<'a, #[pointee] T> {\n    ptr: &'a T,\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Match Expressions in Rust\nDESCRIPTION: Basic structure for match expressions in Rust, showing proper indentation and brace placement. Arms should be block-indented once, with breaks after opening and before closing braces.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nmatch foo {\n    // arms\n}\n\nlet x = match foo.bar.baz() {\n    // arms\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Pointer to Reference Cast\nDESCRIPTION: Illustrates an incorrect casting attempt from a constant pointer (*const u8) to a reference (&u8), which is not permitted in Rust's type system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0605.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet v = core::ptr::null::<u8>(); // So here, `v` is a `*const u8`.\nv as &u8; // error: non-primitive cast: `*const u8` as `&u8`\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Trait with Associated Type in Rust\nDESCRIPTION: This code example shows the correct way to implement a trait that defines an associated type. The trait and implementation both use 'type N' syntax consistently.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0325.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\ntrait Foo {\n    type N;\n}\n\nimpl Foo for Bar {\n    type N = u32; // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Installing AVR-GCC on Different Platforms\nDESCRIPTION: Command-line instructions for installing AVR-GCC compiler dependencies on various operating systems\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/avr-none.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n# Ubuntu:\n$ sudo apt-get install gcc-avr\n\n# Mac:\n$ brew tap osx-cross/avr && brew install avr-gcc\n\n# NixOS (takes a couple of minutes, since it's not provided through Hydra):\n$ nix shell nixpkgs#pkgsCross.avr.buildPackages.gcc11\n```\n\n----------------------------------------\n\nTITLE: Incorrect Self Import in Rust\nDESCRIPTION: Shows incorrect usage of 'self' keyword in a use declaration that results in compilation error E0429.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0429.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::self; // error: `self` imports are only allowed within a { } list\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Lifetime Elision Error\nDESCRIPTION: Example showing code that fails to compile due to unsatisfied outlives bounds between an elided lifetime and generic type parameter T. The compiler cannot establish that T outlives the elided lifetime in no_restriction().\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0311.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn no_restriction<T>(x: &()) -> &() {\n    with_restriction::<T>(x)\n}\n\nfn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Correct FFI Const Usage in External Function Declaration\nDESCRIPTION: Example showing correct usage of the ffi_const attribute on a foreign function declaration (strlen) in an extern block.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0756.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_const)]\n\nextern \"C\" {\n    #[unsafe(ffi_const)] // ok!\n    pub fn strlen(s: *const i8) -> i32;\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Expanding Tuple Struct Rest Pattern in Rust\nDESCRIPTION: Expands rest pattern (..) in tuple struct patterns into explicit field bindings using numbered fields (_0, _1, etc).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_43\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar(Y, Z);\n\nfn foo(bar: Bar) {\n    let Bar(..) = bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Receiver Types with arbitrary_self_types Feature in Rust\nDESCRIPTION: Demonstrates using a custom SmartPtr type as a receiver in a method. The SmartPtr implements core::ops::Receiver, allowing it to be used as the self parameter type in methods of type A.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types)]\n\nstruct A;\n\nimpl A {\n    fn f(self: SmartPtr<Self>) -> i32 { 1 }  // note self type\n}\n\nstruct SmartPtr<T>(T);\n\nimpl<T> core::ops::Receiver for SmartPtr<T> {\n    type Target = T;\n}\n\nfn main() {\n    let smart_ptr = SmartPtr(A);\n    assert_eq!(smart_ptr.f(), 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Extern Crate Declaration Formatting in Rust\nDESCRIPTION: Illustrates the formatting for `extern crate` declarations in Rust, including spacing around keywords and the semicolon.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nextern crate foo;\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Function Arguments in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for function arguments. In this style, arguments after the first line are aligned with the start of the first argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem() {}\n\nfn lorem(ipsum: usize) {}\n\nfn lorem(ipsum: usize,\n         dolor: usize,\n         sit: usize,\n         amet: usize,\n         consectetur: usize,\n         adipiscing: usize,\n         elit: usize) {\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Installing mdBook using Cargo for Clippy Book Development\nDESCRIPTION: Command to install mdBook using Cargo, which is needed to build and test the Clippy book locally. This is the recommended installation method if you already have Cargo installed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/book.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook\n```\n\n----------------------------------------\n\nTITLE: Match Arm Leading Pipes with Never Setting in Rust\nDESCRIPTION: Shows the default match_arm_leading_pipes setting (Never), which removes leading pipe characters from match arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_43\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    match foo {\n        \"foo\" | \"bar\" => {},\n        \"baz\"\n        | \"something relatively long\"\n        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n        \"qux\" => println!(\"y\"),\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Pattern Matching in Rust\nDESCRIPTION: Example of proper pattern matching for an enum variant with multiple fields. The match pattern correctly specifies variables for both fields of the Apple variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0023.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n\nlet x = Fruit::Apple(String::new(), String::new());\n\n// Correct.\nmatch x {\n    Fruit::Apple(a, b) => {},\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Usefulness in Rust Match Expression\nDESCRIPTION: This snippet shows a match expression on a tuple of (bool, Option<Foo>), illustrating how pattern usefulness is checked for redundancy and exhaustiveness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// x: (bool, Option<Foo>)\nmatch x {\n    (true, _) => {} // 1\n    (false, Some(Foo::Bar)) => {} // 2\n    (false, Some(_)) => {} // 3\n    (true, None) => {} // 4\n}\n```\n\n----------------------------------------\n\nTITLE: External Function Reference List in Rust\nDESCRIPTION: A plain list tracking references to external functions across different modules. The list shows repeated mentions of extern_fn_1 and extern_fn_2 in different contexts (extern_1 and extern_2).\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-inline-cross-dylib/output.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nextern_fn_1\nextern_fn_2 in extern_2\nextern_fn_2 in extern_1\nextern_fn_1\nextern_fn_2 in extern_2\nextern_fn_2 in extern_2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0373 Error in Rust Function Return\nDESCRIPTION: This code snippet shows an erroneous example where a closure captures a local variable, causing an E0373 error when trying to return the closure from a function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0373.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Box<dyn Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\n----------------------------------------\n\nTITLE: Early vs Late Bound Lifetime Comparison\nDESCRIPTION: Shows the theoretical difference between early and late bound lifetimes for type outlives bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn early_bound<'a: 'a>(_: &'a String) {}\nfn late_bound<'a>(_: &'a String) {}\n\nfn requires_static<T: 'static>(_: T) {}\n\nfn bar<'b>() {\n    let e = early_bound::<'b>;\n    // this *should* error but does not\n    requires_static(e);\n\n    let l = late_bound;\n    // this correctly does not error\n    requires_static(l);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring enable-raw-pointer-heuristic-for-send\nDESCRIPTION: Controls whether to apply the raw pointer heuristic to determine if a type is `Send`. Defaults to `true`. This affects how Clippy checks for thread safety related to raw pointers.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Referencing Rust Code of Conduct in Markdown\nDESCRIPTION: A markdown snippet that provides a header and a link to the online location of the Rust Code of Conduct. This is typically used in project repositories to direct contributors to the official conduct guidelines.\nSOURCE: https://github.com/rust-lang/rust/blob/master/CODE_OF_CONDUCT.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# The Rust Code of Conduct\n\nThe Code of Conduct for this repository [can be found online](https://www.rust-lang.org/conduct.html).\n```\n\n----------------------------------------\n\nTITLE: Valid Single Lifetime Quantification in Rust Where Clause\nDESCRIPTION: Corrected example showing proper usage of lifetime quantification by combining multiple lifetimes into a single for clause, which is supported by Rust's syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0316.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Tr<'a, 'b> {}\n\nfn foo<T>(t: T)\nwhere\n    for<'a, 'b> &'a T: Tr<'a, 'b>, // ok\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with Per-Target Ignores (Rust)\nDESCRIPTION: This Rust code snippet shows an example of using per-target ignores in a doctest. It demonstrates how to tag doctests with ignore-foo filters to prevent running on specific targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n///```ignore-foo,ignore-bar\n///assert!(2 == 2);\n///```\nstruct Foo;\n```\n\n----------------------------------------\n\nTITLE: Implementing Local Trait for Foreign Type (Rust)\nDESCRIPTION: This code snippet demonstrates an alternative approach to avoid the orphan rule violation by defining a local trait (Bar) and implementing it for a foreign type (u32).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0117.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Implementation of Foreign Trait with Reordered Type Parameters in Rust\nDESCRIPTION: This example demonstrates a valid implementation of a foreign trait with multiple type parameters by reordering them to ensure the local type appears before any use of type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0210.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n```\n\n----------------------------------------\n\nTITLE: Defining Double Precision Float in Rust\nDESCRIPTION: Rust primarily uses f64 as the equivalent of C's double type, which is guaranteed to be an IEEE 754 double-precision floating point number. The standard allows for potential variations in implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_double.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x: f64 = 3.14159;\n```\n\n----------------------------------------\n\nTITLE: Valid Auto Trait Bounds Example in Rust\nDESCRIPTION: Shows a valid case where one non-builtin trait (Read) is combined with auto traits (Send and Sync) as bounds for a trait object. This is allowed and compiles successfully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0225.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let _: Box<dyn std::io::Read + Send + Sync>;\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping C Integer Type in Rust\nDESCRIPTION: Represents the Rust equivalent of C's signed int type, typically mapped to i32 but potentially varying on different systems. Provides insight into type compatibility and system-specific integer representations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_int.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype c_int = i32\n```\n\n----------------------------------------\n\nTITLE: Running the dot_product example with Cargo\nDESCRIPTION: Command to execute the dot_product example from the stdsimd examples crate. This command runs the dot_product.rs file which demonstrates various SIMD implementations of the dot product operation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/crates/core_simd/examples/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --example dot_product\n```\n\n----------------------------------------\n\nTITLE: Incorrect Trait Implementation with Associated Type Override\nDESCRIPTION: Example showing incorrect implementation of a trait where an associated type is overridden without reimplementing the default method, resulting in a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0399.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(associated_type_defaults)]\n\npub trait Foo {\n    type Assoc = u8;\n    fn bar(&self) {}\n}\n\nimpl Foo for i32 {\n    // error - the following trait items need to be reimplemented as\n    //         `Assoc` was overridden: `bar`\n    type Assoc = i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Consistent Variable Binding in Or Pattern - Rust\nDESCRIPTION: This example demonstrates proper variable binding in an OR pattern by ensuring the variable 'y' is bound to a field of the same type in all sub-patterns. The variable is consistently bound regardless of which pattern matches.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0408.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = (0, 2);\nmatch x {\n    (0, y) | (y, 0) => { /* use y */}\n    _ => {}\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Option Return Type in Rust Functions\nDESCRIPTION: Removes the Option wrapper from a function's return type and automatically unwraps the returned value. Useful for simplifying function signatures when Option is no longer needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_115\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> Option<i32> { Some(42i32) }\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> i32 { 42i32 }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0283 Error with Trait Implementation in Rust\nDESCRIPTION: This code snippet shows another scenario that triggers the E0283 error, this time involving trait implementation and method calls.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\n----------------------------------------\n\nTITLE: Configuring Unit Tests Module in Rust\nDESCRIPTION: Shows how to set up separate test modules in Rust crates to optimize compilation times. Tests are placed in a separate file to prevent recompiling the entire crate when tests change.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Mutable Reference Assignment in Rust\nDESCRIPTION: Demonstrates an erroneous attempt to modify data through a non-mutable reference to a mutable reference, which violates Rust's borrowing rules\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0389.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n    let fancy_ref = &(&mut fancy);\n    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n    println!(\"{}\", fancy_ref.num);\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of DiscoverArgument::Path for Workspace Discovery\nDESCRIPTION: JSON example representing the 'Path' variant of DiscoverArgument serialized for passing to the rust-analyzer workspace discovery command. It includes the path key with the source file path.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"path\": \"src/main.rs\"\n}\n```\n\n----------------------------------------\n\nTITLE: Prefer Using General Types\nDESCRIPTION: The code illustrates the preference for more general types on the left, highlighting the benefit of maintaining generality and consistency in type declarations across the code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD      BAD\n&[T]         &Vec<T>\n&str         &String\nOption<&T>   &Option<T>\n&Path        &PathBuf\n```\n\n----------------------------------------\n\nTITLE: Compiling Windows Build System\nDESCRIPTION: Command to compile the build system on Windows using the custom stage2 rustc. This step is necessary for running the build scripts on Windows platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nrustc +stage2 -O build_system/main.rs -o y.exe\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Removing Integer Representation from Zero-Variant Enum in Rust\nDESCRIPTION: This solution addresses the E0084 error by removing the integer representation attribute, allowing a zero-variant enum to be defined without specifying how its (non-existent) values should be represented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0084.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum NightsWatch {}\n```\n\n----------------------------------------\n\nTITLE: Checking Immediate Binding in ELF Binary\nDESCRIPTION: This command uses readelf to check if immediate binding is enabled in a compiled Rust binary by looking for the BIND_NOW flag in the dynamic section.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -d target/release/hello-rust | grep BIND_NOW\n 0x000000000000001e (FLAGS)              BIND_NOW\n```\n\n----------------------------------------\n\nTITLE: Invoking a Query in Rust Compiler\nDESCRIPTION: Shows how to invoke a query (specifically 'type_of') using the TyCtxt (type context) struct. Queries are memoized functions that compute information about the input source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet ty = tcx.type_of(some_def_id);\n```\n\n----------------------------------------\n\nTITLE: Enabling Export of Symbols with RUSTFLAGS\nDESCRIPTION: Bash commands showing how to set the RUSTFLAGS environment variable to include the -Zexport-executable-symbols flag, which enables the export of symbols from executables when building with Cargo.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/export-executable-symbols.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport RUSTFLAGS=\"-Zexport-executable-symbols\"\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Incorrect Trait Object Declaration without Associated Type\nDESCRIPTION: Example showing erroneous code where an associated type is not specified for a trait object, resulting in compilation error E0191.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0191.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = dyn Trait; // error: the value of the associated type `Bar` (from\n                      //        the trait `Trait`) must be specified\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Disallowed Feature Attribute Usage in Rust\nDESCRIPTION: Shows an example of attempting to use a feature attribute that is not allowed by the compiler flags. The code generates an error because the 'never_type' feature is not in the list of allowed features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0725.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(never_type)] // error: the feature `never_type` is not in\n                        // the list of allowed features\n```\n\n----------------------------------------\n\nTITLE: Declaring Traits and Implementations - Rust\nDESCRIPTION: This snippet demonstrates how to declare a trait and implementations for it in Rust, illustrating the mapping to logical inference rules. The `Clone` trait is declared for types `usize` and `Vec<T>`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Clone { }\nimpl Clone for usize { }\nimpl<T> Clone for Vec<T> where T: Clone { }\n```\n\n----------------------------------------\n\nTITLE: Triggering Performance Test for Existing Build\nDESCRIPTION: Command to request a performance test run for an already built artifact using its commit SHA. Cannot be used to benchmark the same artifact multiple times.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/perf.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n@rust-timer build <commit-sha>\n```\n\n----------------------------------------\n\nTITLE: Cross-Crate Re-export Example in JSON\nDESCRIPTION: JSON example showing how re-exports are handled across different crates, including references to dependencies and standard library items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\n  [ \"crate_name\", ... ],\n  [ \"crate_name_2\", { \"q\": [[0, \"crate_name::submodule\"], [5, \"core::option\"]], ... }]\n]\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration Example\nDESCRIPTION: This snippet demonstrates a simple JSON configuration used in the Rust Analyzer project, likely for settings or data serialization. It shows a key-value pair with \"foo\" as the key and \"bar\" as the value. This is a typical example of configuration data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/xtask/test_data/expected.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"foo\":\"bar\"}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Doc Comment in Rust\nDESCRIPTION: Converts traditional doc-comments to attribute form using the #[doc] attribute for clearer documentation representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n#[doc = r\"Multi-line\ncomment\"]\n```\n\n----------------------------------------\n\nTITLE: Correct Union Initialization in Rust\nDESCRIPTION: This example demonstrates the proper way to initialize a union by specifying exactly one field. In this case, we initialize only the 'pigeon' field of the Bird union.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0784.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nunion Bird {\n    pigeon: u8,\n    turtledove: u16,\n}\n\nlet bird = Bird { pigeon: 0 }; // OK\n```\n\n----------------------------------------\n\nTITLE: Fixing Unconstrained Type Parameter by Moving to Method\nDESCRIPTION: This code shows a solution to the E0207 error by moving the type parameter from the impl block to the method level, which properly constrains it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\n// Move the type parameter from the impl to the method\nimpl Foo {\n    fn get<T: Default>(&self) -> T {\n        <T as Default>::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Clippy Driver Directly\nDESCRIPTION: Example of using clippy-driver directly without cargo, showing how to pass compiler flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/usage.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nclippy-driver --edition 2018 -Cpanic=abort foo.rs\n```\n\n----------------------------------------\n\nTITLE: Formatting Spaces Around Ranges in Rust\nDESCRIPTION: Shows the effect of the 'spaces_around_ranges' option. When false (default), no spaces are added around range operators. When true, spaces are added around range operators.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_67\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = 0..10;\n    let ipsum = 0..=10;\n\n    match lorem {\n        1..5 => foo(),\n        _ => bar,\n    }\n\n    match lorem {\n        1..=5 => foo(),\n        _ => bar,\n    }\n\n    match lorem {\n        1...5 => foo(),\n        _ => bar,\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = 0 .. 10;\n    let ipsum = 0 ..= 10;\n\n    match lorem {\n        1 .. 5 => foo(),\n        _ => bar,\n    }\n\n    match lorem {\n        1 ..= 5 => foo(),\n        _ => bar,\n    }\n\n    match lorem {\n        1 ... 5 => foo(),\n        _ => bar,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Octal Digits Error\nDESCRIPTION: This snippet demonstrates an error case where an octal integer literal (0o) is defined without any digits following the prefix. This will cause a compiler error indicating missing digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0o\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Running Stack Use After Scope Example with ASan (Shell)\nDESCRIPTION: This command sequence compiles and runs the stack use after scope example with AddressSanitizer enabled. The ASan output correctly identifies the 'stack-use-after-scope' error, pointing to the attempt to write to the pointer `P` after the variable `x` is no longer valid.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\nLANGUAGE: Shell\nCODE:\n```\n=================================================================\n==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\nWRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n    ...\n\nAddress 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n\n  This frame has 1 object(s):\n    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\nShadow bytes around the buggy address:\n  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==39249==ABORTING\n```\n\n----------------------------------------\n\nTITLE: Enabling ptrace for Debugging on Linux\nDESCRIPTION: Command to enable ptrace for unrelated processes on Linux, which may be necessary when attaching a debugger to a running rust-analyzer server.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\necho 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n```\n\n----------------------------------------\n\nTITLE: Incorrect Constant Initialization in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous way of initializing a constant in Rust. It attempts to use a non-constant value (a local variable) in the initialization, which is not allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0014.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Predicate in cfg Attribute\nDESCRIPTION: This snippet demonstrates an incorrect use of the cfg attribute with an unknown predicate in Rust, leading to a compilation error. It highlights the need for valid predicates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0537.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(unknown())] // error: invalid predicate `unknown`\npub fn something() {}\n\npub fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unnecessary Public Visibility in Rust Enum\nDESCRIPTION: This code snippet shows an erroneous example where the `pub` keyword is unnecessarily used inside a public enum, which previously triggered a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0448.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum Foo {\n    pub Bar, // error: unnecessary `pub` visibility\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Intra-Doc Pointers Feature in Rust\nDESCRIPTION: Example showing how to enable the intra-doc-pointers feature flag and use it with documentation links. This feature is currently unstable and requires explicit opt-in via the feature flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/intra-doc-pointers.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intra_doc_pointers)]\n//! [pointer::add]\n```\n\n----------------------------------------\n\nTITLE: Merging Nested If Statements in Rust\nDESCRIPTION: Demonstrates combining nested if statements into a single if statement with a logical AND condition. This simplifies code structure and makes the condition more readable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_82\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n   i┃f x == 3 { if y == 4 { 1 } }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n   if x == 3 && y == 4 { 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Yield Usage Outside Async Block (Rust)\nDESCRIPTION: This code snippet shows the correct way to use `yield` by moving it outside of the `async` block, resolving the compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0727.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coroutines, stmt_expr_attributes)]\n\nfn main() {\n    let coroutine = #[coroutine] || {\n        yield;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Error Example: Calling Non-Const Function in Const Context\nDESCRIPTION: An example of code that fails to compile because it calls a non-const function 'create_some' in a const context. This generates error E0015.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0015.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\n// error: cannot call non-const function `create_some` in constants\nconst FOO: Option<u8> = create_some();\n```\n\n----------------------------------------\n\nTITLE: Identifying Apple Platform Labels in GitHub\nDESCRIPTION: GitHub labels used to track and manage Apple platform-specific issues in the Rust project, covering macOS, iOS, tvOS, watchOS, and visionOS\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/apple.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* [O-macos]\n* [O-ios]\n* [O-tvos]\n* [O-watchos]\n* [O-visionos]\n```\n\n----------------------------------------\n\nTITLE: Computing Trait Goal in Rust Solver\nDESCRIPTION: The compute_trait_goal function collects all possible ways to prove a trait goal, such as Vec<T>: Clone. It uses assemble_and_evaluate_candidates to gather candidates and merge_candidates to combine the results.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/the-solver.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nEvalCtxt::compute_trait_goal\n```\n\n----------------------------------------\n\nTITLE: Running Code Examples as Tests\nDESCRIPTION: This code snippet shows how to use the `--test` flag to run code examples within the documentation as tests.  This verifies that the code examples are valid and executable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --test\n```\n\n----------------------------------------\n\nTITLE: Resolving Borrowing with Function Parameter\nDESCRIPTION: Demonstrates how passing a reference to a function can help manage borrowing constraints\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0506.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rust Crate for SIMD - Bash\nDESCRIPTION: This bash command initializes a new Rust crate named 'hellosimd', which will be used as the project for SIMD code development. This setup is crucial for organizing Rust code dedicated to SIMD operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo new hellosimd\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Name Conflict Error in Rust Module Imports\nDESCRIPTION: Shows an erroneous code example where importing a function with the same name as an existing function causes a compilation error E0255.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0255.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse bar::foo; // error: an item named `foo` is already in scope\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Static-Const Reference Pattern in Rust\nDESCRIPTION: Shows the correct way to share values between static and const variables by first declaring the value as a const and then referencing it in both static and const declarations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0013.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nconst A: i32 = 42;\nstatic X: i32 = A;\nconst Y: i32 = A;\n```\n\n----------------------------------------\n\nTITLE: Corrected Rust Enum Field Definition and Access\nDESCRIPTION: Shows the correct way to define an enum variant with a field and access it. This example demonstrates proper field naming and initialization in a Rust enum.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0559.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Field {\n    Fool { joke: u32 },\n}\n\nlet s = Field::Fool { joke: 0 }; // ok!\n```\n\n----------------------------------------\n\nTITLE: Correct usage of unsafe function with an unsafe block in Rust\nDESCRIPTION: This example shows the proper way to call an unsafe function by wrapping the call in an unsafe block, which acknowledges and allows the potentially dangerous operation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0133.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Options in Rust Compiler with TOML\nDESCRIPTION: This configuration snippet enables debug information in the Rust compiler by setting relevant parameters in the `bootstrap.toml` file. It includes enabling debug assertions and the debuginfo level.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\ndebug = true\ndebuginfo-level = 2\n```\n\n----------------------------------------\n\nTITLE: Compiling C Code for GIMPLE Generation\nDESCRIPTION: This console command shows how to compile the C code that generates GIMPLE output. It includes the necessary include and library paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\ngcc local.c -I `pwd`/gcc/gcc/jit/ -L `pwd`/gcc-build/gcc -lgccjit -o out\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for wasi-sdk\nDESCRIPTION: This snippet demonstrates how to set the WASI_SDK_PATH environment variable to point to the installed wasi-sdk. This is necessary for building the wasm32-wasip2 target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip2.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport WASI_SDK_PATH=/path/to/wasi-sdk-22.0\n```\n\n----------------------------------------\n\nTITLE: Enum Discriminant Alignment - Default\nDESCRIPTION: Demonstrates the default behavior of enum discriminant alignment when `enum_discrim_align_threshold` is set to 0. No alignment is performed because the threshold is set to 0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    A = 0,\n    Bb = 1,\n    RandomLongVariantGoesHere = 10,\n    Ccc = 71,\n}\n\nenum Bar {\n    VeryLongVariantNameHereA = 0,\n    VeryLongVariantNameHereBb = 1,\n    VeryLongVariantNameHereCcc = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Duplicate Lifetime Declaration in Rust Function\nDESCRIPTION: Example showing incorrect usage where the lifetime parameter 'a' is declared twice in the function signature, which was previously a compiler error E0403.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0263.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b, 'a>(x: &'a str, y: &'b str, z: &'a str) { // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Generics Clause Formatting in Rust\nDESCRIPTION: Demonstrates how to format multi-line generics clauses in Rust. It includes putting each parameter on its own block-indented line and using a trailing comma.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<\n    T: Display,\n    U: Debug,\n>(x: Vec<T>, y: Vec<U>) ...\n```\n\n----------------------------------------\n\nTITLE: Fixing Unconstrained Const Parameter by Moving to Method\nDESCRIPTION: This code shows how to fix the E0207 error with const parameters by moving the const parameter from the impl block to the method level.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\n// Move the const parameter from the impl to the method\nimpl Foo {\n    fn get<const T: i32>(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running tests with remote runner\nDESCRIPTION: This command sets the `TEST_DEVICE_ADDR` environment variable and runs the specified tests using the remote runner. It targets the RISC-V architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n\nexport TEST_DEVICE_ADDR=\"1.2.3.4:12345\"\n./x test tests/ui --target riscv64gc-unknown-linux-gnu\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Extended-Sysroot Test Suite in Rust Build System\nDESCRIPTION: Configuration section for test suite components that require an extended sysroot. Includes tests for external libraries like rust-random/rand, regex, and portable-simd.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/config.txt#2025-04-21_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\ntestsuite.extended_sysroot\ntest.rust-random/rand\ntest.regex\ntest.portable-simd\n```\n\n----------------------------------------\n\nTITLE: Using the stable attribute in Rust\nDESCRIPTION: The #[stable] attribute explicitly marks an item as stabilized in the Rust standard library. It specifies the feature name and the version since which it has been stabilized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stability.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[stable(feature = \"foo\", since = \"1.420.69\")]\n```\n\n----------------------------------------\n\nTITLE: Erroneous Binary Assignment on Unsupported Type in Rust\nDESCRIPTION: This code snippet demonstrates an error where the left shift assignment operator is applied to a float type, which doesn't support this operation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0368.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 12f32; // error: binary operation `<<` cannot be applied to\n                   //        type `f32`\n\nx <<= 2;\n```\n\n----------------------------------------\n\nTITLE: Incorrect SIMD Intrinsic Monomorphization in Rust\nDESCRIPTION: Demonstrates an invalid attempt to use the simd_add intrinsic function with non-SIMD types, which results in a compile-time error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0511.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n\n#[rustc_intrinsic]\nunsafe fn simd_add<T>(a: T, b: T) -> T;\n\nfn main() {\n    unsafe { simd_add(0, 1); }\n    // error: invalid monomorphization of `simd_add` intrinsic\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Missing Default Impl Members in Rust\nDESCRIPTION: This assist adds scaffold for overriding default impl members. It inserts the default implementation of trait methods that have a default implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type X;\n    fn foo(&self);\n    fn bar(&self) {}\n}\n\nimpl Trait for () {\n    type X = ();\n    fn foo(&self) {}\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type X;\n    fn foo(&self);\n    fn bar(&self) {}\n}\n\nimpl Trait for () {\n    type X = ();\n    fn foo(&self) {}\n\n    fn bar(&self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporary Directory for Remote Test Server\nDESCRIPTION: Setting TMPDIR environment variable when running remote test server to specify temporary storage location\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nTMPDIR=/data/tmp/rust remote-test-server --bind 0.0.0.0:12345\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unterminated Double Quote String Error in Rust\nDESCRIPTION: This code snippet shows an example of an unterminated double quote string in Rust, which results in a compilation error (E0765). The string is not properly closed, causing the error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0765.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"; // error!\n```\n\n----------------------------------------\n\nTITLE: Invalid DispatchFromDyn Implementation with Extra Fields\nDESCRIPTION: This example shows an erroneous implementation of DispatchFromDyn on a struct with multiple fields, which is not allowed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0378.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(dispatch_from_dyn)]\nuse std::ops::DispatchFromDyn;\n\nstruct WrapperExtraField<T> {\n    ptr: T,\n    extra_stuff: i32,\n}\n\nimpl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\nwhere\n    T: DispatchFromDyn<U>,\n{}\n```\n\n----------------------------------------\n\nTITLE: Tracing Region Constraints in Rust Functions\nDESCRIPTION: This snippet advances the analysis of function types with distinct regions, breaking down the relationships further to yield specific region constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n'!1: '?3\n'!2: '?3\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Library Crate with Name A\nDESCRIPTION: This snippet defines a Rust library crate named 'a'. It serves as a base for demonstration of crate name conflicts when multiple crates share the same name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0519.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"a\"]\n#![crate_type = \"lib\"]\n\npub fn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring enum-variant-name-threshold\nDESCRIPTION: Sets the minimum number of enum variants for the variant name lints to trigger. Defaults to `3`.  This helps in controlling the sensitivity of variant name linting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_17\n\n\n\n----------------------------------------\n\nTITLE: Upcasting Mechanism in Rust's Unsize Trait\nDESCRIPTION: The snippet outlines the complex upcasting functionality associated with the Unsize trait in Rust, detailing the procedures for unifying traits and managing auto traits and projections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/unsize.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nTwo things are called \"upcasting\" internally:\n1. True upcasting `dyn SubTrait` -> `dyn SuperTrait` (this also allows\ndropping auto traits and adjusting lifetimes, as below).\n2. Dropping auto traits and adjusting the lifetimes of dyn trait\nwithout changing the principal[^1]:\n`dyn Trait + AutoTraits... + 'a` -> `dyn Trait + NewAutoTraits... + 'b`\nwhen `AutoTraits` ⊇ `NewAutoTraits`, and `'a: 'b`.\n```\n\n----------------------------------------\n\nTITLE: Configuring excessive-nesting-threshold\nDESCRIPTION: Sets the maximum amount of nesting a block can have. Defaults to `0`. This helps in identifying and mitigating overly nested code structures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_19\n\n\n\n----------------------------------------\n\nTITLE: Renaming Cargo Package for Publishing\nDESCRIPTION: Instructions for renaming the package from 'clippy_dummy' to 'clippy' in Cargo.toml before publishing to crates.io. The temporary name is used to avoid workspace conflicts during development.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/clippy_dummy/PUBLISH.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Before publishing:\n# clippy_dummy -> clippy in Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Invalid Non-ASCII Identifier Usage in Rust\nDESCRIPTION: Examples of invalid usage of non-ASCII identifiers in Rust, showing errors when used in module declarations and no_mangle functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0754.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod řųśť; // error!\n\n#[no_mangle]\nfn řųśť() {} // error!\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Style Edition 2015 vs 2024 - Function Calls\nDESCRIPTION: Demonstrates the difference in formatting function calls between style_edition 2015 and 2024, specifically around overflow_delimited_expr behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// with style_edition=2015\ndo_thing(\n    x,\n    Bar {\n        x: value,\n        y: value2,\n    },\n);\n\n// with style_edition=2024\ndo_thing(x, Bar {\n    x: value,\n    y: value2,\n});\n```\n\n----------------------------------------\n\nTITLE: Inlining a Type Alias in Rust\nDESCRIPTION: Shows how a type alias can be replaced with its concrete type. This example demonstrates replacing a generic type alias with its default type instantiation at a usage site.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_71\n\nLANGUAGE: rust\nCODE:\n```\ntype A<T = u32> = Vec<T>;\n\nfn main() {\n    let a: ┃A;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntype A<T = u32> = Vec<T>;\n\nfn main() {\n    let a: Vec<u32>;\n}\n```\n\n----------------------------------------\n\nTITLE: Standard GPL License Header Template\nDESCRIPTION: Template for the standard GPL license header that should be included at the start of source files, including copyright notice and warranty disclaimer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/LICENSES/GPL-2.0-only.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\none line to give the program's name and an idea of what it does.\nCopyright (C) yyyy  name of author\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n```\n\n----------------------------------------\n\nTITLE: Byte String Literal Error\nDESCRIPTION: This error message indicates that a byte string literal in Rust is missing a closing double quote (\"). The compiler expects all string literals to be properly terminated. Failing to do so results in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_slash_n.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"BYTE_STRING \\\"b\\\\\"\\\\n\" error: Missing trailing `\\\"` symbol to terminate the byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Properly Terminated Multi-line Comments in Rust\nDESCRIPTION: This snippet shows the correct way to terminate both regular and documentation multi-line comments in Rust, avoiding compilation errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0758.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/* I am terminated! */\n/*! I am also terminated! */\n```\n\n----------------------------------------\n\nTITLE: Configuring Inlay Hint Appearance in VS Code (JSON)\nDESCRIPTION: This snippet configures the appearance of inlay hints within the VS Code editor. It allows customization of the font family, font size, foreground color, and background color.  Dependencies include VS Code and the Rust extension for VS Code. The output modifies the editor's display, showing hints with the specified styling.  This configuration is applied via settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"editor.inlayHints.fontFamily\": \"Courier New\",\n  \"editor.inlayHints.fontSize\": 11,\n\n  \"workbench.colorCustomizations\": {\n    // Name of the theme you are currently using\n    \"[Default Dark+]\": {\n      \"editorInlayHint.foreground\": \"#868686f0\",\n      \"editorInlayHint.background\": \"#3d3d3d48\",\n\n      // Overrides for specific kinds of inlay hints\n      \"editorInlayHint.typeForeground\": \"#fdb6fdf0\",\n      \"editorInlayHint.parameterForeground\": \"#fdb6fdf0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0764 Error: Using Mutable Reference in Rust Constant\nDESCRIPTION: This code snippet shows an erroneous attempt to use a mutable reference in a constant, which triggers the E0764 error in Rust. This is not allowed to prevent the creation of constants with mutable values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0764.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    const OH_NO: &'static mut usize = &mut 1; // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Using Private Helper Function in Implementation\nDESCRIPTION: Solution using a private helper function in an impl block to handle generic parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling vectorcall functions in Rust\nDESCRIPTION: This section demonstrates calling various `vectorcall` functions with different argument types, including integers, floats, structs (`S`, `S2`, `S3`) and combinations thereof. The snippet shows how to pass different data structures and primitive types to `vectorcall` functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.msvc.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nvectorcall_fn_1(14)\nvectorcall_fn_2(16, 3.5)\nvectorcall_fn_3(3.5)\nvectorcall_fn_4(1, 2, 3.0)\nvectorcall_fn_5(S { x: 1, y: 2 }, 16)\nvectorcall_fn_6(S { x: 10, y: 12 })\nvectorcall_fn_7(S2 { x: 15, y: 16 }, 3)\nvectorcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\nvectorcall_fn_9(1, 3.0)\nvectorcall_fn_10(19)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Inline Attribute Usage in Rust\nDESCRIPTION: Demonstrates an incorrect usage of the `inline` attribute with an unsupported argument, which triggers a compile-time error E0535\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0535.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[inline(unknown)] // error: invalid argument\npub fn something() {}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Example of an Unterminated Rust Byte String Literal\nDESCRIPTION: This Rust code snippet shows an invalid byte string literal (`b\\\" `) because it lacks the necessary closing double quote (`\"`). Attempting to compile this code results in the error: 'Missing trailing `\"` symbol to terminate the byte string literal'. This highlights a common syntax error when defining byte strings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_space.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nb\\\" \n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for AVR Target\nDESCRIPTION: Cargo configuration file setup for cross-compiling to AVR microcontrollers, specifying target and build parameters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/avr-none.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"avr-none\"\nrustflags = [\"-C\", \"target-cpu=atmega328p\"]\n\n[unstable]\nbuild-std = [\"core\"]\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Diagnostic Output with rustc\nDESCRIPTION: Demonstrates how to use the '--error-format json' flag with Rust compiler to output diagnostics as JSON objects. This format is used by tools like 'cargo fix' to parse compiler errors programmatically.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ rustc json_error_demo.rs --error-format json\n{\"message\":\"cannot add `&str` to `{integer}`\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"json_error_demo.rs\",\"byte_start\":50,\"byte_end\":51,\"line_start\":4,\"line_end\":4,\"column_start\":7,\"column_end\":8,\"is_primary\":true,\"text\":[{\"text\":\"    a + b\",\"highlight_start\":7,\"highlight_end\":8}],\"label\":\"no implementation for `{integer} + &str`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"the trait `std::ops::Add<&str>` is not implemented for `{integer}`\",\"code\":null,\"level\":\"help\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"error[E0277]: cannot add `&str` to `{integer}`\\n --> json_error_demo.rs:4:7\\n  |\\n4 |     a + b\\n  |       ^ no implementation for `{integer} + &str`\\n  |\\n  = help: the trait `std::ops::Add<&str>` is not implemented for `{integer}`\\n\\n\"}\n{\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\\n\\n\"}\n{\"message\":\"For more information about this error, try `rustc --explain E0277`.\",\"code\":null,\"level\":\"\",\"spans\":[],\"children\":[],\"rendered\":\"For more information about this error, try `rustc --explain E0277`.\\n\"}\n```\n\n----------------------------------------\n\nTITLE: Library Linking with Static Archive Modifier\nDESCRIPTION: Example of linking a static library using the whole-archive modifier, which includes all object files from the archive.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-l static:+whole-archive=mylib\n```\n\n----------------------------------------\n\nTITLE: Integrating External Commands for Compiler Feedback (JSON)\nDESCRIPTION: This snippet demonstrates how to integrate an external command, such as `cargo watch`, to provide compiler feedback within VS Code. It defines a VS Code task that runs the specified command in the background and utilizes the `$rustc-watch` problem matcher to parse and display the output as inline error markers.  Requires VS Code, the Rust extension, and cargo watch. The output of the command is parsed to display errors. Task configuration is defined in tasks.json and settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"label\": \"Watch\",\n    \"group\": \"build\",\n    \"type\": \"shell\",\n    \"command\": \"cargo watch\",\n    \"problemMatcher\": \"$rustc-watch\",\n    \"isBackground\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Setting the WASI SDK Path in Shell\nDESCRIPTION: This snippet demonstrates how to set the `WASI_SDK_PATH` environment variable to a specific installation path of `wasi-sdk`. It is a prerequisite step for building the wasm32-wasip1 target as it allows Rust's build system to locate necessary binaries and programs. The example uses a shell command to configure the path to the SDK.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wasip1.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport WASI_SDK_PATH=/path/to/wasi-sdk-22.0\n```\n\n----------------------------------------\n\nTITLE: Setting Runnable Environment Variables in VS Code (JSON)\nDESCRIPTION: This snippet demonstrates how to configure environment variables for runnable commands within the VS Code editor. It allows users to define environment variables that are passed to rust-analyzer during the execution of runnables. Requires VS Code and the Rust extension. The output provides environment variables to run the program, either for all runnables or for specific runnables with masks. These configurations are added within the settings.json file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"rust-analyzer.runnables.extraEnv\": {\n        \"RUN_SLOW_TESTS\": \"1\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Raw String Termination in Rust\nDESCRIPTION: Example of incorrectly terminated raw string where the number of trailing hash symbols doesn't match the leading hash symbols, resulting in compilation error E0748.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0748.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet dolphins = r##\"Dolphins!\"#; // error!\n```\n\n----------------------------------------\n\nTITLE: Function with Higher-Ranked Lifetime Bounds\nDESCRIPTION: Example showing nested universe creation with multiple for-bound lifetimes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn bar<'a, T>(t: &'a T) {\n    let x: for<'b> fn(&'b u32) = ...;\n    let y: for<'c> fn(&'c u32) = ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Custom Compiler Arguments\nDESCRIPTION: This command allows passing additional arguments to the compiler when running tests, useful in specific scenarios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n./x test --compiletest-rustc-args <additional_args>\n```\n\n----------------------------------------\n\nTITLE: Creating Git Worktree for Multiple Branch Development\nDESCRIPTION: Git commands to create linked working trees for parallel development on multiple branches.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit worktree add ../rust2\ngit worktree add -b my-feature ../rust2 master\n```\n\n----------------------------------------\n\nTITLE: Moving Match Guard to Arm Body in Rust\nDESCRIPTION: Transforms a match guard condition into a conditional statement within the match arm body. This refactoring can improve readability in certain cases by separating pattern matching from conditional logic.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_88\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } if distance > 10 => foo(),\n        _ => (),\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } => if distance > 10 {\n            foo()\n        },\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Travis CI Configuration for Rustfmt\nDESCRIPTION: Example Travis CI configuration to enforce code formatting in continuous integration. Requires Rust 1.31.0 or greater.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/README.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nlanguage: rust\nbefore_script:\n- rustup component add rustfmt\nscript:\n- cargo build\n- cargo test\n- cargo fmt --all -- --check\n```\n\n----------------------------------------\n\nTITLE: Setting Up Rust Toolchain for Miri\nDESCRIPTION: This snippet explains how to install the exact version of rustc that Miri requires using rustup. It sets up a toolchain called 'miri' as an override for the current directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./miri toolchain\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom rust-analyzer Server Path in VS Code (JSON)\nDESCRIPTION: Specifies a custom path to the rust-analyzer server executable within VS Code's `settings.json`. This is necessary when installing `rust-analyzer-no-server.vsix` and providing a separately compiled or downloaded server binary, often used on unsupported platforms or for custom builds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.server.path\": \"~/.local/bin/rust-analyzer-linux\"\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Rust Foreign Function Declaration with Pattern in Argument (E0130)\nDESCRIPTION: This code snippet demonstrates an incorrect way of declaring a foreign function in Rust where a pattern is used directly in the function parameter list, which is invalid and causes error E0130. It highlights the syntax mistake of attempting to destructure a tuple pattern directly in an external function declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0130.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"C\" {\n    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n                                //        function declarations\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Transparent Struct Definition in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of a transparent struct with multiple non-zero-sized fields, resulting in error E0690.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0690.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\nstruct LengthWithUnit<U> { // error: transparent struct needs at most one\n    value: f32,            //        non-zero-sized field, but has 2\n    unit: U,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Compiler Flags for Arm Target\nDESCRIPTION: Example configuration for Cargo to set target CPU, target features, and linker settings for an Arm bare-metal target\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm-none-eabi.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nrustflags = [\n  \"-Clink-arg=-Tlink.x\",\n  \"-Clink-arg=--nmagic\",\n  \"-Ctarget-cpu=cortex-m55\",\n  \"-Ctarget-feature=-mve.fp\"\n]\n\n[build]\ntarget = \"thumbv8m.main-none-eabihf\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Enum with Discriminants in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of an enum with discriminants. It fails to compile because it lacks the required #[repr(inttype)] attribute for enums with non-unit variants or mixed unit and non-unit variants with discriminants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0732.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum { // error!\n    Unit = 1,\n    Tuple() = 2,\n    Struct{} = 3,\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: @rustbot Issue Relabeling Command - Markdown\nDESCRIPTION: Here is the command to relabel an issue or PR using @rustbot. This allows contributors to update the labels indicating the status after performing specific actions such as rebasing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustbot.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot label -S-waiting-on-author +S-waiting-on-review\n```\n\n----------------------------------------\n\nTITLE: Comment Wrapping Default Example in Rust\nDESCRIPTION: Shows default comment formatting behavior when wrap_comments is false.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_83\n\nLANGUAGE: rust\nCODE:\n```\n// Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n// sed do eiusmod tempor incididunt ut labore et dolore\n// magna aliqua. Ut enim ad minim veniam, quis nostrud\n// exercitation ullamco laboris nisi ut aliquip ex ea\n// commodo consequat.\n\n// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\n// Information on the lorem ipsum can be found at the following url: https://en.wikipedia.org/wiki/Lorem_ipsum. Its text is: lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\n/// # This doc comment is a very long header (it starts with a '#'). Had it not been a header it would have been wrapped. But because it is a header, it will not be. That is because wrapping a markdown header breaks it.\nstruct Foo {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference Error in Async Rust Functions\nDESCRIPTION: This code snippet shows an erroneous example where the type variable T in an async function is not bound, causing a compiler error. The compiler cannot infer the type for T, making it impossible to construct the coroutine.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0698.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn bar<T>() -> () {}\n\nasync fn foo() {\n    bar().await; // error: cannot infer type for `T`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring enforce-iter-loop-reborrow\nDESCRIPTION: Configures whether to recommend using implicit `into_iter` for reborrowed values in loop. The example shows the change. The default is false.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: Installing LLVM Tools for PGO in Rust\nDESCRIPTION: Command to install the llvm-tools-preview component using rustup, which provides the llvm-profdata tool required for processing profile data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/profile-guided-optimization.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup component add llvm-tools-preview\n```\n\n----------------------------------------\n\nTITLE: Compiling Multi-file Rust Program\nDESCRIPTION: Command showing how to compile a multi-file Rust program by only specifying the crate root\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc main.rs\n```\n\n----------------------------------------\n\nTITLE: Casting Pointers with Inferred Types - Rust\nDESCRIPTION: The following snippet shows correct ways to cast integers to pointer types in Rust, utilizing explicit type annotations to avoid errors. Annotations help Rust understand the expected pointer type during casting. It demonstrates creation of pointers from references and integer values with explicit type information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0641.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet a = &(String::from(\"Hello world!\")) as *const _; // ok!\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet b = 0 as *const i32; // ok!\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet c: *const i32 = 0 as *const _; // ok!\n```\n\n----------------------------------------\n\nTITLE: Generating Rustdoc Example in Rust\nDESCRIPTION: This snippet demonstrates how to generate a rustdoc example when editing an item's documentation. It adds a complete example template including the use statement and an assert_eq! macro call.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_46\n\nLANGUAGE: rust\nCODE:\n```\n/// Adds two numbers.\npub fn add(a: i32, b: i32) -> i32 { a + b }\n```\n\nLANGUAGE: rust\nCODE:\n```\n/// Adds two numbers.\n///\n/// # Examples\n///\n/// ```\n/// use ra_test_fixture::add;\n///\n/// assert_eq!(add(a, b), );\n/// ```\npub fn add(a: i32, b: i32) -> i32 { a + b }\n```\n\n----------------------------------------\n\nTITLE: Replacing Arithmetic with Checked Operations in Rust\nDESCRIPTION: Replaces basic arithmetic operations on integers with their checked equivalents that return None on overflow. This refactoring improves safety by converting potentially overflowing operations to methods that handle overflow gracefully.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_105\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1 + 2;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let x = 1.checked_add(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating IndexMut Implementation from Index in Rust\nDESCRIPTION: This snippet demonstrates how to generate an IndexMut implementation based on an existing Index trait implementation. It creates a new impl block with the index_mut method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_60\n\nLANGUAGE: rust\nCODE:\n```\npub enum Axis { X = 0, Y = 1, Z = 2 }\n\nimpl<T> core::ops::Index<Axis> for [T; 3] {\n    type Output = T;\n\n    fn index(&self, index: Axis) -> &Self::Output {\n        &self[index as usize]\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub enum Axis { X = 0, Y = 1, Z = 2 }\n\nimpl<T> core::ops::IndexMut<Axis> for [T; 3] {\n    fn index_mut(&mut self, index: Axis) -> &mut Self::Output {\n        &self[index as usize]\n    }\n}\n\nimpl<T> core::ops::Index<Axis> for [T; 3] {\n    type Output = T;\n\n    fn index(&self, index: Axis) -> &Self::Output {\n        &self[index as usize]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote (SSH) in Git\nDESCRIPTION: Adds a remote named 'upstream' pointing to the official rust-lang/rust repository using the SSH protocol. This allows fetching updates directly from the main repository, typically used when authenticated via SSH keys.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngit remote add upstream git@github.com:rust-lang/rust.git\n```\n\n----------------------------------------\n\nTITLE: Declaring Enum in Rust\nDESCRIPTION: The snippet declares an enum named 'Enum' with its definition and source location, critical for structuring data types in Rust. It operates under module conventions, impacting how enums are constructed and referenced in the code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"Enum\",\n    def: Adt(\n        Enum(\n            Enum {\n                id: EnumId(\n                    0,\n                ),\n            },\n        ),\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: ENUM,\n            range: 185..207,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 190..194,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Info Type Line Numbers in Rust\nDESCRIPTION: Markdown documentation explaining a compiler option that enables additional type and line number information in debug info. The option enhances debugger capabilities but may impact compilation performance.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/debug_info_type_line_numbers.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `debug-info-type-line-numbers`\n\n---\n\nThis option causes additional type and line information to be emitted in debug\ninfo to provide richer information to debuggers. This is currently off by\ndefault as it causes some compilation scenarios to be noticeably slower.\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_8 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_8` function with two `S3` structs as arguments. Each `S3` contains an array of integers. It demonstrates passing structs with array members via the `fastcall` calling convention.  The definition of `fastcall_fn_8` determines the behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n```\n\n----------------------------------------\n\nTITLE: Identifying Missing Trailing Quote in Rust String Literal\nDESCRIPTION: This code snippet implicitly demonstrates a Rust compiler error caused by a missing trailing double quote character (\"). This error occurs when the string literal is not properly closed. The output indicates the error message, identifying the location in the source code where the error occurs. To resolve this, ensure the string literal is properly terminated with a closing double quote. There are no specific dependencies for this particular error as it's a syntax issue within the string definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_string_with_space.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSTRING \\\" \\\" error: Missing trailing `\"` symbol to terminate the string literal\n```\n\n----------------------------------------\n\nTITLE: Markdown for Invisible Date Annotation\nDESCRIPTION: This snippet illustrates how to insert a date check annotation that does not appear in the rendered output. This allows maintaining context without displaying excessive information to the user.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- date-check: Apr 2025 -->\n```\n\n----------------------------------------\n\nTITLE: Fixing Match Arm Braces in Rust\nDESCRIPTION: This code snippet demonstrates a fix where rustfmt previously removed braces in match arms when the block had a labeled break statement. The fix ensures that the braces are preserved, maintaining the code's intended behavior. This correction addresses a specific formatting issue in Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    match true {\n        true => 'a: {\n            break 'a\n        }\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling Cargo with perf\nDESCRIPTION: Example of profiling cargo using a specific toolchain with perf. This captures performance data for cargo rustc executions at 99 Hz sampling rate with call graph information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nperf record -F99 --call-graph dwarf cargo +<toolchain> rustc\n```\n\n----------------------------------------\n\nTITLE: Understanding Variables from Binders Syntax in Rust Compiler\nDESCRIPTION: Explains the syntax for variables from binders in the Rust compiler's internal representation. The format is ^{binder}_{index}, where binder and index identify which variable from which binder is being referred to.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n^0_x\n```\n\nLANGUAGE: rust\nCODE:\n```\n^0_2\n```\n\n----------------------------------------\n\nTITLE: Correctly Defining Recursive Type in Rust Using Box\nDESCRIPTION: This code snippet shows the correct way to define a recursive type in Rust by using Box<T> for indirection, allowing the compiler to determine the type's size.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0072.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct ListNode {\n    head: u8,\n    tail: Option<Box<ListNode>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating E0373 Error in Rust Thread Spawning\nDESCRIPTION: This example demonstrates the E0373 error occurring when attempting to use captured variables in a closure passed to a new thread.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0373.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Associated Type Normalization with Cycles\nDESCRIPTION: Example of a case where naive coinduction would allow unsound normalization of associated types, requiring special handling for 'normalizes_to' goals.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    type Assoc;\n}\n\nimpl Trait for () {\n    type Assoc = <() as Trait>::Assoc;\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Associated Type with Lifetime Parameter\nDESCRIPTION: Illustrates a compilation error when using an associated type with a lifetime parameter where the lifetime usage is not guaranteed\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0582.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type Assoc<'a>;\n}\n\nstruct Bar<X, F>\nwhere\n    X: Foo,\n    F: for<'a> Fn(X::Assoc<'a>) -> &'a i32\n{\n    x: X,\n    f: F\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Inline Attribute Width in Rust\nDESCRIPTION: Demonstrates how setting inline_attribute_width to 50 allows attributes and their items to appear on the same line if their combined width fits within the limit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"alloc\")] use core::slice;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Provider Function in Rust Compiler\nDESCRIPTION: Shows how to implement a provide() function that registers query providers with the compiler. This function modifies a Providers struct by assigning specific provider implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub fn provide(providers: &mut Providers) {\n    *providers = Providers {\n        type_of,\n        ..*providers\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Static Method in Trait Making it Non-dyn-compatible in Rust\nDESCRIPTION: Demonstrates a trait with a static method (no self receiver) that makes the trait non-dyn-compatible because there's no way to call such methods through a trait object.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\n----------------------------------------\n\nTITLE: Building remote-test-server for RISC-V\nDESCRIPTION: This command builds the `remote-test-server` tool for the RISC-V architecture. The resulting binary will be located in the `./build/host/stage2-tools/$TARGET_ARCH/release/` directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n\n./x build src/tools/remote-test-server --target riscv64gc-unknown-linux-gnu\n\n```\n\n----------------------------------------\n\nTITLE: Using Partial Generic Type Parameter in Rust's collect() Method\nDESCRIPTION: This example shows how to use a partial generic type parameter, allowing the compiler to infer the rest of the type in the collect() method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0283.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Pattern Binding in Rust\nDESCRIPTION: Shows an erroneous code example where the identifier 'x' is bound twice in the same pattern, causing compile error E0416.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0416.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch (1, 2) {\n    (x, x) => {} // error: identifier `x` is bound more than once in the\n                 //        same pattern\n}\n```\n\n----------------------------------------\n\nTITLE: Finding libgccjit Path for Configuration\nDESCRIPTION: Command to find the path to the libgccjit shared library, which is needed for the config.toml file to correctly link the Rust codegen backend with the GCC installation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ dirname $(readlink -f `find . -name libgccjit.so`)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Default Trait Derivation for Rust Enum\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to derive the Default trait for a Rust enum without specifying a default variant. This will result in a compilation error (E0665).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0665.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Default)]\nenum Food {\n    Sweet,\n    Salty,\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Main Function Declaration in Rust\nDESCRIPTION: This example shows the correct way to declare a main function in Rust without the async keyword, allowing it to serve as the program entry point properly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0752.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), ()> { // ok!\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Universal Function Call Syntax to Method Call in Rust\nDESCRIPTION: Transforms a universal function call syntax (UFCS) into a method call syntax. This refactoring also adds the necessary import statement for the trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_113\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    std::ops::Add::add(1, 2);\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\n\nfn main() {\n    1.add(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Self Keyword in Rust\nDESCRIPTION: An example of erroneous code where the 'Self' keyword is used outside of an impl, trait, or type definition, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0411.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncompile_fail,E0411\n<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n             // definition\n```\n\n----------------------------------------\n\nTITLE: Displaying Rustdoc Version\nDESCRIPTION: This code snippet demonstrates how to use the `-V` or `--version` flag to display the rustdoc version. This can be useful for identifying the rustdoc version being used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc -V\n$ rustdoc --version\n```\n\n----------------------------------------\n\nTITLE: Example of Trait with Lifetime Parameter in Rust\nDESCRIPTION: Demonstrates how trait objects can hold internal data with lifetimes through a simple example using MyTrait and MyStruct.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0772.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {}\n\nstruct MyStruct<'a>(&'a i32);\n\nimpl<'a> MyTrait for MyStruct<'a> {}\n```\n\n----------------------------------------\n\nTITLE: Module Value Access Error\nDESCRIPTION: Demonstrates incorrect module member access syntax that results in E0423 error when trying to access a constant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0423.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub mod a {\n    pub const I: i32 = 1;\n}\n\nfn h1() -> i32 {\n    a.I\n    //~^ ERROR expected value, found module `a`\n    // did you mean `a::I`?\n}\n```\n\n----------------------------------------\n\nTITLE: JIT Mode Execution with Rustc-Clif\nDESCRIPTION: Command to execute Rust code immediately using JIT mode through direct rustc invocation with specific compiler flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/usage.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ $cg_clif_dir/dist/rustc-clif -Cllvm-args=jit-mode -Cprefer-dynamic my_crate.rs\n```\n\n----------------------------------------\n\nTITLE: Cherry-Picking LLVM Commits with Git\nDESCRIPTION: Applies a specific commit from the upstream LLVM repository to the current branch, incorporating the fix into the Rust fork, along with information about where the commit originated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/updating-llvm.md#2025-04-21_snippet_1\n\nLANGUAGE: git\nCODE:\n```\n\"git cherry-pick -x\"\n```\n\n----------------------------------------\n\nTITLE: Prolog Predicate for Well-Formed Type-Checking - Text\nDESCRIPTION: This snippet defines a Prolog predicate that outlines the conditions necessary for `bar()` to be considered well-formed based on type equality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nbarWellFormed(?U) :- Eq(?U, ?U).\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested Path Symbol Mangling in Rust\nDESCRIPTION: Illustrates how closures are mangled as nested paths, including namespace, parent path, and disambiguators for multiple closures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = || {};\n    let y = || {};\n    x();\n    y();\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNCNvCsgStHSCytQ6I_7mycrate4main0B3_\n  ││└─────────────┬─────────────┘│\n  ││              │              │\n  ││              │              └── identifier with length 0\n  ││              └───────────────── path to \"mycrate::main\"\n  │└──────────────────────────────── closure namespace\n  └───────────────────────────────── nested-path\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNCNvCsgStHSCytQ6I_7mycrate4mains_0B3_\n                                 ││\n                                 │└── base-62-number 0\n                                 └─── disambiguator 1 (base-62-number+1)\n```\n\n----------------------------------------\n\nTITLE: Generated TestDescAndFn Structure\nDESCRIPTION: Shows the complete test configuration structure generated by the compiler for each test function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nself::test::TestDescAndFn{\n  desc: self::test::TestDesc{\n    name: self::test::StaticTestName(\"foo\"),\n    ignore: false,\n    should_panic: self::test::ShouldPanic::Yes,\n    allow_fail: false,\n  },\n  testfn: self::test::StaticTestFn(||\n    self::test::assert_test_result(::crate::__test_reexports::foo())),\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Personality Functions in Assembly Dump with Rust\nDESCRIPTION: Command to view personality functions in the assembly dump by passing specific arguments to the linker during the Rust build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tips.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nCG_RUSTFLAGS=\"-Clink-arg=-save-temps -v -Clink-arg=-dA\" ../y.sh cargo build\n```\n\n----------------------------------------\n\nTITLE: Interactive Program License Notice Template\nDESCRIPTION: Template for the short license notice that should be displayed when interactive programs start up.\nSOURCE: https://github.com/rust-lang/rust/blob/master/LICENSES/GPL-2.0-only.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nGnomovision version 69, Copyright (C) year name of author\nGnomovision comes with ABSOLUTELY NO WARRANTY; for details\ntype `show w'.  This is free software, and you are welcome\nto redistribute it under certain conditions; type `show c' \nfor details.\n```\n\n----------------------------------------\n\nTITLE: Referencing C Unsigned Char Type in Rust\nDESCRIPTION: Documentation reference showing the relationship between Rust's u8 type and C's unsigned char type. This type is guaranteed to be u8 sized and is included for C compatibility and type mapping completeness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/c_uchar.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nc_char\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Restricting Trait Visibility\nDESCRIPTION: Shows how to fix the privacy error by limiting the trait's visibility to the crate level, where the private type is accessible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0446.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\npub(crate) trait PubTr { // only public to crate root\n    type Alias;\n}\n\nimpl PubTr for u8 {\n    type Alias = Bar;\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic MIR Pass in Rust\nDESCRIPTION: Example of defining a basic MIR pass called RemoveStorageMarkers. This pass walks the MIR and removes all storage marks if they won't be emitted during codegen.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/passes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct RemoveStorageMarkers;\n```\n\n----------------------------------------\n\nTITLE: Compiler Extern Command Example\nDESCRIPTION: Demonstrates the resulting compiler extern command format when Cargo invokes the compiler, showing how the package is referenced as 'core' in the compiled output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/rustc-std-workspace-core/README.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n--extern core=.../librustc_std_workspace_core-XXXXXXX.rlib\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Deprecated Attribute in Rust\nDESCRIPTION: This snippet provides a correct example of using the `deprecated` attribute with a single note on a Rust function. It illustrates the appropriate way to deprecate a function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0550.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated(note = \\\"because why not, right?\\\")]\nfn the_banished() {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Fixing Code to Comply with Lint Check in Rust\nDESCRIPTION: Shows how to modify the code to pass the lint check by following the snake_case naming convention, eliminating the need for lint check attributes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0453.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![forbid(non_snake_case)]\n\nfn main() {\n    let my_number = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Object Declaration in Rust\nDESCRIPTION: Demonstrates an erroneous trait object declaration that causes compiler error E0224. The code attempts to declare a trait object without specifying any traits after the '+' operator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0224.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo = dyn 'static +;\n```\n\n----------------------------------------\n\nTITLE: LLVM Reduction Test Script\nDESCRIPTION: Bash script for testing LLVM IR reduction with specific error matching\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/debugging.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n<path/to/your/opt> $1 -load-pass-plugin=/path/to/llvmenzyme-19.so -passes=\"enzyme\" \\\n    |& grep \"/some/path.cpp:686: void llvm::callinst::init\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Implementation on Primitive Type in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to implement methods directly on a primitive type (*mut Foo), which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0390.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    x: i32\n}\n\nimpl *mut Foo {}\n// error: cannot define inherent `impl` for primitive types\n```\n\n----------------------------------------\n\nTITLE: Setting HTML logo in Rust Documentation\nDESCRIPTION: This code snippet specifies a logo image to be displayed in the upper left of Rust documentation pages using the #[doc] attribute.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(html_logo_url = \\\"https://example.com/logo.jpg\\\")]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Running Rustfmt from Source\nDESCRIPTION: This command runs rustfmt on a specified file from its source code. It's useful for testing changes or debugging, although direct installation from source is discouraged.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ncargo run --bin rustfmt -- path/to/file.rs\n```\n\n----------------------------------------\n\nTITLE: Linking Rust Toolchain through Cargo\nDESCRIPTION: This snippet shows how to link the Rust toolchain to allow usage through Cargo, enabling the use of experimental features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain link enzyme build/host/stage1\nrustup toolchain install nightly # enables -Z unstable-options\n```\n\n----------------------------------------\n\nTITLE: Using Interior Mutability with Cell in Rust\nDESCRIPTION: This snippet shows an alternative solution using interior mutability with the Cell type, allowing mutation of data within an immutable container.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0386.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\nlet x: i64 = 1;\nlet y: Box<Cell<_>> = Box::new(Cell::new(x));\ny.set(2);\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Assembly Template Pieces in Rust\nDESCRIPTION: Enum representing template pieces for inline assembly, with support for string literals and operand placeholders. Used to parse and represent assembly template strings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/asm.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum InlineAsmTemplatePiece {\n    String(String),\n    Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Type with Type Parameters in Rust\nDESCRIPTION: This snippet demonstrates how to correctly and incorrectly define an opaque type with type parameters in Rust. The first function showcases a valid definition with a type parameter, while the second function shows an invalid definition using a non-type parameter, leading to ambiguity in interpreting the hidden type. Dependencies include understanding of Rust generics and type inference rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<X> = impl Sized;\n\n// `T` is a type parameter.\n// Opaque<T> := ();\nfn good<T>() -> Opaque<T> {}\n\n// `()` is not a type parameter.\n// Opaque<()> := ();\nfn bad() -> Opaque<()> {} //~ ERROR\n\n```\n\n----------------------------------------\n\nTITLE: Fixing Enum Overflow by Explicit Value Assignment\nDESCRIPTION: Solution showing how to fix the overflow by explicitly setting the second enum variant value instead of relying on automatic increment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0370.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(i64)]\nenum Foo {\n    X = 0x7fffffffffffffff,\n    Y = 0, // ok!\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Negative Trait Implementation Example in Rust\nDESCRIPTION: Demonstrates incorrect usage of negative trait implementation by attempting to add an associated type to a negative impl, which results in error E0749.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0749.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![feature(negative_impls)]\ntrait MyTrait {\n    type Foo;\n}\n\nimpl !MyTrait for u32 {\n    type Foo = i32; // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Checking Non-Generic Function - Rust\nDESCRIPTION: This snippet illustrates a simple function in Rust, `foo()`, which calls another function `bar()`, representing type-checking through a well-formed predicate.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/lowering-to-logic.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() { bar::<usize>() }\nfn bar<U: Eq<U>>() { }\n```\n\n----------------------------------------\n\nTITLE: Valid Primitive Type Casting\nDESCRIPTION: Shows correct type casting between numeric primitives and pointer types, demonstrating Rust's allowed casting operations for primitive types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0605.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 0u8;\nx as u32; // ok!\n\nlet v = core::ptr::null::<u8>();\nv as *const i8; // ok!\n```\n\n----------------------------------------\n\nTITLE: Using Control Flow Constructs in Rust\nDESCRIPTION: Illustrates the preference for using control flow constructs like 'if' instead of functional combinators like 'Option::filter' when it improves readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nif !x.cond() {\n    return None;\n}\nSome(x)\n\n// BAD\nSome(x).filter(|it| it.cond())\n```\n\n----------------------------------------\n\nTITLE: Exported Variable with Value 42 in Rust\nDESCRIPTION: Declares a public variable with the value 42. It is meant to be accessible outside the module or crate, serving as a constant or configuration value within the Rust project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-link-ordinal/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nexported_variable value: 42\n```\n\n----------------------------------------\n\nTITLE: Enabling Target in Rust Build Configuration\nDESCRIPTION: This snippet shows how to specify the powerpc64le target in the `rustc` build configuration using a TOML file. The target is set up to be recognized during the build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64le-unknown-linux-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"powerpc64le-unknown-linux-gnu\"]\n```\n\n----------------------------------------\n\nTITLE: Converting a Raw String to a Regular String in Rust\nDESCRIPTION: Shows converting a raw string literal back to a regular string with appropriate escape sequences. This ensures proper escaping of special characters like quotes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_79\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r#\"Hello,┃ \"World!\"\"#;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    \"Hello, \\\"World!\\\"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring disallowed-types\nDESCRIPTION: Specifies a list of disallowed types, written as fully qualified paths. Defaults to an empty list (`[]`).  Allows you to enforce type restrictions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Correct Usage of #[main] Attribute in Rust\nDESCRIPTION: This code snippet demonstrates the correct usage of the #[main] attribute, where only one function is marked as the main entry point of the program.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0137.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(main)]\n\n#[main]\nfn f() {} // ok!\n```\n\n----------------------------------------\n\nTITLE: Defining Erroneous Recursive Type in Rust\nDESCRIPTION: This code snippet demonstrates an incorrect way to define a recursive type in Rust, resulting in an E0072 error due to infinite size.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0072.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct ListNode {\n    head: u8,\n    tail: Option<ListNode>, // error: no indirection here so impossible to\n                            //        compute the type's size\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Struct with ADT\nDESCRIPTION: Demonstrates a generic struct definition that can be used with different type parameters. Shows how a struct like MyStruct can be parameterized with a generic type T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/generic_arguments.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct<T> { x: u8, y: T }\n```\n\n----------------------------------------\n\nTITLE: Validating Rust Lifetime Identifier Syntax\nDESCRIPTION: Highlights compilation errors when defining lifetime identifiers that do not conform to Rust's naming conventions, specifically preventing identifiers from beginning with numeric characters\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/lifetime_starts_with_a_number.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n'1\n```\n\nLANGUAGE: rust\nCODE:\n```\n'1lifetime\n```\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer using rustup\nDESCRIPTION: This snippet shows how to install rust-analyzer as a rustup component. This method is available for users who manage their Rust installation through rustup.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/rust_analyzer_binary.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ rustup component add rust-analyzer\n```\n\n----------------------------------------\n\nTITLE: Correct Type Alias Declarations in Rust\nDESCRIPTION: Examples of properly declared type aliases in Rust, showing how to declare a type alias either without any type parameters or with all type parameters being used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0091.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo = u32; // ok!\ntype Foo2<A> = Box<A>; // ok!\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Usage in Trait Position\nDESCRIPTION: Demonstrates incorrect usage of a struct type Foo in positions where a trait is required, resulting in compilation error E0404.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0404.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nstruct Bar;\n\nimpl Foo for Bar {} // error: `Foo` is not a trait\nfn baz<T: Foo>(t: T) {} // error: `Foo` is not a trait\n```\n\n----------------------------------------\n\nTITLE: Creating Fuchsia Package Manifest for Cargo\nDESCRIPTION: Manifest file specifying package contents for a Cargo-built Rust project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_10\n\nLANGUAGE: txt\nCODE:\n```\nbin/hello_fuchsia=target/x86_64-unknown-fuchsia/debug/hello_fuchsia\nlib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\nlib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\nmeta/package=pkg/meta/package\nmeta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm\n```\n\n----------------------------------------\n\nTITLE: Nested If Statement Pattern Matching\nDESCRIPTION: Simplified version of collapsible_if lint showing complex nested pattern matching\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nif let ast::ExprKind::If(check, then, None) = &expr.node {\n    if then.stmts.len() == 1 {\n        if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node {\n            if let ast::ExprKind::If(check_inner, content, None) = &inner.node {\n                ...\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Built-in Attribute Example\nDESCRIPTION: Shows examples of built-in attributes that are defined in the compiler itself and are always in scope. These attributes cannot be renamed and are processed directly by the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[allow]\n#[macro_use]\n```\n\n----------------------------------------\n\nTITLE: Testing with Hello World\nDESCRIPTION: Command to verify that the rustc_codegen_gcc setup is working correctly by building a simple Hello World test program.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh cargo build --manifest-path tests/hello-world/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Correct Raw String Termination in Rust\nDESCRIPTION: Example of correctly terminated raw string where the number of hash symbols matches at both the beginning and end of the string literal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0748.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet dolphins = r#\"Dolphins!\"#; // One `#` at the beginning, one at the end so\n                               // all good!\n```\n\n----------------------------------------\n\nTITLE: Notifying Unused Dependencies in JavaScript\nDESCRIPTION: This snippet details the JSON structure used when emitting warnings for unused crate dependencies via the `--json=unused-externs` and `--json=unused-externs-silent` flags. It includes the lint level for the warning and an array of unused crate names. This structure aids in notifying users about dependencies that can be removed from their `Cargo.toml` files. Dependencies involve integration with Rust's linting systems.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/json.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    \"lint_level\": \"deny\", /* Level of the warning */\n    \"unused_names\": [\n        \"foo\"  /* Names of unused crates, as specified with --extern foo=libfoo.rlib */\n    ],\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Named Struct to Tuple Struct in Rust\nDESCRIPTION: Changes a struct with named fields to a tuple struct, including modifications to associated methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point(f32, f32);\n\nimpl Point {\n    pub fn new(x: f32, y: f32) -> Self {\n        Point(x, y)\n    }\n\n    pub fn x(&self) -> f32 {\n        self.0\n    }\n\n    pub fn y(&self) -> f32 {\n        self.1\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: @rustbot Release Assignment Command - Markdown\nDESCRIPTION: This snippet provides the command to release an assignment from an issue. Contributors can unassign themselves from an issue using this command.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustbot.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot release-assignment\n```\n\n----------------------------------------\n\nTITLE: Formatting Single-Line If-Else Expressions in Rust\nDESCRIPTION: Guidelines for using single-line formatting for if-else expressions in Rust. This is only appropriate for small expressions in expression context with a single else clause.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet y = if x { 0 } else { 1 };\n\n// Examples that must be multi-line.\nlet y = if something_very_long {\n    not_small\n} else {\n    also_not_small\n};\n\nif x {\n    0\n} else {\n    1\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Unsafe Negative Implementation Example - Rust\nDESCRIPTION: Demonstrates an erroneous attempt to create an unsafe negative implementation of the Clone trait. This code fails to compile because negative implementations are inherently safe and should not be marked as unsafe.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0198.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nunsafe impl !Clone for Foo { } // error!\n```\n\n----------------------------------------\n\nTITLE: Converting Associated Constants to Methods for dyn-compatibility in Rust\nDESCRIPTION: Shows how to work around the associated constant restriction by using a method instead, which makes the trait dyn-compatible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Windows Dependencies with Winget\nDESCRIPTION: Commands for installing required dependencies on Windows using the winget package manager.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\nwinget install -e Python.Python.3\nwinget install -e Kitware.CMake\nwinget install -e Git.Git\n```\n\n----------------------------------------\n\nTITLE: Linking to Example Pull Request in Markdown\nDESCRIPTION: This snippet demonstrates how to create a Markdown link to an example pull request for joining the ARM group. It uses a reference-style link format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/arm.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n[eg]: https://github.com/rust-lang/team/pull/358\n```\n\n----------------------------------------\n\nTITLE: Implementing CoerceUnsized in Rust\nDESCRIPTION: This snippet outlines the types that implement the CoerceUnsized trait in Rust. The trait is intended for smart pointers to allow the pointed data to be unsized.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/unsize.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nSome implementors of `CoerceUnsized` include:\n* `&T`\n* `Arc<T>`\n* `Box<T>`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Duplicate Discriminant Error in Rust Enum\nDESCRIPTION: This code snippet shows an erroneous enum definition where two variants (P and X) are assigned the same discriminant value (3), which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0081.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Enum {\n    P = 3,\n    X = 3, // error!\n    Y = 5,\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Type Checking Implementation\nDESCRIPTION: Example of checking if an expression's type is a struct using pattern matching\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl LateLintPass<'_> for MyStructLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n        // Get type of `expr`\n        let ty = cx.typeck_results().expr_ty(expr);\n        // Match its kind to enter the type\n        match ty.kind() {\n            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n            _ => ()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation of Unsafe Trait in Rust\nDESCRIPTION: This code snippet demonstrates an erroneous implementation of an unsafe trait without marking the implementation as unsafe. This will result in a compilation error (E0200).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0200.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nunsafe trait Bar { }\n\nimpl Bar for Foo { } // error!\n```\n\n----------------------------------------\n\nTITLE: Comparing Rust Compiler Benchmark Results\nDESCRIPTION: Illustrates how to compare benchmark results of two compiler versions using their respective IDs with the 'compare' subcommand of 'x perf'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./x perf compare <baseline> <modified>\n```\n\n----------------------------------------\n\nTITLE: Try Shorthand Default Example in Rust\nDESCRIPTION: Shows the default formatting behavior for try! macro usage when use_try_shorthand is set to false.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_78\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = ipsum.map(|dolor| dolor.sit())?;\n\n    let lorem = try!(ipsum.map(|dolor| dolor.sit()));\n}\n```\n\n----------------------------------------\n\nTITLE: Moving a Condition from a Match Arm Body to a Guard in Rust\nDESCRIPTION: Demonstrates refactoring a match arm by moving an if condition from the arm body into a match guard. This creates more concise and idiomatic match expressions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_83\n\n\n\n----------------------------------------\n\nTITLE: Running Tests with Miri\nDESCRIPTION: This command runs specific test files using the Miri executable, emphasizing the ability to specify target architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n./miri run tests/pass/format.rs\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./miri run tests/pass/hello.rs --target i686-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Running Tests Manually\nDESCRIPTION: Commands to manually run rust tests using the rustc compiler, which can be faster but may not handle all scenarios correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nrustc +stage1 tests/ui/issue-1234.rs\n```\n\n----------------------------------------\n\nTITLE: Correct Variadic Parameter Usage in C FFI\nDESCRIPTION: Demonstrates the proper way to use variadic parameters in Rust by declaring them within an extern \"C\" block for C ABI compatibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0045.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" {\n    fn foo (x: u8, ...);\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern with Inline If Clause - Rust\nDESCRIPTION: Shows formatting for a multi-line pattern where the if clause remains on the same line as the last pattern element.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n    Token::Dimension {\n         value,\n         ref unit,\n         ...\n    } if num_context.is_ok(context.parsing_mode, value) => {\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Invalid Left-Hand Side Assignment in Rust\nDESCRIPTION: An example of invalid code that triggers E0067 because a literal value (12) cannot be the target of an assignment operation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0067.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n12 += 1; // error!\n```\n\n----------------------------------------\n\nTITLE: Creating a New Cargo Project for Documentation Generation\nDESCRIPTION: This snippet demonstrates how to create a new library project using Cargo and navigate into it.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo new docs --lib\n$ cd docs\n```\n\n----------------------------------------\n\nTITLE: Invalid Boolean Casting Example in Rust\nDESCRIPTION: Demonstrates incorrect attempt to cast a numeric value directly to a boolean type, which will fail with error E0054.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0054.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n\n// Not allowed, won't compile\nlet x_is_nonzero = x as bool;\n```\n\n----------------------------------------\n\nTITLE: Example Macro Rules Definition\nDESCRIPTION: Shows a macro_rules definition and usage example demonstrating context differences in expanded code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! m {\n    ($a:expr, $b:expr) => {\n        if $a.is_some() {\n            $b;\n        }\n    }\n}\n\nlet x: Option<u32> = Some(42);\nm!(x, x.unwrap());\n```\n\n----------------------------------------\n\nTITLE: Adding Hash to Raw String Literals in Rust\nDESCRIPTION: This assist adds a hash to a raw string literal. It increases the number of hash symbols, allowing for more flexibility in the string content.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r#\"Hello, World!\"#;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r##\"Hello, World!\"##;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Macro Import at Crate Root (Rust)\nDESCRIPTION: Example showing the correct way to import macros at the crate root level, allowing them to be used throughout the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0468.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_use(debug_assert)] // ok!\nextern crate core;\n\nmod foo {\n    fn run_macro() { debug_assert!(true); }\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid ABI Usage in Rust\nDESCRIPTION: This code snippet shows an example of using an invalid ABI 'invalid' in an external function declaration, which results in a compilation error (E0703).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0703.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"invalid\" fn foo() {} // error!\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Replace if let with match Expression in Rust\nDESCRIPTION: Converts an if let expression to an equivalent match expression, providing more explicit pattern matching syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_110\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    if let Action::Move { distance } = action {\n        foo(distance)\n    } else {\n        bar()\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum Action { Move { distance: u32 }, Stop }\n\nfn handle(action: Action) {\n    match action {\n        Action::Move { distance } => foo(distance),\n        _ => bar(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation Block with Lifetime Parameters\nDESCRIPTION: Example showing incorrect implementation of a struct with lifetime parameters where the impl block fails to declare the lifetime parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0261.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo<'a> {\n    x: &'a str,\n}\n\n// error,  use of undeclared lifetime name `'a`\nimpl Foo<'a> {\n    fn foo<'a>(x: &'a str) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Building and running the parameter count mismatch example with CFI\nDESCRIPTION: Shell commands demonstrating how to build and run the parameter count mismatch example with CFI protection. With CFI, the invalid function call is detected and the program terminates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi\" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu\n   ...\n   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)\n    Finished release [optimized] target(s) in 1m 08s\n     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-2`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nIllegal instruction\n$\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Label for ARM Group in Markdown\nDESCRIPTION: This snippet shows how to format the GitHub label for the ARM group using Markdown syntax. It includes a link to the label on GitHub.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/arm.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[O-ARM]: https://github.com/rust-lang/rust/labels/O-ARM\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0384 Error in Rust\nDESCRIPTION: This code snippet shows an erroneous attempt to reassign a value to an immutable variable, resulting in a compilation error (E0384).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0384.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 3;\n    x = 5; // error, reassignment of immutable variable\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Rust Compiler with x perf\nDESCRIPTION: Shows how to benchmark the Rust compiler and store the results under a specific ID using the 'benchmark' subcommand of 'x perf'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./x perf benchmark <id>\n```\n\n----------------------------------------\n\nTITLE: Installing MSYS2 Build Dependencies\nDESCRIPTION: Commands for installing required build tools and dependencies in MSYS2 environment on Windows.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\npacman -Sy pacman-mirrors\n\npacman -S make \\\n               diffutils \\\n               tar \\\n               mingw-w64-x86_64-python \\\n               mingw-w64-x86_64-cmake \\\n               mingw-w64-x86_64-gcc \\\n               mingw-w64-x86_64-ninja\n```\n\n----------------------------------------\n\nTITLE: Dependency Graph Visualization\nDESCRIPTION: ASCII diagram showing the dependency relationships between the crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0460.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n    crate `main`\n         |\n         +-------------+\n         |             |\n         |             v\ndepends: |         crate `b`\n `a` v1  |             |\n         |             | depends:\n         |             |  `a` v2\n         v             |\n      crate `a` <------+\n```\n\n----------------------------------------\n\nTITLE: Combinable Expressions - Rust\nDESCRIPTION: Shows formatting rules for combinable expressions including function calls with multi-line arguments and closures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nfoo(bar(\n    an_expr,\n    another_expr,\n))\n\nlet x = foo(Bar {\n    field: whatever,\n});\n\nfoo(|param| {\n    action();\n    foo(param)\n})\n\nlet x = combinable([\n    an_expr,\n    another_expr,\n]);\n\nlet arr = [combinable(\n    an_expr,\n    another_expr,\n)];\n```\n\n----------------------------------------\n\nTITLE: Valid Binary Number Declaration in Rust\nDESCRIPTION: Corrected example showing proper syntax for declaring a binary number literal with the 0b prefix followed by valid binary digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0768.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet s: i32 = 0b1; // ok!\n```\n\n----------------------------------------\n\nTITLE: Editing and Updating Reference Files\nDESCRIPTION: Command to bless the output files of tests, adjusting them based on intentional changes in the compiler's output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n./x test tests/ui --bless\n```\n\n----------------------------------------\n\nTITLE: Invalid Multiple Self Import Example\nDESCRIPTION: Example showing incorrect usage where 'self' appears multiple times in an import list, triggering error E0430.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0430.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse something::{self, self}; // error: `self` import can only appear once in\\n                             //        the list\n```\n\n----------------------------------------\n\nTITLE: Updating codegen-backends in bootstrap.toml\nDESCRIPTION: This TOML configuration snippet updates the `codegen-backends` array to include `gcc`. This enables the `rustc_codegen_gcc` backend.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\ncodegen-backends = [\"llvm\", \"gcc\"]\n```\n\n----------------------------------------\n\nTITLE: Correct If-Else Expression Implementation in Rust\nDESCRIPTION: Example of correct Rust code that properly implements an if-else expression by including both blocks and returning consistent types.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0317.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet a = if x == 5 {\n    1\n} else {\n    2\n};\n```\n\n----------------------------------------\n\nTITLE: Pattern Usage in Lint Implementation\nDESCRIPTION: Example showing how to use pattern matching in a lint implementation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl EarlyLintPass for MyAwesomeLint {\n    fn check_expr(&mut self, cx: &EarlyContext, expr: &syntax::ast::Expr) {\n\n        if my_pattern(expr).is_some() {\n            cx.span_lint(\n                MY_AWESOME_LINT,\n                expr.span,\n                \"This is a match for a simple pattern. Well done!\",\n            );\n        }\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding Source Code from Rust Documentation\nDESCRIPTION: This example uses the #[doc(html_no_source)] attribute to prevent the source code from appearing in the generated documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/the-doc-attribute.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n\"\"\"rust,no_run\\n#![doc(html_no_source)]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Configuring libgccjit for C++ Testing\nDESCRIPTION: Configuration flag to enable C++ language support in the GCC build, which is required for running libgccjit tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--enable-languages=jit,c++\n```\n\n----------------------------------------\n\nTITLE: Early Bound Lifetime Parameter Example\nDESCRIPTION: Shows how making a lifetime parameter early bound allows it to be specified via turbofish syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a: 'a>(b: &'a u32) -> &'a u32 { b }\n\nlet f /* : FooFnItem<'static> */ = foo::<'static>;\n```\n\n----------------------------------------\n\nTITLE: Testing Cranelift Codegen Backend\nDESCRIPTION: Commands to prepare the testing environment and run the test suite for the Cranelift codegen backend after building it from source.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./y.sh prepare # only needs to be run the first time\n$ ./test.sh\n```\n\n----------------------------------------\n\nTITLE: WASI Group Command Reference\nDESCRIPTION: Commands and references for interacting with the WASI notification group, including the ping command for rustbot and relevant GitHub label.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/wasi.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@rustbot ping wasi\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom GCC Path in TOML\nDESCRIPTION: Configuration snippet for config.toml to specify a custom GCC installation path and disable automatic downloading of GCC.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\ngcc-path = \"[MY PATH]\"\n# download-gccjit = true\n```\n\n----------------------------------------\n\nTITLE: Direct Rustc-Clif Compilation\nDESCRIPTION: Command to directly compile a Rust source file using the Cranelift backend through rustc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/usage.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ $cg_clif_dir/dist/rustc-clif my_crate.rs\n```\n\n----------------------------------------\n\nTITLE: Rust Attribute Formatting\nDESCRIPTION: Demonstrates proper formatting of attributes, including multi-line attributes, inner attributes, and attributes with argument lists.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\n#[foo(foo, bar)]\n#[long_multi_line_attribute(\n    split,\n    across,\n    lines,\n)]\nstruct CRepr {\n    #![repr(C)]\n    x: f32,\n    y: f32,\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Consistent Pattern Binding in Rust\nDESCRIPTION: Demonstrates the preferred solution of binding all pattern values consistently, either all by-ref or all by-move.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0009.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((ref y, ref z)) => {},\n    // or Some((y, z)) => {}\n    None => panic!()\n}\n```\n\n----------------------------------------\n\nTITLE: Box Error Implementation Overlap Example\nDESCRIPTION: Illustrates implementation overlap with Box<dyn Error> and different trait bounds\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coherence.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl From<MyLocalType> for Box<dyn Error> {}  // in your own crate\nimpl<E> From<E> for Box<dyn Error> where E: Error {} // in std\n```\n\n----------------------------------------\n\nTITLE: Cleaning Temporary Files for GIMPLE Generation\nDESCRIPTION: This console command removes temporary files created by libgccjit to ensure a clean environment for generating new GIMPLE output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_6\n\nLANGUAGE: console\nCODE:\n```\nrm -rf /tmp/libgccjit-*\n```\n\n----------------------------------------\n\nTITLE: GNU Make Recursive Command for Rustc\nDESCRIPTION: Demonstrates proper GNU Make configuration for rustc with jobserver support using the '+' recursive indicator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/jobserver.md#2025-04-21_snippet_1\n\nLANGUAGE: make\nCODE:\n```\nx:\n\t+@echo 'fn main() {}' | rustc -\n```\n\n----------------------------------------\n\nTITLE: Region Inference Variables Example\nDESCRIPTION: Example showing how regions are replaced with inference variables during the analysis process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a, 'b>(x: &'a /* '#1 */ usize) -> &'b /* '#3 */ usize {\n    x // '#2, location L1\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_LOG environment variable for function-level tracing\nDESCRIPTION: This bash command sets the `RUSTC_LOG` environment variable to enable tracing for a specific function, `foo`.  This configuration logs all function calls to `foo`, logs the arguments (except for those in the `skip` list), and logs everything else in the compiler until `foo` returns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_LOG=[foo]\n```\n\n----------------------------------------\n\nTITLE: Correct Public Item Re-export in Rust\nDESCRIPTION: Example showing the correct way to re-export items by making the source item public using the pub keyword.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0364.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    pub fn foo() {} // ok!\n\n    mod a {\n        pub use super::foo;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: External Macro Detection\nDESCRIPTION: Shows how to detect and ignore macros from foreign crates using in_external_macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nif foo_span.in_external_macro(cx.sess().source_map()) {\n    // We should ignore macro from a foreign crate.\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MIPS R6 Target in bootstrap.toml\nDESCRIPTION: Specifies the MIPS R6 target for Rust build and optionally sets paths for the cross-compilation toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"mipsisa64r6el-unknown-linux-gnuabi64\"]\n\n[target.mipsisa64r6el-unknown-linux-gnuabi64]\ncc = \"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc\"\ncxx = \"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-g++\"\nar = \"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc-ar\"\nranlib = \"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-ranlib\"\nlinker = \"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_10 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_10` function in Rust, passing an integer argument (19). It demonstrates how to call functions with the `fastcall` calling convention using a single integer as a parameter. The output will depend on what `fastcall_fn_10` does.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_10(19)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Recursive Async Function Implementation\nDESCRIPTION: An erroneous example showing a recursive async function that fails to compile due to infinite size requirements.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0733.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn foo(n: usize) {\n    if n > 0 {\n        foo(n - 1).await;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Allow-Features Flag Usage in Rust\nDESCRIPTION: This snippet shows how to use the allow-features flag to enable specific features in Rust. It demonstrates the comma-separated syntax for specifying multiple features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/allow-features.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-Z allow-features=ffi_pure,f16\n```\n\n----------------------------------------\n\nTITLE: Displaying Version Information in Runtime Code\nDESCRIPTION: Demonstrates how to retrieve and display the generated version information in the main application code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn show_version() {\n    let version_info = rustc_tools_util::get_version_info!();\n    println!(\"{}\", version_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Reformatting Number Literals in Rust\nDESCRIPTION: Adds or removes separators from integer literals to improve readability. This refactoring makes large numbers easier to read by inserting underscore separators between digit groups according to conventional grouping rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_96\n\nLANGUAGE: rust\nCODE:\n```\nconst _: i32 = 1012345;\n```\n\nLANGUAGE: rust\nCODE:\n```\nconst _: i32 = 1_012_345;\n```\n\n----------------------------------------\n\nTITLE: Removing Hash from Raw String Literals in Rust\nDESCRIPTION: Removes a hash symbol from a raw string literal, simplifying its notation when the extra escaping is not needed. This refactoring converts an r#\"...\"# raw string to a simpler r\"...\" form when possible.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_98\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r#\"Hello, World!\"#;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    r\"Hello, World!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mac Catalyst Targets via Rustup\nDESCRIPTION: Commands to install Mac Catalyst target support through rustup package manager for both ARM64 and x86_64 architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-ios-macabi.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustup target add aarch64-apple-ios-macabi\n$ rustup target add x86_64-apple-ios-macabi\n```\n\n----------------------------------------\n\nTITLE: Handling Unused Variable 'foo' in Rust REPL Subcommand\nDESCRIPTION: This code snippet represents a diagnostic for an unused variable 'foo' in a Rust REPL subcommand. The compiler suggests prefixing the variable with an underscore to indicate it's intentionally unused.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_unused_variable_as_hint.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet foo = /* some value */;\n```\n\n----------------------------------------\n\nTITLE: Printing Host Triple in Rust\nDESCRIPTION: Shows how to print the target-tuple string of the host compiler using rustc's --print flag, with examples for both default and specific targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print host-tuple a.rs\nx86_64-unknown-linux-gnu\n\n$ rustc --print host-tuple --target \"armv7-unknown-linux-gnueabihf\" a.rs\nx86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Cloning rustc-perf Repository\nDESCRIPTION: Command to clone the rustc-perf repository for accessing benchmark tests that can be used for profiling. This repository contains standard benchmarks used by the Rust project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/rust-lang/rustc-perf\n```\n\n----------------------------------------\n\nTITLE: Unconstrained Const Parameter Error Example\nDESCRIPTION: This code demonstrates an E0207 error with a const parameter that is not constrained by the implementing type, implemented trait, or associated type binding.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0207.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl<const T: i32> Foo {\n    // error: the const parameter `T` is not constrained by the impl trait, self\n    // type, or predicates [E0207]\n    fn get(&self) -> i32 {\n        i32::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating External Crate Name Conflict Error in Rust\nDESCRIPTION: Shows the erroneous case where a struct declaration conflicts with an external crate name, generating error E0260.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0260.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate core;\n\nstruct core;\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Corrected Auto Trait Definition in Rust\nDESCRIPTION: This code snippet shows the correct way to define an auto trait in Rust without using generics. Removing the generic type parameter resolves the compilation error, as the compiler doesn't need to infer any types for the trait. The auto trait `Generic` is now valid.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0567.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```\n#![feature(auto_traits)]\n\nauto trait Generic {} // ok!\n# fn main() {}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Code Model in Rust\nDESCRIPTION: This option specifies the code model to use, which impacts address range constraints. Supported values include `tiny`, `small`, `kernel`, `medium`, and `large`.  The default model is typically `small`.  The specific address ranges depend on the target architecture.  It impacts the size and efficiency of generated machine code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Trait Implementation in Rust\nDESCRIPTION: This snippet demonstrates a trait implementation of `ConvertTo<i32>` for the `Object` type. The ellipsis implies that the actual implementation details are not shown. This illustrates how a trait can be implemented for a specific type with a specific associated type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"impl ConvertTo<i32> for Object { ... }\"\n```\n\n----------------------------------------\n\nTITLE: Using Guarded Return in Rust\nDESCRIPTION: Refactors a complex if condition into a simple guard clause, improving readability and maintaining functionality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    if !cond {\n        return;\n    }\n    foo();\n    bar();\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Header for allocator_internals\nDESCRIPTION: Documents that allocator_internals is an unstable implementation detail not meant for external use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/allocator-internals.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `allocator_internals`\n\nThis feature does not have a tracking issue, it is an unstable implementation\ndetail of the `global_allocator` feature not intended for use outside the\ncompiler.\n```\n\n----------------------------------------\n\nTITLE: Correct Labeled Loop Break Syntax in Rust\nDESCRIPTION: Shows the correct method of using break with a label in a while loop condition, resolving the compile-time error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0590.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n'foo: while break 'foo {}\n```\n\n----------------------------------------\n\nTITLE: Basic x.py Command Format\nDESCRIPTION: Basic command format for running the x.py build script on Unix systems. The script manages the bootstrapping process for building the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./x.py <subcommand> [flags]\n```\n\n----------------------------------------\n\nTITLE: Switching to and Resetting Beta Branch\nDESCRIPTION: Commands to switch to the beta branch, fetch upstream changes, and reset to the upstream beta branch.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/backport.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit switch beta\ngit fetch upstream\ngit reset --hard upstream/beta\n```\n\n----------------------------------------\n\nTITLE: Desugaring Async to Impl Future in Rust\nDESCRIPTION: Converts an async function to its equivalent return type using impl Future, maintaining its output structure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\npub fn foo() -> impl core::future::Future<Output = usize> {\n    0\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect FFI Const Usage in Rust Function\nDESCRIPTION: Example showing incorrect usage of the ffi_const attribute on a regular Rust function, which results in error E0756.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0756.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_const)]\n\n#[unsafe(ffi_const)] // error!\npub fn foo() {}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Correct Module Import Example\nDESCRIPTION: Shows the correct way to import from a local module using self:: prefix and proper module declaration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0432.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\n----------------------------------------\n\nTITLE: Enabling Incremental Compilation in Rust\nDESCRIPTION: Enables incremental compilation, storing information to be reused when recompiling. Takes a path to a directory where incremental files will be stored.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Installing rust-analyzer on macOS using Homebrew\nDESCRIPTION: This snippet shows how to install rust-analyzer on macOS using the Homebrew package manager. It assumes Homebrew is already installed on the system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/rust_analyzer_binary.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ brew install rust-analyzer\n```\n\n----------------------------------------\n\nTITLE: Closure Formatting in Rust\nDESCRIPTION: Styling guidelines for defining and formatting Rust closures, including spacing, braces, and different closure forms\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n|arg1, arg2| expr\n\nmove |arg1: i32, arg2: i32| -> i32 {\n    expr1;\n    expr2\n}\n\n|| Foo {\n    field1,\n    field2: 0,\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Alias Usage as Trait\nDESCRIPTION: Shows incorrect usage of a type alias in a trait bound position, which results in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0404.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo = Iterator<Item=String>;\n\nfn bar<T: Foo>(t: T) {} // error: `Foo` is a type alias\n```\n\n----------------------------------------\n\nTITLE: Inline Always Attribute Usage\nDESCRIPTION: Shows the correct way to use the inline attribute with the 'always' parameter, instructing the compiler to inline the function whenever possible\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0534.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[inline(always)]\nfn something() {}\n```\n\n----------------------------------------\n\nTITLE: Building with Cargo-Clif\nDESCRIPTION: Command to build a Rust project using the Cranelift backend through Cargo integration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/usage.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ $cg_clif_dir/dist/cargo-clif build\n```\n\n----------------------------------------\n\nTITLE: Using Cranelift Codegen Backend via Environment Variable\nDESCRIPTION: Command to enable the Cranelift codegen backend using an environment variable with cargo on the nightly toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/Readme.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ CARGO_PROFILE_DEV_CODEGEN_BACKEND=cranelift cargo +nightly build -Zcodegen-backend\n```\n\n----------------------------------------\n\nTITLE: Explicit ABI - False\nDESCRIPTION: Demonstrates the behavior of extern items when `force_explicit_abi` is set to `false`. The \"C\" ABI is removed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nextern {\n    pub static lorem: c_int;\n}\n```\n\n----------------------------------------\n\nTITLE: MIR Pass Definition Structure\nDESCRIPTION: Demonstrates how MIR optimization passes are defined and registered in the Rust compiler, using trait objects and a centralized pass management approach\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/optimizations.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Example of a MIR pass definition\nstruct CleanupPostBorrowck;\n\nimpl MirPass for CleanupPostBorrowck {\n    fn run_pass(&self, tcx: TyCtxt<'_>, body: &mut Body<'_>) {\n        // Optimization logic here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust to Default Location\nDESCRIPTION: Command to install Rust to the default /usr/local directory using the included install script with sudo privileges.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/etc/installer/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./install.sh\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NOP Padding with Patchable Function Entry\nDESCRIPTION: Example showing how the -Z patchable-function-entry=3,2 flag structures function entry with NOP instructions. The example demonstrates placement of NOPs before and after the function label, creating space for potential hotpatching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/patchable-function-entry.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nnop\nnop\nfunction_label:\nnop\n//Actual function code begins here\n```\n\n----------------------------------------\n\nTITLE: Copying Generic Parameters with Bounds for Struct\nDESCRIPTION: Example showing how to copy generic parameters and bounds for inner struct definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing IDE-Rust Package in Atom\nDESCRIPTION: Command to install the ide-rust package in Atom which provides rust-analyzer integration for Rust code formatting\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/atom.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napm install ide-rust\n```\n\n----------------------------------------\n\nTITLE: Correct Boolean Comparison in Rust\nDESCRIPTION: Shows the proper way to convert a numeric value to a boolean by using comparison operators instead of type casting.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0054.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n\n// Ok\nlet x_is_nonzero = x != 0;\n```\n\n----------------------------------------\n\nTITLE: Copying Generic Parameters with Bounds\nDESCRIPTION: Example showing how to copy generic parameters along with their trait bounds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Untagged Union Declaration Formatting in Rust\nDESCRIPTION: Shows how to format untagged union declarations in Rust, following the same guidelines as structs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nunion Foo {\n    a: A,\n    b: B,\n    long_name:\n        LongType,\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-line Directive Example\nDESCRIPTION: Shows how directives can be extended across multiple lines using backslash continuation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/rustdoc-test-suite.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n//@ directive 'argument' \\\n// 'continuation'\n```\n\n----------------------------------------\n\nTITLE: Enabling RISC-V Target in Bootstrap Configuration\nDESCRIPTION: Configuration to include the RISC-V target when building Rust from source\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"riscv64gc-unknown-linux-gnu\"]\n```\n\n----------------------------------------\n\nTITLE: Enabling Pedantic Lints in Rust\nDESCRIPTION: Example of how to enable pedantic lint checks for a Rust crate at the root level.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lints.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![warn(clippy::pedantic)]\n```\n\n----------------------------------------\n\nTITLE: Adding a Single Linker Argument in Rust\nDESCRIPTION: Appends a single extra argument to the linker invocation. This flag can be passed multiple times to add multiple arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: FileCheck Revision Annotation in Rust\nDESCRIPTION: Demonstrates how to specify test revisions and compile-specific flags for different test variations\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/codegen/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// revisions: aaa bbb\n// [bbb] compile-flags: --flags-for-bbb\n```\n\n----------------------------------------\n\nTITLE: Running Cargo with GCC Codegen\nDESCRIPTION: Command to run a Cargo project using the GCC codegen backend in release mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ CHANNEL=\"release\" $CG_GCCJIT_DIR/y.sh cargo run\n```\n\n----------------------------------------\n\nTITLE: Fixing Type Inference with Turbofish Syntax in Rust\nDESCRIPTION: This solution uses the turbofish syntax to specify the type parameter in the path of the expression.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0282.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Vec::<i32>::new();\n```\n\n----------------------------------------\n\nTITLE: Configuring Clippy in rust-analyzer\nDESCRIPTION: Sets the rust-analyzer configuration to use Clippy instead of the default cargo check for diagnostics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/diagnostics.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"rust-analyzer.check.command\": \"clippy\"\n```\n\n----------------------------------------\n\nTITLE: Configuring GNU Linker for RISC-V Target\nDESCRIPTION: Cargo configuration to specify the GNU GCC linker for RISC-V cross-compilation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[target.riscv64gc-unknown-linux-gnu]\nlinker = \"riscv64-linux-gnu-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Testing Rust Trait Object Promotion & Inlining (LLVM IR)\nDESCRIPTION: This LLVM IR snippet, with associated `CHECK` directives, tests indirect call promotion and inlining for trait object method calls in Rust. The `CHECK`s verify that the generated code includes a comparison against the promoted method (`@foo`) and a subsequent direct call to the inlined target (`@opaque_f2`).\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/pgo-indirect-call-promotion/filecheck-patterns.txt#_snippet_1\n\nLANGUAGE: LLVM IR\nCODE:\n```\n# Same checks as above, repeated for the trait object case\n\nCHECK: define void @call_a_bunch_of_trait_methods({{.*}}\nCHECK: %{{.*}} = icmp eq ptr %{{.*}}, {{.*}}@foo\nCHECK: tail call void @opaque_f2()\n```\n\n----------------------------------------\n\nTITLE: Formatting Type Aliases with Where Clauses in Rust\nDESCRIPTION: Demonstrates formatting for type aliases with preceding where clauses and both preceding and trailing where clauses, showing proper indentation and line break rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n// With only a preceding where clause.\ntype WithPrecedingWC<T, U>\nwhere\n    T: U::AnAssociatedType,\n    U: SomeBound,\n= AnEvenLongerType<T, U, Foo<T>>;\n\n// Or with both a preceding and trailing where clause.\ntype WithPrecedingWC<T, U>\nwhere\n    T: U::AnAssociatedType,\n    U: SomeBound,\n= AnEvenLongerType<T, U, Foo<T>>\nwhere\n    T: U::AnAssociatedType2,\n    U: SomeBound2;\n```\n\n----------------------------------------\n\nTITLE: Invalid Rust Lint Attribute Example\nDESCRIPTION: An example showing incorrect usage of a lint attribute where a string value is incorrectly assigned to the lint name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0452.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(foo = \"\")] // error: malformed lint attribute\n```\n\n----------------------------------------\n\nTITLE: Generating Git Patch\nDESCRIPTION: Creates a patch file for the most recent commit using git format-patch\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit format-patch -1 `git rev-parse --short HEAD`\n```\n\n----------------------------------------\n\nTITLE: Fetching Clippy Upstream in Rust Repository\nDESCRIPTION: Command to fetch the latest changes from the Clippy upstream master branch in the Rust repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/backport.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch clippy-upstream master\n```\n\n----------------------------------------\n\nTITLE: Multi-file Rust Program - Main Module\nDESCRIPTION: Example of a Rust program's main file that imports and uses a module from another file\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmod foo;\n\nfn main() {\n    foo::hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Self-Profile Events with Arguments\nDESCRIPTION: Example of enabling the profiler with default events and their arguments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile-events.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -Zself-profile -Zself-profile-events=default,args\n```\n\n----------------------------------------\n\nTITLE: Using Outer Documentation Syntax in Rust\nDESCRIPTION: This snippet shows how to use the outer documentation syntax in Rust for documenting functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n/// This is my first rust crate\n\n```\n\n----------------------------------------\n\nTITLE: SDK Path Environment Variable Setting\nDESCRIPTION: Example of using xcrun to show SDK path for macOS compilation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-darwin.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nxcrun --sdk macosx --show-sdk-path\n```\n\n----------------------------------------\n\nTITLE: Running Tidy and Standard Library Tests\nDESCRIPTION: Commands to run the tidy script and tests on the standard library or using a specific compiler stage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n./x test tidy\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test --stage 0 library/std\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test --stage 0 tidy library/std\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test --stage 1 library/std\n```\n\nLANGUAGE: text\nCODE:\n```\n./x test --stage 2\n```\n\n----------------------------------------\n\nTITLE: Running Clippy on Workspace Package\nDESCRIPTION: Commands to run Clippy on specific workspace packages with dependency options\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo clippy -p example\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo clippy -p example -- --no-deps\n```\n\n----------------------------------------\n\nTITLE: Running GNU Style Check\nDESCRIPTION: Validates the generated patch file against GNU coding style guidelines\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncontrib/check_GNU_style.sh 0001-your-patch.patch\n```\n\n----------------------------------------\n\nTITLE: Building Rust with MSVC\nDESCRIPTION: Commands for building Rust using Microsoft Visual C++ (MSVC) toolchain on Windows.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\npython x.py setup user\npython x.py build\n```\n\nLANGUAGE: batch\nCODE:\n```\nCALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\npython x.py build\n```\n\n----------------------------------------\n\nTITLE: Running m68k Rust Binary with QEMU\nDESCRIPTION: Command to execute a simple m68k Rust binary using QEMU static emulation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ qemu-m68k-static your-code\n```\n\n----------------------------------------\n\nTITLE: Copying Example Configuration\nDESCRIPTION: Command to copy the example configuration file for the rustc_codegen_gcc project setup.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ cp config.example.toml config.toml\n```\n\n----------------------------------------\n\nTITLE: Simple Pattern Macro Usage\nDESCRIPTION: Example of using the proposed pattern macro to match boolean literals\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    my_pattern: Expr =\n        Lit(Bool(false))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Build Configuration with x Setup\nDESCRIPTION: Use the 'x' wrapper tool to create a default build configuration for the Rust compiler\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/quickstart.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./x setup\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation Example in Rust\nDESCRIPTION: Demonstrates a trait implementation for Foo<isize> on usize, used to illustrate the caching mechanism for trait selection\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/caching.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Foo<isize> for usize { ... } \\// Impl #22\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Build with Verbose Output\nDESCRIPTION: Command to show how Cargo invokes rustc compiler with detailed output of compilation process\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo build --verbose\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Commands in Rust Analyzer\nDESCRIPTION: Shows cargo commands that may perform network operations: cargo metadata for registry/dependency management and cargo xtask release for generating release notes via GitHub API.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/privacy.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo metadata\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo xtask release\n```\n\n----------------------------------------\n\nTITLE: Unused Variable Warning Example\nDESCRIPTION: Shows code that triggers the unused_variables warning lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/levels.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn foo() {\n    let x = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Big-Endian Linker Configuration\nDESCRIPTION: GNU linker configuration for BE-32 processors requiring big-endian instruction and data handling\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7r-none-eabi.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n-mbe32\n```\n\n----------------------------------------\n\nTITLE: Using the print-config CLI option in Rustfmt\nDESCRIPTION: Example of using the --print-config CLI option to print the current configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_23\n\nLANGUAGE: Shell\nCODE:\n```\nrustfmt --print-config current\n```\n\n----------------------------------------\n\nTITLE: Checking Specific Commit with Changelog Script\nDESCRIPTION: Verifies changelog formatting for a specific commit hash\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./contrib/gcc-changelog/git_check_commit.py abdef78989\n```\n\n----------------------------------------\n\nTITLE: Apple Platform Ping Command\nDESCRIPTION: Command used to request assistance from the Apple platform support team in the Rust project\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/apple.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n@rustbot ping apple\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in Rust\nDESCRIPTION: This snippet shows how to define a simple private function in Rust to be documented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// foo is a function\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Clang Compiler Wrapper for TEEOS in Shell Script\nDESCRIPTION: The purpose of the shell scripts is to wrap the Clang compiler from the OpenHarmony SDK for cross-compiling to the aarch64-unknown-teeos target. These scripts modify the target triple to 'aarch64-linux-gnu' and execute Clang with all passed arguments. No additional dependencies are required other than the OpenHarmony SDK, and the scripts modify the execution path of clang and clang++.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-unknown-teeos.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\n  -target aarch64-linux-gnu \\\n  \"$@\"\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\n  -target aarch64-linux-gnu \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Complete make Function Implementation in Rust\nDESCRIPTION: Full implementation of the make function returning a tuple with lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/member_constraints.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntype MakeReturn<'x, 'y> = impl Trait<'x, 'y>;\nfn make(a: &'a u32, b: &'b u32) -> MakeReturn<'a, 'b> {\n  (a, b)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Fuchsia Package Directory Structure\nDESCRIPTION: Commands to create the necessary directories for a Fuchsia package.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nmkdir pkg\nmkdir pkg/meta\n```\n\n----------------------------------------\n\nTITLE: Defining CFI Encodings for Rust Types\nDESCRIPTION: This snippet demonstrates how to define custom CFI encodings for Rust types using the cfi_encoding feature. The struct Type1 and external type Type2 are assigned non-standard names to avoid naming conflicts with C functions. The required feature flag must be enabled in order to utilize this functionality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/cfi-encoding.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(cfi_encoding, extern_types)]\n\n#[cfi_encoding = \"3Foo\"]\npub struct Type1(i32);\n\nextern {\n    #[cfi_encoding = \"3Bar\"]\ntype Type2;\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining Aligned SIMD Data from Slices in Rust\nDESCRIPTION: This snippet illustrates the use of as_simd and as_simd_mut methods from slice primitives to obtain data that is correctly aligned for SIMD processing. It highlights the importance of alignment for optimized performance in SIMD operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/portable-simd/beginners-guide.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet aligned_simd_data = slice.as_simd();\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet aligned_simd_mut_data = slice.as_simd_mut();\n```\n\n----------------------------------------\n\nTITLE: Implementing Marker Trait for Overlapping Types in Rust\nDESCRIPTION: Demonstrates how to use the marker_trait_attr feature to create a CheapToClone trait that allows overlapping implementations. The trait inherits from Clone and is implemented for Copy types, tuples, and ranges, showing how marker traits can have multiple potentially overlapping implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/marker-trait-attr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(marker_trait_attr)]\n\n#[marker] trait CheapToClone: Clone {}\n\nimpl<T: Copy> CheapToClone for T {}\n\n// These could potentially overlap with the blanket implementation above,\n// so are only allowed because CheapToClone is a marker trait.\nimpl<T: CheapToClone, U: CheapToClone> CheapToClone for (T, U) {}\nimpl<T: CheapToClone> CheapToClone for std::ops::Range<T> {}\n\nfn cheap_clone<T: CheapToClone>(t: T) -> T {\n    t.clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Compilation Configuration for Armv7R Target\nDESCRIPTION: Cross-compilation configuration for ARM Cortex-R processors using arm-none-eabi toolchain with specific architectural requirements\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7r-none-eabi.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\narm-none-eabi -march=armv7-r\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Definition in Rust\nDESCRIPTION: Shows how to properly define an enum to resolve name references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0425.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\n----------------------------------------\n\nTITLE: Library Crate Definition\nDESCRIPTION: Defines a simple library crate with a single function foo()\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0461.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"lib\"]\n\nfn foo() {}\n```\n\n----------------------------------------\n\nTITLE: Import Layout and Indentation Configurations\nDESCRIPTION: Demonstrates different import layout and indentation strategies in Rust\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nuse foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};\n```\n\n----------------------------------------\n\nTITLE: Correct Clippy Lint Tool Name\nDESCRIPTION: Examples of correctly spelled clippy tool name in lint attributes\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0710.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(clippy::filter_map)] // ok!\nfn main() {\n    // business logic\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[warn(clippy::filter_map)] // ok!\nfn main() {\n    // business logic\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Clippy Component\nDESCRIPTION: Terminal command to add Clippy as a rustup component\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nrustup component add clippy\n```\n\n----------------------------------------\n\nTITLE: Defining Lifetime Identifiers\nDESCRIPTION: This snippet defines several lifetime identifiers as string constants used in Rust. These identifiers are essential for managing lifetimes in the Rust type system. The constants include various names for lifetime annotations found in Rust source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/lifetimes.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nLIFETIME_IDENT \"'a\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nWHITESPACE \" \"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nLIFETIME_IDENT \"'foo\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nWHITESPACE \" \"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nLIFETIME_IDENT \"'foo_bar_baz\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nWHITESPACE \" \"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nLIFETIME_IDENT \"'_\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nWHITESPACE \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of instruction_set Attribute in Rust\nDESCRIPTION: This code snippet demonstrates the proper use of the `instruction_set` attribute with a supported argument 'arm::a32', conditionally applied using `cfg_attr` for ARM architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0779.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(isa_attribute)]\n\n#[cfg_attr(target_arch=\"arm\", instruction_set(arm::a32))] // ok!\npub fn something() {}\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Xtensa Target Names Table in Markdown\nDESCRIPTION: Markdown table showing the mapping between Xtensa target names and their corresponding CPU models, specifically for ESP32 variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/xtensa.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Target name               | Target CPU(s)                                                   |\n| ------------------------- | --------------------------------------------------------------- |\n| `xtensa-esp32-none-elf`   | [ESP32](https://www.espressif.com/en/products/socs/esp32)       |\n| `xtensa-esp32s2-none-elf` | [ESP32-S2](https://www.espressif.com/en/products/socs/esp32-s2) |\n| `xtensa-esp32s3-none-elf` | [ESP32-S3](https://www.espressif.com/en/products/socs/esp32-s3) |\n```\n\n----------------------------------------\n\nTITLE: Comment Wrapping Enabled Example in Rust\nDESCRIPTION: Demonstrates comment formatting when wrap_comments is enabled, showing automatic line breaks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_84\n\nLANGUAGE: rust\nCODE:\n```\n// Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n// sed do eiusmod tempor incididunt ut labore et dolore\n// magna aliqua. Ut enim ad minim veniam, quis nostrud\n// exercitation ullamco laboris nisi ut aliquip ex ea\n// commodo consequat.\n\n// Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n// sed do eiusmod tempor incididunt ut labore et dolore\n// magna aliqua. Ut enim ad minim veniam, quis nostrud\n// exercitation ullamco laboris nisi ut aliquip ex ea\n// commodo consequat.\n\n// Information on the lorem ipsum can be found at the following url: https://en.wikipedia.org/wiki/Lorem_ipsum. Its text is: lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\n/// # This doc comment is a very long header (it starts with a '#'). Had it not been a header it would have been wrapped. But because it is a header, it will not be. That is because wrapping a markdown header breaks it.\nstruct Foo {}\n```\n\n----------------------------------------\n\nTITLE: Correct Declaration of simd_shuffle Function in Rust\nDESCRIPTION: This code snippet shows the correct way to declare the `simd_shuffle` platform-intrinsic function. The length of the shuffle (8 in this case) is included in the function name as `simd_shuffle8`. Note that this example may no longer compile with current Rust versions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0439.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(platform_intrinsics)]\n\nextern \"platform-intrinsic\" {\n    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Lifetime Inference Issues in Closures with Opaque Types\nDESCRIPTION: This example demonstrates how external lifetimes in closures behave more like existential lifetimes, causing issues with the member constraints algorithm. It shows a case where the compiler cannot safely infer lifetime relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x, 'y> = impl Sized;\n\n// \nfn test<'a, 'b>(s: &'a str) -> impl FnOnce() -> Opaque<'a, 'b> {\n    move || { s }\n    //~^ ERROR hidden type for `Opaque<'_, '_>` captures lifetime that does not appear in bounds\n}\n\n// The above closure body is desugared into something like:\nfn test::{closure#0}(_upvar: &'?8 str) -> Opaque<'?6, '?7> {\n    return _upvar\n}\n\n// where `['?8, '?6, ?7]` are universal lifetimes *external* to the closure.\n// There are no known relations between them *inside* the closure.\n// But in the parent fn it is known that `'?6: '?8`.\n//\n// When encountering an opaque definition `Opaque<'?6, '?7> := &'8 str`,\n// The member constraints algorithm does not know enough to safely make `?8 = '?6`.\n// For this reason, it errors with a sensible message:\n// \"hidden type captures lifetime that does not appear in bounds\".\n```\n\n----------------------------------------\n\nTITLE: Crates-io Source Configuration - TOML\nDESCRIPTION: Defines a Crates-io source in a TOML file for specifying the crates to lint. Requires the name of the crate and one or more versions to be checked.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/lintcheck/README.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\nbitflags = {name = \"bitflags\", versions = ['1.2.1']}\n```\n\n----------------------------------------\n\nTITLE: Defining Error Code Constants in Rust\nDESCRIPTION: This snippet showcases a series of error code constants defined in Rust. These constants represent various error conditions that can occur during system operations, file handling, network interactions, and other low-level processes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/windows/c/bindings.txt#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nERROR_ERRORS_ENCOUNTERED\nERROR_EVALUATION_EXPIRATION\nERROR_EVENT_DONE\nERROR_EVENT_PENDING\nERROR_EVENTLOG_CANT_START\nERROR_EVENTLOG_FILE_CHANGED\nERROR_EVENTLOG_FILE_CORRUPT\nERROR_EXCEPTION_IN_SERVICE\nERROR_EXCL_SEM_ALREADY_OWNED\nERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY\nERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY\nERROR_EXE_MACHINE_TYPE_MISMATCH\nERROR_EXE_MARKED_INVALID\nERROR_EXTENDED_ERROR\nERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN\nERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED\nERROR_EXTRANEOUS_INFORMATION\nERROR_FAIL_FAST_EXCEPTION\nERROR_FAIL_I24\nERROR_FAIL_NOACTION_REBOOT\nERROR_FAIL_RESTART\nERROR_FAIL_SHUTDOWN\nERROR_FAILED_DRIVER_ENTRY\nERROR_FAILED_SERVICE_CONTROLLER_CONNECT\nERROR_FATAL_APP_EXIT\nERROR_FILE_CHECKED_OUT\nERROR_FILE_CORRUPT\nERROR_FILE_ENCRYPTED\nERROR_FILE_EXISTS\nERROR_FILE_HANDLE_REVOKED\nERROR_FILE_INVALID\nERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED\nERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS\nERROR_FILE_NOT_ENCRYPTED\nERROR_FILE_NOT_FOUND\nERROR_FILE_NOT_SUPPORTED\nERROR_FILE_OFFLINE\nERROR_FILE_PROTECTED_UNDER_DPL\nERROR_FILE_READ_ONLY\nERROR_FILE_SNAP_IN_PROGRESS\nERROR_FILE_SNAP_INVALID_PARAMETER\nERROR_FILE_SNAP_IO_NOT_COORDINATED\nERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED\nERROR_FILE_SNAP_UNEXPECTED_ERROR\nERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED\nERROR_FILE_SYSTEM_LIMITATION\nERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY\nERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION\nERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT\nERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN\nERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE\nERROR_FILE_TOO_LARGE\nERROR_FILEMARK_DETECTED\nERROR_FILENAME_EXCED_RANGE\nERROR_FIRMWARE_UPDATED\nERROR_FLOAT_MULTIPLE_FAULTS\nERROR_FLOAT_MULTIPLE_TRAPS\nERROR_FLOPPY_BAD_REGISTERS\nERROR_FLOPPY_ID_MARK_NOT_FOUND\nERROR_FLOPPY_UNKNOWN_ERROR\nERROR_FLOPPY_VOLUME\nERROR_FLOPPY_WRONG_CYLINDER\nERROR_FORMS_AUTH_REQUIRED\nERROR_FOUND_OUT_OF_SCOPE\nERROR_FS_DRIVER_REQUIRED\nERROR_FS_METADATA_INCONSISTENT\nERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY\nERROR_FT_DI_SCAN_REQUIRED\nERROR_FT_READ_FAILURE\nERROR_FT_READ_FROM_COPY_FAILURE\nERROR_FT_READ_RECOVERY_FROM_BACKUP\nERROR_FT_WRITE_FAILURE\nERROR_FT_WRITE_RECOVERY\nERROR_FULLSCREEN_MODE\nERROR_FUNCTION_FAILED\nERROR_FUNCTION_NOT_CALLED\nERROR_GDI_HANDLE_LEAK\nERROR_GEN_FAILURE\nERROR_GENERIC_NOT_MAPPED\nERROR_GLOBAL_ONLY_HOOK\nERROR_GRACEFUL_DISCONNECT\nERROR_GROUP_EXISTS\nERROR_GUID_SUBSTITUTION_MADE\nERROR_HANDLE_DISK_FULL\nERROR_HANDLE_EOF\nERROR_HANDLE_REVOKED\nERROR_HANDLES_CLOSED\nERROR_HAS_SYSTEM_CRITICAL_FILES\nERROR_HIBERNATED\nERROR_HIBERNATION_FAILURE\nERROR_HOOK_NEEDS_HMOD\nERROR_HOOK_NOT_INSTALLED\nERROR_HOOK_TYPE_NOT_ALLOWED\nERROR_HOST_DOWN\nERROR_HOST_UNREACHABLE\nERROR_HOTKEY_ALREADY_REGISTERED\nERROR_HOTKEY_NOT_REGISTERED\nERROR_HWNDS_HAVE_DIFF_PARENT\nERROR_ILL_FORMED_PASSWORD\nERROR_ILLEGAL_CHARACTER\nERROR_ILLEGAL_DLL_RELOCATION\nERROR_ILLEGAL_ELEMENT_ADDRESS\nERROR_ILLEGAL_FLOAT_CONTEXT\nERROR_IMAGE_AT_DIFFERENT_BASE\nERROR_IMAGE_MACHINE_TYPE_MISMATCH\nERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE\nERROR_IMAGE_NOT_AT_BASE\nERROR_IMAGE_SUBSYSTEM_NOT_PRESENT\nERROR_IMPLEMENTATION_LIMIT\nERROR_INCOMPATIBLE_SERVICE_PRIVILEGE\nERROR_INCOMPATIBLE_SERVICE_SID_TYPE\nERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING\nERROR_INCORRECT_ACCOUNT_TYPE\nERROR_INCORRECT_ADDRESS\nERROR_INCORRECT_SIZE\nERROR_INDEX_ABSENT\nERROR_INDEX_OUT_OF_BOUNDS\nERROR_INFLOOP_IN_RELOC_CHAIN\nERROR_INSTALL_ALREADY_RUNNING\nERROR_INSTALL_FAILURE\nERROR_INSTALL_LANGUAGE_UNSUPPORTED\nERROR_INSTALL_LOG_FAILURE\nERROR_INSTALL_NOTUSED\nERROR_INSTALL_PACKAGE_INVALID\nERROR_INSTALL_PACKAGE_OPEN_FAILED\nERROR_INSTALL_PACKAGE_REJECTED\nERROR_INSTALL_PACKAGE_VERSION\nERROR_INSTALL_PLATFORM_UNSUPPORTED\nERROR_INSTALL_REJECTED\nERROR_INSTALL_REMOTE_DISALLOWED\nERROR_INSTALL_REMOTE_PROHIBITED\nERROR_INSTALL_SERVICE_FAILURE\nERROR_INSTALL_SERVICE_SAFEBOOT\nERROR_INSTALL_SOURCE_ABSENT\nERROR_INSTALL_SUSPEND\nERROR_INSTALL_TEMP_UNWRITABLE\nERROR_INSTALL_TRANSFORM_FAILURE\nERROR_INSTALL_TRANSFORM_REJECTED\nERROR_INSTALL_UI_FAILURE\nERROR_INSTALL_USEREXIT\nERROR_INSTRUCTION_MISALIGNMENT\nERROR_INSUFFICIENT_BUFFER\nERROR_INSUFFICIENT_LOGON_INFO\nERROR_INSUFFICIENT_POWER\nERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE\nERROR_INSUFFICIENT_VIRTUAL_ADDR_RESOURCES\nERROR_INTERMIXED_KERNEL_EA_OPERATION\nERROR_INTERNAL_DB_CORRUPTION\nERROR_INTERNAL_DB_ERROR\nERROR_INTERNAL_ERROR\nERROR_INTERRUPT_STILL_CONNECTED\nERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED\nERROR_INVALID_ACCEL_HANDLE\nERROR_INVALID_ACCESS\nERROR_INVALID_ACCOUNT_NAME\nERROR_INVALID_ACE_CONDITION\nERROR_INVALID_ACL\nERROR_INVALID_ADDRESS\nERROR_INVALID_AT_INTERRUPT_TIME\nERROR_INVALID_BLOCK\nERROR_INVALID_BLOCK_LENGTH\nERROR_INVALID_CAP\nERROR_INVALID_CATEGORY\nERROR_INVALID_COMBOBOX_MESSAGE\nERROR_INVALID_COMMAND_LINE\nERROR_INVALID_COMPUTERNAME\nERROR_INVALID_CRUNTIME_PARAMETER\nERROR_INVALID_CURSOR_HANDLE\nERROR_INVALID_DATA\nERROR_INVALID_DATATYPE\nERROR_INVALID_DEVICE_OBJECT_PARAMETER\nERROR_INVALID_DLL\nERROR_INVALID_DOMAIN_ROLE\nERROR_INVALID_DOMAIN_STATE\nERROR_INVALID_DOMAINNAME\nERROR_INVALID_DRIVE\nERROR_INVALID_DWP_HANDLE\nERROR_INVALID_EA_HANDLE\nERROR_INVALID_EA_NAME\nERROR_INVALID_EDIT_HEIGHT\nERROR_INVALID_ENVIRONMENT\nERROR_INVALID_EVENT_COUNT\nERROR_INVALID_EVENTNAME\nERROR_INVALID_EXCEPTION_HANDLER\nERROR_INVALID_EXE_SIGNATURE\nERROR_INVALID_FIELD\nERROR_INVALID_FIELD_IN_PARAMETER_LIST\nERROR_INVALID_FILTER_PROC\nERROR_INVALID_FLAG_NUMBER\nERROR_INVALID_FLAGS\nERROR_INVALID_FORM_NAME\nERROR_INVALID_FORM_SIZE\nERROR_INVALID_FUNCTION\nERROR_INVALID_GROUP_ATTRIBUTES\nERROR_INVALID_GROUPNAME\nERROR_INVALID_GW_COMMAND\nERROR_INVALID_HANDLE\nERROR_INVALID_HANDLE_STATE\nERROR_INVALID_HOOK_FILTER\nERROR_INVALID_HOOK_HANDLE\nERROR_INVALID_HW_PROFILE\nERROR_INVALID_ICON_HANDLE\nERROR_INVALID_ID_AUTHORITY\nERROR_INVALID_IMAGE_HASH\nERROR_INVALID_IMPORT_OF_NON_DLL\nERROR_INVALID_INDEX\nERROR_INVALID_KERNEL_INFO_VERSION\nERROR_INVALID_KEYBOARD_HANDLE\nERROR_INVALID_LABEL\nERROR_INVALID_LB_MESSAGE\nERROR_INVALID_LDT_DESCRIPTOR\nERROR_INVALID_LDT_OFFSET\nERROR_INVALID_LDT_SIZE\nERROR_INVALID_LEVEL\nERROR_INVALID_LIST_FORMAT\nERROR_INVALID_LOCK_RANGE\nERROR_INVALID_LOGON_HOURS\nERROR_INVALID_LOGON_TYPE\nERROR_INVALID_MEMBER\nERROR_INVALID_MENU_HANDLE\nERROR_INVALID_MESSAGE\nERROR_INVALID_MESSAGEDEST\nERROR_INVALID_MESSAGENAME\nERROR_INVALID_MINALLOCSIZE\nERROR_INVALID_MODULETYPE\nERROR_INVALID_MONITOR_HANDLE\nERROR_INVALID_MSGBOX_STYLE\nERROR_INVALID_NAME\nERROR_INVALID_NETNAME\nERROR_INVALID_OPLOCK_PROTOCOL\nERROR_INVALID_ORDINAL\nERROR_INVALID_OWNER\nERROR_INVALID_PACKAGE_SID_LENGTH\nERROR_INVALID_PARAMETER\nERROR_INVALID_PASSWORD\nERROR_INVALID_PASSWORDNAME\nERROR_INVALID_PATCH_XML\nERROR_INVALID_PEP_INFO_VERSION\nERROR_INVALID_PLUGPLAY_DEVICE_PATH\nERROR_INVALID_PORT_ATTRIBUTES\nERROR_INVALID_PRIMARY_GROUP\nERROR_INVALID_PRINTER_COMMAND\nERROR_INVALID_PRINTER_NAME\nERROR_INVALID_PRINTER_STATE\nERROR_INVALID_PRIORITY\nERROR_INVALID_QUOTA_LOWER\nERROR_INVALID_REPARSE_DATA\nERROR_INVALID_SCROLLBAR_RANGE\nERROR_INVALID_SECURITY_DESCR\nERROR_INVALID_SEGDPL\nERROR_INVALID_SEGMENT_NUMBER\nERROR_INVALID_SEPARATOR_FILE\nERROR_INVALID_SERVER_STATE\nERROR_INVALID_SERVICE_ACCOUNT\nERROR_INVALID_SERVICE_CONTROL\nERROR_INVALID_SERVICE_LOCK\nERROR_INVALID_SERVICENAME\nERROR_INVALID_SHARENAME\nERROR_INVALID_SHOWWIN_COMMAND\nERROR_INVALID_SID\nERROR_INVALID_SIGNAL_NUMBER\nERROR_INVALID_SPI_VALUE\nERROR_INVALID_STACKSEG\nERROR_INVALID_STARTING_CODESEG\nERROR_INVALID_SUB_AUTHORITY\nERROR_INVALID_TABLE\nERROR_INVALID_TARGET_HANDLE\nERROR_INVALID_TASK_INDEX\nERROR_INVALID_TASK_NAME\nERROR_INVALID_THREAD_ID\nERROR_INVALID_TIME\nERROR_INVALID_TOKEN\nERROR_INVALID_UNWIND_TARGET\nERROR_INVALID_USER_BUFFER\nERROR_INVALID_USER_PRINCIPAL_NAME\nERROR_INVALID_VARIANT\nERROR_INVALID_VERIFY_SWITCH\nERROR_INVALID_WINDOW_HANDLE\nERROR_INVALID_WORKSTATION\nERROR_IO_DEVICE\nERROR_IO_INCOMPLETE\nERROR_IO_PENDING\nERROR_IO_PRIVILEGE_FAILED\nERROR_IO_REISSUE_AS_CACHED\nERROR_IOPL_NOT_ENABLED\nERROR_IP_ADDRESS_CONFLICT1\nERROR_IP_ADDRESS_CONFLICT2\nERROR_IPSEC_IKE_TIMED_OUT\nERROR_IRQ_BUSY\nERROR_IS_JOIN_PATH\nERROR_IS_JOIN_TARGET\nERROR_IS_JOINED\nERROR_IS_SUBST_PATH\nERROR_IS_SUBST_TARGET\nERROR_IS_SUBSTED\nERROR_ITERATED_DATA_EXCEEDS_64k\nERROR_JOB_NO_CONTAINER\nERROR_JOIN_TO_JOIN\nERROR_JOIN_TO_SUBST\nERROR_JOURNAL_DELETE_IN_PROGRESS\nERROR_JOURNAL_ENTRY_DELETED\nERROR_JOURNAL_HOOK_SET\nERROR_JOURNAL_NOT_ACTIVE\nERROR_KERNEL_APC\nERROR_KEY_DELETED\nERROR_KEY_HAS_CHILDREN\nERROR_KM_DRIVER_BLOCKED\nERROR_LABEL_TOO_LONG\nERROR_LAST_ADMIN\nERROR_LB_WITHOUT_TABSTOPS\nERROR_LICENSE_QUOTA_EXCEEDED\nERROR_LINUX_SUBSYSTEM_NOT_PRESENT\nERROR_LINUX_SUBSYSTEM_UPDATE_REQUIRED\nERROR_LISTBOX_ID_NOT_FOUND\nERROR_LM_CROSS_ENCRYPTION_REQUIRED\nERROR_LOCAL_POLICY_MODIFICATION_NOT_SUPPORTED\nERROR_LOCAL_USER_SESSION_KEY\nERROR_LOCK_FAILED\nERROR_LOCK_VIOLATION\nERROR_LOCKED\nERROR_LOG_FILE_FULL\nERROR_LOG_HARD_ERROR\nERROR_LOGIN_TIME_RESTRICTION\nERROR_LOGIN_WKSTA_RESTRICTION\nERROR_LOGON_FAILURE\nERROR_LOGON_NOT_GRANTED\nERROR_LOGON_SERVER_CONFLICT\nERROR_LOGON_SESSION_COLLISION\nERROR_LOGON_SESSION_EXISTS\nERROR_LOGON_TYPE_NOT_GRANTED\nERROR_LONGJUMP\nERROR_LOST_MODE_LOGON_RESTRICTION\nERROR_LOST_WRITEBEHIND_DATA\nERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR\nERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED\nERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR\nERROR_LUIDS_EXHAUSTED\nERROR_MACHINE_LOCKED\nERROR_MAGAZINE_NOT_PRESENT\nERROR_MAPPED_ALIGNMENT\nERROR_MARKED_TO_DISALLOW_WRITES\nERROR_MARSHALL_OVERFLOW\nERROR_MAX_SESSIONS_REACHED\nERROR_MAX_THRDS_REACHED\nERROR_MCA_EXCEPTION\nERROR_MCA_OCCURED\nERROR_MEDIA_CHANGED\nERROR_MEDIA_CHECK\nERROR_MEMBER_IN_ALIAS\nERROR_MEMBER_IN_GROUP\nERROR_MEMBER_NOT_IN_ALIAS\nERROR_MEMBER_NOT_IN_GROUP\nERROR_MEMBERS_PRIMARY_GROUP\nERROR_MEMORY_HARDWARE\nERROR_MENU_ITEM_NOT_FOUND\nERROR_MESSAGE_SYNC_ONLY\nERROR_META_EXPANSION_TOO_LONG\nERROR_MISSING_SYSTEMFILE\nERROR_MOD_NOT_FOUND\nERROR_MORE_DATA\nERROR_MORE_WRITES\nERROR_MOUNT_POINT_NOT_RESOLVED\nERROR_MP_PROCESSOR_MISMATCH\nERROR_MR_MID_NOT_FOUND\nERROR_MULTIPLE_FAULT_VIOLATION\nERROR_MUTANT_LIMIT_EXCEEDED\nERROR_MUTUAL_AUTH_FAILED\nERROR_NEGATIVE_SEEK\nERROR_NESTING_NOT_ALLOWED\nERROR_NET_OPEN_FAILED\nERROR_NET_WRITE_FAULT\nERROR_NETLOGON_NOT_STARTED\nERROR_NETNAME_DELETED\nERROR_NETWORK_ACCESS_DENIED\n```\n\n----------------------------------------\n\nTITLE: Using the dump-mono-stats Compiler Flag in Rust\nDESCRIPTION: The `-Z dump-mono-stats` flag generates a file with monomorphized item statistics. It can accept an optional directory parameter for output location. This flag is useful for investigating compile times and understanding the size of codegen items.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/dump-mono-stats.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `dump-mono-stats`\n\n--------------------\n\nThe `-Z dump-mono-stats` compiler flag generates a file with a list of the monomorphized items in the current crate.\nIt is useful for investigating compile times.\n\nIt accepts an optional directory where the file will be located. If no directory is specified, the file will be placed in the current directory.\n\nSee also `-Z dump-mono-stats-format` and `-Z print-mono-items`. Unlike `print-mono-items`,\n`dump-mono-stats` aggregates monomorphized items by definition and includes a size estimate of how\nlarge the item is when codegened.\n\nSee <https://rustc-dev-guide.rust-lang.org/backend/monomorph.html> for an overview of monomorphized items.\n```\n\n----------------------------------------\n\nTITLE: Searching for Items by Name in Rustdoc\nDESCRIPTION: This snippet illustrates how to search for Rust items by their names or paths, demonstrating special cases in path formatting and providing examples of valid queries. It also explains the behavior of fuzzy matching for typos.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/read-documentation/search.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n* [`vec new`] and [`vec::new`] both show the function `std::vec::Vec::new` as a result.\n* [`vec`], [`vec vec`], [`std::vec`], and [`std::vec::Vec`] all include the struct `std::vec::Vec` itself in the results (and all but the last one also include the module in the results).\n```\n\n----------------------------------------\n\nTITLE: Reordering Impl Items to Match Trait Definition in Rust\nDESCRIPTION: Reorganizes the items within an impl block to follow the same order as the trait definition. This refactoring improves code consistency and readability by aligning implementation order with the trait specification order.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_104\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type A;\n    const B: u8;\n    fn c();\n}\n\nstruct Bar;\nimpl Foo for Bar {\n    const B: u8 = 17;\n    fn c() {}\n    type A = String;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    type A;\n    const B: u8;\n    fn c();\n}\n\nstruct Bar;\nimpl Foo for Bar {\n    type A = String;\n    const B: u8 = 17;\n    fn c() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Array Literal Formatting in Rust\nDESCRIPTION: Guidelines for creating and formatting array literals, including single-line, multi-line, and repeating initializer scenarios\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = [1, 2, 3];\n    let y = vec![a, b, c, d];\n    let a = [42; 10];\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Tuple Struct to Named Struct in Rust\nDESCRIPTION: Transforms a tuple struct into a struct with named fields, updating constructor and accessor methods accordingly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point { field1: f32, field2: f32 }\n\nimpl Point {\n    pub fn new(x: f32, y: f32) -> Self {\n        Point { field1: x, field2: y }\n    }\n\n    pub fn x(&self) -> f32 {\n        self.field1\n    }\n\n    pub fn y(&self) -> f32 {\n        self.field2\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Type Alias with Where Clause\nDESCRIPTION: Shows the formatting of trailing where clauses in type aliases, a new feature added in version 1.8.0.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntype Foo\n    = Bar\nwhere\n    A: B,\n    C: D;\n```\n\n----------------------------------------\n\nTITLE: Removing Nested Parentheses in Rust\nDESCRIPTION: Shows the effect of the remove_nested_parens option on nested parentheses in function calls.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_59\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    (foo());\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    (foo());\n\n    ((((foo()))));\n}\n```\n\n----------------------------------------\n\nTITLE: Block Style Alignment for Generics in Rust\nDESCRIPTION: Shows the default 'Block' alignment style for generic parameters. Each generic parameter is indented as a block, maintaining consistent alignment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nfn lorem<\n    Ipsum: Eq = usize,\n    Dolor: Eq = usize,\n    Sit: Eq = usize,\n    Amet: Eq = usize,\n    Adipiscing: Eq = usize,\n    Consectetur: Eq = usize,\n    Elit: Eq = usize,\n>(\n    ipsum: Ipsum,\n    dolor: Dolor,\n    sit: Sit,\n    amet: Amet,\n    adipiscing: Adipiscing,\n    consectetur: Consectetur,\n    elit: Elit,\n) -> T {\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Layout - Compressed\nDESCRIPTION: Illustrates the 'Compressed' layout for function parameters. Multiple parameters are kept on the same line even if it exceeds max width, and wrapping is done less aggressively than in `Tall` mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\ntrait Lorem {\n    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);\n\n    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {\n        // body\n    }\n\n    fn lorem(\n        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,\n        adipiscing: Adipiscing, elit: Elit,\n    );\n\n    fn lorem(\n        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,\n        adipiscing: Adipiscing, elit: Elit,\n    ) {\n        // body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Visual Style Alignment for Struct Literals in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for struct literals. Fields after the first line are aligned with the first field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = Lorem { ipsum: dolor,\n                        sit: amet };\n}\n```\n\n----------------------------------------\n\nTITLE: Exception to Lifetime Uniqueness Rule for Opaque Types in Rust\nDESCRIPTION: Discusses an exception to the uniqueness rule for lifetime parameters in opaque types when specific bounds require equality among lifetime parameters. This allows for scenarios where lifetimes are defined to be the same or the 'static lifetime, avoiding ambiguities in type inference.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// The definition requires `'x` to be equal to `'static`.\ntype Opaque<'x: 'static> = impl Sized + 'x;\n\nfn good() -> Opaque<'static> {}\n\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Type<'a>(&'a ());\nimpl<'a> Type<'a> {\n    // `'b == 'a`\n    fn do_stuff<'b: 'a>(&'b self) -> impl Trait<'a, 'b> {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Visual Alignment Style for Vector Declarations in Rust\nDESCRIPTION: Demonstrates the 'Visual' alignment style for declaring and initializing a vector. In this style, elements after the first line are aligned with the first element rather than being indented to the next block level.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lorem = vec![\"ipsum\",\n                     \"dolor\",\n                     \"sit\",\n                     \"amet\",\n                     \"consectetur\",\n                     \"adipiscing\",\n                     \"elit\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Functions for Sanitizer Instrumentation in Rust\nDESCRIPTION: This code snippet demonstrates how functions can be marked for exclusion from sanitizer instrumentation using the #[no_sanitize(...)] attribute in Rust. It allows fine-grained control over which functions are instrumented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/sanitizers.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[no_sanitize(...)]\n```\n\n----------------------------------------\n\nTITLE: Configuring disallowed-methods\nDESCRIPTION: Defines a list of disallowed methods, specified as fully qualified paths. Defaults to an empty list (`[]`). Allows enforcing rules against the use of specific methods.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Running cargo-fmt on a Project\nDESCRIPTION: This command demonstrates how to run cargo-fmt, potentially using a locally built version of rustfmt, on a specified project by providing a path to its `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Contributing.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nRUSTFMT=\"./target/debug/rustfmt\" cargo run --bin cargo-fmt -- --manifest-path path/to/project/you/want2test/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Incorrect Unwind Attribute Usage in Rust\nDESCRIPTION: Demonstrates an erroneous implementation of the unwind attribute with no arguments, which would trigger a compiler error\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0633.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unwind_attributes)]\\n\\n#[unwind()] // error: expected one argument\\npub extern \\\"C\\\" fn something() {}\\n\\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Customizing Semantic Token Styling in VS Code (JSON)\nDESCRIPTION: This JSON snippet demonstrates how to customize the visual appearance of semantic tokens in the VS Code editor. It allows the user to modify the style of elements like mutable bindings and unsafe operations within Rust code.  It depends on the VS Code editor and the Rust extension for VS Code.  The output modifies the appearance of semantic elements like setting a specific color or font style. The configuration is done in settings.json.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/editor_features.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"editor.semanticTokenColorCustomizations\": {\n    \"rules\": {\n      \"*.mutable\": {\n        \"fontStyle\": \"\", // underline is the default\n      },\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect `#[inline]` Attribute Placement in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the `#[inline]` attribute on a struct and an impl block in Rust. The `#[inline]` attribute can only be applied to functions or methods, not to structs or entire impl blocks. Applying it to these elements results in a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0518.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0518\n#[inline(always)]\nstruct Foo;\n\n#[inline(never)]\nimpl Foo {\n    // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Missing 'issue' Field in Stability Attributes (Error E0547)\nDESCRIPTION: This code example demonstrates the E0547 error that occurs when the 'issue' field is missing in stability attributes like #[unstable] and #[rustc_const_unstable]. The error occurs in the context of Rust's staged API feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0547.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[unstable(feature = \"_unstable_fn\")] // invalid\nfn _unstable_fn() {}\n\n#[rustc_const_unstable(feature = \"_unstable_const_fn\")] // invalid\nconst fn _unstable_const_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Using Rc as a Receiver Type with arbitrary_self_types in Rust\nDESCRIPTION: Shows how standard smart pointers like Rc can be used as receiver types. This works because Rc implements Deref, which has a blanket implementation of the Receiver trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/arbitrary-self-types.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types)]\n\nuse std::rc::Rc;\n\nstruct A;\n\nimpl A {\n    fn f(self: Rc<Self>) -> i32 { 1 } // Rc implements Deref\n}\n\nfn main() {\n    let smart_ptr = Rc::new(A);\n    assert_eq!(smart_ptr.f(), 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Playground URL in Rustdoc\nDESCRIPTION: Shows how to control the location of the Rust Playground used for the 'Run' buttons in documentation. This allows linking to a custom playground that may have specific dependencies required by your examples.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/\n```\n\n----------------------------------------\n\nTITLE: Building and Running HWAddressSanitizer Example\nDESCRIPTION: This shell script compiles the Rust code, including `-Zsanitizer=hwaddress` which activates the HWAddressSanitizer, and also specifies additional linker and target features.  This ensures that the code is compiled with the HWAddressSanitizer enabled and then executes the compiled program. The expected output includes an error message from the HWAddressSanitizer, indicating the memory error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_19\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustc main.rs -Zsanitizer=hwaddress -C target-feature=+tagged-globals -C\nlinker=aarch64-linux-gnu-gcc -C link-arg=-fuse-ld=lld --target\naarch64-unknown-linux-gnu\n```\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./main\n==241==ERROR: HWAddressSanitizer: tag-mismatch on address 0xefdeffff0050 at pc 0xaaaae0ae4a98\nREAD of size 4 at 0xefdeffff0050 tags: 2c/00 (ptr/mem) in thread T0\n    #0 0xaaaae0ae4a94  (/.../main+0x54a94)\n    ...\n\n[0xefdeffff0040,0xefdeffff0060) is a small allocated heap chunk; size: 32 offset: 16\n0xefdeffff0050 is located 0 bytes to the right of 16-byte region [0xefdeffff0040,0xefdeffff0050)\nallocated here:\n    #0 0xaaaae0acb80c  (/.../main+0x3b80c)\n    ...\n\nThread: T0 0xeffe00002000 stack: [0xffffc28ad000,0xffffc30ad000) sz: 8388608 tls: [0xffffaa10a020,0xffffaa10a7d0)\nMemory tags around the buggy address (one tag corresponds to 16 bytes):\n  0xfefcefffef80: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffef90: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffefa0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffefb0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffefc0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffefd0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffefe0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefcefffeff0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n=>0xfefceffff000: d7  d7  05  00  2c [00] 00  00  00  00  00  00  00  00  00  00\n  0xfefceffff010: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff020: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff030: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff040: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff050: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff060: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff070: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\n  0xfefceffff080: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00\nTags for short granules around the buggy address (one tag corresponds to 16 bytes):\n  0xfefcefffeff0: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\n=>0xfefceffff000: ..  ..  8c  ..  .. [..] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\n  0xfefceffff010: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\nSee https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags\nRegisters where the failure occurred (pc 0xaaaae0ae4a98):\n    x0  2c00efdeffff0050  x1  0000000000000004  x2  0000000000000004  x3  0000000000000000\n    x4  0000fffefc30ac37  x5  000000000000005d  x6  00000ffffc30ac37  x7  0000efff00000000\n    x8  2c00efdeffff0050  x9  0200efff00000000  x10 0000000000000000  x11 0200efff00000000\n    x12 0200effe00000310  x13 0200effe00000310  x14 0000000000000008  x15 5d00ffffc30ac360\n    x16 0000aaaae0ad062c  x17 0000000000000003  x18 0000000000000001  x19 0000ffffc30ac658\n    x20 4e00ffffc30ac6e0  x21 0000aaaae0ac5e10  x22 0000000000000000  x23 0000000000000000\n    x24 0000000000000000  x25 0000000000000000  x26 0000000000000000  x27 0000000000000000\n    x28 0000000000000000  x29 0000ffffc30ac5a0  x30 0000aaaae0ae4a98\nSUMMARY: HWAddressSanitizer: tag-mismatch (/.../main+0x54a94)\n```\n\n----------------------------------------\n\nTITLE: Blank Line Separation in Rust Functions\nDESCRIPTION: Illustrates the guideline for using zero or one blank lines between items and statements within functions to maintain consistent vertical spacing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/README.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    let x = ...;\n\n    let y = ...;\n    let z = ...;\n}\n\nfn bar() {}\nfn baz() {}\n```\n\n----------------------------------------\n\nTITLE: Mixed Early and Late Bound Function Definitions\nDESCRIPTION: Demonstrates different function types with both early and late bound lifetime parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/early_late_parameters.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn free_function<'a: 'a, 'b>(_: &'a (), _: &'b ()) {}\n\nstruct Foo;\n\ntrait Trait: Sized {\n    fn trait_method<'a: 'a, 'b>(self, _: &'a (), _: &'b ());\n    fn trait_function<'a: 'a, 'b>(_: &'a (), _: &'b ());\n}\n\nimpl Trait for Foo {\n    fn trait_method<'a: 'a, 'b>(self, _: &'a (), _: &'b ()) {}\n    fn trait_function<'a: 'a, 'b>(_: &'a (), _: &'b ()) {}\n}\n\nimpl Foo {\n    fn inherent_method<'a: 'a, 'b>(self, _: &'a (), _: &'b ()) {}\n    fn inherent_function<'a: 'a, 'b>(_: &'a (), _: &'b ()) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits with Const Bounds in Rust\nDESCRIPTION: This snippet shows the implementation of const traits 'Bar' and 'Foo'. It emphasizes the necessity of proving const conditions for the trait implementation to be considered well-formed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/effects.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[const_trait]\ntrait Bar {}\n#[const_trait]\ntrait Foo: ~const Bar {}\n\nimpl const Bar for () {}\nimpl const Foo for () {}\n```\n\n----------------------------------------\n\nTITLE: Trait definition in Rust\nDESCRIPTION: This snippet defines a trait `ConvertTo` with a type parameter `A` and a method `convertTo` that returns a value of type `A`. This example is used to illustrate variance and object types, showing how the subtyping relationship between object types like `&Trait<A>` and `&Trait<B>` is determined by the relationship of `A` and `B`. The example assumes the existence of `Object` and `String` types for demonstration purposes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/variance.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\ntrait ConvertTo<A> {\n    fn convertTo(&self) -> A;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Where Clause Single Line Example in Rust\nDESCRIPTION: Shows where clause formatting when where_single_line is set to true.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_82\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Lorem for T\nwhere Option<T>: Ipsum\n{\n    // body\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Glob Imports in Rust\nDESCRIPTION: Expands glob imports (use foo::*) into explicit imports listing each used item. Helps improve code readability by making imports explicit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    pub struct Bar;\n    pub struct Baz;\n}\n\nuse foo::*;\n\nfn qux(bar: Bar, baz: Baz) {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of In-Band Lifetimes in Rust Function Types\nDESCRIPTION: This code snippet demonstrates erroneous usage of in-band lifetimes in `fn` and `Fn` syntax. These examples are no longer valid in Rust as the feature has been removed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0687.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(in_band_lifetimes)]\n\nfn foo(x: fn(&'a u32)) {} // error!\n\nfn bar(x: &Fn(&'a u32)) {} // error!\n\nfn baz(x: fn(&'a u32), y: &'a u32) {} // error!\n\nstruct Foo<'a> { x: &'a u32 }\n\nimpl Foo<'a> {\n    fn bar(&self, x: fn(&'a u32)) {} // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Example of an Unterminated Rust Raw String Literal\nDESCRIPTION: This snippet demonstrates an invalid Rust raw string literal (`r##\"...\"##`). The `STRING` prefix likely indicates its context within a test or parser definition. The literal `r##\"🦀` is unterminated because it lacks the closing `\"##` sequence, leading to a compile-time error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_with_ferris.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nr##\"🦀\n```\n\n----------------------------------------\n\nTITLE: Declaring rustc_tools_util Dependencies\nDESCRIPTION: Configures both regular and build dependencies for rustc_tools_util in Cargo.toml.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/README.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrustc_tools_util = \"0.4.2\"\n\n[build-dependencies]\nrustc_tools_util = \"0.4.2\"\n```\n\n----------------------------------------\n\nTITLE: Hexadecimal Literal Case Control\nDESCRIPTION: Demonstrates configuration for controlling hexadecimal literal case\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Rust Diagnostic Data Structure Definition\nDESCRIPTION: Shows a MappedRustDiagnostic instance containing compiler error information about a type mismatch between usize and u32. Includes file location details, error code E0308, severity level, and related documentation links.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/rustc_mismatched_type.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n[\n    MappedRustDiagnostic {\n        url: Url {\n            scheme: \"file\",\n            cannot_be_a_base: false,\n            username: \"\",\n            password: None,\n            host: None,\n            port: None,\n            path: \"/test/runtime/compiler_support.rs\",\n            query: None,\n            fragment: None,\n        },\n        diagnostic: Diagnostic {\n            range: Range {\n                start: Position {\n                    line: 47,\n                    character: 64,\n                },\n                end: Position {\n                    line: 47,\n                    character: 69,\n                },\n            },\n            severity: Some(\n                Error,\n            ),\n            code: Some(\n                String(\n                    \"E0308\",\n                ),\n            ),\n            code_description: Some(\n                CodeDescription {\n                    href: Url {\n                        scheme: \"https\",\n                        cannot_be_a_base: false,\n                        username: \"\",\n                        password: None,\n                        host: Some(\n                            Domain(\n                                \"doc.rust-lang.org\",\n                            ),\n                        ),\n                        port: None,\n                        path: \"/error-index.html\",\n                        query: None,\n                        fragment: Some(\n                            \"E0308\",\n                        ),\n                    },\n                },\n            ),\n            source: Some(\n                \"rustc\",\n            ),\n            message: \"mismatched types\\nexpected usize, found u32\",\n            related_information: None,\n            tags: None,\n            data: None,\n        },\n        fix: None,\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for OpenHarmony Targets\nDESCRIPTION: This TOML configuration file configures Cargo to use the specified archiver (ar) and linker for the aarch64, armv7, and x86_64 OpenHarmony targets.  This ensures the correct tools from the OpenHarmony SDK are used during compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[target.aarch64-unknown-linux-ohos]\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nlinker = \"/path/to/aarch64-unknown-linux-ohos-clang.sh\"\n\n[target.armv7-unknown-linux-ohos]\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nlinker = \"/path/to/armv7-unknown-linux-ohos-clang.sh\"\n\n[target.x86_64-unknown-linux-ohos]\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nlinker = \"/path/to/x86_64-unknown-linux-ohos-clang.sh\"\n```\n\n----------------------------------------\n\nTITLE: Declaring External Variables in Rust\nDESCRIPTION: This snippet declares external variables with different values, indicating their existence outside the Rust environment, likely in external C code. These declarations are useful for accessing global variables defined elsewhere.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-c/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nextern variable value: 42\n```\n\nLANGUAGE: Rust\nCODE:\n```\nextern variable value: -42\n```\n\n----------------------------------------\n\nTITLE: Configuring Path Remapping in Rust Compiler\nDESCRIPTION: Example showing how to use --remap-path-prefix and --remap-path-scope flags to remap absolute paths in build outputs. The command remaps the current working directory to '/remapped' in object files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/remap-path-scope.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustc --remap-path-prefix=$(PWD)=/remapped -Zremap-path-scope=object main.rs\n```\n\n----------------------------------------\n\nTITLE: Duplicate Rust Feature Enablement\nDESCRIPTION: This code snippet demonstrates a compilation error (E0636) in Rust, triggered by enabling the same feature (`rust1`) multiple times using the `#![feature]` attribute.  The `#![allow(stable_features)]` attribute is used to allow the use of unstable features. The error message indicates that the feature has already been enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0636.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"#![allow(stable_features)]\\n#![feature(rust1)]\\n#![feature(rust1)] // error: the feature `rust1` has already been enabled\"\n```\n\n----------------------------------------\n\nTITLE: Example Output of git range-diff\nDESCRIPTION: Provides a visual example of the output from `git range-diff`, illustrating how it shows differences between commit ranges ('diff of diffs'), including changes in commit messages and file content, using markers like `-`, `+`, and `!`. Note that terminal output is typically colored for better readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n1:  c0debee = 2:  cab005e Add a helpful message at the start\n2:  f00dbal ! 3:  decafe1 Describe a bug\n    @@ -1,3 +1,3 @@\n     Author: A U Thor <author@example.com>\n\n    -TODO: Describe a bug\n    +Describe a bug\n    @@ -324,5 +324,6\n      This is expected.\n\n    -+What is unexpected is that it will also crash.\n    ++Unexpectedly, it also crashes. This is a bug, and the jury is\n    ++still out there how to fix it best. See ticket #314 for details.\n\n      Contact\n3:  bedead < -:  ------- TO-UNDO\n```\n\n----------------------------------------\n\nTITLE: Short Rust Code Fragment\nDESCRIPTION: A minimal code snippet with limited context and functionality\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/rustdoc/short-line.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ninc2\nx\n```\n\n----------------------------------------\n\nTITLE: Running benchmark tests with cargo bench\nDESCRIPTION: Shows the command and output for running benchmark tests in Rust using cargo bench. The output displays both regular tests (which are ignored during benchmarking) and the benchmark results with timing information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/test.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench\n   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n     Running target/release/adder-91b3e234d4ed382a\n\nrunning 2 tests\ntest tests::it_works ... ignored\ntest tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n\ntest result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n```\n\n----------------------------------------\n\nTITLE: Generating Project Documentation with Cargo\nDESCRIPTION: This snippet shows how to use Cargo to generate documentation for the entire project, which internally calls rustdoc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo doc\n```\n\n----------------------------------------\n\nTITLE: Demonstrate Unique Lifetime Parameters in Opaque Types in Rust\nDESCRIPTION: This snippet exemplifies the uniqueness restriction for lifetime parameters in opaque types, showcasing valid and invalid usages. Lifetimes must be unique and not 'static to avoid ambiguities in type inference. Key dependencies include the understanding of lifetime parameters and their role in generic type definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/opaque-types-region-inference-restrictions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x> = impl Sized + 'x;\ntype Inv<'a> = Option<*mut &'a ()>;\n\nfn good<'a>() -> Opaque<'a> { Inv::<'static>::None }\n\nfn bad() -> Opaque<'static> { Inv::<'static>::None }\n//~^ ERROR\n\n```\n\nLANGUAGE: rust\nCODE:\n```\ntype Opaque<'x, 'y> = impl Trait<'x, 'y>;\n\nfn good<'a, 'b>() -> Opaque<'a, 'b> {}\n\nfn bad<'a>() -> Opaque<'a, 'a> {}\n//~^ ERROR\n\n```\n\n----------------------------------------\n\nTITLE: Debugging with Source Code Display\nDESCRIPTION: Enhanced debugger launch command that includes source code paths for both Rust and Fuchsia\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_27\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\n    --symbol-path target/x86_64-unknown-fuchsia/debug \\\n    --build-dir ${RUST_SRC_PATH}/rust \\\n    --build-dir ${FUCHSIA_SRC_PATH}/fuchsia/out/default\n```\n\n----------------------------------------\n\nTITLE: Adding Warning Blocks in Markdown Documentation\nDESCRIPTION: This snippet demonstrates how to add a warning block in documentation using HTML within a Markdown file. Ensure to include an empty line between HTML tags and Markdown content for Markdown to render correctly inside HTML tags. No additional dependencies are required other than support for Markdown and basic HTML.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/how-to-write-documentation.md#2025-04-21_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n/// documentation\n///\n/// <div class=\"warning\">A big warning!</div>\n///\n/// more documentation\n```\n\n----------------------------------------\n\nTITLE: Correct usage of instruction_set with arm::t32 in Rust\nDESCRIPTION: This example demonstrates another valid usage of the instruction_set attribute with arm::t32 parameter for ARM architecture. It conditionally applies the attribute only when compiling for ARM targets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0778.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(isa_attribute)]\n\n#[cfg_attr(target_arch=\"arm\", instruction_set(arm::t32))]\nfn something() {}\n```\n\n----------------------------------------\n\nTITLE: Bitshift Error Example\nDESCRIPTION: Demonstrates code that triggers the exceeding_bitshifts deny-level lint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/lints/levels.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    100u8 << 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enhanced Reference Pattern Matching in Rust Edition 2024\nDESCRIPTION: Example showing new pattern matching capabilities with the ref_pat_eat_one_layer_2024 feature. Demonstrates matching & patterns against ref binding modes and &mut references with type checking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/ref-pat-eat-one-layer-2024.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ref_pat_eat_one_layer_2024)]\n#![allow(incomplete_features)]\n#\n# // Tests type equality in a way that avoids coercing `&&T` or `&mut T` to `&T`.\n# trait Eq<T> {}\n# impl<T> Eq<T> for T {}\n# fn has_type<T>(_: impl Eq<T>) {}\n\n// `&` can match against a `ref` binding mode instead of a reference type:\nlet (x, &y) = &(0, 1);\nhas_type::<&u8>(x);\nhas_type::<u8>(y);\n\n// `&` can match against `&mut` references:\nlet &z = &mut 2;\nhas_type::<u8>(z);\n```\n\n----------------------------------------\n\nTITLE: Correct Module Usage in Rust\nDESCRIPTION: Demonstrates proper module definition and access with static variable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0425.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\n----------------------------------------\n\nTITLE: Merging Raw Profiles with llvm-profdata\nDESCRIPTION: This shell command uses `llvm-profdata` to merge raw profile data files with the sparse option. The indexed `.profdata` output is used in conjunction with coverage maps to generate reports. The command requires a valid `.profraw` file as input, and generates a merged `.profdata` file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ llvm-profdata merge -sparse formatjson5.profraw -o formatjson5.profdata\n```\n\n----------------------------------------\n\nTITLE: Clang Wrapper Script for x86_64-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang compiler from the OpenHarmony SDK for the x86_64-unknown-linux-ohos target. It sets the target architecture, sysroot, and defines the __MUSL__ macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\n  -target x86_64-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Checking for Macro Expansion with from_expansion\nDESCRIPTION: Demonstrates how to check if code comes from a macro expansion using the Span.from_expansion() method to avoid linting macro-generated code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nif expr.span.from_expansion() {\n    // We most likely want to ignore it.\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging Issues with Rustbot Aliases\nDESCRIPTION: These are example commands using aliases to tag an issue as appropriate for a notification group using rustbot. Each command pings the Cleanup Crew. These aliases are defined in the `triagebot.toml` file and are intended for convenience, but are subject to change.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/about.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n@rustbot ping cleanup\n@rustbot ping bisect\n@rustbot ping reduce\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer Inlay Hints Options in JSON\nDESCRIPTION: Defines various flags and parameters controlling the display of inlay hints within rust-analyzer. This includes enabling or disabling hints for closing braces, closure captures and return types, generic parameters, implicit drops, lifetime elisions, parameter names, and type hints. The settings control when and how hints are shown (e.g., minimum lines before hints are displayed, whether to hide certain hints), and additional rendering options such as colon rendering and the maximum hint length. Dependencies include having rust-analyzer integrated in a Rust-supporting IDE. Inputs are configuration keys with boolean or string values, affecting the editor's hint rendering output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rust-analyzer.inlayHints.closingBraceHints.minLines\": 25,\n  \"rust-analyzer.inlayHints.closureCaptureHints.enable\": false,\n  \"rust-analyzer.inlayHints.closureReturnTypeHints.enable\": \"never\",\n  \"rust-analyzer.inlayHints.closureStyle\": \"impl_fn\",\n  \"rust-analyzer.inlayHints.discriminantHints.enable\": \"never\",\n  \"rust-analyzer.inlayHints.expressionAdjustmentHints.enable\": \"never\",\n  \"rust-analyzer.inlayHints.expressionAdjustmentHints.hideOutsideUnsafe\": false,\n  \"rust-analyzer.inlayHints.expressionAdjustmentHints.mode\": \"prefix\",\n  \"rust-analyzer.inlayHints.genericParameterHints.const.enable\": true,\n  \"rust-analyzer.inlayHints.genericParameterHints.lifetime.enable\": false,\n  \"rust-analyzer.inlayHints.genericParameterHints.type.enable\": false,\n  \"rust-analyzer.inlayHints.implicitDrops.enable\": false,\n  \"rust-analyzer.inlayHints.implicitSizedBoundHints.enable\": false,\n  \"rust-analyzer.inlayHints.lifetimeElisionHints.enable\": \"never\",\n  \"rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames\": false,\n  \"rust-analyzer.inlayHints.maxLength\": 25,\n  \"rust-analyzer.inlayHints.parameterHints.enable\": true,\n  \"rust-analyzer.inlayHints.rangeExclusiveHints.enable\": false,\n  \"rust-analyzer.inlayHints.reborrowHints.enable\": \"never\",\n  \"rust-analyzer.inlayHints.renderColons\": true,\n  \"rust-analyzer.inlayHints.typeHints.enable\": true,\n  \"rust-analyzer.inlayHints.typeHints.hideClosureInitialization\": false,\n  \"rust-analyzer.inlayHints.typeHints.hideClosureParameter\": false,\n  \"rust-analyzer.inlayHints.typeHints.hideNamedConstructor\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Auto Trait Declaration in Rust\nDESCRIPTION: This code snippet shows an erroneous declaration of an auto trait with an associated item, which is not allowed in Rust. The example is designed to fail compilation with error E0380.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0380.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunsafe auto trait Trait {\n    type Output; // error!\n}\n```\n\n----------------------------------------\n\nTITLE: Coroutine Trait Definition in Rust\nDESCRIPTION: Defines the core Coroutine trait with associated types for yield and return values, and the resume method signature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coroutines.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait Coroutine<R = ()> {\n    type Yield;\n    type Return;\n    fn resume(self: Pin<&mut Self>, resume: R) -> CoroutineState<Self::Yield, Self::Return>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Undefined Struct Example in Rust\nDESCRIPTION: Example showing a compilation error when trying to use an undefined struct 'Foo'. The code attempts to create a struct instance with fields x and y, but fails because 'Foo' is not defined.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0422.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Programs for LoongArch\nDESCRIPTION: This Shell command demonstrates how to build Rust programs targeting `loongarch64-unknown-linux-gnu` using `rustup`. It requires a LoongArch C/C++ toolchain for linking, especially for Rust crates depending on C code. Make sure to add the target before building.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/loongarch-linux.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nrustup target add loongarch64-unknown-linux-gnu\ncargo build --target loongarch64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Example Rust Analyzer Installation Output\nDESCRIPTION: Sample output showing the installation path of the rust-analyzer binary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/setup.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nInstalling <path-to-rust-analyzer-binary>\nInstalled package `rust-analyzer v0.0.0 (<path-to-rust-analyzer-binary>)` (executable `rust-analyzer.exe`)\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Source Files\nDESCRIPTION: This CMake command sets the variable `ASM_SOURCES` to a list of Assembly source files. These files will be assembled as part of the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(ASM_SOURCES\n    src/foo_asm.s\n    )\n```\n\n----------------------------------------\n\nTITLE: Reusing Error Line with Pipe Notation in Rust UI Tests\nDESCRIPTION: Demonstrates how to use the //~| idiom to define multiple errors on the same line as a previous error annotation, useful for cases with multiple errors at the same location.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Binder(i32, i32, i32);\n\nfn main() {\n    let x = Binder(1, 2, 3);\n    match x {\n        Binder(_a, _x @ ..) => {}  // <- the error is on this line\n        _ => {}\n    }\n}\n//~^^^^ ERROR `_x @` is not allowed in a tuple struct\n//~| ERROR this pattern has 1 field, but the corresponding tuple struct has 3 fields [E0023]\n```\n\n----------------------------------------\n\nTITLE: Creating rustup Toolchains\nDESCRIPTION: These commands create rustup toolchains linked to the stage0, stage1 and stage2 compilers built in the build directory.  This allows for easily switching between different compiler stages using `rustup`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain link stage0 build/host/stage0-sysroot # beta compiler + stage0 std\nrustup toolchain link stage1 build/host/stage1\nrustup toolchain link stage2 build/host/stage2\n```\n\n----------------------------------------\n\nTITLE: Undefined Behavior Example from Invalid Trait Object Casting in Rust\nDESCRIPTION: This example demonstrates how manually adding an auto trait to a trait object that doesn't satisfy the trait can lead to undefined behavior. The code creates an unsound transmutation that results in a crash when a method is called.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0804.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse core::{mem::transmute, ptr::NonNull};\n\ntrait Trait {\n    fn f(&self)\n    where\n        Self: Send;\n}\n\nimpl Trait for NonNull<()> {\n    fn f(&self) {\n        unreachable!()\n    }\n}\n\nfn main() {\n    let unsend: &dyn Trait = &NonNull::dangling();\n    let bad: &(dyn Trait + Send) = unsafe { transmute(unsend) };\n    // This crashes, since the vtable for `NonNull as dyn Trait` does\n    // not have an entry for `Trait::f`.\n    bad.f();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple #[main] Attribute Error in Rust\nDESCRIPTION: This code snippet illustrates the error that occurs when multiple functions are declared with the #[main] attribute. This is not allowed because there must be a unique entry point into a Rust program.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0137.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(main)]\n\n#[main]\nfn foo() {}\n\n#[main]\nfn f() {} // error: multiple functions with a `#[main]` attribute\n```\n\n----------------------------------------\n\nTITLE: Testing Clippy Lints Manually with Bash Commands\nDESCRIPTION: Commands to manually test Clippy with local modifications. These commands help you test a single file, an existing project, or set up a custom rustup toolchain for testing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev lint input.rs\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev lint /path/to/project\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo dev setup toolchain\n\n# Then in `/path/to/project` you can run\ncargo +clippy clippy\n```\n\n----------------------------------------\n\nTITLE: Implementing IsMatch for Lit\nDESCRIPTION: Illustrates an implementation of the IsMatch trait for the Lit enum to match against ast::LitKind nodes, using Rust's match statement. Relies on the Rust AST framework.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nimpl IsMatch<ast::LitKind> for Lit {\n    fn is_match(&self, other: &ast::LitKind) -> bool {\n        match (self, other) {\n            (Lit::Char(i), ast::LitKind::Char(j)) => i.is_match(j),\n            (Lit::Bool(i), ast::LitKind::Bool(j)) => i.is_match(j),\n            (Lit::Int(i), ast::LitKind::Int(j, _)) => i.is_match(j),\n            _ => false,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding target to bootstrap - Diff\nDESCRIPTION: This diff snippet illustrates how to add the new target triple to the 'STAGE0_MISSING_TARGETS' list in the Rust bootstrap sanity check to recognize the new target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\nconst STAGE0_MISSING_TARGETS: &[&str] = &[\n+   \"NEW_TARGET_TRIPLE\"\n];\n```\n\n----------------------------------------\n\nTITLE: Recursive Type with Projected Fields\nDESCRIPTION: A recursive structure that uses Cow to contain a slice of itself, demonstrating a case where coinduction is needed for type-checking recursive structures with projections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\npub struct Foo<'a>(Cow<'a, [Foo<'a>]>);\n```\n\n----------------------------------------\n\nTITLE: Enabling Target in Rust Build Configuration\nDESCRIPTION: Configuration for adding powerpc64-unknown-linux-musl target to Rust build process, specifying the target in build settings\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64-unknown-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"powerpc64-unknown-linux-musl\"]\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Configuration - Rust Test Timing\nDESCRIPTION: Demonstrates the format for setting test execution time thresholds using environment variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/report-time.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nRUST_TEST_TIME_UNIT=100,200\n```\n\n----------------------------------------\n\nTITLE: Forcing Inlining with #[doc(inline)] in Rust\nDESCRIPTION: This code demonstrates how to force an item to be inlined using the `#[doc(inline)]` attribute. Even though `public_mod::Public` is already public, using `#[doc(inline)]` on its re-export causes it to be displayed both at the crate root and in the `public_mod` module in the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/re-exports.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n```rust\npub mod public_mod {\n    pub struct Public;\n}\n#[doc(inline)]\npub use self::public_mod::Public;\n```\n```\n\n----------------------------------------\n\nTITLE: Markdown Links Rendering in Rustdoc\nDESCRIPTION: This snippet shows various ways to create links in markdown and how they are rendered in the documentation. It illustrates the discrepancies in rendering based on the type of link used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n1. [a]\n2. [b][c]\n3. [d](e)\n4. [f]\n\n[f]: g\n```\n\n----------------------------------------\n\nTITLE: Structuring Type Declarations in Rust\nDESCRIPTION: Shows the preferred top-down manner of organizing type declarations, with structs and enums first, followed by their implementations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nstruct Parent {\n    children: Vec<Child>\n}\n\nstruct Child;\n\nimpl Parent {\n}\n\nimpl Child {\n}\n\n// BAD\nstruct Child;\n\nimpl Child {\n}\n\nstruct Parent {\n    children: Vec<Child>\n}\n\nimpl Parent {\n}\n```\n\n----------------------------------------\n\nTITLE: Console Output Example for Simple Error\nDESCRIPTION: Example console output showing how a simple error with suggestion is formatted in the terminal.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ rustc mycode.rs\nerror[E0999]: oh no! this is an error!\n --> mycode.rs:3:5\n  |\n3 |     sad()\n  |     ^ help: try using a qux here: `qux sad()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0999`.\n```\n\n----------------------------------------\n\nTITLE: Correct Intrinsic Function Definition in Rust\nDESCRIPTION: Proper implementation of the unreachable intrinsic function with the correct return type of never (!).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0211.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn unreachable() -> !; // ok!\n```\n\n----------------------------------------\n\nTITLE: Test Output Example\nDESCRIPTION: Example of the test harness output showing the format of test results including passed, failed, ignored, and measured tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/tests/index.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrunning 4 tests\ntest it_works ... ok\ntest check_valid_args ... ok\ntest invalid_characters ... ok\ntest walks_the_dog ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Documentation Style Guidelines in Rust\nDESCRIPTION: Shows proper documentation formatting with complete sentences, starting with capital letters and ending with periods. This approach encourages more detailed context in comments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\n// Only simple single segment paths are allowed.\nMergeBehavior::Last => {\n    tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Using multiple options with --extern flag in Rust\nDESCRIPTION: This example shows how to use multiple options (noprelude, priv, and nounused) with the --extern flag for a dependency. Options are separated by commas.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/extern-options.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nrustc main.rs -Z unstable-options --extern noprelude,priv,nounused:mydep=mydep.rlib\n```\n\n----------------------------------------\n\nTITLE: Running rustc with a Specific Toolchain\nDESCRIPTION: This command demonstrates how to run the compiled `rustc` using a specific rustup toolchain (`stage1`). The `-vV` flag displays the compiler version and other details.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc +stage1 -vV\nrustc 1.48.0-dev\nbinary: rustc\ncommit-hash: unknown\ncommit-date: unknown\nhost: x86_64-unknown-linux-gnu\nrelease: 1.48.0-dev\nLLVM version: 11.0\n```\n\n----------------------------------------\n\nTITLE: Unterminated Raw String Literal in Rust\nDESCRIPTION: An example of a Rust compilation error caused by a raw string literal that doesn't have the correct termination sequence. The raw string starts with 'r##\"' and includes an escape sequence '\\x7f', but is missing the closing '\"##' delimiter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_string_with_ascii_escape.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nr##\"\\x7f\n```\n\n----------------------------------------\n\nTITLE: Configuring Min Identifier Chars Threshold in Rust\nDESCRIPTION: This option sets the minimum number of characters an identifier can have before the `min_ident_chars` lint is triggered. Identifiers with fewer or equal characters will be linted. The default value is `1`. This uses an integer to specify the minimum acceptable identifier length.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/lint_configuration.md#_snippet_31\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating the Difference Between Lazy and Eager Macro Expansion in Rust\nDESCRIPTION: This code snippet illustrates the concept of lazy vs eager macro expansion using two simple macros. In eager expansion, nested macros like bar! would be expanded before the outer foo! macro, while lazy expansion would do the opposite.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro bar($i: ident) { $i }\nmacro foo($i: ident) { $i }\n\nfoo!(bar!(baz));\n```\n\n----------------------------------------\n\nTITLE: Handling Empty Link Name Annotation in Rust\nDESCRIPTION: This snippet shows an incorrect use of the link attribute in Rust, where the 'name' parameter is empty, leading to a compilation error. The Rust compiler requires a valid library name to link external libraries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0454.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[link(name = \"\")] extern \"C\" {}\n// error: `#[link(name = \"\")]` given with empty name\n```\n\n----------------------------------------\n\nTITLE: Cross-compiling with Cargo for s390x\nDESCRIPTION: This snippet shows how to cross-compile a Rust crate for the `s390x-unknown-linux-gnu` target using Cargo. By specifying the `--target` flag, Cargo will build the crate using the appropriate toolchain for the target architecture. This allows you to create executables that can run on s390x Linux systems.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n\n```bash\ncargo build --target s390x-unknown-linux-gnu\n```\n\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Program for Apple tvOS Target\nDESCRIPTION: Command-line example for compiling a Rust program specifically for the aarch64-apple-tvos target architecture using rustc compiler with explicit target specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-tvos.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --target aarch64-apple-tvos your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Variadic C Function in Rust\nDESCRIPTION: This example demonstrates an incorrect usage of C's printf function in Rust, which fails because it doesn't provide the minimum required argument (format string).\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0060.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::os::raw::{c_char, c_int};\n\nextern \"C\" {\n    fn printf(_: *const c_char, ...) -> c_int;\n}\n\nunsafe { printf(); } // error!\n```\n\n----------------------------------------\n\nTITLE: Correct intrinsic function declaration with proper number of type parameters\nDESCRIPTION: This snippet shows the correct way to declare the 'size_of' intrinsic function in Rust, using only a single type parameter as expected. It shares the same feature flags and attribute as the incorrect example but ensures proper parameter count, resolving error E0094. This serves as a reference for proper intrinsic function declarations in Rust with the required number of generic parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0094.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nfn size_of<T>() -> usize; // ok!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reachability with Empty Types in Unsafe Rust\nDESCRIPTION: This snippet shows how a wildcard pattern can be reachable even when matching on a place of an empty type, due to unsafe code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/pat-exhaustive-checking.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum Void {}\nlet x: u8 = 0;\nlet ptr: *const Void = &x as *const u8 as *const Void;\nunsafe {\n    match *ptr {\n        _ => println!(\"Reachable!\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Script in Cargo.toml\nDESCRIPTION: Specifies the build script configuration in Cargo.toml to enable version information generation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/rustc_tools_util/README.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nbuild = \"build.rs\"\n```\n\n----------------------------------------\n\nTITLE: Rust Code Example: Heap Buffer Overflow\nDESCRIPTION: This Rust code snippet demonstrates a heap buffer overflow by accessing an element outside the bounds of a vector using pointer arithmetic. The `offset(4)` call attempts to read memory beyond the vector's allocated space.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let xs = vec![0, 1, 2, 3];\n    let _y = unsafe { *xs.as_ptr().offset(4) };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Target Features Example in Rust\nDESCRIPTION: Example showing problematic target features '+soft-float' and '-sse' on x86/x86-64 architectures, which can cause segfaults and ABI mismatches due to floating point register handling conflicts between software emulated floats and standard library expectations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/targets/known-issues.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Target-Feature | Issue | Seen on | Description | Details |\n| -------------- | ----- | ------- | ----------- | ------- |\n| `+soft-float` <br> and <br> `-sse` | Segfaults and ABI mismatches | `x86` and `x86-64` | The `x86` and `x86_64` architecture uses SSE registers (aka `xmm`) for floating point operations. Using software emulated floats (\"soft-floats\") disables usage of `xmm` registers, but parts of Rust's core libraries (e.g. `std::f32` or `std::f64`) are compiled without soft-floats and expect parameters to be passed in `xmm` registers. This leads to ABI mismatches. <br><br>  Attempting to compile with disabled SSE causes the same error, too. | [#63466](https://github.com/rust-lang/rust/issues/63466) |\n```\n\n----------------------------------------\n\nTITLE: Handling TODO Comments in Rust Code\nDESCRIPTION: This snippet illustrates the usage of TODO comments in Rust code as reminders for incomplete implementations. It shows how the tidy script can enforce the absence of TODO comments before landing the PR, alongside an example of its usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/conventions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn do_something() {\n    if something_else {\n        unimplemented!(); // TODO write this\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nif foo {\n    return true; // TODO wrong, but will be fixed in a later commit\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait for a Static Lifetime in Rust\nDESCRIPTION: This snippet defines a struct `StaticInt` and implements the `Foo` trait for it, specifically for references to `isize` with the `'static` lifetime. This is used to illustrate a failure case in higher-ranked trait bound matching.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/hrtb.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct StaticInt;\nimpl Foo<&'static isize> for StaticInt;\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall functions in Rust\nDESCRIPTION: Demonstrates calling fastcall functions with different arguments including a struct `S` and an integer. This showcases how `fastcall_fn_5` and `fastcall_fn_7` are invoked with specific data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.msvc.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_5(S { x: 1, y: 2 }, 16)\nfastcall_fn_7(S2 { x: 15, y: 16 }, 3)\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of DiscoverArgument::Buildfile for Workspace Discovery\nDESCRIPTION: JSON example representing the 'Buildfile' variant of DiscoverArgument serialized for passing to the rust-analyzer workspace discovery command. It includes the buildfile key with the filename.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/configuration_generated.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"buildfile\": \"BUILD\"\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Struct in Rust\nDESCRIPTION: The snippet illustrates the declaration of a struct named 'Struct', complete with ID and location metadata. This allows for the organization of related data characteristics into manageable entities in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"Struct\",\n    def: Adt(\n        Struct(\n            Struct {\n                id: StructId(\n                    1,\n                ),\n            },\n        ),\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: STRUCT,\n            range: 170..184,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 177..183,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Custom is_null Implementation Example in Rust\nDESCRIPTION: Example showing how arbitrary_self_types feature allows custom is_null implementations that could cause ambiguity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0699.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Foo {\n    fn is_null(self: *const Self) -> bool {\n        // do something else\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Stack Usage Issues with Unsized Locals in Rust\nDESCRIPTION: These snippets illustrate potential pitfalls in stack usage when using unsized locals. They show how unnecessary stack frame extensions can occur with nested blocks or loops, which developers should be aware of when using this feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_locals)]\n\nfn main() {\n    let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n    let _x = {{{{{{{{{{*x}}}}}}}}}};\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_locals)]\n\nfn main() {\n    for _ in 0..10 {\n        let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n        let _x = *x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exported Variable with Value -42 in Rust\nDESCRIPTION: Declares a public variable with the value -42, accessible outside the module or crate. It may be used as a constant or default value within the codebase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-link-ordinal/output.txt#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nexported_variable value: -42\n```\n\n----------------------------------------\n\nTITLE: Erroneous Private Type in Public Trait Implementation\nDESCRIPTION: Demonstrates incorrect usage of a private type Bar in a public trait's associated type signature, which triggers error E0446.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0446.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Bar;\n\npub trait PubTr {\n    type Alias;\n}\n\nimpl PubTr for u8 {\n    type Alias = Bar; // error private type in public interface\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Type Ascription over Turbofish in Rust\nDESCRIPTION: Demonstrates the preference for using type ascription over the turbofish syntax in Rust, avoiding the use of '_' in type ascriptions for better readability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/style.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nlet mutable: Vec<T> = old.into_iter().map(|it| builder.make_mut(it)).collect();\n\n// BAD\nlet mutable: Vec<_> = old.into_iter().map(|it| builder.make_mut(it)).collect();\n\n// BAD\nlet mutable = old.into_iter().map(|it| builder.make_mut(it)).collect::<Vec<_>>();\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol for Inherent Impl Function in Rust\nDESCRIPTION: This example explains the mangled symbol for the function `foo` in an inherent implementation in the `Example` struct, breaking down the components into path and disambiguator representations. It includes recommendations for demangling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n_RNvMs_Cs4Cv8Wi1oAIB_7mycrateNtB4_7Example3foo\n```\n\n----------------------------------------\n\nTITLE: Invalid Multi-Field Struct with SIMD Attribute\nDESCRIPTION: Example showing incorrect usage of #[repr(simd)] on a struct with multiple fields, which will result in compilation error E0075.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0075.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad([u32; 1], [u32; 1]); // error!\n```\n\n----------------------------------------\n\nTITLE: JavaScript Search Test Definition\nDESCRIPTION: This JavaScript code defines the `EXPECTED` variable, which specifies the search queries and expected results for the test. The test checks if the `constructor` function can be found with different queries and in different search tabs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// tests/rustdoc-js/constructor_search.js\n// exact-check\n// Since this test runs against its own crate,\n// new items should not appear in the search results.\nconst EXPECTED = [\n  // This first test targets name-based search.\n  {\n    query: \"constructor\",\n    others: [\n      { path: \"constructor_search\", name: \"constructor\" },\n    ],\n    in_args: [],\n    returned: [],\n  },\n  // This test targets the second tab.\n  {\n    query: \"str\",\n    others: [],\n    in_args: [\n      { path: \"constructor_search\", name: \"constructor\" },\n    ],\n    returned: [],\n  },\n  // This test targets the third tab.\n  {\n    query: \"i32\",\n    others: [],\n    in_args: [],\n    returned: [\n      { path: \"constructor_search\", name: \"constructor\" },\n    ],\n  },\n  // This test targets advanced type-driven search.\n  {\n    query: \"str -> i32\",\n    others: [\n      { path: \"constructor_search\", name: \"constructor\" },\n    ],\n    in_args: [],\n    returned: [],\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Super Trait Cycles Requiring Careful Coinduction Handling\nDESCRIPTION: Example demonstrating an issue with super trait relationships that would be unsound if coinduction were implemented naively without considering trait relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait: SuperTrait {}\n\nimpl<T: Trait> Trait for T {}\n\n// Keeping the current setup for coinduction\n// would allow this compile. Uff :<\nfn sup<T: SuperTrait>() {}\nfn requires_trait<T: Trait>() { sup::<T>() }\nfn generic<T>() { requires_trait::<T>() }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SIGPIPE error handling in Rust\nDESCRIPTION: Example program showing how -Zon-broken-pipe=error affects program behavior when writing to a closed pipe. The program will receive an ErrorKind::BrokenPipe error instead of being terminated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/on-broken-pipe.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        println!(\"hello world\");\n    }\n}\n```\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -Zon-broken-pipe=error main.rs\n$ ./main | head -n1\nhello world\nthread 'main' panicked at library/std/src/io/stdio.rs:1118:9:\nfailed printing to stdout: Broken pipe (os error 32)\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Drop Check with Invalid References\nDESCRIPTION: Example showing how drop checking allows values to be dropped even when their type is not well-formed due to invalid references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/drop_check.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = vec![];\n    {\n        let y = String::from(\"I am temporary\");\n        x.push(&y);\n    }\n    // `x` goes out of scope here, after the reference to `y`\n    // is invalidated. This means that while dropping `x` its type\n    // is not well-formed as it contain regions which are not live.\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Borrowing Leading to Lifetime Error in Rust\nDESCRIPTION: This snippet demonstrates a common lifetime error in Rust, where a value is borrowed longer than it lives. A struct `Foo` contains an optional reference that fails when the referenced value is prematurely dropped. This example leads to a compile-time error because the reference outlives the value it points to.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0597.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\n{\n    let y = 0;\n    x.x = Some(&y); // error: `y` does not live long enough\n}\nprintln!(\"{:?}\", x.x);\n```\n\n----------------------------------------\n\nTITLE: Defining cdecl Functions in Rust\nDESCRIPTION: This snippet defines several functions using the cdecl calling convention, which is used for calling functions in C. It includes multiple function signatures with varying prefixes and decorations. No special dependencies are required aside from the Rust environment itself.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-import-name-type/output.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nLooksLikeAPrivateGlobal(13)\ncdecl_fn_undecorated(1)\ncdecl_fn_undecorated2(10)\ncdecl_fn_noprefix(2)\ncdecl_fn_decorated(3)\n```\n\n----------------------------------------\n\nTITLE: Declaring an Intrinsic with Fallback Logic in Rust\nDESCRIPTION: Example of defining a constant deallocate intrinsic with fallback logic. This implementation provides a default empty body that backends can override if needed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/intrinsics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nconst unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}\n```\n\n----------------------------------------\n\nTITLE: Coroutine State Machine Implementation Example in Rust\nDESCRIPTION: Shows how coroutines are compiled into state machines with an example implementation including state transitions and storage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/coroutines.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(arbitrary_self_types, coroutine_trait)]\n\nuse std::ops::{Coroutine, CoroutineState};\nuse std::pin::Pin;\n\nfn main() {\n    let ret = \"foo\";\n    let mut coroutine = {\n        enum __Coroutine {\n            Start(&'static str),\n            Yield1(&'static str),\n            Done,\n        }\n\n        impl Coroutine for __Coroutine {\n            type Yield = i32;\n            type Return = &'static str;\n\n            fn resume(mut self: Pin<&mut Self>, resume: ()) -> CoroutineState<i32, &'static str> {\n                use std::mem;\n                match mem::replace(&mut *self, __Coroutine::Done) {\n                    __Coroutine::Start(s) => {\n                        *self = __Coroutine::Yield1(s);\n                        CoroutineState::Yielded(1)\n                    }\n\n                    __Coroutine::Yield1(s) => {\n                        *self = __Coroutine::Done;\n                        CoroutineState::Complete(s)\n                    }\n\n                    __Coroutine::Done => {\n                        panic!(\"coroutine resumed after completion\")\n                    }\n                }\n            }\n        }\n\n        __Coroutine::Start(ret)\n    };\n\n    Pin::new(&mut coroutine).resume(());\n    Pin::new(&mut coroutine).resume(());\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Enum Alignment Representation in Rust\nDESCRIPTION: Demonstrates a compilation error when specifying an invalid alignment value that is not a power of two for a Rust enum. The compiler enforces strict alignment requirements to ensure memory layout consistency.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0589.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two\nenum Foo {\n    Bar(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Linker Arguments in Rust\nDESCRIPTION: Appends multiple extra arguments to the linker invocation. The options should be separated by spaces.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/codegen-options/index.md#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Checking for Non-Executable Memory Regions in Rust Binaries\nDESCRIPTION: Example showing how to verify if non-executable memory regions are enabled for a Rust binary by examining the GNU_STACK program header. The absence of the PF_X flag indicates non-executable stack.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     0x10\n```\n\n----------------------------------------\n\nTITLE: Single-Line Tuple Struct Definition in Rust\nDESCRIPTION: Illustrates the formatting of single-line tuple struct definitions in Rust.  Shows how to separate types using a comma and space.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/items.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub struct Foo(String, u8);\n```\n\n----------------------------------------\n\nTITLE: Invalid Link Attribute Kind Example in Rust\nDESCRIPTION: Demonstrates incorrect usage of the link attribute's kind parameter by specifying an invalid value 'wonderful_unicorn'. This code will fail to compile with error E0458.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0458.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[link(kind = \"wonderful_unicorn\")] extern \"C\" {}\n// error: unknown kind: `wonderful_unicorn`\n```\n\n----------------------------------------\n\nTITLE: Multiple Argument Function with Closure - Rust\nDESCRIPTION: Demonstrates formatting for functions with multiple arguments where the last argument is a multi-line closure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nfoo(first_arg, x, |param| {\n    action();\n    foo(param)\n})\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Relocation Models\nDESCRIPTION: Demonstrates how to list available relocation models using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print relocation-models a.rs\nAvailable relocation models:\n    static\n    pic\n    pie\n    dynamic-no-pic\n    ropi\n    rwpi\n    ropi-rwpi\n    default\n```\n\n----------------------------------------\n\nTITLE: Declaring Array with Non-Constant Value in Rust\nDESCRIPTION: This snippet demonstrates an incorrect attempt to declare a Rust array using a non-constant value, which results in a compile-time error. It highlights the need for compile-time values when defining array sizes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0435.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet foo = 42;\nlet a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n```\n\n----------------------------------------\n\nTITLE: Implementing an Early Lint Pass in Clippy\nDESCRIPTION: Example of a lint implementation structure showing how the 'ElseIfWithoutElse' struct is defined and implements the EarlyLintPass trait. Early lint passes operate on AST information before type checking occurs.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// ./clippy_lints/src/else_if_without_else.rs\n\nuse rustc_lint::{EarlyLintPass, EarlyContext};\n\n// ...\n\npub struct ElseIfWithoutElse;\n\n// ...\n\nimpl EarlyLintPass for ElseIfWithoutElse {\n    // ... the functions needed, to make the lint work\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Hierarchy and Where Clause Resolution\nDESCRIPTION: Demonstrates trait inheritance and where clause resolution, showing how subtrait obligations can be resolved through parameter environment constraints\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/resolution.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntrait A1 {\n    fn do_a1(&self);\n}\ntrait A2 : A1 { ... }\n\ntrait B {\n    fn do_b(&self);\n}\n\nfn foo<X:A2+B>(x: X) {\n    x.do_a1(); // (*)\n    x.do_b();  // (#)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Intrinsic Function Declaration in Rust\nDESCRIPTION: Example of an incorrect intrinsic function declaration that results in compilation error E0093. Shows what happens when declaring an unrecognized intrinsic function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0093.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nunsafe fn foo(); // error: unrecognized intrinsic function: `foo`\n\nfn main() {\n    unsafe {\n        foo();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Higher Ranked Function Pointer Example\nDESCRIPTION: Demonstrates the complexities of handling bound variables in function pointers with different lifetimes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/instantiating_binders.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(a: &'a u32) -> &'a u32 {\n    a\n}\nfn bar<T>(a: fn(&u32) -> T) -> T {\n    a(&10)\n}\n\nfn main() {\n    let higher_ranked_fn_ptr = foo as for<'a> fn(&'a u32) -> &'a u32;\n    let references_bound_vars = bar(higher_ranked_fn_ptr);\n}\n```\n\n----------------------------------------\n\nTITLE: Using crate-attr Flag for Crate Name Injection in Rust\nDESCRIPTION: Example showing how to use the `-Z crate-attr` flag to inject a crate_name attribute into the crate root, equivalent to adding `#![crate_name=\"test\"]` at the beginning of the source file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/crate-attr.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name=\"test\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Hidden Visibility in Rust Compilation\nDESCRIPTION: Uses the `-Zdefault-visibility=hidden` flag to set symbol visibility to hidden, preventing symbol export from shared objects. This is similar to Clang's `-fvisibility=hidden` flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/default-visibility.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Zdefault-visibility=hidden\n```\n\n----------------------------------------\n\nTITLE: Defining extern \"C\" Functions in C\nDESCRIPTION: This C code snippet defines the equivalent `take_my_pair` function using a struct `my_pair`. It highlights the ABI discrepancy where the C function receives a single parameter compared to Rust's two.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nstruct my_pair {\n    unsigned a;\n    unsigned b;\n};\n\nunsigned take_my_pair(struct my_pair pair) {\n    return pair.a + pair.b;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of #[lang] Attribute on Static Item in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect application of the #[lang = \"owned_box\"] attribute on a static item, which leads to a compilation error E0718. The #[lang] attribute is intended for specific language items and should not be used on static variables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0718.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(lang_items)]\n\n#[lang = \"owned_box\"]\nstatic X: u32 = 42;\n```\n\n----------------------------------------\n\nTITLE: Line Index Usage Example\nDESCRIPTION: This code snippet demonstrates how to use the `LineIndex` struct to convert between text offsets and line/column coordinates. It creates a `LineIndex` from a string, and then uses `line_col` to get the line and column from an offset, and `offset` to get the offset from a line and column. The `into()` method is used to convert the numerical offset to the correct type for the `line_col` method.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/lib/line-index/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse line_index::LineIndex;\n\nlet line_index = LineIndex::new(\"This is a\\nmulti-line\\ntext.\");\nline_index.line_col(3.into()); // LineCol { line: 0, col: 3 }\nline_index.line_col(13.into()); // LineCol { line: 1, col: 3 }\nline_index.offset(LineCol { line: 2, col: 3 }); // Some (24)\n```\n\n----------------------------------------\n\nTITLE: Unsafe Handling of Cell Types in Rust\nDESCRIPTION: This example introduces an unsafe approach to handle Cell types by wrapping them and implementing Sync manually. Though it allows static usage, care must be taken to synchronize access appropriately to prevent race conditions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0492.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::Cell;\n\nstruct NotThreadSafe<T> {\n    value: Cell<T>,\n}\n\nunsafe impl<T> Sync for NotThreadSafe<T> {}\n\nstatic A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\nstatic B: &'static NotThreadSafe<usize> = &A; // ok!\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Rebase Autostash Globally\nDESCRIPTION: Sets the global Git configuration option `rebase.autostash` to `true`. This automatically creates a temporary stash before a rebase begins and reapplies it after the rebase completes, helping to avoid \"cannot rebase: You have unstaged changes\" errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global rebase.autostash true\n```\n\n----------------------------------------\n\nTITLE: Configuring Rustfmt with inline_attribute_width option\nDESCRIPTION: Example configuration option to write an item and its attribute on the same line if their combined width is below a threshold.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_22\n\nLANGUAGE: TOML\nCODE:\n```\ninline_attribute_width = 80\n```\n\n----------------------------------------\n\nTITLE: Merging Imports in Rust\nDESCRIPTION: Demonstrates the effect of merging imports into a single use statement with the same visibility.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_54\n\nLANGUAGE: rust\nCODE:\n```\npub use foo::{x, y};\nuse {\n    bar:{\n        a,\n        b::{self, f, g},\n        c,\n        d::e,\n    },\n    qux::{h, i},\n};\n```\n\n----------------------------------------\n\nTITLE: Using LLD Linker with Self-Contained Linking\nDESCRIPTION: Example command showing how to enable the LLD linker with self-contained linking in Rust. This approach uses the `rust-lld` linker from the toolchain rather than a system-installed binary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/linker-features.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n-Clinker-features=+lld -Clink-self-contained=+linker\n```\n\n----------------------------------------\n\nTITLE: Installing rustfilt demangler for Rust symbol names\nDESCRIPTION: Command to install rustfilt, a tool that demangles Rust's mangled symbol names in coverage reports to make them more readable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install rustfilt\n```\n\n----------------------------------------\n\nTITLE: Compiled WebAssembly module from Rust\nDESCRIPTION: This WebAssembly module, compiled from the Rust code, demonstrates the ABI mismatch where Rust expects two i32 parameters for the `take_my_pair` function while the C version only expects one.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-unknown.md#2025-04-21_snippet_8\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (import \"env\" \"take_my_pair\" (func $take_my_pair (param i32 i32) (result i32)))\n  (func $call_c\n    i32.const 1\n    i32.const 2\n    call $take_my_pair\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Baremetal Rust Executable for Hexagon Standalone OS (Rust)\nDESCRIPTION: Demonstrates a minimal `no_std`, `no_main` Rust program for the Hexagon target using `extern \"C\"` functions (`putchar`, `_exit`) likely provided by a C library or runtime for console output via semihosting and program termination. It defines a custom `main` function as the entry point and includes a basic panic handler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![no_std]\n#![no_main]\n\nextern \"C\" {\n    fn putchar(ch: i32);\n    fn _exit(code: i32) -> !;\n}\n\n#[no_mangle]\nextern \"C\" fn main() -> i32 {\n    let message = \"Hello, this is Rust!\";\n    for b in message.bytes() {\n        unsafe {\n            putchar(b as i32);\n        }\n    }\n    0\n}\n\n#[panic_handler]\nfn panic(_panic: &core::panic::PanicInfo) -> ! {\n    unsafe {\n        _exit(1);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Dependency Graph Edges\nDESCRIPTION: This snippet describes the output format when displaying the edges of the dependency graph containing paths that should not exist. It helps in visualizing the connections and understanding the dependencies better.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nHir(foo) -> Collect(bar)\nCollect(bar) -> TypeckTables(bar)\n```\n\n----------------------------------------\n\nTITLE: Rust Test Directives Substitution Example\nDESCRIPTION: Example of using path substitution in compiler test flags to remap source paths dynamically\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/directives.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//@ compile-flags: --remap-path-prefix={{src-base}}=/the/src\n```\n\n----------------------------------------\n\nTITLE: Invalid Generic Receiver Type Example 2 (Using impl Trait)\nDESCRIPTION: Another example of invalid code that generates error E0801 by attempting to use 'impl Trait' as the receiver type for a method, which is also not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0801.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\n\nimpl Foo {\n    fn foo(self: impl std::ops::Deref<Target=Self>) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Verbose Output\nDESCRIPTION: This code snippet illustrates how to use the `-v` or `--verbose` flag to enable verbose mode in rustdoc, providing more detailed output to the standard output. The content of the output depends on the other flags used.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc -v src/lib.rs\n$ rustdoc --verbose src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Invalid Rust Linkage Example\nDESCRIPTION: Demonstrates an invalid usage of the #[linkage] attribute with a non-pointer i8 type, which will result in error E0791.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0791.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(linkage)]\n\nextern \"C\" {\n    #[linkage = \"extern_weak\"]\n    static foo: i8;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Derive Attribute to Struct in Rust\nDESCRIPTION: This snippet shows how to add a new #[derive()] clause to a struct or enum. It inserts the derive attribute just above the struct definition, ready for the user to specify which traits to derive.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_45\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: u32,\n    y: u32,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive()]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU RISC-V Emulator on Ubuntu\nDESCRIPTION: Command to install QEMU system emulator for RISC-V 64-bit architecture\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\napt install qemu-system-riscv64\n```\n\n----------------------------------------\n\nTITLE: Installing Emscripten Compiler Toolchain\nDESCRIPTION: This shell script installs the Emscripten compiler toolchain, necessary for compiling the wasm32-unknown-emscripten target. Dependencies include git and adequate permissions to source environment scripts. The input is a git clone command that downloads the Emscripten SDK, followed by installation and activation commands. The script outputs the configured environment settings required for the Emscripten compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-unknown-emscripten.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/emscripten-core/emsdk.git --depth 1\n./emsdk/emsdk install 3.1.68\n./emsdk/emsdk activate 3.1.68\nsource ./emsdk/emsdk_env.sh\n```\n\n----------------------------------------\n\nTITLE: Rust Raw String Literal Syntax Error\nDESCRIPTION: Error occurs when attempting to create a raw string literal without proper quotation syntax. Raw string literals in Rust require matching `r` prefix and `#` symbols around the quotes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unstarted_raw_string_at_eof.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nr##\"\n```\n\n----------------------------------------\n\nTITLE: Fixing Generic Method Parameters with Self: Sized in Rust\nDESCRIPTION: Shows how to make a trait with generic methods dyn-compatible by restricting the generic methods to only be available on concrete types using the `where Self: Sized` bound.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0038.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\n----------------------------------------\n\nTITLE: Installing addr2line for Better perf Report Reading\nDESCRIPTION: Command to install addr2line with binary features to help resolve issues with reading perf data collected from cargo. This helps prevent 'could not read first record' errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo install addr2line --features=\"bin\"\n```\n\n----------------------------------------\n\nTITLE: Nested Goal Handling in Old Rust Trait Fulfillment\nDESCRIPTION: In the old trait system's fulfillment phase, nested goals are simply returned for later processing, unlike in the evaluation phase.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/significant-changes.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Source: fulfill-nested\nmatch goal.predicate {\n    ty::PredicateKind::Trait(trait_predicate) => {\n        self.fulfill_trait_obligation(goal, trait_predicate)\n    }\n    ty::PredicateKind::Projection(projection_predicate) => {\n        self.fulfill_projection(goal, &projection_predicate)\n    }\n    // ... (other cases)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Trait Reference\nDESCRIPTION: This snippet defines the structure of a TraitRef which consists of the name of a trait along with a suitable set of inputs P0..Pn.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n\"TraitRef = P0: TraitName<P1..Pn>\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Mismatch in Rust Trait Implementations (E0053)\nDESCRIPTION: This example demonstrates two common errors in trait implementation: using incorrect parameter types and differing mutability of self references. The code fails to compile with error E0053 because trait method parameters must exactly match between trait definition and implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0053.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo(x: u16);\n    fn bar(&self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, expected u16, found i16\n    fn foo(x: i16) { }\n\n    // error, types differ in mutability\n    fn bar(&mut self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple env-set Arguments Example 1\nDESCRIPTION: Example showing how to set multiple environment variables using separate --env-set flags. This establishes baseline values that will be checked for changes in subsequent compilations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/env-set.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n--env-set A=B --env X=12\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust staticlib with linker plugin LTO using cargo\nDESCRIPTION: This snippet demonstrates how to compile a Rust static library with linker plugin LTO enabled, using `cargo`. It sets the `RUSTFLAGS` environment variable to include `-Clinker-plugin-lto` and then builds the project in release mode.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/linker-plugin-lto.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"RUSTFLAGS=\\\"-Clinker-plugin-lto\\\" cargo build --release\"\n```\n\n----------------------------------------\n\nTITLE: Building and Installing rust-analyzer from Source (Shell)\nDESCRIPTION: Clones the rust-analyzer repository and uses `cargo xtask install` to build and install both the language server and the VS Code extension. Requires Git, Cargo, Node.js (matching a supported VS Code version), and npm. Note that this method might not work directly for VS Code Remote environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone https://github.com/rust-lang/rust-analyzer.git && cd rust-analyzer\n$ cargo xtask install\n```\n\n----------------------------------------\n\nTITLE: Using cargo-llvm-lines to profile Rust compiler's LLVM IR generation\nDESCRIPTION: Commands to install cargo-llvm-lines, build rustc with saved LLVM IR, convert the bitcode to human-readable format, and analyze line counts. This process helps identify functions generating excessive LLVM IR, which can be targeted for optimization to improve rustc's bootstrap times.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-llvm-lines\n# On a normal crate you could now run `cargo llvm-lines`, but `x` isn't normal :P\n\n# Do a clean before every run, to not mix in the results from previous runs.\n./x clean\nenv RUSTFLAGS=-Csave-temps ./x build --stage 0 compiler/rustc\n\n# Single crate, e.g., rustc_middle. (Relies on the glob support of your shell.)\n# Convert unoptimized LLVM bitcode into a human readable LLVM assembly accepted by cargo-llvm-lines.\nfor f in build/x86_64-unknown-linux-gnu/stage0-rustc/x86_64-unknown-linux-gnu/release/deps/rustc_middle-*.no-opt.bc; do\n  ./build/x86_64-unknown-linux-gnu/llvm/bin/llvm-dis \"$f\"\ndone\ncargo llvm-lines --files ./build/x86_64-unknown-linux-gnu/stage0-rustc/x86_64-unknown-linux-gnu/release/deps/rustc_middle-*.ll > llvm-lines-middle.txt\n\n# Specify all crates of the compiler.\nfor f in build/x86_64-unknown-linux-gnu/stage0-rustc/x86_64-unknown-linux-gnu/release/deps/*.no-opt.bc; do\n  ./build/x86_64-unknown-linux-gnu/llvm/bin/llvm-dis \"$f\"\ndone\ncargo llvm-lines --files ./build/x86_64-unknown-linux-gnu/stage0-rustc/x86_64-unknown-linux-gnu/release/deps/*.ll > llvm-lines.txt\n```\n\n----------------------------------------\n\nTITLE: Complex Filtering with Logical Operators in #[rustc_on_unimplemented]\nDESCRIPTION: Shows how to use logical operators (all, any, not) to create more complex filtering conditions for custom error messages, specifically for the From trait when coercing between String and &str.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_on_unimplemented(\n    on(\n        all(_Self=\"&str\", T=\"std::string::String\"),\n        note=\"you can coerce a `{T}` into a `{Self}` by writing `&*variable`\"\n    )\n)]\npub trait From<T>: Sized { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: UEFI Rust std Build Configuration\nDESCRIPTION: Configuration settings for building Rust standard library with UEFI support using bootstrap.toml and cargo commands.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\nlld = true\n```\n\nLANGUAGE: sh\nCODE:\n```\n./x.py build --target x86_64-unknown-uefi --stage 1\n```\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --target x86_64-unknown-uefi -Zbuild-std=std,panic_abort\n```\n\n----------------------------------------\n\nTITLE: Testing Dependency Graph with Annotations in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]` annotations to validate the dependency relationships between functions in Rust. If the function `foo` changes, the compiler will determine if it impacts the requirements of `bar`. The expected output on changing `foo` is 'OK'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[rustc_if_this_changed]\nfn foo() { }\n\n#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\nfn bar() { foo(); }\n```\n\n----------------------------------------\n\nTITLE: Illustrative Clause Example\nDESCRIPTION: Illustrates how a trait is implemented given another implemented trait. This example demonstrates how the `Implemented(Foo: Bar)` goal depends on itself, leading to an infinite recursion if `Bar` isn't a co-inductive trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n\"Implemented(Foo: Bar) :-\n    Implemented(Foo: Bar).\"\n```\n\n----------------------------------------\n\nTITLE: Rust Main Function with Test\nDESCRIPTION: This Rust snippet defines a main function that prints a greeting for Fuchsia, alongside a basic test function. It showcases the usage of tests within the main application file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello Fuchsia!\");\n}\n\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: ADT Type Representation in Rust Compiler\nDESCRIPTION: Illustrates how the Rust compiler internally represents ADT types using AdtDef and GenericArgs, showing the two-part structure of generic type representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/generic_arguments.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nAdt(&'tcx AdtDef, GenericArgs<'tcx>)\n```\n\n----------------------------------------\n\nTITLE: Building and Running Example (CFI Disabled)\nDESCRIPTION: This shell script compiles the C library and the Rust code, then executes the compiled Rust binary. It first creates the necessary directories, compiles the C code to an object file, and archives it into a static library. Then, it compiles the Rust code and links it with the created C library. Finally, it runs the executable, demonstrating that the transmuted function runs in this configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\n$ make\nmkdir -p target/release\nclang -I. -Isrc -Wall -c src/foo.c -o target/release/libfoo.o\nllvm-ar rcs target/release/libfoo.a target/release/libfoo.o\nRUSTFLAGS=\"-L./target/release -Clinker=clang -Clink-arg=-fuse-ld=lld\" cargo build --release\n   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)\n    Finished release [optimized] target(s) in 0.49s\n$ ./target/release/rust-cfi-4\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nThe next answer is: 14\n$\n```\n\n----------------------------------------\n\nTITLE: Declaring a Migration Lint in Rust\nDESCRIPTION: This snippet demonstrates how to declare a migration lint for edition compatibility. It uses the `declare_lint!` macro to create a lint that detects edition keywords being used as identifiers, with future incompatibility information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/guides/editions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub KEYWORD_IDENTS,\n    Allow,\n    \"detects edition keywords being used as an identifier\",\n    @future_incompatible = FutureIncompatibleInfo {\n        reason: FutureIncompatibilityReason::EditionError(Edition::Edition2018),\n        reference: \"issue #49716 <https://github.com/rust-lang/rust/issues/49716>\",\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Type Example\nDESCRIPTION: This code snippet illustrates the difference between syntactic types (`hir::Ty`) and the internal type representation (`Ty<'tcx>`) within the Rust compiler. It shows how two parameters with the same underlying type can have distinct `hir::Ty` nodes but are represented by the same internal type after collection.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-checking.md#2025-04-21_snippet_0\n\nLANGUAGE: rust,ignore\nCODE:\n```\n\"struct Foo { }\nfn foo(x: Foo, y: self::Foo) { ... }\n//        ^^^     ^^^^^^^^^\n\"\n```\n\n----------------------------------------\n\nTITLE: Using dump-mono-stats-format Compiler Flag in Rust\nDESCRIPTION: The -Z dump-mono-stats-format flag controls the output format when using -Z dump-mono-stats. It accepts format parameters with markdown being the default. JSON format is also supported and is useful for programmatic analysis of compilation performance metrics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/dump-mono-stats-format.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `dump-mono-stats-format`\n```\n\n----------------------------------------\n\nTITLE: Failed Generic Parameter Inheritance in Type Definition\nDESCRIPTION: Example showing incorrect attempt to use outer function's generic parameter in inner type definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0401.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Changing Struct Update in Rust\nDESCRIPTION: This code snippet demonstrates the usage of the 'type_changing_struct_update' feature in Rust. It defines a generic struct 'Foo' and creates instances with different type parameters using the struct update syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/type-changing-struct-update.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(unused_variables, dead_code)]\n#![feature(type_changing_struct_update)]\n\nfn main () {\n    struct Foo<T, U> {\n        field1: T,\n        field2: U,\n    }\n\n    let base: Foo<String, i32> = Foo {\n        field1: String::from(\"hello\"),\n        field2: 1234,\n    };\n    let updated: Foo<f64, i32> = Foo {\n        field1: 3.14,\n        ..base\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Rust Program with SPARC Simulator\nDESCRIPTION: Illustrates a workflow using cargo to run a Rust program on a SPARC simulator. Utilizes TSIM Leon3 for simulation, showing console interactions and executing the compiled binary.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_5\n\nLANGUAGE: Console\nCODE:\n```\n$ cargo run --target=sparc-unknown-none-elf\n   Compiling sparc-demo-rust v0.1.0 (/work/sparc-demo-rust)\n    Finished dev [unoptimized + debuginfo] target(s) in 3.44s\n     Running `tsim-leon3 target/sparc-unknown-none-elf/debug/sparc-demo-rust`\n\n TSIM3 LEON3 SPARC simulator, version 3.1.9 (evaluation version)\n\n Copyright (C) 2023, Frontgrade Gaisler - all rights reserved.\n This software may only be used with a valid license.\n For latest updates, go to https://www.gaisler.com/\n Comments or bug-reports to support@gaisler.com\n\n This TSIM evaluation version will expire 2023-11-28\n\nNumber of CPUs: 2\nsystem frequency: 50.000 MHz\nicache: 1 * 4 KiB, 16 bytes/line (4 KiB total)\ndcache: 1 * 4 KiB, 16 bytes/line (4 KiB total)\nAllocated 8192 KiB SRAM memory, in 1 bank at 0x40000000\nAllocated 32 MiB SDRAM memory, in 1 bank at 0x60000000\nAllocated 8192 KiB ROM memory at 0x00000000\nsection: .text, addr: 0x40000000, size: 20528 bytes\nsection: .rodata, addr: 0x40005030, size: 128 bytes\nsection: .data, addr: 0x400050b0, size: 1176 bytes\nread 347 symbols\n\ntsim> run\n  Initializing and starting from 0x40000000\nHello, this is Rust!\n\n  Program exited normally on CPU 0.\ntsim>\n```\n\n----------------------------------------\n\nTITLE: Disabling RELRO in Cargo Configuration for QNX Targets\nDESCRIPTION: This snippet demonstrates how to disable RELocation Read-Only (RELRO) for specific QNX targets by adding a `rustflags` entry to the `.cargo/config.toml` file. Disabling RELRO might be necessary in some QNX kernel setups where the default RELRO setting causes execution failures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n\n```toml\n[target.aarch64-unknown-nto-qnx700]\nrustflags = [\"-C\", \"relro_level=off\"]\n```\n\n```\n\n----------------------------------------\n\nTITLE: Masking extern crates from documentation\nDESCRIPTION: This Rust snippet shows how to use the `#[doc(masked)]` attribute on `extern crate` declarations to prevent types from those crates from being included in documentation.  This is used to hide internal types. It requires the `doc_masked` feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Building Rust Programs for MIPS R6\nDESCRIPTION: Uses Cargo to build Rust programs targeting the MIPS R6 architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --target mipsisa64r6el-unknown-linux-gnuabi64\n```\n\n----------------------------------------\n\nTITLE: Configuring arm64e-apple-tvos Target in Bootstrap.toml\nDESCRIPTION: This snippet shows how to configure the 'arm64e-apple-tvos' target in the `bootstrap.toml` file to build Rust with support for this target. It requires adding the specific target name to the `target` list under the `[build]` section, necessitating at least Xcode 12 on macOS.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64e-apple-tvos.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"arm64e-apple-tvos\"]\n```\n\n----------------------------------------\n\nTITLE: Example bash commands for setting RUSTC_LOG and RUSTDOC_LOG\nDESCRIPTION: This collection of bash commands demonstrates various uses of `RUSTC_LOG` and `RUSTDOC_LOG` for enabling tracing in the Rust compiler and rustdoc. It shows how to filter by module, logging level, and how to redirect output to a file. It also includes examples for enabling tracing in `rustc_codegen_ssa` and `rustc_resolve`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# This puts the output of all debug calls in `rustc_middle/src/traits` into\n# standard error, which might fill your console backscroll.\n$ RUSTC_LOG=rustc_middle::traits=debug rustc +stage1 my-file.rs\n\n# This puts the output of all debug calls in `rustc_middle/src/traits` in\n# `traits-log`, so you can then see it with a text editor.\n$ RUSTC_LOG=rustc_middle::traits=debug rustc +stage1 my-file.rs 2>traits-log\n\n# Not recommended! This will show the output of all `debug!` calls\n# in the Rust compiler, and there are a *lot* of them, so it will be\n# hard to find anything.\n$ RUSTC_LOG=debug rustc +stage1 my-file.rs 2>all-log\n\n# This will show the output of all `info!` calls in `rustc_codegen_ssa`.\n#\n# There's an `info!` statement in `codegen_instance` that outputs\n# every function that is codegen'd. This is useful to find out\n# which function triggers an LLVM assertion, and this is an `info!`\n# log rather than a `debug!` log so it will work on the official\n# compilers.\n$ RUSTC_LOG=rustc_codegen_ssa=info rustc +stage1 my-file.rs\n\n# This will show all logs in `rustc_codegen_ssa` and `rustc_resolve`.\n$ RUSTC_LOG=rustc_codegen_ssa,rustc_resolve rustc +stage1 my-file.rs\n\n# This will show the output of all `info!` calls made by rustdoc\n# or any rustc library it calls.\n$ RUSTDOC_LOG=info rustdoc +stage1 my-file.rs\n\n# This will only show `debug!` calls made by rustdoc directly,\n# not any `rustc*` crate.\n$ RUSTDOC_LOG=rustdoc=debug rustdoc +stage1 my-file.rs\n```\n\n----------------------------------------\n\nTITLE: Enabling Inlay Hints in Neovim with rust-analyzer\nDESCRIPTION: This Lua snippet enables inlay hints in Neovim using rust-analyzer via the `vim.lsp.inlay_hint.enable` function.  It shows the hints in the specified buffer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_5\n\nLANGUAGE: Lua\nCODE:\n```\nlspconfig.rust_analyzer.setup({\n    on_attach = function(client, bufnr)\n        vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })\n    end\n})\n```\n\n----------------------------------------\n\nTITLE: Building Rust Compiler and Tools\nDESCRIPTION: Command to build the Rust compiler, standard library, rustdoc, and rustfmt using the x.py build script. This step is crucial for incorporating local changes into the Rust toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npython x.py build --stage=2 compiler library/std src/tools/rustdoc src/tools/rustfmt\n```\n\n----------------------------------------\n\nTITLE: Default Match Arm Blocks Behavior in Rust\nDESCRIPTION: Shows the default match_arm_blocks setting (true), which wraps match arm bodies in blocks when they cannot fit on the same line as the match operator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    match lorem {\n        ipsum => {\n            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)\n        }\n        dolor => println!(\"{}\", sit),\n        sit => foo(\n            \"foooooooooooooooooooooooo\",\n            \"baaaaaaaaaaaaaaaaaaaaaaaarr\",\n            \"baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz\",\n            \"qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx\",\n        ),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Match Arm Leading Pipes with Always Setting in Rust\nDESCRIPTION: Demonstrates the match_arm_leading_pipes setting set to Always, which adds leading pipe characters to all match arms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/Configurations.md#2025-04-21_snippet_44\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    match foo {\n        | \"foo\" | \"bar\" => {},\n        | \"baz\"\n        | \"something relatively long\"\n        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n        | \"qux\" => println!(\"y\"),\n        | _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect SIMD Tuple Struct Implementation in Rust\nDESCRIPTION: Shows incorrect implementation of a SIMD tuple struct where the field is not declared as an array, which results in compiler error E0076.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0076.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad(u16); // error!\n```\n\n----------------------------------------\n\nTITLE: Configuring Core Dependency in Cargo.toml\nDESCRIPTION: Shows how to properly configure a dependency on the rustc-std-workspace-core crate, renaming it to 'core' using the package key for compatibility with compiler directives.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/rustc-std-workspace-core/README.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\ncore = { version = \"1.0.0\", optional = true, package = 'rustc-std-workspace-core' }\n```\n\n----------------------------------------\n\nTITLE: Configuring QEMU Runner for RISC-V Testing\nDESCRIPTION: Cargo configuration to use QEMU for running and testing cross-compiled RISC-V binaries\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[target.riscv64gc-unknown-linux-gnu]\nrunner = \"qemu-riscv64-static -L /usr/riscv64-linux-gnu -cpu rv64\"\n```\n\n----------------------------------------\n\nTITLE: Setting QEMU as Runner for s390x in Cargo\nDESCRIPTION: This snippet shows how to configure Cargo to use QEMU as the runner for executing cross-compiled s390x binaries. By setting the `runner` option in `.cargo/config.toml`, Cargo will automatically execute the compiled binary using QEMU, with the specified root filesystem. This setup is useful for testing cross-compiled binaries on a development machine.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_7\n\nLANGUAGE: TOML\nCODE:\n```\n\n```toml\n[target.s390x-unknown-linux-gnu]\nrunner = \"qemu-s390x-static -L /usr/s390x-linux-gnu\"\n```\n\n```\n\n----------------------------------------\n\nTITLE: Lint Registration in Rust Compiler\nDESCRIPTION: This snippet describes the registration process of lints in the `LintStore`, utilizing the `LintStore::register_lint` function. It illustrates the flow post `Session` creation where all lints are registered into the store ensuring that each lint is registered exactly once to avoid Internal Compiler Errors (ICE). This process is crucial for the runtime behavior of lint checks in the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/lintstore.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// Example lint registration\nlint_store.register_lint(MY_LINT);\n```\n\n----------------------------------------\n\nTITLE: Debug Print Statement in Rust Analyzer\nDESCRIPTION: Example debug print statement using eprintln! macro for debugging rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/setup.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\neprintln!(\"Hello, world!\");\n```\n\n----------------------------------------\n\nTITLE: Defining a public function in Rust\nDESCRIPTION: This snippet shows a simple public function definition in a Rust library. The function, `a_func`, takes no arguments and returns nothing.  It is intended to be used as a target for examples that will be scraped and included in the documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/scraped-examples.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"// a_crate/src/lib.rs\npub fn a_func() {}\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Late-Bound Lifetime Parameter Specification\nDESCRIPTION: Demonstrates an erroneous attempt to specify a lifetime argument for a late-bound lifetime parameter, which is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0794.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<'a>(x: &'a str) -> &'a str { x }\nlet _ = foo::<'static>;\n```\n\n----------------------------------------\n\nTITLE: Documentation of Rust Build System Output Structure\nDESCRIPTION: The document provides an overview of the directory layout utilized by the Rust bootstrap build system. This system stores all outputs under a `build` directory, with subdirectories allocated for cached downloads, build artifacts, temporary files, and specific host triple outputs. Each directory serves a precise function within the build process, such as caching stage0 compiler downloads, storing documentation, and accommodating compiletest outputs. This layout facilitates clear organization and efficient management of the build process components.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/bootstrap/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Root folder of all output. Everything is scoped underneath here\nbuild/\n\n  # Location where the stage0 compiler downloads are all cached. This directory\n  # only contains the tarballs themselves, as they're extracted elsewhere.\n  cache/\n    2015-12-19/\n    2016-01-15/\n    2016-01-21/\n    ...\n\n  # Output directory for building this build system itself. The stage0\n  # cargo/rustc are used to build the build system into this location.\n  bootstrap/\n    debug/\n    release/\n\n  # Output of the dist-related steps like dist-std, dist-rustc, and dist-docs\n  dist/\n\n  # Temporary directory used for various input/output as part of various stages\n  tmp/\n\n  # Each remaining directory is scoped by the \"host\" triple of compilation at\n  # hand.\n  x86_64-unknown-linux-gnu/\n\n    # The build artifacts for the `compiler-rt` library for the target that\n    # this folder is under. The exact layout here will likely depend on the\n    # platform, and this is also built with CMake, so the build system is\n    # also likely different.\n    compiler-rt/\n      build/\n\n    # Output folder for LLVM if it is compiled for this target\n    llvm/\n\n      # build folder (e.g. the platform-specific build system). Like with\n      # compiler-rt, this is compiled with CMake\n      build/\n\n      # Installation of LLVM. Note that we run the equivalent of 'make install'\n      # for LLVM, to setup these folders.\n      bin/\n      lib/\n      include/\n      share/\n      ...\n\n    # Output folder for all documentation of this target. This is what's filled\n    # in whenever the `doc` step is run.\n    doc/\n\n    # Output for all compiletest-based test suites\n    test/\n      ui/\n      debuginfo/\n      ...\n\n    # Location where the stage0 Cargo and Rust compiler are unpacked. This\n    # directory is purely an extracted and overlaid tarball of these two (done\n    # by the bootstrap Python script). In theory, the build system does not\n    # modify anything under this directory afterwards.\n    stage0/\n\n    # These to-build directories are the cargo output directories for builds of\n    # the standard library, the test system, the compiler, and various tools,\n    # respectively. Internally, these may also\n    # have other target directories, which represent artifacts being compiled\n    # from the host to the specified target.\n    #\n    # Essentially, each of these directories is filled in by one `cargo`\n    # invocation. The build system instruments calling Cargo in the right order\n    # with the right variables to ensure that these are filled in correctly.\n    stageN-std/\n    stageN-test/\n    stageN-rustc/\n    stageN-tools/\n\n    # This is a special case of the above directories, **not** filled in via\n    # Cargo but rather the build system itself. The stage0 compiler already has\n    # a set of target libraries for its own host triple (in its own sysroot)\n    # inside of stage0/. When we run the stage0 compiler to bootstrap more\n    # things, however, we don't want to use any of these libraries (as those are\n    # the ones that we're building). So essentially, when the stage1 compiler is\n    # being compiled (e.g. after libstd has been built), *this* is used as the\n    # sysroot for the stage0 compiler being run.\n    #\n    # Basically, this directory is just a temporary artifact used to configure the\n    # stage0 compiler to ensure that the libstd that we just built is used to\n    # compile the stage1 compiler.\n    stage0-sysroot/lib/\n\n    # These output directories are intended to be standalone working\n    # implementations of the compiler (corresponding to each stage). The build\n    # system will link (using hard links) output from stageN-{std,rustc} into\n    # each of these directories.\n    #\n    # In theory these are working rustc sysroot directories, meaning there is\n    # no extra build output in these directories.\n    stage1/\n    stage2/\n    stage3/\n```\n\n----------------------------------------\n\nTITLE: Removing Redundant Parentheses in Rust\nDESCRIPTION: Eliminates unnecessary parentheses in expressions where they don't affect operator precedence or evaluation order. This refactoring improves code readability by removing syntactic noise when parentheses are not needed for clarification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_100\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    _ = (2) + 2;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    _ = 2 + 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Unused Function Parameters in Rust\nDESCRIPTION: This assist binds unused function parameters to an underscore. It adds a statement to explicitly ignore the unused parameter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn some_function(x: i32) {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn some_function(x: i32) {\n    let _ = x;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Variable Assignment Outside Conditional in Rust\nDESCRIPTION: Pulls variable assignments from inside conditional branches to the outside, converting the conditional statement into an expression. This refactoring reduces repetition and clarifies that the primary purpose of the conditional is to compute a value.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_93\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut foo = 6;\n\n    if true {\n        foo = 5;\n    } else {\n        foo = 4;\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut foo = 6;\n\n    foo = if true {\n        5\n    } else {\n        4\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling rustdoc-scrape-examples with cargo doc\nDESCRIPTION: This command shows how to enable the unstable `rustdoc-scrape-examples` feature when running `cargo doc`. The `-Zunstable-options` flag enables unstable features, and `-Zrustdoc-scrape-examples` specifically enables the example scraping.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/scraped-examples.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo doc -Zunstable-options -Zrustdoc-scrape-examples\"\n```\n\n----------------------------------------\n\nTITLE: Configuring docs.rs to use rustdoc-scrape-examples\nDESCRIPTION: This snippet shows how to configure `docs.rs` to enable the `rustdoc-scrape-examples` feature.  The `cargo-args` array in the `package.metadata.docs.rs` section of `Cargo.toml` specifies the arguments to pass to `cargo doc` when generating documentation on `docs.rs`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/scraped-examples.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n\"[package.metadata.docs.rs]\ncargo-args = [\\\"-Zunstable-options\\\", \\\"-Zrustdoc-scrape-examples\\\"]\"\n```\n\n----------------------------------------\n\nTITLE: Running MemorySanitizer with Rust Flags in Shell\nDESCRIPTION: This shell snippet shows how to configure environment variables to enable MemorySanitizer instrumentation when running a Rust project. It sets `RUSTFLAGS` and `RUSTDOCFLAGS` to include `-Zsanitizer=memory` and `-Zsanitizer-memory-track-origins` to enable detailed origin tracking of uninitialized memory. It then cleans the cargo build directory and runs the project rebuilding the standard library with `-Zbuild-std` targeting `x86_64-unknown-linux-gnu`. The command is expected to generate detailed MemorySanitizer warnings about uninitialized memory usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ export \\\n  RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n  RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n$ cargo clean\n$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU for Hexagon Architecture\nDESCRIPTION: This snippet shows how to install QEMU for running Hexagon architecture programs on a Debian-based system. QEMU allows emulation of Hexagon binaries to test applications.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# apt install qemu-user-static\n# qemu-hexagon-static ./hello\n```\n\n----------------------------------------\n\nTITLE: Using asm_goto_with_outputs for inline assembly with both label and output operands in Rust\nDESCRIPTION: This example demonstrates how to use the `asm_goto_with_outputs` feature to combine label operands with output operands in inline assembly. The assembly code assigns a value to an output variable and then jumps to a labeled block. The output operands are assigned before the label blocks are executed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-goto-with-outputs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nunsafe {\n    let a: usize;\n    asm!(\n        \"mov {}, 1\"\n        \"jmp {}\",\n        out(reg) a,\n        label {\n            println!(\"Jumped from asm {}!\", a);\n        }\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Running Miri Tests in Rust Toolchain with Bash\nDESCRIPTION: This snippet showcases the command to run Miri tests within the context of the Rust repository, highlighting the use of the Rust toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\n./x.py test miri\n```\n\nLANGUAGE: sh\nCODE:\n```\n./x.py run miri --stage 1 --args src/tools/miri/tests/pass/hello.rs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Move Paths in Rust\nDESCRIPTION: This Rust code snippet demonstrates the concept of move paths by illustrating the movement and initialization state of tuple elements. It showcases how moving individual elements affects their initialization state. Requires the understanding of Rust's ownership and borrow rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/moves_and_initialization/move_paths.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() {\n    let a: (Vec<u32>, Vec<u32>) = (vec![22], vec![44]);\n\n    // a.0 and a.1 are both initialized\n\n    let b = a.0; // moves a.0\n\n    // a.0 is not initialized, but a.1 still is\n\n    let c = a.0; // ERROR\n    let d = a.1; // OK\n}\n```\n\n----------------------------------------\n\nTITLE: Example of incorrect intrinsic function with wrong number of type parameters\nDESCRIPTION: This snippet demonstrates an erroneous intrinsic function declaration in Rust where two generic parameters are specified for the 'size_of' function, which expects only one. It includes feature flags and intrinsic attributes. The code shows the improper usage that triggers error E0094, indicating a parameter mismatch. Dependencies include the unstable feature 'intrinsics' and internal features, with the main focus on function signature correctness.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0094.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\nfn size_of<T, U>() -> usize; // error: intrinsic has wrong number\n                             //        of type parameters\n```\n\n----------------------------------------\n\nTITLE: Implementing UEFI Hello World with Rust std\nDESCRIPTION: Advanced UEFI application example using Rust's standard library features including stdio and alloc. Demonstrates usage of OsString and Vec for string handling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncargo +custom build --target x86_64-unknown-uefi\n```\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(uefi_std)]\n\nuse r_efi::{efi, protocols::simple_text_output};\nuse std::{\n  ffi::OsString,\n  os::uefi::{env, ffi::OsStrExt}\n};\n\npub fn main() {\n  println!(\"Starting Rust Application...\");\n\n  let st = env::system_table().as_ptr() as *mut efi::SystemTable;\n  let mut s: Vec<u16> = OsString::from(\"Hello World!\\n\").encode_wide().collect();\n  s.push(0);\n  let r =\n      unsafe {\n        let con_out: *mut simple_text_output::Protocol = (*st).con_out;\n        let output_string: extern \"efiapi\" fn(_: *mut simple_text_output::Protocol, *mut u16) -> efi::Status = (*con_out).output_string;\n        output_string(con_out, s.as_ptr() as *mut efi::Char16)\n      };\n  assert!(!r.is_error())\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Precise Capturing Bound in Rust\nDESCRIPTION: Demonstrates the formatting of a `use<'a, T>` precise capturing bound in Rust. The bound is formatted as a single path segment with non-turbofished angle-bracketed arguments, similar to a trait bound with the identifier 'use'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/nightly.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> impl Sized + use<'a> {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> impl Sized + Use<'a> {}\n```\n\n----------------------------------------\n\nTITLE: Invalid CoercePointee with Multiple Pointee Designations\nDESCRIPTION: Example showing error when deriving CoercePointee on a struct with multiple pointee designations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0802.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(coerce_pointee)]\nuse std::marker::CoercePointee;\n#[derive(CoercePointee)]\n#[repr(transparent)]\nstruct TooManyPointees<\n    'a,\n    #[pointee] A: ?Sized,\n    #[pointee] B: ?Sized>\n((&'a A, &'a B));\n```\n\n----------------------------------------\n\nTITLE: Configuring WALI Target in Rust (TOML)\nDESCRIPTION: This snippet shows how to configure the Rust target with support for WALI by providing a sample `config.toml` file. It includes setting up toolchain artifacts and specifying toolchain paths like musl-root, llvm-config, and compiler binaries in the WALI source directory. The configuration includes necessary paths for building Rust with WALI support.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/wasm32-wali-linux.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"wasm32-wali-linux-musl\"]\n\n[target.wasm32-wali-linux-musl]\nmusl-root = \"<WALI>/wali-musl/sysroot\"\nllvm-config = \"<WALI>/llvm-project/build/bin/llvm-config\"\ncc = \"<WALI>/llvm-project/build/bin/clang-18\"\ncxx = \"<WALI>/llvm-project/build/bin/clang-18\"\nar = \"<WALI>/llvm-project/build/bin/llvm-ar\"\nranlib = \"<WALI>/llvm-project/build/bin/llvm-ranlib\"\nllvm-libunwind = \"system\"\ncrt-static = true\n```\n\n----------------------------------------\n\nTITLE: Comparing Branches Before and After Rebase\nDESCRIPTION: Uses `git range-diff` to show the difference between the set of changes introduced by the branch *before* the rebase (relative to the master base) and the set of changes *after* the rebase. Compares the old branch state (`@{upstream}` or `@{u}`) with the new state (`HEAD`) relative to `master`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\ngit range-diff master @{upstream} HEAD\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit range-diff master @{u} HEAD\n```\n\n----------------------------------------\n\nTITLE: Exporting Profiling Data to Chromium Format\nDESCRIPTION: Shows how to convert rustc profiling data to Chromium-profiler compatible format using the crox tool from measureme.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/self-profile.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ ../measureme/target/release/crox foo-1234\n```\n\n----------------------------------------\n\nTITLE: Using the Windows vectorcall ABI in Rust\nDESCRIPTION: This code demonstrates how to declare and use a function that uses the Windows vectorcall ABI. The example shows a foreign function interface declaration for a function that adds two f64 floating-point values, using the 'vectorcall' ABI specification.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-vectorcall.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern \"vectorcall\" {\n    fn add_f64s(x: f64, y: f64) -> f64;\n}\n\nfn main() {\n    println!(\"{}\", add_f64s(2.0, 4.0));\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Closures as Method Receivers in Rust\nDESCRIPTION: This code showcases the fix for adding parentheses around closures when they are used as method receivers, lack a block body, and end with a dot. This ensures code like `|| (10.).method()` and similar examples are correctly formatted by rustfmt. This enhancement improves the readability and correctness of formatted code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    || (10.).method();\n    (|| ..).method();\n    (|| 1..).method();\n}\n```\n\n----------------------------------------\n\nTITLE: Default Assembly Output\nDESCRIPTION: The standard assembly output generated without the -Zverbose-asm flag, showing basic assembly instructions and labels.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/verbose-asm.md#2025-04-21_snippet_1\n\nLANGUAGE: asm\nCODE:\n```\nfoo:\n        push    rax\n        add     edi, esi\n        mov     dword ptr [rsp + 4], edi\n        seto    al\n        jo      .LBB0_2\n        mov     eax, dword ptr [rsp + 4]\n        pop     rcx\n        ret\n.LBB0_2:\n        lea     rdi, [rip + .L__unnamed_1]\n        mov     rax, qword ptr [rip + core::panicking::panic_const::panic_const_add_overflow::h9c85248fe0d735b2@GOTPCREL]\n        call    rax\n\n.L__unnamed_2:\n        .ascii  \"/app/example.rs\"\n\n.L__unnamed_1:\n        .quad   .L__unnamed_2\n        .asciz  \"\\017\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\005\\000\\000\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Jemalloc Allocator\nDESCRIPTION: By adding the `rust.jemalloc` option with a value of `true` in `bootstrap.toml`, this snippet configures the Rust compiler to use the `jemalloc` memory allocator. This setup is applicable on Linux and macOS targets to improve performance over the default allocator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\njemalloc = true\n```\n\n----------------------------------------\n\nTITLE: Correct Intrinsic Function Declaration in Rust\nDESCRIPTION: A corrected example showing how to properly declare an intrinsic function in Rust. The intrinsic is now defined as an unsafe function, which is the correct approach for compiler-handled special functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0622.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\\n#![allow(internal_features)]\\n\\n#[rustc_intrinsic]\\npub unsafe fn atomic_singlethreadfence_seqcst(); // ok!\\n\\nfn main() { unsafe { atomic_singlethreadfence_seqcst(); } }\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Rust\nDESCRIPTION: Commands for building and installing Rust using x.py or make.\nSOURCE: https://github.com/rust-lang/rust/blob/master/INSTALL.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n./x.py build && ./x.py install\n```\n\nLANGUAGE: sh\nCODE:\n```\n./configure\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: Clang++ Wrapper Script for aarch64-unknown-linux-ohos\nDESCRIPTION: This shell script wraps the Clang++ compiler from the OpenHarmony SDK for the aarch64-unknown-linux-ohos target.  It configures the compiler to target OpenHarmony by specifying the sysroot, target architecture and defines the __MUSL__ macro.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\n  -target aarch64-linux-ohos \\\n  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\n  -D__MUSL__ \\\n  \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Defining C Source Files\nDESCRIPTION: This CMake command sets the variable `C_SOURCES` to a list of C source files. These files will be compiled as part of the project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(C_SOURCES\n    src/foo.c\n    )\n```\n\n----------------------------------------\n\nTITLE: Rust Second Version of Crate A (a2.rs)\nDESCRIPTION: Second version of crate 'a' with an implementation that includes a print statement.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0460.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"a\"]\n\npub fn foo<T>() {\n    println!(\"foo<T>()\");\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of 'continue' in Rust Functions\nDESCRIPTION: This code snippet demonstrates incorrect usage of the 'continue' keyword in Rust functions. The 'continue' statement is used incorrectly within labeled blocks, which will result in compilation errors.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0696.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn continue_simple() {\n    'b: {\n        continue; // error!\n    }\n}\nfn continue_labeled() {\n    'b: {\n        continue 'b; // error!\n    }\n}\nfn continue_crossing() {\n    loop {\n        'b: {\n            continue; // error!\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Where-Clause Cycles in Trait Implementations\nDESCRIPTION: Example showing how trait implementations with cyclic where clauses can lead to an infinite proof tree that coinduction needs to handle.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {}\nstruct Wrapper<T>(T);\n\nimpl<T> Foo for Wrapper<Wrapper<T>>\nwhere\n    Wrapper<T>: Foo\n{} \n```\n\n----------------------------------------\n\nTITLE: Using UI Testing in Miri\nDESCRIPTION: This command generates stderr and stdout files for Miri's output, as part of the ui-testing process. It automates the blessing of test output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n./miri test --bless\n```\n\n----------------------------------------\n\nTITLE: Adding Lifetime to Type in Rust\nDESCRIPTION: This assist adds a new lifetime to a struct, enum or union. It introduces a lifetime parameter and applies it to references within the type definition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/assists_generated.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: &u32,\n    y: u32,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<'a> {\n    x: &'a u32,\n    y: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Main Function for Stack Size Analysis\nDESCRIPTION: This Rust snippet defines a main function that allocates an array on the stack, used to demonstrate stack size analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// file: src/main.rs\nuse std::ptr;\n\n#[inline(never)]\nfn main() {\n    let xs = [0u32; 2];\n\n    // force LLVM to allocate `xs` on the stack\n    unsafe { ptr::read_volatile(&xs.as_ptr()); }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust: Transmute Dataflow Analysis Example\nDESCRIPTION: This code demonstrates a simplified dataflow analysis to detect potential `mem::transmute` calls. It illustrates how to define the analysis domain (a boolean indicating if `transmute` has been called), the bottom and top values, and the join operator (boolean OR) to conservatively approximate the analysis result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/dataflow.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n# unsafe fn example(some_cond: bool) {\nlet x = if some_cond {\n    std::mem::transmute::<i32, u32>(0_i32) // transmute was called!\n} else {\n    1_u32 // transmute was not called\n};\n\n// Has transmute been called by this point? We conservatively approximate that\n// as yes, and that is why we use the OR operator.\nprintln!(\"x: {}\", x);\n# }\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Version Override Example in Rust Console\nDESCRIPTION: Demonstrates basic usage of RUSTC_OVERRIDE_VERSION_STRING to modify the version output of rustc --version command. Shows how the version string is completely overwritten, discarding the original commit hash and date information.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/rustc-override-version-string.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --version\nrustc 1.87.0-nightly (43f0014ef 2025-03-25)\n$ env RUSTC_OVERRIDE_VERSION_STRING=1.81.0-nightly rustc --version\nrustc 1.81.0-nightly\n```\n\n----------------------------------------\n\nTITLE: Calling fastcall_fn_1 - Rust\nDESCRIPTION: This snippet calls the `fastcall_fn_1` function in Rust, passing an integer argument (14). It demonstrates how to call a function using the `fastcall` calling convention with a single integer parameter. The outcome depends on the implementation of `fastcall_fn_1`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nfastcall_fn_1(14)\n```\n\n----------------------------------------\n\nTITLE: Linker Script for Preserving Stack Size Metadata\nDESCRIPTION: This text snippet provides a linker script to preserve the .stack_sizes section, which is normally discarded by default.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n/* file: keep-stack-sizes.x */\nSECTIONS\n{\n  /* `INFO` makes the section not allocatable so it won't be loaded into memory */\n  .stack_sizes (INFO) :\n  {\n    KEEP(*(.stack_sizes));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Randomize Layout Flag in Rust Compiler\nDESCRIPTION: The -Zrandomize-layout is a compiler flag that modifies how Rust lays out struct fields in memory. It can be combined with -Zlayout-seed=<u64> to provide additional entropy for the randomization process. This feature affects repr(Rust) types defined in the current crate and their downstream instantiations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/randomize-layout.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Zrandomize-layout\n-Zlayout-seed=<u64>\n```\n\n----------------------------------------\n\nTITLE: Feature Flag Error Example in Rust\nDESCRIPTION: Demonstrates an erroneous use of #![feature] attributes where a feature flag is used for functionality that is already stable in Rust 2018 edition. This example shows how attempting to enable an already-stable feature through a feature flag would trigger a compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0705.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rust_2018_preview)]\n#![feature(test_2018_feature)] // error: the feature\n                               // `test_2018_feature` is\n                               // included in the Rust 2018 edition\n```\n\n----------------------------------------\n\nTITLE: Manual Rustc Compilation with GCC Backend\nDESCRIPTION: A manual command showing how to invoke rustc with the necessary environment variables and flags to use the GCC codegen backend.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/Readme.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ LIBRARY_PATH=\"[gcc-path value]\" LD_LIBRARY_PATH=\"[gcc-path value]\" rustc +$(cat $CG_GCCJIT_DIR/rust-toolchain | grep 'channel' | cut -d '=' -f 2 | sed 's/\"//g' | sed 's/ //g') -Cpanic=abort -Zcodegen-backend=$CG_GCCJIT_DIR/target/release/librustc_codegen_gcc.so --sysroot $CG_GCCJIT_DIR/build_sysroot/sysroot my_crate.rs\n```\n\n----------------------------------------\n\nTITLE: Building MDBook Documentation\nDESCRIPTION: Command to build the static HTML documentation site and open it in a browser.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmdbook build --open\n```\n\n----------------------------------------\n\nTITLE: Handling 'failed to build archive' Error in Rust Compilation\nDESCRIPTION: This error occurs when trying to compile with 'lto = \"fat\"' without compiling the sysroot with LTO. The solution may involve setting the FAT_LTO flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/errors.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nerror: failed to build archive: failed to open object file: No such file or directory (os error 2)\n```\n\n----------------------------------------\n\nTITLE: Neovim Configuration for Rust Development in Lua\nDESCRIPTION: This Lua script configures Neovim's LSP client for Rust projects, specifically for working with rust-lang/rust. It customizes the root directory detection and initialization options based on workspace configurations. Users need to have rust-analyzer pre-configured.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_3\n\nLANGUAGE: lua\nCODE:\n```\nlocal function expand_config_variables(option)\n    local var_placeholders = {\n        ['${workspaceFolder}'] = function(_)\n            return vim.lsp.buf.list_workspace_folders()[1]\n        end,\n    }\n\n    if type(option) == \"table\" then\n        local mt = getmetatable(option)\n        local result = {}\n        for k, v in pairs(option) do\n            result[expand_config_variables(k)] = expand_config_variables(v)\n        end\n        return setmetatable(result, mt)\n    end\n    if type(option) ~= \"string\" then\n        return option\n    end\n    local ret = option\n    for key, fn in pairs(var_placeholders) do\n        ret = ret:gsub(key, fn)\n    end\n    return ret\nend\nlspconfig.rust_analyzer.setup {\n    root_dir = function()\n        local default = lspconfig.rust_analyzer.config_def.default_config.root_dir()\n        -- the default root detection uses the cargo workspace root.\n        -- but for rust-lang/rust, the standard library is in its own workspace.\n        -- use the git root instead.\n        local compiler_config = vim.fs.joinpath(default, \"../src/bootstrap/defaults/config.compiler.toml\")\n        if vim.fs.basename(default) == \"library\" and vim.uv.fs_stat(compiler_config) then\n            return vim.fs.dirname(default)\n        end\n        return default\n    end,\n    on_init = function(client)\n        local path = client.workspace_folders[1].name\n        local config = vim.fs.joinpath(path, \"src/etc/rust_analyzer_zed.json\")\n        if vim.uv.fs_stat(config) then\n            -- load rust-lang/rust settings\n            local file = io.open(config)\n            local json = vim.json.decode(file:read(\"*a\"))\n            client.config.settings[\"rust-analyzer\"] = expand_config_variables(json.lsp[\"rust-analyzer\"].initialization_options)\n            client.notify(\"workspace/didChangeConfiguration\", { settings = client.config.settings })\n        end\n        return true\n    end\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Type Memory Layout in Rustdoc\nDESCRIPTION: Shows how to include memory layout information for types in documentation. This adds a 'Layout' section to each type's docs showing size and other layout details computed by rustc, though this information is unstable.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --show-type-layout\n```\n\n----------------------------------------\n\nTITLE: Setting Up C Compiler for RISC-V Target - TOML\nDESCRIPTION: This snippet configures the C compiler settings for the RISC-V target in Rust. It includes definitions for the C compiler and related tools necessary for the build process. These settings must be included in the bootstrap.toml file for proper compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-musl.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.riscv64gc-unknown-linux-musl]\ncc = \"riscv64-linux-gnu-gcc\"\ncxx = \"riscv64-linux-gnu-g++\"\nar = \"riscv64-linux-gnu-ar\"\nlinker = \"riscv64-linux-gnu-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Rust\nDESCRIPTION: Command to uninstall Rust using the uninstall script located in the rustlib directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/etc/installer/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo /usr/local/lib/rustlib/uninstall.sh\n```\n\n----------------------------------------\n\nTITLE: Assembly Output for TrustZone-M Secure Entry Function\nDESCRIPTION: Disassembled output showing the compiled assembly code for the secure entry function. Demonstrates the security-related operations including register clearing and use of BXNS instruction for secure return.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/cmse-nonsecure-entry.md#2025-04-21_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n00000000 <entry_function>:\n   0:   b580            push    {r7, lr}\n   2:   466f            mov     r7, sp\n   4:   b082            sub     sp, #8\n   6:   9001            str     r0, [sp, #4]\n   8:   1d81            adds    r1, r0, #6\n   a:   460a            mov     r2, r1\n   c:   4281            cmp     r1, r0\n   e:   9200            str     r2, [sp, #0]\n  10:   d30b            bcc.n   2a <entry_function+0x2a>\n  12:   e7ff            b.n     14 <entry_function+0x14>\n  14:   9800            ldr     r0, [sp, #0]\n  16:   b002            add     sp, #8\n  18:   e8bd 4080       ldmia.w sp!, {r7, lr}\n  1c:   4671            mov     r1, lr\n  1e:   4672            mov     r2, lr\n  20:   4673            mov     r3, lr\n  22:   46f4            mov     ip, lr\n  24:   f38e 8800       msr     CPSR_f, lr\n  28:   4774            bxns    lr\n  2a:   f240 0000       movw    r0, #0\n  2e:   f2c0 0000       movt    r0, #0\n  32:   f240 0200       movw    r2, #0\n  36:   f2c0 0200       movt    r2, #0\n  3a:   211c            movs    r1, #28\n  3c:   f7ff fffe       bl      0 <_ZN4core9panicking5panic17h5c028258ca2fb3f5E>\n  40:   defe            udf     #254    ; 0xfe\n```\n\n----------------------------------------\n\nTITLE: Building Rust Compiler\nDESCRIPTION: This snippet builds the Rust compiler using the provided configuration options. It indicates the stage of the build which targets the Rust library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./x.py build --stage 1 library\n```\n\n----------------------------------------\n\nTITLE: Rustup Target Addition\nDESCRIPTION: These commands use rustup to add the OpenHarmony targets for aarch64, armv7, and x86_64 architectures, enabling cross-compilation to these platforms.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add aarch64-unknown-linux-ohos\nrustup target add armv7-unknown-linux-ohos\nrustup target add x86_64-unknown-linux-ohos\n```\n\n----------------------------------------\n\nTITLE: Generating Full Rust Installer with gen-installer.sh\nDESCRIPTION: This bash command uses gen-installer.sh to create a full Rust installer. It specifies various parameters including product name, manifest directory, success message, and directory paths for the installation process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-installer/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./gen-installer.sh --product-name=Rust \\\n                   --rel-manifest-dir=rustlib \\\n                   --success-message=Rust-is-ready-to-roll. \\\n                   --image-dir=./install-image \\\n                   --work-dir=./temp \\\n                   --output-dir=./dist \\\n                   --non-installed-overlay=./overlay \\\n                   --package-name=rustc-nightly-i686-apple-darwin \\\n                   --component-name=rustc \\\n                   --legacy-manifest-dirs=rustlib \\\n                   --bulk-dirs=share/doc\n```\n\n----------------------------------------\n\nTITLE: Desugaring Closure with Immutable Reference in Rust\nDESCRIPTION: The purpose of this Rust code is to demonstrate how variables captured by a non-mutating closure are treated as immutable references by the Rust compiler. The closure captures a local variable `x` through immutable borrowing (`Fn`). It is highlighted with the MIR dump that shows how `x` is handled in the compiled form. Prerequisites include a compiler setup with the ability to process command-line flags and generate MIR dumps.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/closure.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn closure(f: impl Fn()) {\n    f();\n}\n\nfn main() {\n    let x: i32 = 10;\n    closure(|| println!(\"Hi {}\", x));  // The closure just reads x.\n    println!(\"Value of x after return {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Rust Linkage Examples\nDESCRIPTION: Shows valid implementations of the #[linkage] attribute using Option<function pointer>, Option<reference>, and raw pointer types that correctly match C's nullable pointer semantics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0791.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(linkage)]\n\nextern \"C\" {\n    #[linkage = \"extern_weak\"]\n    static foo: Option<unsafe extern \"C\" fn()>;\n\n    #[linkage = \"extern_weak\"]\n    static bar: Option<&'static i8>;\n\n    #[linkage = \"extern_weak\"]\n    static baz: *mut i8;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of offset_of! Macro with Enum Variants in Rust\nDESCRIPTION: This example demonstrates an incorrect usage of the offset_of! macro that results in error E0795. The error occurs because the second argument is an enum variant (Some) rather than a field within a variant.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0795.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(offset_of_enum)]\n\nlet x = std::mem::offset_of!(Option<u8>, Some);\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Unpretty Flag Usage\nDESCRIPTION: Command to inspect the expanded module source after macro expansion using rustc's unpretty flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc my_mod.rs -Z unpretty=hir\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of rustc_on_unimplemented Attribute in Rust\nDESCRIPTION: Demonstrates incorrect usage of the rustc_on_unimplemented attribute with an empty message parameter. This example shows what not to do, as empty attributes will not provide helpful error messages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0232.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n#![allow(internal_features)]\n\n#[rustc_on_unimplemented(lorem=\"\")] // error!\ntrait BadAnnotation {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Toolchain for powerpc64le Target\nDESCRIPTION: Specifies compiler, archiver, and linker paths for powerpc64le-unknown-linux-musl target in bootstrap configuration\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64le-unknown-linux-musl.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.powerpc64le-unknown-linux-musl]\ncc = \"powerpc64le-linux-musl-gcc\"\ncxx = \"powerpc64le-linux-musl-g++\"\nar = \"powerpc64le-linux-musl-ar\"\nlinker = \"powerpc64le-linux-musl-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Bootstrap Configuration for Building Rust from Source\nDESCRIPTION: This TOML configuration file is used to build a Rust toolchain from source for the OpenHarmony targets. It specifies the compiler profile, build options, and paths to the C compiler, C++ compiler, archiver, ranlib, and linker for each target architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/openharmony.md#2025-04-21_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\nprofile = \"compiler\"\nchange-id = 115898\n\n[build]\nsanitizers = true\nprofiler = true\n\n[target.aarch64-unknown-linux-ohos]\ncc = \"/path/to/aarch64-unknown-linux-ohos-clang.sh\"\ncxx = \"/path/to/aarch64-unknown-linux-ohos-clang++.sh\"\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nranlib = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\"\nlinker  = \"/path/to/aarch64-unknown-linux-ohos-clang.sh\"\n\n[target.armv7-unknown-linux-ohos]\ncc = \"/path/to/armv7-unknown-linux-ohos-clang.sh\"\ncxx = \"/path/to/armv7-unknown-linux-ohos-clang++.sh\"\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nranlib = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\"\nlinker  = \"/path/to/armv7-unknown-linux-ohos-clang.sh\"\n\n[target.x86_64-unknown-linux-ohos]\ncc = \"/path/to/x86_64-unknown-linux-ohos-clang.sh\"\ncxx = \"/path/to/x86_64-unknown-linux-ohos-clang++.sh\"\nar = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\"\nranlib = \"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\"\nlinker  = \"/path/to/x86_64-unknown-linux-ohos-clang.sh\"\n```\n\n----------------------------------------\n\nTITLE: Bare-Metal Target Configuration for Cortex-M23\nDESCRIPTION: Specifies target details for Arm Cortex-M23 processors, including CPU type, ABI, and architectural constraints\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/thumbv8m.base-none-eabi.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| CPU         | FPU | Target CPU   | Target Features       |\n| ----------- | --- | ------------ | --------------------- |\n| Cortex-M23  | No  | `cortex-m23` | None                  |\n```\n\n----------------------------------------\n\nTITLE: Configuring RISC-V Target for Rust Build - TOML\nDESCRIPTION: This snippet sets the target for Rust build to the RISC-V architecture using the musl libc. The target is specified in the build configuration for rustc. It requires a compatible RISC-V compiler to be available in the system's PATH.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"riscv64gc-unknown-linux-musl\"]\n```\n\n----------------------------------------\n\nTITLE: Comparing Span Contexts\nDESCRIPTION: Demonstrates how to compare span contexts to detect if expressions come from different macro expansions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nif left.span.ctxt() != right.span.ctxt() {\n    // The code author most likely cannot modify this expression\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Clippy Lint\nDESCRIPTION: This Rust macro, `declare_clippy_lint!`, is used to declare a new Clippy lint. It provides the structure for defining the lint including its description, why it's bad, an example of the issue, and an example of how to fix it. It also includes the Clippy version and lint group.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/defining_lints.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_clippy_lint! {\n    /// ### What it does\n    ///\n    /// // Describe here what does the lint do.\n    ///\n    /// Triggers when detects...\n    ///\n    /// ### Why is this bad?\n    ///\n    /// // Describe why this pattern would be bad\n    ///\n    /// It can lead to...\n    ///\n    /// ### Example\n    /// ```rust\n    /// // example code where Clippy issues a warning\n    /// ```\n    /// Use instead:\n    /// ```rust\n    /// // example code which does not raise Clippy warning\n    /// ```\n    #[clippy::version = \"1.70.0\"] // <- In which version was this implemented, keep it up to date!\n    pub LINT_NAME, // <- The lint name IN_ALL_CAPS\n    pedantic, // <- The lint group\n    \"default lint description\" // <- A lint description, e.g. \"A function has an unit return type.\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Iterator Trait Implementation Using Diagnostic Items\nDESCRIPTION: Demonstrates how to check if an expression implements the Iterator trait using diagnostic items and the LateContext. Uses the clippy_utils library and rustc's type checking facilities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/trait_checking.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::is_trait_method;\nuse rustc_hir::Expr;\nuse rustc_lint::{LateContext, LateLintPass};\nuse rustc_span::symbol::sym;\n\nimpl LateLintPass<'_> for CheckIteratorTraitLint {\n    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n\t\tlet implements_iterator = cx.tcx.get_diagnostic_item(sym::Iterator).map_or(false, |id| {\n    \t\timplements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n\t\t});\n\t\tif implements_iterator {\n\t\t\t// [...]\n\t\t}\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Trait Implementation Example in Rust\nDESCRIPTION: Example showing a compile error when trying to use a type (i32) that doesn't implement a required trait (Foo). This demonstrates the E0277 error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0277.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Binary Digits with Underscore Error\nDESCRIPTION: This snippet demonstrates an error case where a binary integer literal (0b_) is defined with only an underscore after the prefix, without digits. This should trigger a compiler error for missing digits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0b_\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting External HTML Root URLs for Dependencies in Rustdoc\nDESCRIPTION: Shows how to control how Rustdoc links to types from non-local crates. This allows specifying custom URLs for dependencies when the documentation is hosted elsewhere or not available in the output directory.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --extern-html-root-url some-crate=https://example.com/some-crate/1.0.1\n```\n\n----------------------------------------\n\nTITLE: Registering Revision Names in FileCheck Directives\nDESCRIPTION: This snippet shows how to register the current revision name as an additional prefix for FileCheck directives by using `//@[revision-name]`. It exemplifies how to structure tests for coverage and normal scenarios.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/compiletest.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"//@ revisions: NORMAL COVERAGE\\n//@[COVERAGE] compile-flags: -Cinstrument-coverage\\n//@[COVERAGE] needs-profiler-runtime\\n\\n// COVERAGE:   @__llvm_coverage_mapping\\n// NORMAL-NOT: @__llvm_coverage_mapping\\n\\n// CHECK: main\\nfn main() {}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Tier 3 iOS Targets in Bootstrap Configuration\nDESCRIPTION: Configuration example for bootstrap.toml to enable building tier 3 iOS targets (armv7s and i386) in a rustc build.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-ios.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"armv7s-apple-ios\", \"i386-apple-ios\"]\n```\n\n----------------------------------------\n\nTITLE: Creating a Static Library\nDESCRIPTION: This CMake command creates a static library named `cmake_foo` using the source files listed in the `SOURCES` variable. The `STATIC` keyword specifies that a static library should be created.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(cmake_foo STATIC\n    ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Erroneous Usage of ffi_const and ffi_pure Attributes in Rust\nDESCRIPTION: This code snippet demonstrates the incorrect usage of both ffi_const and ffi_pure attributes on a single function declaration. This combination is not allowed as ffi_const provides stronger guarantees than ffi_pure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0757.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ffi_const, ffi_pure)]\n\nextern \"C\" {\n    #[unsafe(ffi_const)]\n    #[unsafe(ffi_pure)]\n    //~^ ERROR `#[ffi_const]` function cannot be `#[ffi_pure]`\n    pub fn square(num: i32) -> i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Code Embedding in Rust Compiler Debug Information\nDESCRIPTION: This snippet outlines the usage of the 'embed-source' flag in the Rust compiler. It controls whether the compiler embeds the program source code text into the object debug information section. The flag accepts various boolean-like values and is used in conjunction with DWARF debug information settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/embed-source.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `embed-source`\n\nThis flag controls whether the compiler embeds the program source code text into\nthe object debug information section. It takes one of the following values:\n\n* `y`, `yes`, `on` or `true`: put source code in debug info.\n* `n`, `no`, `off`, `false` or no value: omit source code from debug info (the default).\n\nThis flag is ignored in configurations that don't emit DWARF debug information\nand is ignored on non-LLVM backends. `-Z embed-source` requires DWARFv5. Use\n`-Z dwarf-version=5` to control the compiler's DWARF target version and `-g` to\nenable debug info generation.\n```\n\n----------------------------------------\n\nTITLE: Including HTML After Content\nDESCRIPTION: This code snippet demonstrates how to use the `--html-after-content` flag to include HTML files after the main content of the generated documentation.  This is useful for adding footers or concluding sections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs --html-after-content extra.html\n$ rustdoc README.md --html-after-content extra.html\n```\n\n----------------------------------------\n\nTITLE: Completion Implementation Core (Rust)\nDESCRIPTION: This function implements the core logic of code completion, collecting the completion context and running a series of independent completion routines to generate completion suggestions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/lib.rs#L148-L229\n```\n\n----------------------------------------\n\nTITLE: Setup Environment for Fuchsia Compilation\nDESCRIPTION: This shell script sets up environment variables for cross-compiling Rust on Fuchsia. Replace placeholders with actual paths and ensure necessary tools and libraries are accessible from these paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n# Configure this environment variable to be the path to the downloaded SDK\nexport SDK_PATH=\"<SDK path goes here>\"\n\nexport CFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\nexport CXXFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\nexport LDFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib\"\nexport CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib\"\nexport CFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\nexport CXXFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\nexport LDFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib\"\nexport CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\"\n```\n\n----------------------------------------\n\nTITLE: Example Pattern for Repeated Literals\nDESCRIPTION: Example of a pattern that matches repeated boolean literals in an array, and how a potential lint could suggest using a more concise repetition syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    my_pattern: Expr =\n        Array( Lit(Bool(false)) Lit(Bool(false)) )\n}\n```\n\n----------------------------------------\n\nTITLE: AstIdMap for Source Mapping (Rust)\nDESCRIPTION: This code defines the AstIdMap structure that maps position-independent AstIds to position-dependent syntax nodes, enabling connections between stable representations and actual source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/ast_id_map.rs#L136-L142\n```\n\n----------------------------------------\n\nTITLE: Travis CI Configuration for Clippy\nDESCRIPTION: YAML configuration for integrating Clippy into Travis CI pipeline\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/README.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nlanguage: rust\nrust:\n  - stable\n  - beta\nbefore_script:\n  - rustup component add clippy\nscript:\n  - cargo clippy\n  # if you want the build job to fail when encountering warnings, use\n  - cargo clippy -- -D warnings\n  # in order to also check tests and non-default crate features, use\n  - cargo clippy --all-targets --all-features -- -D warnings\n  - cargo test\n  # etc.\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeFoldable for Structs in Rust\nDESCRIPTION: This example shows how to implement the `TypeFoldable` trait for a custom struct `MyFoldable`. It requires the `TypeFolder` trait and assumes knowledge of folding operations in Rust. The `super_fold_with` method iterates over fields of `MyFoldable` to invoke `fold_with` on each, enabling selective replacement within the struct during type folding. Inputs include an instance of `MyFoldable`, and the output is a new folded instance of the same type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty-fold.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl TypeFoldable for MyFoldable {\n  fn super_fold_with(&self, folder: &mut impl TypeFolder<'tcx>) -> MyFoldable {\n    MyFoldable {\n      def_id: self.def_id.fold_with(folder),\n      ty: self.ty.fold_with(folder),\n    }\n  }\n\n  fn super_visit_with(..) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configuration for armv7-unknown-linux-uclibceabi in TOML\nDESCRIPTION: This TOML snippet sets up the build configuration for compiling Rust programs targeting armv7-unknown-linux-uclibceabi. It specifies the compiler, linker, and other tools required for the build process. Dependencies include having a complete cross-compilation toolchain installed for Armv7-A.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabi.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\nbuild-stage = 2\\ntarget = [\\\"armv7-unknown-linux-uclibceabi\\\"]\\n\\n[target.armv7-unknown-linux-uclibceabi]\\ncc = \\\"/path/to/arm-unknown-linux-uclibcgnueabi-gcc\\\"\\ncxx = \\\"/path/to/arm-unknown-linux-uclibcgnueabi-g++\\\"\\nar = \\\"path/to/arm-unknown-linux-uclibcgnueabi-ar\\\"\\nranlib = \\\"/path/to/arm-unknown-linux-uclibcgnueabi-ranlib\\\"\\nlinker = \\\"/path/to/arm-unknown-linux-uclibcgnueabi-gcc\\\"\n```\n\n----------------------------------------\n\nTITLE: Robots.txt Disallow Rules for Rust Website\nDESCRIPTION: This robots.txt snippet configures web crawler access. It prevents crawlers from accessing specific directories related to old versions of the Rust book documentation, ensuring that search engines primarily index the latest content.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\n\"User-agent: *\\nDisallow: /1.\\nDisallow: /0.\\nDisallow: /book/first-edition/\\nDisallow: /book/second-edition/\\nDisallow: /stable/book/first-edition/\\nDisallow: /stable/book/second-edition/\\nDisallow: /beta/book/first-edition/\\nDisallow: /beta/book/second-edition/\\nDisallow: /nightly/book/first-edition/\\nDisallow: /nightly/book/second-edition/\"\n```\n\n----------------------------------------\n\nTITLE: Defining dylib-lto Option in Rust Compiler\nDESCRIPTION: Specifies the `dylib-lto` configuration option which enables Link Time Optimization for dynamic libraries. This is primarily used when compiling the Rust compiler itself, specifically for the `librustc_driver` dylib.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/dylib-lto.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## `dylib-lto`\n\nThis option enables using LTO for the `dylib` crate type. This is currently only used for compiling\n`rustc` itself (more specifically, the `librustc_driver` dylib).\n```\n\n----------------------------------------\n\nTITLE: Defining IsMatch Trait in Rust\nDESCRIPTION: This Rust code snippet defines a generic trait 'IsMatch' for matching pattern tree nodes against specific syntax tree nodes. Dependencies include Rust's trait system and type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub trait IsMatch<O> {\n    fn is_match(&self, other: &'o O) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SIGPIPE kill behavior in Rust\nDESCRIPTION: Example program showing how -Zon-broken-pipe=kill affects program behavior when writing to a closed pipe. The program will be terminated when the pipe is closed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/on-broken-pipe.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        println!(\"hello world\");\n    }\n}\n```\n\nLANGUAGE: console\nCODE:\n```\n$ rustc -Zon-broken-pipe=kill main.rs\n$ ./main | head -n1\nhello world\n```\n\n----------------------------------------\n\nTITLE: Erroneous In-Band Lifetimes Usage in Rust\nDESCRIPTION: This code snippet demonstrates incorrect usage of in-band lifetimes mixed with explicit lifetime binders, which is no longer supported in Rust. It shows examples of errors in function declarations, struct implementations, and impl blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0688.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(in_band_lifetimes)]\n\nfn foo<'a>(x: &'a u32, y: &'b u32) {}   // error!\n\nstruct Foo<'a> { x: &'a u32 }\n\nimpl Foo<'a> {\n    fn bar<'b>(x: &'a u32, y: &'b u32, z: &'c u32) {}   // error!\n}\n\nimpl<'b> Foo<'a> {  // error!\n    fn baz() {}\n}\n```\n\n----------------------------------------\n\nTITLE: No-std Rust Program for SPARC\nDESCRIPTION: A `no_std` Rust application example targeting SPARC architecture, using C functions for output. This requires a compatible C environment to interact with the SPARC simulator for console output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#![no_std]\n#![no_main]\n\nextern \"C\" {\n    fn putchar(ch: i32);\n    fn _exit(code: i32) -> !;\n}\n\n#[no_mangle]\nextern \"C\" fn main() -> i32 {\n    let message = \"Hello, this is Rust!\";\n    for b in message.bytes() {\n        unsafe {\n            putchar(b as i32);\n        }\n    }\n    0\n}\n\n#[panic_handler]\nfn panic(_panic: &core::panic::PanicInfo) -> ! {\n    unsafe {\n        _exit(1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Sub-binding in Rust Pattern Matching\nDESCRIPTION: This code snippet shows an example of a previously disallowed sub-binding pattern in Rust. It attempts to use a ref binding with a nested pattern, which could potentially violate memory safety.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0303.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch Some(\"hi\".to_string()) {\n    ref op_string_ref @ Some(s) => {},\n    None => {},\n}\n```\n\n----------------------------------------\n\nTITLE: Error Annotation Example\nDESCRIPTION: This code snippet shows an example of error annotations in UI tests. Error annotations are comments within the source code that specify the expected compiler errors. These annotations ensure that the compiler emits the expected errors and help prevent mistakes by providing a direct link between the error and its location in the source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    boom  //~ ERROR cannot find value `boom` in this scope [E0425]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring LLVM Instruction Set in Bootstrap\nDESCRIPTION: Through the use of `cxxflags` and `cflags` options in `bootstrap.toml`, this snippet specifies an instruction set architecture (ISA) for compiling LLVM to `x86-64-v3`. This customization enhances performance on compatible hardware by utilizing specific instructions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[llvm]\ncxxflags = \"-march=x86-64-v3\"\ncflags = \"-march=x86-64-v3\"\n```\n\n----------------------------------------\n\nTITLE: Defining Encodable and Decodable Traits in Rust\nDESCRIPTION: The core traits used for serialization in rustc, defining the interface for encoding and decoding data. These traits are implemented by various types to allow them to be serialized and deserialized during compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/serialization.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Encodable<S: Encoder> {\n    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n}\n\npub trait Decodable<D: Decoder>: Sized {\n    fn decode(d: &mut D) -> Result<Self, D::Error>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Salsa Input Query Group in Rust\nDESCRIPTION: Example of defining a Salsa input query group using a trait with the #[salsa::query_group] attribute. This demonstrates how to create base input queries that don't rely on derived input, allowing values to be set externally.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/queries/salsa.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// This attribute will process this tree, produce this tree as output, and produce\n/// a bunch of intermediate stuff that Salsa also uses. One of these things is a\n/// \"StorageStruct\", whose name we have specified in the attribute.\n///\n/// This query group is a bunch of **input** queries, that do not rely on any\n/// derived input.\n#[salsa::query_group(InputsStorage)]\npub trait Inputs {\n    /// This attribute (`#[salsa::input]`) indicates that this query is a base\n    /// input, therefore `set_manifest` is going to be auto-generated\n    #[salsa::input]\n    fn manifest(&self) -> Manifest;\n\n    #[salsa::input]\n    fn source_text(&self, name: String) -> String;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing perf-focus for Analysis\nDESCRIPTION: Command to install the perf-focus tool via cargo. This utility helps analyze perf profiles with targeted queries about time spent in specific functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncargo install perf-focus\n```\n\n----------------------------------------\n\nTITLE: Profiling with RA_PROFILE_JSON\nDESCRIPTION: This snippet demonstrates how to use the `RA_PROFILE_JSON` environment variable to enable machine-readable JSON output for profiling in rust-analyzer, filtering by span name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nRA_PROFILE=* // dump everything\nRA_PROFILE_JSON=\"vfs_load|parallel_prime_caches|discover_command\" // dump selected spans\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enhanced Reference Pattern Matching in Rust Edition 2024\nDESCRIPTION: This example illustrates the experimental `ref_pat_eat_one_layer_2024_structural` feature that allows using `&` patterns in more contexts, including matching against `ref` binding mode and `&mut` references.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/ref-pat-eat-one-layer-2024-structural.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(ref_pat_eat_one_layer_2024_structural)]\n#![allow(incomplete_features)]\n#\n# // Tests type equality in a way that avoids coercing `&&T` or `&mut T` to `&T`.\n# trait Eq<T> {}\n# impl<T> Eq<T> for T {}\n# fn has_type<T>(_: impl Eq<T>) {}\n\n// `&` can match against a `ref` binding mode instead of a reference type:\nlet (x, &y) = &(0, 1);\nhas_type::<&u8>(x);\nhas_type::<u8>(y);\n\n// `&` can match against `&mut` references:\nlet &z = &mut 2;\nhas_type::<u8>(z);\n```\n\n----------------------------------------\n\nTITLE: Enabling Thin LTO in Bootstrap\nDESCRIPTION: This TOML snippet configures the Rust compiler (`rustc`) to use Thin Link Time Optimization (LTO) by setting the `rust.lto` option to 'thin' in the `bootstrap.toml` file. This enhancement is primarily supported on the `x86_64-unknown-linux-gnu` target, with potential but untested compatibility on other architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/optimized-build.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\nlto = \"thin\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Use of Stability Attributes in Rust\nDESCRIPTION: This code snippet shows an example of incorrectly using #[stable] and #[unstable] attributes on a function outside the standard library. These attributes are reserved for use within the Rust standard library and will cause compilation errors when used in user crates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0734.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\n----------------------------------------\n\nTITLE: Specifying MIPS64 OpenWrt Linux MUSL Target in Rust\nDESCRIPTION: This code snippet defines the target triple for MIPS64 OpenWrt Linux with MUSL libc. It's used to identify the specific target architecture and environment for cross-compilation in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips64-openwrt-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `mips64-openwrt-linux-musl`\n```\n\n----------------------------------------\n\nTITLE: Calling stdcall_fn_9 - Rust\nDESCRIPTION: This snippet calls the `stdcall_fn_9` function with an integer (1) and a floating-point number (3.0) as arguments in Rust.  It demonstrates calling with the `stdcall` convention. The output will depend on the functions implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/raw-dylib-alt-calling-convention/output.txt#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nstdcall_fn_9(1, 3.0)\n```\n\n----------------------------------------\n\nTITLE: Merging Candidate Responses in Rust Trait Solver\nDESCRIPTION: When multiple ways to prove a goal exist, the solver uses try_merge_responses to attempt merging the results. If merging fails, it falls back to flounder, returning ambiguity. In some cases, certain choices may be incompletely preferred over others.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/the-solver.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nEvalCtxt::try_merge_responses\n```\n\n----------------------------------------\n\nTITLE: Running Programs with Hexagon Toolchain\nDESCRIPTION: This snippet demonstrates how to run a program using the Hexagon toolchain's QEMU and specifies the library path. The path must be adjusted to point to the installed Hexagon C library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-linux-musl.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr/ ./hello\n```\n\n----------------------------------------\n\nTITLE: Building with Cargo for Experimental Target\nDESCRIPTION: This text snippet demonstrates how to use the `cargo build` command with the `-Z build-std` flag to build for the `aarch64-kmc-solid_asp3` target on Rust Nightly. It allows building without the target artifacts being available.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/kmc-solid.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ncargo build -Z build-std --target aarch64-kmc-solid_asp3\n```\n\n----------------------------------------\n\nTITLE: WorkerLocal Implementation in Parallel Compiler - Rust\nDESCRIPTION: The `WorkerLocal` data structure is designed to hold worker-local values for each thread in a thread pool within the parallel compiler. It is accessed through a specific implementation and is essential for memory allocation in a parallel environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/parallel-rustc.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// `WorkerLocal` is a special data structure implemented for parallel compilers.\n/// It holds worker-locals values for each thread in a thread pool. You can only\n/// access the worker local value through the `Deref` `impl` on the thread pool it\n/// was constructed on. It panics otherwise.\n`WorkerLocal` is used to implement the `Arena` allocator in the parallel\nenvironment, which is critical in parallel queries. Its implementation is\nlocated in the [`rustc_data_structures::sync::worker_local`] module. However,\nin the non-parallel compiler, it is implemented as `(OneThread<T>)`, whose `T`\ncan be accessed directly through `Deref::deref`.\n```\n\n----------------------------------------\n\nTITLE: Example of Rust Code Triggering a Compilation Error\nDESCRIPTION: This Rust code snippet demonstrates a simple situation leading to a compilation error due to type mismatches, which can be traced for debugging purposes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    1 + ();\n}\n```\n\n----------------------------------------\n\nTITLE: Valid and Invalid Zero-Sized Transparent Unions in Rust\nDESCRIPTION: Shows examples of valid non-transparent unions and invalid transparent unions with only zero-sized fields. Transparent unions must have exactly one non-zero-sized field.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/transparent-unions.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(transparent_unions)]\n\n// This (non-transparent) union is already valid in stable Rust:\npub union GoodUnion {\n    pub nothing: (),\n}\n\n// Error: transparent union needs exactly one non-zero-sized field, but has 0\n// #[repr(transparent)]\n// pub union BadUnion {\n//     pub nothing: (),\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing By-Value Trait Objects in Rust\nDESCRIPTION: This snippet demonstrates how to use by-value self arguments without Self: Sized bounds in trait implementations. It shows how this feature allows for more flexible trait object usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/unsized-locals.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(unsized_fn_params)]\n\ntrait Foo {\n    fn foo(self) {}\n}\n\nimpl<T: ?Sized> Foo for T {}\n\nfn main() {\n    let slice: Box<[i32]> = Box::new([1, 2, 3]);\n    <[i32] as Foo>::foo(*slice);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring rust-analyzer in Kate Text Editor (JSON)\nDESCRIPTION: This JSON snippet configures rust-analyzer options within the Kate text editor through its LSP plugin. It disables cache priming, restricts checks to only the current target, and disables checks on save. The configuration is applied through Kate's User Server Settings and requires restarting the LSP server.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/other_editors.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"servers\": {\n        \"rust\": {\n            \"initializationOptions\": {\n                \"cachePriming\": {\n                    \"enable\": false\n                },\n                \"check\": {\n                    \"allTargets\": false\n                },\n                \"checkOnSave\": false\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Language Properties for Assembly Sources\nDESCRIPTION: This CMake command sets the `LANGUAGE` property to `ASM` for the files listed in `ASM_SOURCES`. This ensures that the CMake build system treats them as Assembly source files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset_source_files_properties(${ASM_SOURCES}\n                            PROPERTIES\n                            LANGUAGE ASM)\n```\n\n----------------------------------------\n\nTITLE: Serving Fuchsia Package\nDESCRIPTION: Commands to start a package repository server and register it with the Fuchsia emulator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_18\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx repository server start \\\n    --background --repository hello-fuchsia --repo-path pkg-repo\n\n${SDK_PATH}/tools/${ARCH}/ffx target repository register \\\n    --repository hello-fuchsia\n```\n\n----------------------------------------\n\nTITLE: Using Imported Trait Associated Function in Rust\nDESCRIPTION: Shows how to import the add function from std::ops::Add trait and use it directly in a reduce operation. The feature allows for cleaner syntax compared to the traditional approach of using Add::add.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/import-trait-associated-functions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(import_trait_associated_functions)]\n\nuse std::ops::Add::add;\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6];\n    let sum = numbers.into_iter().reduce(add); // instead of `.reduce(Add:add)`\n\n    assert_eq!(sum, Some(21));\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Target in TOML for ARM64e-Apple-iOS\nDESCRIPTION: This snippet demonstrates how to configure the build target in the 'bootstrap.toml' file for the ARM64e architecture on iOS. Users need to specify the 'target' list under the [build] section to include 'arm64e-apple-ios'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64e-apple-ios.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\ntarget = [\"arm64e-apple-ios\"]\n```\n\n----------------------------------------\n\nTITLE: Building Rust Programs for watchOS Targets\nDESCRIPTION: This console command compiles a Rust program for the specified watchOS target. The example demonstrates using the --target flag with rustc, assuming it has been built with support for the watchOS target architectures. The main input is the Rust source file, and outputs are the corresponding binaries for the watchOS target.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/apple-watchos.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ rustc --target aarch64-apple-watchos-sim your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Attribute Path Resolution Example\nDESCRIPTION: Demonstrates how attribute renaming works (or doesn't work) for built-in attributes. Shows that while the allow keyword can be imported with an alias, using it as an attribute will fail.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/attributes.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse allow as foo\n```\n\n----------------------------------------\n\nTITLE: Generating HIR Representation for Cargo Projects in Rust\nDESCRIPTION: This snippet demonstrates the command to generate a human-readable representation of the HIR using the `cargo` tool with the appropriate flag. It's crucial for developers needing to inspect the desugaring of their code during AST lowering.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir-debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ncargo rustc -- -Z unpretty=hir\n```\n\n----------------------------------------\n\nTITLE: Using the lint-llvm-ir Flag in Rust Compiler\nDESCRIPTION: This snippet shows how to use the lint-llvm-ir flag which adds a LintPass to the compiler pipeline. It can be combined with the llvm-args flag to abort compilation when errors are found in the generated LLVM IR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/lint-llvm-ir.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `lint-llvm-ir`\n\n---------------------\n\nThis flag will add `LintPass` to the start of the pipeline.\nYou can use it to check for common errors in the LLVM IR generated by `rustc`.\nYou can add `-Cllvm-args=-lint-abort-on-error` to abort the process if errors were found.\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code for Nintendo Switch\nDESCRIPTION: This command allows the user to compile Rust source code for the aarch64 Nintendo Switch target. It ensures that the generated binaries are compatible with the specified architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-nintendo-switch-freestanding.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrustc --target aarch64-nintendo-switch-freestanding your-code.rs\n```\n\n----------------------------------------\n\nTITLE: Creating Fuchsia Package Repository\nDESCRIPTION: Command to create a Fuchsia package repository.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx repository create pkg/repo\n```\n\n----------------------------------------\n\nTITLE: Target Specification Identifier\nDESCRIPTION: Unique identifier for the RISC-V 32-bit embedded target with support for RV32E, RV32EM, and RV32EMC instruction set architectures\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv32e-unknown-none-elf.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nriscv32{e,em,emc}-unknown-none-elf\n```\n\n----------------------------------------\n\nTITLE: Setting Up Incremental Compilation in bootstrap.toml\nDESCRIPTION: TOML configuration to enable incremental compilation for faster subsequent builds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/suggested.md#2025-04-21_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[rust]\nincremental = true\n```\n\n----------------------------------------\n\nTITLE: Multiple env-set Arguments Example 2\nDESCRIPTION: Example showing a subsequent compilation with fewer environment variables set. This would trigger recompilation since the X variable is no longer specified.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/env-set.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n--env-set A=B\n```\n\n----------------------------------------\n\nTITLE: Using Rust-like Pattern Syntax for Lints\nDESCRIPTION: This code snippet proposes a rust-like pattern syntax for matching if expressions with specific conditions, illustrating alternative ways to express patterns. The syntax remains a theoretical approach.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nif false {\n    #[*]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Flatpak SDK Extensions for Rust Development (Shell)\nDESCRIPTION: Installs required Flatpak SDK extensions (LLVM and Rust stable for runtime version 23.08) needed for C compilation and Rust tooling within the Flatpak sandbox. This is a prerequisite for using rust-analyzer effectively in a Flatpak installation of VS Code or VSCodium.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/vs_code.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nflatpak install org.freedesktop.Sdk.Extension.{llvm15,rust-stable}//23.08\n```\n\n----------------------------------------\n\nTITLE: Running LLVM IR Generation with Optimization\nDESCRIPTION: Commands to generate and optimize LLVM IR using rustc and LLVM's opt tool. Demonstrates how to emit LLVM IR with optimization flags and process it through LLVM's optimizer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc +local my-file.rs --emit=llvm-ir -O -C no-prepopulate-passes \\\n    -C codegen-units=1\n$ OPT=./build/$TRIPLE/llvm/bin/opt\n$ $OPT -S -O2 < my-file.ll > my\n```\n\n----------------------------------------\n\nTITLE: Split Match Arms Solution - Rust\nDESCRIPTION: This example shows the correct approach by splitting the patterns into separate match arms. Each arm handles its case independently, avoiding inconsistent variable binding issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0408.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(1);\nmatch x {\n    Some(y) => { /* use y */ }\n    None => { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Running rustc_codegen_gcc tests with LIBRARY_PATH\nDESCRIPTION: This command runs the `rustc_codegen_gcc` tests, explicitly setting the `LIBRARY_PATH` environment variable to the location of the libgccjit `.so` library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/running.md#2025-04-21_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n\nLIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/12/ ./x test compiler/rustc_codegen_gcc/\n\n```\n\n----------------------------------------\n\nTITLE: Building and running the type mismatch example with CFI\nDESCRIPTION: Shell commands demonstrating how to build and run the type mismatch example with CFI protection. With CFI, the invalid function call with mismatched types is detected and the program terminates.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi\" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu\n   ...\n   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)\n    Finished release [optimized] target(s) in 1m 07s\n     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-3`\nThe answer is: 12\nWith CFI enabled, you should not see the next answer\nIllegal instruction\n$\n```\n\n----------------------------------------\n\nTITLE: Declaring Lint Groups\nDESCRIPTION: This Rust code snippet illustrates the use of the `add_lint_group!` macro to define a lint group named `nonstandard_style`, which bundles multiple individual lints for unified management. Users can activate the group using attributes in their source code or command-line options. Requires knowledge of the lint macro system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nadd_lint_group!(sess,\n    \"nonstandard_style\",\n    NON_CAMEL_CASE_TYPES,\n    NON_SNAKE_CASE,\n    NON_UPPER_CASE_GLOBALS);\n\n```\n\n----------------------------------------\n\nTITLE: Profiling Rust Compiler with Samply\nDESCRIPTION: Shows how to profile the Rust compiler using the Samply sampling profiler via the 'samply' subcommand of 'x perf'.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./x perf samply\n```\n\n----------------------------------------\n\nTITLE: LocalAnalyzer Structure Definition\nDESCRIPTION: Analysis structure with multiple lifetime parameters needed for borrow checking in the generic backend implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/backend-agnostic.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct LocalAnalyzer<'mir, 'a, 'tcx> {\n  /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Spans from External Macros in Rust\nDESCRIPTION: This snippet demonstrates how to detect if a given span originates from a macro defined in an external crate using the `span.in_external_macro(cx.sess().source_map())` method.  This is useful to avoid linting code that the user can't change. This example depends on `a_crate_with_macros` and its macros. The input is a valid span, `match_span` in the example.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nuse a_crate_with_macros::foo;\n\n// `foo` is defined in `a_crate_with_macros`\nfoo!(\"bar\");\n\n// if we lint the `match` of `foo` call and test its span\nassert_eq!(match_span.in_external_macro(cx.sess().source_map()), true);\n```\n\n----------------------------------------\n\nTITLE: Emit MIR After a Specific Optimization - Rust\nDESCRIPTION: This code snippet emits the final MIR state after a particular optimization has been applied.  The output is saved to the specified `.after.mir` file. This is useful for verifying the final result of an optimization, rather than its intermediate steps.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// EMIT_MIR $file_name_of_some_mir_dump.after.mir\n```\n\n----------------------------------------\n\nTITLE: Using Iterator Combinators for Type Folding in Rust\nDESCRIPTION: This snippet demonstrates the analogy between Rust's iterator combinators and the `TypeFolder` and `TypeFoldable` traits. `TypeFolder` acts like the `map` operation, while `TypeFoldable` is akin to the `iter` method. There are no dependencies, but it assumes familiarity with Rust iterators. No parameters are involved in this comparison, and it serves purely for illustrative purposes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty-fold.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nvec.iter().map(|e1| foo(e2)).collect()\n```\n\n----------------------------------------\n\nTITLE: Printing Rust Target Library Directory\nDESCRIPTION: Demonstrates how to get the path to the target library directory using rustc's --print flag.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/command-line-arguments/print-options.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc --print target-libdir a.rs\n/home/[REDACTED]/.rustup/toolchains/beta-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib\n```\n\n----------------------------------------\n\nTITLE: Building a UEFI Driver - TOML\nDESCRIPTION: This snippet demonstrates how to modify build settings in Cargo to produce a UEFI runtime driver instead of the default application, by setting the appropriate subsystem linker argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/unknown-uefi.md#2025-04-21_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\n# In .cargo/config.toml:\n[build]\nrustflags = [\"-C\", \"link-args=/subsystem:efi_runtime_driver\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Library Path Environment Variable\nDESCRIPTION: Command to configure the library search path for custom LLVM installations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/remarks-on-perma-unstable-features.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nexport LD_LIBRARY_PATH=/path/to/llvm/lib:$LD_LIBRARY_PATH\n```\n\n----------------------------------------\n\nTITLE: Finding Clippy Commit in Rust Repo - Bash\nDESCRIPTION: This command sequence, executed within the Rust repository, retrieves the commit hash of the last Clippy sync for a given branch (`stable`, `beta`, or `master`).  It switches to the specified branch, then uses `git log`, `grep`, `head`, and `sed` to extract the commit hash from the merge commit message related to `src/tools/clippy/`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit switch <branch>\nSHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n```\n\n----------------------------------------\n\nTITLE: Enabling s390x Target in `bootstrap.toml`\nDESCRIPTION: This snippet shows how to enable the `s390x-unknown-linux-gnu` target when building Rust from source. It involves modifying the `bootstrap.toml` file to include the target in the `build.target` array. This configuration is required when building a custom Rust toolchain for the s390x architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n\n```toml\n[build]\ntarget = [\"s390x-unknown-linux-gnu\"]\n```\n\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_LOG environment variable to filter query tracing by arguments with regex\nDESCRIPTION: This bash command sets the `RUSTC_LOG` environment variable to enable tracing for the `typeck` query, but only when the `key` argument (a LocalDefId) matches the provided regular expression. This allows filtering query executions based on their arguments for more specific debugging.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_LOG=[typeck{key=.*name_of_item.*}]\n```\n\n----------------------------------------\n\nTITLE: Parsing Token Trees with Macro Parser in Rust\nDESCRIPTION: This function defines the interface for the macro parser. It takes a mutable reference to a `Parser` (representing the state of the Rust parser), and a slice of `MatcherLoc` (representing the pattern to match against). It returns a `ParseResult` indicating success, failure, or error during parsing. The token stream from the `parser` is matched against the `matcher` to produce bindings of metavariables.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn parse_tt(\n    &mut self,\n    parser: &mut Cow<'_, Parser<'_>>,\n    matcher: &[MatcherLoc]\n) -> ParseResult\n```\n\n----------------------------------------\n\nTITLE: Architecture Diagram - Stable MIR System Components\nDESCRIPTION: ASCII art diagram showing the interaction between external tools using stable_mir and the Rust compiler's rustc_smir component. The diagram illustrates the separation between external tools and the compiler infrastructure.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/stable_mir/README.md#2025-04-21_snippet_0\n\nLANGUAGE: ascii-art\nCODE:\n```\n    ┌──────────────────────────────────┐           ┌──────────────────────────────────┐\n    │   External Tool     ┌──────────┐ │           │ ┌──────────┐   Rust Compiler     │\n    │                     │          │ │           │ │          │                     │\n    │                     │stable_mir| │           │ │rustc_smir│                     │\n    │                     │          │ ├──────────►| │          │                     │\n    │                     │          │ │◄──────────┤ │          │                     │\n    │                     │          │ │           │ │          │                     │\n    │                     │          │ │           │ │          │                     │\n    │                     └──────────┘ │           │ └──────────┘                     │\n    └──────────────────────────────────┘           └──────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for C-SKY Targets\nDESCRIPTION: Modifies the 'bootstrap.toml' to include C-SKY targets for compilation. Requires an appropriate toolchain and stage setting for the 'rustc' build environment. Adjust the 'cc' path to point to the C-SKY GCC toolchain.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/csky-unknown-linux-gnuabiv2.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[build]\ntarget = [\"x86_64-unknown-linux-gnu\", \"csky-unknown-linux-gnuabiv2\", \"csky-unknown-linux-gnuabiv2hf\"]\nstage = 2\n\n[target.csky-unknown-linux-gnuabiv2]\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\ncc = \"${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc\"\n\n[target.csky-unknown-linux-gnuabiv2hf]\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\ncc = \"${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Applying Liveness Constraints to SCCs\nDESCRIPTION: Describes how liveness constraints are applied to SCCs in the region inference process.  The example shows how the liveness values associated with individual regions are unioned into the corresponding SCC's value.  The process involves iterating through each region, identifying its SCC, and updating the SCC's value by taking the union of its current value and the region's liveness values.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md#2025-04-21_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nfor each region R:\n  let S be the SCC that contains R\n  Values(S) = Values(S) union Liveness(R)\n```\n\n----------------------------------------\n\nTITLE: Correct Combined Self and Member Import in Rust\nDESCRIPTION: Demonstrates proper usage of 'self' keyword within a brace-enclosed list to import both namespace and specific members.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0429.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{self, Debug};\n```\n\n----------------------------------------\n\nTITLE: Running GCC Changelog Check Script\nDESCRIPTION: Executes the changelog verification script to check commit formatting\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./contrib/gcc-changelog/git_check_commit.py\n```\n\n----------------------------------------\n\nTITLE: Correlating NodeId and DefId with Source Code in Rust\nDESCRIPTION: This snippet details the flag used to correlate `NodeId`s and `DefId`s with source code, assisting developers in identifying specific nodes and definitions in their code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir-debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n-Z unpretty=expanded,identified\n```\n\n----------------------------------------\n\nTITLE: C Library Example for FFI\nDESCRIPTION: This C code snippet defines a function `do_twice` that takes a function pointer and an integer as input. It then calls the provided function twice with the given integer argument and returns the sum of the results. This serves as an example for the FFI (Foreign Function Interface) in the following Rust code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\nint\ndo_twice(int (*fn)(int), int arg)\n{\n    return fn(arg) + fn(arg);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic MIR Dump for Function\nDESCRIPTION: Demonstrates how to dump MIR for a specific function using the `-Z dump-mir` flag in the Rust compiler. This command will generate MIR dump files for functions matching the specified filter.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/debugging.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc -Z dump-mir=foo ...\n```\n\n----------------------------------------\n\nTITLE: Span Context Assertion\nDESCRIPTION: Shows how to assert that spans from different parts of a macro expansion have different contexts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/macro_expansions.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// x.is_some() is from inside the macro\n// x.unwrap() is from outside the macro\nassert_ne!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n```\n\n----------------------------------------\n\nTITLE: Defining SyntaxNode Structure - Rust\nDESCRIPTION: This snippet defines the structure of `SyntaxNode` and its underlying data structure `SyntaxData`. It includes methods for creating root nodes, accessing parent nodes, and iterating over children. The focus is on maintaining parent pointers for relational access in syntax trees.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntype SyntaxNode = Arc<SyntaxData>;\n\nstruct SyntaxData {\n    offset: usize,\n    parent: Option<SyntaxNode>,\n    green: Arc<GreenNode>,\n}\n\nimpl SyntaxNode {\n    fn new_root(root: Arc<GreenNode>) -> SyntaxNode {\n        Arc::new(SyntaxData {\n            offset: 0,\n            parent: None,\n            green: root,\n        })\n    }\n    fn parent(&self) -> Option<SyntaxNode> {\n        self.parent.clone()\n    }\n    fn children(&self) -> impl Iterator<Item = SyntaxNode> {\n        let mut offset = self.offset;\n        self.green.children().map(|green_child| {\n            let child_offset = offset;\n            offset += green_child.text_len;\n            Arc::new(SyntaxData {\n                offset: child_offset,\n                parent: Some(Arc::clone(self)),\n                green: Arc::clone(green_child),\n            })\n        })\n    }\n}\n\nimpl PartialEq for SyntaxNode {\n    fn eq(&self, other: &SyntaxNode) -> bool {\n        self.offset == other.offset\n            && Arc::ptr_eq(&self.green, &other.green)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Default Analysis Instance in Rust\nDESCRIPTION: This snippet demonstrates how to create an empty analysis instance using the default method within the AnalysisHost component. It highlights the structure necessary to initiate the analysis process, which is crucial for managing input changes and query responses.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Creating an empty analysis instance\nlet analysis_host = AnalysisHost::default();\n```\n\n----------------------------------------\n\nTITLE: Defining Server Status Notification in TypeScript\nDESCRIPTION: Defines an experimental server status notification with health status, quiescence state, and optional message for client-side status display\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ServerStatusParams {\n    health: \"ok\" | \"warning\" | \"error\",\n    quiescent: boolean,\n    message?: string,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Crate Dependencies and Configuration\nDESCRIPTION: Defines a CrateData structure containing configuration for a hello_world project, including its dependencies on core Rust crates like std, alloc, and proc_macro. Specifies edition 2018, display name, cfg options, and environment settings.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_hello_world_project_model.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nproc_macro_cwd: None,\n    },\n    10: CrateData {\n        root_file_id: FileId(\n            11,\n        ),\n        edition: Edition2018,\n        version: None,\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello_world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {},\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(1),\n                name: CrateName(\n                    \"core\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"alloc\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(6),\n                name: CrateName(\n                    \"std\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(8),\n                name: CrateName(\n                    \"test\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"proc_macro\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello_world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: None,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Dataflow State Peeking for Initialization in Rust Compiler\nDESCRIPTION: This `#[rustc_mir]` attribute applied to a function enables the `rustc_peek` intrinsic calls within that function to query the dataflow state specifically related to the 'maybe initialized' analysis. If `rustc_peek` is called on an Lvalue whose 'maybe initialized' bit is not set at that control flow point, the compiler will emit an error, facilitating unit tests for initialization analysis.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/mir-dataflow/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[rustc_mir(rustc_peek_maybe_init)]\n```\n\n----------------------------------------\n\nTITLE: Handling File Changes in Rust\nDESCRIPTION: This code showcases how to define a Change object, which contains file changes that need to be applied through the AnalysisHost. The Change object serves as a wrapper around file modifications, essential for input management within rust-analyzer.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Defining a change that wraps a file modification\nlet change = Change::change_file(file_id, Some(Arc::new(new_content)));\n```\n\n----------------------------------------\n\nTITLE: Handling Integer with Missing Exponent Digits in Rust Lexer\nDESCRIPTION: Illustrates how the Rust lexer handles integer literals followed by an exponent symbol (`e` or `E`) and an optional sign (`+` or `-`) but without the necessary digits after the exponent. This produces a `FLOAT_NUMBER` token with an error message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_exponent.txt#_snippet_1\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42e+\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42e-\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42E+\" error: Missing digits after the exponent symbol\n```\n\nLANGUAGE: Lexer Output Line\nCODE:\n```\nFLOAT_NUMBER \"42E-\" error: Missing digits after the exponent symbol\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Hexadecimal Digits with Underscore Error\nDESCRIPTION: This snippet shows an error case where a hexadecimal integer literal (0x_) is defined with only an underscore after the prefix, but no digits. This results in a 'missing digits' compiler error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0x_\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Unstable Coverage Options in Rust\nDESCRIPTION: Shows the syntax for the unstable '-Z coverage-options' flag. This option allows for more advanced configuration of code coverage features, but its exact behavior is not described here.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/instrument-coverage.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n-Z coverage-options=<options>\n```\n\n----------------------------------------\n\nTITLE: Partial Clone of the Rust Repository\nDESCRIPTION: This code snippet illustrates how to perform a partial clone of the Rust repository, which saves bandwidth and disk space by only fetching current file contents and deferring the retrieval of other contents. This is useful for users with slower internet connections.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --filter='blob:none' https://github.com/rust-lang/rust.git\ncd rust\n```\n\n----------------------------------------\n\nTITLE: Detailed Toolchain Path Configuration\nDESCRIPTION: Advanced configuration for specifying custom paths to RISC-V toolchain binaries\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv64gc-unknown-linux-gnu.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[target.riscv64gc-unknown-linux-gnu]\ncc = \"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc\"\ncxx = \"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-g++\"\nar = \"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ar\"\nranlib = \"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ranlib\"\nlinker = \"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Small Pattern Grammar Definition - Rust\nDESCRIPTION: Defines the grammar for what constitutes a 'small' pattern in Rust formatting rules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/style-guide/src/expressions.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nsmall:\n    - small_no_tuple\n    - unary tuple constructor: `(` small_no_tuple `,` `)`\n    - `&` small\n\nsmall_no_tuple:\n    - single token\n    - `&` small_no_tuple\n```\n\n----------------------------------------\n\nTITLE: Empty Values Check-Cfg Commands in Bash\nDESCRIPTION: Demonstrates how to check for configurations with no values or empty value sets.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/check-cfg.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustc --check-cfg 'cfg(name)'\nrustc --check-cfg 'cfg(name, values(none()))'\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for Rust-specific Functions\nDESCRIPTION: This snippet marks various Rust-specific functions as uninstrumented for DFSan. It includes memory allocation, deallocation, and core Rust functions that should not be instrumented.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfun:__rdl_alloc=uninstrumented\nfun:__rdl_alloc_zeroed=uninstrumented\nfun:__rdl_dealloc=uninstrumented\nfun:__rdl_realloc=uninstrumented\nfun:__rg_oom=uninstrumented\nfun:__rust_alloc=uninstrumented\nfun:__rust_alloc_error_handler=uninstrumented\nfun:__rust_alloc_zeroed=uninstrumented\nfun:__rust_dealloc=uninstrumented\nfun:__rust_realloc=uninstrumented\nfun:_ZN4core*=uninstrumented\nfun:_ZN3std*=uninstrumented\nfun:rust_eh_personality=uninstrumented\n```\n\n----------------------------------------\n\nTITLE: Testing MIPS R6 Binaries with QEMU\nDESCRIPTION: Sets up environment variables and uses QEMU to test cross-compiled MIPS R6 binaries on the build system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mips-release-6.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nenv \\\n    CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_LINKER=\"/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-gcc\" \\\n    CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_RUNNER=\"qemu-mips64el-static -L /var/ab/cross-root/mips64r6el\" \\\n    cargo run --release \\\n        --target mipsisa64r6el-unknown-linux-gnuabi64\n```\n\n----------------------------------------\n\nTITLE: Declaring Constant in Rust\nDESCRIPTION: This snippet illustrates the declaration of a constant named 'CONST' within a Rust module. It includes the necessary definition and location details. It is essential for ensuring constants are properly recognized by the Rust compiler. Inputs consist of the constant name and value, while outputs are the constant's reference during execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nFileSymbol {\n    name: \"CONST\",\n    def: Const(\n        Const {\n            id: ConstId(\n                0,\n            ),\n        },\n    ),\n    loc: DeclarationLocation {\n        hir_file_id: EditionedFileId(\n            FileId(\n                0,\n            ),\n            Edition2021,\n        ),\n        ptr: SyntaxNodePtr {\n            kind: CONST,\n            range: 413..434,\n        },\n        name_ptr: AstPtr(\n            SyntaxNodePtr {\n                kind: NAME,\n                range: 419..424,\n            },\n        ),\n    },\n    container_name: None,\n    is_alias: false,\n    is_assoc: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of #[derive] Attribute in Rust\nDESCRIPTION: This code snippet shows an erroneous use of the #[derive] attribute where a string literal is passed instead of a trait path. This will result in a compile-time error E0777.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0777.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(\"Clone\")] // error!\nstruct Foo;\n```\n\n----------------------------------------\n\nTITLE: Installing rustc-dev and llvm-tools Components with rustup\nDESCRIPTION: Command to install the necessary components for using rustc_private with official Rust toolchains distributed via rustup. These components provide compiler libraries and LLVM libraries needed for linking.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/rustc-private.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nrustup component add rustc-dev llvm-tools\n```\n\n----------------------------------------\n\nTITLE: Using pre-built LLVM - Toml\nDESCRIPTION: This code snippet shows how to configure Rust to use a pre-built version of LLVM by updating the 'bootstrap.toml' file with the path to the LLVM configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.x86_64-unknown-linux-gnu]\nllvm-config = \"/path/to/llvm/llvm-7.0.1/bin/llvm-config\"\n```\n\n----------------------------------------\n\nTITLE: Launching zxdb Debugger\nDESCRIPTION: Command to start the zxdb debugger with symbol paths for debugging Fuchsia components\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_26\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\n    --symbol-path target/x86_64-unknown-fuchsia/debug\n```\n\n----------------------------------------\n\nTITLE: Enabling XRay Instrumentation with Default Settings in Rust\nDESCRIPTION: Use the -Z instrument-xray compiler flag to enable XRay instrumentation with default settings. This generates NOP sleds for function tracing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/instrument-xray.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n-Z instrument-xray\n```\n\n----------------------------------------\n\nTITLE: Setting CFLAGS Environment Variable for 3DS Target\nDESCRIPTION: Export command for setting the required compiler flags (CFLAGS) for the armv6k-nintendo-3ds target to build compiler_builtins, specifying the float ABI, processor tuning, and architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv6k-nintendo-3ds.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nexport CFLAGS_armv6k_nintendo_3ds=\"-mfloat-abi=hard -mtune=mpcore -mtp=soft -march=armv6k\"\n```\n\n----------------------------------------\n\nTITLE: Defining HirFileId Enum for Macro Handling in Rust\nDESCRIPTION: This snippet defines the HirFileId enum, which allows for managing file references for both traditional source files and macro-generated files. It uses a combination of FileId and MacroCallId to differentiate between the two types of references. The implementation ensures compact representation using a single u32, with the most significant bit used to determine the type of file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum HirFileId {\n    FileId(FileId),\n    Macro(MacroCallId),\n}\n```\n\n----------------------------------------\n\nTITLE: Running M68K Programs with QEMU\nDESCRIPTION: Command to run simple M68K programs using QEMU user emulation. This is suitable for basic programs without complex dependencies.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nqemu-m68k-static your-code\n```\n\n----------------------------------------\n\nTITLE: Adding Date Annotation for Documentation\nDESCRIPTION: This snippet shows how to include a date annotation in markdown to provide context for information. It describes the recommended format for adding the date and how to leverage it within the guide.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- date-check --> Apr 2025\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Clobber Syntax in LLVM Assembly (Rust)\nDESCRIPTION: This code snippet shows an example of incorrectly using braces around a clobber in the `llvm_asm` macro. This syntax is no longer valid and the associated error is no longer emitted by the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0664.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nllvm_asm!(\"mov $$0x200, %eax\"\n          :\n          :\n          : \"{eax}\"\n         );\n```\n\n----------------------------------------\n\nTITLE: Normalizing Types in Rust Trait Solver\nDESCRIPTION: The solver uses try_normalize_ty to normalize types as much as possible before matching on TyKind. This is necessary because the solver lazily normalizes types, and matching on unnormalized types can lead to incorrect results.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/the-solver.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nEvalCtxt::try_normalize_ty\n```\n\n----------------------------------------\n\nTITLE: Installing M68K Cross-Compiler on Debian-based Systems\nDESCRIPTION: Command to install the G++ cross-compiler for M68K architecture on Debian-based systems. This will also pull in additional dependencies required for cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\napt install g++-m68k-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Configuring Build for aarch64 Nintendo Switch\nDESCRIPTION: This Toml configuration sets up the build stage and target for the aarch64 Nintendo Switch freestanding environment. It's necessary for specifying that the build process should use a custom target during compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-nintendo-switch-freestanding.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\\nbuild-stage = 1\\ntarget = [\"aarch64-nintendo-switch-freestanding\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating E0310 Error with Missing Lifetime Constraint in Rust\nDESCRIPTION: This example shows incorrect code that will fail to compile with E0310 error. The struct Foo has a type parameter T without a lifetime constraint, but tries to store a static reference to T.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0310.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This won't compile because T is not constrained to the static lifetime\n// the reference needs\nstruct Foo<T> {\n    foo: &'static T\n}\n```\n\n----------------------------------------\n\nTITLE: Example of ReLateParam representation in Rust\nDESCRIPTION: This code snippet demonstrates how the lifetime `'a` within a function body is represented using `ReLateParam`. It showcases the structure including the `DefId` of the item that introduced the late bound generic parameter and a `BoundRegionKind` specifying the generic parameter and its name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/instantiating_binders.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"impl Trait for Whatever {\\n    fn foo<'a>(a: &'a u32) -> &'a u32 {\\n        let b: &'a u32 = a;\\n        b\\n    }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Linker for Rust Programs on TEEOS\nDESCRIPTION: This toml snippet configures Cargo to use a specific linker when building Rust programs for the aarch64-unknown-teeos target. The configuration is added to '~/.cargo/config', specifying the location of the custom shell script that wraps the Clang compiler. This ensures the built Rust programs are correctly cross-compiled for TEEOS.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/aarch64-unknown-teeos.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[target.aarch64-unknown-teeos]\nlinker = \"/path/to/aarch64-unknown-teeos-clang.sh\" # or aarch64-linux-gnu-ld\n```\n\n----------------------------------------\n\nTITLE: Original Values Array\nDESCRIPTION: This snippet illustrates the use of the CanonicalVarValues array OV which captures the original values corresponding to the canonicalized variables. This array will later be needed when processing the trait query response.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/canonicalization.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[?A, 'static, ?B]\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Rust Functions for Stack Size Analysis\nDESCRIPTION: This snippet defines two Rust functions: 'foo' which doesn't use the stack, and 'bar' which allocates an array on the stack.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/emit-stack-sizes.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_type = \"lib\"]\n\nuse std::ptr;\n\npub fn foo() {\n    // this function doesn't use the stack\n}\n\npub fn bar() {\n    let xs = [0u32; 2];\n\n    // force LLVM to allocate `xs` on the stack\n    unsafe { ptr::read_volatile(&xs.as_ptr()); }\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-compiling Rust - Bash\nDESCRIPTION: This script demonstrates how to cross-compile the Rust compiler using a target specification JSON file to defined paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/new-target.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nDESTDIR=/path/to/install/in \\\n./x install -i --stage 1 --host aarch64-apple-darwin.json --target aarch64-apple-darwin \\\ncompiler/rustc library/std\n```\n\n----------------------------------------\n\nTITLE: Extending TextDocumentEdit Interface for Snippet Support\nDESCRIPTION: Modifies the TextDocumentEdit interface to allow for SnippetTextEdit elements in the edits array, enabling text document edits to contain both plain text and snippet edits.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TextDocumentEdit {\n    textDocument: OptionalVersionedTextDocumentIdentifier;\n    edits: (TextEdit | SnippetTextEdit)[];\n}\n```\n\n----------------------------------------\n\nTITLE: Positioning Error Annotations on Error Line in Rust UI Tests\nDESCRIPTION: Demonstrates how to use the //~ ERROR idiom to annotate errors directly on the line where they occur in UI tests. This technique precisely marks where the compiler error is expected.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = (1, 2, 3);\n    match x {\n        (_a, _x @ ..) => {} //~ ERROR `_x @` is not allowed in a tuple\n        _ => {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Commit Range with Changelog Script\nDESCRIPTION: Validates changelog formatting for a range of commits\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./contrib/gcc-changelog/git_check_commit.py HEAD~2\n```\n\n----------------------------------------\n\nTITLE: Using autodiff for Differentiable Programming in Rust\nDESCRIPTION: This code snippet uses the std::autodiff feature in Rust to perform automatic differentiation. The primary function 'foo' calculates x squared, while 'bar', derived via the #[autodiff] attribute, also computes the derivative of 'foo', returning a tuple of the original function result and its derivative. The main function tests this by asserting correct values for specific inputs. Dependencies: Rust nightly channel with autodiff feature enabled. Inputs: a float 'x'. Outputs: a tuple containing the output of the function and its derivative.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/internals.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(autodiff)]\\nuse std::autodiff::autodiff;\\n\\n// f(x) = x * x, f'(x) = 2.0 * x\\n// bar therefore returns (x * x, 2.0 * x)\\n#[autodiff(bar, Reverse, Active, Active)]\\nfn foo(x: f32) -> f32 { x * x }\\n\\nfn main() {\\n    assert_eq!(bar(3.0, 1.0), (9.0, 6.0));\\n    assert_eq!(bar(4.0, 1.0), (16.0, 8.0));\\n}\n```\n\n----------------------------------------\n\nTITLE: Building Fuchsia Package Manifest\nDESCRIPTION: Command to build the package manifest using ffx.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx package build \\\n    --api-level $(${SDK_PATH}/tools/${ARCH}/ffx --machine json version | jq .tool_version.api_level) \\\n    --out pkg/hello_fuchsia_manifest \\\n    pkg/hello_fuchsia.manifest\n```\n\n----------------------------------------\n\nTITLE: Suppressing the Internal Compiler Error File with Environment Variable\nDESCRIPTION: This command prevents the Rust compiler from creating an ICE file in the working directory upon encountering an Internal Compiler Error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/compiler-debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_ICE=0\n```\n\n----------------------------------------\n\nTITLE: HTML Search Form Implementation in JavaScript\nDESCRIPTION: JavaScript function to handle search form submission and URL routing based on selected search option\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/not_found.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction on_submit(event) {\n    var form = event.target;\n    var q = form['q'].value;\n\n    event.preventDefault();\n\n    if (form['from'].value === 'duckduckgo') {\n        document.location.href = form.action + '?q=' + encodeURIComponent(q + ' site:doc.rust-lang.org');\n    } else if (form['from'].value === 'library') {\n        document.location.href = '/std/index.html?search=' + encodeURIComponent(q);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Code for GIMPLE Generation\nDESCRIPTION: This console command demonstrates how to run the compiled code to generate GIMPLE output. It sets the necessary library paths.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/gimple.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nLD_LIBRARY_PATH=`pwd`/gcc-build/gcc LIBRARY_PATH=`pwd`/gcc-build/gcc ./out\n```\n\n----------------------------------------\n\nTITLE: Failing Struct Declaration with Duplicate Fields in Rust\nDESCRIPTION: An erroneous example demonstrating the E0124 compiler error that occurs when two fields in a struct have the same name. The compiler will reject this code because 'field1' is declared twice.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0124.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo {\n    field1: i32,\n    field1: i32, // error: field is already declared\n}\n```\n\n----------------------------------------\n\nTITLE: Windows API Constants Definition List\nDESCRIPTION: A filtered list of Windows API constants and error codes for generating Rust bindings. Includes process control flags, file operations, DNS error codes, console modes, and system error definitions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/windows/c/bindings.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n--out windows_sys.rs\n--flat\n--sys\n--no-deps\n--link windows_targets\n--filter\n!INVALID_HANDLE_VALUE\nABOVE_NORMAL_PRIORITY_CLASS\naccept\nAcquireSRWLockExclusive\nAcquireSRWLockShared\nADDRESS_FAMILY\nADDRINFOA\nAddVectoredExceptionHandler\nAF_INET\nAF_INET6\nAF_UNIX\nAF_UNSPEC\nALL_PROCESSOR_GROUPS\nARM64_NT_NEON128\nBELOW_NORMAL_PRIORITY_CLASS\nbind\nBY_HANDLE_FILE_INFORMATION\nCALLBACK_CHUNK_FINISHED\nCALLBACK_STREAM_SWITCH\nCancelIo\nCloseHandle\nclosesocket\nCOMPARESTRING_RESULT\nCompareStringOrdinal\nconnect\nCONSOLE_MODE\nCONSOLE_READCONSOLE_CONTROL\nCONTEXT\nCopyFileExW\nCP_UTF8\nCREATE_ALWAYS\n[...additional constants...]\n```\n\n----------------------------------------\n\nTITLE: Moving a Feature from Unstable to Accepted Status in Rust Compiler\nDESCRIPTION: Example of how to update a feature's status from 'unstable' to 'accepted' when stabilizing it. The entry is moved to the accepted.rs file with its status changed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// pub(restricted) visibilities (RFC 1422)\n(accepted, pub_restricted, \"CURRENT_RUSTC_VERSION\", Some(32409)),\n// note that we changed this\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unstable Linker Flavor Usage in Rust\nDESCRIPTION: This snippet shows how to use the unstable 'llbc' linker flavor for Nvidia NVPTX targets. It requires specific rustup components and command-line flags.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/codegen-options.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n-Zunstable-options -Clink-self-contained=+linker -Clinker-flavor=llbc\n```\n\n----------------------------------------\n\nTITLE: Custom Linker Configuration for SPARC in TOML\nDESCRIPTION: This code snippet configures a custom GCC linker for the `sparc-unknown-none-elf` target in a project's `.cargo/config.toml`. This customization is crucial for linking Rust programs correctly for SPARC systems.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/sparc-unknown-none-elf.md#2025-04-21_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\n[target.sparc-unknown-none-elf]\nlinker = \"sparc-custom-elf-gcc\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for AMD GPU target as cdylib\nDESCRIPTION: The TOML snippet configures a Rust project to build the library as a cdylib, ensuring the binaries are suitable for use on AMD's GPU architecture. LTO is enabled to optimize the build for both development and release profiles, and the configuration is essential for GPU-specific optimizations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/amdgcn-amd-amdhsa.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\\ncrate-type = [\"cdylib\"]\\n\\n[profile.dev]\\nlto = true # LTO must be explicitly enabled for now\\n[profile.release]\\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Mangled Symbol for Crate-Rooted Function in Rust\nDESCRIPTION: The text example presents the mangled symbol representation for the function `example` in a crate named `mycrate`, explicating the components of the crate-root encoding and providing a recommendation for its demangling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n_RNvCs15kBYyAo9fc_7mycrate7example\n```\n\n----------------------------------------\n\nTITLE: Test Re-export Module Transformation\nDESCRIPTION: Shows how the compiler transforms private module tests by creating __test_reexports modules.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/test-implementation.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod my_priv_mod {\n    fn my_priv_func() -> bool {}\n\n    pub fn test_priv_func() {\n        assert!(my_priv_func());\n    }\n\n    pub mod __test_reexports {\n        pub use super::test_priv_func;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Install Script with gen-install-script.sh\nDESCRIPTION: This bash command uses gen-install-script.sh to generate a standalone install script for Rust. It specifies the product name, manifest directory, success message, output script name, and legacy manifest directories.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-installer/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./gen-install-script.sh --product-name=Rust \\\n                        --rel-manifest-dir=rustlib \\\n                        --success-message=Rust-is-ready-to-roll. \\\n                        --output-script=install.sh \\\n                        --legacy-manifest-dirs=rustlib\n```\n\n----------------------------------------\n\nTITLE: Pattern Structure Alternatives, Sequences, and Optionals in Rust\nDESCRIPTION: The code defines the `Alt`, `Seq`, and `Opt` data structures used for handling pattern variations in PatternTree. It shows how alternatives, sequences, and optional elements are represented within the hierarchical pattern system. This is essential for building pattern representations using Rust's memory-safe language features.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub enum Alt<T> {\n    Any,\n    Elmt(Box<T>),\n    Alt(Box<Self>, Box<Self>),\n    Named(Box<Self>, ...)\n}\n\npub enum Opt<T> {\n    Any,  // anything, but not None\n    Elmt(Box<T>),\n    None,\n    Alt(Box<Self>, Box<Self>),\n    Named(Box<Self>, ...)\n}\n\npub enum Seq<T> {\n    Any,\n    Empty,\n    Elmt(Box<T>),\n    Repeat(Box<Self>, RepeatRange),\n    Seq(Box<Self>, Box<Self>),\n    Alt(Box<Self>, Box<Self>),\n    Named(Box<Self>, ...)\n}\n\npub struct RepeatRange {\n    pub start: usize,\n    pub end: Option<usize>  // exclusive\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling PGO Instrumentation Generation in LLVM PassManager (C)\nDESCRIPTION: This code snippet shows how rustc instructs LLVM to add profiling instrumentation by setting appropriate flags when creating LLVM PassManagers. It enables PGO instrumentation generation and sets the default output path for the .profraw file.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profile-guided-optimization.md#2025-04-21_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n    unwrap(PMBR)->EnablePGOInstrGen = true;\n    unwrap(PMBR)->PGOInstrGen = PGOGenPath;\n```\n\n----------------------------------------\n\nTITLE: Method Lookup Transformation Example\nDESCRIPTION: Demonstrates how method lookup transforms a method call from receiver.method(...) to a fully-qualified syntax with receiver type adjustments\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/method-lookup.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Transformation example\n// receiver.method(...) becomes:\n// Trait::method(ADJ(receiver), ...) // for trait calls\n// ReceiverType::method(ADJ(receiver), ...) // for inherent method calls\n```\n\n----------------------------------------\n\nTITLE: Checking Method Implementation in Rust Impl Blocks\nDESCRIPTION: Shows how to verify if an impl block defines a specific method by examining ImplItem structures. Includes checks for method name, self parameter, and return type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/method_checking.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse clippy_utils::ty::is_type_diagnostic_item;\nuse clippy_utils::return_ty;\nuse rustc_hir::{ImplItem, ImplItemKind};\nuse rustc_lint::{LateContext, LateLintPass};\nuse rustc_span::symbol::sym;\n\nimpl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n        // Check if item is a method/function\n        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind\n            // Check the method is named `our_fancy_method`\n            && impl_item.ident.name.as_str() == \"our_fancy_method\"\n            // We can also check it has a parameter `self`\n            && signature.decl.implicit_self.has_implicit_self()\n            // We can go even further and even check if its return type is `String`\n            && is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::String)\n        {\n            println!(\"`our_fancy_method` is implemented!\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Windows 7 Target in Bootstrap\nDESCRIPTION: Configuration snippet for enabling Windows 7 target in Rust's bootstrap configuration file, specifying target list and build stage\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/win7-windows-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"x86_64-win7-windows-gnu\"]\n```\n\n----------------------------------------\n\nTITLE: Macro Definition Example 0 (Rust)\nDESCRIPTION: This example demonstrates a simple macro `m` that expands to an identifier `ident`. It shows how the context of `ident` changes after macro expansion, starting from `SyntaxContext::root` and becoming `ROOT -> id(m)`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/macro-expansion.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmacro m() { ident }\n\nm!();\n```\n\n----------------------------------------\n\nTITLE: JIT Mode Execution with Cargo-Clif\nDESCRIPTION: Command to execute Rust code immediately using JIT mode through Cargo integration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/usage.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ $cg_clif_dir/dist/cargo-clif jit\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Semicolon Error in Rust\nDESCRIPTION: This code sample shows a simple Rust program with a syntax error. The statement assigning value 234 to variable 'x' is missing a required semicolon at the end, which would cause a compilation error in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/rustdoc-ui/doctest/doctest-output-include-fail.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 234 // no semicolon here! oh no!\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Source for Search Test\nDESCRIPTION: This rust code defines a function `constructor` which will be used by `rustdoc-js` to verify the search functionality. This function must be declared as `pub` to be discoverable during search.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// tests/rustdoc-js/constructor_search.rs\n// The test case needs to find this result.\npub fn constructor(_input: &str) -> i32 { 1 }\n```\n\n----------------------------------------\n\nTITLE: Printing Debug Representation of a Gimple Struct in C\nDESCRIPTION: This function call prints a debug representation of a gimple struct in C. It's helpful for examining the internal state of gimple structures during libgccjit debugging.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging-libgccjit.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ndebug_gimple_stmt(gimple_struct)\n```\n\n----------------------------------------\n\nTITLE: Running Fuchsia Component\nDESCRIPTION: Command to run the Fuchsia component on the emulator.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_19\n\nLANGUAGE: sh\nCODE:\n```\n${SDK_PATH}/tools/${ARCH}/ffx component run \\\n    /core/ffx-laboratory:hello_fuchsia \\\n    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm\n```\n\n----------------------------------------\n\nTITLE: Doctest Compilation Performance Metrics for sysinfo Crate\nDESCRIPTION: Shows performance metrics from running doctests on the sysinfo crate, demonstrating the time spent on compilation versus runtime execution.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/write-documentation/documentation-tests.md#2025-04-21_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nwall-time duration: 4.59s\ntotal compile time: 27.067s\ntotal runtime: 3.969s\n```\n\n----------------------------------------\n\nTITLE: Analyzing MIR Borrowck Time with perf-focus\nDESCRIPTION: Example of using perf-focus to determine what percentage of execution time was spent in the do_mir_borrowck function. This shows how to query specific function performance.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_perf.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ perf focus '{do_mir_borrowck}'\nMatcher    : {do_mir_borrowck}\nMatches    : 228\nNot Matches: 542\nPercentage : 29%\n```\n\n----------------------------------------\n\nTITLE: Filtering Dependency Graph in Rust Compiler\nDESCRIPTION: This section describes the syntax for filtering the dependency graph using the `RUST_DEP_GRAPH_FILTER` environment variable. This enables filtering the dependencies to view specific nodes and relations based on provided filters in the graph.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsource_filter     // nodes originating from source_filter\n-> target_filter  // nodes that can reach target_filter\nsource_filter -> target_filter // nodes in between source_filter and target_filter\n```\n\n----------------------------------------\n\nTITLE: Generating Full Debug Dump of HIR in Rust\nDESCRIPTION: This snippet illustrates the command for generating a full `Debug` dump of the HIR. This is useful for examining the complete structure of the HIR from the compiler's perspective.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/hir-debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n-Z unpretty=hir-tree\n```\n\n----------------------------------------\n\nTITLE: MIR representation of if statement\nDESCRIPTION: Shows the textual MIR representation of an `if` statement in Rust. The original Rust code is transformed into four basic blocks (BB0, BB1, BB2, BB3) with `goto` statements dictating control flow based on the condition.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/background.md#2025-04-21_snippet_2\n\nLANGUAGE: mir\nCODE:\n```\nBB0: {\n    a = 1;\n    if some_variable {\n        goto BB1;\n    } else {\n        goto BB2;\n    }\n}\n\nBB1: {\n    b = 1;\n    goto BB3;\n}\n\nBB2: {\n    c = 1;\n    goto BB3;\n}\n\nBB3: {\n    d = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Flag Documentation - no-parallel-llvm\nDESCRIPTION: Documents the no-parallel-llvm flag which disables parallel codegen and linking while maintaining codegen units and LTO behavior. This flag is primarily intended for debugging LLVM backend issues by preventing output interleaving during parallel operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/no-parallel-llvm.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `no-parallel-llvm`\n\n---------------------\n\nThis flag disables parallelization of codegen and linking, while otherwise preserving\nbehavior with regard to codegen units and LTO.\n\nThis flag is not useful for regular users, but it can be useful for debugging the backend. Codegen issues commonly only manifest under specific circumstances, e.g. if multiple codegen units are used and ThinLTO is enabled. Serialization of these threaded configurations makes the use of LLVM debugging facilities easier, by avoiding the interleaving of output.\n```\n\n----------------------------------------\n\nTITLE: Building Rust Project for Armv7 Target\nDESCRIPTION: This Bash snippet provides the command to build the Rust project using the provided toolchain configuration for the Armv7 target. It utilizes the x.py build system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/armv7-unknown-linux-uclibceabihf.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# in rust dir\n./x.py build --stage 2\n```\n\n----------------------------------------\n\nTITLE: Enabling powerpc64le Target in Rust Build Configuration\nDESCRIPTION: Configures rustc build to include powerpc64le-unknown-linux-musl target by specifying target in build configuration\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/powerpc64le-unknown-linux-musl.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = [\"powerpc64le-unknown-linux-musl\"]\n```\n\n----------------------------------------\n\nTITLE: Updating Rust Repository with GCC Changes\nDESCRIPTION: Commands to pull changes from rustc_codegen_gcc back into the main Rust repository. Includes creating a new branch, performing the subtree pull, and syncing changes back to prevent future merge conflicts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/subtree.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ../rust\ngit pull origin master\ngit checkout -b subtree-update_cg_gcc_YYYY-MM-DD\nPATH=\"$HOME/bin:$PATH\" ~/bin/git-subtree pull --prefix=compiler/rustc_codegen_gcc/ https://github.com/rust-lang/rustc_codegen_gcc.git master\ngit push\n\n# Immediately merge the merge commit into cg_gcc to prevent merge conflicts when syncing from rust-lang/rust later.\nPATH=\"$HOME/bin:$PATH\" ~/bin/git-subtree push -P compiler/rustc_codegen_gcc/ ../rustc_codegen_gcc/ sync_branch_name\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Trait Bounds in Rust\nDESCRIPTION: This snippet demonstrates the definition of a function 'foo' that has a default trait bound for its generic type T. It shows how trait bounds are checked for validity when using the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/effects.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>() where T: Default {}\n```\n\n----------------------------------------\n\nTITLE: Running Rust test suite on QNX\nDESCRIPTION: This bash script demonstrates how to run the Rust test suite on a QNX target. It sets environment variables for the test device address and compiler build environment, and then executes the `x.py test` script, excluding certain tests that are known to fail or are not applicable to the target environment.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/nto-qnx.md#2025-04-21_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n```bash\nexport TEST_DEVICE_ADDR=\"localhost:12345\" # must address the test target, can be a SSH tunnel\nexport build_env=<see above>\n\n# Disable tests that only work on the host or don't make sense for this target.\n# See also:\n# - src/ci/docker/host-x86_64/i686-gnu/Dockerfile\n# - https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Running.20tests.20on.20remote.20target\n# - .github/workflows/ci.yml\nexport exclude_tests='\\\n    --exclude src/bootstrap \\\n    --exclude src/tools/error_index_generator \\\n    --exclude src/tools/linkchecker \\\n    --exclude tests/ui-fulldeps \\\n    --exclude rustc \\\n    --exclude rustdoc'\n\nenv $build_env \\\n    ./x.py test \\\n        $exclude_tests \\\n        --stage 1 \\\n        --target x86_64-pc-nto-qnx710\n```\n```\n\n----------------------------------------\n\nTITLE: Setting the Dependency Graph Filter for Functions in Rust\nDESCRIPTION: This snippet shows examples of how to set specific filters for dependency graphs in Rust. Different combinations are created to focus on specific nodes involved in the dependency relationships.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/incrcomp-debugging.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nRUST_DEP_GRAPH_FILTER='-> TypeckTables'\nRUST_DEP_GRAPH_FILTER='-> TypeckTables & bar'\nRUST_DEP_GRAPH_FILTER='Hir & foo -> TypeckTables & bar'\n```\n\n----------------------------------------\n\nTITLE: Explaining Trait Definition Symbol Mangling in Rust\nDESCRIPTION: Shows how a trait definition is mangled, including the trait-definition indicator, Self type, and path to the trait.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntrait Trait {\n    fn example() {}\n}\nstruct Example;\nimpl Trait for Example {}\n```\n\nLANGUAGE: text\nCODE:\n```\n_RNvYNtCs15kBYyAo9fc_7mycrate7ExampleNtB4_5Trait7exampleB4_\n    │└──────────────┬───────────────┘└────┬────┘\n    │               │                     │\n    │               │                     └── path to the trait \"Trait\"\n    │               └──────────────────────── path to the implementing type \"mycrate::Example\"\n    └──────────────────────────────────────── trait-definition\n```\n\n----------------------------------------\n\nTITLE: Showing rustc Commands for UI Tests\nDESCRIPTION: This command shows how to run Rust UI tests with the verbose flag to display the rustc commands being executed. Adding the --verbose flag to the test arguments increases the output verbosity.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/tests.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./x.py test --test-args \"--verbose\"\n```\n\n----------------------------------------\n\nTITLE: LLVM IR Example with Enzyme Intrinsic\nDESCRIPTION: Example of LLVM IR showing an Enzyme forward differentiation call\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/debugging.md#2025-04-21_snippet_4\n\nLANGUAGE: llvm-ir\nCODE:\n```\ndefine double @enzyme_opt_helper_0(ptr %0, i64 %1, double %2) {\n  %4 = call double (...) @__enzyme_fwddiff(ptr @_zn2ad3_f217h3b3b1800bd39fde3e, metadata !\"enzyme_const\", ptr %0, metadata !\"enzyme_const\", i64 %1, metadata !\"enzyme_dup\", double %2, double %2)\n  ret double %4\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Compilation Tools in bootstrap.toml\nDESCRIPTION: This TOML configuration specifies the custom linker and C compiler scripts for the x86_64-win7-windows-msvc target, enabling cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/win7-windows-msvc.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[target.x86_64-win7-windows-msvc]\nlinker = \"path/to/xwin-lld-link\"\ncc = \"path/to/xwin-clang-cl\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Marker Trait with Associated Constant in Rust\nDESCRIPTION: Example showing incorrect usage of a marker trait containing an associated constant, which triggers error E0714. Marker traits cannot contain associated items since they cannot be overridden per-type.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0714.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(marker_trait_attr)]\n#![feature(associated_type_defaults)]\n\n#[marker]\ntrait MarkerConst {\n    const N: usize; // error!\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Intrinsics Feature in Rust\nDESCRIPTION: This code snippet defines the 'core_intrinsics' feature as an internal Rust compiler feature. It specifies that this feature is not intended for general use and is restricted to internal compiler operations.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/core-intrinsics.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `core_intrinsics`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Example Lint Level Output Format\nDESCRIPTION: Shows the output format of the lint levels command, which displays each lint name and its associated level in NAME=LEVEL format.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/print-crate-root-lint-levels.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nunknown_lint=warn\narithmetic_overflow=deny\n```\n\n----------------------------------------\n\nTITLE: Accessing a Move Path Place in Rust\nDESCRIPTION: This code snippet demonstrates how to access a MIR Place using a MovePathIndex in Rust. It requires the `move_paths` field of `MoveData` for converting indices to Places. Useful for cases where the move analysis requires understanding of indexed locations within MIR.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/moves_and_initialization/move_paths.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmove_data.move_paths[mpi].place\n```\n\n----------------------------------------\n\nTITLE: Declaring an Intrinsic Without a Body in Rust\nDESCRIPTION: Example of declaring an intrinsic without fallback logic using #[rustc_intrinsic]. These intrinsics must be implemented by all backends and cannot have a default implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/intrinsics.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(intrinsics)]\n#![allow(internal_features)]\n\n#[rustc_intrinsic]\npub fn abort() -> !;\n```\n\n----------------------------------------\n\nTITLE: LLVM Debug Configuration in bootstrap.toml\nDESCRIPTION: Configuration settings for enabling LLVM debug builds and assertions in the Rust compiler's bootstrap configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/backend/debugging.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[llvm]\n# Indicates whether the LLVM assertions are enabled or not\nassertions = true\n\n# Indicates whether the LLVM build is a Release or Debug build\noptimize = false\n```\n\n----------------------------------------\n\nTITLE: Full Example Output - Rust Test Time Reporting\nDESCRIPTION: Shows complete example output of running tests with time reporting enabled, including quick, warning, and critical time thresholds.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/report-time.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo test --tests -- -Zunstable-options --report-time\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running target/debug/deps/example-27fb188025bec02c\n\nrunning 3 tests\ntest tests::unit_test_quick ... ok <0.000s>\ntest tests::unit_test_warn ... ok <0.055s>\ntest tests::unit_test_critical ... ok <0.110s>\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/debug/deps/tests-cedb06f6526d15d9\n\nrunning 3 tests\ntest unit_test_quick ... ok <0.000s>\ntest unit_test_warn ... ok <0.550s>\ntest unit_test_critical ... ok <1.100s>\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Specifying C Compiler for RISC-V Target\nDESCRIPTION: In this snippet, the C compiler and archiver for the RISC-V target are specified in the `bootstrap.toml` configuration file. This is necessary for cross-compiling Rust programs to the RISC-V architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/riscv32imac-unknown-xous-elf.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[target.riscv32imac-unknown-xous-elf]\ncc = \"riscv-none-elf-gcc\"\nar = \"riscv-none-elf-ar\"\n```\n\n----------------------------------------\n\nTITLE: Defining Region Relationships in Rust\nDESCRIPTION: This snippet illustrates the creation of region element domains for a specific subtyping constraint in Rust's type system. It outlines how universal variables are established, showing their initial values and the relationship between them.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nVs = { CFG; end('static) } // it is in U0, so can't name anything else\nV1 = { placeholder(1) }\n```\n\n----------------------------------------\n\nTITLE: Checking LLVM SafeStack Status Using readelf\nDESCRIPTION: Command line example showing how to verify if LLVM SafeStack is enabled for a binary by checking for the presence of __safestack_init symbol using readelf.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/exploit-mitigations.md#2025-04-21_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n$ readelf -s target/release/hello-rust | grep __safestack_init\n   678: 0000000000008c80   426 FUNC    GLOBAL DEFAULT   15 __safestack_init\n```\n\n----------------------------------------\n\nTITLE: Running Test Cases for Autodiff\nDESCRIPTION: This snippet runs test cases for the autodiff feature using the Rust build tool, specifying the stage and directories for the test cases.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./x.py test --stage 1 library tests/ui/autodiff\n./x.py test --stage 1 library tests/codegen/autodiff\n./x.py test --stage 1 library tests/pretty/autodiff*\n```\n\n----------------------------------------\n\nTITLE: Ty Struct Definition\nDESCRIPTION: Core type representation structure in Rust compiler\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n```\n\n----------------------------------------\n\nTITLE: Test Output from Generated Test Functions in Rust\nDESCRIPTION: This shows the test output when running the tests generated by the test_math macro. Six test functions were generated with names that incorporate the integer type and the operation being tested.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/macro-metavar-expr-concat.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nrunning 6 tests\ntest test_i32_subtraction ... ok\ntest test_i32_addition ... ok\ntest test_u128_addition ... ok\ntest test_u128_subtraction ... ok\ntest test_u64_addition ... ok\ntest test_u64_subtraction ... ok\n\ntest result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Invalid Transmutation with Generic Types in Rust\nDESCRIPTION: This code demonstrates an invalid use of `std::mem::transmute` with uninstantiated type parameters, which is not allowed by the compiler. The example attempts to transmute between Vec<T> and Foo<T> in a generic function context.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0139.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem::transmute;\n\nstruct Foo<T>(Vec<T>);\n\nfn foo<T>(x: Vec<T>) {\n    // we are transmuting between Vec<T> and Foo<F> here\n    let y: Foo<T> = unsafe { transmute(x) };\n    // do something with y\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Github Label and Ping Command in Markdown\nDESCRIPTION: This snippet shows how to format the Github label and ping command for the Windows notification group using Markdown syntax.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/windows.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n**Github Label:** [O-Windows] <br>\n**Ping command:** `@rustbot ping windows`\n\n[O-Windows]: https://github.com/rust-lang/rust/labels/O-Windows\n```\n\n----------------------------------------\n\nTITLE: Disassembly Output of MSP430 Interrupt Handler\nDESCRIPTION: This shows the disassembly output of the compiled MSP430 interrupt handler, demonstrating how the compiler placed the interrupt vector at the correct memory address (0xfff2) and how the interrupt handler function ends with the required 'reti' instruction for MSP430 architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/abi-msp430-interrupt.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n$ msp430-elf-objdump -CD ./target/msp430/release/app\nDisassembly of section __interrupt_vector_10:\n\n0000fff2 <TIM0_VECTOR>:\n    fff2:       00 c0           interrupt service routine at 0xc000\n\nDisassembly of section .text:\n\n0000c000 <int::tim0>:\n    c000:       00 13           reti\n```\n\n----------------------------------------\n\nTITLE: Raw Byte String Literal Error\nDESCRIPTION: This code snippet demonstrates a raw byte string literal that is missing its trailing delimiter. In Rust, raw string literals (including byte strings) require a matching number of `#` symbols at the beginning and end of the literal. The error message indicates that the trailing quote and `#` symbols are missing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_with_slash.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"br##\\\"\\\\\\\" error: Missing trailing \\`\\\"\\` with `#` symbols to terminate the raw byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Running the rust-analyzer CLI for Batch Analysis (bash)\nDESCRIPTION: This command runs the rust-analyzer CLI with the analysis-stats command for batch analysis on a Rust crate. The snippet uses --release for optimal speed and -p rust-analyzer to specify the package. Replace 'path/to/some/rust/crate' with the actual path to the target crate. Useful for profiling, performance, or debugging and requires a built, up-to-date rust-analyzer in the workspace.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --release -p rust-analyzer -- analysis-stats path/to/some/rust/crate\n\n```\n\n----------------------------------------\n\nTITLE: String Literal Error\nDESCRIPTION: This code snippet presents a Rust compiler error message indicating a missing closing quote (\") in a string literal. The error message suggests that the string literal is not properly terminated, leading to a compilation failure. The literal in the error message is \"🦀.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_string_with_ferris.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"\\\"🦀\" error: Missing trailing `\\\"` symbol to terminate the string literal\"\n```\n\n----------------------------------------\n\nTITLE: Capturing Rust Compiler stderr Output\nDESCRIPTION: Demonstrates how to run the Rust compiler and capture its stderr output using the 'eprintln' subcommand of 'x perf'. This is useful for debugging when additional eprintln! calls have been added to the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/profiling/with_rustc_perf.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./x perf eprintln\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Octal Literal\nDESCRIPTION: This snippet shows that `0onoDigit` gives a `Missing digits after the integer base prefix` error, because it requires digits, but gets a string that isn't a valid digit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0onoDigit\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Windows Docker Toolbox VirtualBox Configuration\nDESCRIPTION: Batch commands to configure VirtualBox for Docker Toolbox on Windows, enabling symbolic link support in shared folders\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/docker/README.md#2025-04-21_snippet_3\n\nLANGUAGE: batch\nCODE:\n```\ncd \"C:\\Program Files\\Oracle\\VirtualBox\"\nVBoxManage setextradata default VBoxInternal2/SharedFoldersEnableSymlinksCreate/e/rust 1\n```\n\n----------------------------------------\n\nTITLE: Syncing updates from Clippy to rust-lang/rust via git subtree\nDESCRIPTION: This snippet shows the commands to update the rust-lang/rust repository with the latest Clippy code. It involves creating a new branch, pulling in Clippy’s master branch into the rust repository’s subtree, and then making a pull request to incorporate the changes into rust. This process maintains seamless integration and up-to-date tooling.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/sync.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit switch -c clippy-subtree-update\ngit subtree pull -P src/tools/clippy clippy-upstream master\n```\n\n----------------------------------------\n\nTITLE: GN Config for Custom Rust Compiler Flags\nDESCRIPTION: Example GN configuration showing how to add custom compiler flags to a Rust binary target in Fuchsia build system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ecosystem-test-jobs/fuchsia.md#2025-04-21_snippet_1\n\nLANGUAGE: gn\nCODE:\n```\nconfig(\"everybody_loops\") {\n    rustflags = [ \"-Zeverybody-loops\" ]\n}\n\nrustc_binary(\"example\") {\n    crate_root = \"src/bin.rs\"\n    # ...existing keys here...\n    configs += [ \":everybody_loops\" ]\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming libunwind Libraries for Native Bootstrapping\nDESCRIPTION: Shell command to rename libunwind libraries to mimic libgcc for native bootstrapping of GNULLVM targets. This is a workaround that might become obsolete and is not recommended for regular use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/windows-gnullvm.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nhttps://github.com/msys2/MINGW-packages/blob/68e640756df2df6df6afa60f025e3f936e7b977c/mingw-w64-rust/PKGBUILD#L108-L109\n```\n\n----------------------------------------\n\nTITLE: Defining CrateData Structures in Rust\nDESCRIPTION: The CrateData structure is used to store metadata and dependency information for Rust crates. Each entry contains details such as the root file ID, edition, version, display name, environment variables, and dependencies. These details are necessary for managing and analyzing crates in Rust projects. Primary dependencies include crates like libc, which are essential for system-level interactions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/cargo_hello_world_project_model_with_selective_overrides.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nCrateData {\n    ...\n    edition: Edition2018,\n    version: Some(\n        \"0.1.0\",\n    ),\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"hello_world\",\n            ),\n            canonical_name: \"hello-world\",\n        },\n    ),\n    ...\n    dependencies: [\n        Dependency {\n            crate_id: Idx::<CrateData>(4),\n            name: CrateName(\n                \"libc\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n    ],\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Issue Value in Stability Attributes (Rust)\nDESCRIPTION: Fixed example showing the proper way to specify the 'issue' field in stability attributes using 'none' or a valid issue number.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0545.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(staged_api)]\n#![allow(internal_features)]\n#![stable(since = \"1.0.0\", feature = \"test\")]\n\n#[unstable(feature = \"_unstable_fn\", issue = \"none\")] // ok!\nfn _unstable_fn() {}\n\n#[rustc_const_unstable(feature = \"_unstable_const_fn\", issue = \"1\")] // ok!\nconst fn _unstable_const_fn() {}\n```\n\n----------------------------------------\n\nTITLE: Installing QEMU User Emulation for M68K\nDESCRIPTION: Command to install QEMU user emulation package on Debian-based systems to run simple static M68K binaries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-none-elf.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# apt install qemu-user-static\n```\n\n----------------------------------------\n\nTITLE: Removing Feature Gate Error in the Rust Compiler\nDESCRIPTION: Example of removing code that flags an error when a feature gate is not enabled. This type of code needs to be removed when stabilizing a feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/stabilization_guide.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ngate_feature_post!(&self, pub_restricted, span,\n \"`pub(restricted)` syntax is experimental\");\n```\n\n----------------------------------------\n\nTITLE: Setting RUSTC_LOG environment variable for query-level tracing\nDESCRIPTION: This bash command sets the `RUSTC_LOG` environment variable to enable tracing for a specific query, `typeck`. This configuration logs all messages during the execution of the type checking query.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tracing.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nRUSTC_LOG=[typeck]\n```\n\n----------------------------------------\n\nTITLE: Query Provider Function Signature in Rust Compiler\nDESCRIPTION: Shows the standard signature for a query provider function. Providers always take a TyCtxt and the query key as parameters, and return the query result.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/query.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn provider<'tcx>(\n    tcx: TyCtxt<'tcx>,\n    key: QUERY_KEY,\n) -> QUERY_RESULT {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Clippy Commit Hash from Rust Repository\nDESCRIPTION: A bash command that extracts the latest Clippy commit hash from the Rust repository logs. It filters the git log to find Clippy merge commits and extracts just the commit hash.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/changelog_update.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\"\n```\n\n----------------------------------------\n\nTITLE: Rust Unstable CLI Option\nDESCRIPTION: Command-line option flag for enabling unstable features in Rust's compiler. Required for using experimental compiler options.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/tests/index.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n-Z unstable-options\n```\n\n----------------------------------------\n\nTITLE: Error: Missing Trailing Quote in Raw Byte String Literal - Rust\nDESCRIPTION: This snippet describes an error that occurs when a raw byte string literal is missing the trailing double quote, which is necessary for terminating the literal. The use of '#' symbols determines the level of escaping needed for the string literal. The error occurs when the closing quote is missing and the number of '#' symbols match the beginning of the literal. The expected input is a Rust source file. The output is a compiler error indicating the missing trailing quote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_raw_byte_string_with_space.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nBYTE_STRING \"br##\\\" \" error: Missing trailing `\"` with `#` symbols to terminate the raw byte string literal\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for Rustfmt 0.2.4\nDESCRIPTION: Documents the addition of Yield support in version 0.2.4.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_26\n\nLANGUAGE: markdown\nCODE:\n```\n## [0.2.4] 2017-08-30\n\n### Added\n\n- Add support for `Yield` (#1928).\n```\n\n----------------------------------------\n\nTITLE: Common Linking Error Message\nDESCRIPTION: Example of the linking error that occurs when LLVM tools are not properly installed or configured.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustc-driver/remarks-on-perma-unstable-features.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note: rust-lld: error: unable to find library -lLLVM-{version}\n```\n\n----------------------------------------\n\nTITLE: Representing Async Closures in HIR\nDESCRIPTION: This snippet shows how async closures are represented within the High-Level Intermediate Representation (HIR) in Rust. Async closures are depicted as `hir::Closure` with a specific `ClosureKind` wrapping an async block, capturing arguments with `CaptureBy::ByRef`. This representation is crucial for correctly handling closure arguments and indicates how the async block should behave with respect to argument moving and borrowing.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/coroutine-closures.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nhir::Closure whose closure-kind is `ClosureKind::CoroutineClosure(_)`\n```\n\n----------------------------------------\n\nTITLE: Instantiating Crate Example in Rust\nDESCRIPTION: Demonstrates symbol name creation for a method with an instantiating crate identifier, showing how Rust encodes symbol names with crate context\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nstd::path::Path::new(\"example\");\n```\n\n----------------------------------------\n\nTITLE: Body Source Map Implementation (Rust)\nDESCRIPTION: This code defines the source map structure that maps between position-independent expression IDs and the original syntax, facilitating lookups between stable representation and actual source code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/body.rs#L84-L88\n```\n\n----------------------------------------\n\nTITLE: Type Checking Flow Diagram\nDESCRIPTION: Mermaid flowchart showing the steps involved in type checking and resolving opaque types in the compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/opaque-types-impl-trait-inference.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    TypeChecking[\"type checking `main`\"]\n    subgraph TypeOfSeq[\"type_of(Seq<T>) query\"]\n        WalkModuleHir[\"Walk the HIR for the module `m`\\nto find the hidden types from each\\nfunction/const/static within\"]\n        VisitProduceSingleton[\"visit `produce_singleton`\"]\n        InterimType[\"`produce_singleton` hidden type is `Vec<T>`\\nkeep searching\"]\n        VisitProduceDoubleton[\"visit `produce_doubleton`\"]\n        CompareType[\"`produce_doubleton` hidden type is also Vec<T>\\nthis matches what we saw before ✅\"]\n        Done[\"No more items to look at in scope\\nReturn `Vec<T>`\"]\n    end\n\n    BorrowCheckProduceSingleton[\"`borrow_check(produce_singleton)`\"]\n    TypeCheckProduceSingleton[\"`type_check(produce_singleton)`\"]\n\n    BorrowCheckProduceDoubleton[\"`borrow_check(produce_doubleton)`\"]\n    TypeCheckProduceDoubleton[\"`type_check(produce_doubleton)`\"]\n\n    Substitute[\"Substitute `T => u32`,\\nyielding `Vec<i32>` as the hidden type\"]\n    CheckSend[\"Check that `Vec<i32>: Send` ✅\"]\n\n    TypeChecking -- trait code for auto traits --> TypeOfSeq\n    TypeOfSeq --> WalkModuleHir\n    WalkModuleHir --> VisitProduceSingleton\n    VisitProduceSingleton --> BorrowCheckProduceSingleton\n    BorrowCheckProduceSingleton --> TypeCheckProduceSingleton\n    TypeCheckProduceSingleton --> InterimType\n    InterimType --> VisitProduceDoubleton\n    VisitProduceDoubleton --> BorrowCheckProduceDoubleton\n    BorrowCheckProduceDoubleton --> TypeCheckProduceDoubleton\n    TypeCheckProduceDoubleton --> CompareType --> Done\n    Done --> Substitute --> CheckSend\n```\n\n----------------------------------------\n\nTITLE: Adding New Lint Changelog Entry\nDESCRIPTION: Example of how to add a changelog entry for a new lint contribution to Clippy.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nchangelog: new lint: [`missing_trait_methods`]\n```\n\n----------------------------------------\n\nTITLE: Formatting Example: Inline Const Block with Inner Attributes\nDESCRIPTION: Demonstrates preservation of inner attributes in inline const blocks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    const {\n        #![allow(clippy::assertions_on_constants)]\n\n        assert!(1 < 2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Two-Phase Borrows in Rust\nDESCRIPTION: This code snippet expands the previous example to explicitly show how two-phase borrows are represented internally. It demonstrates the creation of temporary variables and the use of the `two_phase` keyword (which is illustrative, not actual Rust syntax) to indicate the reservation point of the borrow.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/two_phase_borrows.md#2025-04-21_snippet_1\n\nLANGUAGE: rust,ignore\nCODE:\n```\n// Case 1:\nlet mut v = Vec::new();\nlet temp1 = &two_phase v;\nlet temp2 = v.len();\nVec::push(temp1, temp2);\nlet r = &mut Vec::new();\nlet temp3 = &two_phase *r;\nlet temp4 = r.len();\nVec::push(temp3, temp4);\n\n// Case 2:\nlet temp5 = &two_phase *r;\nlet temp6 = vec![1, r.len()];\nstd::mem::replace(temp5, temp6);\n\n// Case 3:\nlet mut x = std::num::Wrapping(2);\nlet temp7 = &two_phase x;\nlet temp8 = x;\nstd::ops::AddAssign::add_assign(temp7, temp8);\n```\n\n----------------------------------------\n\nTITLE: Error Detection for Missing Byte String Terminator in Rust\nDESCRIPTION: This snippet illustrates an error message generated by the Rust compiler when a byte string literal is not properly terminated. The error specifically points out the missing double quote character (`\"`) at the end of the byte string literal. The input is a partially formed byte string literal, `b\"\\\"`. The output is an error diagnostic indicating the problem.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_slash_double_quote.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nBYTE_STRING \"b\\\"\\\"\" error: Missing trailing `\"` symbol to terminate the byte string literal\n```\n\n----------------------------------------\n\nTITLE: Tracking Variable Initialization Dynamically - Rust\nDESCRIPTION: This code snippet illustrates how variables are conditionally moved and emphasizes the dynamics of initialization prior to a drop. It shows the importance of understanding when a variable goes out of scope and the implications on its drop behavior.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/drop-elaboration.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut y = vec![];\n\n{\n    let x = vec![1, 2, 3];\n    if std::process::id() % 2 == 0 {\n        y = x; // conditionally move `x` into `y`\n    }\n} // `x` goes out of scope here. Should it be dropped?\n```\n\n----------------------------------------\n\nTITLE: MIR Basic Block Example\nDESCRIPTION: This MIR snippet shows an example of a basic block in MIR, including storage statements and a terminator that calls a function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/index.md#2025-04-21_snippet_3\n\nLANGUAGE: mir\nCODE:\n```\nbb0: {\n    StorageLive(_1);\n    _1 = const <std::vec::Vec<T>>::new() -> bb2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MappedRustDiagnostic Structure in Rust\nDESCRIPTION: This code snippet defines a MappedRustDiagnostic structure that contains detailed information about a Rust compiler error. It includes the file URL, diagnostic details such as error range, severity, code, and message.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/handles_macro_location.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nMappedRustDiagnostic {\n    url: Url {\n        scheme: \"file\",\n        cannot_be_a_base: false,\n        username: \"\",\n        password: None,\n        host: None,\n        port: None,\n        path: \"/test/src/main.rs\",\n        query: None,\n        fragment: None,\n    },\n    diagnostic: Diagnostic {\n        range: Range {\n            start: Position {\n                line: 1,\n                character: 4,\n            },\n            end: Position {\n                line: 1,\n                character: 26,\n            },\n        },\n        severity: Some(\n            Error,\n        ),\n        code: Some(\n            String(\n                \"E0277\",\n            ),\n        ),\n        code_description: Some(\n            CodeDescription {\n                href: Url {\n                    scheme: \"https\",\n                    cannot_be_a_base: false,\n                    username: \"\",\n                    password: None,\n                    host: Some(\n                        Domain(\n                            \"doc.rust-lang.org\",\n                        ),\n                    ),\n                    port: None,\n                    path: \"/error-index.html\",\n                    query: None,\n                    fragment: Some(\n                        \"E0277\",\n                    ),\n                },\n            },\n        ),\n        source: Some(\n            \"rustc\",\n        ),\n        message: \"can't compare `{integer}` with `&str`\\nthe trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n        related_information: None,\n        tags: None,\n        data: None,\n    },\n    fix: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Invalid Hexadecimal Character Error (lowercase)\nDESCRIPTION: This snippet demonstrates an error where a hexadecimal integer literal (0x) contains an invalid character 'g'. Valid hexadecimal characters are 0-9 and A-F (or a-f).\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/empty_int.txt#2025-04-21_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n\"INT_NUMBER \\\"0xg\\\" error: Missing digits after the integer base prefix\\nWHITESPACE \\\"\\n\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Registering Early Lint Pass with Clippy - Rust\nDESCRIPTION: Demonstrates how to manually register an early lint pass in Clippy by calling the store.register_early_pass method within the register_lints function. This is necessary when introducing a new lint pass that is not auto-registered by Clippy tooling. The key parameter is the lint pass constructor (here, FooFunctions), and the registration ensures the pass is executed during linting. No external dependencies are required but must be placed correctly in clippy_lints/src/lib.rs. The registration order can affect diagnostics output.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstore.register_early_pass(|| Box::new(foo_functions::FooFunctions));\n```\n\n----------------------------------------\n\nTITLE: Initializing Green Node Builder in Rust\nDESCRIPTION: A struct for constructing green syntax trees through depth-first traversal, providing methods to build and manipulate syntax nodes\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/syntax.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub struct GreenNodeBuilder { ... }\n\nimpl GreenNodeBuilder {\n    pub fn new() -> GreenNodeBuilder { ... }\n\n    pub fn token(&mut self, kind: SyntaxKind, text: &str) { ... }\n\n    pub fn start_node(&mut self, kind: SyntaxKind) { ... }\n    pub fn finish_node(&mut self) { ... }\n\n    pub fn finish(self) -> GreenNode { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding a Subtree Dependency Using Git in Bash\nDESCRIPTION: This Bash command adds a new subtree dependency to the Rust repository, effectively incorporating another repository like Clippy into the main rustc monorepo. It initializes the subtree and sets Clippy as part of the project's source tree. Ensure you run this from the repository's root directory and do not rebase the resulting commit.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/external-repos.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"git subtree add -P src/tools/clippy https://github.com/rust-lang/rust-clippy.git master\"\n```\n\n----------------------------------------\n\nTITLE: Re-export Data Structure Example in JSON\nDESCRIPTION: Example JSON structure showing how re-exported items are represented in the search index, demonstrating path tracking and canonical path storage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/search.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\n    [ \"crate_name\", {\n        \"doc\": \"Documentation\",\n        \"n\": [\"Data\", \"Data\"],\n        \"t\": \"FF\",\n        \"d\": [\"The data struct\", \"The data struct\"],\n        \"q\": [[0, \"crate_name\"], [1, \"crate_name::submodule\"]],\n        \"i\": [0, 0],\n        \"p\": [],\n        \"f\": \"\"\"\",\n        \"b\": [],\n        \"c\": [],\n        \"a\": [],\n        \"r\": [[0, 1]],\n    }]\n]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Trait Implementation in Rust\nDESCRIPTION: This code snippet shows an erroneous implementation of a trait method. The trait defines a method with a `&self` parameter, but the implementation incorrectly omits it, causing a compilation error.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0186.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Foo {\n    fn foo(&self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, method `foo` has a `&self` declaration in the trait, but not in\n    // the impl\n    fn foo() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Explaining Generic Arguments Symbol Mangling in Rust\nDESCRIPTION: Demonstrates how generic arguments, including types and const values, are mangled in a function's symbol.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/symbol-mangling/v0.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    example([123]);\n}\n\nfn example<T, const N: usize>(x: [T; N]) {}\n```\n\nLANGUAGE: text\nCODE:\n```\n_RINvCsgStHSCytQ6I_7mycrate7examplelKj1_EB2_\n  │└──────────────┬───────────────┘││││││\n  │               │                │││││└── end of generic-args\n  │               │                ││││└─── end of const-data\n  │               │                │││└──── const value `1`\n  │               │                ││└───── const type `usize`\n  │               │                │└────── const generic\n  │               │                └─────── generic type i32\n  │               └──────────────────────── path to \"mycrate::example\"\n  └──────────────────────────────────────── generic-args\n```\n\n----------------------------------------\n\nTITLE: Running Dependent Tests\nDESCRIPTION: This shows how to run tests that have dependencies, using Miri to specify the dependent filename.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n./miri run --dep tests/pass-dep/shims/libc-fs.rs\n```\n\n----------------------------------------\n\nTITLE: Cherry-picking Commit for Backport\nDESCRIPTION: Command to cherry-pick a merged PR commit to the beta branch using the commit SHA1.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/backport.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit cherry-pick -m 1 `<sha1>`\n```\n\n----------------------------------------\n\nTITLE: Export Table Output from objdump\nDESCRIPTION: Example output from running 'objdump -x' on a binary built with -Zexport-executable-symbols, showing the export directory containing the exported functions my_function and main.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/export-executable-symbols.md#2025-04-21_snippet_2\n\nLANGUAGE: plain\nCODE:\n```\nThe Export Tables (interpreted .edata section contents)\n\n...\n\n[Ordinal/Name Pointer] Table\n    [   0] my_function\n    [   1] main\n```\n\n----------------------------------------\n\nTITLE: Fetching PRs Between Commit Ranges\nDESCRIPTION: A command that uses a utility script to fetch all PRs between two specified commit hashes and save them to a file for review.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/changelog_update.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nutil/fetch_prs_between.sh commit1 commit2 > changes.txt\n```\n\n----------------------------------------\n\nTITLE: NLL Solver in Rust\nDESCRIPTION: This snippet discusses the functioning of the NLL solver within the MIR type-checker, which uses canonical queries for solving traits. It explains the use of `take_and_reset_region_constraints` at the end of the process to extract outlives constraints, and how this prepares the NLL solver for analyzing region variable origins with `take_region_var_origins`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/type-inference.md#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nThe NLL solver (actually, the MIR type-checker) does things slightly differently. It uses canonical queries for trait solving which use [`take_and_reset_region_constraints`] at the end. This extracts all of the outlives constraints added during the canonical query.\n```\n\n----------------------------------------\n\nTITLE: Query System for Parallel Compilation - Rust\nDESCRIPTION: This section describes the query model used in the Rust compiler's parallel environment. It explains how queries are evaluated in parallel and the mechanisms in place for cache management and cycle error detection.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/parallel-rustc.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// The query model has some properties that make it actually feasible to evaluate\n/// multiple queries in parallel without too much effort:\n/// \n/// - All data a query provider can access is via the query context, so\n///   the query context can take care of synchronizing access.\n/// - Query results are required to be immutable so they can safely be used by\n///   different threads concurrently.\n/// \n/// When a query `foo` is evaluated, the cache table for `foo` is locked.\n/// \n/// - If there already is a result, we can clone it, release the lock and\n///   we are done.\n/// - If there is no cache entry and no other active query invocation computing the\n///   same result, we mark the key as being \"in progress\", release the lock and\n///   start evaluating.\n/// - If there *is* another query invocation for the same key in progress, we\n///   release the lock, and just block the thread until the other invocation has\n///   computed the result we are waiting for. **Cycle error detection** in the parallel\n///   compiler requires more complex logic than in single-threaded mode.\n```\n\n----------------------------------------\n\nTITLE: Custom CSS for Search Interface\nDESCRIPTION: Styling rules for search input, button, and form layout with hover and focus effects\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/not_found.md#2025-04-21_snippet_3\n\nLANGUAGE: css\nCODE:\n```\n#search-input {\n    width: calc(100% - 100px);\n}\n#search-but {\n    cursor: pointer;\n}\n#search-but, #search-input {\n    padding: 4px;\n    border: 1px solid #ccc;\n    border-radius: 3px;\n    outline: none;\n    font-size: 0.7em;\n    background-color: #fff;\n}\n#search-but:hover, #search-input:focus {\n    border-color: #55a9ff;\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Argument Manipulation Example\nDESCRIPTION: Demonstrates how to unpack and pack generic arguments using GenericArgKind, showing type, lifetime, and const argument handling in Rust's type system.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/ty_module/generic_arguments.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn deal_with_generic_arg<'tcx>(generic_arg: GenericArg<'tcx>) -> GenericArg<'tcx> {\n    let new_generic_arg: GenericArgKind<'tcx> = match generic_arg.unpack() {\n        GenericArgKind::Type(ty) => { /* ... */ }\n        GenericArgKind::Lifetime(lt) => { /* ... */ }\n        GenericArgKind::Const(ct) => { /* ... */ }\n    };\n    new_generic_arg.pack()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Compiler Dependencies for m68k Linux\nDESCRIPTION: Command to install the g++ cross-compiler for m68k architecture on Debian-based systems, which automatically pulls in necessary cross-development dependencies\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# apt install g++-m68k-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Creating a Rustfix Test in Rust\nDESCRIPTION: Example of a Rustfix test that validates diagnostic suggestions and ensures they apply correctly. The test includes directives for run-rustfix and checks that the resulting code passes compilation after fixes are applied.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ui.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n//@ run-rustfix\n//@ check-pass\n#![crate_type = \"lib\"]\n\npub struct not_camel_case {}\n//~^ WARN `not_camel_case` should have an upper camel case name\n//~| HELP convert the identifier to upper camel case\n//~| SUGGESTION NotCamelCase\n```\n\n----------------------------------------\n\nTITLE: Registering Configurable Lint Pass in Clippy\nDESCRIPTION: Code comparison showing how to modify the lint registration to pass the configuration values to the lint implementation struct constructor.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/adding_lints.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n// Default generated registration:\nstore.register_*_pass(|| box module::StructName);\n\n// New registration with configuration value\nstore.register_*_pass(move || box module::StructName::new(conf));\n```\n\n----------------------------------------\n\nTITLE: Styling Documentation Interface with CSS\nDESCRIPTION: CSS styles for documentation navigation, search functionality, and external link indicators. Includes responsive design elements and hover states for interactive components.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/index.md#2025-04-21_snippet_0\n\nLANGUAGE: css\nCODE:\n```\nnav {\n    display: none;\n}\nh3 {\n    font-size: 1.35rem;\n}\nh4 {\n    font-size: 1.1rem;\n}\n\n#search-input {\n    width: calc(100% - 58px);\n}\n#search-but {\n    cursor: pointer;\n}\n#search-but, #search-input {\n    padding: 4px;\n    border: 1px solid #ccc;\n    border-radius: 3px;\n    outline: none;\n    font-size: 0.7em;\n    background-color: #fff;\n}\n#search-but:hover, #search-input:focus {\n    border-color: #55a9ff;\n}\n\nsvg.external-link {\n  display: inline-block;\n  position: relative;\n  vertical-align: super;\n  width: 0.7rem;\n  height: 0.7rem;\n  padding-left: 2px;\n  top: 3px;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Std - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `std` crate (index 6). It includes the Rust edition (`Edition2021`), standard compiler configuration flags, and an extensive list of dependencies, including `alloc`, `panic_unwind`, `panic_abort`, `core`, `profiler_builtins`, `unwind`, `std_detect`, and `test`. This crate represents the core standard library.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n6: CrateData {\n    root_file_id: FileId(\n        7,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"std\",\n            ),\n            canonical_name: \"std\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [\n        Dependency {\n            crate_id: Idx::<CrateData>(0),\n            name: CrateName(\n                \"alloc\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(3),\n            name: CrateName(\n                \"panic_unwind\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(2),\n            name: CrateName(\n                \"panic_abort\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(1),\n            name: CrateName(\n                \"core\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(5),\n            name: CrateName(\n                \"profiler_builtins\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(9),\n            name: CrateName(\n                \"unwind\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(7),\n            name: CrateName(\n                \"std_detect\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(8),\n            name: CrateName(\n                \"test\",\n            ),\n            prelude: true,\n            sysroot: false,\n        }\n    ],\n    origin: Lang(\n        Std,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Main Function Declaration in Rust\nDESCRIPTION: This snippet demonstrates an incorrect declaration of the `main` function in Rust.  The `main` function should not accept any arguments. The compiler will issue an error if arguments are provided.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0580.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```compile_fail,E0580\nfn main(x: i32) { // error: main function has wrong type\n    println!(\"{}\", x);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Contacting Rust for Linux Devs\nDESCRIPTION: This snippet provides instructions for pinging the Rust for Linux developers for support. It is essential for ensuring effective communication during issues related to the integration tests.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ecosystem-test-jobs/rust-for-linux.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"@rustbot ping rfl\"\n```\n\n----------------------------------------\n\nTITLE: Referencing AsyncFn Trait Documentation in Rust\nDESCRIPTION: This code snippet provides a link to the documentation for the `AsyncFn` trait in the Rust standard library. It demonstrates how to reference external documentation within Markdown files.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/async-fn-traits.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`AsyncFn*`]: ../../std/ops/trait.AsyncFn.html\n```\n\n----------------------------------------\n\nTITLE: is_char Implementation\nDESCRIPTION: Internal implementation of is_char method for type checking\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/type_checking.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[inline]\npub fn is_char(self) -> bool {\n    matches!(self.kind(), Char)\n}\n```\n\n----------------------------------------\n\nTITLE: Building Enzyme from LLVM\nDESCRIPTION: This snippet illustrates the final steps to build Enzyme from the previously built LLVM project, specifying necessary paths for configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/autodiff/installation.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:EnzymeAD/Enzyme.git \ncd Enzyme/enzyme\nmkdir build \ncd build \ncmake .. -G Ninja -DLLVM_DIR=<YourLocalPath>/llvm-project/build/lib/cmake/llvm/ -DLLVM_EXTERNAL_LIT=<YourLocalPath>/llvm-project/llvm/utils/lit/lit.py -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=YES -DBUILD_SHARED_LIBS=ON\ninja\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Documentation in bootstrap.toml - TOML\nDESCRIPTION: This snippet explains how to modify the bootstrap.toml file to enable the default building of compiler documentation when invoking the x doc command. It highlights the required configuration.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/compiler-documenting.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\n  compiler-docs = true\n```\n\n----------------------------------------\n\nTITLE: Including content from features_generated.md in Markdown\nDESCRIPTION: This snippet includes a section from the `features_generated.md` file, starting from line 2 and continuing for an unspecified number of lines. This is a common practice for incorporating dynamically generated or modular content into markdown documentation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/features.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n{{#include features_generated.md:2:}}\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Windows Handle Feature in Rust\nDESCRIPTION: This markdown snippet documents the 'windows_handle' feature, indicating that it is an internal feature of the Rust compiler and not intended for general use. It serves as a warning or notice to developers who might encounter this feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/windows-handle.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `windows_handle`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: LLVM Function Declaration Check\nDESCRIPTION: This snippet checks for the declaration of a function named `@foo`. It also captures the attribute list ID associated with the function declaration for later checks.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/no-builtins-attribute/filecheck.main.txt#2025-04-21_snippet_0\n\nLANGUAGE: llvm\nCODE:\n```\nCHECK: declare void @foo()\nCHECK-SAME: #[[ATTR_3:[0-9]+]]\n```\n\n----------------------------------------\n\nTITLE: Improved Pattern with Repetition Syntax\nDESCRIPTION: Example of a more concise pattern using proposed repetition syntax to match multiple occurrences of the same element in an array.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\npattern!{\n    my_pattern: Expr =\n        Array( Lit(Bool(false)){2} )\n}\n```\n\n----------------------------------------\n\nTITLE: Enable Separate MIR Files for Each Bit Width - Rust\nDESCRIPTION: This code snippet, when added to a Rust MIR test file, ensures that separate MIR output files are generated for 32-bit and 64-bit systems. This is useful when testing code with bit-width-dependent constants or pointers. It avoids issues with comparing MIR outputs across different architectures.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/mir-opt/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// EMIT_MIR_FOR_EACH_BIT_WIDTH\n```\n\n----------------------------------------\n\nTITLE: C Compilation for Arm64EC with MSVC Toolchain\nDESCRIPTION: Command-line compilation for C code targeting Arm64EC architecture using Microsoft Visual C++ compiler (cl) with Arm64EC specific flag\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/arm64ec-pc-windows-msvc.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncl /arm64EC /c ...\n```\n\n----------------------------------------\n\nTITLE: Checking Remote Branch Comparison with Changelog Script\nDESCRIPTION: Verifies changelog formatting between remote branch and current HEAD\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/sending-gcc-patch.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./contrib/gcc-changelog/git_check_commit.py upstream/master..HEAD\n```\n\n----------------------------------------\n\nTITLE: Example of Suggestion-style Lint Output in Rust\nDESCRIPTION: Example showing how suggestions appear in lint output, demonstrating fold-to-any conversion suggestion.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/emitting_lints.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nerror: This `.fold` can be more succinctly expressed as `.any`\n--> tests/ui/methods.rs:390:13\n    |\n390 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n    |\n```\n\n----------------------------------------\n\nTITLE: Context Comparison with Assertions in Rust\nDESCRIPTION: This snippet uses assertions to confirm that spans from different macro contexts are not equal.  It shows how `span.ctxt()` can identify spans within the same macro expansion context. This snippet works on a contrived macro m!.  The inputs are two spans: `x_is_some_span` and `x_unwrap_span`.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nmacro_rules! m {\n    ($a:expr, $b:expr) => {\n        if $a.is_some() {\n            $b;\n        }\n    }\n}\n\nlet x: Option<u32> = Some(42);\nm!(x, x.unwrap());\n\n// These spans are not from the same context\n// x.is_some() is from inside the macro\n// x.unwrap() is from outside the macro\nassert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n```\n\n----------------------------------------\n\nTITLE: Whitespace Characters in Rust\nDESCRIPTION: This snippet shows how whitespace characters are defined in Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/byte_strings.txt#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n\"WHITESPACE \\\" \\\"\"\n\n```\n\nLANGUAGE: Rust\nCODE:\n```\n\"WHITESPACE \\\"\\n\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: CI Tooling Documentation in Markdown\nDESCRIPTION: Documentation explaining the purpose of a Rust CI script that manages job execution determination and local CI testing capabilities.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/citool/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# CI tooling\nThis is a simple Rust script that determines which jobs should be executed on CI based on the situation (pull request, try job, merge attempt). It also provides a simple way of executing (some) CI jobs locally.\n```\n\n----------------------------------------\n\nTITLE: Defining CrateData Structures for Rust Standard Library Components\nDESCRIPTION: This code snippet defines CrateData structures for various components of the Rust standard library, including alloc, core, std, and utility crates. Each structure contains metadata such as root file ID, edition, display name, configuration options, dependencies, and origin.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_hello_world_project_model.txt#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    0: CrateData {\n        root_file_id: FileId(\n            1,\n        ),\n        edition: Edition2021,\n        version: None,\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"alloc\",\n                ),\n                canonical_name: \"alloc\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"debug_assertions\",\n                \"miri\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {},\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(1),\n                name: CrateName(\n                    \"core\",\n                ),\n                prelude: true,\n                sysroot: false,\n            },\n        ],\n        origin: Lang(\n            Alloc,\n        ),\n        is_proc_macro: false,\n        proc_macro_cwd: None,\n    },\n    // ... (similar structures for other crates)\n}\n```\n\n----------------------------------------\n\nTITLE: Subtyping Relationships with Return Types in Rust\nDESCRIPTION: This code snippet depicts the creation of subtyping relationships that include function return types, demonstrating the complexity of enforcing outlives constraints.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/borrow_check/region_inference/placeholders_and_universes.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n&'!1 u32 <: &'?3 u32 // arg 1\n&'!2 u32 <: &'?3 u32 // arg 2\n&'?3 u32 <: &'!1 u32 // return type\n```\n\n----------------------------------------\n\nTITLE: Invalid C-cmse-nonsecure-call Function with Alignment Issues\nDESCRIPTION: Example demonstrating alignment constraints where a u64 argument consumes two registers (r2 and r3), leaving no space for the final f32 argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0798.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(abi_c_cmse_nonsecure_call)]\n\n#[no_mangle]\npub fn test(\n    f: extern \"C-cmse-nonsecure-call\" fn(u32, u64, f32) -> u32,\n) -> u32 {\n    f(1, 2, 3.0)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Malformed Inline Assembly in Rust (Deprecated)\nDESCRIPTION: This code snippet shows an example of malformed inline assembly that would have previously triggered an LLVM rejection. The error occurs due to a missing closing bracket in the register constraint.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0668.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(llvm_asm)]\n\nfn main() {\n    let rax: u64;\n    unsafe {\n        llvm_asm!(\"\" :\"={rax\"(rax));\n        println!(\"Accumulator is: {}\", rax);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Debian m68k Chroot Environment\nDESCRIPTION: Commands to install debootstrap and create a Debian m68k chroot for running and testing m68k binaries using QEMU user emulation\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/m68k-unknown-linux-gnu.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# apt install debootstrap debian-ports-archive-keyring\n# debootstrap --keyring=/usr/share/keyrings/debian-ports-archive-keyring.gpg --arch=m68k unstable debian-68k http://ftp.ports.debian.org/debian-ports\n```\n\n----------------------------------------\n\nTITLE: Configuring GCC Linker for s390x in Cargo\nDESCRIPTION: This snippet demonstrates how to configure Cargo to use the GNU GCC linker for the `s390x-unknown-linux-gnu` target. This configuration is necessary when the system's default linker is not compatible with the target architecture.  Adding this to `.cargo/config.toml` ensures that the correct linker is used during the build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/s390x-unknown-linux-gnu.md#2025-04-21_snippet_4\n\nLANGUAGE: TOML\nCODE:\n```\n\n```toml\n[target.s390x-unknown-linux-gnu]\nlinker = \"s390x-linux-gnu-gcc\"\n```\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for hexagon-unknown-none-elf Target (TOML)\nDESCRIPTION: Specifies build settings in `bootstrap.toml` to include the `hexagon-unknown-none-elf` target when building the Rust toolchain. It defines host and target architectures, and configures the specific C/C++ compiler, linker, and archiver to use for the Hexagon target, along with enabling in-tree LLVM libunwind. Requires replacing `<target for your host>` with the appropriate host triple.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/hexagon-unknown-none-elf.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\nhost = [\"<target for your host>\"]\ntarget = [\"<target for your host>\", \"hexagon-unknown-none-elf\"]\n\n[target.hexagon-unknown-none-elf]\n\ncc = \"hexagon-unknown-none-elf-clang\"\ncxx = \"hexagon-unknown-none-elf-clang++\"\nlinker = \"hexagon-unknown-none-elf-clang\"\nranlib = \"hexagon-unknown-none-elf-ranlib\"\nar = \"hexagon-unknown-none-elf-ar\"\nllvm-libunwind = 'in-tree'\n```\n\n----------------------------------------\n\nTITLE: Enabling Languages in CMake\nDESCRIPTION: This CMake command enables support for C, C++, and Assembly languages within the project. It is a necessary step to compile and link source files written in these languages.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/libcmake_foo/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nenable_language(C CXX ASM)\n```\n\n----------------------------------------\n\nTITLE: Creating xwin-clang-cl Script for Cross-Compilation\nDESCRIPTION: This bash script configures clang-cl to use the Windows SDK include directories for cross-compilation. It sets the target to x86_64-pc-windows-msvc.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/win7-windows-msvc.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n#!/usr/bin/env bash\nset -e\nXWIN=/path/to/winsdk\nclang-cl /imsvc \"$XWIN/crt/include\" /imsvc \"$XWIN/sdk/include/ucrt\" /imsvc \"$XWIN/sdk/include/um\" /imsvc \"$XWIN/sdk/include/shared\" --target=\"x86_64-pc-windows-msvc\" \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Running Stdarch Tests with System Debugger Extension\nDESCRIPTION: Command to run stdarch tests with the System Debugger Extension (SDE) to emulate specific CPU features. Uses environment variables to configure test execution for x86_64 Linux.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_gcc/doc/debugging.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd build/build_sysroot/sysroot_src/library/stdarch/\nSTDARCH_TEST_EVERYTHING=1 CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER=\"sde -future -rtm_mode full --\" TARGET=x86_64-unknown-linux-gnu ../../../../../y.sh cargo test\n```\n\n----------------------------------------\n\nTITLE: Generating Manifest Locally\nDESCRIPTION: Cargo command to generate Rust distribution manifest using build-manifest package. Creates manifest files in build/manifest directory with specified parameters including date and distribution channel.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/build-manifest/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p build/manifest\ncargo +nightly run --release -p build-manifest build/dist build/manifest 1970-01-01 http://example.com nightly\n```\n\n----------------------------------------\n\nTITLE: Defining Projection\nDESCRIPTION: This snippet defines the structure of a Projection, consisting of an associated item reference along with its inputs P0..Pm.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/goals-and-clauses.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n\"Projection = <P0 as TraitName<P1..Pn>>::AssocItem<Pn+1..Pm>\"\n```\n\n----------------------------------------\n\nTITLE: Dot Completion for Fields and Methods (Rust)\nDESCRIPTION: This function implements completion for fields and methods after dot operators (foo.bar|), extracting semantic receiver types and determining available members and special completions like .await.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/guide.md#2025-04-21_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\n// https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/completions/dot.rs#L11-L41\n```\n\n----------------------------------------\n\nTITLE: LLVM Attribute Check\nDESCRIPTION: This snippet checks for the existence of an attribute list with a specific ID (captured in the previous snippet as `ATTR_3`). It then verifies that the `no-builtins` attribute is present in that attribute list.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/no-builtins-attribute/filecheck.main.txt#2025-04-21_snippet_1\n\nLANGUAGE: llvm\nCODE:\n```\nCHECK: attributes #[[ATTR_3]] \nCHECK-SAME: no-builtins\n```\n\n----------------------------------------\n\nTITLE: Configuring DFSan for DFSan Wrappers in Rust\nDESCRIPTION: This snippet marks DFSan wrapper functions as uninstrumented and discarded. These functions are specific to DFSan's internal operations and should not be analyzed.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/ui/sanitizer/dataflow-abilist.txt#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfun:__dfsw_*=uninstrumented\nfun:__dfsw_*=discard\nfun:__dfso_*=uninstrumented\nfun:__dfso_*=discard\n```\n\n----------------------------------------\n\nTITLE: Implementing MIR Optimization Passes in Rust\nDESCRIPTION: Guidelines for creating new MIR optimization passes in the Rust compiler, including step-by-step instructions for adding and testing a new optimization\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/mir/optimizations.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Make a Rust source file in `tests/mir-opt` that shows the code you want to optimize.\n2. Run `./x test --bless tests/mir-opt/<your-test>.rs` to generate a MIR dump.\n3. Commit the current working directory state.\n4. Implement a new optimization in `compiler/rustc_mir_transform/src`.\n5. Rerun `./x test --bless tests/mir-opt/<your-test>.rs`.\n6. Run `./x test tests/ui`.\n7. Commit and open a PR.\n```\n\n----------------------------------------\n\nTITLE: Checking Span for Macro Expansion in Rust\nDESCRIPTION: This snippet demonstrates how to use `span.from_expansion()` to detect if a given code span originates from a macro expansion.  It provides a basic conditional check to ignore code derived from macros, preventing false positives in lints.  The code requires a valid `expr.span` representing the code location.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/common_tools_writing_lints.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nif expr.span.from_expansion() {\n    // just forget it\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Conversion with Type Parameter Confirmation\nDESCRIPTION: Showcases trait implementation with type parameter conversion, highlighting the confirmation phase of trait resolution where type compatibility is checked\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/traits/resolution.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Convert<Target> {\n    fn convert(&self) -> Target;\n}\n\nimpl Convert<usize> for isize { ... } // isize -> usize\nimpl Convert<isize> for usize { ... } // usize -> isize\n\nlet x: isize = ...;\nlet y: char = x.convert(); // NOTE: `y: char` now!\n```\n\n----------------------------------------\n\nTITLE: Tagging the Stable Commit - Bash\nDESCRIPTION: This command sequence creates and pushes a tag for the stable release. The tag name follows the format `rust-1.XX.0`, where `XX` should be replaced with the corresponding Rust version.  `upstream` refers to the `rust-lang/rust-clippy` remote.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/infrastructure/release.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit tag rust-1.XX.0               # XX should be exchanged with the corresponding version\ngit push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote\n```\n\n----------------------------------------\n\nTITLE: Finding Next Available Rust Error Code\nDESCRIPTION: This shell command runs the `tidy` script, which checks for coding conventions and identifies the highest used error code. The output helps determine the next available error code for allocation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/diagnostics/error-codes.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n\n./x test tidy\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Trait Error Messages in Rust\nDESCRIPTION: Example demonstrating incorrect usage of the #[rustc_on_unimplemented] attribute where the error occurs due to missing identifier in curly braces. The attribute allows custom error messages with type parameter placeholders using {Self} and other type parameters.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0231.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n#![allow(internal_features)]\n\n#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{}>`\"] // error!\ntrait BadAnnotation<A> {}\n```\n\n----------------------------------------\n\nTITLE: Generating EarlyLintPass Boilerplate in Clippy\nDESCRIPTION: Command to generate boilerplate code for a new lint that uses EarlyLintPass. This is used when the lint doesn't need type information and only deals with syntax-related issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/lint_passes.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo dev new_lint --name=<your_new_lint> --pass=early --category=<your_category_choice>\n```\n\n----------------------------------------\n\nTITLE: Flycheck Control Notifications in TypeScript\nDESCRIPTION: Defines LSP notifications for controlling flycheck processes in Rust Analyzer, including running, clearing, and canceling flycheck diagnostics\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RunFlycheckParams {\n    textDocument: lc.TextDocumentIdentifier | null;\n}\n\ninterface ClearFlycheckParams {}\n\ninterface CancelFlycheckParams {}\n```\n\n----------------------------------------\n\nTITLE: Files Directive Example\nDESCRIPTION: Example demonstrating how to use the 'files' directive to verify directory contents matches expected entries.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/rustdoc-internals/rustdoc-test-suite.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//@ files \"foo/bar\" '[\"index.html\", \"sidebar-items.js\"]'\n```\n\n----------------------------------------\n\nTITLE: Building proc-macro-srv-cli\nDESCRIPTION: This command builds the `rust-analyzer-proc-macro-srv` component, used by rust-analyzer and IntelliJ Rust plugin to work with proc macros.  It's necessary when using custom toolchains.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/building/how-to-build-and-run.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./x build proc-macro-srv-cli\n```\n\n----------------------------------------\n\nTITLE: Register Class Table for s390x Architecture in Rust Inline Assembly\nDESCRIPTION: This table defines the 'vreg' register class for the s390x architecture, specifying the available registers and corresponding LLVM constraint code. It notes that 'vreg' is clobber-only in stable Rust.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/asm-experimental-reg.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Architecture | Register class | Registers | LLVM constraint code |\n| ------------ | -------------- | --------- | -------------------- |\n| s390x | `vreg` | `v[0-31]` | `v` |\n```\n\n----------------------------------------\n\nTITLE: Cyclic Relationship with Try and FromResidual Traits\nDESCRIPTION: Example showing trait relationships that form a cycle through implied bounds, which requires coinduction to handle correctly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/coinduction.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait FromResidual<R> {}\ntrait Try: FromResidual<<Self as Try>::Residual> {\n    type Residual;\n}\n\nstruct Ready<T>(T);\nimpl<T> Try for Ready<T> {\n    type Residual = Ready<()>;\n}\nimpl<T> FromResidual<<Ready<T> as Try>::Residual> for Ready<T> {}\n```\n\n----------------------------------------\n\nTITLE: Valid Type Parameter Naming - Unique Parameters\nDESCRIPTION: Correct example showing how to properly name type parameters with unique identifiers T and Y.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0403.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn f<T, Y>(s: T, u: Y) {}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Type-Specific Lint\nDESCRIPTION: This command is used to create a new lint that is associated with a specific lint type (e.g., functions, loops). It uses the Clippy dev tools, and registers the lint under a specific type. The `--type` flag is used instead of `--pass` as with standalone definitions. The output files are listed in the comments following the shell script.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/defining_lints.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo dev new_lint --name=foo_functions --type=functions --category=pedantic\n```\n\n----------------------------------------\n\nTITLE: Defining Crate Metadata for Proc Macro - Rust\nDESCRIPTION: Defines the `CrateData` structure for the `proc_macro` crate (index 4). It includes the Rust edition (`Edition2021`), standard compiler configuration flags (`debug_assertions`, `miri`, `true`), and its dependencies on the `std` (index 6) and `core` (index 1) crates. This crate is essential for defining procedural macros.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n4: CrateData {\n    root_file_id: FileId(\n        5,\n    ),\n    edition: Edition2021,\n    version: None,\n    display_name: Some(\n        CrateDisplayName {\n            crate_name: CrateName(\n                \"proc_macro\",\n            ),\n            canonical_name: \"proc_macro\",\n        },\n    ),\n    cfg_options: CfgOptions(\n        [\n            \"debug_assertions\",\n            \"miri\",\n            \"true\",\n        ],\n    ),\n    potential_cfg_options: None,\n    env: Env {\n        entries: {},\n    },\n    dependencies: [\n        Dependency {\n            crate_id: Idx::<CrateData>(6),\n            name: CrateName(\n                \"std\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n        Dependency {\n            crate_id: Idx::<CrateData>(1),\n            name: CrateName(\n                \"core\",\n            ),\n            prelude: true,\n            sysroot: false,\n        },\n    ],\n    origin: Lang(\n        ProcMacro,\n    ),\n    is_proc_macro: false,\n    proc_macro_cwd: None,\n}\n```\n\n----------------------------------------\n\nTITLE: Building Miri\nDESCRIPTION: This snippet shows the command to compile Miri after preparing the build environment. It details how to invoke the Miri build process.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./miri build\n```\n\n----------------------------------------\n\nTITLE: Multi-file Rust Program - Foo Module\nDESCRIPTION: Supporting module file containing a function that prints 'Hello, world!'\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/what-is-rustc.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an Unstable Lint with Feature Gate in Rust\nDESCRIPTION: This example demonstrates how to declare an unstable lint with a feature gate. The lint will only fire if the user has enabled the specified feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/guides/editions.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ndeclare_lint! {\n    pub SOME_LINT_NAME,\n    Allow,\n    \"my cool lint\",\n    @feature_gate = sym::my_feature_name;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fuchsia Package Metadata\nDESCRIPTION: JSON file defining the package name and version.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/fuchsia.md#2025-04-21_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"hello_fuchsia\",\n  \"version\": \"0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Integer Literals in Rust\nDESCRIPTION: Test cases for parsing integer literals with different bases, formats, and potential error conditions\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/numbers.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nINT_NUMBER \"0\"\nINT_NUMBER \"00\"\nINT_NUMBER \"0_\"\nINT_NUMBER \"01790\"\nINT_NUMBER \"0b1790\"\nINT_NUMBER \"0o1790\"\nINT_NUMBER \"0x1790aAbBcCdDeEfF\"\nINT_NUMBER \"001279\"\nINT_NUMBER \"0_1279\"\nINT_NUMBER \"1i64\"\nINT_NUMBER \"11__s\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Rust Compiler Feature 'fd' in Markdown\nDESCRIPTION: A markdown comment describing the 'fd' feature as internal to the Rust compiler and not intended for general use. This serves as a warning or notice to developers who might encounter this feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/fd.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `fd`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Hard Resetting Branch to Master in Git (Discarding Changes)\nDESCRIPTION: Resets the current branch head to match the 'master' branch, discarding any local changes, commits, and staging area modifications since the last common commit. Use with caution as changes are lost.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/git.md#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n# WARNING: this throws out any local changes you've made!\ngit reset --hard master\n```\n\n----------------------------------------\n\nTITLE: Copyright Disclaimer Template\nDESCRIPTION: Template for a copyright disclaimer that may need to be signed by an employer or school.\nSOURCE: https://github.com/rust-lang/rust/blob/master/LICENSES/GPL-2.0-only.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nYoyodyne, Inc., hereby disclaims all copyright\ninterest in the program `Gnomovision'\n(which makes passes at compilers) written \nby James Hacker.\n\nsignature of Ty Coon, 1 April 1989\nTy Coon, President of Vice\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error: Transparent Struct with Over-Aligned Zero-Sized Field in Rust\nDESCRIPTION: This code snippet shows an example that would have previously triggered the error. It defines a struct with repr(transparent) that contains a zero-sized field with an alignment of 32, which conflicts with the transparent representation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0691.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(repr_align)]\n\n#[repr(align(32))]\nstruct ForceAlign32;\n\n#[repr(transparent)]\nstruct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent\n                                   //        struct has alignment of 32, which\n                                   //        is larger than 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Code Action and Position Data Structures in Rust\nDESCRIPTION: Defines a complex nested data structure for handling code positions, ranges, and text edits. Contains definitions for code actions with fix suggestions including position tracking and text replacement functionality.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/test_data/snap_multi_line_fix.txt#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n                                end: Position {\n                                    line: 3,\n                                    character: 5,\n                                },\n                            },\n                        },\n                        message: \"original diagnostic\",\n                    },\n                ],\n            ),\n            tags: None,\n            data: None,\n        },\n        fix: Some(\n            Fix {\n                ranges: [\n                    Range {\n                        start: Position {\n                            line: 2,\n                            character: 4,\n                        },\n                        end: Position {\n                            line: 2,\n                            character: 30,\n                        },\n                    },\n                    Range {\n                        start: Position {\n                            line: 3,\n                            character: 4,\n                        },\n                        end: Position {\n                            line: 3,\n                            character: 5,\n                        },\n                    },\n                ],\n                action: CodeAction {\n                    title: \"return the expression directly: `(0..10).collect()`\",\n                    group: None,\n                    kind: Some(\n                        CodeActionKind(\n                            \"quickfix\",\n                        ),\n                    ),\n                    command: None,\n                    edit: Some(\n                        SnippetWorkspaceEdit {\n                            changes: Some(\n                                {\n                                    Url {\n                                        scheme: \"file\",\n                                        cannot_be_a_base: false,\n                                        username: \"\",\n                                        password: None,\n                                        host: None,\n                                        port: None,\n                                        path: \"/test/src/main.rs\",\n                                        query: None,\n                                        fragment: None,\n                                    }: [\n                                        TextEdit {\n                                            range: Range {\n                                                start: Position {\n                                                    line: 2,\n                                                    character: 4,\n                                                },\n                                                end: Position {\n                                                    line: 2,\n                                                    character: 30,\n                                                },\n                                            },\n                                            new_text: \"\",\n                                        },\n                                        TextEdit {\n                                            range: Range {\n                                                start: Position {\n                                                    line: 3,\n                                                    character: 4,\n                                                },\n                                                end: Position {\n                                                    line: 3,\n                                                    character: 5,\n                                                },\n                                            },\n                                            new_text: \"(0..10).collect()\",\n                                        },\n                                    ],\n                                },\n                            ),\n                            document_changes: None,\n                            change_annotations: None,\n                        },\n                    ),\n                    is_preferred: Some(\n                        true,\n                    ),\n                    data: None,\n                },\n            },\n        ),\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Running Specific x86_64 GNU LLVM Job\nDESCRIPTION: Example command to run the x86_64-gnu-llvm-19-1 CI job locally\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/ci/docker/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --manifest-path src/ci/citool/Cargo.toml run-local x86_64-gnu-llvm-19-1\n```\n\n----------------------------------------\n\nTITLE: Using Runtool and Runtool Arguments in Rustdoc (Bash)\nDESCRIPTION: This command shows how to use the --runtool and --runtool-arg flags in Rustdoc to specify a program to run tests with and pass arguments to it. It's useful for running doctests under specific programs or environments.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n$ rustdoc src/lib.rs -Z unstable-options --runtool runner --runtool-arg --do-thing --runtool-arg --do-other-thing\n```\n\n----------------------------------------\n\nTITLE: Generating Doctest Information in JSON Format (Bash)\nDESCRIPTION: This command shows how to use the --output-format doctest flag in Rustdoc to emit JSON information about doctests in the provided crate. It's useful for analyzing and processing doctest data.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/unstable-features.md#2025-04-21_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nrustdoc -Zunstable-options --output-format=doctest src/lib.rs\n```\n\n----------------------------------------\n\nTITLE: Combining Rust Installers with combine-installers.sh\nDESCRIPTION: This bash command uses combine-installers.sh to merge multiple installers into a single package. It specifies various parameters including product name, manifest directory, work and output directories, and input tarballs to be combined.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-installer/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./combine-installers.sh --product-name=Rust \\\n                        --rel-manifest-dir=rustlib \\\n                        --success-message=Rust-is-ready-to-roll. \\\n                        --work-dir=./temp \\\n                        --output-dir=./dist \\\n                        --non-installed-overlay=./overlay \\\n                        --package-name=rustc-nightly-i686-apple-darwin \\\n                        --legacy-manifest-dirs=rustlib \\\n                        --input-tarballs=./rustc.tar.gz,cargo.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Build for mipsel-sony-psx Target\nDESCRIPTION: TOML configuration for enabling the mipsel-sony-psx target in a Rust build. This snippet specifies the build stage and target for cross-compilation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/mipsel-sony-psx.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nbuild-stage = 1\ntarget = [\"mipsel-sony-psx\"]\n```\n\n----------------------------------------\n\nTITLE: Pinging Fuchsia Team on Rustbot\nDESCRIPTION: Command to notify the Fuchsia team through Rustbot when help is needed with build issues.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/tests/ecosystem-test-jobs/fuchsia.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n@rustbot ping fuchsia\n```\n\n----------------------------------------\n\nTITLE: Inline Code Reference\nDESCRIPTION: Inline code formatting in markdown to highlight the rustc compiler name.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/contributing.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`rustc`\n```\n\n----------------------------------------\n\nTITLE: LLVM Profile Count Verification\nDESCRIPTION: This snippet validates the counts associated with the `!prof` metadata tags defined earlier. It verifies the `function_entry_count` and `branch_weights` for each of the functions.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/pgo-branch-weights/filecheck-patterns.txt#2025-04-21_snippet_1\n\nLANGUAGE: llvm\nCODE:\n```\nCHECK: [[function_called_twice_id]] = !{{\"function_entry_count\", i64 2}\nCHECK: [[branch_weights0]] = !{{\"branch_weights\", i32 2, i32 0}\nCHECK: [[function_called_42_times_id]] = !{{\"function_entry_count\", i64 42}\nCHECK: [[branch_weights1]] = !{{\"branch_weights\", i32 2, i32 12, i32 28}\nCHECK: [[function_called_never_id]] = !{{\"function_entry_count\", i64 0}\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Rust Compiler Feature in Markdown\nDESCRIPTION: This snippet provides a short explanation about the 'print_internals' feature, indicating that it is for internal use within the Rust compiler and not meant for general usage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/print-internals.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `print_internals`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for Rustfmt 0.2.3\nDESCRIPTION: Details extensive changes in version 0.2.3 including new configuration options, formatting changes, and bug fixes.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rustfmt/CHANGELOG.md#2025-04-21_snippet_27\n\nLANGUAGE: markdown\nCODE:\n```\n## [0.2.3] 2017-08-30\n\n### Added\n\n- `multiline_closure_forces_block` configuration option (#1898).\n- `multiline_match_arm_forces_block` configuration option (#1898).\n- `merge_derives` configuration option (#1910).\n- `struct_remove_empty_braces` configuration option (#1930).\n- Various refactorings.\n\n### Changed\n\n- Put single-lined block comments on the same line with list-like structure's item (#1923).\n- Preserve blank line between doc comment and attribute (#1925).\n- Put the opening and the closing braces of enum and struct on the same line, even when `item_brace_style = \"AlwaysNextLine\"` (#1930).\n\n### Fixed\n\n- Format attributes on `ast::ForeignItem` and take max width into account (#1916).\n- Ignore empty lines when calculating the shortest indent width inside macro with braces (#1918).\n- Handle tabs properly inside macro with braces (#1918).\n- Fix a typo in `compute_budgets_for_args()` (#1924).\n- Recover comment between keyword (`impl` and `trait`) and `{` which used to get removed (#1925).\n```\n\n----------------------------------------\n\nTITLE: Target Addition Issue Template for Rust Compiler\nDESCRIPTION: A markdown template for requesting a compiler team member review when adding a new target to Rust. This is used as part of the pull request process to ensure proper review.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/target-tier-policy.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nr? compiler\n```\n\n----------------------------------------\n\nTITLE: Markdown Header for rustc-std-workspace-std Documentation\nDESCRIPTION: Simple markdown header indicating the crate name and reference to related documentation\nSOURCE: https://github.com/rust-lang/rust/blob/master/library/rustc-std-workspace-std/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# The `rustc-std-workspace-std` crate\n\nSee documentation for the `rustc-std-workspace-core` crate.\n```\n\n----------------------------------------\n\nTITLE: Internal Feature Marker for update_panic_count\nDESCRIPTION: Markdown header indicating the internal compiler feature update_panic_count that is restricted from general use\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/update-panic-count.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `update_panic_count`\n```\n\n----------------------------------------\n\nTITLE: Copying Cargo from Nightly Toolchain\nDESCRIPTION: Command to copy the cargo binary from the nightly toolchain to the local build directory. This ensures compatibility with the custom-built Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/docs/rustc_testing.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp $(rustup +nightly which cargo) ./build/host/stage2/bin/cargo\n```\n\n----------------------------------------\n\nTITLE: Markdown Code of Conduct Link\nDESCRIPTION: Simple markdown document that references the external Code of Conduct document for the Rust project.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/CODE_OF_CONDUCT.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# The Rust Code of Conduct\n\nThis repository follows the [Code of Conduct](https://www.rust-lang.org/policies/code-of-conduct) of the Rust organization.\n```\n\n----------------------------------------\n\nTITLE: LLVM Function Profile Check\nDESCRIPTION: This snippet checks that the `!prof` metadata is correctly attached to the specified functions, `function_called_twice`, `function_called_42_times`, and `function_called_never`. It also verifies that the branching instructions within these functions have the appropriate `!prof` metadata.\nSOURCE: https://github.com/rust-lang/rust/blob/master/tests/run-make/pgo-branch-weights/filecheck-patterns.txt#2025-04-21_snippet_0\n\nLANGUAGE: llvm\nCODE:\n```\nCHECK: define void @function_called_twice(i32 {{.*}} !prof [[function_called_twice_id:![0-9]+]] {\nCHECK: br i1 {{.*}}, label {{.*}}, label {{.*}}, !prof [[branch_weights0:![0-9]+]]\n\nCHECK: define void @function_called_42_times(i32{{.*}} %c) {{.*}} !prof [[function_called_42_times_id:![0-9]+]] {\nCHECK:      switch i32 %c, label {{.*}} [\nCHECK-NEXT:     i32 97, label {{.*}}\nCHECK-NEXT:     i32 98, label {{.*}}\nCHECK-NEXT: ], !prof [[branch_weights1:![0-9]+]]\n\nCHECK: define void @function_called_never(i32 {{.*}} !prof [[function_called_never_id:![0-9]+]] {\n```\n\n----------------------------------------\n\nTITLE: Defining Diagnostic Interface with Colored Output in TypeScript\nDESCRIPTION: TypeScript interface definition for LSP Diagnostic objects that includes support for rendered compiler output with optional ANSI color codes. This is used when the client has the 'colorDiagnosticOutput' capability enabled.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/docs/book/src/contributing/lsp-extensions.md#2025-04-21_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n// https://microsoft.github.io/language-server-protocol/specifications/specification-current#diagnostic\nexport interface Diagnostic {\n    ...\n    data?: {\n        /**\n         * The human-readable compiler output as it would be printed to a terminal.\n         * Includes ANSI color and style codes if the client has set the experimental\n         * `colorDiagnosticOutput` capability.\n         */\n        rendered?: string;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal Rust Compiler Feature in Markdown\nDESCRIPTION: This snippet provides a brief documentation for the 'link_cfg' feature, which is internal to the Rust compiler. It explicitly states that this feature is not intended for general use, indicating it's a specialized component of the compiler's implementation.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/link-cfg.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `link_cfg`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Comment Styles in Bash\nDESCRIPTION: These snippets illustrate several ways to document and comment within a shell script. The examples include various comment prefixes such as '//', '//!', and '///', which do not affect the execution of the script. This is useful for documentation and organizational purposes in different contexts when writing scripts.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/ok/single_line_comments.txt#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n#!/usr/bin/env bash\\n\\n// hello\\n//! World\\n//!! Inner line doc\\n/// Outer line doc\\n//// Just a comment\\n\\n//\\n//!\\n//!!\\n///\\n////\\n\n```\n\n----------------------------------------\n\nTITLE: Tagging Issues with Rustbot\nDESCRIPTION: These are example commands for tagging an issue as appropriate for a notification group using rustbot. Each command pings a specific group by name, notifying the members of that group. These commands are typically used during compiler team triage.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/about.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n@rustbot ping apple\n@rustbot ping arm\n@rustbot ping cleanup-crew\n@rustbot ping emscripten\n@rustbot ping icebreakers-llvm\n@rustbot ping risc-v\n@rustbot ping wasi\n@rustbot ping wasm\n@rustbot ping windows\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Rust Compiler Feature 'core_private_diy_float'\nDESCRIPTION: This code snippet defines an internal feature of the Rust compiler called 'core_private_diy_float'. It is explicitly stated that this feature is not intended for general use and is internal to the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/core-private-diy-float.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `core_private_diy_float`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Adding User to Rust Team\nDESCRIPTION: This command is used to add a user to the Rust team. It needs to be executed after adding the user's GitHub username to the relevant file in the Rust team repository, if the user is not already a member of a Rust team. The command takes the user's GitHub username as an argument.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/notification-groups/about.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run add-person $your_user_name\n```\n\n----------------------------------------\n\nTITLE: Debugging Type Layout with rustc_layout in Rust\nDESCRIPTION: This code snippet demonstrates the use of the #[rustc_layout(...)] attribute to debug the ABI and size of an enum at compile time. It shows how to apply the attribute to a simple enum with two variants.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/rustc-attrs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(rustc_attrs)]\n\n#[rustc_layout(abi, size)]\npub enum X {\n    Y(u8, u8, u8),\n    Z(isize),\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Graph Visualization with Mermaid\nDESCRIPTION: Visualization of a cycle dependency tree showing relationships between nodes A, B, and C where A and B are cycle heads but only A is a root.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/solve/caching.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TB\n    A --> B\n    B --> C\n    C --> B\n    C --> A\n```\n\n----------------------------------------\n\nTITLE: Search Form Population and Event Listener Setup\nDESCRIPTION: Initializes search form, sets default values, and attaches submit event handler\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/not_found.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction populate_search() {\n    var form = document.getElementById('search-form');\n    form.addEventListener('submit', on_submit);\n    document.getElementById('search-from').style.display = '';\n\n    form['from'].value = 'library';\n\n    var op = get_url_fragments();\n    document.getElementById('search-input').value = op.join(' ');\n}\npopulate_search();\n```\n\n----------------------------------------\n\nTITLE: Invalid Track Caller Attribute Usage Example in Rust\nDESCRIPTION: Demonstrates incorrect usage of the #[track_caller] attribute by attempting to apply it to a struct definition. The #[track_caller] attribute can only be applied to functions, resulting in compilation error E0739.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0739.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[track_caller]\nstruct Bar {\n    a: u8,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bootstrap for Coverage Instrumentation\nDESCRIPTION: TOML configuration settings for enabling profiler runtime and debug assertions in Rust compiler builds\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/llvm-coverage-instrumentation.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nprofile = \"codegen\"\n\n[build]\nprofiler = true\n\n[rust]\ndebug-assertions = true\n```\n\n----------------------------------------\n\nTITLE: Defining CrateData Instances in Rust\nDESCRIPTION: This Rust code defines two instances of a `CrateData` struct, indexed as 10 and 11. These structures hold metadata for Rust crates named \"hello_world\" and \"other_crate\", respectively. Key fields include `edition` (Edition2018), `display_name`, `cfg_options` (compilation configuration flags), `dependencies` (listing standard library dependencies like core, alloc, std, test, proc_macro), and `origin` (indicating they are local crates). These definitions are likely used internally by a compiler or analysis tool.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/project-model/test_data/output/rust_project_cfg_groups.txt#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n        proc_macro_cwd: None,\n    },\n    10: CrateData {\n        root_file_id: FileId(\n            11,\n        ),\n        edition: Edition2018,\n        version: None,\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"hello_world\",\n                ),\n                canonical_name: \"hello_world\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"group1_cfg=some_config\",\n                \"group1_other_cfg=other_config\",\n                \"group2_cfg=yet_another_config\",\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {},\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(1),\n                name: CrateName(\n                    \"core\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"alloc\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(6),\n                name: CrateName(\n                    \"std\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(8),\n                name: CrateName(\n                    \"test\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"proc_macro\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"hello_world\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: None,\n    },\n    11: CrateData {\n        root_file_id: FileId(\n            11,\n        ),\n        edition: Edition2018,\n        version: None,\n        display_name: Some(\n            CrateDisplayName {\n                crate_name: CrateName(\n                    \"other_crate\",\n                ),\n                canonical_name: \"other_crate\",\n            },\n        ),\n        cfg_options: CfgOptions(\n            [\n                \"group2_cfg=fourth_config\",\n                \"group2_cfg=yet_another_config\",\n                \"rust_analyzer\",\n                \"test\",\n                \"true\",\n                \"unrelated_cfg\",\n            ],\n        ),\n        potential_cfg_options: None,\n        env: Env {\n            entries: {},\n        },\n        dependencies: [\n            Dependency {\n                crate_id: Idx::<CrateData>(1),\n                name: CrateName(\n                    \"core\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(0),\n                name: CrateName(\n                    \"alloc\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(6),\n                name: CrateName(\n                    \"std\",\n                ),\n                prelude: true,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(8),\n                name: CrateName(\n                    \"test\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n            Dependency {\n                crate_id: Idx::<CrateData>(4),\n                name: CrateName(\n                    \"proc_macro\",\n                ),\n                prelude: false,\n                sysroot: true,\n            },\n        ],\n        origin: Local {\n            repo: None,\n            name: Some(\n                \"other_crate\",\n            ),\n        },\n        is_proc_macro: false,\n        proc_macro_cwd: None,\n    },\n```\n\n----------------------------------------\n\nTITLE: Example of Contextual Date Usage\nDESCRIPTION: This snippet provides an example of how to contextualize information with a date in the documentation. It emphasizes the importance of adding a date for reliability.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nAs of <!-- date-check --> Apr 2025, the foo did the bar.\n```\n\n----------------------------------------\n\nTITLE: Invalid Drop Implementation on Trait Object (Rust)\nDESCRIPTION: This code demonstrates an invalid attempt to implement the Drop trait directly on a trait object. In Rust, only structs, enums, and unions can implement Drop.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0120.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait MyTrait {}\n\nimpl Drop for MyTrait {\n    fn drop(&mut self) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Fine-grained Logging\nDESCRIPTION: This snippet configures the logging settings in Miri to trace which MIR statements are executed, useful for debugging.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/miri/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nMIRI_LOG=info ./miri run tests/pass/vec.rs\n```\n\nLANGUAGE: Shell\nCODE:\n```\nMIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows ./miri run tests/pass/vec.rs\n```\n\n----------------------------------------\n\nTITLE: Using Tiny Const Eval Limit Flag in Rust\nDESCRIPTION: The -Ztiny-const-eval-limit is a compiler flag that enforces a minimal, fixed limit for constant evaluation. This flag is specifically designed for use in rustc's test suite and should not be used in production code.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/tiny-const-eval-limit.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `tiny-const-eval-limit`\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Rust Compiler Feature in Markdown\nDESCRIPTION: This snippet defines the 'profiler_runtime_lib' feature as an internal component of the Rust compiler, emphasizing that it is not intended for general use.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/profiler-runtime-lib.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# `profiler_runtime_lib`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Enum for Type-Preserving Returns\nDESCRIPTION: This snippet demonstrates creating a custom enum with variants for each possible return type. This approach allows preserving the original types while still providing a single return type for the function.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0746.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Rust Documentation Reference\nDESCRIPTION: Use the 'rustdoc' command to render a Markdown file to HTML, facilitating the verification of small documentation fixes. Note that CSS may not render perfectly.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/contributing.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nrustdoc src/doc/reference.md\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation - Clippy Roadmap 2021\nDESCRIPTION: Comprehensive markdown document detailing Clippy's planned improvements for 2021, including user-facing changes like lint configurations and internal process developments for better project management.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/clippy/book/src/development/proposals/roadmap-2021.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Roadmap 2021\n\n# Summary\n\nThis Roadmap lays out the plans for Clippy in 2021:\n\n- Improving usability and reliability\n- Improving experience of contributors and maintainers \n- Develop and specify processes\n\n[...remaining markdown content...]\n```\n\n----------------------------------------\n\nTITLE: Float128 Type Declaration Comment\nDESCRIPTION: Documentation header specifying the f128 type for IEEE 128-bit floating point numbers, with reference to tracking issue #116909.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/language-features/f128.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `f128`\n\nThe tracking issue for this feature is: [#116909]\n\n[#116909]: https://github.com/rust-lang/rust/issues/116909\n\n---\n\nEnable the `f128` type for  IEEE 128-bit floating numbers (quad precision).\n```\n\n----------------------------------------\n\nTITLE: Rustdoc Verbose Version Output\nDESCRIPTION: This is an example of verbose output when using the `--verbose` and `--version` flags together. This output provides additional information about the rustdoc build and environment, including binary path, commit hash, date, host tuple, release version, and LLVM version.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/command-line-arguments.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n$ rustdoc --verbose --version\nrustdoc 1.17.0 (56124baa9 2017-04-24)\nbinary: rustdoc\ncommit-hash: hash\ncommit-date: date\nhost: host-tuple\nrelease: 1.17.0\nLLVM version: 3.9\n```\n\n----------------------------------------\n\nTITLE: Referencing Rust Allocator API Tracking Issue\nDESCRIPTION: Provides a link to the GitHub issue tracking the `allocator_api` feature in Rust. This reference allows developers to follow the progress and discussions related to this feature.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/allocator-api.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[#32838]: https://github.com/rust-lang/rust/issues/32838\n```\n\n----------------------------------------\n\nTITLE: Invalid Input Operand Constraint in llvm_asm Macro (Rust)\nDESCRIPTION: This code snippet demonstrates an erroneous use of the llvm_asm macro in Rust. It shows an invalid input operand constraint '+test' which would have previously triggered a compiler error. This error is no longer emitted by the compiler as the llvm_asm macro has been deprecated.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0663.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nllvm_asm!(\"xor %eax, %eax\"\n          :\n          : \"+test\"(\"a\")\n         );\n```\n\n----------------------------------------\n\nTITLE: Fixed-Length Array Pattern Matching in Rust\nDESCRIPTION: Correct implementation using a fixed-length array of size 3, allowing proper pattern matching with rest patterns.\nSOURCE: https://github.com/rust-lang/rust/blob/master/compiler/rustc_error_codes/src/error_codes/E0730.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn is_123(x: [u32; 3]) -> bool { // We use an array with a fixed size\n    match x {\n        [1, 2, ..] => true, // ok!\n        _ => false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Rust Compiler Feature: core_private_bignum\nDESCRIPTION: This code snippet defines the 'core_private_bignum' feature as an internal component of the Rust compiler. It explicitly states that this feature is not intended for general use, indicating its restricted access and specialized purpose within the compiler's architecture.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/library-features/core-private-bignum.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# `core_private_bignum`\n\nThis feature is internal to the Rust compiler and is not intended for general use.\n```\n\n----------------------------------------\n\nTITLE: Rust Byte String Error: Missing Trailing Quote\nDESCRIPTION: This error occurs when defining a byte string literal in Rust using the `b\"` prefix but failing to include a closing `\"` character. The compiler expects a matching quote to terminate the string. Correcting this error involves adding the missing closing quote to properly delimit the byte string.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/tools/rust-analyzer/crates/parser/test_data/lexer/err/unclosed_byte_string_with_ferris.txt#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"BYTE_STRING \\\"b\\\"🦀\\\" error: Missing trailing `\\\"` symbol to terminate the byte string literal\"\n```\n\n----------------------------------------\n\nTITLE: Markdown List of Rust Humor References\nDESCRIPTION: A markdown formatted list of links to various humorous content in the Rust ecosystem, including test files, blog posts, and pull requests that demonstrate the community's sense of humor.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/rustc-dev-guide/src/appendix/humorust.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Humor in Rust\n\nWhat's a project without a sense of humor? And frankly some of these are\nenlightening?\n\n- [Weird exprs test](https://github.com/rust-lang/rust/blob/master/tests/ui/weird-exprs.rs)\n- [Ferris Rap](https://fitzgen.com/2018/12/13/rust-raps.html)\n- [The Genesis of Generic Germination](https://github.com/rust-lang/rust/pull/53645#issue-210543221)\n- [The Bastion of the Turbofish test](https://github.com/rust-lang/rust/blob/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f/src/test/ui/bastion-of-the-turbofish.rs)\n- [Rust Koans](https://users.rust-lang.org/t/rust-koans/2408)\n- [`break rust;`](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0ab2bd6a9d722e0f05a95e2a5dcf89cc)\n- [The Nomicon Intro](https://doc.rust-lang.org/stable/nomicon/)\n- [`rustc-ty` renaming punfest](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/rustc-ty.20naming.20bikeshed.20.2F.20punfest.20%28was.3A.20design.20meeting.202.2E.2E.2E/near/189906455)\n- [try using their name \"ferris\" instead](https://github.com/rust-lang/rust/pull/91476)\n- [Forbid pineapple on pizza](https://github.com/rust-lang/rust/pull/70645)\n```\n\n----------------------------------------\n\nTITLE: Markdown UB Checks Documentation\nDESCRIPTION: Markdown documentation detailing the -Zub-checks compiler flag implementation, its relationship with debug-assertions, and handling of undefined behavior detection through non-unwinding panics.\nSOURCE: https://github.com/rust-lang/rust/blob/master/src/doc/unstable-book/src/compiler-flags/ub-checks.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `ub-checks`\n\nThe tracking issue for this feature is: [#123499](https://github.com/rust-lang/rust/issues/123499).\n\n--------------------\n\nThe `-Zub-checks` compiler flag enables additional runtime checks that detect some causes of Undefined Behavior at runtime.\nBy default, `-Zub-checks` flag inherits the value of `-Cdebug-assertions`.\n\nAll checks are generated on a best-effort basis; even if we have a check implemented for some cause of Undefined Behavior, it may be possible for the check to not fire.\nIf a dependency is compiled with `-Zub-checks=no` but the final binary or library is compiled with `-Zub-checks=yes`, UB checks reached by the dependency are likely to be optimized out.\n\nWhen `-Zub-checks` detects UB, a non-unwinding panic is produced.\nThat means that we will not unwind the stack and will not call any `Drop` impls, but we will execute the configured panic hook.\nWe expect that unsafe code has been written which relies on code not unwinding which may have UB checks inserted.\nErgo, an unwinding panic could easily turn works-as-intended UB into a much bigger problem.\nCalling the panic hook theoretically has the same implications, but we expect that the standard library panic hook will be stateless enough to be always called, and that if a user has configured a panic hook that the hook may be very helpful to debugging the detected UB.\n```"
  }
]