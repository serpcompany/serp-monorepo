[
  {
    "owner": "sourcegraph",
    "repo": "conc",
    "content": "TITLE: Using conc.WaitGroup for Safer Goroutine Management in Go\nDESCRIPTION: Example demonstrating the use of conc.WaitGroup to manage goroutines safely, including automatic panic handling and propagation.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    var wg conc.WaitGroup\n    wg.Go(doSomethingThatMightPanic)\n    // panics with a nice stacktrace\n    wg.Wait()\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Goroutines and Waiting for Completion in Go\nDESCRIPTION: Demonstrates how to spawn a set of goroutines and wait for them to finish using both standard Go and the 'conc' package. The 'conc' version simplifies error handling and reduces boilerplate code.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            // crashes on panic!\n            doSomething()\n        }()\n    }\n    wg.Wait()\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    var wg conc.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Go(doSomething)\n    }\n    wg.Wait()\n}\n```\n\n----------------------------------------\n\nTITLE: Concurrent Slice Mapping in Go\nDESCRIPTION: Demonstrates how to concurrently map a slice using both standard Go and the 'conc' package. The 'conc' version simplifies the implementation by using the 'iter.Map' function.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc concMap(\n    input []int,\n    f func(int) int,\n) []int {\n    res := make([]int, len(input))\n    var idx atomic.Int64\n\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n\n            for {\n                i := int(idx.Add(1) - 1)\n                if i >= len(input) {\n                    return\n                }\n\n                res[i] = f(input[i])\n            }\n        }()\n    }\n    wg.Wait()\n    return res\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc concMap(\n    input []int,\n    f func(*int) int,\n) []int {\n    return iter.Map(input, f)\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Ordered Stream Concurrently in Go\nDESCRIPTION: Shows how to process an ordered stream concurrently while maintaining order. The 'conc' version uses the 'stream' package to simplify the implementation and reduce boilerplate code.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc mapStream(\n    in chan int,\n    out chan int,\n    f func(int) int,\n) {\n    tasks := make(chan func())\n    taskResults := make(chan chan int)\n\n    // Worker goroutines\n    var workerWg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        workerWg.Add(1)\n        go func() {\n            defer workerWg.Done()\n            for task := range tasks {\n                task()\n            }\n        }()\n    }\n\n    // Ordered reader goroutines\n    var readerWg sync.WaitGroup\n    readerWg.Add(1)\n    go func() {\n        defer readerWg.Done()\n        for result := range taskResults {\n            item := <-result\n            out <- item\n        }\n    }()\n\n    // Feed the workers with tasks\n    for elem := range in {\n        resultCh := make(chan int, 1)\n        taskResults <- resultCh\n        tasks <- func() {\n            resultCh <- f(elem)\n        }\n    }\n\n    // We've exhausted input.\n    // Wait for everything to finish\n    close(tasks)\n    workerWg.Wait()\n    close(taskResults)\n    readerWg.Wait()\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc mapStream(\n    in chan int,\n    out chan int,\n    f func(int) int,\n) {\n    s := stream.New().WithMaxGoroutines(10)\n    for elem := range in {\n        elem := elem\n        s.Go(func() stream.Callback {\n            res := f(elem)\n            return func() { out <- res }\n        })\n    }\n    s.Wait()\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Slice Elements with Static Goroutine Pool in Go\nDESCRIPTION: Illustrates how to process each element of a slice using a static pool of goroutines. The 'conc' version significantly simplifies the code by using the 'iter.ForEach' function.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc process(values []int) {\n    feeder := make(chan int, 8)\n\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for elem := range feeder {\n                handle(elem)\n            }\n        }()\n    }\n\n    for _, value := range values {\n        feeder <- value\n    }\n    close(feeder)\n    wg.Wait()\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc process(values []int) {\n    iter.ForEach(values, handle)\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Stream Elements with Static Goroutine Pool in Go\nDESCRIPTION: Shows how to process each element of a stream using a static pool of goroutines. The 'conc' version uses a pool abstraction to simplify goroutine management and improve code readability.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc process(stream chan int) {\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for elem := range stream {\n                handle(elem)\n            }\n        }()\n    }\n    wg.Wait()\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc process(stream chan int) {\n    p := pool.New().WithMaxGoroutines(10)\n    for elem := range stream {\n        elem := elem\n        p.Go(func() {\n            handle(elem)\n        })\n    }\n    p.Wait()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Goroutine Management with Standard Library in Go\nDESCRIPTION: Example showing how to manage goroutines and handle panics using the standard library, which is more verbose compared to using conc.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype caughtPanicError struct {\n    val   any\n    stack []byte\n}\n\nfunc (e *caughtPanicError) Error() string {\n    return fmt.Sprintf(\n        \"panic: %q\\n%s\",\n        e.val,\n        string(e.stack)\n    )\n}\n\nfunc main() {\n    done := make(chan error)\n    go func() {\n        defer func() {\n            if v := recover(); v != nil {\n                done <- &caughtPanicError{\n                    val: v,\n                    stack: debug.Stack()\n                }\n            } else {\n                done <- nil\n            }\n        }()\n        doSomethingThatMightPanic()\n    }()\n    err := <-done\n    if err != nil {\n        panic(err)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing conc Package in Go\nDESCRIPTION: Command to install the conc package using Go's package manager.\nSOURCE: https://github.com/sourcegraph/conc/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/sourcegraph/conc\n```"
  }
]