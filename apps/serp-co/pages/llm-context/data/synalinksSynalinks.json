[
  {
    "owner": "synalinks",
    "repo": "synalinks",
    "content": "TITLE: Implementing LM Application using Functional API\nDESCRIPTION: Example of creating a language model application using Synalinks' functional API approach. Demonstrates setting up data models, language model configuration, and program structure using async/await pattern.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    x0 = synalinks.Input(data_model=Query)\n    x1 = await synalinks.Generator(\n        data_model=AnswerWithThinking,\n        language_model=language_model,\n    )(x0)\n\n    program = synalinks.Program(\n        inputs=x0,\n        outputs=x1,\n        name=\"chain_of_thought\",\n        description=\"Useful to answer in a step by step manner.\",\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing a Chain of Thought Program with Synalinks Subclassing and Functional API\nDESCRIPTION: This snippet demonstrates how to create a program by subclassing from synalinks.Program while using the Functional API. It defines data models for input queries and answers with thinking, implements a ChainOfThought class, and shows how to initialize it with a language model.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    class ChainOfThought(synalinks.Program):\n        \"\"\"Useful to answer in a step by step manner.\"\"\"\n\n        def __init__(\n            self,\n            language_model=None,\n            name=None,\n            description=None,\n            trainable=True,\n        ):\n            super().__init__(\n                name=name,\n                description=description,\n                trainable=trainable,\n            )\n\n            self.language_model = language_model\n        \n        async def build(self, inputs):\n            outputs = await synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=self.language_model,\n            )(inputs)\n\n            # Create your program using the functional API\n            super().__init__(\n                inputs=inputs,\n                outputs=outputs,\n                name=self.name,\n                description=self.description,\n                trainable=self.trainable,\n            )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    program = ChainOfThought(\n        language_model=language_model,\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing LM Application using Program Subclassing\nDESCRIPTION: Example of creating a language model application by subclassing Synalinks' Program class. Shows implementation of initialization, call method, configuration management, and serialization support.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    class ChainOfThought(synalinks.Program):\n        \"\"\"Useful to answer in a step by step manner.\n        \n        The first line of the docstring is provided as description\n        for the program if not provided in the `super().__init__()`.\n        In a similar way the name is automatically infered based on\n        the class name if not provided.\n        \"\"\"\n\n        def __init__(\n            self,\n            language_model=None,\n            name=None,\n            description=None,\n            trainable=True,\n        ):\n            super().__init__(\n                name=name,\n                description=description,\n                trainable=trainable,\n            )\n            self.answer = synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=language_model,\n                name=self.name+\"_generator\",\n            )\n\n        async def call(self, inputs, training=False):\n            if not inputs:\n                return None\n            x = await self.answer(inputs, training=training)\n            return x\n\n        def get_config(self):\n            config = {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"trainable\": self.trainable,\n            }\n            language_model_config = \\\n            {\n                \"language_model\": synalinks.saving.serialize_synalinks_object(\n                    self.language_model\n                )\n            }\n            return {**config, **language_model_config}\n\n        @classmethod\n        def from_config(cls, config):\n            language_model = synalinks.saving.deserialize_synalinks_object(\n                config.pop(\"language_model\")\n            )\n            return cls(language_model=language_model, **config)\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    program = ChainOfThought(\n        language_model=language_model,\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Creating a Chain of Thought Program with Synalinks Sequential API\nDESCRIPTION: This snippet shows how to create a program using the Sequential API, which enables stacking single-input, single-output modules. It defines data models for input queries and answers with thinking, and creates a sequential program with Input and Generator modules.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    program = synalinks.Sequential(\n        [\n            synalinks.Input(\n                data_model=Query,\n            ),\n            synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=language_model,\n            ),\n        ],\n        name=\"chain_of_thought\",\n        description=\"Useful to answer in a step by step manner.\",\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Training a Synalinks Program in Python\nDESCRIPTION: Shows the process of compiling and training a Synalinks program using a dataset, including reward definition, optimizer selection, and fitting the model.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n\n    # ... your program definition\n\n    (x_train, y_train), (x_test, y_test) = synalinks.datasets.gsm8k.load_data()\n\n    program.compile(\n        reward=synalinks.rewards.ExactMatch(in_mask=[\"answer\"]),\n        optimizer=synalinks.optimizers.RandomFewShot()\n    )\n\n    batch_size=32\n    epochs=10\n\n    history = await program.fit(\n        x_train,\n        y_train,\n        validation_data=(x_test, y_test),\n        batch_size=batch_size,\n        epochs=epochs,\n    )\n\n    synalinks.utils.plot_history(history)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain of Thought by Subclassing Program in Python\nDESCRIPTION: Shows how to create a Chain of Thought program by subclassing Synalinks' Program class. It includes custom initialization, call method, and configuration handling.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    class ChainOfThought(synalinks.Program):\n        \"\"\"Useful to answer in a step by step manner.\n        \n        The first line of the docstring is provided as description\n        for the program if not provided in the `super().__init__()`.\n        In a similar way the name is automatically infered based on\n        the class name if not provided.\n        \"\"\"\n\n        def __init__(\n            self,\n            language_model=None,\n            name=None,\n            description=None,\n            trainable=True,\n        ):\n            super().__init__(\n                name=name,\n                description=description,\n                trainable=trainable,\n            )\n            self.answer = synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=language_model,\n                name=self.name+\"_generator\",\n            )\n\n        async def call(self, inputs, training=False):\n            if not inputs:\n                return None\n            x = await self.answer(inputs, training=training)\n            return x\n\n        def get_config(self):\n            config = {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"trainable\": self.trainable,\n            }\n            language_model_config = \\\n            {\n                \"language_model\": synalinks.saving.serialize_synalinks_object(\n                    self.language_model\n                )\n            }\n            return {**config, **language_model_config}\n\n        @classmethod\n        def from_config(cls, config):\n            language_model = synalinks.saving.deserialize_synalinks_object(\n                config.pop(\"language_model\")\n            )\n            return cls(language_model=language_model, **config)\n\n    language_model = synalinks.LanguageModel(model=\"ollama_chat/deepseek-r1\")\n\n    program = ChainOfThought(language_model=language_model)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing JSONDataModel Class in Python for SynaLinks Backend\nDESCRIPTION: This code defines a JSONDataModel class that serves as a base class for JSON-based data models in the SynaLinks backend. It provides methods for validation, conversion between different formats, and handling data attributes.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The JsonDataModel class.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Dict, List, Optional, Type, TypeVar, Union, get_type_hints\nimport json\nfrom pydantic import BaseModel, create_model, validator\nfrom pydantic.error_wrappers import ValidationError\nfrom functools import lru_cache\n\nT = TypeVar('T', bound='JSONDataModel')\n\nclass JSONDataModel:\n    \"\"\"Base class for JSON-compatible data models.\n    \n    This class provides methods for validating, converting, and manipulating\n    JSON data structures.\n    \"\"\"\n    \n    @classmethod\n    def get_pydantic_model(cls: Type[T]) -> Type[BaseModel]:\n        \"\"\"Get a Pydantic model for validating instances of this class.\n        \n        Returns:\n            A Pydantic model class.\n        \"\"\"\n        # Cache the created model to avoid recreating it each time\n        if not hasattr(cls, '_pydantic_model'):\n            # Get type hints for the class\n            hints = get_type_hints(cls)\n            # Create a new Pydantic model with the same field types\n            cls._pydantic_model = create_model(\n                cls.__name__, \n                **{field: (type_, ...) for field, type_ in hints.items()}\n            )\n        return cls._pydantic_model\n    \n    @classmethod\n    def from_dict(cls: Type[T], data: Dict[str, Any]) -> T:\n        \"\"\"Create an instance from a dictionary.\n        \n        Args:\n            data: A dictionary containing the model data.\n            \n        Returns:\n            An instance of this class.\n            \n        Raises:\n            ValidationError: If the data is invalid.\n        \"\"\"\n        # Validate the data using the Pydantic model\n        model = cls.get_pydantic_model().parse_obj(data)\n        # Create a new instance with the validated data\n        instance = cls()\n        for field, value in model.dict().items():\n            setattr(instance, field, value)\n        return instance\n    \n    @classmethod\n    def from_json(cls: Type[T], json_str: str) -> T:\n        \"\"\"Create an instance from a JSON string.\n        \n        Args:\n            json_str: A JSON string containing the model data.\n            \n        Returns:\n            An instance of this class.\n            \n        Raises:\n            ValidationError: If the data is invalid.\n            json.JSONDecodeError: If the JSON string is invalid.\n        \"\"\"\n        data = json.loads(json_str)\n        return cls.from_dict(data)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert this instance to a dictionary.\n        \n        Returns:\n            A dictionary containing the model data.\n        \"\"\"\n        # Get type hints for the class\n        hints = get_type_hints(self.__class__)\n        # Build a dictionary with all fields\n        return {field: getattr(self, field) for field in hints.keys() if hasattr(self, field)}\n    \n    def to_json(self) -> str:\n        \"\"\"Convert this instance to a JSON string.\n        \n        Returns:\n            A JSON string containing the model data.\n        \"\"\"\n        return json.dumps(self.to_dict())\n    \n    def validate(self) -> None:\n        \"\"\"Validate this instance.\n        \n        Raises:\n            ValidationError: If the instance is invalid.\n        \"\"\"\n        # Use the Pydantic model to validate the data\n        self.__class__.get_pydantic_model().parse_obj(self.to_dict())\n```\n\n----------------------------------------\n\nTITLE: Configuring Base Pydantic Model Settings in Python\nDESCRIPTION: Defines a common configuration class for Pydantic models to ensure consistent model validation and serialization behavior across the application. The configuration specifies case insensitivity during JSON schema generation and validation.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The Base DataModels.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: synalinks.src.backend.pydantic.base\n```\n\n----------------------------------------\n\nTITLE: Training a Synalinks Program with GSM8K Dataset\nDESCRIPTION: This snippet demonstrates how to train a Synalinks program using the GSM8K dataset. It shows the compilation process with reward and optimizer configuration, fitting the model with training data, and visualizing the training history.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n\n    # ... your program definition\n\n    (x_train, y_train), (x_test, y_test) = synalinks.datasets.gsm8k.load_data()\n\n    program.compile(\n        reward=synalinks.rewards.ExactMatch(in_mask=[\"answer\"]),\n        optimizer=synalinks.optimizers.RandomFewShot()\n    )\n\n    batch_size=32\n    epochs=10\n\n    history = await program.fit(\n        x_train,\n        y_train,\n        validation_data=(x_test, y_test),\n        batch_size=batch_size,\n        epochs=epochs,\n    )\n\n    synalinks.utils.plot_history(history)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing InputModule Class in Python for Synalinks\nDESCRIPTION: This code implements the InputModule class which is a core component for processing various types of input data in the Synalinks project. The module handles text, PDF, and binary data inputs, and provides methods for transforming them into standardized formats for further processing.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Input module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass InputModule:\n    \"\"\"Input module for processing various types of input data.\n    \n    This module handles text, PDF, and binary inputs and transforms them\n    into a standardized format for further processing.\n    \"\"\"\n    \n    def __init__(self, config=None):\n        \"\"\"Initialize the input module.\n        \n        Args:\n            config (dict, optional): Configuration parameters for the module.\n        \"\"\"\n        self.config = config or {}\n        self.default_encoding = self.config.get('encoding', 'utf-8')\n        \n    def process_text(self, text, encoding=None):\n        \"\"\"Process text input.\n        \n        Args:\n            text (str): The input text to process.\n            encoding (str, optional): Text encoding. Defaults to the configured default.\n            \n        Returns:\n            dict: Processed text data.\n        \"\"\"\n        encoding = encoding or self.default_encoding\n        return {\n            'type': 'text',\n            'content': text,\n            'encoding': encoding,\n            'metadata': {\n                'length': len(text),\n                'processed_at': datetime.now().isoformat()\n            }\n        }\n    \n    def process_file(self, file_path):\n        \"\"\"Process a file input.\n        \n        Args:\n            file_path (str): Path to the input file.\n            \n        Returns:\n            dict: Processed file data.\n        \"\"\"\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"Input file not found: {file_path}\")\n            \n        ext = os.path.splitext(file_path)[1].lower()\n        \n        if ext == '.pdf':\n            return self._process_pdf(file_path)\n        elif ext in ['.txt', '.md', '.csv', '.json']:\n            return self._process_text_file(file_path)\n        else:\n            return self._process_binary_file(file_path)\n    \n    def _process_pdf(self, file_path):\n        \"\"\"Process a PDF file.\n        \n        Args:\n            file_path (str): Path to the PDF file.\n            \n        Returns:\n            dict: Processed PDF data.\n        \"\"\"\n        # PDF processing implementation would go here\n        # For now, return a placeholder\n        return {\n            'type': 'pdf',\n            'file_path': file_path,\n            'content': \"PDF content would be extracted here\",\n            'metadata': {\n                'file_size': os.path.getsize(file_path),\n                'processed_at': datetime.now().isoformat()\n            }\n        }\n    \n    def _process_text_file(self, file_path):\n        \"\"\"Process a text-based file.\n        \n        Args:\n            file_path (str): Path to the text file.\n            \n        Returns:\n            dict: Processed text file data.\n        \"\"\"\n        with open(file_path, 'r', encoding=self.default_encoding) as f:\n            content = f.read()\n        \n        return {\n            'type': 'text_file',\n            'file_path': file_path,\n            'content': content,\n            'encoding': self.default_encoding,\n            'metadata': {\n                'file_size': os.path.getsize(file_path),\n                'processed_at': datetime.now().isoformat()\n            }\n        }\n    \n    def _process_binary_file(self, file_path):\n        \"\"\"Process a binary file.\n        \n        Args:\n            file_path (str): Path to the binary file.\n            \n        Returns:\n            dict: Processed binary file data.\n        \"\"\"\n        # For binary files, we just return metadata without the content\n        return {\n            'type': 'binary',\n            'file_path': file_path,\n            'metadata': {\n                'file_size': os.path.getsize(file_path),\n                'file_type': mimetypes.guess_type(file_path)[0] or 'application/octet-stream',\n                'processed_at': datetime.now().isoformat()\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing Logical OR Operation for Merging Statements in Python\nDESCRIPTION: This code snippet defines the logical_or function that merges two statements by removing redundant statements that are semantically equivalent. It handles multiple statement formats and ensures that contradictory statements are preserved in the merge operation.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Merging Modules/Or module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef logical_or(s1, s2):\n    \"\"\"Merge two statements by removing redundant statements that are semantically equivalent.\n\n    Args:\n        s1: First statement\n        s2: Second statement\n\n    Returns:\n        Merged statement\n    \"\"\"\n    # If both statements are strings, convert them to lists\n    if isinstance(s1, str) and isinstance(s2, str):\n        s1 = [s1]\n        s2 = [s2]\n\n    # If s1 is a string and s2 is a list, convert s1 to a list\n    if isinstance(s1, str) and isinstance(s2, list):\n        s1 = [s1]\n\n    # If s2 is a string and s1 is a list, convert s2 to a list\n    if isinstance(s2, str) and isinstance(s1, list):\n        s2 = [s2]\n\n    # Merge the two lists and remove redundant statements\n    merged = s1 + s2\n    non_redundant = []\n    for s in merged:\n        # Check if s is semantically equivalent to any statement in non_redundant\n        if not any(are_semantically_equivalent(s, nr) for nr in non_redundant):\n            non_redundant.append(s)\n\n    return non_redundant\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Class Recall in Python\nDESCRIPTION: This function calculates recall for multi-class classification. It takes a list of true positives and false negatives for each class and returns the average recall.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef multi_class_recall(true_positives: List[float], false_negatives: List[float]) -> float:\n    \"\"\"Calculate multi-class recall.\n\n    Args:\n        true_positives: List of true positives for each class.\n        false_negatives: List of false negatives for each class.\n\n    Returns:\n        Average recall across all classes.\n    \"\"\"\n    recalls = [recall(tp, fn) for tp, fn in zip(true_positives, false_negatives)]\n    return sum(recalls) / len(recalls) if recalls else 0.0\n```\n\n----------------------------------------\n\nTITLE: Calculating F-Score for Binary Classification in Python\nDESCRIPTION: This function calculates the F-score for binary classification. It takes precision and recall as inputs, along with an optional beta parameter, and returns the F-score.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef f_score(precision: float, recall: float, beta: float = 1.0) -> float:\n    \"\"\"Calculate F-score.\n\n    Args:\n        precision: Precision score.\n        recall: Recall score.\n        beta: Weight of precision in harmonic mean.\n\n    Returns:\n        F-score.\n    \"\"\"\n    return (1 + beta**2) * (precision * recall) / ((beta**2 * precision) + recall) if (precision + recall) > 0 else 0.0\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Trainable Module in Synalinks with Python\nDESCRIPTION: Demonstrates how to create a sequential program with two generators in Synalinks where the first generator is frozen (non-trainable) during training. Shows the distinction between trainable attributes and training mode.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class ThinkingWithAnswer(synalinks.DataModel):\n        thinking: str\n        answer: str\n\n    language_model = synalinks.LanguageModel(\n        \"ollama_chat/deepseek-r1\",\n    )\n\n    program = synalinks.Sequential(\n        [\n            synalinks.Generator(\n                data_model=ThinkingWithAnswer,\n                language_model=language_model,\n            ),\n            synalinks.Generator(\n                data_model=ThinkingWithAnswer,\n                language_model=language_model,\n            ),\n        ]\n    )\n\n    program.modules[0].trainable = False # Freeze the first generator\n\n    assert program.modules[0].trainable_variables == []\n\n    program.compile(...)\n    history = await program.fit(...) # Train only the second generator\n\nif __main__ == \"__name__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain of Thought using Functional API in Python\nDESCRIPTION: Demonstrates how to create a Chain of Thought program using Synalinks' Functional API. It defines data models, sets up a language model, and constructs a program structure.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    x0 = synalinks.Input(data_model=Query)\n    x1 = await synalinks.Generator(\n        data_model=AnswerWithThinking,\n        language_model=language_model,\n    )(x0)\n\n    program = synalinks.Program(\n        inputs=x0,\n        outputs=x1,\n        name=\"chain_of_thought\",\n        description=\"Useful to answer in a step by step manner.\",\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Calculating Root Mean Squared Error in Python\nDESCRIPTION: This function calculates the root mean squared error between true and predicted values. It utilizes the mean_squared_error function and returns the square root of the result.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Metric wrappers and reduction metrics.md#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef root_mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"Compute root mean squared error.\n\n    Args:\n        y_true: Ground truth target values.\n        y_pred: Estimated target values.\n\n    Returns:\n        Root mean squared error.\n    \"\"\"\n    return np.sqrt(mean_squared_error(y_true, y_pred))\n```\n\n----------------------------------------\n\nTITLE: Plotting Evaluation Metrics in Python for Synalinks\nDESCRIPTION: The plot_metrics function creates a bar plot to visualize various evaluation metrics such as accuracy, precision, recall, and F1-score. It uses matplotlib for plotting and saves the resulting figure to a specified file. The function can handle multiple sets of metrics for comparison.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Utilities/More plotting utilities.md#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef plot_metrics(metrics_list, labels, save_path):\n    metrics = ['accuracy', 'precision', 'recall', 'f1-score']\n    x = np.arange(len(metrics))\n    width = 0.35\n    fig, ax = plt.subplots(figsize=(10, 6))\n    for i, m in enumerate(metrics_list):\n        ax.bar(x + i*width/len(metrics_list), [m['accuracy'], m['precision'], m['recall'], m['f1-score']], width/len(metrics_list), label=labels[i])\n    ax.set_ylabel('Scores')\n    ax.set_title('Model Evaluation Metrics')\n    ax.set_xticks(x + width/2)\n    ax.set_xticklabels(metrics)\n    ax.legend()\n    plt.savefig(save_path)\n    plt.close()\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain of Thought using Mixed Subclassing and Functional API in Python\nDESCRIPTION: Demonstrates a hybrid approach to creating a Chain of Thought program, combining subclassing with the Functional API. This method focuses on initialization and build methods.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    class ChainOfThought(synalinks.Program):\n        \"\"\"Useful to answer in a step by step manner.\"\"\"\n\n        def __init__(\n            self,\n            language_model=None,\n            name=None,\n            description=None,\n            trainable=True,\n        ):\n            super().__init__(\n                name=name,\n                description=description,\n                trainable=trainable,\n            )\n\n            self.language_model = language_model\n        \n        async def build(self, inputs):\n            outputs = await synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=self.language_model,\n            )(inputs)\n\n            # Create your program using the functional API\n            super().__init__(\n                inputs=inputs,\n                outputs=outputs,\n                name=self.name,\n                description=self.description,\n                trainable=self.trainable,\n            )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    program = ChainOfThought(\n        language_model=language_model,\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Defining User and Organization Models in Python for Synalinks\nDESCRIPTION: This snippet defines the User and Organization models using SQLAlchemy ORM. It includes fields for basic user information, authentication details, and relationships between users and organizations.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Identity module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy import Column, Integer, String, Boolean, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom synalinks.src.modules.core.base import Base\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    organization_id = Column(Integer, ForeignKey('organizations.id'))\n    organization = relationship('Organization', back_populates='users')\n\nclass Organization(Base):\n    __tablename__ = 'organizations'\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    users = relationship('User', back_populates='organization')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Project Structure for Synalinks REST API\nDESCRIPTION: Displays the recommended project structure for a Synalinks-based REST API project, including backend, frontend, and scripts directories.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndemo/\n├── backend/\n│   ├── app/\n│   │   ├── checkpoint.program.json\n│   │   └── main.py\n│   ├── requirements.txt\n│   ├── Dockerfile\n├── frontend/\n│   └── ... (your frontend code)\n├── scripts/\n│   └── train.py (refer to the code examples to learn how to train programs)\n├── docker-compose.yml\n├── .env.backend\n└── README.md\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain of Thought using Sequential API in Python\nDESCRIPTION: Shows how to create a Chain of Thought program using Synalinks' Sequential API, which is suitable for programs with a linear structure of single-input, single-output modules.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking process\",\n        )\n        answer: float = synalinks.Field(\n            description=\"The correct numerical answer\",\n        )\n\n    language_model = synalinks.LanguageModel(\n        model=\"ollama_chat/deepseek-r1\",\n    )\n\n    program = synalinks.Sequential(\n        [\n            synalinks.Input(\n                data_model=Query,\n            ),\n            synalinks.Generator(\n                data_model=AnswerWithThinking,\n                language_model=language_model,\n            ),\n        ],\n        name=\"chain_of_thought\",\n        description=\"Useful to answer in a step by step manner.\",\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Converting Dictionary to JSON String in Python\nDESCRIPTION: A function that converts a Python dictionary to a JSON string with specified indentation. It handles converting Python types to JSON-compatible formats with optional indentation for better readability.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Ops API/JSON Ops.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom json import dumps\nfrom typing import Dict, Any\n\n\ndef to_json(data: Dict[str, Any], indent: int = 4) -> str:\n    \"\"\"Convert a dictionary to a JSON string.\n\n    Args:\n        data: Dictionary to convert.\n        indent: Indentation level for the JSON string.\n\n    Returns:\n        JSON string.\n    \"\"\"\n    return dumps(data, indent=indent)\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON String to Dictionary in Python\nDESCRIPTION: A function that converts a JSON string back to a Python dictionary. It provides the reverse operation of to_json, allowing JSON data to be parsed into Python objects.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Ops API/JSON Ops.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom json import loads\nfrom typing import Dict, Any\n\n\ndef from_json(data: str) -> Dict[str, Any]:\n    \"\"\"Convert a JSON string to a dictionary.\n\n    Args:\n        data: JSON string to convert.\n\n    Returns:\n        Dictionary.\n    \"\"\"\n    return loads(data)\n```\n\n----------------------------------------\n\nTITLE: Defining Module Class for Synalinks in Python\nDESCRIPTION: This code snippet defines the Module class, which is a core component of the Synalinks project. It includes methods for initialization, configuration, and module management.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Base Module class.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Module:\n    def __init__(self, name: str, config: dict = None):\n        self.name = name\n        self.config = config or {}\n        self.submodules = {}\n\n    def configure(self, config: dict):\n        self.config.update(config)\n\n    def add_submodule(self, name: str, module: 'Module'):\n        self.submodules[name] = module\n\n    def get_submodule(self, name: str) -> 'Module':\n        return self.submodules.get(name)\n\n    def remove_submodule(self, name: str):\n        self.submodules.pop(name, None)\n\n    def __repr__(self):\n        return f\"<Module '{self.name}'>\"\n```\n\n----------------------------------------\n\nTITLE: Loading GSM8K Dataset in Python\nDESCRIPTION: Function that loads the GSM8K dataset from the specified directory. It returns a dataset object with organized examples of math word problems and solutions.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Built-in Datasets/GSM8K.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef load_gsm8k(\n    path: Optional[str] = None,\n    train_path: Optional[str] = None,\n    test_path: Optional[str] = None,\n) -> dict:\n    \"\"\"Load the GSM8K dataset.\n\n    Args:\n        path: Path to directory containing gsm8k jsonl files.\n        train_path: Path to train file. Overrides path.\n        test_path: Path to test file. Overrides path.\n\n    Returns:\n        Dict with keys 'train', 'test', each containing a dataset.\n    \"\"\"\n    dataset = {}\n\n    if path is None:\n        path = \"~/data/gsm8k\"\n    path = os.path.expanduser(path)\n\n    if train_path is None:\n        train_path = os.path.join(path, \"train.jsonl\")\n    if test_path is None:\n        test_path = os.path.join(path, \"test.jsonl\")\n\n    dataset[\"train\"] = TextDataset()\n    dataset[\"train\"].from_jsonl(train_path, GSM8KExample)\n\n    dataset[\"test\"] = TextDataset()\n    dataset[\"test\"].from_jsonl(test_path, GSM8KExample)\n\n    return dataset\n```\n\n----------------------------------------\n\nTITLE: Aligning GSM8K Dataset with Python\nDESCRIPTION: Function that aligns the GSM8K dataset from JSON format to a format suitable for processing. It creates examples with questions and answers from the provided JSON data.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Built-in Datasets/GSM8K.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef align_gsm8k(data: List[dict]) -> List[dict]:\n    \"\"\"Align GSM8K dataset.\n\n    Args:\n        data: List of GSM8K examples as dicts.\n\n    Returns:\n        List of examples.\n    \"\"\"\n    examples = []\n    for d in data:\n        examples.append(GSM8KExample(question=d[\"question\"], answer=d[\"answer\"]))\n    return examples\n```\n\n----------------------------------------\n\nTITLE: Implementing FastAPI Endpoint with Synalinks and OpenTelemetry\nDESCRIPTION: Python code for creating a FastAPI application that serves a Synalinks program as a chat completion API endpoint. Includes OpenTelemetry integration with Arize Phoenix for observability.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport logging\nimport os\nimport uvicorn\nfrom dotenv import load_dotenv\nfrom fastapi import FastAPI\n\nimport synalinks\n\n# Import open-telemetry dependencies\nfrom arize.otel import register\nfrom openinference.instrumentation.litellm import LiteLLMInstrumentor\n\n# Load the environment variables\nload_dotenv()\n\n# Setup OTel via Arize Phoenix convenience function\ntracer_provider = register(\n    space_id = os.environ[\"ARIZE_SPACE_ID\"], # in app space settings page\n    api_key = os.environ[\"ARIZE_API_KEY\"], # in app space settings page\n    project_name = os.environ[\"ARIZE_PROJECT_NAME\"], # name this to whatever you would like\n)\n\nLiteLLMInstrumentor().instrument(tracer_provider=tracer_provider)\n\n# Set up logging\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",\n)\n# Set up FastAPI\napp = FastAPI()\n\n# The dictionary mapping the name of your custom modules to their class\ncustom_modules = {}\n\n# Load your program\nprogram = synalinks.Program.load(\n    \"checkpoint.program.json\",\n    custom_modules=custom_modules,\n)\n\n@app.post(\"/v1/chat_completion\")\nasync def chat_completion(messages: synalinks.ChatMessages):\n    logger.info(messages.pretty_json())\n    try:\n        result = await program(messages)\n        if result:\n            logger.info(result.prettify_json())\n            return result.get_json()\n        else:\n            return None\n    except Exception as e:\n        logger.error(f\"Error occured: {str(e)}\")\n        return None\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--host\", type=str, default=\"127.0.0.1\")\n    parser.add_argument(\"--port\", type=int, default=8000)\n    args = parser.parse_args()\n    uvicorn.run(app, host=args.host, port=args.port)\n```\n\n----------------------------------------\n\nTITLE: Calculating Precision for Binary Classification in Python\nDESCRIPTION: This function calculates precision for binary classification. It takes true positives and false positives as inputs and returns the precision score.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef precision(true_positives: float, false_positives: float) -> float:\n    \"\"\"Calculate precision.\n\n    Args:\n        true_positives: Number of true positives.\n        false_positives: Number of false positives.\n\n    Returns:\n        Precision score.\n    \"\"\"\n    return true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0.0\n```\n\n----------------------------------------\n\nTITLE: Calculating Recall for Binary Classification in Python\nDESCRIPTION: This function calculates recall for binary classification. It takes true positives and false negatives as inputs and returns the recall score.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef recall(true_positives: float, false_negatives: float) -> float:\n    \"\"\"Calculate recall.\n\n    Args:\n        true_positives: Number of true positives.\n        false_negatives: Number of false negatives.\n\n    Returns:\n        Recall score.\n    \"\"\"\n    return true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0.0\n```\n\n----------------------------------------\n\nTITLE: Defining Base Action Class in Python\nDESCRIPTION: Implementation of the core Action class that provides the foundation for all actions in the SynaLinks system. It includes methods for initialization, validation, and execution of actions.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Action module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Action:\n    def __init__(self, action_id=None, action_type=None, condition=None, action_data=None):\n        self.action_id = action_id\n        self.action_type = action_type\n        self.condition = condition\n        self.action_data = action_data if action_data is not None else {}\n\n    def validate(self):\n        \"\"\"Validate if the action is properly configured.\"\"\"\n        if not self.action_type:\n            return False\n        return True\n\n    def execute(self, context):\n        \"\"\"Execute the action based on the provided context.\"\"\"\n        if self.condition and not self._evaluate_condition(context):\n            return None\n        return self._execute_internal(context)\n\n    def _execute_internal(self, context):\n        \"\"\"Internal execution method to be overridden by subclasses.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement _execute_internal\")\n\n    def _evaluate_condition(self, context):\n        \"\"\"Evaluate if the condition for this action is met.\"\"\"\n        # Simplified condition evaluation\n        if not self.condition:\n            return True\n        # Here would be the actual condition evaluation logic\n        return True\n\n    def to_dict(self):\n        \"\"\"Convert action to dictionary representation.\"\"\"\n        return {\n            \"action_id\": self.action_id,\n            \"action_type\": self.action_type,\n            \"condition\": self.condition,\n            \"action_data\": self.action_data\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create an action from dictionary representation.\"\"\"\n        return cls(\n            action_id=data.get(\"action_id\"),\n            action_type=data.get(\"action_type\"),\n            condition=data.get(\"condition\"),\n            action_data=data.get(\"action_data\")\n        )\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Class Precision in Python\nDESCRIPTION: This function calculates precision for multi-class classification. It takes a list of true positives and false positives for each class and returns the average precision.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef multi_class_precision(true_positives: List[float], false_positives: List[float]) -> float:\n    \"\"\"Calculate multi-class precision.\n\n    Args:\n        true_positives: List of true positives for each class.\n        false_positives: List of false positives for each class.\n\n    Returns:\n        Average precision across all classes.\n    \"\"\"\n    precisions = [precision(tp, fp) for tp, fp in zip(true_positives, false_positives)]\n    return sum(precisions) / len(precisions) if precisions else 0.0\n```\n\n----------------------------------------\n\nTITLE: Running a Synalinks Program with Input Query\nDESCRIPTION: This snippet shows how to execute a Synalinks program by passing an input query and awaiting the result. The example uses a Query data model to structure the input.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nresult = await program(\n    Query(query=\"What is the French city of aerospace?\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using a Synalinks Generator Module in Python\nDESCRIPTION: This code snippet demonstrates how to set up and use a Synalinks Generator module. It defines data models for input and output, initializes a language model and a generator, and processes a query asynchronously.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/index.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    class Query(synalinks.DataModel):\n        query: str = synalinks.Field(\n            description=\"The user query\",\n        )\n\n    class AnswerWithThinking(synalinks.DataModel):\n        thinking: str = synalinks.Field(\n            description=\"Your step by step thinking\",\n        )\n        answer: str = synalinks.Field(\n            description=\"The correct answer\",\n        )\n\n    language_model = LanguageModel(\"ollama_chat/deepseek-r1\")\n\n    generator = synalinks.Generator(\n        data_model=AnswerWithThinking,\n        language_model=language_model,\n    )\n\n    inputs = Query(query=\"What is the capital of France?\")\n    outputs = await generator(inputs)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Generating Program Summary in Python\nDESCRIPTION: Code snippets to generate a tabular summary and a plot of the Synalinks program structure.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprogram.summary()\n```\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.utils.plot_program(\n    program,\n    show_module_names=True,\n    show_trainable=True,\n    show_schemas=True,\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Symbolic Constant Class in Python\nDESCRIPTION: This class represents a constant value in the symbolic data model. It inherits from SymbolicExpression and provides implementation for evaluation and simplification.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass Constant(SymbolicExpression):\n    def __init__(self, value):\n        self.value = value\n\n    def evaluate(self, context=None):\n        return self.value\n\n    def simplify(self):\n        return self\n```\n\n----------------------------------------\n\nTITLE: Running Arize Phoenix Server\nDESCRIPTION: This command runs the Arize Phoenix server in a Docker container, mapping the necessary ports for web interface and telemetry data.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Enabling LM Tracing.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -p 6006:6006 -p 4317:4317 -i -t arizephoenix/phoenix:latest\n```\n\n----------------------------------------\n\nTITLE: Implementing a Multiple-Choice LM Judge for Answer Evaluation in Python\nDESCRIPTION: A concrete implementation of LMJudge that evaluates answers by selecting from multiple options. It handles formatting inputs with multiple choices and processes model outputs to determine the selected option.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Rewards/LMAsJudge reward.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MultipleChoiceLMJudge(LMJudge):\n    def __init__(self, model, tokenizer, choices):\n        super().__init__(model, tokenizer)\n        self.choices = choices  # e.g., [\"A\", \"B\", \"C\", \"D\"]\n    \n    def judge(self, question, reference_answer, system_answer):\n        inputs = self.prepare_inputs(question, reference_answer, system_answer)\n        outputs = self.model(**inputs)\n        result = self.process_outputs(outputs)\n        return result\n    \n    def prepare_inputs(self, question, reference_answer, system_answer):\n        choices_text = \"\\n\".join([f\"{choice}: {desc}\" for choice, desc in self.choices.items()])\n        prompt = f\"Question: {question}\\nReference Answer: {reference_answer}\\nSystem Answer: {system_answer}\\n\\nChoose the option that best describes the system answer:\\n{choices_text}\\nSelected option:\"\n        inputs = self.tokenizer(prompt, return_tensors=\"pt\")\n        return inputs\n    \n    def process_outputs(self, outputs):\n        # Map model output to one of the choices\n        # This is a simplified implementation\n        logits = outputs.logits\n        predicted_token_id = logits[0, -1].argmax().item()\n        predicted_token = self.tokenizer.decode(predicted_token_id)\n        \n        # Match the predicted token to one of the choices\n        for choice in self.choices:\n            if choice.lower() in predicted_token.lower():\n                return choice\n        \n        # Default return if no match found\n        return list(self.choices.keys())[0]\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Operation Class in Python\nDESCRIPTION: This abstract class represents binary operations in the symbolic data model. It provides a framework for implementing specific binary operations and includes methods for evaluation and simplification.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass BinaryOperation(SymbolicExpression):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    @abstractmethod\n    def _operate(self, left, right):\n        pass\n\n    def evaluate(self, context=None):\n        left_value = self.left.evaluate(context)\n        right_value = self.right.evaluate(context)\n        return self._operate(left_value, right_value)\n\n    def simplify(self):\n        simplified_left = self.left.simplify()\n        simplified_right = self.right.simplify()\n        if isinstance(simplified_left, Constant) and isinstance(simplified_right, Constant):\n            return Constant(self._operate(simplified_left.value, simplified_right.value))\n        return self.__class__(simplified_left, simplified_right)\n```\n\n----------------------------------------\n\nTITLE: Importing Language Model Module\nDESCRIPTION: Import statement showing the module path for the language models component in the Synalinks project.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Language Models API.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.src.language_models.language_model\n```\n\n----------------------------------------\n\nTITLE: Implementing a Multi-Scale LM Judge for Detailed Answer Evaluation in Python\nDESCRIPTION: A concrete implementation of LMJudge that evaluates answers on multiple scales or criteria. It formats inputs with multiple evaluation dimensions and processes model outputs to extract scores for each dimension.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Rewards/LMAsJudge reward.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MultiScaleLMJudge(LMJudge):\n    def __init__(self, model, tokenizer, scales):\n        super().__init__(model, tokenizer)\n        self.scales = scales  # e.g., {\"relevance\": [1, 2, 3, 4, 5], \"correctness\": [1, 2, 3, 4, 5]}\n    \n    def judge(self, question, reference_answer, system_answer):\n        results = {}\n        \n        # Evaluate on each scale\n        for scale_name, scale_values in self.scales.items():\n            inputs = self.prepare_inputs(question, reference_answer, system_answer, scale_name, scale_values)\n            outputs = self.model(**inputs)\n            results[scale_name] = self.process_outputs(outputs, scale_values)\n        \n        return results\n    \n    def prepare_inputs(self, question, reference_answer, system_answer, scale_name, scale_values):\n        scale_description = f\"Rate the {scale_name} on a scale of {min(scale_values)} to {max(scale_values)}\"\n        prompt = f\"Question: {question}\\nReference Answer: {reference_answer}\\nSystem Answer: {system_answer}\\n\\n{scale_description}\\nRating:\"\n        inputs = self.tokenizer(prompt, return_tensors=\"pt\")\n        return inputs\n    \n    def process_outputs(self, outputs, scale_values):\n        # Extract the predicted rating from model output\n        logits = outputs.logits\n        predicted_token_id = logits[0, -1].argmax().item()\n        predicted_token = self.tokenizer.decode(predicted_token_id)\n        \n        # Try to convert to integer and match with scale values\n        try:\n            rating = int(predicted_token.strip())\n            if rating in scale_values:\n                return rating\n            else:\n                # Return closest value in scale\n                return min(scale_values, key=lambda x: abs(x - rating))\n        except:\n            # Default to middle of scale if conversion fails\n            return scale_values[len(scale_values) // 2]\n```\n\n----------------------------------------\n\nTITLE: Implementing Addition Operation Class in Python\nDESCRIPTION: This class represents the addition operation in the symbolic data model. It inherits from BinaryOperation and provides specific implementation for addition.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nclass Addition(BinaryOperation):\n    def _operate(self, left, right):\n        return left + right\n```\n\n----------------------------------------\n\nTITLE: Implementing an Abstract Base Class for LM-based Judges in Python\nDESCRIPTION: Defines an abstract base class for language model-based judges that evaluate answer quality. The class includes abstract methods for judgment and helper methods for processing inputs.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Rewards/LMAsJudge reward.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass LMJudge(ABC):\n    def __init__(self, model, tokenizer):\n        self.model = model\n        self.tokenizer = tokenizer\n    \n    @abstractmethod\n    def judge(self, question, reference_answer, system_answer):\n        pass\n    \n    def prepare_inputs(self, question, reference_answer, system_answer):\n        \"\"\"Prepare inputs in a format suitable for the judge.\"\"\"\n        pass\n    \n    def process_outputs(self, outputs):\n        \"\"\"Process outputs from the model.\"\"\"\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining Optimizer Abstract Base Class in Python\nDESCRIPTION: Creates an abstract base class for optimization algorithms with abstract methods for optimization functionality. The class requires implementations to provide initialize, optimize, and update_parameters methods.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Optimizers API/Base Optimizer class.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Optimizer(ABC):\n    \"\"\"Base class for optimization algorithms.\"\"\"\n\n    @abstractmethod\n    def initialize(self, **kwargs):\n        \"\"\"Initialize the optimizer.\n\n        Parameters\n        ----------\n        **kwargs\n            Optimizer parameters.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def optimize(self, **kwargs):\n        \"\"\"Run the optimization.\n\n        Parameters\n        ----------\n        **kwargs\n            Parameters for the optimization.\n\n        Returns\n        -------\n        dict\n            Results of the optimization.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_parameters(self, **kwargs):\n        \"\"\"Update the optimization parameters. This method is used for updating\n        the optimization parameters during the optimization process.\n\n        Parameters\n        ----------\n        **kwargs\n            New parameters.\n        \"\"\"\n        pass\n```\n\n----------------------------------------\n\nTITLE: Configuring LM Tracing in Python Script\nDESCRIPTION: This Python code snippet sets up LM tracing by importing required dependencies, registering with Arize Phoenix, and instrumenting LiteLLM. It requires space_id, api_key, and project_name to be configured.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Enabling LM Tracing.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Import open-telemetry dependencies\nfrom arize.otel import register\nfrom openinference.instrumentation.litellm import LiteLLMInstrumentor\n\n# Setup OTel via Arize Phoenix convenience function\ntracer_provider = register(\n    space_id = \"your-space-id\", # in app space settings page\n    api_key = \"your-api-key\", # in app space settings page\n    project_name = \"your-project-name\", # name this to whatever you would like\n)\n\nLiteLLMInstrumentor().instrument(tracer_provider=tracer_provider)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Binary LM Judge for Answer Quality Assessment in Python\nDESCRIPTION: A concrete implementation of LMJudge that makes binary judgments (correct/incorrect) on answer quality. It prepares inputs in a specific format and processes model outputs to extract binary decisions.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Rewards/LMAsJudge reward.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass BinaryLMJudge(LMJudge):\n    def __init__(self, model, tokenizer):\n        super().__init__(model, tokenizer)\n    \n    def judge(self, question, reference_answer, system_answer):\n        inputs = self.prepare_inputs(question, reference_answer, system_answer)\n        # Call model to get prediction\n        outputs = self.model(**inputs)\n        result = self.process_outputs(outputs)\n        return result\n    \n    def prepare_inputs(self, question, reference_answer, system_answer):\n        prompt = f\"Question: {question}\\nReference Answer: {reference_answer}\\nSystem Answer: {system_answer}\\nIs the system answer correct? (Yes/No)\"\n        inputs = self.tokenizer(prompt, return_tensors=\"pt\")\n        return inputs\n    \n    def process_outputs(self, outputs):\n        # Extract predicted token and map to binary decision\n        # This is a simplified version\n        logits = outputs.logits\n        predicted_token_id = logits[0, -1].argmax().item()\n        predicted_token = self.tokenizer.decode(predicted_token_id)\n        \n        if predicted_token.lower() == \"yes\":\n            return True\n        else:\n            return False\n```\n\n----------------------------------------\n\nTITLE: Defining the Metric Abstract Base Class in Python\nDESCRIPTION: Implementation of an abstract base class for metrics that compute similarity between vectors. It includes abstract methods that must be implemented by subclasses and provides batch processing functionality.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Base Metric class.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\n\nimport numpy as np\n\n\nclass Metric(ABC):\n    \"\"\"An abstract base class for metrics that compute the distance or similarity between vectors.\"\"\"\n\n    @abstractmethod\n    def compute(self, u: np.ndarray, v: np.ndarray) -> float:\n        \"\"\"Compute the metric between two vectors.\n\n        Args:\n            u: The first vector.\n            v: The second vector.\n\n        Returns:\n            The computed metric.\n        \"\"\"\n        raise NotImplementedError(\n            \"Subclasses must implement the compute method.\"\n        )\n\n    def batch_compute(\n        self, u: np.ndarray, v: Union[np.ndarray, List[np.ndarray]]\n    ) -> np.ndarray:\n        \"\"\"Compute the metric between u and each vector in v.\n\n        Args:\n            u: The first vector.\n            v: A matrix where each row is a vector, or a list of vectors.\n\n        Returns:\n            An array of computed metrics.\n        \"\"\"\n        if isinstance(v, list):\n            return np.array([self.compute(u, vi) for vi in v])\n        return np.array([self.compute(u, vi) for vi in v])\n```\n\n----------------------------------------\n\nTITLE: Synalinks Default Directory Structure in Bash\nDESCRIPTION: Shows the default directory path where Synalinks stores configuration files and downloaded datasets. Includes the primary location in the user's home directory and the backup location in case of permission issues.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$HOME/.synalinks/\n```\n\n----------------------------------------\n\nTITLE: Implementing ArcaGIDataset Class in Python for Synalinks\nDESCRIPTION: Defines the ArcaGIDataset class which extends a base dataset class to work with ArcaGI data. It sets up dataset-specific properties including context length, tokenizer configuration, and data formatting options.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Built-in Datasets/ARC-AGI.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom ...utils.registry import register_dataset\nfrom ..base_dataset import BaseDataset\n\n\n@register_dataset\nclass ArcaGIDataset(BaseDataset):\n    \"\"\"ArcaGI dataset.\"\"\"\n\n    def __init__(\n        self,\n        data_path: Optional[str] = None,\n        context_length: Optional[int] = 2048,\n        end_of_human_token: Optional[str] = \"<|endofhuman|>\",\n        end_of_assistant_token: Optional[str] = \"<|endofassistant|>\",\n        human_prefix: Optional[str] = \"Human: \",\n        assistant_prefix: Optional[str] = \"Assistant: \",\n        extra_msg_prefix: Optional[str] = None,\n        **kwargs,\n    ):\n        super().__init__(\n            data_path=data_path,\n            context_length=context_length,\n            end_of_human_token=end_of_human_token,\n            end_of_assistant_token=end_of_assistant_token,\n            human_prefix=human_prefix,\n            assistant_prefix=assistant_prefix,\n            **kwargs,\n        )\n\n    def preprocess(\n        self,\n        dialog: List[Dict[str, str]],\n        **kwargs,\n    ) -> List[Dict[str, str]]:\n        \"\"\"Preprocess a dialog.\"\"\"\n        for msg in dialog:\n            msg[\"content\"] = msg[\"content\"].strip()\n        return dialog\n\n    def standardize_dialog(\n        self,\n        dialog: List[Dict[str, str]],\n        **kwargs,\n    ) -> List[Dict[str, str]]:\n        \"\"\"Standardize a dialog to follow the format: human, assistant, human, assistant, ...\"\"\"\n        return dialog\n\n    def standardize_roles(\n        self,\n        dialog: List[Dict[str, str]],\n        **kwargs,\n    ) -> List[Dict[str, str]]:\n        \"\"\"Standardize the roles of a dialog to follow the format: human, assistant, human, assistant, ...\"\"\"\n        return dialog\n```\n\n----------------------------------------\n\nTITLE: Defining Variable Class in Python for Synalinks Backend\nDESCRIPTION: This code snippet defines the Variable class used in the Synalinks backend. It includes properties for name, type, and value, as well as methods for serialization and deserialization. The class is designed to handle different variable types and provides functionality for converting between internal representations and JSON-compatible formats.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The Variable class.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Variable:\n    \"\"\"Represents a variable in the system.\"\"\"\n\n    def __init__(self, name: str, type: str, value: Any):\n        self.name = name\n        self.type = type\n        self.value = value\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert the variable to a dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"type\": self.type,\n            \"value\": self.value,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"Variable\":\n        \"\"\"Create a Variable instance from a dictionary.\"\"\"\n        return cls(\n            name=data[\"name\"],\n            type=data[\"type\"],\n            value=data[\"value\"],\n        )\n\n    def __repr__(self) -> str:\n        return f\"Variable(name={self.name}, type={self.type}, value={self.value})\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Callbacks in Synalinks Training Program\nDESCRIPTION: Example demonstrating how to use callbacks with the .fit() method in a Synalinks program. Shows implementation of CSVLogger for logging training metrics and ProgramCheckpoint for saving model checkpoints during training.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/index.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport synalinks\nimport asyncio\n\nasync def main():\n    # ... you program declaration here\n\n    callbacks = [\n        synalinks.callbacks.CSVLogger(filepath=\"training_log.csv\"),\n        synalinks.callbacks.ProgramCheckpoint(\n            filepath=\"program.{epoch:02d}-{val_loss:.2f}.json\"\n        ),\n    ]\n\n    history = await program.fit(\n        x=x_train,\n        y=y_train,\n        epochs=10,\n        callbacks=callbacks,\n    )\n\nif __main__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Launching Synalinks REST API with Docker Compose\nDESCRIPTION: Shell commands for starting the Synalinks backend using Docker Compose. After execution, the API will be available at http://0.0.0.0:8000/docs for testing.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd demo\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Symbolic Expression Class in Python\nDESCRIPTION: This snippet defines an abstract base class 'SymbolicExpression' that serves as the foundation for all symbolic expressions in the system. It includes abstract methods for evaluating and simplifying expressions.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom abc import ABC, abstractmethod\n\nclass SymbolicExpression(ABC):\n    @abstractmethod\n    def evaluate(self, context=None):\n        pass\n\n    @abstractmethod\n    def simplify(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Logical XOR Operation in Python for SynaLinks Merging\nDESCRIPTION: This code snippet defines a logical_xor function that performs an exclusive OR operation. It takes two boolean values as input and returns the XOR result. This operation is likely used in merging algorithms within the SynaLinks project.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Merging Modules/Xor module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef logical_xor(a: bool, b: bool) -> bool:\n    return (a or b) and not (a and b)\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Absolute Error in Python\nDESCRIPTION: This function computes the mean absolute error between true and predicted values. It takes two arrays as input and returns a float value representing the average absolute difference between corresponding elements.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Metric wrappers and reduction metrics.md#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef mean_absolute_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"Compute mean absolute error.\n\n    Args:\n        y_true: Ground truth target values.\n        y_pred: Estimated target values.\n\n    Returns:\n        Mean absolute error.\n    \"\"\"\n    return np.mean(np.abs(y_true - y_pred))\n```\n\n----------------------------------------\n\nTITLE: Saving Synalinks Program to JSON File in Python\nDESCRIPTION: This method saves a Synalinks program object to a JSON file. It takes a filename as input and writes the program's data to the specified file in JSON format.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Programs API/Program Saving API/Program saving and loading.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.src.programs.program.Program.save\n```\n\n----------------------------------------\n\nTITLE: Defining EmbeddingModel Class in Python for Text Encoding and Similarity Computation\nDESCRIPTION: This code snippet defines the EmbeddingModel class, which serves as an interface for embedding models. It includes methods for encoding text into embeddings and computing cosine similarity between embeddings. The class is designed to be subclassed by specific embedding model implementations.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Embedding Models API.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass EmbeddingModel:\n    \"\"\"Interface for embedding models.\"\"\"\n\n    def encode(self, text: str) -> List[float]:\n        \"\"\"Encode text into embeddings.\n\n        Args:\n            text: The text to encode.\n\n        Returns:\n            A list of floats representing the embedding.\n        \"\"\"\n        raise NotImplementedError\n\n    def cosine_similarity(self, embedding1: List[float], embedding2: List[float]) -> float:\n        \"\"\"Compute cosine similarity between two embeddings.\n\n        Args:\n            embedding1: The first embedding.\n            embedding2: The second embedding.\n\n        Returns:\n            The cosine similarity between the two embeddings.\n        \"\"\"\n        dot_product = sum(a * b for a, b in zip(embedding1, embedding2))\n        magnitude1 = math.sqrt(sum(a * a for a in embedding1))\n        magnitude2 = math.sqrt(sum(b * b for b in embedding2))\n        return dot_product / (magnitude1 * magnitude2)\n```\n\n----------------------------------------\n\nTITLE: Installing Synalinks using uv\nDESCRIPTION: Commands to install Synalinks and initialize a new project using the uv package manager.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuv pip install synalinks\n```\n\nLANGUAGE: shell\nCODE:\n```\nuv run synalinks init\n```\n\n----------------------------------------\n\nTITLE: Serializing Synalinks Program to JSON String in Python\nDESCRIPTION: This method converts a Synalinks program object to a JSON string representation. It serializes the program's data into a JSON-formatted string, which can be used for data transfer or storage.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Programs API/Program Saving API/Program saving and loading.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.src.programs.program.Program.to_json\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiplication Operation Class in Python\nDESCRIPTION: This class represents the multiplication operation in the symbolic data model. It inherits from BinaryOperation and provides specific implementation for multiplication.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass Multiplication(BinaryOperation):\n    def _operate(self, left, right):\n        return left * right\n```\n\n----------------------------------------\n\nTITLE: Implementing CSVLogger Class for Synalinks in Python\nDESCRIPTION: This code defines the CSVLogger class, which inherits from BaseCallback. It initializes with a file path and optional append mode. The class manages a CSV file for logging training metrics, handling file creation, writing headers, and appending data rows.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/CSVLogger.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport csv\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nfrom synalinks.src.callbacks.base import BaseCallback\n\n\nclass CSVLogger(BaseCallback):\n    def __init__(self, filepath: str, append: bool = False):\n        super().__init__()\n        self.filepath = Path(filepath)\n        self.append = append\n        self.file = None\n        self.writer = None\n        self.keys = None\n\n    def on_train_begin(self, logs: Dict[str, Any] = None) -> None:\n        if self.append:\n            self.file = open(self.filepath, 'a')\n        else:\n            self.file = open(self.filepath, 'w')\n        self.keys = sorted(logs.keys())\n        self.writer = csv.DictWriter(self.file, fieldnames=['epoch'] + self.keys)\n        if self.file.tell() == 0:\n            self.writer.writeheader()\n\n    def on_epoch_end(self, epoch: int, logs: Dict[str, Any] = None) -> None:\n        if self.writer is None:\n            self.keys = sorted(logs.keys())\n            self.writer = csv.DictWriter(self.file,\n                                         fieldnames=['epoch'] + self.keys)\n            self.writer.writeheader()\n        row_dict = {'epoch': epoch}\n        row_dict.update((key, logs[key]) for key in self.keys)\n        self.writer.writerow(row_dict)\n        self.file.flush()\n\n    def on_train_end(self, logs: Dict[str, Any] = None) -> None:\n        self.file.close()\n        self.writer = None\n```\n\n----------------------------------------\n\nTITLE: Loading Synalinks Program from JSON File in Python\nDESCRIPTION: This method loads a Synalinks program from a JSON file. It takes a filename as input, reads the JSON data from the file, and constructs a Program object from the deserialized data.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Programs API/Program Saving API/Program saving and loading.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.src.programs.program.Program.load\n```\n\n----------------------------------------\n\nTITLE: Comparing Keras predict() vs __call__() methods\nDESCRIPTION: The predict() method processes data in batches and returns a NumPy array of predictions for multiple inputs. The __call__() method (accessed as program(x)) performs a single prediction and is designed for API endpoints handling one request at a time.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npredict(x, batch_size=64)\n```\n\nLANGUAGE: python\nCODE:\n```\nprogram(x)\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph from Python Source Files in Python\nDESCRIPTION: Creates a Graphviz Digraph representation of function calls from Python source files. It processes files specified by file paths, extracts function definitions and calls, and visualizes them as a connected graph.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Utilities/Program plotting utilities.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef generate_call_graph(file_paths, output_path=\"call_graph\", format=\"png\"):\n    \"\"\"\n    Generate a call graph from a list of Python source files.\n    \n    Args:\n        file_paths (list): List of paths to Python source files.\n        output_path (str): Path to save the output graph.\n        format (str): Format of the output graph (e.g., \"png\", \"pdf\").\n    \n    Returns:\n        graphviz.Digraph: The generated call graph.\n    \"\"\"\n    # Create a directed graph\n    dot = Digraph(comment=\"Call Graph\")\n    dot.attr(rankdir=\"TB\")\n    dot.attr(\"node\", shape=\"box\", style=\"filled\", color=\"lightblue\")\n    \n    # Dictionary to store function definitions\n    function_defs = {}\n    \n    # Parse all files to extract function definitions\n    for file_path in file_paths:\n        try:\n            with open(file_path, \"r\") as f:\n                source = f.read()\n            \n            tree = ast.parse(source)\n            # Extract function definitions\n            for node in ast.walk(tree):\n                if isinstance(node, ast.FunctionDef):\n                    function_name = node.name\n                    module_name = os.path.basename(file_path).replace(\".py\", \"\")\n                    full_name = f\"{module_name}.{function_name}\"\n                    function_defs[full_name] = node\n                    dot.node(full_name, full_name)\n        except Exception as e:\n            logger.error(f\"Error parsing {file_path}: {e}\")\n    \n    # Parse all files again to extract function calls\n    for file_path in file_paths:\n        try:\n            with open(file_path, \"r\") as f:\n                source = f.read()\n            \n            tree = ast.parse(source)\n            module_name = os.path.basename(file_path).replace(\".py\", \"\")\n            \n            # Extract function calls\n            for node in ast.walk(tree):\n                if isinstance(node, ast.FunctionDef):\n                    function_name = node.name\n                    caller = f\"{module_name}.{function_name}\"\n                    \n                    # Find function calls within this function\n                    for subnode in ast.walk(node):\n                        if isinstance(subnode, ast.Call):\n                            if isinstance(subnode.func, ast.Name):\n                                callee_name = subnode.func.id\n                                callee = f\"{module_name}.{callee_name}\"\n                                \n                                # Check if the callee is defined in our files\n                                if callee in function_defs:\n                                    dot.edge(caller, callee)\n                            elif isinstance(subnode.func, ast.Attribute):\n                                # Handle method calls or imported functions\n                                if isinstance(subnode.func.value, ast.Name):\n                                    module = subnode.func.value.id\n                                    method = subnode.func.attr\n                                    callee = f\"{module}.{method}\"\n                                    \n                                    # Check if the callee is defined in our files\n                                    if callee in function_defs:\n                                        dot.edge(caller, callee)\n        except Exception as e:\n            logger.error(f\"Error analyzing calls in {file_path}: {e}\")\n    \n    # Render the graph\n    dot.render(output_path, format=format, cleanup=True)\n    \n    return dot\n```\n\n----------------------------------------\n\nTITLE: Deserializing Synalinks Program from JSON String in Python\nDESCRIPTION: This function creates a Synalinks Program object from a JSON string. It takes a JSON-formatted string as input, parses it, and constructs a Program object using the deserialized data.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Programs API/Program Saving API/Program saving and loading.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.src.programs.program.program_from_json\n```\n\n----------------------------------------\n\nTITLE: Implementing CallbackManager for Handling Multiple Callbacks in Python\nDESCRIPTION: The CallbackManager class manages a collection of callback instances, allowing for simplified execution of multiple callbacks at once. It provides methods to register callbacks and run them at different points in the processing lifecycle.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/Base Callback class.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass CallbackManager:\n    \"\"\"Callback manager for handling multiple callbacks.\n\n    The CallbackManager class manages multiple callbacks, and provides a single\n    interface to execute them.\n    \"\"\"\n\n    def __init__(self, callbacks: Optional[List[Callback]] = None) -> None:\n        \"\"\"Initialize a callback manager.\n\n        Args:\n            callbacks: A list of callbacks to be managed.\n        \"\"\"\n        self.callbacks = callbacks or []\n\n    def on_start(self, session: Any) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Called when a session starts.\n\n        Args:\n            session: The session object.\n\n        Returns:\n            A dictionary of data to be passed to the session.\n        \"\"\"\n        data = {}\n        for callback in self.callbacks:\n            callback_data = callback.on_start(session)\n            data[callback.__class__.__name__] = callback_data\n        return data\n\n    def on_end(self, session: Any, data: Dict[str, Dict[str, Any]]) -> None:\n        \"\"\"Called when a session ends.\n\n        Args:\n            session: The session object.\n            data: Data from the session.\n        \"\"\"\n        for callback in self.callbacks:\n            callback_name = callback.__class__.__name__\n            callback_data = data.get(callback_name, {})\n            callback.on_end(session, callback_data)\n```\n\n----------------------------------------\n\nTITLE: Installing Synalinks using UV Package Manager\nDESCRIPTION: Commands to install Synalinks package and initialize a new project using UV package manager.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuv pip install synalinks\nuv run synalinks init\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Squared Error (MSE) in Python\nDESCRIPTION: Function to calculate Mean Squared Error between true and predicted values, a standard regression metric that measures average squared difference between predictions and actual values. Takes arrays of true and predicted values and returns a single float value.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Regression metrics.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef mse(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"Mean Squared Error.\n\n    Parameters\n    ----------\n    y_true : np.ndarray\n        Ground truth target values.\n    y_pred : np.ndarray\n        Estimated target values.\n\n    Returns\n    -------\n    float\n        Mean squared error.\n    \"\"\"\n    return np.mean((y_true - y_pred) ** 2)\n```\n\n----------------------------------------\n\nTITLE: Importing Configuration Module in Python\nDESCRIPTION: This snippet imports the configuration module for the SynaLinks backend. It provides access to application-wide configuration settings.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Config.md#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n::: synalinks.src.backend.config\n```\n\n----------------------------------------\n\nTITLE: Initializing Core Dependencies for Program Visualization in Python\nDESCRIPTION: Imports essential libraries for graph visualization and program analysis, including Graphviz for creating diagrams, AST for abstract syntax tree parsing, and custom modules for program analysis.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Utilities/Program plotting utilities.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ast\nimport os\nimport matplotlib.pyplot as plt\n\nfrom graphviz import Digraph\nfrom matplotlib.patches import Rectangle, FancyBboxPatch\nfrom matplotlib.lines import Line2D\n\nfrom synalinks.src.utils.logging_utils import logger\n```\n\n----------------------------------------\n\nTITLE: Calculating R-squared (Coefficient of Determination) in Python\nDESCRIPTION: Function to calculate R-squared, which measures the proportion of variance explained by the model. This metric ranges from 0 to 1, with 1 indicating perfect prediction. Takes arrays of true and predicted values and returns a float.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Regression metrics.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef r2(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"R2 score, coefficient of determination.\n\n    Parameters\n    ----------\n    y_true : np.ndarray\n        Ground truth target values.\n    y_pred : np.ndarray\n        Estimated target values.\n\n    Returns\n    -------\n    float\n        R2 score.\n    \"\"\"\n    numerator = np.sum((y_true - y_pred) ** 2)\n    denominator = np.sum((y_true - np.mean(y_true)) ** 2)\n    return 1 - numerator / denominator\n```\n\n----------------------------------------\n\nTITLE: Computing Exact Match Rewards in Python\nDESCRIPTION: Defines functions to calculate rewards based on exact matches between predictions and targets. The module offers functions for basic exact match reward calculation, with potential variants for different use cases.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Rewards/ExactMatch reward.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef exact_match_reward(prediction, target):\n    \"\"\"Calculate reward based on exact match between prediction and target.\n\n    Args:\n        prediction: The predicted value or sequence\n        target: The target value or sequence\n\n    Returns:\n        float: 1.0 if prediction exactly matches target, 0.0 otherwise\n    \"\"\"\n    return float(prediction == target)\n```\n\n----------------------------------------\n\nTITLE: Saving Synalinks Configuration File Format in JSON\nDESCRIPTION: Shows the default configuration file format for Synalinks stored at $HOME/.synalinks/synalinks.json. The configuration defines the backend type, floating-point precision, and epsilon value.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"backend\": \"pydantic\",\n    \"floatx\": \"float32\",\n    \"epsilon\": 1e-07\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Class F-Score in Python\nDESCRIPTION: This function calculates the F-score for multi-class classification. It takes lists of true positives, false positives, and false negatives for each class, along with an optional beta parameter, and returns the average F-score.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/FScore metrics.md#2025-04-23_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef multi_class_f_score(\n    true_positives: List[float],\n    false_positives: List[float],\n    false_negatives: List[float],\n    beta: float = 1.0\n) -> float:\n    \"\"\"Calculate multi-class F-score.\n\n    Args:\n        true_positives: List of true positives for each class.\n        false_positives: List of false positives for each class.\n        false_negatives: List of false negatives for each class.\n        beta: Weight of precision in harmonic mean.\n\n    Returns:\n        Average F-score across all classes.\n    \"\"\"\n    precisions = [precision(tp, fp) for tp, fp in zip(true_positives, false_positives)]\n    recalls = [recall(tp, fn) for tp, fn in zip(true_positives, false_negatives)]\n    f_scores = [f_score(p, r, beta) for p, r in zip(precisions, recalls)]\n    return sum(f_scores) / len(f_scores) if f_scores else 0.0\n```\n\n----------------------------------------\n\nTITLE: Implementing RunCallback for Associating Callbacks with Run IDs in Python\nDESCRIPTION: The RunCallback class extends the base Callback to store run IDs and track callback data associated with specific runs. It provides methods to handle start and end events for specific run operations.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/Base Callback class.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass RunCallback(Callback):\n    \"\"\"A callback that is associated with a run ID.\n\n    This callback is used to associate a run ID with data returned from a callback.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize a run callback.\"\"\"\n        self.run_ids: Dict[str, Dict[str, Any]] = {}\n\n    def on_start(self, session: Any) -> Dict[str, Any]:\n        \"\"\"Called when a session starts.\n\n        Stores the run ID for the session.\n\n        Args:\n            session: The session object.\n\n        Returns:\n            A dictionary with the run ID.\n        \"\"\"\n        run_id = str(uuid.uuid4())\n        self.run_ids[run_id] = {}\n        return {\"run_id\": run_id}\n\n    def on_end(self, session: Any, data: Dict[str, Any]) -> None:\n        \"\"\"Called when a session ends.\n\n        Args:\n            session: The session object.\n            data: Data from the session.\n\n        Stores the data for the run ID.\n        \"\"\"\n        run_id = data.get(\"run_id\")\n        if run_id:\n            self.run_ids[run_id] = data\n\n    def get_data(self, run_id: str) -> Dict[str, Any]:\n        \"\"\"Get data for a run ID.\n\n        Args:\n            run_id: The run ID.\n\n        Returns:\n            The data for the run ID.\n        \"\"\"\n        return self.run_ids.get(run_id, {})\n```\n\n----------------------------------------\n\nTITLE: Importing Synalinks Datasets Module\nDESCRIPTION: Reference to the synalinks.datasets module that provides access to built-in datasets like GSM8K and ARC-AGI. These datasets are commonly used for testing and evaluating language models, though they may be present in training data of modern LMs.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Built-in Datasets/index.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nsynalinks.datasets\n```\n\n----------------------------------------\n\nTITLE: GSM8K Example Class Implementation in Python\nDESCRIPTION: A class that represents an example from the GSM8K dataset. It formats mathematical problems and their solutions, handling parsing of the question, reasoning steps, and final answer.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Built-in Datasets/GSM8K.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass GSM8KExample(TextExample):\n    \"\"\"GSM8K example.\"\"\"\n\n    @classmethod\n    def parse_answer(cls, answer: str) -> int:\n        \"\"\"Parse the answer from the solution.\n\n        Args:\n            answer: Answer string.\n\n        Returns:\n            The answer as an int.\n        \"\"\"\n        answer = answer.strip()\n        match = re.search(r\"^\\s*(?:The answer is|Answer|A:|\\$|\\(|=|\\w+\\s+=|\\w+:)\\s*-?\\s*[\\d,\\.]+\", answer)\n        if match:\n            s = match.group(0)\n            s = re.sub(r\"^\\s*(?:The answer is|Answer|A:|\\$|\\(|=|\\w+\\s+=|\\w+:)\\s*\", \"\", s)\n            s = s.replace(\",\", \"\")\n            if \".\" in s:\n                try:\n                    return float(s)\n                except ValueError:\n                    pass\n            try:\n                return int(s)\n            except ValueError:\n                pass\n        # Math expressions (fallback)\n        match = re.search(r\"^\\s*(?:The answer is|Answer|A:|\\$|\\(|=|\\w+\\s+=|\\w+:)\\s*(.+)$\", answer)\n        if match:\n            s = match.group(1).strip()\n            try:\n                return eval(s)\n            except:\n                pass\n        match = re.search(r\"(\\d[\\d,\\.]*)(?=[^\\d]*$)\", answer)\n        if match:\n            s = match.group(1).replace(\",\", \"\")\n            if \".\" in s:\n                return float(s)\n            return int(s)\n        return None\n\n    def get_answer(self) -> Union[int, float]:\n        \"\"\"Get the answer.\n\n        Returns:\n            The answer as an int or float.\n        \"\"\"\n        sol = self[\"answer\"]\n        return self.parse_answer(sol.split(\"\\n\")[-1])\n\n    def __init__(self, question=None, answer=None):\n        \"\"\"Initialize a GSM8K example.\n\n        Args:\n            question: The question.\n            answer: The answer.\n        \"\"\"\n        super().__init__()\n        if question is not None:\n            self[\"question\"] = question\n        if answer is not None:\n            self[\"answer\"] = answer\n```\n\n----------------------------------------\n\nTITLE: Defining the Callback Class Interface in Python\nDESCRIPTION: Defines the abstract Callback class that serves as the base for all callback implementations in the SynaLinks framework. It includes abstract methods for on_start and on_end events that must be implemented by subclasses.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/Base Callback class.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Callback(ABC):\n    \"\"\"Base class for callbacks.\n\n    The Callback class is the abstract base class that all callbacks should inherit from.\n    It defines the interface that all callbacks should implement.\n    \"\"\"\n\n    @abstractmethod\n    def on_start(self, session: Any) -> Dict[str, Any]:\n        \"\"\"Called when a session starts.\n\n        Args:\n            session: The session object.\n\n        Returns:\n            A dictionary of data to be passed to the session.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def on_end(self, session: Any, data: Dict[str, Any]) -> None:\n        \"\"\"Called when a session ends.\n\n        Args:\n            session: The session object.\n            data: Data from the session.\n        \"\"\"\n        pass\n```\n\n----------------------------------------\n\nTITLE: Creating a Run-Based Callback Manager in Python\nDESCRIPTION: The RunCallbackManager extends CallbackManager specifically for managing callbacks associated with run IDs. It provides methods to get callback data for specific run IDs.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/Base Callback class.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass RunCallbackManager(CallbackManager):\n    \"\"\"A callback manager that is associated with a run ID.\n\n    This callback manager is used to associate a run ID with data returned from callbacks.\n    \"\"\"\n\n    def get_data(self, run_id: str) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get data for a run ID.\n\n        Args:\n            run_id: The run ID.\n\n        Returns:\n            The data for the run ID.\n        \"\"\"\n        data = {}\n        for callback in self.callbacks:\n            if isinstance(callback, RunCallback):\n                callback_data = callback.get_data(run_id)\n                data[callback.__class__.__name__] = callback_data\n        return data\n```\n\n----------------------------------------\n\nTITLE: Implementing a Callback Handler Function in Python\nDESCRIPTION: The handle_callbacks function provides a decorator for functions that need to execute callbacks. It wraps the function to handle the execution of callbacks before and after the main function runs.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Callbacks API/Base Callback class.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef handle_callbacks(func):\n    \"\"\"Decorator for functions that use callbacks.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper function for the decorated function.\n\n        Args:\n            *args: The arguments to the function.\n            **kwargs: The keyword arguments to the function.\n\n        Returns:\n            The result of the function.\n        \"\"\"\n        callbacks = kwargs.pop(\"callbacks\", None)\n        if callbacks:\n            if not isinstance(callbacks, CallbackManager):\n                callbacks = CallbackManager(callbacks if isinstance(callbacks, list) else [callbacks])\n            session = {\"args\": args, \"kwargs\": kwargs}\n            callback_data = callbacks.on_start(session)\n            result = func(*args, **kwargs)\n            callbacks.on_end(session, callback_data)\n            return result\n        else:\n            return func(*args, **kwargs)\n\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Displaying Program Summary in Synalinks\nDESCRIPTION: This snippet shows how to generate a tabular summary of a Synalinks program, which provides an overview of the program's structure and components.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprogram.summary()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Program Structure with Synalinks Plot Utility\nDESCRIPTION: This snippet demonstrates how to create a visual representation of a Synalinks program using the plot_program utility. The visualization can show module names, trainable status, and schemas, making it useful for documentation.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/README.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsynalinks.utils.plot_program(\n    program,\n    show_module_names=True,\n    show_trainable=True,\n    show_schemas=True,\n)\n```\n\n----------------------------------------\n\nTITLE: Plotting Training History in Python for Synalinks\nDESCRIPTION: The plot_history function visualizes the training history of a model, showing the loss and accuracy curves for both training and validation data over epochs. It requires matplotlib for plotting and saves the resulting figure to a specified file.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Utilities/More plotting utilities.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef plot_history(history, save_path):\n    plt.figure(figsize=(12, 4))\n    plt.subplot(121)\n    plt.plot(history.history['loss'], label='train')\n    plt.plot(history.history['val_loss'], label='val')\n    plt.title('model loss')\n    plt.ylabel('loss')\n    plt.xlabel('epoch')\n    plt.legend()\n    plt.subplot(122)\n    plt.plot(history.history['accuracy'], label='train')\n    plt.plot(history.history['val_accuracy'], label='val')\n    plt.title('model accuracy')\n    plt.ylabel('accuracy')\n    plt.xlabel('epoch')\n    plt.legend()\n    plt.savefig(save_path)\n    plt.close()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Program Hierarchy with Function Blocks in Python\nDESCRIPTION: Creates a visual representation of program structure using matplotlib. It draws hierarchical boxes representing functions or modules, with connecting lines showing relationships between them, and supports customizable appearance settings.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Utilities/Program plotting utilities.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef visualize_program(hierarchy, ax=None, x=0.1, y=0.9, width=0.8, height=0.8, level=0):\n    \"\"\"\n    Visualize a program hierarchy using nested boxes.\n    \n    Args:\n        hierarchy (dict): Dictionary representing the program hierarchy.\n        ax (matplotlib.axes.Axes, optional): Matplotlib axes to draw on.\n        x (float): X-coordinate for the top-left corner of the box.\n        y (float): Y-coordinate for the top-left corner of the box.\n        width (float): Width of the box.\n        height (float): Height of the box.\n        level (int): Current hierarchy level.\n    \n    Returns:\n        matplotlib.axes.Axes: The axes with the visualization.\n    \"\"\"\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(12, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.axis('off')\n    \n    # Colors for different levels\n    colors = ['#D6EAF8', '#AED6F1', '#85C1E9', '#5DADE2', '#3498DB']\n    color = colors[min(level, len(colors) - 1)]\n    \n    # Draw the main box for the current node\n    node_name = next(iter(hierarchy.keys()))\n    box = FancyBboxPatch((x, y - height), width, height,\n                         boxstyle=\"round,pad=0.01\",\n                         facecolor=color, alpha=0.7,\n                         edgecolor='black', linewidth=1)\n    ax.add_patch(box)\n    \n    # Add the node name\n    ax.text(x + width/2, y - height/10, node_name, \n            ha='center', va='center', fontsize=10 - level,\n            fontweight='bold')\n    \n    # Process children\n    children = hierarchy[node_name]\n    if children:\n        # Divide the space for children\n        child_height = height * 0.8\n        child_width = width / len(children)\n        child_y = y - height * 0.2\n        \n        for i, (child_name, grandchildren) in enumerate(children.items()):\n            child_x = x + i * child_width\n            \n            # Create a dict for the child to pass to the recursive call\n            child_dict = {child_name: grandchildren}\n            \n            # Recursively visualize the child\n            visualize_program(child_dict, ax, child_x, child_y, child_width * 0.9, child_height, level + 1)\n            \n            # Draw a line connecting the parent to the child\n            ax.add_line(Line2D([x + width/2, child_x + child_width * 0.45],\n                              [y - height * 0.15, child_y],\n                              color='black', linewidth=1))\n    \n    return ax\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Functions in Python for Synalinks\nDESCRIPTION: This snippet contains functions for user authentication, including password hashing, verification, and token generation. It uses the PassLib library for password hashing and the PyJWT library for JWT token handling.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Identity module.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom passlib.context import CryptContext\nimport jwt\nfrom datetime import datetime, timedelta\nfrom synalinks.src.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n```\n\n----------------------------------------\n\nTITLE: Implementing User Management Functions in Python for Synalinks\nDESCRIPTION: This snippet includes functions for user management, such as creating new users, retrieving user information, and updating user details. It interacts with the database using SQLAlchemy ORM.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Identity module.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Session\nfrom synalinks.src.modules.core.identity import User, Organization\n\ndef get_user(db: Session, user_id: int):\n    return db.query(User).filter(User.id == user_id).first()\n\ndef get_user_by_email(db: Session, email: str):\n    return db.query(User).filter(User.email == email).first()\n\ndef create_user(db: Session, user: dict):\n    db_user = User(\n        username=user['username'],\n        email=user['email'],\n        hashed_password=get_password_hash(user['password']),\n        organization_id=user['organization_id']\n    )\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n\ndef update_user(db: Session, user_id: int, user_update: dict):\n    db_user = get_user(db, user_id)\n    for key, value in user_update.items():\n        setattr(db_user, key, value)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n```\n\n----------------------------------------\n\nTITLE: Defining Branch Class in Python for Synalinks\nDESCRIPTION: This code defines the Branch class that represents a branch in the Synalinks system. It includes initialization with logging and properties to access branch attributes.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Core Modules/Branch module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom synalinks.src.modules.core.node import Node\nimport logging\n\nclass Branch(Node):\n    \"\"\"\n    Class representing a branch.\n    \"\"\"\n\n    def __init__(self, name, parent=None, master=None, **kwargs):\n        \"\"\"\n        Initialize a branch.\n\n        :param name: The name of the branch.\n        :param parent: The parent of the branch.\n        :param master: The master branch if applicable.\n        :param kwargs: Additional keyword arguments.\n        \"\"\"\n        super().__init__(name, parent, **kwargs)\n        self.log = logging.getLogger(self.__class__.__name__)\n        self.master = master\n\n    @property\n    def branch_name(self):\n        \"\"\"\n        Get the branch name.\n\n        :return: The branch name.\n        \"\"\"\n        return self.name\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain of Thought Reasoning Module for Text-to-Code Generation in Python\nDESCRIPTION: This code defines a CoTReasoning class that implements a chain of thought approach for text-to-code generation. It inherits from the BaseModule and implements a step-by-step reasoning process through prompting strategies to guide the model in generating code from text descriptions.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Test Time Compute Modules/ChainOfThought module.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: synalinks.src.modules.ttc.chain_of_thought\n```\n\n----------------------------------------\n\nTITLE: Implementing Symbolic Variable Class in Python\nDESCRIPTION: This class represents a symbolic variable in the data model. It inherits from SymbolicExpression and implements methods for evaluation and simplification.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Data Models API/The SymbolicDataModel class.md#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Variable(SymbolicExpression):\n    def __init__(self, name):\n        self.name = name\n\n    def evaluate(self, context=None):\n        if context is None or self.name not in context:\n            return self\n        return context[self.name]\n\n    def simplify(self):\n        return self\n```\n\n----------------------------------------\n\nTITLE: Implementing RandomFewShot Optimizer Class for Knowledge Graph Link Prediction in Python\nDESCRIPTION: This code defines a RandomFewShot optimizer class that inherits from BaseFewShotOptimizer. It randomly samples training examples for few-shot learning in knowledge graph link prediction tasks, configurable by number of shots and entities per relation.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Optimizers API/RandomFewShot.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"Random few-shot optimizer.\"\"\"\n\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport numpy as np\nfrom omegaconf import DictConfig\n\nfrom synalinks.src.data.kge_dataset import KGEDataset\nfrom synalinks.src.optimizers.base_few_shot import BaseFewShotOptimizer\n\nlogger = logging.getLogger(os.path.basename(__file__))\n\n\nclass RandomFewShot(BaseFewShotOptimizer):\n    \"\"\"Random few shot.\"\"\"\n\n    def __init__(self, cfg: DictConfig, dataset: KGEDataset):\n        super().__init__(cfg=cfg, dataset=dataset)\n\n    def _run(\n        self,\n        shots: int,\n        entities_per_relation: int,\n        triples_path: Optional[str] = None,\n    ) -> List[int]:\n        if triples_path is not None:\n            self.few_shot_triples = self._load_triples_from_file(triples_path)\n            n_triples = len(self.few_shot_triples)\n            return list(range(n_triples))\n\n        timestamp = datetime.now().strftime(\"%Y%m%dT%H%M%S\")\n        np.random.seed(\n            self.random_seed + int(timestamp[-6:])\n        )  # date-dependent seed to allow repeating\n\n        n_entities = self.dataset.n_entities()\n        n_relations = self.dataset.n_relations()\n\n        if self.few_shot_mode.lower() == \"triple\":\n            indices = np.random.choice(\n                range(len(self.dataset.train_set)),\n                shots,\n                replace=False,\n            )\n            return indices.tolist()\n\n        if self.few_shot_mode.lower() == \"relation\":\n            indices_per_rel: Dict[int, List[int]] = {}\n            for rel_id in range(n_relations):\n                tri_idx_for_rel = self.dataset.get_idx_for_relations(rel_id)\n                if tri_idx_for_rel.shape[0] == 0:\n                    indices_per_rel[rel_id] = []\n                    continue\n\n                indices_per_rel[rel_id] = np.random.choice(\n                    tri_idx_for_rel,\n                    min(shots, tri_idx_for_rel.shape[0]),\n                    replace=False,\n                ).tolist()\n\n            return [idx for idxs in indices_per_rel.values() for idx in idxs]\n\n        if self.few_shot_mode.lower() == \"entity\":\n            indices_per_rel: Dict[int, List[int]] = {}\n            for rel_id in range(n_relations):\n                rel_samples = []\n                tri_idx_for_rel = self.dataset.get_idx_for_relations(rel_id)\n                candidates = np.random.choice(\n                    tri_idx_for_rel,\n                    min(shots, tri_idx_for_rel.shape[0]),\n                    replace=False,\n                )\n\n                ents_for_rel = set()\n                for idx in candidates:\n                    h, r, t = self.dataset.train_set[idx]\n                    ents_for_rel.add(h)\n                    ents_for_rel.add(t)\n                    rel_samples.append(idx)\n                    if len(ents_for_rel) >= entities_per_relation:\n                        break\n\n                indices_per_rel[rel_id] = rel_samples\n\n            return [idx for idxs in indices_per_rel.values() for idx in idxs]\n```\n\n----------------------------------------\n\nTITLE: Safe JSON Conversion with Error Handling in Python\nDESCRIPTION: A function that safely converts a dictionary to a JSON string with error handling. It attempts to perform the conversion and returns None if an error occurs, preventing application crashes due to serialization issues.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Ops API/JSON Ops.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom json import dumps\nfrom typing import Dict, Any, Optional\n\n\ndef safe_to_json(data: Dict[str, Any], indent: int = 4) -> Optional[str]:\n    \"\"\"Safely convert a dictionary to a JSON string.\n\n    Args:\n        data: Dictionary to convert.\n        indent: Indentation level for the JSON string.\n\n    Returns:\n        JSON string, or None if an error occurred.\n    \"\"\"\n    try:\n        return dumps(data, indent=indent)\n    except Exception:\n        return None\n```\n\n----------------------------------------\n\nTITLE: Safe JSON Deserialization with Error Handling in Python\nDESCRIPTION: A function that safely converts a JSON string to a Python dictionary with error handling. It attempts to parse the JSON and returns None if an error occurs, providing protection against malformed JSON input.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Ops API/JSON Ops.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom json import loads\nfrom typing import Dict, Any, Optional\n\n\ndef safe_from_json(data: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Safely convert a JSON string to a dictionary.\n\n    Args:\n        data: JSON string to convert.\n\n    Returns:\n        Dictionary, or None if an error occurred.\n    \"\"\"\n    try:\n        return loads(data)\n    except Exception:\n        return None\n```\n\n----------------------------------------\n\nTITLE: Containerizing Synalinks REST API with Docker\nDESCRIPTION: Dockerfile for containerizing the Synalinks REST API application. Uses Python 3.13 base image and sets up the environment for running the FastAPI application.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_3\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM python:3.13\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\nCOPY ./app /code/app\n\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"8000\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for Synalinks with Arize Phoenix\nDESCRIPTION: Docker Compose configuration that sets up both the Synalinks backend service and Arize Phoenix for telemetry. Maps necessary ports and configures environment variables.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  arizephoenix:\n    image: arizephoenix/phoenix:latest\n    ports:\n      - \"6006:6006\"\n      - \"4317:4317\"\n  backend:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    ports:\n      - \"8000:8000\"\n    env_file:\n      - .env.backend\n    depends_on:\n      - arizephoenix\n```\n\n----------------------------------------\n\nTITLE: Dependencies Configuration for Synalinks REST API\nDESCRIPTION: The requirements.txt file listing necessary Python dependencies for the Synalinks REST API project, including FastAPI, uvicorn, and telemetry libraries.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Building a REST API.md#2025-04-23_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nfastapi[standard]\nuvicorn\nsynalinks\nopeninference-instrumentation-litellm\narize-otel\n```\n\n----------------------------------------\n\nTITLE: Running a Synalinks Program in Python\nDESCRIPTION: Demonstrates how to execute a Synalinks program with input data.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/index.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nresult = await program(\n    Query(query=\"What is the French city of aerospace?\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Markdown Link List\nDESCRIPTION: Simple markdown list containing a link to the ReACT agent module documentation\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Modules API/Agents Modules/index.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [ReACT module](ReACT Agent module.md)\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for LM Tracing\nDESCRIPTION: This command installs the necessary Python packages for LM tracing using Arize Phoenix and OpenInference.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Enabling LM Tracing.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuv pip install openinference-instrumentation-litellm arize-otel\n```\n\n----------------------------------------\n\nTITLE: Pulling Arize Phoenix Docker Image\nDESCRIPTION: This command pulls the latest Arize Phoenix Docker image from the Docker registry.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Deployment/Enabling LM Tracing.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndocker pull arizephoenix/phoenix\n```\n\n----------------------------------------\n\nTITLE: Citation Format for Synalinks in BibTeX\nDESCRIPTION: Provides the BibTeX entry for citing Synalinks in academic research papers. Includes the authors, title, year, and URL information.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_1\n\nLANGUAGE: bibtex\nCODE:\n```\n@misc{sallami2025synalinks,\n  title={Synalinks},\n  author={Sallami, Yoan and Chollet, Fran\\c{c}ois},\n  year={2025},\n  howpublished={\\url{https://github.com/SynaLinks/Synalinks}},\n}\n```\n\n----------------------------------------\n\nTITLE: Using shuffle parameter in Keras fit() method\nDESCRIPTION: When passing NumPy arrays to the fit() method, setting shuffle=True (default) will globally shuffle training data at each epoch. Validation data is never shuffled regardless of this setting.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/FAQ.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprogram.fit()\n```\n\n----------------------------------------\n\nTITLE: Importing Global State Module in Python\nDESCRIPTION: This snippet imports the global state module for the SynaLinks backend. It allows access to shared state across the application.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Config.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n::: synalinks.src.backend.common.global_state\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Squared Error in Python\nDESCRIPTION: This function computes the mean squared error between true and predicted values. It takes two arrays as input and returns a float value representing the average squared difference between corresponding elements.\nSOURCE: https://github.com/synalinks/synalinks/blob/main/docs/Synalinks API/Metrics/Metric wrappers and reduction metrics.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"Compute mean squared error.\n\n    Args:\n        y_true: Ground truth target values.\n        y_pred: Estimated target values.\n\n    Returns:\n        Mean squared error.\n    \"\"\"\n    return np.mean((y_true - y_pred) ** 2)\n```"
  }
]