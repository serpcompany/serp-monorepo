[
  {
    "owner": "paulmillr",
    "repo": "noble-curves",
    "content": "TITLE: ECDSA Operations with secp256k1\nDESCRIPTION: Shows how to perform basic ECDSA operations using secp256k1 curve. This includes generating private and public keys, signing messages, verifying signatures, and recovering public keys from signatures.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { secp256k1 } from '@noble/curves/secp256k1';\n// import { p256 } from '@noble/curves/p256'; // or p384 / p521\n\nconst priv = secp256k1.utils.randomPrivateKey();\nconst pub = secp256k1.getPublicKey(priv);\nconst msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\nconst sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\nconst isValid = secp256k1.verify(sig, msg, pub) === true;\n\n// hex strings are also supported besides Uint8Array-s:\nconst privHex = '46c930bc7bb4db7f55da20798697421b98c4175a52c630294d75a84b9c126236';\nconst pub2 = secp256k1.getPublicKey(privHex);\n\n// public key recovery\n// let sig = secp256k1.Signature.fromCompact(sigHex); // or .fromDER(sigDERHex)\n// sig = sig.addRecoveryBit(bit); // bit is not serialized into compact / der format\nsig.recoverPublicKey(msg).toRawBytes(); // === pub; // public key recovery\n```\n\n----------------------------------------\n\nTITLE: Ed25519 Signature Operations\nDESCRIPTION: Shows how to perform signature operations with Ed25519 curve. Demonstrates key generation, signing, and verification with different verification modes (ZIP215 and SBS/RFC8032).\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ed25519 } from '@noble/curves/ed25519';\nconst priv = ed25519.utils.randomPrivateKey();\nconst pub = ed25519.getPublicKey(priv);\nconst msg = new TextEncoder().encode('hello');\nconst sig = ed25519.sign(msg, priv);\ned25519.verify(sig, msg, pub); // Default mode: follows ZIP215\ned25519.verify(sig, msg, pub, { zip215: false }); // SBS / e-voting / RFC8032 / FIPS 186-5\n\n// Variants from RFC8032: with context, prehashed\nimport { ed25519ctx, ed25519ph } from '@noble/curves/ed25519';\n```\n\n----------------------------------------\n\nTITLE: Schnorr Signature Implementation using secp256k1\nDESCRIPTION: Demonstrates how to use Schnorr signatures according to BIP340 specification with the secp256k1 curve. Shows key generation, message signing, and signature verification.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { schnorr } from '@noble/curves/secp256k1';\nconst priv = schnorr.utils.randomPrivateKey();\nconst pub = schnorr.getPublicKey(priv);\nconst msg = new TextEncoder().encode('hello');\nconst sig = schnorr.sign(msg, priv);\nconst isValid = schnorr.verify(sig, msg, pub);\n```\n\n----------------------------------------\n\nTITLE: ECDH Implementation for Shared Secret Generation\nDESCRIPTION: Shows how to perform Elliptic Curve Diffie-Hellman (ECDH) key exchange to generate a shared secret between two parties. Includes notes about properly handling the output.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst someonesPub = secp256k1.getPublicKey(secp256k1.utils.randomPrivateKey());\nconst shared = secp256k1.getSharedSecret(priv, someonesPub);\n// NOTE:\n// - `shared` includes parity byte: strip it using shared.slice(1)\n// - `shared` is not hashed: more secure way is sha256(shared) or hkdf(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Hedged ECDSA with Noise for Enhanced Security\nDESCRIPTION: Demonstrates how to use hedged ECDSA, which adds entropy to signatures for better protection against fault attacks. Shows both automatic entropy generation and providing custom entropy.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst noisySignature = secp256k1.sign(msg, priv, { extraEntropy: true });\nconst ent = new Uint8Array(32).fill(3); // set custom entropy\nconst noisySignature2 = secp256k1.sign(msg, priv, { extraEntropy: ent });\n```\n\n----------------------------------------\n\nTITLE: X25519 Key Exchange and Edwards-to-Montgomery Conversion\nDESCRIPTION: Demonstrates X25519 (Montgomery curve) for ECDH key exchange as specified in RFC7748. Shows shared secret generation, public key derivation, and converting between Ed25519 and X25519 key formats.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// X25519 aka ECDH on Curve25519 from [RFC7748](https://www.rfc-editor.org/rfc/rfc7748)\nimport { x25519 } from '@noble/curves/ed25519';\nconst priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\nconst pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\nx25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\nx25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\nx25519.getPublicKey(x25519.utils.randomPrivateKey());\n\n// ed25519 => x25519 conversion\nimport { edwardsToMontgomeryPub, edwardsToMontgomeryPriv } from '@noble/curves/ed25519';\nedwardsToMontgomeryPub(ed25519.getPublicKey(ed25519.utils.randomPrivateKey()));\nedwardsToMontgomeryPriv(ed25519.utils.randomPrivateKey());\n```\n\n----------------------------------------\n\nTITLE: Using BLS12-381 for Signatures and Key Operations\nDESCRIPTION: Demonstrates BLS12-381 curve operations including key generation, signing, verification, and aggregation. The example shows both G1/G2 signature schemes, custom domain separation tags, and pairing operations.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bls12_381 as bls } from '@noble/curves/bls12-381';\n\n// G1 keys, G2 signatures\nconst privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\nconst message = '64726e3da8';\nconst publicKey = bls.getPublicKey(privateKey);\nconst signature = bls.sign(message, privateKey);\nconst isValid = bls.verify(signature, message, publicKey);\nconsole.log({ publicKey, signature, isValid });\n\n// G2 keys, G1 signatures\n// getPublicKeyForShortSignatures(privateKey)\n// signShortSignature(message, privateKey)\n// verifyShortSignature(signature, message, publicKey)\n// aggregateShortSignatures(signatures)\n\n// Custom DST\nconst htfEthereum = { DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_' };\nconst signatureEth = bls.sign(message, privateKey, htfEthereum);\nconst isValidEth = bls.verify(signature, message, publicKey, htfEthereum);\n\n// Aggregation\nconst aggregatedKey = bls.aggregatePublicKeys([\n  bls.utils.randomPrivateKey(),\n  bls.utils.randomPrivateKey(),\n]);\n// const aggregatedSig = bls.aggregateSignatures(sigs)\n\n// Pairings, with and without final exponentiation\n// bls.pairing(PointG1, PointG2);\n// bls.pairing(PointG1, PointG2, false);\n// bls.fields.Fp12.finalExponentiate(bls.fields.Fp12.mul(PointG1, PointG2));\n\n// Others\n// bls.G1.ProjectivePoint.BASE, bls.G2.ProjectivePoint.BASE;\n// bls.fields.Fp, bls.fields.Fp2, bls.fields.Fp12, bls.fields.Fr;\n```\n\n----------------------------------------\n\nTITLE: Ed448 Signature Operations\nDESCRIPTION: Demonstrates signature operations with the Ed448 curve. Shows key generation, signing, verification, and mentions the prehashed variant from RFC8032.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ed448 } from '@noble/curves/ed448';\nconst priv = ed448.utils.randomPrivateKey();\nconst pub = ed448.getPublicKey(priv);\nconst msg = new TextEncoder().encode('whatsup');\nconst sig = ed448.sign(msg, priv);\ned448.verify(sig, msg, pub);\n\n// Variants from RFC8032: prehashed\nimport { ed448ph } from '@noble/curves/ed448';\n```\n\n----------------------------------------\n\nTITLE: Ristretto255 Operations\nDESCRIPTION: Shows how to use Ristretto255, a prime-order group built from Curve25519 as specified in RFC9496. Demonstrates point operations, hash-to-curve functionality, and working with the Ristretto format.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// ristretto255 from [RFC9496](https://www.rfc-editor.org/rfc/rfc9496)\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { sha512 } from '@noble/hashes/sha512';\nimport {\n  hashToCurve,\n  encodeToCurve,\n  RistrettoPoint,\n  hashToRistretto255,\n} from '@noble/curves/ed25519';\n\nconst msg = utf8ToBytes('Ristretto is traditionally a short shot of espresso coffee');\nhashToCurve(msg);\n\nconst rp = RistrettoPoint.fromHex(\n  '6a493210f7499cd17fecb510ae0cea23a110e8d5b901f8acadd3095c73a3b919'\n);\nRistrettoPoint.BASE.multiply(2n).add(rp).subtract(RistrettoPoint.BASE).toRawBytes();\nRistrettoPoint.ZERO.equals(dp) === false;\n// pre-hashed hash-to-curve\nRistrettoPoint.hashToCurve(sha512(msg));\n// full hash-to-curve including domain separation tag\nhashToRistretto255(msg, { DST: 'ristretto255_XMD:SHA-512_R255MAP_RO_' });\n```\n\n----------------------------------------\n\nTITLE: X448 Key Exchange and Edwards-to-Montgomery Conversion\nDESCRIPTION: Shows how to use X448 (Montgomery curve) for ECDH key exchange as specified in RFC7748. Demonstrates shared secret generation, public key derivation, and converting keys between Ed448 and X448 formats.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// X448 aka ECDH on Curve448 from [RFC7748](https://www.rfc-editor.org/rfc/rfc7748)\nimport { x448 } from '@noble/curves/ed448';\nx448.getSharedSecret(priv, pub) === x448.scalarMult(priv, pub); // aliases\nx448.getPublicKey(priv) === x448.scalarMultBase(priv);\n\n// ed448 => x448 conversion\nimport { edwardsToMontgomeryPub } from '@noble/curves/ed448';\nedwardsToMontgomeryPub(ed448.getPublicKey(ed448.utils.randomPrivateKey()));\n```\n\n----------------------------------------\n\nTITLE: Implementing Decaf448 Operations in TypeScript\nDESCRIPTION: Demonstrates how to use decaf448 functionality from RFC9496, including hash-to-curve operations, point manipulation, and equality testing. This snippet shows basic operations with DecafPoint including multiplication, addition, and subtraction.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// decaf448 from [RFC9496](https://www.rfc-editor.org/rfc/rfc9496)\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { shake256 } from '@noble/hashes/sha3';\nimport { hashToCurve, encodeToCurve, DecafPoint, hashToDecaf448 } from '@noble/curves/ed448';\n\nconst msg = utf8ToBytes('Ristretto is traditionally a short shot of espresso coffee');\nhashToCurve(msg);\n\nconst dp = DecafPoint.fromHex(\n  'c898eb4f87f97c564c6fd61fc7e49689314a1f818ec85eeb3bd5514ac816d38778f69ef347a89fca817e66defdedce178c7cc709b2116e75'\n);\nDecafPoint.BASE.multiply(2n).add(dp).subtract(DecafPoint.BASE).toRawBytes();\nDecafPoint.ZERO.equals(dp) === false;\n// pre-hashed hash-to-curve\nDecafPoint.hashToCurve(shake256(msg, { dkLen: 112 }));\n// full hash-to-curve including domain separation tag\nhashToDecaf448(msg, { DST: 'decaf448_XOF:SHAKE256_D448MAP_RO_' });\n```\n\n----------------------------------------\n\nTITLE: Importing and Using BN254 (alt_bn128) Curve\nDESCRIPTION: Shows how to import and use the BN254 curve (also known as alt_bn128). This curve is compatible with Ethereum's EIP-196 and EIP-197 and provides similar API to the BLS12-381 implementation.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bn254 } from '@noble/curves/bn254';\n\nconsole.log(bn254.G1, bn254.G2, bn254.pairing);\n```\n\n----------------------------------------\n\nTITLE: Using Custom Curve API for ECDSA Operations and Point Manipulation\nDESCRIPTION: Demonstrates how to use a custom curve instance for various operations including key generation, signing, verification, and point manipulation. This example shows the consistent API across different curve implementations.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// All curves expose same generic interface.\nconst priv = secq256k1.utils.randomPrivateKey();\nsecq256k1.getPublicKey(priv); // Convert private key to public.\nconst sig = secq256k1.sign(msg, priv); // Sign msg with private key.\nconst sig2 = secq256k1.sign(msg, priv, { prehash: true }); // hash(msg)\nsecq256k1.verify(sig, msg, priv); // Verify if sig is correct.\n\n// Default behavior is \"try DER, then try compact if fails\". Can be explicit:\nsecq256k1.verify(sig.toCompactHex(), msg, priv, { format: 'compact' });\n\nconst Point = secq256k1.ProjectivePoint;\nconst point = Point.BASE; // Elliptic curve Point class and BASE point static var.\npoint.add(point).equals(point.double()); // add(), equals(), double() methods\npoint.subtract(point).equals(Point.ZERO); // subtract() method, ZERO static var\npoint.negate(); // Flips point over x/y coordinate.\npoint.multiply(31415n); // Multiplication of Point by scalar.\n\npoint.assertValidity(); // Checks for being on-curve\npoint.toAffine(); // Converts to 2d affine xy coordinates\n\nsecq256k1.CURVE.n;\nsecq256k1.CURVE.p;\nsecq256k1.CURVE.Fp.mod();\nsecq256k1.CURVE.hash();\n\n// precomputes\nconst fast = secq256k1.utils.precompute(8, Point.fromHex(someonesPubKey));\nfast.multiply(privKey); // much faster ECDH now\n```\n\n----------------------------------------\n\nTITLE: Hashing to Curve Points with hashToCurve and encodeToCurve\nDESCRIPTION: Demonstrates usage of hashToCurve and encodeToCurve functions for hashing arbitrary strings to elliptic curve points, following RFC 9380. Shows examples for both secp256k1 and BLS12-381 curves with custom domain separation tags.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { hashToCurve, encodeToCurve } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nhashToCurve('0102abcd');\nconsole.log(hashToCurve(randomBytes()));\nconsole.log(encodeToCurve(randomBytes()));\n\nimport { bls12_381 } from '@noble/curves/bls12-381';\nbls12_381.G1.hashToCurve(randomBytes(), { DST: 'another' });\nbls12_381.G2.hashToCurve(randomBytes(), { DST: 'custom' });\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Weierstrass Curves with the Abstract API\nDESCRIPTION: Demonstrates how to define custom Weierstrass curves using the abstract API. Includes examples for secq256k1 and secp192r1 curves with their parameters, and shows how to use the resulting curve instances for cryptographic operations.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { weierstrass } from '@noble/curves/abstract/weierstrass';\nimport { Field } from '@noble/curves/abstract/modular';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\n\nconst hmacSha256 = (key: Uint8Array, ...msgs: Uint8Array[]) =>\n  hmac(sha256, key, concatBytes(...msgs));\n\n// secQ (not secP) - secq256k1 is a cycle of secp256k1 with Fp/N flipped.\n// https://personaelabs.org/posts/spartan-ecdsa\n// https://zcash.github.io/halo2/background/curves.html#cycles-of-curves\nconst secq256k1 = weierstrass({\n  a: 0n,\n  b: 7n,\n  Fp: Field(2n ** 256n - 432420386565659656852420866394968145599n),\n  n: 2n ** 256n - 2n ** 32n - 2n ** 9n - 2n ** 8n - 2n ** 7n - 2n ** 6n - 2n ** 4n - 1n,\n  Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n  Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n  hash: sha256,\n  hmac: hmacSha256,\n  randomBytes,\n});\n\n// NIST secp192r1 aka p192\n// https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/secg/secp192r1\nconst secp192r1 = weierstrass({\n  a: 0xfffffffffffffffffffffffffffffffefffffffffffffffcn,\n  b: 0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1n,\n  Fp: Field(0xfffffffffffffffffffffffffffffffeffffffffffffffffn),\n  n: 0xffffffffffffffffffffffff99def836146bc9b1b4d22831n,\n  Gx: 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012n,\n  Gy: 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811n,\n  hash: sha256,\n  hmac: hmacSha256,\n  randomBytes,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Low-Level Curve Methods and Multi-Scalar Multiplication\nDESCRIPTION: Shows how to access low-level curve parameters and perform multi-scalar multiplication (MSM). MSM is significantly faster than naive addition for large numbers of points and uses the Pippenger algorithm.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\n// Curve's variables\n// Every curve has `CURVE` object that contains its parameters, field, and others\nconsole.log(secp256k1.CURVE.p); // field modulus\nconsole.log(secp256k1.CURVE.n); // curve order\nconsole.log(secp256k1.CURVE.a, secp256k1.CURVE.b); // equation params\nconsole.log(secp256k1.CURVE.Gx, secp256k1.CURVE.Gy); // base point coordinates\n\n// MSM\nconst p = secp256k1.ProjectivePoint;\nconst points = [p.BASE, p.BASE.multiply(2n), p.BASE.multiply(4n), p.BASE.multiply(8n)];\np.msm(points, [3n, 5n, 7n, 11n]).equals(p.BASE.multiply(129n)); // 129*G\n```\n\n----------------------------------------\n\nTITLE: Initializing Twisted Edwards Curve for Ed25519 in TypeScript\nDESCRIPTION: Creates an Ed25519 implementation using the twistedEdwards function. Defines the field, curve parameters, and hashing functions needed for the Edwards curve with formula ax² + y² = 1 + dx²y². Includes specific scalar byte adjustment required for Ed25519.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { twistedEdwards } from '@noble/curves/abstract/edwards';\nimport { Field } from '@noble/curves/abstract/modular';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { randomBytes } from '@noble/hashes/utils';\n\nconst Fp = Field(2n ** 255n - 19n);\nconst ed25519 = twistedEdwards({\n  a: Fp.create(-1n),\n  d: Fp.div(-121665n, 121666n), // -121665n/121666n mod p\n  Fp: Fp,\n  n: 2n ** 252n + 27742317777372353535851937790883648493n,\n  h: 8n,\n  Gx: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,\n  Gy: 46316835694926478169428394003475163141307993866256225615783033603165251855960n,\n  hash: sha512,\n  randomBytes,\n  adjustScalarBytes(bytes) {\n    // optional; but mandatory in ed25519\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n  },\n} as const);\n```\n\n----------------------------------------\n\nTITLE: Importing Miscellaneous Curves for ZK Proofs\nDESCRIPTION: Demonstrates how to import miscellaneous curves from the Noble Curves library, specifically jubjub and babyjubjub which are useful for zero-knowledge proofs.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jubjub, babyjubjub } from '@noble/curves/misc';\n```\n\n----------------------------------------\n\nTITLE: Implementing Low-Level Hash-to-Curve Methods\nDESCRIPTION: Outlines the low-level methods used in the hash-to-curve specification, including expand_message_xmd, expand_message_xof, and hash_to_field functions. These methods handle domain separation, field extension, and security parameters for reliable hashing to elliptic curve points.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\nfunction expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash // For CHash see abstract/weierstrass docs section\n): Uint8Array;\n// produces a uniformly random byte string using an extendable-output function (XOF) H.\nfunction expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array;\n// Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\nfunction hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][];\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\ntype Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand?: 'xmd' | 'xof';\n  hash: CHash;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Poseidon Hash and Sponge Construction\nDESCRIPTION: Shows how to use the Poseidon hash module to create a permutation and sponge construction. Demonstrates setting up parameters like MDS matrix, round constants, and sbox power, which are required for this ZK-friendly hash function.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { poseidon, poseidonSponge } from '@noble/curves/abstract/poseidon';\n\nconst rate = 2;\nconst capacity = 1;\nconst { mds, roundConstants } = poseidon.grainGenConstants({\n  Fp,\n  t: rate + capacity,\n  roundsFull: 8,\n  roundsPartial: 31,\n});\nconst opts = {\n  Fp,\n  rate,\n  capacity,\n  sboxPower: 17,\n  mds,\n  roundConstants,\n  roundsFull: 8,\n  roundsPartial: 31,\n};\nconst permutation = poseidon.poseidon(opts);\nconst sponge = poseidon.poseidonSponge(opts); // use carefully, not specced\n```\n\n----------------------------------------\n\nTITLE: Using Modular Arithmetic Utilities for Finite Field Operations\nDESCRIPTION: Demonstrates the use of modular arithmetic utilities for finite field operations such as multiplication, exponentiation, division, inverse calculation, and square root. Shows both Field-specific operations and generic modular arithmetic utilities.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mod from '@noble/curves/abstract/modular';\n\n// Finite Field utils\nconst fp = mod.Field(2n ** 255n - 19n); // Finite field over 2^255-19\nfp.mul(591n, 932n); // multiplication\nfp.pow(481n, 11024858120n); // exponentiation\nfp.div(5n, 17n); // division: 5/17 mod 2^255-19 == 5 * invert(17)\nfp.inv(5n); // modular inverse\nfp.sqrt(21n); // square root\n\n// Non-Field generic utils are also available\nmod.mod(21n, 10n); // 21 mod 10 == 1n; fixed version of 21 % 10\nmod.invert(17n, 10n); // invert(17) mod 10; modular multiplicative inverse\nmod.invertBatch([1n, 2n, 4n], 21n); // => [1n, 11n, 16n] in one inversion\n```\n\n----------------------------------------\n\nTITLE: Creating Unbiased Private Keys from Hash Values\nDESCRIPTION: Shows how to create unbiased private keys from hash values using FIPS 186-5 A.2 and RFC 9380 techniques. Demonstrates the use of hashToPrivateScalar to handle bias reduction when deriving private keys from hashes.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { p256 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport * as mod from '@noble/curves/abstract/modular';\nconst someKey = new Uint8Array(32).fill(2); // Needs to actually be random, not .fill(2)\nconst derived = hkdf(sha256, someKey, undefined, 'application', 48); // 48 bytes for 32-byte priv\nconst validPrivateKey = mod.hashToPrivateScalar(derived, p256.CURVE.n);\n```\n\n----------------------------------------\n\nTITLE: Using Utility Functions for Byte Manipulation and Conversion\nDESCRIPTION: Demonstrates utility functions for byte array manipulation, hex conversion, and number-to-byte transformation in both big-endian and little-endian formats. Includes functions for concatenating byte arrays and comparing byte equality.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as utils from '@noble/curves/abstract/utils';\n\nutils.bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.hexToBytes('deadbeef');\nutils.numberToHexUnpadded(123n);\nutils.hexToNumber();\n\nutils.bytesToNumberBE(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.bytesToNumberLE(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.numberToBytesBE(123n, 32);\nutils.numberToBytesLE(123n, 64);\n\nutils.concatBytes(Uint8Array.from([0xde, 0xad]), Uint8Array.from([0xbe, 0xef]));\nutils.nLength(255n);\nutils.equalBytes(Uint8Array.from([0xde]), Uint8Array.from([0xde]));\n```\n\n----------------------------------------\n\nTITLE: Importing Curve Modules with TypeScript\nDESCRIPTION: Demonstrates how to import various curve implementations from the noble-curves library. The imports cover all major elliptic curves including secp256k1, ed25519, ed448, NIST curves, BLS12-381, BN254, and utility functions.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// import * from '@noble/curves'; // Error: use sub-imports, to ensure small app size\nimport { secp256k1, schnorr } from '@noble/curves/secp256k1';\nimport { ed25519, ed25519ph, ed25519ctx, x25519 } from '@noble/curves/ed25519';\nimport { ed448, ed448ph, ed448ctx, x448 } from '@noble/curves/ed448';\nimport { p256 } from '@noble/curves/p256';\nimport { p384 } from '@noble/curves/p384';\nimport { p521 } from '@noble/curves/p521';\nimport { bls12_381 } from '@noble/curves/bls12-381';\nimport { bn254 } from '@noble/curves/bn254'; // also known as alt_bn128\nimport { jubjub, babyjubjub } from '@noble/curves/misc';\nimport { bytesToHex, hexToBytes, concatBytes, utf8ToBytes } from '@noble/curves/abstract/utils';\n```\n\n----------------------------------------\n\nTITLE: Noble Curves Performance Benchmark Results\nDESCRIPTION: Comprehensive benchmark results showing performance metrics for various cryptographic operations across different curves including secp256k1, ed25519, ed448, p256, p384, p521, ristretto255, decaf448, ECDH, hash-to-curve, modular operations, and bls12-381\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_25\n\nLANGUAGE: plaintext\nCODE:\n```\n# secp256k1\ninit 10ms\ngetPublicKey x 9,099 ops/sec @ 109μs/op\nsign x 7,182 ops/sec @ 139μs/op\nverify x 1,188 ops/sec @ 841μs/op\ngetSharedSecret x 735 ops/sec @ 1ms/op\nrecoverPublicKey x 1,265 ops/sec @ 790μs/op\nschnorr.sign x 957 ops/sec @ 1ms/op\nschnorr.verify x 1,210 ops/sec @ 825μs/op\n\n# ed25519\ninit 14ms\ngetPublicKey x 14,216 ops/sec @ 70μs/op\nsign x 6,849 ops/sec @ 145μs/op\nverify x 1,400 ops/sec @ 713μs/op\n\n# ed448\ninit 37ms\ngetPublicKey x 5,273 ops/sec @ 189μs/op\nsign x 2,494 ops/sec @ 400μs/op\nverify x 476 ops/sec @ 2ms/op\n\n# p256\ninit 17ms\ngetPublicKey x 8,977 ops/sec @ 111μs/op\nsign x 7,236 ops/sec @ 138μs/op\nverify x 877 ops/sec @ 1ms/op\n\n# p384\ninit 42ms\ngetPublicKey x 4,084 ops/sec @ 244μs/op\nsign x 3,247 ops/sec @ 307μs/op\nverify x 331 ops/sec @ 3ms/op\n\n# p521\ninit 83ms\ngetPublicKey x 2,049 ops/sec @ 487μs/op\nsign x 1,748 ops/sec @ 571μs/op\nverify x 170 ops/sec @ 5ms/op\n\n# ristretto255\nadd x 931,966 ops/sec @ 1μs/op\nmultiply x 15,444 ops/sec @ 64μs/op\nencode x 21,367 ops/sec @ 46μs/op\ndecode x 21,715 ops/sec @ 46μs/op\n\n# decaf448\nadd x 478,011 ops/sec @ 2μs/op\nmultiply x 416 ops/sec @ 2ms/op\nencode x 8,562 ops/sec @ 116μs/op\ndecode x 8,636 ops/sec @ 115μs/op\n\n# ECDH\nx25519 x 1,981 ops/sec @ 504μs/op\nx448 x 743 ops/sec @ 1ms/op\nsecp256k1 x 728 ops/sec @ 1ms/op\np256 x 705 ops/sec @ 1ms/op\np384 x 268 ops/sec @ 3ms/op\np521 x 137 ops/sec @ 7ms/op\n\n# hash-to-curve\nhashToPrivateScalar x 1,754,385 ops/sec @ 570ns/op\nhash_to_field x 135,703 ops/sec @ 7μs/op\nhashToCurve secp256k1 x 3,194 ops/sec @ 313μs/op\nhashToCurve p256 x 5,962 ops/sec @ 167μs/op\nhashToCurve p384 x 2,230 ops/sec @ 448μs/op\nhashToCurve p521 x 1,063 ops/sec @ 940μs/op\nhashToCurve ed25519 x 4,047 ops/sec @ 247μs/op\nhashToCurve ed448 x 1,691 ops/sec @ 591μs/op\nhash_to_ristretto255 x 8,733 ops/sec @ 114μs/op\nhash_to_decaf448 x 3,882 ops/sec @ 257μs/op\n\n# modular over secp256k1 P field\ninvert a x 866,551 ops/sec @ 1μs/op\ninvert b x 693,962 ops/sec @ 1μs/op\nsqrt p = 3 mod 4 x 25,738 ops/sec @ 38μs/op\nsqrt tonneli-shanks x 847 ops/sec @ 1ms/op\n\n# bls12-381\ninit 22ms\ngetPublicKey x 1,325 ops/sec @ 754μs/op\nsign x 80 ops/sec @ 12ms/op\nverify x 62 ops/sec @ 15ms/op\npairing x 166 ops/sec @ 6ms/op\npairing10 x 54 ops/sec @ 18ms/op ± 23.48% (15ms..36ms)\nMSM 4096 scalars x points 3286ms\naggregatePublicKeys/8 x 173 ops/sec @ 5ms/op\naggregatePublicKeys/32 x 46 ops/sec @ 21ms/op\naggregatePublicKeys/128 x 11 ops/sec @ 84ms/op\naggregatePublicKeys/512 x 2 ops/sec @ 335ms/op\naggregatePublicKeys/2048 x 0 ops/sec @ 1346ms/op\naggregateSignatures/8 x 82 ops/sec @ 12ms/op\naggregateSignatures/32 x 21 ops/sec @ 45ms/op\naggregateSignatures/128 x 5 ops/sec @ 178ms/op\naggregateSignatures/512 x 1 ops/sec @ 705ms/op\naggregateSignatures/2048 x 0 ops/sec @ 2823ms/op\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Noble Curves Benchmarks\nDESCRIPTION: Shell commands to install dependencies and run performance benchmarks for the noble-curves library\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/README.md#2025-04-22_snippet_24\n\nLANGUAGE: sh\nCODE:\n```\nnpm run bench:install && npm run bench\n```\n\n----------------------------------------\n\nTITLE: Displaying Cryptographic Hash Input-Output Pairs\nDESCRIPTION: Collection of cryptographic hash input-output pairs organized with the input (possibly with a salt) before the double colon and the resulting hash in hexadecimal format after. These examples appear to be test vectors or reference outputs for the noble-curves cryptographic library.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\ne2e213db79a576da7d0a616666f4a28038f37e3d70b389c75bfccc0404e1b023::8aedfb44ff3d22ce2d0b27fefb61b4aaa7f44456b7151375262cb4fba097dce4ebd54353e9f1048d7ae9b0bcf4166d7319b6055c2ee1a2a36cc32432f1195dc88112203108e4db786540e1334157e90aabdbd26ed3e0c9abe2e26150f5e65757\n```\n\n----------------------------------------\n\nTITLE: Hash Data Collection\nDESCRIPTION: A collection of cryptographic hash pairs, where each line contains a hash followed by a delimiter and associated data\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n31e6a9f2bfd89057675b9986a2326af50fc5b4fa6900e06392500d6a7cb8281e:41e77882d77d:83a3cf3e0e9b4726f76ce301c93db6d15e563bfdb5f93e885c37f0fcf28362e54c86e30d0e6a63f831f097eb624c153e15f8061c8dfd215e7d3a3da513b8f35061b2376457391db393bbafcf43e032f4b3c39a8dd20a1f4e8df3a217113ca007\n```\n\n----------------------------------------\n\nTITLE: Generating SHA-256 Hash for 'abcdef0123456789' in JavaScript\nDESCRIPTION: This snippet shows the SHA-256 hash output for the string 'abcdef0123456789'. The hash is represented as a 64-character hexadecimal string.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-scalar-xmd-sha256-test-vectors.txt#2025-04-22_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nabcdef0123456789:3dff572f262e702f2ee8fb79b70e3225f5ee543a389eea2e58eec7b2bfd6afeb\n```\n\n----------------------------------------\n\nTITLE: Cryptographic Hash Data\nDESCRIPTION: Collection of hex-encoded hash values paired with their corresponding input or output data. Each line contains a hash value followed by separator and associated data.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n0fc195c56cd4f54fc81f4f78a4abc2ba834b5b0018bfc150a64e7c6a5823933c:ed0afd7c4881:a40286e1cc833d2adde1d0640abbcc2199b2767b27ef540420dc96f12deb14af17eb655cd2e958a52a68ba2bed2e3e160344101b101eacbc33f3c5277fb1ee6bf6d9b866b5b8f5794f55a5d7236d3ca0de4356bc1e8cac30a2cb87f94eff4817\n```\n\n----------------------------------------\n\nTITLE: Cryptographic Hash Test Vector\nDESCRIPTION: A single test vector for a cryptographic hash function or key derivation function. It includes the input data, optional salt or additional data, and the expected hash output.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g1-test-vectors.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n25d8cef413ba263e8d5732d3fca51fd369db74712655a5fd7b0b3a58d8095be8::800134e27aacc74dc91153a6bd65f96a5f8c8365c722da2f1e12eb048e0aed6987fa4168a51241ce41434fd05fd4bdd9\n```\n\n----------------------------------------\n\nTITLE: Hex-Encoded Encryption Data\nDESCRIPTION: Collection of hex-encoded encryption operations containing keys, IVs, and ciphertexts. Each line represents a separate encryption operation with components separated by colons.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n3967f728a6fc9b97d815a8a76c5df791d8252cb44fbab8a52bee1aa59228f26a:96dc2c37e0f9efb8f177873b:8dda9f419ff275828006089d7e4e1342b5eb17dcf7c51a2fb7c5cd6ebfcc2064b987c3b2d100c166b8499d82d705905511682b1210616c5674b11c3f6b472fd92879b1532d2c60a2c05535d8224832efcfbae410cdeeaff9428af6159f07621f\n```\n\n----------------------------------------\n\nTITLE: Cryptographic Hex Data Entries\nDESCRIPTION: Collection of hex value triplets separated by colons, possibly representing cryptographic keys, nonces, or other parameters used in curve implementations\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g1-test-vectors.txt#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n3f528ca57a9a03e0e1af999cff2a602d43a8a7fc9774a5b35b91d46ba2332590:5c52e68adbf3a47d0352d333bca88b4559579fe3dc2efe7369fce4c10acea51c4166e8ab22d243741d7e2c2ae49a0ba35f729456f8c37b7bd31e858205a968cc0a6e5afaf2b3964b09619e241b3438c6d7:a2b1e39069444e3b1f14aab6015a6e25543ed0baa4a23ab6b187ac300c54d433580ea036af283a3a25d5421a945409ce\n```\n\n----------------------------------------\n\nTITLE: Generating SHA-256 Hash for 'abc' in JavaScript\nDESCRIPTION: This snippet demonstrates the SHA-256 hash output for the string 'abc'. The hash is represented as a 64-character hexadecimal string.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-scalar-xmd-sha256-test-vectors.txt#2025-04-22_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nabc:47e7a8839695a3df27f202cf71e295a8554b47cef75c1e316b1865317720e188\n```\n\n----------------------------------------\n\nTITLE: Formatted Hash Data Entries\nDESCRIPTION: Collection of colon-separated hash entries, likely representing cryptographic verification data or blockchain-related information. Each line contains hex-encoded values of varying lengths.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n8d750998b2143613209a3284da5d9bb2d63c5b7504f0ded55cba58d99902ba68:d626a5:8ab12e4ebbebbc60760f61eed87a65fc221abb342fe3909483db1dffe132ab2cd208568955821e7167f29bd2fed824f309904e2e77577ca6cb8a59e16077cd2847985a083838af48b0820336cea6011c6a7dbdea166fc3a733a8941ab53bf3f3\n```\n\n----------------------------------------\n\nTITLE: Cryptographic Hash-Data Pairs\nDESCRIPTION: Each line contains a SHA-256 hash (64 hex characters), followed by a colon and associated data values in hexadecimal format. This appears to be a log or ledger of cryptographic operations.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nf4e297d963163769b5aaf4aafdd1969e78ac101fbb5f08f48d62f21b4dca91c2:a8d74c3c2d54faff2095a18c:81008cb4621bf919e027aaf6877618444953723e24625e6d1330554c599072d0fa9ac69d513d330cc102b6ae79220af10fd084898192663a701c599050c8cad6b7a37240ccecc2cd680474ae70d121cd64413d7428f32822467d6b695c890385\n```\n\n----------------------------------------\n\nTITLE: Generating SHA-256 Hash for Empty String in JavaScript\nDESCRIPTION: This snippet shows the SHA-256 hash output for an empty string. The hash is represented as a 64-character hexadecimal string.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-scalar-xmd-sha256-test-vectors.txt#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n:3b3fdf74b194c0a0f683d67a312a4e72d663d74b8478dc7b56be41e0ce11caa1\n```\n\n----------------------------------------\n\nTITLE: Hex-Encoded Cryptographic Data\nDESCRIPTION: Collection of hex-encoded entries in key:value format, where each entry contains cryptographic data like hashes or keys. Each line follows a pattern of colon-separated hex values.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n6f3c9137e679a12e1cbd241b7436e8bb6807aa491bbf083c6b68398894cadb4f:580e2bb1668220c7f7:848be794b037494823c76cae9de6083a69902dceee2979893d27b04efc18eee6b28a4754288d7e20f5970e540709cc4f040fc33482c6be06311d1793fbecd66194fc97f9b491631257e19babb61bb58a464888a02924d5e10ba4113b2e9d990f\n```\n\n----------------------------------------\n\nTITLE: Referencing Audit File Location\nDESCRIPTION: Markdown link to the security section in the main README file where all library audits are described.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/audit/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[README's Security section](../README.md#security)\n```\n\n----------------------------------------\n\nTITLE: Version Support Table in Markdown\nDESCRIPTION: Markdown table showing supported versions of the noble-curves project, indicating that versions 1.8.0 and above are supported while earlier versions are not.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/SECURITY.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Version | Supported          |\n| ------- | ------------------ |\n| >=1.8.0   | :white_check_mark: |\n| <1.8.0   | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Cryptographic Hash Computation Example\nDESCRIPTION: This snippet shows a single line from the file, demonstrating the format of the hash computations. It includes a hash value, followed by a separator, and then additional data or parameters.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/bls12-381/bls12-381-g2-test-vectors.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndb29a6e1db5d6dcb485f26c174d11dd0ab1ecc54125e31dde2949b03e925ef23::8e49a02dc374bb1702ec4c8aa514c6d72e0884d3611334ae749462eb545a4d0a6086ef0a6b1bbc5db2934d297bf766c60dbe665dfc33d3aa765d071712075b4102a71f518e16376fc58c982d30a6196fdd8319090bcb2728c9bbbd8045fc7863\n```\n\n----------------------------------------\n\nTITLE: Displaying Public Keys in Hexadecimal Format\nDESCRIPTION: This snippet shows a collection of public keys represented as hexadecimal strings. Each line contains a unique 66-character hexadecimal string, which is likely a compressed public key used in cryptographic systems.\nSOURCE: https://github.com/paulmillr/noble-curves/blob/main/test/vectors/secp256k1/points.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\n0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\n02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5\n02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\n02fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e\n03936cb2bd56e681d360bbce6a3a7a1ccbf72f3ab8792edbc45fb08f55b929c588\n02993e1095f5caa7548e55950d77ac3c2dd1e59f1cfce7f19b01849ff8398c9e09\n02dca0df5a8e3f9547d1162f93e3ecf5f943e8e2dace37005daae069ac4a45cb88\n028e834a9b951ba2de51a26e9ecc03509067d26fa1e4687a066aa458841bffd276\n0300a566fc5d0b861a14494b305d90d4d392e0f2051adb84e3164e5a40cc5717b1\n```"
  }
]