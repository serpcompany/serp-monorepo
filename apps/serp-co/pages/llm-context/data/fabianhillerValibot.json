[
  {
    "owner": "fabian-hiller",
    "repo": "valibot",
    "content": "TITLE: Creating and Using a Login Schema with Valibot in TypeScript\nDESCRIPTION: This example demonstrates how to create a login schema with email and password validation using Valibot. It shows how to define validation rules, infer TypeScript types from the schema, and parse data against the schema both with valid and invalid inputs.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/README.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot'; // 1.31 kB\n\n// Create login schema with email and password\nconst LoginSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n// Infer output TypeScript type of login schema as\n// { email: string; password: string }\ntype LoginData = v.InferOutput<typeof LoginSchema>;\n\n// Throws error for email and password\nconst output1 = v.parse(LoginSchema, { email: '', password: '' });\n\n// Returns data as { email: string; password: string }\nconst output2 = v.parse(LoginSchema, {\n  email: 'jane@example.com',\n  password: '12345678',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Validation Pipeline in Valibot\nDESCRIPTION: Shows how to create a validation pipeline for an email field using pipe, email, and endsWith validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/quick-start/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.email(), v.endsWith('@example.com'));\n```\n\n----------------------------------------\n\nTITLE: Creating an Email Schema with Pipe and Actions in Valibot\nDESCRIPTION: This snippet illustrates how to use the pipe method along with actions to create a more complex schema. It defines an email schema that trims the input string and validates it as an email address.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/mental-model/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.trim(), v.email());\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Valibot Schema in TypeScript\nDESCRIPTION: Demonstrates the comparison between TypeScript type definition and Valibot schema definition for a login data structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/quick-start/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// TypeScript\ntype LoginData = {\n  email: string;\n  password: string;\n};\n\n// Valibot\nconst LoginSchema = v.object({\n  email: v.string(),\n  password: v.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Valibot via npm for Node and Bun\nDESCRIPTION: Command-line instructions for installing Valibot using various package managers including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install valibot     # npm\nyarn add valibot        # yarn\npnpm add valibot        # pnpm\nbun add valibot         # bun\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages in Valibot Schema\nDESCRIPTION: Demonstrates how to add custom error messages to validation rules in a login schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/quick-start/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst LoginSchema = v.object({\n  email: v.pipe(\n    v.string('Your email must be a string.'),\n    v.nonEmpty('Please enter your email.'),\n    v.email('The email address is badly formatted.')\n  ),\n  password: v.pipe(\n    v.string('Your password must be a string.'),\n    v.nonEmpty('Please enter your password.'),\n    v.minLength(8, 'Your password must have 8 characters or more.')\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Early Validation Abort Configuration\nDESCRIPTION: Shows how to use abortEarly option to stop validation at first error, improving performance when detailed error collection isn't needed.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/parse-data/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntry {\n  const ProfileSchema = v.object({\n    name: v.string(),\n    bio: v.string(),\n  });\n  const profile = v.parse(\n    ProfileSchema,\n    { name: 'Jane', bio: '' },\n    { abortEarly: true }\n  );\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.log(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Record Schema Validation in TypeScript\nDESCRIPTION: Shows how to validate objects with uniform entries using the record schema validator.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst RecordSchema = v.record(v.string(), v.number()); // Record<string, number>\n```\n\n----------------------------------------\n\nTITLE: Using Valibot Schema for Type Inference and Validation\nDESCRIPTION: Shows how to use a Valibot schema to infer types and validate unknown data at runtime.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/quick-start/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst LoginSchema = v.object({â€¦});\n\ntype LoginData = v.InferOutput<typeof LoginSchema>;\n\nfunction getLoginData(data: unknown): LoginData {\n  return v.parse(LoginSchema, data);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Book Schema in Valibot\nDESCRIPTION: This snippet demonstrates how to create a schema for a book object using Valibot. It defines properties for title, number of pages, publication date, and tags.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/mental-model/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst BookSchema = v.object({\n  title: v.string(),\n  numberOfPages: v.number(),\n  publication: v.date(),\n  tags: v.array(v.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Pipeline Validation for Arrays in Valibot\nDESCRIPTION: Uses pipe to combine multiple validators for an array schema. This example validates an array of strings with constraints on length and content requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/arrays/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ArraySchema = v.pipe(\n  v.array(v.string()),\n  v.minLength(1),\n  v.maxLength(5),\n  v.includes('foo'),\n  v.excludes('bar')\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Valibot Schema Validation Example in TypeScript\nDESCRIPTION: Demonstrates creating and using a login validation schema with email and password fields. Shows schema definition, type inference, and validation using parse() method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/introduction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot'; // 1.31 kB\n\n// Create login schema with email and password\nconst LoginSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n// Infer output TypeScript type of login schema as\n// { email: string; password: string }\ntype LoginData = v.InferOutput<typeof LoginSchema>;\n\n// Throws error for email and password\nconst output1 = v.parse(LoginSchema, { email: '', password: '' });\n\n// Returns data as { email: string; password: string }\nconst output2 = v.parse(LoginSchema, {\n  email: 'jane@example.com',\n  password: '12345678',\n});\n```\n\n----------------------------------------\n\nTITLE: Object Properties Validation Using Check\nDESCRIPTION: Example showing how to validate object properties using check action within a pipe to ensure list length matches the length property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/check/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst CustomObjectSchema = v.pipe(\n  v.object({\n    list: v.array(v.string()),\n    length: v.number(),\n  }),\n  v.check(\n    (input) => input.list.length === input.length,\n    'The list does not match the length.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Email Validation Pipeline in TypeScript\nDESCRIPTION: A practical example of using pipe to create an email validation schema. It chains multiple validations including string type checking, non-empty check, email format validation, and maximum length constraint.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/pipe/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please enter your email.'),\n  v.email('The email is badly formatted.'),\n  v.maxLength(30, 'Your email is too long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Validation\nDESCRIPTION: Example of validating an object with two keys - a string and a number\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.object({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Validation\nDESCRIPTION: Example of validating an object with two keys - a string and a number\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.object({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Validation\nDESCRIPTION: Example of validating an object with two keys - a string and a number\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.object({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Validation\nDESCRIPTION: Example of validating an object with two keys - a string and a number\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.object({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Array Schema in Valibot\nDESCRIPTION: Creates a basic array schema that validates a collection of numbers. The array function takes a schema for validating each item in the array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/arrays/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ArraySchema = v.array(v.number()); // number[]\n```\n\n----------------------------------------\n\nTITLE: Implementing Schema Intersection using Valibot\nDESCRIPTION: Demonstrates how to create an intersection schema using Valibot's intersect function. Shows equivalent TypeScript type definition and Valibot schema implementation for combining object schemas with AND relationship.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/intersections/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// TypeScript\ntype Intersect = { foo: string } & { bar: number };\n\n// Valibot\nconst IntersectSchema = v.intersect([\n  v.object({ foo: v.string() }),\n  v.object({ bar: v.number() }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Password Validation Schema with Valibot\nDESCRIPTION: Schema to validate a password with specific requirements: must be a string, between 8-30 characters, and containing at least one lowercase letter, one uppercase letter, and one number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/string/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst PasswordSchema = v.pipe(\n  v.string(),\n  v.minLength(8, 'Your password is too short.'),\n  v.maxLength(30, 'Your password is too long.'),\n  v.regex(/[a-z]/, 'Your password must contain a lowercase letter.'),\n  v.regex(/[A-Z]/, 'Your password must contain a uppercase letter.'),\n  v.regex(/[0-9]/, 'Your password must contain a number.')\n);\n```\n\n----------------------------------------\n\nTITLE: Example of Validating Email with Valibot's parse Method\nDESCRIPTION: Demonstrates how to validate an email address using the parse method with pipe and email validation. The example shows using try/catch to handle validation errors.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/parse/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  const EmailSchema = v.pipe(v.string(), v.email());\n  const email = v.parse(EmailSchema, 'jane@example.com');\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.log(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Login Schema in Valibot\nDESCRIPTION: This example demonstrates how to create a validation schema with email and password fields, infer TypeScript types from it, and validate data at runtime. It shows both failed and successful validation attempts using the parse function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/library/README.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot'; // 1.31 kB\n\n// Create login schema with email and password\nconst LoginSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n// Infer output TypeScript type of login schema as\n// { email: string; password: string }\ntype LoginData = v.InferOutput<typeof LoginSchema>;\n\n// Throws error for email and password\nconst output1 = v.parse(LoginSchema, { email: '', password: '' });\n\n// Returns data as { email: string; password: string }\nconst output2 = v.parse(LoginSchema, {\n  email: 'jane@example.com',\n  password: '12345678',\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Object Schema Validation in TypeScript\nDESCRIPTION: Demonstrates how to create a basic object schema with string and number validations using Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ObjectSchema = v.object({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Profile Validation with Valibot\nDESCRIPTION: Example showing how to validate a profile object with an async username check against a database. Demonstrates the combination of both synchronous and asynchronous validation methods in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/async-validation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { isUsernameAvailable } from '~/api';\n\nconst ProfileSchema = v.objectAsync({\n  username: v.pipeAsync(v.string(), v.checkAsync(isUsernameAvailable)),\n  avatar: v.pipe(v.string(), v.url()),\n  description: v.pipe(v.string(), v.maxLength(1000)),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Email Validation Pipeline in TypeScript\nDESCRIPTION: Demonstrates how to create a pipeline that validates an email string by trimming whitespace, checking if it's a valid email format, and ensuring it ends with a specific domain.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(\n  v.string(),\n  v.trim(),\n  v.email(),\n  v.endsWith('@example.com')\n);\n```\n\n----------------------------------------\n\nTITLE: Basic SafeParse Usage with TypeScript\nDESCRIPTION: Basic example showing how to use the safeParse method to validate input against a schema. The method returns a result object indicating success or failure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/safeParse/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = v.safeParse<TSchema>(schema, input, config);\n```\n\n----------------------------------------\n\nTITLE: Selective Object Property Validation\nDESCRIPTION: Creates a schema that validates only specific properties from an object using the pick method\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst PickObjectSchema = v.pick(\n  v.object({\n    key1: v.string(),\n    key2: v.number(),\n    key3: v.boolean(),\n  }),\n  ['key1', 'key3']\n);\n```\n\n----------------------------------------\n\nTITLE: Email Validation with SafeParse\nDESCRIPTION: Practical example demonstrating email validation using safeParse with a pipe schema combining string and email validation. Shows how to handle both success and error cases.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/safeParse/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst result = v.safeParse(EmailSchema, 'jane@example.com');\n\nif (result.success) {\n  const email = result.output;\n} else {\n  console.log(result.issues);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Special Case Schemas in TypeScript with Valibot\nDESCRIPTION: Illustrates the creation of schemas for special cases like any, custom types, enums, intersections, unions, and more using Valibot. Covers a wide range of special schema types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/schemas/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst AnySchema = v.any(); // any\nconst CustomSchema = v.custom<`${number}px`>(isPixelString); // `${number}px`\nconst EnumSchema = v.enum(Direction); // Direction\nconst ExactOptionalSchema = v.exactOptional(v.string()); // string\nconst InstanceSchema = v.instance(Error); // Error\nconst LazySchema = v.lazy(() => v.string()); // string\nconst IntersectSchema = v.intersect([v.string(), v.literal('a')]); // string & 'a'\nconst LiteralSchema = v.literal('foo'); // 'foo'\nconst NanSchema = v.nan(); // NaN\nconst NeverSchema = v.never(); // never\nconst NonNullableSchema = v.nonNullable(v.nullable(v.string())); // string\nconst NonNullishSchema = v.nonNullish(v.nullish(v.string())); // string\nconst NonOptionalSchema = v.nonOptional(v.optional(v.string())); // string\nconst NullableSchema = v.nullable(v.string()); // string | null\nconst NullishSchema = v.nullish(v.string()); // string | null | undefined\nconst OptionalSchema = v.optional(v.string()); // string | undefined\nconst PicklistSchema = v.picklist(['a', 'b']); // 'a' | 'b'\nconst UndefinedableSchema = v.undefinedable(v.string()); // string | undefined\nconst UnionSchema = v.union([v.string(), v.number()]); // string | number\nconst UnknownSchema = v.unknown(); // unknown\nconst VariantSchema = v.variant('type', [\n  v.object({ type: v.literal('a'), foo: v.string() }),\n  v.object({ type: v.literal('b'), bar: v.number() }),\n]); // { type: 'a'; foo: string } | { type: 'b'; bar: number }\nconst VoidSchema = v.void(); // void\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Valibot's parse Method in TypeScript\nDESCRIPTION: Shows the basic usage of the parse method that takes a schema, input data, and optional config. The method validates the input against the schema and returns the parsed output or throws a ValiError if validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/parse/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst output = v.parse<TSchema>(schema, input, config);\n```\n\n----------------------------------------\n\nTITLE: Defining Function Schema with Arguments and Return Type in TypeScript\nDESCRIPTION: This example shows how to create a schema for a function that takes a string argument, transforms it to a decimal, and returns a number. It uses 'args' to specify the argument schema and 'returns' for the return type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/args/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FunctionSchema = v.pipe(\n  v.function(),\n  v.args(v.tuple([v.pipe(v.string(), v.decimal())])),\n  v.returns(v.number())\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Array Length in Valibot\nDESCRIPTION: Example of creating a schema that validates an array of numbers and its length using pipe to chain multiple validations. The array must have between 1 and 3 elements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/array/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArrayLengthSchema = v.pipe(\n  v.array(v.number()),\n  v.minLength(1),\n  v.maxLength(3)\n);\n```\n\n----------------------------------------\n\nTITLE: Formatting Arrays for Picklist Schemas in Valibot with TypeScript\nDESCRIPTION: Illustrates how to format an array of objects into the required format for a picklist schema using the `map` method. This is useful when the original array structure doesn't match the desired enum values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/enums/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst countries = [\n  { name: 'Germany', code: 'DE' },\n  { name: 'France', code: 'FR' },\n  { name: 'United States', code: 'US' },\n] as const;\n\nconst CountrySchema = v.picklist(countries.map((country) => country.code));\n```\n\n----------------------------------------\n\nTITLE: Pipeline Validation for Object Schema in TypeScript\nDESCRIPTION: Illustrates how to implement pipeline validation for objects with interdependent field validation using check and forward functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst CalculationSchema = v.pipe(\n  v.object({\n    a: v.number(),\n    b: v.number(),\n    sum: v.number(),\n  }),\n  v.forward(\n    v.check(({ a, b, sum }) => a + b === sum, 'The calculation is incorrect.'),\n    ['sum']\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: String to Number Transformation Pipeline in TypeScript\nDESCRIPTION: An example showing how to use pipe for data transformation. This schema converts a string input to a number type, involving string validation, transformation using Number constructor, and number type validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/pipe/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(v.string(), v.transform(Number), v.number());\n```\n\n----------------------------------------\n\nTITLE: Stored Email Validation Schema - TypeScript\nDESCRIPTION: Example schema that validates a stored email address using multiple validation steps including async database check.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/pipeAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst StoredEmailSchema = v.pipeAsync(\n  v.string(),\n  v.nonEmpty('Please enter your email.'),\n  v.email('The email is badly formatted.'),\n  v.maxLength(30, 'Your email is too long.'),\n  v.checkAsync(isEmailPresent, 'The email is not in the database.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Primitive Value Schemas in TypeScript with Valibot\nDESCRIPTION: Demonstrates how to create schemas for primitive data types like bigint, boolean, null, number, string, symbol, and undefined using Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/schemas/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst BigintSchema = v.bigint(); // bigint\nconst BooleanSchema = v.boolean(); // boolean\nconst NullSchema = v.null(); // null\nconst NumberSchema = v.number(); // number\nconst StringSchema = v.string(); // string\nconst SymbolSchema = v.symbol(); // symbol\nconst UndefinedSchema = v.undefined(); // undefined\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Validation with Valibot in TypeScript\nDESCRIPTION: This code demonstrates how to use Valibot to create a login schema that validates email and password fields. It shows how to define schemas, perform validations using pipes, infer TypeScript types from schemas, and parse data against the schema to ensure validity.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v1-the-1-kb-schema-library/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as v from 'valibot'; // 1.31 kB\n\n// Create login schema with email and password\nconst LoginSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n// Infer output TypeScript type of login schema as\n// { email: string; password: string }\ntype LoginData = v.InferOutput<typeof LoginSchema>;\n\n// Throws error for email and password\nconst output1 = v.parse(LoginSchema, { email: '', password: '' });\n\n// Returns data as { email: string; password: string }\nconst output2 = v.parse(LoginSchema, {\n  email: 'jane@example.com',\n  password: '12345678',\n});\n```\n\n----------------------------------------\n\nTITLE: Using parseAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the parseAsync method. It takes a schema, input, and optional config as parameters, and returns a promise that resolves to the parsed output.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/parseAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst output = v.parseAsync<TSchema>(schema, input, config);\n```\n\n----------------------------------------\n\nTITLE: Validating String Content with Includes in TypeScript\nDESCRIPTION: This example demonstrates how to use the 'includes' function to create a schema that validates if a string contains a specific substring. It combines 'string' and 'includes' validations using the 'pipe' method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/includes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(\n  v.string(),\n  v.includes('foo', 'The string must contain \"foo\".')\n);\n```\n\n----------------------------------------\n\nTITLE: Using fallback Method in Valibot\nDESCRIPTION: Demonstrates how to use the fallback method to provide a default value when validation fails. In this example, if a non-string value is passed to the string schema, it returns 'hello' instead of throwing an error.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/methods/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst StringSchema = v.fallback(v.string(), 'hello');\nconst stringOutput = v.parse(StringSchema, 123); // 'hello'\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Schema with Nullable Entry in TypeScript with Valibot\nDESCRIPTION: Example of creating an object schema with a nullable string entry using Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullable/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullableEntrySchema = v.object({\n  key: v.nullable(v.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Using safeParseAsync with a Schema in Valibot\nDESCRIPTION: Basic usage of the safeParseAsync method to parse an unknown input based on a schema. The method returns a result object indicating success or failure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/safeParseAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = v.safeParseAsync<TSchema>(schema, input, config);\n```\n\n----------------------------------------\n\nTITLE: Binary Tree Schema Using Lazy for Recursion\nDESCRIPTION: Example of creating a recursive schema to validate a binary tree structure. The BinaryTreeSchema uses lazy() to reference itself for the left and right properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/lazy/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype BinaryTree = {\n  element: string;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n};\n\nconst BinaryTreeSchema: v.GenericSchema<BinaryTree> = v.object({\n  element: v.string(),\n  left: v.nullable(v.lazy(() => BinaryTreeSchema)),\n  right: v.nullable(v.lazy(() => BinaryTreeSchema)),\n});\n```\n\n----------------------------------------\n\nTITLE: Email Validation Parser Example in TypeScript\nDESCRIPTION: Practical example showing how to create and use a parser for email validation, including error handling. The code creates an email schema using pipe and email validators, then uses it to parse an email address.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/parser/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  const EmailSchema = v.pipe(v.string(), v.email());\n  const emailParser = v.parser(EmailSchema);\n  const email = emailParser('jane@example.com');\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.log(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Parsing with Result Object\nDESCRIPTION: Shows how to use safeParse() method to handle validation without throwing errors, returning a result object with success status and either output or issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/parse-data/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst result = v.safeParse(EmailSchema, 'jane@example.com');\n\nif (result.success) {\n  const email = result.output;\n} else {\n  console.log(result.issues);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Email Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating an email validation action with optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/email/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.email<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Object Schema in TypeScript\nDESCRIPTION: Basic syntax for creating an object schema with type generics and optional message parameter\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object<TEntries, TMessage>(entries, message);\n```\n\n----------------------------------------\n\nTITLE: Using parserAsync with Async Email Validation in TypeScript\nDESCRIPTION: This example shows how to use parserAsync with a custom email schema that includes asynchronous validation. It demonstrates error handling and the use of pipe, string, email, and checkAsync validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/parserAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\ntry {\n  const StoredEmailSchema = v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  );\n  const storedEmailParser = v.parserAsync(StoredEmailSchema);\n  const storedEmail = await storedEmailParser('jane@example.com');\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.error(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an ID to Email Schema with recordAsync in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a record mapping UUIDs to public email addresses. It uses pipe and pipeAsync for complex validations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/recordAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPublic } from '~/api';\n\nconst IdToEmailSchema = v.recordAsync(\n  v.pipe(v.string(), v.uuid()),\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPublic, 'The email address is private.')\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Partial Object Schema with Specific Keys in TypeScript\nDESCRIPTION: Example of creating a schema where only specific entries are marked as optional. This allows for more granular control over which properties should be required versus optional.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/partial/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialSchema = v.partial(\n  v.object({\n    key1: v.string(),\n    key2: v.number(),\n    key3: v.boolean(),\n  }),\n  ['key1', 'key3']\n); // { key1?: string; key2: number; key3?: boolean }\n```\n\n----------------------------------------\n\nTITLE: Finding Duplicate Items in an Array using findItem in TypeScript\nDESCRIPTION: This example shows how to use findItem to create a schema that finds the first duplicate item in an array of strings. It uses pipe to combine array validation with the findItem operation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/findItem/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DuplicateItemSchema = v.pipe(\n  v.array(v.string()),\n  v.findItem((item, index, array) => array.indexOf(item) !== index)\n);\n```\n\n----------------------------------------\n\nTITLE: Email Validation Example with Valibot Assert (TypeScript)\nDESCRIPTION: Example demonstrating how to use the assert method to validate an email address. It creates an EmailSchema using pipe and email validators, then asserts an unknown input against this schema to safely type it as a string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/assert/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst data: unknown = 'jane@example.com';\n\nv.assert(EmailSchema, data);\nconst email = data; // string\n```\n\n----------------------------------------\n\nTITLE: Cart Items Schema Using checkItemsAsync\nDESCRIPTION: An example schema that validates an array of cart item objects, using checkItemsAsync to verify that the requested quantity of each item is available in stock by making an asynchronous API call.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/checkItemsAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getProductItem } from '~/api';\n\nconst CartItemsSchema = v.pipeAsync(\n  v.array(\n    v.object({\n      itemId: v.pipe(v.string(), v.uuid()),\n      quantity: v.pipe(v.number(), v.minValue(1)),\n    })\n  ),\n  v.checkItemsAsync(async (input) => {\n    const productItem = await getProductItem(input.itemId);\n    return (productItem?.quantity ?? 0) >= input.quantity;\n  }, 'The required quantity is greater than available.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating New User Schema with Async Email Validation\nDESCRIPTION: Example of creating a schema for validating new user data with looseObjectAsync. It includes validation for firstName, lastName, email (with asynchronous check if email is already present), password, and optional avatar.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/looseObjectAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst NewUserSchema = v.looseObjectAsync({\n  firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is already in use by another user.')\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n  avatar: v.optional(v.pipe(v.string(), v.url())),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating String Array Schema in Valibot\nDESCRIPTION: Example of creating a schema that validates an array of strings with a custom error message if validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/array/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringArraySchema = v.array(v.string(), 'An array is required.');\n```\n\n----------------------------------------\n\nTITLE: Validating Email with Async Check in Valibot\nDESCRIPTION: Example of using safeParseAsync with a pipeAsync schema to validate an email string and check if it exists in a database asynchronously. The result is handled differently based on success or failure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/safeParseAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst StoredEmailSchema = v.pipeAsync(\n  v.string(),\n  v.email(),\n  v.checkAsync(isEmailPresent, 'The email is not in the database.')\n);\nconst result = await v.safeParseAsync(StoredEmailSchema, 'jane@example.com');\n\nif (result.success) {\n  const storedEmail = result.output;\n} else {\n  console.error(result.issues);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Validation with Zod in TypeScript\nDESCRIPTION: This example shows the same login schema validation implemented with Zod. It demonstrates Zod's method-chaining approach which results in a larger bundle size of 13.5 kB compared to Valibot's more modular approach.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/comparison/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { object, string } from 'zod'; // 13.5 kB\n\nconst LoginSchema = object({\n  email: string()\n    .min(1, 'Please enter your email.')\n    .email('The email address is badly formatted.'),\n  password: string()\n    .min(1, 'Please enter your password.')\n    .min(8, 'Your password must have 8 characters or more.'),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Partial Object Schema with Rest using objectWithRest in TypeScript\nDESCRIPTION: Shows how to create a partial object schema where all entries are optional, including a rest schema for undefined properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/objectWithRest/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialObjectSchema = partial(\n  objectWithRest(\n    {\n      key1: string(),\n      key2: number(),\n    },\n    v.undefined()\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: URL Validation Schema with Valibot\nDESCRIPTION: Schema to validate a URL by ensuring it's a string with a custom error message and checking that it follows a valid URL format.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/string/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst UrlSchema = v.pipe(\n  v.string('A URL must be string.'),\n  v.url('The URL is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating User Details with Nested variantAsync in TypeScript\nDESCRIPTION: This example demonstrates a more complex use case of variantAsync, creating a schema for validating user details. It includes nested variant schemas and async validation for email, username, and user ID.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/variantAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isRegisteredEmail, isRegisteredUsername, isValidUserId } from '~/api';\n\nconst UserSchema = v.variantAsync('type', [\n  // Assume this schema is from a different file and reused here.\n  v.variantAsync('type', [\n    v.objectAsync({\n      type: v.literal('email'),\n      email: v.pipeAsync(\n        v.string(),\n        v.email(),\n        v.checkAsync(isRegisteredEmail, 'The email is not registered.')\n      ),\n    }),\n    v.objectAsync({\n      type: v.literal('username'),\n      username: v.pipeAsync(\n        v.string(),\n        v.nonEmpty(),\n        v.checkAsync(isRegisteredUsername, 'The username is not registered.')\n      ),\n    }),\n  ]),\n  v.objectAsync({\n    type: v.literal('userId'),\n    userId: v.pipeAsync(\n      v.string(),\n      v.uuid(),\n      v.checkAsync(isValidUserId, 'The user id is not valid.')\n    ),\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Inferring Intersect Output Types with Valibot\nDESCRIPTION: This example demonstrates how to infer the output type of intersected object schemas using Valibot's InferIntersectOutput utility. The code creates two object schemas with transformed string properties and then uses InferIntersectOutput to infer their combined type after intersection.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferIntersectOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object schemas\nconst ObjectSchemas = [\n  v.object({\n    key1: v.pipe(\n      v.string(),\n      v.transform((input) => input.length)\n    ),\n  }),\n  v.object({\n    key2: v.pipe(\n      v.string(),\n      v.transform((input) => input.length)\n    ),\n  }),\n];\n\n// Infer object intersect output type\ntype ObjectOutput = v.InferIntersectOutput<typeof ObjectSchemas>; // { key1: number } & { key2: number }\n```\n\n----------------------------------------\n\nTITLE: Implementing Slug Validation Schema - TypeScript\nDESCRIPTION: Complete example showing how to create a validation schema for slugs using pipe() to combine multiple validations including string type check, non-empty check, slug format validation, and maximum length constraint.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/slug/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SlugSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please provide a slug.'),\n  v.slug('The slug is badly formatted.'),\n  v.maxLength(100, 'Your slug is too long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Using Required Method in Valibot (TypeScript)\nDESCRIPTION: Demonstrates how to use the 'required' method to create schemas with required entries. It shows two variants: one for making all keys required and another for selecting specific keys to be required.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/required/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst AllKeysSchema = v.required<TSchema, TMessage>(schema, message);\nconst SelectedKeysSchema = v.required<TSchema, TKeys, TMessage>(\n  schema,\n  keys,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Date Schema with Minimum Value Constraint\nDESCRIPTION: Example of creating a date schema that enforces a minimum date value of today using pipe and toMinValue validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/date/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinDateSchema = v.pipe(v.date(), v.toMinValue(new Date()));\n```\n\n----------------------------------------\n\nTITLE: Tuple Schema with Email Validation and Rest Boolean Items\nDESCRIPTION: Example of creating a tuple schema that validates a number, an email with async database check, and allows additional boolean values as rest items.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/tupleWithRestAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst TupleSchemaWithRest = v.tupleWithRestAsync(\n  [\n    v.number(),\n    v.pipeAsync(\n      v.string(),\n      v.email(),\n      v.checkAsync(isEmailPresent, 'The email is not in the database.')\n    ),\n  ],\n  v.boolean()\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Validation with Valibot in TypeScript\nDESCRIPTION: This example demonstrates how to create a login schema using Valibot with email and password validation. The snippet shows Valibot's modular approach which results in a minimal bundle size of only 1.37 kB.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/comparison/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot'; // 1.37 kB\n\nconst LoginSchema = v.object({\n  email: v.pipe(\n    v.string(),\n    v.nonEmpty('Please enter your email.'),\n    v.email('The email address is badly formatted.')\n  ),\n  password: v.pipe(\n    v.string(),\n    v.nonEmpty('Please enter your password.'),\n    v.minLength(8, 'Your password must have 8 characters or more.')\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Async Email Validation in TypeScript\nDESCRIPTION: This example shows how to use parseAsync with a custom asynchronous email validation schema. It demonstrates error handling with try/catch and uses pipeAsync for combining multiple validations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/parseAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\ntry {\n  const StoredEmailSchema = v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  );\n  const storedEmail = await v.parseAsync(StoredEmailSchema, 'jane@example.com');\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.error(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Number Range Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a number within a specific range, from 10 to 20.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/number/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberRangeSchema = v.pipe(v.number(), v.minValue(10), v.maxValue(20));\n```\n\n----------------------------------------\n\nTITLE: Email Validation Schema with Valibot\nDESCRIPTION: Schema to validate an email using a pipe of multiple validators: ensuring it's a string, not empty, properly formatted as an email, and within a maximum length of 30 characters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/string/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please enter your email.'),\n  v.email('The email is badly formatted.'),\n  v.maxLength(30, 'Your email is too long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Order Schema Validation Example\nDESCRIPTION: Complex example showing how to validate an order schema with free delivery requirements using rawTransformAsync. Demonstrates custom validation logic, error handling, and data transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/rawTransformAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getTotalAmount } from '~/api';\nimport { FREE_DELIVERY_MIN_AMOUNT } from '~/constants';\n\nconst OrderSchema = v.pipeAsync(\n  v.object({\n    cart: v.array(\n      v.object({\n        itemId: v.pipe(v.string(), v.uuid()),\n        quantity: v.pipe(v.number(), v.integer(), v.minValue(1)),\n      })\n    ),\n    expectsFreeDelivery: v.optional(v.boolean(), false),\n  }),\n  v.rawTransformAsync(\n    async ({ dataset: { value: input }, addIssue, NEVER }) => {\n      const total = await getTotalAmount(input.cart);\n      if (input.expectsFreeDelivery && total < FREE_DELIVERY_MIN_AMOUNT) {\n        addIssue({\n          label: 'order',\n          expected: `>=${FREE_DELIVERY_MIN_AMOUNT}`,\n          received: `${total}`,\n          message: `The total amount must be at least $${FREE_DELIVERY_MIN_AMOUNT} for free delivery.`,\n          path: [\n            {\n              type: 'object',\n              origin: 'value',\n              input,\n              key: 'cart',\n              value: input.cart,\n            },\n          ],\n        });\n        return NEVER;\n      }\n      return { ...input, total };\n    }\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Image File Validation Schema with Valibot\nDESCRIPTION: Example of creating a schema to validate image files. It uses pipe to combine multiple validations: ensuring the input is a file, validating mime types (JPEG or PNG), and checking file size (less than 10 MB).\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/file/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ImageSchema = v.pipe(\n  v.file('Please select an image file.'),\n  v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.'),\n  v.maxSize(1024 * 1024 * 10, 'Please select a file smaller than 10 MB.')\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing User Group Validation Schema with Raw Check Async\nDESCRIPTION: Complex example showing how to use rawCheckAsync to validate user additions to a group by checking for existing members asynchronously. The schema validates UUIDs and usernames while ensuring users aren't already in the group.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/rawCheckAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAlreadyInGroup } from '~/api';\n\nconst AddUsersSchema = v.pipeAsync(\n  v.object({\n    groupId: v.pipe(v.string(), v.uuid()),\n    usernames: v.array(v.pipe(v.string(), v.nonEmpty())),\n  }),\n  v.rawCheckAsync(async ({ dataset, addIssue }) => {\n    if (dataset.typed) {\n      await Promise.all(\n        dataset.value.usernames.map(async (username, index) => {\n          if (await isAlreadyInGroup(username, dataset.value.groupId)) {\n            addIssue({\n              received: username,\n              message: 'The user is already in the group.',\n              path: [\n                {\n                  type: 'object',\n                  origin: 'value',\n                  input: dataset.value,\n                  key: 'usernames',\n                  value: dataset.value.usernames,\n                },\n                {\n                  type: 'array',\n                  origin: 'value',\n                  input: dataset.value.usernames,\n                  key: index,\n                  value: username,\n                },\n              ],\n            });\n          }\n        })\n      );\n    }\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Validating New User Object Schema - TypeScript Implementation\nDESCRIPTION: Complex example showing how to create an async object schema for validating new user details, including email validation, string length constraints, and optional fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/objectAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is already in use by another user.')\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n  avatar: v.optional(v.pipe(v.string(), v.url())),\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Schema Types with minValue Validation in TypeScript\nDESCRIPTION: Shows how to use the minValue validation with different schema types including string, number, bigint, and date in a pipeline.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst StringSchema = v.pipe(v.string(), v.minValue('foo'));\nconst NumberSchema = v.pipe(v.number(), v.minValue(1234));\nconst BigintSchema = v.pipe(v.bigint(), v.minValue(1234n));\nconst DateSchema = v.pipe(v.date(), v.minValue(new Date()));\n```\n\n----------------------------------------\n\nTITLE: Implementing minBytes Validation in a Schema\nDESCRIPTION: This example shows how to use minBytes in a schema to validate a string with a minimum of 64 bytes. It combines string validation with the minBytes action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minBytes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinBytesSchema = v.pipe(\n  v.string(),\n  v.minBytes(64, 'The string must contain at least 64 bytes.')\n);\n```\n\n----------------------------------------\n\nTITLE: URL Schema Validation Example in TypeScript\nDESCRIPTION: Complete example showing URL validation with multiple validation rules including string type checking, non-empty validation, URL format validation, and domain suffix validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/url/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UrlSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please enter your url.'),\n  v.url('The url is badly formatted.'),\n  v.endsWith('.com', 'Only \".com\" domains are allowed.')\n);\n```\n\n----------------------------------------\n\nTITLE: Email Schema Validation Example in TypeScript\nDESCRIPTION: Complete example showing how to create a schema for email validation with multiple validation rules including string type, non-empty check, email format validation, and maximum length constraint.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/email/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please enter your email.'),\n  v.email('The email is badly formatted.'),\n  v.maxLength(30, 'Your email is too long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Default Schema Parsing in Valibot\nDESCRIPTION: Demonstrates basic schema validation using parse() method that throws ValiError for invalid inputs. Uses email validation as an example.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/parse-data/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntry {\n  const EmailSchema = v.pipe(v.string(), v.email());\n  const email = v.parse(EmailSchema, 'jane@example.com');\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.log(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Using forward Method for Error Propagation\nDESCRIPTION: Demonstrates how to use the forward method to associate validation errors with specific fields in a form. This example shows a registration form that validates matching passwords and forwards any error to the second password field.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/methods/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst RegisterSchema = v.pipe(\n  v.object({\n    email: v.pipe(\n      v.string(),\n      v.nonEmpty('Please enter your email.'),\n      v.email('The email address is badly formatted.')\n    ),\n    password1: v.pipe(\n      v.string(),\n      v.nonEmpty('Please enter your password.'),\n      v.minLength(8, 'Your password must have 8 characters or more.')\n    ),\n    password2: v.string(),\n  }),\n  v.forward(\n    v.partialCheck(\n      [['password1'], ['password2']],\n      (input) => input.password1 === input.password2,\n      'The two passwords do not match.'\n    ),\n    ['password2']\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Transformation with transform Function in TypeScript\nDESCRIPTION: Demonstrates how to implement custom transformation logic in a pipeline using the transform function to convert values below 10 to null.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.transform((input) => (input < 10 ? null : input))\n);\n```\n\n----------------------------------------\n\nTITLE: Object Schema with Rest Validation in TypeScript\nDESCRIPTION: Shows how to create an object schema that handles additional properties with a specific validation schema for unknown entries.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ObjectSchema = v.objectWithRest(\n  {\n    key1: v.string(),\n    key2: v.number(),\n  },\n  v.null()\n);\n```\n\n----------------------------------------\n\nTITLE: String Length Transform - TypeScript\nDESCRIPTION: Example of transforming a string input to its length using pipe and transform actions. Validates input as string first, then transforms to number length.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/transform/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringLengthSchema = v.pipe(\n  v.string(),\n  v.transform((input) => input.length)\n);\n```\n\n----------------------------------------\n\nTITLE: Using the Parse Method with a Schema in Valibot\nDESCRIPTION: This example shows how to use the parse method to validate unknown data against a defined schema. It creates a function that takes unknown data and returns a parsed book object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/mental-model/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst BookSchema = v.object({â€¦});\n\nfunction createBook(data: unknown) {\n  return v.parse(BookSchema, data);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Metadata to Schema with Title and Description in TypeScript\nDESCRIPTION: Shows how to add metadata to a schema using title and description actions in a pipeline, which is useful for documentation and AI tools.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst UsernameSchema = v.pipe(\n  v.string(),\n  v.regex(/^[a-z0-9_-]{4,16}$/iu),\n  v.title('Username'),\n  v.description(\n    'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Email Validation Schema with Raw Check - TypeScript\nDESCRIPTION: Complex example showing how to use rawCheck to validate that a primary email is not duplicated in other emails array. The validation adds custom issues with specific paths for invalid entries.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawCheck/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailsSchema = v.pipe(\n  v.object({\n    primaryEmail: v.pipe(v.string(), v.email()),\n    otherEmails: v.array(v.pipe(v.string(), v.email())),\n  }),\n  v.rawCheck(({ dataset, addIssue }) => {\n    if (dataset.typed) {\n      dataset.value.otherEmails.forEach((otherEmail, index) => {\n        if (otherEmail === dataset.value.primaryEmail) {\n          addIssue({\n            message: 'This email is already being used as the primary email.',\n            path: [\n              {\n                type: 'object',\n                origin: 'value',\n                input: dataset.value,\n                key: 'otherEmails',\n                value: dataset.value.otherEmails,\n              },\n              {\n                type: 'array',\n                origin: 'value',\n                input: dataset.value.otherEmails,\n                key: index,\n                value: otherEmail,\n              },\n            ],\n          });\n        }\n      });\n    }\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing ISO Time Schema with Validation\nDESCRIPTION: Shows how to create a schema that validates a string as an ISO time format using pipe and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoTime/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoTimeSchema = v.pipe(\n  v.string(),\n  v.isoTime('The time is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: JSON Data Schema with Recursive Validation\nDESCRIPTION: Schema for validating JSON data with recursive structures. This example shows how lazy() can be used to create a schema that handles all possible JSON value types, including nested objects and arrays.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/lazy/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntype JsonData =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: JsonData }\n  | JsonData[];\n\nconst JsonSchema: v.GenericSchema<JsonData> = v.lazy(() =>\n  v.union([\n    v.string(),\n    v.number(),\n    v.boolean(),\n    v.null(),\n    v.record(v.string(), JsonSchema),\n    v.array(JsonSchema),\n  ])\n);\n```\n\n----------------------------------------\n\nTITLE: Record Schema with Specific Keys in TypeScript\nDESCRIPTION: Demonstrates how to create a record schema with specific key validation using picklist.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst RecordSchema = v.record(v.picklist(['key1', 'key2']), v.number()); // { key1?: number; key2?: number }\n```\n\n----------------------------------------\n\nTITLE: Normalizing String Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that normalizes a string using Valibot. It combines the string schema with the normalize action using the pipe method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/normalize/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.normalize());\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validation with check Function in TypeScript\nDESCRIPTION: Demonstrates how to implement custom validation logic in a pipeline using the check function with a custom validator function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { isValidUsername } from '~/utils';\n\nconst UsernameSchema = v.pipe(\n  v.string(),\n  v.check(isValidUsername, 'This username is invalid.')\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Password Matching Validation with forward Method\nDESCRIPTION: A complete registration schema example that uses forward to ensure two password fields match, forwarding the validation error to the second password field when there's a mismatch.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/forward/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst RegisterSchema = v.pipe(\n  v.object({\n    email: v.pipe(\n      v.string(),\n      v.nonEmpty('Please enter your email.'),\n      v.email('The email address is badly formatted.')\n    ),\n    password1: v.pipe(\n      v.string(),\n      v.nonEmpty('Please enter your password.'),\n      v.minLength(8, 'Your password must have 8 characters or more.')\n    ),\n    password2: v.string(),\n  }),\n  v.forward(\n    v.partialCheck(\n      [['password1'], ['password2']],\n      (input) => input.password1 === input.password2,\n      'The two passwords do not match.'\n    ),\n    ['password2']\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Dates Not Equal to a Specific Date\nDESCRIPTION: Schema using notValue to validate that a date is not equal to January 1, 2000. It first validates that the input is a date, then ensures it is not equal to the start of 2000.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.notValue(new Date('2000-01-01'), 'The date must not be the start of 2000.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Not Value Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a not value validation action using Valibot. It defines the structure for validating that an input does not match a specific requirement value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.notValue<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Donation Schema with intersectAsync in Valibot\nDESCRIPTION: A practical example of using intersectAsync to create a donation validation schema that combines multiple object schemas including asynchronous validation for organization existence.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/intersectAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isOrganizationPresent } from '~/api';\n\nconst DonationSchema = v.intersectAsync([\n  v.objectAsync({\n    organizationId: v.pipeAsync(\n      v.string(),\n      v.uuid(),\n      v.checkAsync(\n        isOrganizationPresent,\n        'The organization is not in the database.'\n      )\n    ),\n  }),\n  // Assume the schemas below are from different files and are reused here\n  v.object({\n    amount: v.pipe(v.number(), v.minValue(100)),\n    message: v.pipe(v.string(), v.nonEmpty()),\n  }),\n  v.object({\n    amount: v.pipe(v.number(), v.maxValue(1_000_000)),\n    message: v.pipe(v.string(), v.maxLength(500)),\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Base64 String Schema in Valibot\nDESCRIPTION: Demonstrates how to create a schema that validates a Base64 string by piping a string validation with a Base64 format validation. The example includes a custom error message for invalid Base64 formatting.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/base64/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Base64Schema = v.pipe(v.string(), v.base64('The data is badly encoded.'));\n```\n\n----------------------------------------\n\nTITLE: Defining Exact Optional Object Entries with Valibot\nDESCRIPTION: This example shows how to create an object schema with exact optional entries. It demonstrates using default values, including a function that returns a new Date instance each time the input is undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/exactOptional/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalEntrySchema = v.object({\n  key1: v.exactOptional(v.string()),\n  key2: v.exactOptional(v.string(), \"I'm the default!\"),\n  key3: v.exactOptional(v.date(), () => new Date()),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Optional Schemas in Objects with Valibot\nDESCRIPTION: Shows how to use optional schemas within object schemas in Valibot, which marks the value as optional in TypeScript with a question mark.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/optionals/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst OptionalKeySchema = v.object({ key: v.optional(v.string()) }); // { key?: string | undefined }\n```\n\n----------------------------------------\n\nTITLE: Simple Tuple Schema Example in TypeScript\nDESCRIPTION: Example of creating a strict tuple schema that validates a tuple with a string and number type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictTuple/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleTupleSchema = v.strictTuple([v.string(), v.number()]);\n```\n\n----------------------------------------\n\nTITLE: Inferring Input Types with InferInput in TypeScript\nDESCRIPTION: Example of using the InferInput utility type to extract the input type from a validation schema. This creates a TypeScript type that represents the structure required for valid input data.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/infer-types/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst LoginSchema = v.object({\n  email: v.string(),\n  password: v.string(),\n});\n\ntype LoginInput = v.InferInput<typeof LoginSchema>; // { email: string; password: string }\n```\n\n----------------------------------------\n\nTITLE: Creating an Image Validation Schema in TypeScript\nDESCRIPTION: An example schema that validates an image file by combining the blob schema with mime type and file size validation. It checks that the file is a Blob, is either JPEG or PNG format, and is less than 10MB in size.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/blob/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ImageSchema = v.pipe(\n  v.blob('Please select an image file.'),\n  v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.'),\n  v.maxSize(1024 * 1024 * 10, 'Please select a file smaller than 10 MB.')\n);\n```\n\n----------------------------------------\n\nTITLE: Inferring Output Types with InferOutput in TypeScript\nDESCRIPTION: Example of using the InferOutput utility type to extract the output type from a validation schema with transformations. This creates a TypeScript type that represents the structure of data after validation and transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/infer-types/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { hashPassword } from '~/utils';\n\nconst LoginSchema = v.pipe(\n  v.object({\n    email: v.string(),\n    password: v.pipe(v.string(), v.transform(hashPassword)),\n  }),\n  v.transform((input) => {\n    return {\n      ...input,\n      timestamp: new Date().toISOString(),\n    };\n  })\n);\n\ntype LoginOutput = v.InferOutput<typeof LoginSchema>; // { email: string; password: string; timestamp: string }\n```\n\n----------------------------------------\n\nTITLE: Creating a Description Action in Valibot\nDESCRIPTION: Basic syntax for creating a description metadata action in Valibot. The action adds descriptive information to a schema that can be useful for documentation or AI tools.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/description/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.description<TInput, TDescription>(description_);\n```\n\n----------------------------------------\n\nTITLE: Markdown Navigation Structure for Valibot Docs\nDESCRIPTION: Hierarchical markdown structure defining the navigation and organization of Valibot's documentation, including links to various guides and sections.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/menu.md#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Guides\n\n## Get started\n\n- [Introduction](/guides/introduction/)\n- [Installation](/guides/installation/)\n- [Quick start](/guides/quick-start/)\n- [Use cases](/guides/use-cases/)\n- [Comparison](/guides/comparison/)\n- [Ecosystem](/guides/ecosystem/)\n\n## Main concepts\n\n- [Mental model](/guides/mental-model/)\n- [Schemas](/guides/schemas/)\n- [Pipelines](/guides/pipelines/)\n- [Parse data](/guides/parse-data/)\n- [Infer types](/guides/infer-types/)\n- [Methods](/guides/methods/)\n- [Issues](/guides/issues/)\n\n## Schemas\n\n- [Objects](/guides/objects/)\n- [Arrays](/guides/arrays/)\n- [Optionals](/guides/optionals/)\n- [Enums](/guides/enums/)\n- [Unions](/guides/unions/)\n- [Intersects](/guides/intersections/)\n- [Other](/guides/other/)\n\n## Advanced\n\n- [Naming](/guides/naming-convention/)\n- [Async](/guides/async-validation/)\n- [JSON Schema](/guides/json-schema/)\n- [i18n](/guides/internationalization/)\n\n## Migration\n\n- [To v0.31.0](/guides/migrate-to-v0.31.0/)\n- [From Zod](/guides/migrate-from-zod/)\n- [From Ajv](/guides/migrate-from-ajv/)\n- [From Joi](/guides/migrate-from-joi/)\n- [From Yup](/guides/migrate-from-yup/)\n```\n\n----------------------------------------\n\nTITLE: Email Schema Validation Example in TypeScript\nDESCRIPTION: Complete example showing how to create an email validation schema using pipe, string validation, non-empty check, RFC email validation, and maximum length constraint.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rfcEmail/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(\n  v.string(),\n  v.nonEmpty('Please enter your email.'),\n  v.rfcEmail('The email is badly formatted.'),\n  v.maxLength(30, 'Your email is too long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Add User Schema Implementation Example\nDESCRIPTION: Complex example showing how to use nonOptionalAsync in combination with other schemas to validate user addition details. Includes group ID validation and email validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonOptionalAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isGroupPresent } from '~/api';\n\nconst AddUserSchema = v.objectAsync({\n  groupId: v.nonOptionalAsync(\n    // Assume this schema is from a different file and reused here.\n    v.optionalAsync(\n      v.pipeAsync(\n        v.string(),\n        v.uuid(),\n        v.checkAsync(\n          isGroupPresent,\n          'The group is not present in the database.'\n        )\n      )\n    )\n  ),\n  userEmail: v.pipe(v.string(), v.email()),\n});\n```\n\n----------------------------------------\n\nTITLE: Update User Schema Example with Valibot\nDESCRIPTION: Practical example demonstrating how to create a partial user schema for updates using partialAsync with email, username and password validation\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/partialAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailAbsent, isUsernameAbsent } from '~/api';\n\nconst UserSchema = v.objectAsync({\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailAbsent, 'The email is already in the database.')\n  ),\n  username: v.pipeAsync(\n    v.string(),\n    v.nonEmpty(),\n    v.checkAsync(isUsernameAbsent, 'The username is already in the database.')\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\nconst UpdateUserSchema = v.partialAsync(UserSchema);\n\n/*\n  { \n    email?: string;\n    username?: string; \n    password?: string;\n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Converting Valibot Email Schema to JSON Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the toJsonSchema function from @valibot/to-json-schema to convert a Valibot email schema to JSON Schema format. It imports necessary functions, creates a Valibot email schema, and then converts it to JSON Schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/json-schema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\nconst ValibotEmailSchema = v.pipe(v.string(), v.email());\nconst JsonEmailSchema = toJsonSchema(ValibotEmailSchema);\n// -> { type: 'string', format: 'email' }\n```\n\n----------------------------------------\n\nTITLE: New User Schema with Transformation - TypeScript\nDESCRIPTION: Complex schema that validates user details with nested async validation and transforms the output to a string format.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/pipeAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.pipeAsync(\n  v.objectAsync({\n    firstName: v.pipe(v.string(), v.nonEmpty(), v.maxLength(30)),\n    lastName: v.pipe(v.string(), v.nonEmpty(), v.maxLength(30)),\n    username: v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.maxLength(30),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    ),\n  }),\n  v.transform(\n    ({ firstName, lastName, username }) =>\n      `${username} (${firstName} ${lastName})`\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining UUID Schema with Custom Error Message in TypeScript\nDESCRIPTION: Shows how to create a schema that validates a string as a UUID using Valibot's pipe and uuid functions. It combines string validation with UUID format checking and includes a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/uuid/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UuidSchema = v.pipe(v.string(), v.uuid('The UUID is badly formatted.'));\n```\n\n----------------------------------------\n\nTITLE: Validating Array Content in Valibot\nDESCRIPTION: Example of creating a schema that validates the content of a string array, ensuring it includes 'foo' and excludes 'bar'.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/array/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArrayContentSchema = v.pipe(\n  v.array(v.string()),\n  v.includes('foo'),\n  v.excludes('bar')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Image File MIME Types in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating image files. It uses the pipe method to combine a blob validation with a MIME type check for JPEG and PNG formats.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mimeType/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ImageSchema = v.pipe(\n  v.blob(),\n  v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining PipeAction Interface in TypeScript\nDESCRIPTION: The PipeAction interface is defined with three generic types: TInput for the input type, TOutput for the output type, and TIssue for the issue type. The interface itself is not shown in the provided content, but it's referenced as a property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PipeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface PipeAction<TInput, TOutput, TIssue> {\n  // Interface definition not provided in the content\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Array Schema in Valibot\nDESCRIPTION: Basic syntax for creating an array schema using Valibot. This function validates that the input is an array containing items of the specified type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/array/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.array<TItem, TMessage>(item, message);\n```\n\n----------------------------------------\n\nTITLE: Updating Import Statements in TypeScript\nDESCRIPTION: Shows how to change imports from Zod to Valibot and replace the z namespace with v.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nimport { z } from 'zod';\nconst Schema = z.object({ key: z.string() });\n\n// To this\nimport * as v from 'valibot';\nconst Schema = v.object({ key: v.string() });\n```\n\n----------------------------------------\n\nTITLE: Validating Message Objects with variantAsync in TypeScript\nDESCRIPTION: This example creates a schema for validating message objects. It uses variantAsync to handle different receiver types (group or user) and includes async validation for group and user receivers.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/variantAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isValidGroupReceiver, isValidUserReceiver } from '~/api';\n\nconst MessageSchema = v.objectAsync({\n  message: v.pipe(v.string(), v.nonEmpty()),\n  receiver: v.variantAsync('type', [\n    v.objectAsync({\n      type: v.literal('group'),\n      groupId: v.pipeAsync(\n        v.string(),\n        v.uuid(),\n        v.checkAsync(isValidGroupReceiver, 'The group cannot receive messages.')\n      ),\n    }),\n    v.objectAsync({\n      type: v.literal('user'),\n      email: v.pipeAsync(\n        v.string(),\n        v.email(),\n        v.checkAsync(isValidUserReceiver, 'The user cannot receive messages.')\n      ),\n    }),\n  ]),\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Unique Array Items with checkItems\nDESCRIPTION: Example schema that validates an array of strings to ensure it contains no duplicate items. It uses the checkItems action to compare each item's index with its first occurrence index.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/checkItems/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.string()),\n  v.checkItems(\n    (item, index, array) => array.indexOf(item) === index,\n    'Duplicate items are not allowed.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Recursive Transaction List Schema in TypeScript\nDESCRIPTION: Example of using lazyAsync to create a recursive schema for validating transactions. Due to TypeScript limitations, input and output types for recursive schemas must be explicitly specified using GenericSchemaAsync.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/lazyAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isTransactionValid } from '~/api';\n\ntype Transaction = {\n  transactionId: string;\n  next: Transaction | null;\n};\n\nconst TransactionSchema: v.GenericSchemaAsync<Transaction> = v.objectAsync({\n  transactionId: v.pipeAsync(\n    v.string(),\n    v.uuid(),\n    v.checkAsync(isTransactionValid, 'The transaction is not valid.')\n  ),\n  next: v.nullableAsync(v.lazyAsync(() => TransactionSchema)),\n});\n```\n\n----------------------------------------\n\nTITLE: Type Guard Validation\nDESCRIPTION: Demonstrates using type guards with is() method for runtime type checking, useful for simple validation cases without transformation needs.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/parse-data/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst data: unknown = 'jane@example.com';\n\nif (v.is(EmailSchema, data)) {\n  const email = data; // string\n}\n```\n\n----------------------------------------\n\nTITLE: Email Validation Example with Valibot's is Method\nDESCRIPTION: An example showing how to use the 'is' method as a type guard. It validates if a value is an email string, and when validation passes, TypeScript recognizes the narrowed type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/is/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst data: unknown = 'jane@example.com';\n\nif (v.is(EmailSchema, data)) {\n  const email = data; // string\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Set Schema with Valibot\nDESCRIPTION: Example of creating a schema to validate a Set containing object values. Each object in the Set must have a 'key' property that is a string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/set/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSetSchema = v.set(v.object({ key: v.string() }));\n```\n\n----------------------------------------\n\nTITLE: Using assert Method in Valibot (TypeScript)\nDESCRIPTION: Basic usage syntax of the Valibot assert method, which checks if an input matches a schema. This method accepts a schema and input parameter and acts as a type guard in TypeScript.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/assert/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.assert<TSchema>(schema, input);\n```\n\n----------------------------------------\n\nTITLE: Date Schema Using Union in Valibot\nDESCRIPTION: Schema to validate either a Date object or an ISO timestamp string using union. It combines a date schema with a piped string schema that has ISO timestamp validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/union/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.union([v.date(), v.pipe(v.string(), v.isoTimestamp())]);\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Value Schemas in TypeScript with Valibot\nDESCRIPTION: Shows how to create schemas for complex data types such as arrays, objects, tuples, maps, and more using Valibot. Includes various object-related methods and special cases.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/schemas/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ArraySchema = v.array(v.string()); // string[]\nconst BlobSchema = v.blob(); // Blob\nconst DateSchema = v.date(); // Date\nconst FileSchema = v.file(); // File\nconst FunctionSchema = v.function(); // (...args: unknown[]) => unknown\nconst LooseObjectSchema = v.looseObject({ key: v.string() }); // { key: string }\nconst LooseTupleSchema = v.looseTuple([v.string(), v.number()]); // [string, number]\nconst MapSchema = v.map(v.string(), v.number()); // Map<string, number>\nconst ObjectSchema = v.object({ key: v.string() }); // { key: string }\nconst ObjectWithRestSchema = v.objectWithRest({ key: v.string() }, v.null()); // { key: string } & { [key: string]: null }\nconst PromiseSchema = v.promise(); // Promise<unknown>\nconst RecordSchema = v.record(v.string(), v.number()); // Record<string, number>\nconst SetSchema = v.set(v.number()); // Set<number>\nconst StrictObjectSchema = v.strictObject({ key: v.string() }); // { key: string }\nconst StrictTupleSchema = v.strictTuple([v.string(), v.number()]); // [string, number]\nconst TupleSchema = v.tuple([v.string(), v.number()]); // [string, number]\nconst TupleWithRestSchema = v.tupleWithRest([v.string(), v.number()], v.null()); // [string, number, ...null[]]\n```\n\n----------------------------------------\n\nTITLE: Declaring DescriptionAction Interface with Generics\nDESCRIPTION: Interface definition showing the structure of the DescriptionAction type with its generic parameters TInput and TDescription, along with its core properties like type, reference, and description.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DescriptionAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DescriptionAction<TInput, TDescription> {\n  type: string;\n  reference: TInput;\n  description: TDescription;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Details Schema Validation with partialCheckAsync\nDESCRIPTION: An example schema that validates message details including sender information, group ID, and message content. Uses partialCheckAsync with forwardAsync to verify that the sender is a member of the specified group.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/partialCheckAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSenderInTheGroup } from '~/api';\n\nconst MessageDetailsSchema = v.pipeAsync(\n  v.object({\n    sender: v.object({\n      name: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n      email: v.pipe(v.string(), v.email()),\n    }),\n    groupId: v.pipe(v.string(), v.uuid()),\n    message: v.pipe(v.string(), v.nonEmpty(), v.maxLength(500)),\n  }),\n  v.forwardAsync(\n    v.partialCheckAsync(\n      [['sender', 'email'], ['groupId']],\n      (input) =>\n        isSenderInTheGroup({\n          senderEmail: input.sender.email,\n          groupId: input.groupId,\n        }),\n      'The sender is not in the group.'\n    ),\n    ['sender', 'email']\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an IPv4 Validation Action in Valibot\nDESCRIPTION: Syntax for creating an IPv4 validation action in Valibot. The function takes an optional custom error message and returns a validation action that can be used in pipes or other validation constructs.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ipv4/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.ipv4<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Word Map Schema with User Validation\nDESCRIPTION: Demonstrates creating an object schema for a word map with specific validated properties ($userId and $targetLanguage) while allowing the rest of the properties to be string values. Includes an async validation for user permissions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/objectWithRestAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUserAllowedToMutate } from '~/api';\n\n// Assume the rest of the keys are always English words\nconst WordMapSchema = v.objectWithRestAsync(\n  {\n    $userId: v.pipeAsync(\n      v.string(),\n      v.regex(/^[a-z0-9]{12}$/i),\n      v.checkAsync(\n        isUserAllowedToMutate,\n        'The user is not allowed to change the word map.'\n      )\n    ),\n    $targetLanguage: v.union([\n      v.literal('hindi'),\n      v.literal('spanish'),\n      v.literal('french'),\n    ]),\n  },\n  v.string()\n);\n```\n\n----------------------------------------\n\nTITLE: Date Schema with gtValue Validation\nDESCRIPTION: Example of creating a date validation schema that ensures the date is after January 1st, 2000 using pipe and gtValue validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/gtValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.gtValue(\n    new Date('2000-01-01'),\n    'The date must be greater than 1st January 2000.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Profile Table Schema with Metadata\nDESCRIPTION: Example showing how to create a profile table schema with custom metadata for table name, primary key, and indexes using pipe and object validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/metadata/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ProfileTableSchema = v.pipe(\n  v.object({\n    username: v.pipe(v.string(), v.nonEmpty()),\n    email: v.pipe(v.string(), v.email()),\n    avatar: v.pipe(v.string(), v.url()),\n    description: v.pipe(v.string(), v.maxLength(500)),\n  }),\n  v.metadata({\n    table: 'profiles',\n    primaryKey: 'username',\n    indexes: ['email'],\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Global Translations in Valibot\nDESCRIPTION: Shows how to set custom translations at different hierarchy levels using setGlobalMessage, setSchemaMessage, and setSpecificMessage functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/internationalization/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// Set the translation globally (can be used as a fallback)\nv.setGlobalMessage((issue) => `Invalid input: ...`, 'en');\n\n// Set the translation globally for every schema functions\nv.setSchemaMessage((issue) => `Invalid type: ...`, 'en');\n\n// Set the translation globally for a specific function\nv.setSpecificMessage(v.minLength, (issue) => `Invalid length: ...`, 'en');\n```\n\n----------------------------------------\n\nTITLE: Creating a String Schema with Valibot\nDESCRIPTION: Basic syntax for creating a string schema with an optional custom error message. The schema validates that the input is a string type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/string/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.string<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating a String Schema with Valibot\nDESCRIPTION: Basic syntax for creating a string schema with an optional custom error message. The schema validates that the input is a string type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/string/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.string<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Validating Minimum Array Length in TypeScript\nDESCRIPTION: This example demonstrates how to create a schema that validates an array with a minimum length of 5 items using the minLength validation action in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minLength/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinArraySchema = v.pipe(\n  v.array(v.number()),\n  v.minLength(5, 'The array must contain 5 numbers or more.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating HTTPS URL Schema with startsWith in Valibot\nDESCRIPTION: Example of using the startsWith validation function to ensure a URL starts with 'https://'. This is combined with string and url validations using the pipe method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/startsWith/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst HttpsUrlSchema = v.pipe(v.string(), v.url(), v.startsWith('https://'));\n```\n\n----------------------------------------\n\nTITLE: Number Schema Validation with Value Check\nDESCRIPTION: Example schema that validates a number must exactly equal 100, using pipe to combine number validation with value validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/value/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.value(100, 'The number must be 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining ParserAsync Interface with Generics\nDESCRIPTION: The ParserAsync interface definition that specifies two generic type parameters TSchema and TConfig, along with the parser function signature that accepts a schema and configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ParserAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ParserAsync<TSchema, TConfig> {\n  (schema: TSchema, config?: TConfig): Promise<unknown>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullish Schema in Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a nullish schema using Valibot. It wraps another schema and optionally provides a default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullish/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nullish<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Defining UnknownPathItem Interface Structure\nDESCRIPTION: Interface definition for UnknownPathItem that contains properties for type, origin, input, key, and value. The interface is used to track path information during validation, where input may differ from the issue input due to parent schema transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnknownPathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  type: string;\n  origin: string;\n  input: unknown;\n  key: unknown;\n  value: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getDefault Method - Basic Syntax\nDESCRIPTION: Basic syntax for using the getDefault method to retrieve the default value from a schema with optional type parameters and configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getDefault/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = v.getDefault<TSchema>(schema, dataset, config);\n```\n\n----------------------------------------\n\nTITLE: Creating a Pixel String Schema with Custom Validation\nDESCRIPTION: Example of creating a schema that validates if a string follows the pixel format (number followed by 'px'). Uses custom validation with a regular expression test.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/custom/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst PixelStringSchema = v.custom<`${number}px`>((input) =>\n  typeof input === 'string' ? /^\\d+px$/.test(input) : false\n);\n```\n\n----------------------------------------\n\nTITLE: Number Schema with Values Validation in Valibot (TypeScript)\nDESCRIPTION: Example showing how to create a number schema that validates values against a specific set of allowed numbers (5, 15, 20). Includes a custom error message for validation failures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/values/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.values([5, 15, 20], 'The number must be one of the allowed numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullable Schema in TypeScript with Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a nullable schema using Valibot. The schema accepts a wrapped schema and an optional default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullable/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nullable<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Country Code Validation Schema - TypeScript\nDESCRIPTION: Advanced example showing how to create a picklist schema for country code validation with custom error message and mapped values from a constant array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/picklist/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst countries = [\n  { name: 'Germany', code: 'DE' },\n  { name: 'France', code: 'FR' },\n  { name: 'United States', code: 'US' },\n] as const;\n\nconst CountrySchema = v.picklist(\n  countries.map((country) => country.code),\n  'Please select your country.'\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Message Method Usage in TypeScript\nDESCRIPTION: Shows the basic syntax for using the message method to modify schema error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/message/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.message<TSchema>(schema, message_);\n```\n\n----------------------------------------\n\nTITLE: Email Validation Example with Safe Parser\nDESCRIPTION: Example showing how to create and use a safe parser for email validation, including success and error handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/safeParser/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst safeEmailParser = v.safeParser(EmailSchema);\nconst result = safeEmailParser('jane@example.com');\n\nif (result.success) {\n  const email = result.output;\n} else {\n  console.log(result.issues);\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Object Schemas\nDESCRIPTION: Demonstrates how to combine entries from two different object schemas into a single schema\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MergedObjectSchema = v.object({\n  ...ObjectSchema1.entries,\n  ...ObjectSchema2.entries,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a nonEmpty Validation Action in TypeScript\nDESCRIPTION: Demonstrates how to create a nonEmpty validation action with Valibot. This action is used to ensure that strings or arrays are not empty.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/nonEmpty/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.nonEmpty<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Defining SchemaWithFallbackAsync Type Interface\nDESCRIPTION: Type definition for a schema that supports asynchronous validation with fallback values. Includes generic type parameters TSchema and TFallback, along with required properties for fallback handling and async execution.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SchemaWithFallbackAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SchemaWithFallbackAsync<TSchema, TFallback> = {\n  fallback: TFallback;\n  async: true;\n  ~run: () => Promise<TSchema>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Object Schema with Optional Entry in TypeScript\nDESCRIPTION: Shows how to create an object schema with an optional string property using the 'optional' function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/optional/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalEntrySchema = v.object({\n  key: v.optional(v.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Emoji Schema with Valibot in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating an emoji using Valibot. It combines the string validation with the emoji validation action and includes a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/emoji/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmojiSchema = v.pipe(\n  v.string(),\n  v.emoji('Please provide a valid emoji.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Numbers with Minimum Value in Valibot\nDESCRIPTION: Schema example that creates a pipeline to validate a number with a minimum value of 100. Uses pipe() to combine a number type check with the minValue validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.minValue(100, 'The number must be at least 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Schema with Valibot in TypeScript\nDESCRIPTION: Demonstrates the basic usage of the 'optional' function to create an optional schema. It shows the function signature and explains its generics and parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/optional/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.optional<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Defining a String Map Schema in TypeScript with Valibot\nDESCRIPTION: Creates a schema to validate a map with string keys and string values. This example shows how to use the 'map' function with string schemas for both keys and values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/map/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringMapSchema = v.map(v.string(), v.string());\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Schemas with Valibot in TypeScript\nDESCRIPTION: Demonstrates how to create enum schemas using Valibot's `enum` function for both JavaScript objects and TypeScript enums. The schema validates if the input matches one of the enum values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/enums/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// As JavaScript object\nconst Direction = {\n  Left: 'LEFT',\n  Right: 'RIGHT',\n} as const;\n\n// As TypeScript enum\nenum Direction {\n  Left = 'LEFT',\n  Right = 'RIGHT',\n}\n\nconst DirectionSchema = v.enum(Direction);\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values in Optional Schemas with Valibot\nDESCRIPTION: Demonstrates how to set default values for optional schemas in Valibot, which changes the input and output types of the schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/optionals/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst OptionalStringSchema = v.optional(v.string(), \"I'm the default!\");\n\ntype OptionalStringInput = v.InferInput<typeof OptionalStringSchema>; // string | undefined\ntype OptionalStringOutput = v.InferOutput<typeof OptionalStringSchema>; // string\n```\n\n----------------------------------------\n\nTITLE: Validating Blob Size with notSize in TypeScript\nDESCRIPTION: Schema to validate a blob with a size that is not 10 MB. It uses the pipe method to combine blob validation with notSize validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notSize/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BlobSchema = v.pipe(\n  v.blob(),\n  v.notSize(10 * 1024 * 1024, 'The blob must not be 10 MB in size.')\n);\n```\n\n----------------------------------------\n\nTITLE: Object Transform with Added Property - TypeScript\nDESCRIPTION: Example of transforming an object by adding a new property. Validates object structure first, then adds a created timestamp during transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/transform/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst UserSchema = v.pipe(\n  v.object({ name: v.string(), age: v.number() }),\n  v.transform((input) => ({\n    ...input,\n    created: new Date().toISOString(),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: HexColorAction Interface Type Definition\nDESCRIPTION: TypeScript interface defining the structure of a hex color validation action. Includes generics for input and message types, along with properties for validation type, reference, expectations, requirements and custom messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/HexColorAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface HexColorAction<TInput, TMessage> {\n  type: 'hex_color';\n  reference: TInput;\n  expects: string;\n  requirement: boolean;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Array Content with Includes in TypeScript\nDESCRIPTION: This example shows how to use the 'includes' function to create a schema that validates if an array contains a specific string. It combines 'array', 'string', and 'includes' validations using the 'pipe' method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/includes/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.string()),\n  v.includes('foo', 'The array must contain \"foo\".')\n);\n```\n\n----------------------------------------\n\nTITLE: IMEI Validation Schema Example - TypeScript\nDESCRIPTION: Example of creating a schema that validates an IMEI string. It combines string validation with IMEI format validation using pipe method and includes a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/imei/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ImeiSchema = v.pipe(v.string(), v.imei('The imei is badly formatted.'));\n```\n\n----------------------------------------\n\nTITLE: Validating Array Length in TypeScript\nDESCRIPTION: Example schema that validates an array must contain exactly 100 numbers using pipe and length validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/length/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.number()),\n  v.length(100, 'The array must contain 100 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Object Array Schema in Valibot\nDESCRIPTION: Example of creating a schema that validates an array of objects, where each object must have a 'key' property of type string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/array/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectArraySchema = v.array(v.object({ key: v.string() }));\n```\n\n----------------------------------------\n\nTITLE: Creating a Required Object Schema in Valibot (TypeScript)\nDESCRIPTION: Example of using the 'required' method to create a schema that validates an object with all entries required. It transforms optional entries into required ones.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/required/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst RequiredSchema = v.required(\n  v.object({\n    key1: v.optional(v.string()),\n    key2: v.optional(v.number()),\n  })\n); // { key1: string; key2: number }\n```\n\n----------------------------------------\n\nTITLE: Validating Arrays with Excludes in Valibot\nDESCRIPTION: Schema example that validates an array of strings does not contain a specific string 'foo'. The pipe method combines array validation with the excludes validation action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/excludes/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.string()),\n  v.excludes('foo', 'The array must not contain \"foo\".')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayRequirement Type in TypeScript\nDESCRIPTION: This snippet defines the ArrayRequirement type, which is used to specify requirements for array validation. It includes a generic type parameter TInput and defines the structure of the ArrayRequirement object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArrayRequirement/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype ArrayRequirement<TInput> = {\n  min?: number;\n  max?: number;\n  length?: number;\n  unique?: boolean;\n  every?: Requirement<TInput>;\n  some?: Requirement<TInput>;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a New User Schema with Undefinedable Username\nDESCRIPTION: Example of a user registration schema with an undefinedable username field. The schema validates that email and username are unique using async validation, while username is optional.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/undefinedableAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailUnique, isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailUnique, 'The email is not unique.')\n  ),\n  username: v.undefinedableAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n/*\n  The input and output types of the schema:\n    {\n      email: string;\n      password: string;\n      username: string | undefined;\n    }\n*/\n```\n\n----------------------------------------\n\nTITLE: Cart Item Schema Validation Example\nDESCRIPTION: Example showing how to validate a cart item object using checkAsync to verify product quantity availability asynchronously against an API.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/checkAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getProductItem } from '~/api';\n\nconst CartItemSchema = v.pipeAsync(\n  v.object({\n    itemId: v.pipe(v.string(), v.regex(/^[a-z0-9]{10}$/i)),\n    quantity: v.pipe(v.number(), v.minValue(1)),\n  }),\n  v.checkAsync(async (input) => {\n    const productItem = await getProductItem(input.itemId);\n    return productItem?.quantity >= input.quantity;\n  }, 'The required quantity is greater than available.')\n);\n```\n\n----------------------------------------\n\nTITLE: Converting Object Schema Configuration\nDESCRIPTION: Demonstrates how to migrate Zod's object schema configuration methods to Valibot's dedicated schema functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst ObjectSchema = z.object({ key: z.string() }).strict();\n\n// To this\nconst ObjectSchema = v.strictObject({ key: v.string() });\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple Schema in Valibot\nDESCRIPTION: Creates a tuple schema with a specific shape. This example validates a tuple containing a string followed by a number, representing a fixed structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/arrays/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst TupleSchema = v.tuple([v.string(), v.number()]); // [string, number]\n```\n\n----------------------------------------\n\nTITLE: Defining RecordIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the RecordIssue interface, which extends BaseIssue and includes additional properties for record validation issues. It specifies the kind, type, and expected properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StringIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nRecordIssue {\n  kind: 'record'\n  type: string\n  expected: string\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Input Type from Object Schema in TypeScript\nDESCRIPTION: This example demonstrates how to create an object schema using Valibot and then infer the input type using the InferInput utility. The schema includes a pipe that transforms a string input to its length.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object schema\nconst ObjectSchema = v.object({\n  key: v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n});\n\n// Infer object input type\ntype ObjectInput = v.InferInput<typeof ObjectSchema>; // { key: string }\n```\n\n----------------------------------------\n\nTITLE: Date Schema Validation with Value Check\nDESCRIPTION: Example schema that validates a date must match January 1st 2000, using pipe to combine date validation with value validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/value/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.value(new Date('2000-01-01'), 'The date must be the first day of 2000.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Maximum Array Length with maxLength in Valibot\nDESCRIPTION: Creates a schema to validate that an array of numbers doesn't contain more than 5 items, with a custom error message when validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxLength/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxArraySchema = v.pipe(\n  v.array(v.number()),\n  v.maxLength(5, 'The array must not exceed 5 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Error Instance Schema Example in Valibot\nDESCRIPTION: Example of an instance schema that validates if the input is an instance of the Error class. It includes a custom error message for validation failures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/instance/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ErrorSchema = v.instance(Error, 'Error instance required.');\n```\n\n----------------------------------------\n\nTITLE: Basic Flatten Method Usage in TypeScript\nDESCRIPTION: Basic usage example of the flatten method for transforming validation issues into flattened errors.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/flatten/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst errors = v.flatten<TSchema>(issues);\n```\n\n----------------------------------------\n\nTITLE: Creating Picklist Schemas with Valibot in TypeScript\nDESCRIPTION: Shows how to create picklist schemas using Valibot's `picklist` function for array-based enumerated types. The schema checks if the input matches one of the items in the array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/enums/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst Direction = ['LEFT', 'RIGHT'] as const;\n\nconst DirectionSchema = v.picklist(Direction);\n```\n\n----------------------------------------\n\nTITLE: Transforming a Blob to String using Valibot in TypeScript\nDESCRIPTION: This example shows how to use transformAsync in combination with pipeAsync to create a schema that transforms a Blob input into its string value asynchronously.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/transformAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipeAsync(\n  v.blob(),\n  v.transformAsync((value) => value.text())\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullish Username Schema with Async Validation\nDESCRIPTION: Schema that validates a username string but also accepts undefined or null values, providing a unique username as default when input is nullish.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nullishAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUniqueUsername, isUsernameUnique } from '~/api';\n\nconst NullishUsernameSchema = v.nullishAsync(\n  v.pipeAsync(\n    v.string(),\n    v.nonEmpty(),\n    v.checkAsync(isUsernameUnique, 'The username is not unique.')\n  ),\n  getUniqueUsername\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Integer Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates an integer by combining the number schema with the integer validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/number/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IntegerSchema = v.pipe(v.number(), v.integer());\n```\n\n----------------------------------------\n\nTITLE: Validating a Date Range in Valibot\nDESCRIPTION: Example of creating a date schema that validates a date falls within a specified range using pipe, minValue, and maxValue validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/date/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateRangeSchema = v.pipe(\n  v.date(),\n  v.minValue(new Date(2019, 0, 1)),\n  v.maxValue(new Date(2020, 0, 1))\n);\n```\n\n----------------------------------------\n\nTITLE: Navigating to i18n Directory\nDESCRIPTION: Command to change directory to the i18n package folder\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/i18n/README.md#2025-04-09_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd ../packages/i18n\n```\n\n----------------------------------------\n\nTITLE: Creating Recursive Schemas with Lazy in Valibot\nDESCRIPTION: Demonstrates how to use the lazy schema function to define recursive schemas, such as a binary tree structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/other/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntype BinaryTree = {\n  element: string;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n};\n\nconst BinaryTreeSchema: v.GenericSchema<BinaryTree> = v.object({\n  element: v.string(),\n  left: v.nullable(v.lazy(() => BinaryTreeSchema)),\n  right: v.nullable(v.lazy(() => BinaryTreeSchema)),\n});\n```\n\n----------------------------------------\n\nTITLE: Marking Duplicates in a String Array using mapItems\nDESCRIPTION: Example of using mapItems to transform a string array by adding metadata to each item that indicates whether it's a duplicate. The operation function receives the item, index, and the full array to determine if the item is a duplicate.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mapItems/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MarkedArraySchema = v.pipe(\n  v.array(v.string()),\n  v.mapItems((item, index, array) => {\n    const isDuplicate = array.indexOf(item) !== index;\n    return { item, isDuplicate };\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Defining IPv6 Address Schema with Custom Error Message in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating an IPv6 address using Valibot. It combines the string validation with the ipv6 validation action and includes a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ipv6/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Ipv6Schema = v.pipe(\n  v.string(),\n  v.ipv6('The IP address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Number Schema Using Union in Valibot\nDESCRIPTION: Schema to validate either a number or a decimal string using union. It combines a number schema with a piped string schema that has decimal validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/union/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.union([v.number(), v.pipe(v.string(), v.decimal())]);\n```\n\n----------------------------------------\n\nTITLE: Maximum Object Properties Validation Example\nDESCRIPTION: Example schema that validates an object to ensure it has no more than 5 properties. Uses pipe to combine a record schema with maxEntries validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxEntries/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxEntriesSchema = v.pipe(\n  v.record(v.string(), v.number()),\n  v.maxEntries(5, 'Object must not exceed 5 entries.')\n);\n```\n\n----------------------------------------\n\nTITLE: Brand Interface Definition\nDESCRIPTION: The Brand interface type definition showing a generic typed interface used for branding/tagging types\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Brand/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nBrand<TName>\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema with Lazy in Valibot\nDESCRIPTION: Shows how to create a schema for all possible JSON values using the lazy schema function, allowing for recursive data structures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/other/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntype JsonData =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: JsonData }\n  | JsonData[];\n\nconst JsonSchema: v.GenericSchema<JsonData> = v.lazy(() =>\n  v.union([\n    v.string(),\n    v.number(),\n    v.boolean(),\n    v.null(),\n    v.record(v.string(), JsonSchema),\n    v.array(JsonSchema),\n  ])\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Nano ID Schema with Length Validation in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating a Nano ID. It combines the 'nanoid' function with 'string' and 'length' validations to ensure correct formatting and length.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/nanoid/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NanoIDSchema = v.pipe(\n  v.string(),\n  v.nanoid('The Nano ID is badly formatted.'),\n  v.length(21, 'The Nano ID must be 21 characters long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Blob Size in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a blob with a size of 256 bytes using the 'size' action in combination with 'pipe' and 'blob' methods.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/size/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BlobSchema = v.pipe(\n  v.blob(),\n  v.size(256, 'The blob must be 256 bytes in size.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Email Array Schema with Async Validation\nDESCRIPTION: Example showing how to create a schema for validating an array of stored emails, combining string validation, email format checking, and async database presence validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/arrayAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst StoredEmailsSchema = v.arrayAsync(\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: OptionalSchema Interface Type Definition\nDESCRIPTION: TypeScript interface definition showing the structure of OptionalSchema with its generics and properties. The interface extends BaseSchema and includes type, reference, expects, wrapped, and default properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/OptionalSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface OptionalSchema<TWrapped, TDefault> extends BaseSchema {\n  type: 'optional';\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing New User Schema with Nullish Username\nDESCRIPTION: Schema for validating new user details where username is optional (nullish) but email and password are required, with async validation for uniqueness.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nullishAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailUnique, isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailUnique, 'The email is not unique.')\n  ),\n  username: v.nullishAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n/*\n  The input and output types of the schema:\n    {\n      email: string;\n      password: string;\n      username?: string | null | undefined;\n    }\n*/\n```\n\n----------------------------------------\n\nTITLE: Validating Numbers with ltValue in TypeScript\nDESCRIPTION: Schema implementation that validates if a number is less than 100, combining the number() validator with ltValue in a pipe.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ltValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.ltValue(100, 'The number must be less than 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Global Configuration in Valibot\nDESCRIPTION: Demonstrates how to use the setGlobalConfig function to update global configuration settings. The function takes a config object parameter and merges it with existing configuration, overwriting any previously set properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/setGlobalConfig/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.setGlobalConfig(merge);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Schemas in Valibot\nDESCRIPTION: Illustrates the use of the custom schema function to define a schema with a custom validation function, in this case for a pixel string format.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/other/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst PixelStringSchema = v.custom<`${number}px`>((input) =>\n  typeof input === 'string' ? /^\\d+px$/.test(input) : false\n);\n```\n\n----------------------------------------\n\nTITLE: Defining IP Address Schema with Custom Error Message\nDESCRIPTION: This example shows how to create a schema for validating an IP address using Valibot. It combines the 'string' and 'ip' validators in a pipe, with a custom error message for invalid IP addresses.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ip/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IpAddressSchema = v.pipe(\n  v.string(),\n  v.ip('The IP address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Object Schema with Readonly Property - TypeScript\nDESCRIPTION: Example demonstrating how to create an object schema with a specific property marked as readonly using pipe.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/readonly/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object({\n  name: v.string(),\n  username: v.pipe(v.string(), v.readonly()),\n  age: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Donation Schema Defaults Example\nDESCRIPTION: Comprehensive example showing how to use getDefaultsAsync with a donation schema that includes optional fields and async default value generation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/getDefaultsAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getRandomOrgId } from '~/api';\n\nconst DonationSchema = v.objectAsync({\n  timestamp: v.optional(v.date(), () => new Date()),\n  sponsor: v.optional(v.pipe(v.string(), v.nonEmpty()), 'anonymous'),\n  organizationId: v.optionalAsync(v.pipe(v.string(), v.uuid()), getRandomOrgId),\n  message: v.optional(v.pipe(v.string(), v.minLength(1))),\n});\n\nconst defaultValues = await v.getDefaultsAsync(DonationSchema);\n\n/*\n  {\n    timestamp: new Date(),\n    sponsor: \"anonymous\",\n    organizationId: \"43775869-95f3-4e00-9f37-161ec8f9f7cd\",\n    message: undefined\n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Creating RFC Email Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating an RFC email validation action with optional message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rfcEmail/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.rfcEmail<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining TrimEndAction Interface Structure\nDESCRIPTION: The interface definition shows TrimEndAction properties including type and reference fields inherited from BaseTransformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TrimEndAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TrimEndAction extends BaseTransformation {\n  type: string;\n  reference: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EveryItemAction Interface in TypeScript\nDESCRIPTION: This code snippet outlines the structure of the EveryItemAction interface. It includes generics TInput and TMessage, and defines properties such as type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EveryItemAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EveryItemAction<TInput, TMessage> {\n  type: 'every_item';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean | Promise<boolean>;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getDotPath to Convert Validation Issue Path to Dot Notation in TypeScript\nDESCRIPTION: Example of using the getDotPath utility function from Valibot to convert a validation issue's path into dot notation format. The function takes a validation issue as input and returns a string representation of the path using dot notation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/getDotPath/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst dotPath = v.getDotPath<TSchema>(issue);\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullish Date Schema in Valibot\nDESCRIPTION: Creates a schema that accepts Date objects, undefined, and null. It uses a function to provide a new Date instance as the default value when the input is undefined or null.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullish/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullishDateSchema = v.nullish(v.date(), () => new Date());\n```\n\n----------------------------------------\n\nTITLE: Defining a Safe Integer Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a safe integer using Valibot. It combines the number() and safeInteger() actions in a pipe to ensure the input is both a number and a safe integer.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/safeInteger/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SafeIntegerSchema = v.pipe(\n  v.number(),\n  v.safeInteger('The number must be a safe integer.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining FilterItemsAction Interface in TypeScript\nDESCRIPTION: This snippet defines the FilterItemsAction interface with its properties. It includes a generic type TInput, and properties for type, reference, and operation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FilterItemsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface FilterItemsAction<TInput> {\n  type: 'filter_items';\n  reference: keyof TInput;\n  operation: FilterOperation;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Valibot via JSR for Node, Deno, and Bun\nDESCRIPTION: Command-line instructions for installing Valibot using JSR with various package managers including deno, npx, yarn, pnpm, and bun.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndeno add jsr:@valibot/valibot      # deno\nnpx jsr add @valibot/valibot       # npm\nyarn dlx jsr add @valibot/valibot  # yarn\npnpm dlx jsr add @valibot/valibot  # pnpm\nbunx jsr add @valibot/valibot      # bun\n```\n\n----------------------------------------\n\nTITLE: Creating an ISO Date Schema with Validation in Valibot\nDESCRIPTION: Example of creating a schema that validates an ISO date string. The pipe function combines the string validation with the ISO date format validation, including a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoDate/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoDateSchema = v.pipe(\n  v.string(),\n  v.isoDate('The date is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining RecordSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the RecordSchemaAsync interface. It extends BaseSchemaAsync and includes properties for type, reference, expects, key, value, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RecordSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface RecordSchemaAsync<TKey, TValue, TMessage> extends BaseSchemaAsync {\n  type: 'record';\n  reference: unknown;\n  expects: string;\n  key: SchemaAsync<TKey>;\n  value: SchemaAsync<TValue>;\n  message?: ErrorMessage<TMessage>;\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Variant Schema with Multiple Discriminators\nDESCRIPTION: Advanced example showing how to implement complex variant schemas with multiple discriminator keys for hierarchical validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/variant/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst ComplexVariantSchema = v.variant('kind', [\n  v.variant('type', [\n    v.object({\n      kind: v.literal('fruit'),\n      type: v.literal('apple'),\n      item: v.object({ â€¦ }),\n    }),\n    v.object({\n      kind: v.literal('fruit'),\n      type: v.literal('banana'),\n      item: v.object({ â€¦ }),\n    }),\n  ]),\n  v.variant('type', [\n    v.object({\n      kind: v.literal('vegetable'),\n      type: v.literal('carrot'),\n      item: v.object({ â€¦ }),\n    }),\n    v.object({\n      kind: v.literal('vegetable'),\n      type: v.literal('tomato'),\n      item: v.object({ â€¦ }),\n    }),\n  ]),\n]);\n```\n\n----------------------------------------\n\nTITLE: Basic Pipe Method Signature in TypeScript\nDESCRIPTION: The basic syntax for creating a pipeline with Valibot's pipe method. It takes a schema as the first parameter followed by validation and transformation items.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/pipe/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.pipe<TSchema, TItems>(schema, ...items);\n```\n\n----------------------------------------\n\nTITLE: Setting Local Translations in Valibot Schema\nDESCRIPTION: Demonstrates how to define custom error messages locally within schema validation rules, which can be particularly useful when using an i18n library like Paraglide JS.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/internationalization/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport * as m from './paraglide/messages.js';\n\nconst LoginSchema = v.object({\n  email: v.pipe(\n    v.string(),\n    v.nonEmpty(m.emailRequired),\n    v.email(m.emailInvalid)\n  ),\n  password: v.pipe(\n    v.string(),\n    v.nonEmpty(m.passwordRequired),\n    v.minLength(8, m.passwordInvalid)\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: TupleSchemaAsync Interface Type Definition\nDESCRIPTION: Type definition for TupleSchemaAsync interface that extends BaseSchemaAsync with tuple-specific properties including type, reference, expects, items, and message configurations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TupleSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TupleSchemaAsync<TItems, TMessage> extends BaseSchemaAsync {\n  type: 'tuple';\n  reference: typeof Reference;\n  expects: string;\n  items: TItems;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using InferObjectOutput to Extract Transformed Object Types in Valibot\nDESCRIPTION: This example demonstrates how to use Valibot's InferObjectOutput utility type to infer the final type of an object schema after transformations. It creates an object with a string field that gets transformed to a number, then uses InferObjectOutput to extract the resulting type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferObjectOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object entries\nconst entries = {\n  key: v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n};\n\n// Infer entries output type\ntype EntriesOutput = v.InferObjectOutput<typeof entries>; // { key: number }\n```\n\n----------------------------------------\n\nTITLE: Validating Dates with Minimum Value in Valibot\nDESCRIPTION: Schema example for validating dates with a minimum year requirement. Creates a pipeline that ensures a date is valid and occurs after the year 1999.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.minValue(new Date('2000-01-01'), 'The date must be after the year 1999.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Octal Validation Schema with Pipe in Typescript\nDESCRIPTION: Example schema that validates an input as a string and then checks if it's formatted as a valid octal number. It uses the pipe method to chain validation actions and provides a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/octal/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OctalSchema = v.pipe(\n  v.string(),\n  v.octal('The octal is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Number Schema with gtValue Validation\nDESCRIPTION: Example of creating a number validation schema that ensures the value is greater than 100 using pipe and gtValue validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/gtValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.gtValue(100, 'The number must be greater than 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Boolean Schema with Custom Error Message\nDESCRIPTION: This example shows how to create a boolean schema with a custom error message. The message will be used if the input is not a boolean.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/boolean/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BooleanSchema = v.boolean('A boolean is required');\n```\n\n----------------------------------------\n\nTITLE: Implementing Credit Card Schema in TypeScript\nDESCRIPTION: This example demonstrates how to create a schema for validating a credit card using the pipe and creditCard functions from Valibot. It combines string validation with credit card format validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/creditCard/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst CreditCardSchema = v.pipe(\n  v.string(),\n  v.creditCard('The credit card is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Loose Tuple Schema in TypeScript\nDESCRIPTION: This example shows how to create a simple loose tuple schema that validates a tuple with two specific items: a string and a number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseTuple/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleTupleSchema = v.looseTuple([v.string(), v.number()]);\n```\n\n----------------------------------------\n\nTITLE: Validating a Number Promise with Valibot\nDESCRIPTION: This example shows how to create a schema that validates a promise resolving to a number. It uses a pipeline of promise, awaitAsync, and number validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/promise/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberPromiseSchema = v.pipeAsync(\n  v.promise(),\n  v.awaitAsync(),\n  v.number()\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Blob Size with MinSize in TypeScript\nDESCRIPTION: Schema implementation to validate a blob that must be at least 10 MB in size using pipe and minSize validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minSize/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BlobSchema = v.pipe(\n  v.blob(),\n  v.minSize(10 * 1024 * 1024, 'The blob must be at least 10 MB.')\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Fallback Method Usage in Valibot\nDESCRIPTION: Shows the basic syntax for using the fallback method in Valibot to define a schema with a fallback value when validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/fallback/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.fallback<TSchema, TFallback>(schema, fallback);\n```\n\n----------------------------------------\n\nTITLE: Pixel String Schema Validation - TypeScript\nDESCRIPTION: Example schema that validates a pixel string format using pipe to combine string validation with regex pattern matching. The regex ensures the string ends with 'px' and contains only digits before it.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/regex/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst PixelStringSchema = v.pipe(\n  v.string(),\n  v.regex(/^\\d+px$/, 'The pixel string is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating a Date with MaxValue in Valibot\nDESCRIPTION: Schema example that validates a date, ensuring it doesn't exceed the end of 1999. It first validates that the input is a date, then checks if it's before or equal to December 31, 1999.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.maxValue(new Date('1999-12-31'), 'The date must not exceed the year 1999.')\n);\n```\n\n----------------------------------------\n\nTITLE: File Instance Schema with Additional Validations in Valibot\nDESCRIPTION: Advanced example creating a File instance schema with pipe validation. It validates that the input is a File instance, checks the MIME type against allowed types, and enforces a maximum file size of 10MB.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/instance/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst FileSchema = v.pipe(\n  v.instance(File),\n  v.mimeType(['image/jpeg', 'image/png']),\n  v.maxSize(1024 * 1024 * 10)\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a 48-bit MAC Address Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating a 48-bit MAC address using Valibot. It combines the string validation with the mac48 function in a pipe to ensure proper formatting.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mac48/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Mac48Schema = v.pipe(\n  v.string(),\n  v.mac48('The MAC address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Maximum String Length with maxLength in Valibot\nDESCRIPTION: Creates a schema to validate that a string doesn't exceed 32 characters in length, with a custom error message when validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxLength/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxStringSchema = v.pipe(\n  v.string(),\n  v.maxLength(32, 'The string must not exceed 32 characters.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Partial Object Schema in TypeScript\nDESCRIPTION: Example of creating a schema to validate an object where all entries are marked as optional. This transforms a required object schema to one where all properties can be omitted.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/partial/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialSchema = v.partial(\n  v.object({\n    key1: v.string(),\n    key2: v.number(),\n  })\n); // { key1?: string; key2?: number }\n```\n\n----------------------------------------\n\nTITLE: Summing Numbers in an Array using reduceItems in TypeScript\nDESCRIPTION: This example shows how to use reduceItems to create a schema that sums all the numbers in an array. It combines the array schema with the reduceItems action in a pipe to create a custom validation and transformation schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/reduceItems/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SumArraySchema = v.pipe(\n  v.array(v.number()),\n  v.reduceItems((sum, item) => sum + item, 0)\n);\n```\n\n----------------------------------------\n\nTITLE: TupleWithRestSchemaAsync Interface Definition in TypeScript\nDESCRIPTION: The TupleWithRestSchemaAsync interface definition including its generic type parameters (TItems, TRest, TMessage) and properties like type, reference, expects, items, rest, and message that extend the BaseSchemaAsync interface.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TupleWithRestSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TupleWithRestSchemaAsync<TItems, TRest, TMessage> extends BaseSchemaAsync {\n  type: 'tuple';\n  reference: unknown[];\n  expects: string;\n  items: TItems;\n  rest: TRest;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Picklist Record Schema - TypeScript\nDESCRIPTION: Schema definition for validating a record with specific optional keys from a predefined list of products.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst ProductRecordSchema = v.record(\n  v.picklist(['product_a', 'product_b', 'product_c']),\n  v.optional(v.number())\n);\n```\n\n----------------------------------------\n\nTITLE: Validating a Number and Email Tuple with tupleAsync in TypeScript\nDESCRIPTION: This example shows how to create a schema for a tuple containing a number and an email address. It uses tupleAsync with nested validation, including an asynchronous check to verify if the email exists in a database.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/tupleAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst TupleSchema = v.tupleAsync([\n  v.number(),\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  ),\n]);\n```\n\n----------------------------------------\n\nTITLE: MaxWordsAction Interface Definition with Generics\nDESCRIPTION: TypeScript interface definition for MaxWordsAction that validates maximum word count. The interface includes generic parameters for input type, locales, requirement, and message customization, along with core validation properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxWordsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MaxWordsAction<TInput, TLocales, TRequirement, TMessage> {\n  type: 'max_words';\n  reference: TInput;\n  expects: TRequirement;\n  locales?: TLocales;\n  requirement?: TRequirement;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: MinLengthIssue Interface Definition in TypeScript\nDESCRIPTION: Interface definition that extends BaseIssue to specify the structure of minimum length validation errors. It includes properties for error kind, type, expected and received values, and the minimum length requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinLengthIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MinLengthIssue<TInput, TRequirement> extends BaseIssue {\n  kind: string;\n  type: 'min_length';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NotValueIssue Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the NotValueIssue interface. It extends BaseIssue and includes properties for kind, type, expected value, and requirement. The interface is generic, allowing for flexible input and requirement types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotValueIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nNotValueIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'not_value';\n  type: string;\n  expected: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ISO Week Schema with Pipe in TypeScript\nDESCRIPTION: This example shows how to create a schema for validating ISO weeks using the pipe method to combine string validation with the isoWeek action. It includes a custom error message for invalid formats.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoWeek/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoWeekSchema = v.pipe(\n  v.string(),\n  v.isoWeek('The week is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Set of IP Addresses - TypeScript\nDESCRIPTION: Example schema that validates a set of IP addresses using multiple validation steps including string validation, IP format checking, and custom async validation through an API call.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/setAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isIpAllowed } from '~/api';\n\nconst AllowedIPsSchema = v.setAsync(\n  v.pipeAsync(\n    v.string(),\n    v.ip(),\n    v.checkAsync(isIpAllowed, 'This IP address is not allowed.')\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing a BIC Schema with Valibot\nDESCRIPTION: Example of creating a schema to validate a BIC, which pipes a string through uppercase conversion and BIC validation with a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/bic/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BicSchema = v.pipe(\n  v.string(),\n  v.toUpperCase(),\n  v.bic('The BIC is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Using Partial Method with Object Schema in TypeScript\nDESCRIPTION: Basic usage of the partial method to create a schema where all properties are optional. This demonstrates the core functionality similar to TypeScript's Partial utility type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/partial/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.partial<TSchema, TKeys>(schema, keys);\n```\n\n----------------------------------------\n\nTITLE: Object Key Schema Example - TypeScript Implementation\nDESCRIPTION: Practical example showing how to create a keyof schema from an object schema. Creates a union type of literal string keys from the object's properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/keyof/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object({ key1: v.string(), key2: v.number() });\nconst ObjectKeySchema = v.keyof(ObjectSchema); // 'key1' | 'key2'\n```\n\n----------------------------------------\n\nTITLE: Implementing a Tuple Schema with Boolean Rest Items in TypeScript\nDESCRIPTION: Example of creating a tuple schema that validates an array where the first element must be a string, the second a number, and any additional elements must be booleans.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/tupleWithRest/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst TupleSchemaWithRest = v.tupleWithRest(\n  [v.string(), v.number()],\n  v.boolean()\n);\n```\n\n----------------------------------------\n\nTITLE: Complex Object Validation with Flatten Method\nDESCRIPTION: Example showing how to use flatten with a nested object schema validation, including error handling for missing nested properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/flatten/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object({\n  nested: v.object({\n    key: v.string('Value of \"nested.key\" is missing.'),\n  }),\n});\n\nconst result = v.safeParse(Schema, { nested: {} });\n\nif (result.issues) {\n  const flatErrors = v.flatten<typeof Schema>(result.issues);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Decimal Validation Action in Valibot\nDESCRIPTION: Basic usage pattern for creating a decimal validation action in Valibot. This function validates that a string represents a decimal number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/decimal/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.decimal<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: IsoDateIssue Interface Definition\nDESCRIPTION: Interface extending BaseIssue that defines the structure for ISO date validation errors. Includes properties for error kind, type, expected and received values, and validation requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IsoDateIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IsoDateIssue<TInput> extends BaseIssue {\n  kind: 'iso_date';\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReturnsAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the ReturnsAction interface with its generics and properties. It extends the BaseTransformation interface and includes type, reference, and schema properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ReturnsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ReturnsAction<TInput, TSchema> extends BaseTransformation {\n  type: 'returns';\n  reference: TInput;\n  schema: TSchema;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a MAC Address Schema with Valibot\nDESCRIPTION: Example of creating a schema that validates a MAC address string using pipe() to combine string validation with MAC address format validation. Includes a custom error message for formatting issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mac/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MacSchema = v.pipe(\n  v.string(),\n  v.mac('The MAC address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Email Schema Validation with Custom Message\nDESCRIPTION: Example showing how to create an email validation schema with a custom error message for the entire validation pipeline.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/message/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.message(\n  v.pipe(v.string(), v.trim(), v.nonEmpty(), v.email(), v.maxLength(100)),\n  'The email is not in the required format.'\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Numbers Not Equal to a Specific Value\nDESCRIPTION: Schema using notValue to validate that a number is not equal to 100. It first validates that the input is a number, then ensures it is not equal to 100.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.notValue(100, 'The number must not be 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Map Schema in TypeScript using Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a map schema using Valibot. The schema validates both the key and value types of the map.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/map/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.map<TKey, TValue, TMessage>(key, value, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Union Schema in Valibot\nDESCRIPTION: Basic syntax for creating a union schema with Valibot. The function takes options and an optional error message as parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/union/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.union<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Implementing Hexadecimal Schema Validation in TypeScript\nDESCRIPTION: Example showing how to create a schema that validates hexadecimal strings using pipe to combine string validation with hexadecimal format checking. Includes custom error message for invalid formats.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/hexadecimal/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst HexadecimalSchema = v.pipe(\n  v.string(),\n  v.hexadecimal('The hexadecimal is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Getting Default Values from Object Schema\nDESCRIPTION: Example showing how to retrieve default values from an object schema that contains an optional string property with a default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getDefaults/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object({\n  key: v.optional(v.string(), \"I'm the default!\"),\n});\n\nconst defaultValues = v.getDefaults(ObjectSchema); // { key: \"I'm the default!\" }\n```\n\n----------------------------------------\n\nTITLE: Defining InferNullishOutput Type with Generics\nDESCRIPTION: Type definition that infers nullish output types with two generic parameters: TWrapped represents the wrapped type to be checked for nullish values, and TDefault represents an optional default type when the value is nullish.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNullishOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype InferNullishOutput<TWrapped, TDefault = TWrapped>\n```\n\n----------------------------------------\n\nTITLE: Language Validation Schema - TypeScript\nDESCRIPTION: Example of creating a picklist schema to validate programming language selections from a fixed set of options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/picklist/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst LanguageSchema = v.picklist(['JavaScript', 'TypeScript']);\n```\n\n----------------------------------------\n\nTITLE: Creating a Union Schema in Valibot\nDESCRIPTION: Basic syntax for creating a union schema with Valibot. The function takes options and an optional error message as parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/union/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.union<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Defining RawCheckActionAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the RawCheckActionAsync interface with a generic type parameter TInput. It extends BaseValidationAsync and includes properties for type, reference, and expects.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RawCheckActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface RawCheckActionAsync<TInput> extends BaseValidationAsync {\n  type: 'check';\n  reference: string;\n  expects: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Finite Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a finite validation action using Valibot. It shows the basic syntax and generic types used in the action creation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/finite/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.finite<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Declaring ErrorMessage Type Property\nDESCRIPTION: Defines the ErrorMessage type property with appropriate error handling structure\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ErrorMessage/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nErrorMessage\n```\n\n----------------------------------------\n\nTITLE: Bytes Schema Example\nDESCRIPTION: Example showing how to create a schema that validates a string must be exactly 8 bytes in length. Uses pipe to combine string validation with bytes validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/bytes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BytesSchema = v.pipe(\n  v.string(),\n  v.bytes(8, 'Exactly 8 bytes are required.')\n);\n```\n\n----------------------------------------\n\nTITLE: Array Schema with Empty Validation in TypeScript\nDESCRIPTION: An example schema that validates an array is empty. It combines array validation (of numbers) with the empty validation, providing a custom error message when the array contains elements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/empty/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.number()),\n  v.empty('The array must be empty.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Blob Size with maxSize in TypeScript\nDESCRIPTION: Example of using maxSize to create a schema that validates a blob with a maximum size of 10 MB. The schema uses a pipe to combine blob validation with size validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxSize/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BlobSchema = v.pipe(\n  v.blob(),\n  v.maxSize(10 * 1024 * 1024, 'The blob must not exceed 10 MB.')\n);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Exact Optional Schema in Valibot\nDESCRIPTION: This example demonstrates how to use the unwrap function to undo the effect of exactOptional, converting an optional schema back to its wrapped schema type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/exactOptional/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalNumberSchema = v.exactOptional(v.number());\nconst NumberSchema = v.unwrap(OptionalNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: StringSchema Interface Definition in TypeScript\nDESCRIPTION: Interface definition for StringSchema that extends BaseSchema with specific string validation properties. It includes type definitions, reference handling, expectation management, and custom error messaging.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StringSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface StringSchema<TMessage> extends BaseSchema {\n  type: string;\n  reference: string;\n  expects: string;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fallback String Schema in Valibot\nDESCRIPTION: Creates a schema that validates strings and returns a fallback text when validation fails, ensuring the output is always a string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/fallback/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FallbackStringSchema = v.fallback(v.string(), \"I'm the fallback!\");\n```\n\n----------------------------------------\n\nTITLE: Using objectWithRestAsync Schema in TypeScript\nDESCRIPTION: Shows the basic syntax for creating an object schema with rest schema. This schema validates specific entries while allowing unknown entries to pass through to the output.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/objectWithRestAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.objectWithRestAsync<TEntries, TRest, TMessage>(\n  entries,\n  rest,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Number and Email Tuple Validation Example\nDESCRIPTION: Example schema that validates a loose tuple containing a number and an email address that must exist in a database. Uses pipe async for email validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/looseTupleAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst TupleSchema = v.looseTupleAsync([\n  v.number(),\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  ),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating Not Words Schema in TypeScript\nDESCRIPTION: Demonstrates how to create a schema that validates a string with more or less than 5 words using the notWords action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notWords/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NotWordsSchema = v.pipe(\n  v.string(),\n  v.notWords('en', 5, 'The string must not have 5 words.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Safe Integer Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a safe integer validation action using Valibot. It specifies the generic types for input and message, and takes an optional custom error message as a parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/safeInteger/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.safeInteger<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining StandardProps Interface in TypeScript\nDESCRIPTION: This code snippet outlines the structure of the StandardProps interface, which is used to define standard properties for schemas in Valibot. It includes generics for input and output types, and properties for version, vendor, validation, and types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StandardProps/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nStandardProps<TInput, TOutput> {\n  version?: string;\n  vendor?: string;\n  validate?: (input: TInput) => TOutput;\n  types?: {\n    input: TInput;\n    output: TOutput;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Set Size with notSize in TypeScript\nDESCRIPTION: Schema to validate a set with a size that is not 8 numbers. It uses the pipe method to combine set validation with notSize validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notSize/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst SetSchema = v.pipe(\n  v.set(number()),\n  v.notSize(8, 'The set must not contain 8 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Optional Username Schema with Unique Validation\nDESCRIPTION: Example of creating an optional username schema that validates uniqueness and provides a default value generator function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/optionalAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUniqueUsername, isUsernameUnique } from '~/api';\n\nconst OptionalUsernameSchema = v.optionalAsync(\n  v.pipeAsync(\n    v.string(),\n    v.nonEmpty(),\n    v.checkAsync(isUsernameUnique, 'The username is not unique.')\n  ),\n  getUniqueUsername\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Strings with Excludes in Valibot\nDESCRIPTION: Schema example that validates a string does not contain a specific substring 'foo'. The pipe method chains the string validation with the excludes validation action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/excludes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(\n  v.string(),\n  v.excludes('foo', 'The string must not contain \"foo\".')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Optional String Schema in Valibot\nDESCRIPTION: Example of creating a schema that requires a string value and doesn't accept undefined. This is done by wrapping an optional string schema with nonOptional to reverse the optional behavior.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonOptional/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NonOptionalStringSchema = v.nonOptional(v.optional(v.string()));\n```\n\n----------------------------------------\n\nTITLE: Defining NullableSchema Interface Properties - TypeScript\nDESCRIPTION: Interface structure for NullableSchema showing its properties including type, reference, expects, wrapped, and default values. Includes two generic type parameters TWrapped and TDefault.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NullableSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NullableSchema<TWrapped, TDefault> {\n  type: string;\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Tuple Schema in TypeScript\nDESCRIPTION: Basic syntax for creating a tuple schema with custom message support. This schema validates the data type and content of a tuple against specified items.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/tuple/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.tuple<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Validating String Length with notLength in TypeScript\nDESCRIPTION: This example shows how to use notLength to validate that a string does not have a specific length. It creates a schema that ensures the string is not exactly 8 characters long.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notLength/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(\n  v.string(),\n  v.notLength(8, 'The string must not be 8 characters long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating ULID Validation Action in TypeScript using Valibot\nDESCRIPTION: Basic syntax for creating an ULID validation action in Valibot. This creates a validation action that checks if a string follows the ULID format specification, with optional custom error message support.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ulid/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.ulid<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Tuple Schema in TypeScript\nDESCRIPTION: Basic syntax for creating a tuple schema with custom message support. This schema validates the data type and content of a tuple against specified items.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/tuple/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.tuple<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Implementing entriesFromList with Object Schema in TypeScript\nDESCRIPTION: Example showing how to use entriesFromList to create an object schema where multiple keys ('foo', 'bar', 'baz') all share the same validation schema (string). This creates an object where all three properties must be valid strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/entriesFromList/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object(\n  v.entriesFromList(['foo', 'bar', 'baz'], v.string())\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Object Schema with Rest using objectWithRest in TypeScript\nDESCRIPTION: Demonstrates the basic usage of objectWithRest to create an object schema with typed entries and a rest schema for additional properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/objectWithRest/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.objectWithRest<TEntries, TRest, TMessage>(\n  entries,\n  rest,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a MaxValue Action in Valibot\nDESCRIPTION: The basic syntax for creating a maxValue validation action in Valibot. This action validates that the input value does not exceed the specified maximum requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxValue<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Implementing Readonly Array Schema - TypeScript\nDESCRIPTION: Example showing how to create a schema for a readonly array of numbers using pipe and readonly transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/readonly/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(v.array(v.number()), v.readonly());\n```\n\n----------------------------------------\n\nTITLE: String Schema with Empty Validation in TypeScript\nDESCRIPTION: An example schema that validates a string is empty. It uses the pipe method to combine a string validation with an empty validation, providing a custom error message when the string is not empty.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/empty/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.empty('The string must be empty.'));\n```\n\n----------------------------------------\n\nTITLE: Creating Dependent Default Values in Object Schemas with Valibot\nDESCRIPTION: Demonstrates how to create default values that depend on other values in the same object using transform and pipe in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/optionals/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst CalculationSchema = v.pipe(\n  v.object({\n    a: v.number(),\n    b: v.number(),\n    sum: v.optional(v.number()),\n  }),\n  v.transform((input) => ({\n    ...input,\n    sum: input.sum === undefined ? input.a + input.b : input.sum,\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Migrating Validation Pipeline Syntax in TypeScript\nDESCRIPTION: Shows how to migrate from array-based validation to pipe-based validation chains. Updates email, password and union type validations to use the new pipe syntax.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/codemod/migrate-to-v0.31.0/README.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nv.object({\n  email: v.string([v.email(), v.endsWith('@gmail.com')]),\n  password: v.string([v.minLength(8)]),\n  other: v.union([v.string([v.decimal()]), v.number()]),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nv.object({\n  email: v.pipe(v.string(), v.email(), v.endsWith('@gmail.com')),\n  password: v.pipe(v.string(), v.minLength(8)),\n  other: v.union([v.pipe(v.string(), v.decimal()), v.number()]),\n});\n```\n\n----------------------------------------\n\nTITLE: Object Schema Interface Definition\nDESCRIPTION: Interface declaration showing the structure of ObjectSchema with its generic types and properties. Includes type definitions for entries and validation messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ObjectSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ObjectSchema<TEntries, TMessage> extends BaseSchema {\n  type: 'object';\n  reference: TEntries;\n  expects: string;\n  entries: TEntries;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Picking Specific Keys from an Object Schema in Valibot\nDESCRIPTION: Example showing how to create a new schema that contains only selected keys ('key1' and 'key3') from an existing object schema, leaving out 'key2'.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/pick/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst PickedSchema = v.pick(\n  object({\n    key1: string(),\n    key2: number(),\n    key3: boolean(),\n  }),\n  ['key1', 'key3']\n); // { key1: string; key3: boolean }\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullable String Schema in TypeScript with Valibot\nDESCRIPTION: Example of creating a nullable string schema that accepts string and null values, with a default string value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullable/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullableStringSchema = v.nullable(v.string(), \"I'm the default!\");\n```\n\n----------------------------------------\n\nTITLE: Implementing strictObjectAsync for New User Validation with Async Email Check\nDESCRIPTION: Example schema that validates a new user object with async email validation. Demonstrates how to create a schema that validates object properties and includes an async check for email uniqueness.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/strictObjectAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst NewUserSchema = v.strictObjectAsync({\n  firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is already in use by another user.')\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n  avatar: v.optional(v.pipe(v.string(), v.url())),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Words Schema Validation in Valibot TypeScript\nDESCRIPTION: Example schema implementation that validates a string containing exactly 3 words in English. The schema pipes the input through a string validation first, then applies the words validation with a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/words/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst WordsSchema = v.pipe(\n  v.string(),\n  v.words('en', 3, 'Exactly 3 words are required.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Nullish Schema in TypeScript\nDESCRIPTION: Demonstrates the basic usage of the nonNullish function to create a schema that doesn't accept null or undefined values. It shows the function signature with generics and parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonNullish/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonNullish<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a minValue Validation Action in TypeScript with Valibot\nDESCRIPTION: Basic syntax for creating a minimum value validation action with Valibot. This snippet shows the function signature including generic types for input, requirement, and custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.minValue<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Defining InferObjectIssue Type in TypeScript\nDESCRIPTION: This snippet defines the InferObjectIssue type, which is used to infer object issue types. It uses a generic parameter TEntries and likely involves complex type manipulation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferObjectIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nInferObjectIssue<TEntries>\n```\n\n----------------------------------------\n\nTITLE: Filtering Duplicate Items in Valibot Array Schema\nDESCRIPTION: Shows how to use filterItems to create a schema that removes duplicate items from an array of strings. It combines the array schema with a pipe and filterItems action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/filterItems/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FilteredArraySchema = v.pipe(\n  v.array(v.string()),\n  v.filterItems((item, index, array) => array.indexOf(item) === index)\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Optional Schemas in Valibot\nDESCRIPTION: Demonstrates how to create different types of optional schemas using Valibot, including optional, exactOptional, undefinable, nullable, and nullish schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/optionals/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst OptionalStringSchema = v.optional(v.string()); // string | undefined\nconst ExactOptionalStringSchema = v.exactOptional(v.string()); // string\nconst UndefinedableStringSchema = v.undefinedable(v.string()); // string | undefined\nconst NullableStringSchema = v.nullable(v.string()); // string | null\nconst NullishStringSchema = v.nullish(v.string()); // string | null | undefined\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Date Schema in TypeScript\nDESCRIPTION: Demonstrates creating an optional Date schema that accepts Date objects and undefined, using a function to generate a new Date as the default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/optional/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalDateSchema = v.optional(v.date(), () => new Date());\n```\n\n----------------------------------------\n\nTITLE: Integer Schema Implementation Example\nDESCRIPTION: Example showing how to create a schema that validates an integer using pipe and number validation combined with integer validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/integer/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IntegerSchema = v.pipe(\n  v.number(),\n  v.integer('The number must be an integer.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Partial Object Schema\nDESCRIPTION: Shows how to create a schema where all properties are optional using the partial wrapper.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseObject/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialObjectSchema = v.partial(\n  v.looseObject({\n    key1: v.string(),\n    key2: v.number(),\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Email Domain with endsWith in TypeScript\nDESCRIPTION: This example shows how to use endsWith in combination with other validators to create a schema for validating an email address with a specific domain.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/endsWith/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email(), v.endsWith('@example.com'));\n```\n\n----------------------------------------\n\nTITLE: Creating Hash Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a hash validation action that validates string inputs against specified hash types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/hash/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.hash<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Object Properties\nDESCRIPTION: Demonstrates how to create a schema that validates only selected properties from a strict object schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictObject/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst PickObjectSchema = v.pick(\n  v.strictObject({\n    key1: v.string(),\n    key2: v.number(),\n    key3: v.boolean(),\n  }),\n  ['key1', 'key3']\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Schema Configuration Usage\nDESCRIPTION: Basic usage example showing how to apply configuration to a schema using the config method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/config/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.config<TSchema>(schema, config);\n```\n\n----------------------------------------\n\nTITLE: TypeScript SizeAction Interface Properties\nDESCRIPTION: Interface definition showing the generic types and properties of the SizeAction interface. It includes TInput for input type, TRequirement for requirement type, and TMessage for error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SizeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SizeAction<TInput, TRequirement, TMessage> {\n  type: 'size';\n  reference: TInput;\n  expects: 'less' | 'lessOrEqual' | 'equal' | 'notEqual' | 'greaterOrEqual' | 'greater';\n  requirement: TRequirement;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Regex Validation Action - TypeScript\nDESCRIPTION: Basic syntax for creating a regex validation action in Valibot. Uses generics TInput and TMessage to define input type and error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/regex/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.regex<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Enforcing Minimum Value for Numbers in Valibot\nDESCRIPTION: Example showing how to create a schema that enforces a minimum value of 100 for numbers. If the input is less than 100, it will be transformed to 100.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMinValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(v.number(), v.toMinValue(100));\n```\n\n----------------------------------------\n\nTITLE: Creating a String Set Schema with Valibot\nDESCRIPTION: Example of creating a schema to validate a Set containing string values. This ensures all values in the Set are valid strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/set/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSetSchema = v.set(v.string());\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Transformation with toMinValue in TypeScript\nDESCRIPTION: Shows how to create a pipeline that transforms input values by enforcing a minimum value of 10 for numbers.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/pipelines/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst NumberSchema = v.pipe(v.number(), v.toMinValue(10));\n```\n\n----------------------------------------\n\nTITLE: Creating a Partially Required Object Schema in Valibot (TypeScript)\nDESCRIPTION: Example of using the 'required' method to create a schema that validates an object with only specific entries marked as required. It allows for selective requirement of object properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/required/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst RequiredSchema = v.required(\n  v.object({\n    key1: v.optional(v.string()),\n    key2: v.optional(v.number()),\n    key3: v.optional(v.boolean()),\n  }),\n  ['key1', 'key3']\n); // { key1: string; key2?: number; key3: boolean }\n```\n\n----------------------------------------\n\nTITLE: Simple Tuple Schema Example\nDESCRIPTION: Example of creating a tuple schema that validates a tuple with two items - a string followed by a number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/tuple/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleTupleSchema = v.tuple([v.string(), v.number()]);\n```\n\n----------------------------------------\n\nTITLE: Merging Object Schemas\nDESCRIPTION: Demonstrates how to merge entries from multiple object schemas into a single loose object schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseObject/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MergedObjectSchema = v.looseObject({\n  ...ObjectSchema1.entries,\n  ...ObjectSchema2.entries,\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Minimum String Length in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a string with a minimum length of 3 characters using the minLength validation action in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minLength/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinStringSchema = v.pipe(\n  v.string(),\n  v.minLength(3, 'The string must be 3 or more characters long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Validation\nDESCRIPTION: Example showing how to create a strict object schema with two typed properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictObject/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.strictObject({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Object Schemas\nDESCRIPTION: Demonstrates how to combine entries from multiple object schemas into a single strict object schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictObject/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MergedObjectSchema = v.strictObject({\n  ...ObjectSchema1.entries,\n  ...ObjectSchema2.entries,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining UuidAction Interface in TypeScript\nDESCRIPTION: Interface definition for UUID validation actions that includes type checking, reference value comparison, and custom validation messages. The interface uses generics TInput and TMessage for flexible input and message typing.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UuidAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UuidAction<TInput, TMessage> {\n  type: 'uuid';\n  reference?: string;\n  expects?: string;\n  requirement?: number;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Context Interface Structure for Valibot\nDESCRIPTION: Interface definition for Context that includes dataset, config, and addIssue properties. Used for validation context in raw checks with generic type TInput.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawCheck/Context/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Context<TInput> {\n  dataset: Map<string, unknown>;\n  config: ValiConfig;\n  addIssue: (issue: Issue) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of forward Method in Valibot\nDESCRIPTION: Basic syntax example showing how to use the forward method to pass validation issues from one action to a specific path.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/forward/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.forward<TInput, TIssue, TPath>(action, path);\n```\n\n----------------------------------------\n\nTITLE: Converting Chained Validations to Pipelines\nDESCRIPTION: Demonstrates how to convert Zod's chained validation methods to Valibot's pipeline approach with multiple validation steps.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst Schema = z.string().email().endsWith('@example.com');\n\n// To this\nconst Schema = v.pipe(v.string(), v.email(), v.endsWith('@example.com'));\n```\n\n----------------------------------------\n\nTITLE: Username Schema with Description Metadata\nDESCRIPTION: Example of a username validation schema using the description action. The schema validates that a username is a string matching specific regex requirements, with a title and description that explains the validation rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/description/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UsernameSchema = v.pipe(\n  v.string(),\n  v.regex(/^[a-z0-9_-]{4,16}$/iu),\n  v.title('Username'),\n  v.description(\n    'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Proposed Object Schema Implementation in TypeScript\nDESCRIPTION: Shows the proposed solution using separate optional and undefinedable schema functions to properly handle missing and undefined values in object entries.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-the-object-schema/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object({\n  key1: v.string(),                               // key1: string\n  key2: v.optional(v.string()),                   // key2?: string\n  key3: v.undefinedable(v.string()),              // key3: string | undefined\n  key4: v.optional(v.undefinedable(v.string())),  // key4?: string | undefined\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullish String Schema in Valibot\nDESCRIPTION: Creates a schema that accepts string, undefined, and null values. It also provides a default string value when the input is undefined or null.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullish/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullishStringSchema = v.nullish(v.string(), \"I'm the default!\");\n```\n\n----------------------------------------\n\nTITLE: Validating Number Literal in TypeScript\nDESCRIPTION: This example demonstrates creating a schema to validate a number literal 26 using Valibot's literal function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/literal/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberLiteralSchema = v.literal(26);\n```\n\n----------------------------------------\n\nTITLE: Using toUpperCase in a Pipe Schema (TypeScript)\nDESCRIPTION: Shows how to use the toUpperCase action in a pipe schema to transform a string to uppercase. This example combines the string schema with the toUpperCase action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toUpperCase/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.toUpperCase());\n```\n\n----------------------------------------\n\nTITLE: Defining AddIssue Type with Generic in TypeScript\nDESCRIPTION: This snippet defines the AddIssue type with a generic parameter TInput. It represents a function that takes an input and returns an Issue object or undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawCheck/AddIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype AddIssue<TInput> = (input: TInput) => Issue | undefined;\n```\n\n----------------------------------------\n\nTITLE: Task Schema Implementation - Required Fields Example\nDESCRIPTION: Practical example showing how to create a schema for task validation where optional fields are converted to required fields using requiredAsync.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/requiredAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isOwnerPresent } from '~/api';\n\nconst UpdateTaskSchema = v.objectAsync({\n  owner: v.optionalAsync(\n    v.pipeAsync(\n      v.string(),\n      v.email(),\n      v.checkAsync(isOwnerPresent, 'The owner is not in the database.')\n    )\n  ),\n  title: v.optional(v.pipe(v.string(), v.nonEmpty(), v.maxLength(255))),\n  description: v.optional(v.pipe(v.string(), v.nonEmpty())),\n});\n\nconst NewTaskSchema = v.requiredAsync(UpdateTaskSchema);\n\n/*\n  {\n    owner: string;\n    title: string;\n    description: string;\n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Implementing ISO Time Second Schema with Valibot\nDESCRIPTION: Example schema implementation that validates an ISO time second format. It pipes a string validation with the isoTimeSecond validation, providing a custom error message for invalid formatting.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoTimeSecond/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoTimeSecondSchema = v.pipe(\n  v.string(),\n  v.isoTimeSecond('The time is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Improving Type Safety with Valibot's Pipe, String, Decimal, and Transform in TypeScript\nDESCRIPTION: Shows a more type-safe approach using Valibot's pipe with string and decimal schemas before transforming to a number. This allows for validation of string formatting before conversion.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(v.string(), v.decimal(), v.transform(Number));\n```\n\n----------------------------------------\n\nTITLE: Defining FileIssue Interface Properties in TypeScript\nDESCRIPTION: Interface definition for FileIssue that extends BaseIssue, specifying properties for file validation issues including kind, type, and expected values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FileIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nFileIssue {\n  kind: BaseIssue\n  type: string\n  expected: string\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Definition Generation for Lazy Schemas in JSON Schema Conversion\nDESCRIPTION: Shows how the converter automatically generates definitions for lazy schemas when not explicitly provided.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/to-json-schema/README.md#2025-04-09_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\nconst StringSchema = v.string();\ntoJsonSchema(v.object({ key: v.lazy(() => StringSchema) }));\n\n/*\n{\n  $schema: \"http://json-schema.org/draft-07/schema#\",\n  type: \"object\",\n  properties: {\n    key: {\n      $ref: \"#/$defs/0\",\n    },\n  },\n  required: [\"key\"],\n  additionalProperties: false,\n  $defs: {\n    \"0\": {\n      type: \"string\",\n    },\n  },\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Updating Error Message Configuration\nDESCRIPTION: Shows how to convert Zod's error message configuration to Valibot's simplified string-based approach.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst SchemaSchema = z\n  .string({ invalid_type_error: 'Not a string' })\n  .min(5, { message: 'Too short' });\n\n// To this\nconst StringSchema = v.pipe(\n  v.string('Not a string'),\n  v.minLength(5, 'Too short')\n);\n```\n\n----------------------------------------\n\nTITLE: Sorting Numbers Array Schema Example\nDESCRIPTION: Creates a schema that validates an array of numbers and sorts them in ascending order using the sortItems transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/sortItems/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SortedArraySchema = v.pipe(v.array(v.number()), v.sortItems());\n```\n\n----------------------------------------\n\nTITLE: Nested Variant Schema Implementation\nDESCRIPTION: Demonstration of nesting variant schemas to create more complex validation structures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/variant/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NestedVariantSchema = v.variant('type', [\n  VariantSchema,\n  v.object({\n    type: v.literal('color'),\n    date: v.pipe(v.string(), v.hexColor()),\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating an Undefinedable String Schema in TypeScript\nDESCRIPTION: Example of creating a schema that accepts both string values and undefined, with a default string value to be used when the input is undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefinedable/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UndefinedableStringSchema = v.undefinedable(\n  v.string(),\n  \"I'm the default!\"\n);\n```\n\n----------------------------------------\n\nTITLE: Picking Selected Object Properties\nDESCRIPTION: Example of creating a schema that validates only specific properties from a loose object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseObject/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst PickObjectSchema = v.pick(\n  v.looseObject({\n    key1: v.string(),\n    key2: v.number(),\n    key3: v.boolean(),\n  }),\n  ['key1', 'key3']\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimum Value Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a schema that enforces a minimum value of 10 for a number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/number/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinNumberSchema = v.pipe(v.number(), v.toMinValue(10));\n```\n\n----------------------------------------\n\nTITLE: Basic requiredAsync Usage - TypeScript Schema Definition\nDESCRIPTION: Basic syntax for creating required object schemas using requiredAsync method with both all keys and selected keys options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/requiredAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst AllKeysSchema = v.requiredAsync<TSchema, TMessage>(schema, message);\nconst SelectedKeysSchema = v.requiredAsync<TSchema, TKeys, TMessage>(\n  schema,\n  keys,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Min Graphemes Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a string with a minimum of 8 graphemes using the minGraphemes action in combination with the pipe method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minGraphemes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinGraphemesSchema = v.pipe(\n  v.string(),\n  v.minGraphemes(8, 'The string must contain at least 8 graphemes.')\n);\n```\n\n----------------------------------------\n\nTITLE: VariantSchema Interface Generic Types\nDESCRIPTION: Definition of the generic type parameters used in the VariantSchema interface, including TKey for key type, TOptions for options configuration, and TMessage for error messaging.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VariantSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTKey\nTOptions\nTMessage\n```\n\n----------------------------------------\n\nTITLE: SymbolSchema Interface Definition\nDESCRIPTION: Typescript interface definition showing key properties of the SymbolSchema including type, reference, expects, and message properties. The interface accepts a TMessage generic parameter for custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SymbolSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SymbolSchema<TMessage> {\n  type: 'symbol';\n  reference: string;\n  expects: string;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ArraySchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the ArraySchemaAsync interface. It includes generics for item type and message type, and defines properties such as type, reference, expects, item, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArraySchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nArraySchemaAsync<TItem, TMessage> {\n  type: 'array';\n  reference: Reference;\n  expects: string;\n  item: TItem;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Email or Username Schema with Lazy Async Validation\nDESCRIPTION: Example of using lazyAsync to create a schema that validates an object containing either an email or a username. This approach is recommended only for special cases, as unionAsync and variantAsync are generally better choices for such schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/lazyAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent, isUsernamePresent } from '~/api';\n\nconst EmailOrUsernameSchema = v.lazyAsync((input) => {\n  if (input && typeof input === 'object' && 'type' in input) {\n    switch (input.type) {\n      case 'email':\n        return v.objectAsync({\n          type: v.literal('email'),\n          email: v.pipeAsync(\n            v.string(),\n            v.email(),\n            v.checkAsync(\n              isEmailPresent,\n              'The email is not present in the database.'\n            )\n          ),\n        });\n      case 'username':\n        return v.objectAsync({\n          type: v.literal('username'),\n          username: v.pipeAsync(\n            v.string(),\n            v.nonEmpty(),\n            v.checkAsync(\n              isUsernamePresent,\n              'The username is not present in the database.'\n            )\n          ),\n        });\n    }\n  }\n  return v.never();\n});\n```\n\n----------------------------------------\n\nTITLE: Unwrapping a Non-Optional Schema in Valibot\nDESCRIPTION: Demonstrates how to use the unwrap function to reverse the effect of nonOptional. This creates a schema that accepts undefined values, effectively converting a non-optional schema back to an optional one.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonOptional/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NonOptionalNumberSchema = v.nonOptional(v.optional(v.number()));\nconst OptionalNumberSchema = v.unwrap(NonOptionalNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Getting Fallback Value from a String Schema\nDESCRIPTION: Example showing how to retrieve the fallback value from a string schema. The fallback method is first used to create a schema with a fallback value, then getFallback is used to retrieve that value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getFallback/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FallbackStringSchema = v.fallback(v.string(), \"I'm the fallback!\");\nconst fallbackValue = v.getFallback(FallbackStringSchema); // \"I'm the fallback!\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Lazy Schema in Valibot\nDESCRIPTION: Basic usage example of creating a lazy schema in Valibot. The lazy function takes a getter function that returns the schema and can be used to create recursive schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/lazy/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.lazy<TWrapped>(getter);\n```\n\n----------------------------------------\n\nTITLE: Tuple Schema Fallbacks Example - TypeScript\nDESCRIPTION: Shows how to get fallback values from a tuple schema containing a number with a fallback value of 100.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getFallbacks/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst TupleSchema = v.tuple([v.fallback(v.number(), 100)]);\nconst fallbackValues = v.getFallbacks(TupleSchema); // [100]\n```\n\n----------------------------------------\n\nTITLE: Defining a Graphemes Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a string with exactly 8 graphemes using Valibot's pipe and graphemes actions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/graphemes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst GraphemesSchema = v.pipe(\n  v.string(),\n  v.graphemes(8, 'Exactly 8 graphemes are required.')\n);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Optional Schema in TypeScript\nDESCRIPTION: Demonstrates how to use the 'unwrap' function to remove the optional wrapper from a schema, reverting it to its original non-optional form.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/optional/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalNumberSchema = v.optional(v.number());\nconst NumberSchema = v.unwrap(OptionalNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Max Bytes Schema Implementation - TypeScript\nDESCRIPTION: Example schema implementation that validates a string to ensure it does not exceed 64 bytes. Uses pipe to combine string validation with maxBytes validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxBytes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxBytesSchema = v.pipe(\n  v.string(),\n  v.maxBytes(64, 'The string must not exceed 64 bytes.')\n);\n```\n\n----------------------------------------\n\nTITLE: Declaring NonNullable Schema Type - TypeScript\nDESCRIPTION: Basic syntax for creating a non-nullable schema with generic types for wrapped schema and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonNullable/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonNullable<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with PNPM\nDESCRIPTION: Command to install project dependencies using the PNPM package manager.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/README.md#2025-04-09_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Using InferOutput with Transformed Schema in TypeScript\nDESCRIPTION: Demonstrates how to use InferOutput to infer the output type of an object schema with a transformation. The example creates an object schema with a string property that is transformed to its length (number), then uses InferOutput to get the resulting type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object schema\nconst ObjectSchema = v.object({\n  key: v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n});\n\n// Infer object output type\ntype ObjectOutput = v.InferOutput<typeof ObjectSchema>; // { key: number }\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Optional Schema with Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a non-optional schema in Valibot. This allows you to enforce required values by rejecting undefined inputs, with the option to customize error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonOptional/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonOptional<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Simple Object Schema Definition\nDESCRIPTION: Example of creating a loose object schema with two typed properties: a string and a number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseObject/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SimpleObjectSchema = v.looseObject({\n  key1: v.string(),\n  key2: v.number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Trim Action in String Schema with TypeScript\nDESCRIPTION: This example shows how to use the trim action in combination with a string schema. It creates a schema that first validates the input as a string, then trims whitespace from both ends.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/trim/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.trim());\n```\n\n----------------------------------------\n\nTITLE: Implementing a Branded Fruit Schema in TypeScript\nDESCRIPTION: This example shows how to create a branded schema for fruits using Valibot. It demonstrates schema creation, type inference, and how branding affects type checking.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/brand/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Create schema and infer output type\nconst FruitSchema = v.pipe(v.object({ name: v.string() }), v.brand('Fruit'));\ntype FruitOutput = v.InferOutput<typeof FruitSchema>;\n\n// This works because output is branded\nconst apple: FruitOutput = v.parse(FruitSchema, { name: 'apple' });\n\n// But this will result in a type error\nconst banana: FruitOutput = { name: 'banana' };\n```\n\n----------------------------------------\n\nTITLE: Implementing a Decimal Schema with Valibot\nDESCRIPTION: Example showing how to create a schema that validates a string as a properly formatted decimal. The schema pipes the input through string validation and then decimal format validation with a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/decimal/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DecimalSchema = v.pipe(\n  v.string(),\n  v.decimal('The decimal is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Undefinedable Schema in TypeScript\nDESCRIPTION: Example demonstrating how to use the unwrap function to remove the undefinedable wrapper from a schema, reverting it to its original type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefinedable/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst UndefinedableNumberSchema = v.undefinedable(v.number());\nconst NumberSchema = v.unwrap(UndefinedableNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Creating a Min Words Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a string with a minimum of 50 words using the minWords function in combination with the pipe and string functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minWords/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinWordsSchema = v.pipe(\n  v.string(),\n  v.minWords('en', 50, 'The string must contain at least 50 words.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Strict Tuple Schema in TypeScript\nDESCRIPTION: Basic syntax for creating a strict tuple schema with generic types and optional message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictTuple/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.strictTuple<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Defining SchemaWithoutPipe Type in TypeScript\nDESCRIPTION: This snippet defines the SchemaWithoutPipe type, which is a schema without a pipe type. It uses a generic TSchema and excludes schemas with a pipe property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SchemaWithoutPipe/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SchemaWithoutPipe<TSchema extends BaseSchema> = TSchema extends { pipe: unknown } ? never : TSchema;\n```\n\n----------------------------------------\n\nTITLE: Creating a Symbol Schema with Custom Error Message\nDESCRIPTION: This example shows how to create a symbol schema with a custom error message. The schema will validate that the input is a symbol and return the specified error message if it's not.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/symbol/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = v.symbol('A symbol is required');\n```\n\n----------------------------------------\n\nTITLE: Enforcing Maximum Value for Numbers\nDESCRIPTION: Example schema that enforces a maximum value of 100 for a number using the pipe function with a number schema and toMaxValue transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMaxValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(v.number(), v.toMaxValue(100));\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Nullish String Schema in TypeScript\nDESCRIPTION: Shows how to create a schema for a non-nullish string using the nonNullish function. This schema will not accept null or undefined values for strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonNullish/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NonNullishStringSchema = v.nonNullish(v.nullish(v.string()));\n```\n\n----------------------------------------\n\nTITLE: Validating Array Length with notLength in TypeScript\nDESCRIPTION: This example demonstrates using notLength to validate that an array does not have a specific length. It creates a schema that ensures the array does not contain exactly 10 numbers.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notLength/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(number()),\n  v.notLength(10, 'The array must not contain 10 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Applying toLowerCase in String Schema Pipeline\nDESCRIPTION: Example showing how to combine the toLowerCase action with a string schema using the pipe method to create a schema that validates and transforms strings to lowercase.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toLowerCase/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.toLowerCase());\n```\n\n----------------------------------------\n\nTITLE: Implementing Cuid2 Schema Validation\nDESCRIPTION: Example of creating a schema to validate a Cuid2 string with length validation. The schema pipes together string validation, Cuid2 format validation, and length validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/cuid2/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Cuid2Schema = v.pipe(\n  v.string(),\n  v.cuid2('The Cuid2 is badly formatted.'),\n  v.length(10, 'The Cuid2 must be 10 characters long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining SortItemsAction Interface in TypeScript\nDESCRIPTION: This snippet shows the structure of the SortItemsAction interface. It extends BaseTransformation and includes properties for type, reference, and operation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SortItemsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nSortItemsAction<TInput> extends BaseTransformation {\n  type: 'sort';\n  reference: keyof TInput;\n  operation: 'asc' | 'desc';\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Undefinedable Schema in Valibot\nDESCRIPTION: Example showing how to use the unwrap function to undo the effect of undefinedableAsync. This technique allows reusing an undefinedable schema when the undefinable behavior is not needed.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/undefinedableAsync/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUsernameUnique } from '~/api';\n\nconst UsernameSchema = v.unwrap(\n  // Assume this schema is from a different file and is reused here\n  v.undefinedableAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an IPv4 Address Validation Schema\nDESCRIPTION: Example of creating a complete validation schema for an IPv4 address using Valibot's pipe method. The schema first ensures the input is a string, then validates that it conforms to IPv4 format, with a custom error message if validation fails.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ipv4/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Ipv4Schema = v.pipe(\n  v.string(),\n  v.ipv4('The IP address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Boolean Literal in TypeScript\nDESCRIPTION: This example illustrates how to create a schema to validate a boolean literal 'true' using Valibot's literal function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/literal/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst BooleanLiteralSchema = v.literal(true);\n```\n\n----------------------------------------\n\nTITLE: NonEmptyAction Interface Structure\nDESCRIPTION: Interface definition for NonEmptyAction that extends BaseValidation. Used to validate non-empty values with custom messaging support through generics TInput and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonEmptyAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NonEmptyAction<TInput, TMessage> extends BaseValidation {\n  type: 'non_empty';\n  reference: unknown;\n  expects: 'non_empty';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing PartialInput Type\nDESCRIPTION: Imports for the PartialInput type documentation page, including a Property component and properties configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PartialInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Validating String Literal in TypeScript\nDESCRIPTION: This example shows how to create a schema to validate a string literal 'foo' using Valibot's literal function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/literal/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringLiteralSchema = v.literal('foo');\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Object Schemas with objectWithRest in TypeScript\nDESCRIPTION: Demonstrates how to merge entries from two object schemas into a new schema, with null as the rest type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/objectWithRest/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MergedObjectSchema = v.objectWithRest(\n  {\n    ...ObjectSchema1.entries,\n    ...ObjectSchema2.entries,\n  },\n  v.null()\n);\n```\n\n----------------------------------------\n\nTITLE: Validating String Length in TypeScript\nDESCRIPTION: Example schema that validates a string must be exactly 8 characters long using pipe and length validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/length/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(\n  v.string(),\n  v.length(8, 'The string must be 8 characters long.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Credit Card Validation Action in TypeScript\nDESCRIPTION: This snippet shows the basic syntax for creating a credit card validation action using the creditCard function from Valibot. It demonstrates the use of generics for input type and message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/creditCard/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.creditCard<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Map Schema in TypeScript using Valibot\nDESCRIPTION: Defines a schema to validate a map with string keys and object values. The object values are expected to have a 'key' property of type string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/map/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectMapSchema = v.map(v.string(), v.object({ key: v.string() }));\n```\n\n----------------------------------------\n\nTITLE: TupleWithRestSchema Interface Definition\nDESCRIPTION: Type definition showing the structure of TupleWithRestSchema interface that extends BaseSchema with tuple-specific properties including items and rest schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TupleWithRestSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TupleWithRestSchema<TItems, TRest, TMessage> extends BaseSchema {\n  type: 'tuple';\n  reference: Reference;\n  expects: string;\n  items: TItems;\n  rest: TRest;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Early Pipeline Abort Configuration\nDESCRIPTION: Example demonstrating how to configure a schema to abort pipeline validation early for specific fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/config/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object({\n  url: v.config(\n    v.pipe(v.string(), v.trim(), v.url(), v.endsWith('@example.com')),\n    { abortPipeEarly: true }\n  ),\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing ISO Timestamp Schema Validation\nDESCRIPTION: Example showing how to create a schema that validates ISO timestamps by combining string validation with isoTimestamp validation action. Includes custom error message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoTimestamp/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoTimestampSchema = v.pipe(\n  v.string(),\n  v.isoTimestamp('The timestamp is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Number Schema Transformation Comparison\nDESCRIPTION: Shows the difference in implementing number transformation between proposed and current API.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// With the new `pipe` function\nconst NumberSchema = pipe(\n  string(),\n  toTrimmed(),\n  decimal(),\n  transform(parseInt)\n);\n\n// With Valibot's current API\nconst NumberSchema = transform(\n  string([toTrimmed(), decimal()]),\n  parseInt\n);\n```\n\n----------------------------------------\n\nTITLE: Union Schema Error Structure Example\nDESCRIPTION: Shows the error structure returned when validating invalid input against a union schema, demonstrating how subissues are handled for each schema type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/unions/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[\n  {\n    kind: 'schema',\n    type: 'union',\n    input: null,\n    expected: 'string | number',\n    received: 'null',\n    message: 'Invalid type: Expected string | number but received null',\n    issues: [\n      {\n        kind: 'schema',\n        type: 'string',\n        input: null,\n        expected: 'string',\n        received: 'null',\n        message: 'Invalid type: Expected string but received null',\n      },\n      {\n        kind: 'schema',\n        type: 'number',\n        input: null,\n        expected: 'number',\n        received: 'null',\n        message: 'Invalid type: Expected number but received null',\n      },\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining Product Function Schema with argsAsync in TypeScript\nDESCRIPTION: This example shows how to use argsAsync to define a schema for a function that returns a product by its ID. It includes input validation, argument checking, and return type specification.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/argsAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isValidProductId } from '~/api';\n\nconst ProductFunctionSchema = v.pipeAsync(\n  v.function(),\n  v.argsAsync(\n    v.tupleAsync([v.pipeAsync(v.string(), v.checkAsync(isValidProductId))])\n  ),\n  v.returnsAsync(\n    v.pipeAsync(\n      v.promise(),\n      v.awaitAsync(),\n      v.object({\n        id: v.string(),\n        name: v.string(),\n        price: v.number(),\n      })\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Finite Number Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a finite number using Valibot. It combines the 'number' and 'finite' validations in a pipe.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/finite/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FiniteNumberSchema = v.pipe(\n  v.number(),\n  v.finite('The number must be finite.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Literal Schemas in Valibot\nDESCRIPTION: Demonstrates how to use the literal schema function to match specific string, number, or boolean values, representing literal types in TypeScript.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/other/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst StringLiteralSchema = v.literal('foo'); // 'foo'\nconst NumberLiteralSchema = v.literal(12345); // 12345\nconst BooleanLiteralSchema = v.literal(true); // true\n```\n\n----------------------------------------\n\nTITLE: LastTupleItem Type Definition\nDESCRIPTION: Defines the LastTupleItem type utility that extracts the type of the last item from a tuple type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LastTupleItem/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nLastTupleItem\n```\n\n----------------------------------------\n\nTITLE: Creating a Min Words Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the minWords function to create a validation action. It specifies the input type, locales, requirement, and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minWords/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.minWords<TInput, TLocales, TRequirement, TMessage>(\n  locales,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Basic nullableAsync Schema Definition\nDESCRIPTION: Basic syntax for creating a nullable schema with optional default value using nullableAsync.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nullableAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nullableAsync<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Defining an Allowed Country Schema with nonNullishAsync in TypeScript\nDESCRIPTION: This example shows how to use nonNullishAsync to create a schema that checks if a string matches one of the allowed country names. It combines nonNullishAsync with other schema functions and asynchronous validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonNullishAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAllowedCountry } from '~/api';\n\nconst AllowedCountrySchema = v.nonNullishAsync(\n  // Assume this schema is from a different file and reused here.\n  v.nullishAsync(\n    v.pipeAsync(v.string(), v.nonEmpty(), v.checkAsync(isAllowedCountry))\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a notLength Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a notLength validation action. It validates that the input does not have a specific length, with customizable error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notLength/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.notLength<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Enforcing Minimum Date Value in Valibot\nDESCRIPTION: Example demonstrating how to create a schema that enforces a minimum date value. If the input date is earlier than December 31, 1999, it will be transformed to that date.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMinValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(v.date(), v.toMinValue(new Date('1999-12-31')));\n```\n\n----------------------------------------\n\nTITLE: Implementing Hex Color Schema Validation\nDESCRIPTION: Example showing how to create a schema that validates hex color strings by combining string validation with hex color format validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/hexColor/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst HexColorSchema = v.pipe(\n  v.string(),\n  v.hexColor('The hex color is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Replacing Schema Merge Operations\nDESCRIPTION: Shows how to replace the merge function with direct object entry spreading for combining multiple object schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/codemod/migrate-to-v0.31.0/README.md#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ObjectSchema1 = v.object({ foo: v.string() });\nconst ObjectSchema2 = v.object({ bar: v.number() });\n\nconst MergedObject = v.merge([ObjectSchema1, ObjectSchema2]);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ObjectSchema1 = v.object({ foo: v.string() });\nconst ObjectSchema2 = v.object({ bar: v.number() });\n\nconst MergedObject = v.object({\n  ...ObjectSchema1.entries,\n  ...ObjectSchema2.entries,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining NullableSchemaAsync Interface Structure\nDESCRIPTION: Interface definition showing the structure of NullableSchemaAsync with its generics and properties. The interface extends BaseSchemaAsync and includes type information, reference handling, expectations, wrapped schema, and default value handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NullableSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NullableSchemaAsync<TWrapped, TDefault> extends BaseSchemaAsync {\n  type: 'nullable';\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DateIssue Interface in TypeScript\nDESCRIPTION: The DateIssue interface extends BaseIssue and includes properties for kind, type, and expected value. It is used to represent issues related to date validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DateIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nDateIssue extends BaseIssue {\n  kind: 'date';\n  type: 'invalid_date';\n  expected: 'date';\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Function Arguments Transformation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the 'args' function to create a transformation action for function arguments. It specifies the input type and schema type as generics.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/args/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.args<TInput, TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Creating an Excludes Validation Action in Valibot\nDESCRIPTION: Basic syntax for creating an excludes validation action in Valibot, which validates that a string or array does not contain a specific element defined by the requirement parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/excludes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.excludes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Validating Dates with ltValue in TypeScript\nDESCRIPTION: Schema implementation that validates if a date is before January 1st, 2000, combining the date() validator with ltValue in a pipe.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ltValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(\n  v.date(),\n  v.ltValue(\n    new Date('2000-01-01'),\n    'The date must be less than 1st January 2000.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Bytes Validation Action Definition\nDESCRIPTION: Basic syntax for creating a bytes validation action. Used to validate the byte length of strings with optional custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/bytes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.bytes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Defining Object Schema with Rest and Specific Entry Types in TypeScript\nDESCRIPTION: Shows how to create an object schema with specific entry types for known keys and a boolean type for additional unknown properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/objectWithRest/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchemaWithRest = v.objectWithRest(\n  {\n    key1: v.string(),\n    key2: v.number(),\n  },\n  v.boolean()\n);\n```\n\n----------------------------------------\n\nTITLE: Defining PromiseSchema Interface in TypeScript\nDESCRIPTION: This code snippet outlines the structure of the PromiseSchema interface. It extends BaseSchema and includes specific properties for Promise validation such as type, reference, expects, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PromiseSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nPromiseSchema<TMessage> extends BaseSchema {\n  type: 'promise';\n  reference: SchemaWithOutput<unknown>;\n  expects: unknown;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a toMinValue Transformation Action in Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a toMinValue transformation action. This action enforces a minimum value for numbers, dates, or strings by transforming inputs that don't meet the requirement to the minimum value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMinValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.toMinValue<TInput, TRequirement>(requirement);\n```\n\n----------------------------------------\n\nTITLE: Hash Schema Implementation Example\nDESCRIPTION: Example of creating a schema that validates hash strings by combining string validation with hash validation. Uses pipe to chain validations and supports multiple hash types like MD5 and SHA1.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/hash/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst HashSchema = v.pipe(\n  v.string(),\n  v.hash(['md5', 'sha1'], 'The specified hash is invalid.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Nullable Date Schema in TypeScript with Valibot\nDESCRIPTION: Example of creating a nullable date schema that accepts Date objects and null values, with a default function that returns a new Date instance.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullable/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullableDateSchema = v.nullable(v.date(), () => new Date());\n```\n\n----------------------------------------\n\nTITLE: Defining BaseValidationAsync Interface in TypeScript\nDESCRIPTION: This code snippet defines the BaseValidationAsync interface, which includes generics for input, output, and issue types. It specifies properties for reference, async flag, and a run method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseValidationAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nBaseValidationAsync<TInput, TOutput, TIssue> {\n  reference: unknown;\n  async: true;\n  ~run: (input: TInput, info: ValidationInfo) => Promise<BaseValidationResult<TOutput, TIssue>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Number Validation Schema with notValues\nDESCRIPTION: Demonstrates how to create a validation schema for numbers that must not equal 10, 11, or 12, combining pipe and notValues actions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notValues/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.notValues([10, 11, 12], 'The number must not be 10, 11 or 12.')\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing notValues Validation Action in TypeScript\nDESCRIPTION: Shows the basic syntax for creating a notValues validation action with type parameters for input, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notValues/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.notValues<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Basic everyItem Action Syntax in TypeScript\nDESCRIPTION: Shows the basic syntax for creating an everyItem validation action in Valibot. This action validates that every item in an array meets a specified requirement, with an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/everyItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.everyItem<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: FirstTupleItem Usage Example\nDESCRIPTION: Component usage showing the generic parameter TTuple and FirstTupleItem type definition.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FirstTupleItem/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n# FirstTupleItem\n\nExtracts first tuple item.\n\n## Generics\n\n- `TTuple` <Property {...properties.TTuple} />\n\n## Definition\n\n- `FirstTupleItem` <Property {...properties.FirstTupleItem} />\n```\n\n----------------------------------------\n\nTITLE: Creating gtValue Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a greater than value validation action with type parameters for input, requirement, and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/gtValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.gtValue<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Loose Tuple Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a loose tuple schema using the looseTuple function from Valibot. It specifies the generic types, parameters, and return type of the function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseTuple/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.looseTuple<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Defining EnumSchema Interface in TypeScript\nDESCRIPTION: This code snippet defines the structure of the EnumSchema interface. It includes generics for enum type and message, and specifies the properties of the schema such as type, reference, enum, options, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EnumSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nEnumSchema<TEnum, TMessage> {\n  type: 'enum';\n  reference: TEnum;\n  enum: TEnum;\n  options?: SchemaOptions;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: PartialDataset Interface Structure\nDESCRIPTION: Interface definition showing the structure of PartialDataset with generics TValue and TIssue, and core properties including typed, value, and issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PartialDataset/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PartialDataset<TValue, TIssue> {\n  typed: boolean;\n  value: TValue;\n  issues: TIssue[];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Max Graphemes Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates a string with a maximum of 8 graphemes using the maxGraphemes action in combination with the pipe method and string schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxGraphemes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxGraphemesSchema = v.pipe(\n  v.string(),\n  v.maxGraphemes(8, 'The string must not exceed 8 graphemes.')\n);\n```\n\n----------------------------------------\n\nTITLE: Validating Set Size with MinSize in TypeScript\nDESCRIPTION: Schema implementation to validate a set that must contain at least 8 numbers using pipe and minSize validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minSize/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst SetSchema = v.pipe(\n  v.set(number()),\n  v.minSize(8, 'The set must contain at least 8 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Exact Optional Async Schema\nDESCRIPTION: Demonstration of using the unwrap function to undo the effect of exactOptionalAsync, which is useful when you need to reuse a schema without its optional behavior.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/exactOptionalAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUsernameUnique } from '~/api';\n\nconst UsernameSchema = v.unwrap(\n  // Assume this schema is from a different file and is reused here\n  v.exactOptionalAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Converting Zod's Coerce Number to Valibot's Pipe and Transform in TypeScript\nDESCRIPTION: Demonstrates how to convert Zod's coerce.number() method to Valibot's pipe and transform approach. This enforces primitive values and explicitly defines the input for safer code.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst NumberSchema = z.coerce.number();\n\n// To this\nconst NumberSchema = v.pipe(v.unknown(), v.transform(Number));\n```\n\n----------------------------------------\n\nTITLE: Defining StrictObjectSchema Interface in TypeScript\nDESCRIPTION: This code snippet outlines the structure of the StrictObjectSchema interface. It extends BaseSchema and includes properties for type, reference, expects, entries, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StrictObjectSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nStrictObjectSchema<TEntries, TMessage> extends BaseSchema {\n  type: 'object';\n  reference: 'strict';\n  expects: string;\n  entries: TEntries;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getDefault with Optional String Schema\nDESCRIPTION: Example showing how to use getDefault to retrieve the default value from an optional string schema with a predefined default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getDefault/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalStringSchema = v.optional(v.string(), \"I'm the default!\");\nconst defaultValue = v.getDefault(OptionalStringSchema); // \"I'm the default!\"\n```\n\n----------------------------------------\n\nTITLE: ULID Schema Implementation Example in Valibot\nDESCRIPTION: A practical example showing how to create a schema to validate ULID strings. This combines the string validator with the ULID format validator in a pipe, and includes a custom error message for format validation failures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ulid/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UlidSchema = v.pipe(v.string(), v.ulid('The ULID is badly formatted.'));\n```\n\n----------------------------------------\n\nTITLE: NonOptionalSchema Interface Type Definition\nDESCRIPTION: TypeScript interface definition for NonOptionalSchema that extends BaseSchema with properties for type, reference, expectations, wrapped values and error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonOptionalSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NonOptionalSchema<TWrapped, TMessage> extends BaseSchema {\n  type: string;\n  reference: unknown;\n  expects: string;\n  wrapped: TWrapped;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Sorted Array Schema with everyItem\nDESCRIPTION: Example of using everyItem to create a schema that validates if an array of numbers is sorted in ascending order. The requirement function checks if each item is greater than or equal to the previous item in the array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/everyItem/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SortedArraySchema = v.pipe(\n  v.array(v.number()),\n  v.everyItem(\n    (item, index, array) => index === 0 || item >= array[index - 1],\n    'The numbers must be sorted in ascending order.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Validating a Number with MaxValue in Valibot\nDESCRIPTION: Schema example that validates a number with a maximum value of 100. It first validates that the input is a number, then ensures it doesn't exceed 100.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxValue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = v.pipe(\n  v.number(),\n  v.maxValue(100, 'The number must not exceed 100.')\n);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Optional String Schema in Valibot (TypeScript)\nDESCRIPTION: Shows a specific example of unwrapping an optional string schema. This example creates an optional string schema and then unwraps it to get a non-optional string schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/unwrap/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalStringSchema = v.optional(v.string());\nconst StringSchema = v.unwrap(OptionalStringSchema);\n```\n\n----------------------------------------\n\nTITLE: Example of entriesFromObjects with Schema Overwriting in Valibot\nDESCRIPTION: Shows a practical example of using entriesFromObjects with multiple object schemas. The third schema overwrites the 'foo' and 'baz' properties defined in previous schemas, demonstrating the merging behavior.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/entriesFromObjects/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object(\n  v.entriesFromObjects([\n     v.object({ foo:  v.string(), bar:  v.string() });\n     v.object({ baz:  v.number(), qux:  v.number() });\n     v.object({ foo:  v.boolean(), baz:  v.boolean() });\n  ])\n);\n```\n\n----------------------------------------\n\nTITLE: Optional Properties in Strict Object Schema\nDESCRIPTION: Shows how to create a partial object schema where all properties are optional using the partial wrapper.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/strictObject/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialObjectSchema = v.partial(\n  v.strictObject({\n    key1: v.string(),\n    key2: v.number(),\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Maximum Value Bigint Schema in Valibot\nDESCRIPTION: Demonstrates how to create a schema that validates a maximum bigint value. This combines the bigint schema with the maxValue action to validate an upper boundary.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/bigint/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MaxBigintSchema = v.pipe(v.bigint(), v.maxValue(999n));\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fallback Values for New User Schema in TypeScript\nDESCRIPTION: Example demonstrating how to use getFallbacksAsync with a custom NewUserSchema to retrieve fallback values, including an asynchronous fallback for the username field.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/getFallbacksAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAnyUniqueUsername, isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  username: v.fallbackAsync(\n    v.pipeAsync(v.string(), v.minLength(3), v.checkAsync(isUsernameUnique)),\n    getAnyUniqueUsername\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\nconst fallbackValues = await v.getFallbacksAsync(NewUserSchema);\n/*\n  {\n    username: \"cookieMonster07\",\n    password: undefined\n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining NotBytesAction Interface Components in TypeScript\nDESCRIPTION: Interface structure showing the components of NotBytesAction including type, reference, expects, requirement and message properties along with generics TInput, TRequirement, and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotBytesAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NotBytesAction<TInput, TRequirement, TMessage> {\n  type: 'not_bytes';\n  reference: TInput;\n  expects: string;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Object Schema Fallbacks Example - TypeScript\nDESCRIPTION: Demonstrates how to retrieve fallback values from an object schema where a string property has a defined fallback value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getFallbacks/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.object({\n  key: v.fallback(v.string(), \"I'm the fallback!\"),\n});\n\nconst fallbackValues = v.getFallbacks(ObjectSchema); // { key: \"I'm the fallback!\" }\n```\n\n----------------------------------------\n\nTITLE: Creating a 64-bit MAC Address Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a 64-bit MAC address validation action using Valibot. The function accepts an optional custom error message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mac64/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.mac64<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: InferMapOutput Type Definition in TypeScript\nDESCRIPTION: Defines type parameters TKey and TValue that are used to infer the output type structure of a map. TKey represents the key type while TValue represents the value type for the map.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferMapOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nInferMapOutput<TKey, TValue>\n```\n\n----------------------------------------\n\nTITLE: Validating Set Size with maxSize in TypeScript\nDESCRIPTION: Example of using maxSize to create a schema that validates a set with a maximum of 8 numbers. The schema uses a pipe to combine set validation with size validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxSize/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst SetSchema = v.pipe(\n  v.set(number()),\n  v.maxSize(8, 'The set must not exceed 8 numbers.')\n);\n```\n\n----------------------------------------\n\nTITLE: Object Intersection Example in Valibot\nDESCRIPTION: Example demonstrating how to combine two object schemas using the intersect function, resulting in a schema that requires both a string 'foo' and a number 'bar' property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/intersect/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema = v.intersect([\n  v.object({ foo: v.string() }),\n  v.object({ bar: v.number() }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining SafeParser Interface in TypeScript\nDESCRIPTION: This code snippet defines the SafeParser interface with generics for schema and configuration. It specifies the function signature and required properties for schema and config.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SafeParser/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nSafeParser<TSchema, TConfig> = {\n  function: (input: unknown, config?: TConfig) => SafeParseResult<Output<TSchema>>,\n  schema: TSchema,\n  config?: TConfig\n}\n```\n\n----------------------------------------\n\nTITLE: Using Brand and Transform in Valibot Pipelines with TypeScript\nDESCRIPTION: Shows how to use the brand and transform actions within a Valibot pipe method, replacing the previous method of wrapping schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst BrandedSchema = v.brand(v.string(), 'foo');\nconst TransformedSchema = v.transform(v.string(), (input) => input.length);\n\n// To this\nconst BrandedSchema = v.pipe(v.string(), v.brand('foo'));\nconst TransformedSchema = v.pipe(\n  v.string(),\n  v.transform((input) => input.length)\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Undefinedable Date Schema in TypeScript\nDESCRIPTION: Example of creating a schema that accepts both Date objects and undefined values, with a function that generates a new Date as the default value when the input is undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefinedable/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst UndefinedableDateSchema = v.undefinedable(v.date(), () => new Date());\n```\n\n----------------------------------------\n\nTITLE: Defining ExactOptionalSchemaAsync Interface in TypeScript\nDESCRIPTION: This code snippet defines the ExactOptionalSchemaAsync interface, extending BaseSchemaAsync. It includes properties for type, reference, expects, wrapped, and default values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ExactOptionalSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nExactOptionalSchemaAsync<TWrapped, TDefault> extends BaseSchemaAsync {\n  type: 'exact_optional';\n  reference: Reference;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getFallback Method in Valibot\nDESCRIPTION: Basic syntax for using the getFallback method to retrieve the fallback value from a schema. This method takes a schema object, an optional dataset, and configuration options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getFallback/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = v.getFallback<TSchema>(schema, dataset, config);\n```\n\n----------------------------------------\n\nTITLE: Creating an Undefinedable Username Schema with Async Validation\nDESCRIPTION: Example of an undefinedable username schema that validates uniqueness asynchronously. If the input is undefined, it generates a unique username using a function provided as the default parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/undefinedableAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUniqueUsername, isUsernameUnique } from '~/api';\n\nconst UndefinedableUsernameSchema = v.undefinedableAsync(\n  v.pipeAsync(\n    v.string(),\n    v.nonEmpty(),\n    v.checkAsync(isUsernameUnique, 'The username is not unique.')\n  ),\n  getUniqueUsername\n);\n```\n\n----------------------------------------\n\nTITLE: Defining BaseTransformationAsync Interface in TypeScript\nDESCRIPTION: Type definition for the BaseTransformationAsync interface that includes generics for input, output, and issue types along with reference and run method definitions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseTransformationAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BaseTransformationAsync<TInput, TOutput, TIssue> {\n  reference?: string;\n  async: true;\n  run(input: TInput): Promise<TOutput>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating URL Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a URL validation action with optional message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/url/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.url<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Using Definitions in Valibot to JSON Schema Conversion\nDESCRIPTION: Demonstrates how to use the definitions configuration to create named schema definitions during the conversion process.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/to-json-schema/README.md#2025-04-09_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.email());\ntoJsonSchema(v.object({ email: EmailSchema }), {\n  definitions: { EmailSchema },\n});\n\n/*\n{\n  $schema: \"http://json-schema.org/draft-07/schema#\",\n  type: \"object\",\n  properties: {\n    email: {\n      $ref: \"#/$defs/EmailSchema\",\n    },\n  },\n  required: [\"email\"],\n  additionalProperties: false,\n  $defs: {\n    EmailSchema: {\n      type: \"string\",\n      format: \"email\",\n    },\n  },\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Creating maxBytes Validation Action - TypeScript\nDESCRIPTION: Basic syntax for creating a maxBytes validation action. Used to validate the byte length of strings with custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxBytes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxBytes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Validating Non-Empty Arrays with Valibot in TypeScript\nDESCRIPTION: Example of creating a schema to validate that an array is non-empty using Valibot's pipe and nonEmpty functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/nonEmpty/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ArraySchema = v.pipe(\n  v.array(v.number()),\n  v.nonEmpty('The array should contain at least one item.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining FunctionSchema Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the FunctionSchema interface. It includes a generic type parameter TMessage and defines properties like type, reference, expects, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FunctionSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nFunctionSchema<TMessage> {\n  type: 'function';\n  reference: Function;\n  expects: SchemaWithoutDefault<unknown>[];\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Valibot Error Issues in TypeScript\nDESCRIPTION: Demonstrates the updated usage of the flatten function, which now accepts only an array of issues instead of a ValiError or an array of issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst flatErrors = v.flatten(error);\n\n// To this\nconst flatErrors = v.flatten(error.issues);\n```\n\n----------------------------------------\n\nTITLE: Implementing Convention 1: Identical Schema and Type Names in TypeScript\nDESCRIPTION: Demonstrates the first naming convention where schema and type share the same PascalCase name. Creates a PublicUser schema with validation rules for name, email, avatar, and bio fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/naming-convention/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nexport const PublicUser = v.object({\n  name: v.pipe(v.string(), v.maxLength(30)),\n  email: v.pipe(v.string(), v.email()),\n  avatar: v.nullable(v.file()),\n  bio: v.pipe(v.string(), v.maxLength(1000)),\n});\n\nexport type PublicUser = v.InferOutput<typeof PublicUser>;\n```\n\n----------------------------------------\n\nTITLE: TypedDataset Interface Structure\nDESCRIPTION: Defines the structure of a TypedDataset interface with three main properties: typed, value, and issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnknownDataset/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `TypedDataset`\n  - `typed` <Property {...properties.typed} />\n  - `value` <Property {...properties.value} />\n  - `issues` <Property {...properties.issues} />\n```\n\n----------------------------------------\n\nTITLE: Creating a ValiError instance in TypeScript\nDESCRIPTION: Demonstrates how to instantiate a new ValiError object with validation issues. ValiError is a utility class that creates Valibot errors with structured information about validation failures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/ValiError/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst error = new v.ValiError<TSchema>(issues);\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Schema with Nullish Entry in Valibot\nDESCRIPTION: Demonstrates how to use a nullish schema as part of an object schema, allowing a specific property to be a string, undefined, or null.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullish/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullishEntrySchema = v.object({\n  key: v.nullish(v.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GenericSchema Type in TypeScript\nDESCRIPTION: This snippet defines the GenericSchema type with three generic parameters: TInput, TOutput, and TIssue. It extends the BaseSchema type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericSchema<TInput = unknown, TOutput = TInput, TIssue = Issue> = BaseSchema<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: Creating ISO Time Validation Action in TypeScript\nDESCRIPTION: Demonstrates the basic syntax for creating an ISO time validation action with optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoTime/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.isoTime<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Modifying Schema Parse Methods\nDESCRIPTION: Shows how to update schema parsing methods from Zod's chained approach to Valibot's functional approach.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-from-zod/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst value = z.string().parse('foo');\n\n// To this\nconst value = v.parse(v.string(), 'foo');\n```\n\n----------------------------------------\n\nTITLE: Creating Readonly Action - TypeScript\nDESCRIPTION: Basic example of creating a readonly transformation action with generic type input.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/readonly/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.readonly<TInput>();\n```\n\n----------------------------------------\n\nTITLE: Validating Minimum Object Properties with minEntries\nDESCRIPTION: Example schema that validates an object with at least 5 properties using pipe and record schemas combined with minEntries validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minEntries/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinEntriesSchema = v.pipe(\n  v.record(v.string(), v.number()),\n  v.minEntries(5, 'The object should have at least 5 entries.')\n);\n```\n\n----------------------------------------\n\nTITLE: BlobSchema Interface Structure\nDESCRIPTION: Defines the structure of the BlobSchema interface with its generic type parameter TMessage and core properties including type, reference, expects, and message fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BlobSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BlobSchema<TMessage> {\n  type: 'blob';\n  reference: Blob;\n  expects: string;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EveryItemIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the EveryItemIssue interface, which extends BaseIssue. It includes properties for kind, type, expected value, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EveryItemIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EveryItemIssue<TInput> extends BaseIssue {\n  kind: 'every_item';\n  type: string;\n  expected: string;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Convention 1: Schema and Type Usage Example\nDESCRIPTION: Shows how to import and use the PublicUser schema and type together for validation and type checking.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/naming-convention/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { PublicUser } from './types';\n\n// Use `PublicUser` as a type\nconst publicUsers: PublicUser[] = [];\n\npublicUsers.push(\n  // Use `PublicUser` as a schema\n  v.parse(PublicUser, {\n    name: 'Jane Doe',\n    email: 'jane@example.com',\n    avatar: null,\n    bio: 'Lorem ipsum ...',\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Issue Type in TypeScript\nDESCRIPTION: TypeScript type definition for a BaseIssue in Valibot, detailing the structure of validation issues including required and optional properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/issues/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype BaseIssue = {\n  // Required info\n  kind: 'schema' | 'validation' | 'transformation';\n  type: string;\n  input: unknown;\n  expected: string | null;\n  received: string;\n  message: string;\n\n  // Optional info\n  requirement?: unknown;\n  path?: IssuePath;\n  issues?: Issues;\n  lang?: string;\n  abortEarly?: boolean;\n  abortPipeEarly?: boolean;\n  skipPipe?: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining NonNullishSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the NonNullishSchemaAsync interface, which extends BaseSchemaAsync. It includes properties for type, reference, expects, wrapped, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullishSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nNonNullishSchemaAsync<TWrapped, TMessage> extends BaseSchemaAsync {\n  type: 'non_nullish';\n  reference: TWrapped;\n  expects: string;\n  wrapped: TWrapped;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Intersect Input Types with InferIntersectInput in Valibot\nDESCRIPTION: Example showing how to use InferIntersectInput to determine the combined input type of multiple object schemas that use pipe and transform. The resulting type includes the pre-transformation input fields from all schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferIntersectInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object schemas\nconst ObjectSchemas = [\n  v.object({\n    key1: v.pipe(\n      v.string(),\n      v.transform((input) => input.length)\n    ),\n  }),\n  v.object({\n    key2: v.pipe(\n      v.string(),\n      v.transform((input) => input.length)\n    ),\n  }),\n];\n\n// Infer object intersect input type\ntype ObjectInput = v.InferIntersectInput<typeof ObjectSchemas>; // { key1: string } & { key2: string }\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interface for Async Validation Action\nDESCRIPTION: Interface that defines the structure of an asynchronous validation check action. Includes generic types for input and message handling, along with properties for validation type, reference, expectations, requirements and error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/CheckActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CheckActionAsync<TInput, TMessage> {\n  type: 'async';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => Promise<boolean>;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonNullish Type Utility in TypeScript\nDESCRIPTION: The NonNullish type utility extracts null and undefined from a given type TValue. It uses a generic parameter TValue and returns a new type excluding null and undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullish/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype NonNullish<TValue> = TValue extends null | undefined ? never : TValue;\n```\n\n----------------------------------------\n\nTITLE: Creating a BIC Validation Action in Valibot\nDESCRIPTION: Basic syntax for creating a BIC validation action in Valibot. The function accepts an optional custom error message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/bic/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.bic<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Non-Nullable String Schema - TypeScript\nDESCRIPTION: Example showing how to create a non-nullable string schema by wrapping a nullable string schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonNullable/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NonNullableStringSchema = v.nonNullable(v.nullable(v.string()));\n```\n\n----------------------------------------\n\nTITLE: Basic Returns Action Definition in TypeScript\nDESCRIPTION: Basic syntax for creating a returns transformation action with generic types for input and schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/returns/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.returns<TInput, TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Creating a String Schema with notGraphemes Validation in TypeScript\nDESCRIPTION: Example schema that validates a string to ensure it does not have exactly 8 graphemes. It combines the string schema with the notGraphemes validation using pipe.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notGraphemes/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NotGraphemesSchema = v.pipe(\n  v.string(),\n  v.notGraphemes(8, 'The string must not have 8 graphemes.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NullSchema Interface Properties in TypeScript\nDESCRIPTION: TypeScript interface definition for NullSchema that extends BaseSchema interface. It specifies type, reference, expects, and message properties that define the schema validation behavior for null values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NullSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NullSchema<TMessage> extends BaseSchema {\n  type: 'null';\n  reference: null;\n  expects: 'null';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Default Value Schema in TypeScript\nDESCRIPTION: Demonstrates the verbose syntax required to define default values for both optional and undefinedable cases in the proposed implementation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-the-object-schema/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object({\n  key: v.optional(\n    v.undefinedable(v.string(), 'undefinedable_default'),\n    'optional_default'\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Union Schema in TypeScript with Valibot\nDESCRIPTION: Demonstrates how to create a union schema that accepts either string or number values using Valibot's union function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/unions/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// TypeScript\ntype Union = string | number;\n\n// Valibot\nconst UnionSchema = v.union([v.string(), v.number()]);\n```\n\n----------------------------------------\n\nTITLE: SafeIntegerIssue Interface Structure in TypeScript\nDESCRIPTION: Interface definition showing the structure of SafeIntegerIssue, which extends BaseIssue with properties specific to safe integer validation. It includes a generic type parameter TInput and properties for kind, type, expected value, received value, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SafeIntegerIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SafeIntegerIssue<TInput> extends BaseIssue {\n  kind: 'type';\n  type: 'safe_integer';\n  expected: 'safe_integer';\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Conditional Image Components in JSX\nDESCRIPTION: Renders two image components for the playground, conditionally displaying one based on dark mode.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/how-valibot-has-evolved-this-year/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<PlaygroundDark\n  alt=\"The new playground to write, test and share schemas\"\n  class=\"hidden dark:block\"\n/>\n<PlaygroundLight\n  alt=\"The new playground to write, test and share schemas\"\n  class=\"dark:hidden\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Implementing Digits Schema Validation in TypeScript\nDESCRIPTION: Example showing how to create a schema that validates if a string contains only numerical digits, using pipe to combine string validation with digits validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/digits/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DigitsSchema = v.pipe(\n  v.string(),\n  v.digits('The string contains something other than digits.')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining SchemaWithPipeAsync Type in TypeScript\nDESCRIPTION: This snippet defines the SchemaWithPipeAsync type, which extends a schema with an asynchronous pipe function. It includes generics for the pipe type and properties for the pipe function, async flag, and internal types and run function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SchemaWithPipeAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SchemaWithPipeAsync<TPipe> = {\n  pipe: TPipe;\n  async: true;\n  '~types': any;\n  '~run': any;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MIME Type Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the mimeType function to create a MIME type validation action. It shows the function signature with generic types for input, requirement, and custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mimeType/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.mimeType<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping a Nullable Schema in TypeScript with Valibot\nDESCRIPTION: Demonstrates how to use the 'unwrap' function to remove the nullable property from a schema, reverting it to its original non-nullable form.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullable/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullableNumberSchema = v.nullable(v.number());\nconst NumberSchema = v.unwrap(NullableNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Creating a 64-bit MAC Address Schema with Valibot\nDESCRIPTION: Example of creating a schema to validate a 64-bit MAC address by piping a string validation with a MAC address validation. The schema includes a custom error message for invalid MAC addresses.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mac64/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Mac64Schema = v.pipe(\n  v.string(),\n  v.mac64('The MAC address is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Basic getFallbacks Method Usage - TypeScript\nDESCRIPTION: Basic syntax example showing how to use the getFallbacks method with a schema to retrieve fallback values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getFallbacks/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst values = v.getFallbacks<TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Optional Object Schema Properties\nDESCRIPTION: Creates a schema where all object properties are optional using the partial wrapper\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/object/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst PartialObjectSchema = v.partial(\n  v.object({\n    key1: v.string(),\n    key2: v.number(),\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Pipeline Validation for Tuples in Valibot\nDESCRIPTION: Combines tuple validation with pipeline validation for additional constraints. This example validates a tuple starting with a string, followed by any number of strings, with constraints on length and content.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/arrays/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst TupleSchema = v.pipe(\n  v.tupleWithRest([v.string()], v.string()),\n  v.maxLength(5),\n  v.includes('foo'),\n  v.excludes('bar')\n);\n```\n\n----------------------------------------\n\nTITLE: Pixel Value Validation and Transformation Pipeline\nDESCRIPTION: Shows how to create a validation pipeline that transforms string pixel values into numbers and applies additional validation rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/first-draft-of-the-new-pipe-function/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst PixelSchema = v.pipe(\n  v.string(),\n  v.regex(/^\\d+px$/),\n  v.transform(parseInt),\n  v.number(),\n  v.maxValue(100)\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Variant Schema in TypeScript with Valibot\nDESCRIPTION: Shows how to implement a discriminated union using Valibot's variant function, which provides better performance and type safety than regular unions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/unions/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst VariantScheme = v.variant('type', [\n  v.object({\n    type: v.literal('foo'),\n    foo: v.string(),\n  }),\n  v.object({\n    type: v.literal('bar'),\n    bar: v.number(),\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating an Exact Optional Async Schema in Valibot\nDESCRIPTION: Basic syntax for creating an exact optional async schema with Valibot. This schema allows missing object entries but not undefined ones, and can provide default values when entries are missing.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/exactOptionalAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.exactOptionalAsync<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple with Rest Schema in Valibot\nDESCRIPTION: Creates a tuple schema that validates specific items in the beginning of the tuple, while applying a different schema to any additional items. This example validates a string followed by a number, with any additional items validated as null.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/arrays/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst TupleSchema = v.tupleWithRest([v.string(), v.number()], v.null());\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Default Values in Nullable Schemas with Valibot\nDESCRIPTION: Shows how to use a function to generate dynamic default values for nullable schemas in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/optionals/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst NullableDateSchema = v.nullable(v.date(), () => new Date());\n```\n\n----------------------------------------\n\nTITLE: VariantSchema Interface Properties\nDESCRIPTION: Core properties of the VariantSchema interface including type, reference, expects, key, options, and message fields that define the schema structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VariantSchema/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype\nreference\nexpects\nkey\noptions\nmessage\n```\n\n----------------------------------------\n\nTITLE: Using the MAC Validation Action in Valibot\nDESCRIPTION: Basic usage syntax for the 'mac' validation action that validates if a string is a properly formatted MAC address. It shows the function signature with generics for input type and custom error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/mac/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.mac<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining InferNullableOutput Type in TypeScript\nDESCRIPTION: This snippet shows the TypeScript definition of the InferNullableOutput type. It uses two generic parameters: TWrapped and TDefault, and infers the nullable output type based on these parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNullableOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nInferNullableOutput<TWrapped, TDefault>\n```\n\n----------------------------------------\n\nTITLE: Enforcing Maximum Date Value\nDESCRIPTION: Example schema that enforces a maximum date of December 31, 1999 using the pipe function with a date schema and toMaxValue transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMaxValue/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DateSchema = v.pipe(v.date(), v.toMaxValue(new Date('1999-12-31')));\n```\n\n----------------------------------------\n\nTITLE: Implementing Unsorted Array Validation - TypeScript\nDESCRIPTION: Example showing how to create a schema that validates an array is not sorted in ascending order using someItem and pipe methods.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/someItem/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UnsortedArraySchema = v.pipe(\n  v.array(v.number()),\n  v.someItem(\n    (item, index, array) => array.length === 1 || item < array[index - 1],\n    'The numbers must not be sorted in ascending order.'\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Undefinedable Schema Basic Usage in TypeScript\nDESCRIPTION: The basic syntax for creating an undefinedable schema in Valibot that allows both the wrapped type and undefined values, with an optional default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefinedable/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.undefinedable<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Creating Array Schema - Basic TypeScript Definition\nDESCRIPTION: Basic type definition showing how to create an array schema with arrayAsync function. The schema takes item type and optional error message as parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/arrayAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.arrayAsync<TItem, TMessage>(item, message);\n```\n\n----------------------------------------\n\nTITLE: Object Record Schema - TypeScript\nDESCRIPTION: Schema definition for validating a record where keys are strings and values are objects containing a string key property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectRecordSchema = v.record(v.string(), v.object({ key: v.string() }));\n```\n\n----------------------------------------\n\nTITLE: Creating a trimEnd Transformation Action in Valibot\nDESCRIPTION: Creates a basic trimEnd transformation action that can be used to remove whitespace from the end of strings in a validation pipeline.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/trimEnd/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst Action = v.trimEnd();\n```\n\n----------------------------------------\n\nTITLE: Component Import Definition\nDESCRIPTION: Import statements for the Property component and properties object used in the documentation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VoidIssue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Defining LengthAction Interface in TypeScript\nDESCRIPTION: Interface definition for LengthAction that includes validation type, reference, expectations, requirements and message handling. Used for length-based validation operations with generic type parameters for input, requirement and message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LengthAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface LengthAction<TInput, TRequirement, TMessage> {\n  type: 'length';\n  reference: TInput;\n  expects: string;\n  requirement: TRequirement;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Record Schema Type Definition in TypeScript\nDESCRIPTION: Type definition for RecordSchema interface with generics TKey, TValue, and TMessage. The schema includes properties for type, reference, expects, key, value and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RecordSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RecordSchema<TKey, TValue, TMessage> extends BaseSchema {\n  type: 'record';\n  reference: Record<TKey, TValue>;\n  expects: string;\n  key: Schema<TKey>;\n  value: Schema<TValue>;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using toMaxValue Function Signature\nDESCRIPTION: The basic signature for creating a toMaxValue transformation action, which enforces a maximum value for numbers, dates, or strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toMaxValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.toMaxValue<TInput, TRequirement>(requirement);\n```\n\n----------------------------------------\n\nTITLE: Creating a Values Validation Action in Valibot (TypeScript)\nDESCRIPTION: Demonstrates the basic syntax for creating a values validation action in Valibot. This action validates that the input matches one of the specified values in the requirement array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/values/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.values<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic looseObject Schema in TypeScript\nDESCRIPTION: Basic syntax for creating a loose object schema with type parameters and message customization.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/looseObject/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.looseObject<TEntries, TMessage>(entries, message);\n```\n\n----------------------------------------\n\nTITLE: New User Schema with Optional Fields\nDESCRIPTION: Complex example showing how to create a user schema with required and optional fields, including async email and username validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/optionalAsync/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailUnique, isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailUnique, 'The email is not unique.')\n  ),\n  username: v.optionalAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of undefinedableAsync Schema in Valibot\nDESCRIPTION: Shows the basic syntax for creating an undefinedable schema with optional default value. The schema will pass undefined inputs and can use a default value if specified.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/undefinedableAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.undefinedableAsync<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Enum Record Schema - TypeScript\nDESCRIPTION: Schema definition for validating a record using enum values as keys and optional numbers as values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nenum Products {\n  PRODUCT_A = 'product_a',\n  PRODUCT_B = 'product_b',\n  PRODUCT_C = 'product_c',\n}\n\nconst ProductRecordSchema = v.record(v.enum(Products), v.optional(v.number()));\n```\n\n----------------------------------------\n\nTITLE: Basic unionAsync Schema Declaration\nDESCRIPTION: Basic syntax for creating a unionAsync schema with options and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/unionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.unionAsync<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Implementing Convention 2: Suffixed Schema and Types in TypeScript\nDESCRIPTION: Demonstrates the second naming convention using separate suffixes for schema (Schema), input type (Input), and output type (Output). Creates an Image schema with various validation rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/naming-convention/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nexport const ImageSchema = v.object({\n  status: v.optional(v.picklist(['public', 'private']), 'private'),\n  created: v.optional(v.date(), () => new Date()),\n  title: v.pipe(v.string(), v.maxLength(100)),\n  source: v.pipe(v.string(), v.url()),\n  size: v.pipe(v.number(), v.minValue(0)),\n});\n\nexport type ImageInput = v.InferInput<typeof ImageSchema>;\nexport type ImageOutput = v.InferOutput<typeof ImageSchema>;\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Schema with Valibot in TypeScript\nDESCRIPTION: This snippet demonstrates the basic syntax for creating an enum schema using Valibot. It includes generic type parameters for the enum and error message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/enum/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.enum<TEnum, TMessage>(enum, message);\n```\n\n----------------------------------------\n\nTITLE: String Record Schema - TypeScript\nDESCRIPTION: Schema definition for validating a record where both keys and values must be strings, with a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringRecordSchema = v.record(\n  v.string(),\n  v.string(),\n  'An object is required.'\n);\n```\n\n----------------------------------------\n\nTITLE: Defining VariantOptions Type with Generic Parameter in TypeScript\nDESCRIPTION: Type definition for VariantOptions that uses a generic TKey parameter. This appears to be a utility type used for variant configurations or options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VariantOptions/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype VariantOptions<TKey> = {\n  /**\n   * The key of the variant.\n   */\n  key: TKey;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RegexAction Interface Type Structure\nDESCRIPTION: Interface structure showing the composition of a RegexAction type with generics TInput and TMessage, including properties for type, reference, expects, requirement, and message configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RegexAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RegexAction<TInput, TMessage> {\n  type: 'regex';\n  reference: RegExp;\n  expects: boolean;\n  requirement: RegExp;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Value Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a value validation action with generic types for input, requirement and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/value/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.value<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: FiniteAction Interface Type Definition\nDESCRIPTION: Interface definition for FiniteAction that includes type, reference, expects, requirement and message properties. Uses generics TInput for input type and TMessage for message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FiniteAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface FiniteAction<TInput, TMessage> {\n  type: string;\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Object Input Type with InferObjectInput in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the InferObjectInput type to infer the input type of an object schema in Valibot. It creates an object with a 'key' property that uses a pipe for validation and transformation, then infers the input type using InferObjectInput.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferObjectInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create object entries\nconst entries = {\n  key: v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n};\n\n// Infer entries input type\ntype EntriesInput = v.InferObjectInput<typeof entries>; // { key: string }\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Number Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic number schema using Valibot. It includes a generic type for custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/number/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.number<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Configuring Error Messages\nDESCRIPTION: Example showing how to configure a schema with a custom error message for email validation pipeline.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/config/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.object({\n  email: v.config(\n    v.pipe(v.string(), v.trim(), v.email(), v.endsWith('@example.com')),\n    { message: 'The email does not conform to the required format.' }\n  ),\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Undefined Schema in TypeScript\nDESCRIPTION: Creates a schema to validate undefined values with an optional custom error message. The schema supports type parameter TMessage for custom error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefined/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.undefined<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Using safeParserAsync Method in Valibot\nDESCRIPTION: The basic syntax for creating a safe parser function from an asynchronous schema. This returns a function that can validate input data against the schema and returns a result object with either the validated output or validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/safeParserAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst safeParser = v.safeParserAsync<TSchema, TConfig>(schema, config);\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Number Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic number schema using Valibot. It includes a generic type for custom error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/number/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.number<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Return Transformation Action with returnsAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the returnsAsync function to create a function return transformation action. It specifies the input type and schema type as generics.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/returnsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.returnsAsync<TInput, TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Record Schema - TypeScript\nDESCRIPTION: Basic syntax for creating a record schema with generic types for key, value and optional error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.record<TKey, TValue, TMessage>(key, value, message);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Record Schema - TypeScript\nDESCRIPTION: Basic syntax for creating a record schema with generic types for key, value and optional error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/record/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.record<TKey, TValue, TMessage>(key, value, message);\n```\n\n----------------------------------------\n\nTITLE: Object Schema Variants Implementation\nDESCRIPTION: Shows the different object schema variants available for handling unknown properties and rest parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/first-draft-of-the-new-pipe-function/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst NormalObjectSchema = v.object({ ... });\nconst ObjectWithRestSchema = v.objectWithRest({ ... }, v.string());\nconst LooseObjectSchema = v.looseObject({ ... });\nconst StrictObjectSchema = v.strictObject({ ... });\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface Definition for MultipleOfAction\nDESCRIPTION: Interface definition showing the structure of MultipleOfAction with its generic types and required properties for validation purposes.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MultipleOfAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MultipleOfAction<TInput, TRequirement, TMessage> {\n  type: 'multiple_of';\n  reference: number;\n  expects: TInput;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Raw Check Validation Action - TypeScript\nDESCRIPTION: Basic syntax for creating a raw check validation action using Valibot\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawCheck/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.rawCheck<TInput>(action);\n```\n\n----------------------------------------\n\nTITLE: Defining InferSetOutput Generic Type\nDESCRIPTION: TypeScript type definition for inferring the output type of a set validation schema. Takes a generic type parameter TValue representing the value type of the set.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferSetOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype InferSetOutput<TValue> = Set<TValue>\n```\n\n----------------------------------------\n\nTITLE: Using InferTupleOutput to infer transformed validation schema types in TypeScript\nDESCRIPTION: This example demonstrates how to use the InferTupleOutput utility type to infer the output types from a tuple of validation schemas where transformation is applied. The schema converts a string to its length as a number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferTupleOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst items = [\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n];\n\n// Infer items output type\ntype ItemsOutput = v.InferTupleOutput<typeof items>; // [number]\n```\n\n----------------------------------------\n\nTITLE: TypeScript BaseSchema Interface Definition\nDESCRIPTION: Defines the base schema interface with generics TInput, TOutput, and TIssue. Includes core properties like kind, type, reference, expects, async, and internal methods.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BaseSchema<TInput, TOutput, TIssue> {\n  kind: string;\n  type: string;\n  reference?: string;\n  expects?: string;\n  async: boolean;\n  ~standard: (input: TInput) => TOutput;\n  ~run: (input: TInput) => TIssue[];\n  ~types: {\n    input: TInput;\n    output: TOutput;\n    issue: TIssue;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping a Nullish Schema in Valibot\nDESCRIPTION: Shows how to use the 'unwrap' function to remove the nullish behavior from a schema, reverting it to its original non-nullish form.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nullish/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst NullishNumberSchema = v.nullish(v.number());\nconst NumberSchema = v.unwrap(NullishNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Creating a Void Schema in TypeScript with Valibot\nDESCRIPTION: This snippet demonstrates how to create a void schema using the void function from Valibot. It allows for optional customization of the error message when the input is not undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/void/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.void<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Keyof Schema - TypeScript Basic Usage\nDESCRIPTION: Basic syntax for creating a keyof schema with optional validation message. The method takes a schema and optional message parameter to create a picklist of object keys.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/keyof/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.keyof<TSchema, TMessage>(schema, message);\n```\n\n----------------------------------------\n\nTITLE: Restructuring Schema Pipeline with pipe() Method in TypeScript\nDESCRIPTION: Example of migrating from the old array-based pipeline approach to the new pipe() method in Valibot v0.31.0. This shows how to chain validation steps.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst Schema = v.string([v.email()]);\n\n// To this\nconst Schema = v.pipe(v.string(), v.email());\n```\n\n----------------------------------------\n\nTITLE: Defining an ISO Date Time Schema in TypeScript\nDESCRIPTION: This example shows how to create a schema that validates an ISO date time string. It uses the pipe method to combine a string validation with the isoDateTime validation, including a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoDateTime/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst IsoDateTimeSchema = v.pipe(\n  v.string(),\n  v.isoDateTime('The date is badly formatted.')\n);\n```\n\n----------------------------------------\n\nTITLE: Picking Specific Entries from Object Schema with Rest in TypeScript\nDESCRIPTION: Demonstrates how to create a new schema by picking specific entries from an existing object schema with rest, using the pick method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/objectWithRest/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst PickObjectSchema = v.pick(\n  v.objectWithRest(\n    {\n      key1: v.string(),\n      key2: v.number(),\n      key3: v.boolean(),\n    },\n    v.null()\n  ),\n  ['key1', 'key3']\n);\n```\n\n----------------------------------------\n\nTITLE: Defining IssuePathItem Type in TypeScript\nDESCRIPTION: Defines the IssuePathItem type, which can be either a string or a number. This type is likely used to represent individual segments in a validation error path.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IssuePathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nIssuePathItem\n```\n\n----------------------------------------\n\nTITLE: Defining BaseMetadata Interface in TypeScript\nDESCRIPTION: Defines the BaseMetadata interface with generics and properties. It includes 'kind', 'type', 'reference', and optional '~types' properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseMetadata/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nBaseMetadata<TInput> {\n  kind: string;\n  type: string;\n  reference: TInput;\n  ~types?: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata Action in TypeScript\nDESCRIPTION: Basic syntax for creating a custom metadata action with generic types for input and metadata.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/metadata/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.metadata<TInput, TMetadata>(metadata_);\n```\n\n----------------------------------------\n\nTITLE: Defining minEntries Action in TypeScript\nDESCRIPTION: Basic syntax for creating a minEntries validation action with generic types for input, requirement and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minEntries/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.minEntries<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Inferring Non-Nullable Type from Nullable Schema in TypeScript\nDESCRIPTION: Demonstrates creating a nullable string schema and using InferNonNullableInput to infer the non-nullable input type. The example shows how to combine pipe, string, and transform validations with nullable type inference.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNonNullableInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create nullable sting schema\nconst NullableStringSchema = v.nullable(\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  )\n);\n\n// Infer non nullable string input type\ntype NonNullableStringInput = v.InferNonNullableInput<\n  typeof NullableStringSchema\n>; // string\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple Schema with tupleAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of tupleAsync to create a tuple schema. It specifies the generic types for items and error messages, and takes items and an optional custom error message as parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/tupleAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.tupleAsync<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Unwrapping a Nullish Schema in Valibot\nDESCRIPTION: Example of using the unwrap function to remove the nullish behavior from a schema, restoring the original wrapped schema behavior.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nullishAsync/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUsernameUnique } from '~/api';\n\nconst UsernameSchema = v.unwrap(\n  // Assume this schema is from a different file and is reused here\n  v.nullishAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Schema with the 'pick' Method in Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating a modified schema that contains only selected entries from an object schema using Valibot's pick method.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/pick/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.pick<TSchema, TKeys>(schema, keys);\n```\n\n----------------------------------------\n\nTITLE: Creating a Date Schema in Valibot\nDESCRIPTION: Basic syntax for creating a date schema with an optional custom error message. This validates that an input is a JavaScript Date object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/date/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.date<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining GenericTransformation Type with TypeScript Generics\nDESCRIPTION: Type definition for a generic transformation that includes three type parameters: TInput for input type, TOutput for output type, and TIssue for handling validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericTransformation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericTransformation<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: Discriminated Union Schema Using Lazy with Input Access\nDESCRIPTION: Example of a lazy schema that validates a discriminated union based on examining the input. This approach uses the input parameter of the getter function to determine which schema to apply based on the type property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/lazy/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst LazyUnionSchema = v.lazy((input) => {\n  if (input && typeof input === 'object' && 'type' in input) {\n    switch (input.type) {\n      case 'email':\n        return v.object({\n          type: v.literal('email'),\n          email: v.pipe(v.string(), v.email()),\n        });\n      case 'url':\n        return v.object({\n          type: v.literal('url'),\n          url: v.pipe(v.string(), v.url()),\n        });\n      case 'date':\n        return v.object({\n          type: v.literal('date'),\n          date: v.pipe(v.string(), v.isoDate()),\n        });\n    }\n  }\n  return v.never();\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring NotValueAction Interface Structure\nDESCRIPTION: Interface definition for NotValueAction that includes generic type parameters TInput, TRequirement, and TMessage. The interface extends BaseValidation and includes properties for type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotValueAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NotValueAction<TInput, TRequirement, TMessage> extends BaseValidation {\n  type: 'not';\n  reference: TInput;\n  expects: boolean;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: NotLengthIssue Interface Definition with Generics\nDESCRIPTION: Interface extending BaseIssue to represent length validation issues with generic type parameters TInput and TRequirement. Includes properties for validation kind, type, expected and received values, and requirement details.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotLengthIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NotLengthIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'not_length';\n  type: string;\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating toLowerCase Action in TypeScript\nDESCRIPTION: Creates a transformation action that converts strings to lowercase. This is typically used as part of validation schema creation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toLowerCase/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.toLowerCase();\n```\n\n----------------------------------------\n\nTITLE: Creating NaN Schema in TypeScript\nDESCRIPTION: Creates a schema to validate if a value is NaN. Accepts an optional custom error message parameter and returns a Schema object that can validate NaN values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nan/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nan<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: TupleSchema Interface TypeScript Definition\nDESCRIPTION: Type definition showing the structure of the TupleSchema interface with its properties type, reference, expects, items, and message. Used for validating tuple data structures with fixed-length arrays of specific types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TupleSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TupleSchema<TItems, TMessage> {\n  type: 'tuple';\n  reference: string;\n  expects: string;\n  items: TItems;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using trimStart with a String Schema in Valibot\nDESCRIPTION: Example of trimming the start of a string by piping a string schema with the trimStart function. This creates a schema that validates strings and automatically removes leading whitespace.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/trimStart/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst StringSchema = v.pipe(v.string(), v.trimStart());\n```\n\n----------------------------------------\n\nTITLE: Creating Any Schema in Valibot\nDESCRIPTION: Creates an 'any' schema in Valibot. This schema accepts any type of value without validation. Note that using 'unknown' is recommended instead for accepting unknown data.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/any/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.any();\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimum Value Bigint Schema in Valibot\nDESCRIPTION: Demonstrates how to create a schema that enforces a minimum bigint value. This combines the bigint schema with the toMinValue action to enforce a lower boundary.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/bigint/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst MinBigintSchema = v.pipe(v.bigint(), v.toMinValue(10n));\n```\n\n----------------------------------------\n\nTITLE: Using getFallbacksAsync Function in TypeScript\nDESCRIPTION: Basic usage of the getFallbacksAsync function to retrieve fallback values from a schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/getFallbacksAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst values = v.getFallbacksAsync<TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Blob Schema in TypeScript\nDESCRIPTION: The basic syntax for creating a blob schema in Valibot. The schema validates that the input is a Blob object and can include a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/blob/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.blob<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Valibot Development Setup Commands\nDESCRIPTION: Bash commands for cloning, installing dependencies, and setting up the Valibot development environment.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/first-draft-of-the-new-pipe-function/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Clone repository\ngit clone git@github.com:fabian-hiller/valibot.git\n\n# Switch branch\ngit switch rewrite-with-pipe\n\n# Install dependencies\ncd ./valibot && pnpm install\n\n# Bundle library\ncd ./library && pnpm build\n\n# Modify `playground.ts`\n\n# Run playground\npnpm play\n```\n\n----------------------------------------\n\nTITLE: Creating a Bigint Schema in Valibot\nDESCRIPTION: Shows the basic syntax for creating a bigint schema in Valibot. This allows validation that input values are of bigint type, with an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/bigint/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.bigint<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: MaxValueIssue Interface Definition with Generics\nDESCRIPTION: TypeScript interface definition for MaxValueIssue that extends BaseIssue. It includes generic type parameters TInput and TRequirement, and defines properties for validation error handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxValueIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MaxValueIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_value';\n  type: string;\n  expected: number;\n  requirement: TRequirement;\n  input: TInput;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Picklist Schema Definition - TypeScript\nDESCRIPTION: Base syntax for creating a picklist schema with options and optional error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/picklist/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.picklist<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Creating Cuid2 Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a Cuid2 validation action with optional message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/cuid2/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.cuid2<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining UndefinedableSchema Interface in TypeScript\nDESCRIPTION: This snippet defines the UndefinedableSchema interface with its properties and generics. It extends BaseSchema and includes specific properties for handling undefined values and default values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UndefinedableSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UndefinedableSchema<TWrapped, TDefault> extends BaseSchema {\n  type: 'undefinedable';\n  reference: Reference;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: User Validation Schema Example\nDESCRIPTION: Example showing how to create a union schema that validates either an email or username with async database checks.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/unionAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent, isUsernamePresent } from '~/api';\n\nconst UserSchema = v.unionAsync([\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  ),\n  v.pipeAsync(\n    v.string(),\n    v.nonEmpty(),\n    v.checkAsync(isUsernamePresent, 'The username is not in the database.')\n  ),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Record Schema with recordAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of recordAsync to create a record schema. It includes type parameters for key, value, and error message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/recordAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.recordAsync<TKey, TValue, TMessage>(key, value, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Set Schema in TypeScript with Valibot\nDESCRIPTION: API signature for creating a set schema in Valibot. This function validates that the input is a Set and that its values conform to the specified schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/set/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.set<TValue, TMessage>(value, message);\n```\n\n----------------------------------------\n\nTITLE: Creating an Intersect Schema in Valibot\nDESCRIPTION: Basic syntax for creating an intersect schema in Valibot, specifying options and optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/intersect/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.intersect<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Creating a reduceItems Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a reduceItems transformation action in Valibot. It takes an operation function and an initial value as parameters, and applies the operation to each item in an array to reduce it to a single value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/reduceItems/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.reduceItems<TInput, TOutput>(operation, initial);\n```\n\n----------------------------------------\n\nTITLE: Defining SomeItemIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the SomeItemIssue interface, which extends BaseIssue. It includes properties for kind, type, expected, and requirement. The interface is generic, using TInput as a type parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SomeItemIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SomeItemIssue<TInput> extends BaseIssue {\n  kind: 'some_item';\n  type: 'type_issue';\n  expected: string;\n  requirement: TInput;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Null Schema in Typescript using Valibot\nDESCRIPTION: This snippet demonstrates how to create a null schema using Valibot. It allows for optional custom error messages and type inference.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/null/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.null<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: LtValueIssue Type Definition with Generics\nDESCRIPTION: Type definition for LtValueIssue that extends BaseIssue with properties for handling less than value comparison validation failures. Includes generic type parameters for input and requirement values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LtValueIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface LtValueIssue<TInput, TRequirement> extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: NullishSchema Interface Type Definition\nDESCRIPTION: The NullishSchema interface extends BaseSchema and includes properties for type definition, reference handling, expectations, wrapped schema, and default values. It uses two generic types TWrapped and TDefault for type flexibility.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NullishSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NullishSchema<TWrapped, TDefault> extends BaseSchema {\n  type: 'nullish';\n  reference: SchemaReference;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Shopping Items Schema with Async Validation\nDESCRIPTION: Example schema that validates a map where keys are verified usernames and values are non-negative numbers representing purchased items. It uses asynchronous validation to check if the username is verified.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/mapAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUserVerified } from '~/api';\n\nconst ShoppingItemsSchema = v.mapAsync(\n  v.pipeAsync(\n    v.string(),\n    v.checkAsync(isUserVerified, 'The username is not allowed to shop.')\n  ),\n  v.pipe(v.number(), v.minValue(0))\n);\n```\n\n----------------------------------------\n\nTITLE: Inferring Non-Nullable Output Type from Nullable Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a nullable string schema and then use InferNonNullableOutput to infer its non-nullable output type. The schema includes a transformation that returns the length of the string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNonNullableOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create nullable sting schema\nconst NullableStringSchema = v.nullable(\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  )\n);\n\n// Infer non nullable string output type\ntype NonNullableStringOutput = v.InferNonNullableOutput<\n  typeof NullableStringSchema\n>; // number\n```\n\n----------------------------------------\n\nTITLE: Creating Even Number Schema with MultipleOf\nDESCRIPTION: Example showing how to create a schema that validates if a number is even using pipe and multipleOf validators.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/multipleOf/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EvenNumberSchema = v.pipe(\n  v.number(),\n  v.multipleOf(2, 'The number must be even.')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Boolean Schema in Valibot\nDESCRIPTION: This snippet demonstrates the basic usage of the 'boolean' function to create a boolean schema. It shows the function signature with optional generic type and message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/boolean/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.boolean<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Initializing parserAsync Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize the parserAsync function with a schema and optional configuration. It returns a parser function that can be used to validate and parse input data.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/parserAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst parser = v.parserAsync<TSchema, TConfig>(schema, config);\n```\n\n----------------------------------------\n\nTITLE: Defining LooseObjectSchema Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the LooseObjectSchema interface. It extends BaseSchema and includes properties for type, reference, expects, entries, and message. The interface is generic, allowing for customization of entries and message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LooseObjectSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nLooseObjectSchema<TEntries, TMessage> extends BaseSchema {\n  type: 'object';\n  reference: 'loose';\n  expects: string;\n  entries: TEntries;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Definition - ULID Action Properties\nDESCRIPTION: Interface definition showing the required properties for ULID validation including type parameters TInput and TMessage, along with properties for type, reference, expects, requirement and message validation controls.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UlidAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UlidAction<TInput, TMessage> {\n  type: \"ulid\";\n  reference: string;\n  expects: string;\n  requirement: boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Unknown Schema in TypeScript with Valibot\nDESCRIPTION: Creates a basic unknown schema using Valibot's unknown() function. This schema should only be used when the data type is truly unknown and cannot be more specifically defined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/unknown/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.unknown();\n```\n\n----------------------------------------\n\nTITLE: Defining ObjectPathItem Interface in TypeScript\nDESCRIPTION: This snippet defines the structure of the ObjectPathItem interface. It includes properties for type, origin, input, key, and value. The interface is used to represent items in an object validation path.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ObjectPathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ObjectPathItem {\n  type: string;\n  origin: unknown;\n  input: unknown;\n  key: string;\n  value: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonNullableSchema Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the NonNullableSchema interface, including its generics and properties. It extends the BaseSchema interface and includes specific properties for non-nullable schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullableSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface NonNullableSchema<TWrapped, TMessage> extends BaseSchema {\n  type: 'non_nullable';\n  reference: unknown;\n  expects: string;\n  wrapped: TWrapped;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Parser with Schema in TypeScript\nDESCRIPTION: Basic syntax for creating a parser function from a schema with optional configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/parser/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst parser = v.parser<TSchema, TConfig>(schema, config);\n```\n\n----------------------------------------\n\nTITLE: Inferring Non-Optional Output Type from Optional Schema in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the InferNonOptionalOutput type to infer the non-optional output type from an optional schema. It creates an optional string schema with a transformation and then infers its non-optional output type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNonOptionalOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create optional sting schema\nconst OptionalStringSchema = v.optional(\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  )\n);\n\n// Infer non optional string output type\ntype NonOptionalStringOutput = v.InferNonOptionalOutput<\n  typeof OptionalStringSchema\n>; // number\n```\n\n----------------------------------------\n\nTITLE: Creating Trim Transformation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a trim transformation action using Valibot. The trim action is used to remove whitespace from the beginning and end of a string.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/trim/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.trim();\n```\n\n----------------------------------------\n\nTITLE: Creating Async Object Schema - TypeScript Basic Usage\nDESCRIPTION: Basic syntax for creating an async object schema with Valibot, showing the function signature with generic types for entries and custom messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/objectAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.objectAsync<TEntries, TMessage>(entries, message);\n```\n\n----------------------------------------\n\nTITLE: Database Schema with Metadata\nDESCRIPTION: Demonstrates proposed pipe function usage with database metadata features.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst UserSchema = pipe(\n  object({\n    id: pipe(string(), uuid(), primaryKey()),\n    name: pipe(string(), maxLength(32), unique()),\n    bio: pipe(string(), description('Text ...')),\n  }),\n  table('users')\n);\n```\n\n----------------------------------------\n\nTITLE: ToMaxValueAction Interface Structure\nDESCRIPTION: Interface definition showing the structure of ToMaxValueAction with its type properties, reference and requirement fields. Uses generics TInput and TRequirement for type flexibility.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ToMinValueAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ToMaxValueAction<TInput, TRequirement> {\n  type: 'to_max_value';\n  reference: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Safe Parser Function\nDESCRIPTION: Basic syntax for creating a safe parser function using a schema and optional config.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/safeParser/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst safeParser = v.safeParser<TSchema, TConfig>(schema, config);\n```\n\n----------------------------------------\n\nTITLE: IntersectSchema Interface Type Definition\nDESCRIPTION: Interface definition for the IntersectSchema type showing its generic parameters (TOptions, TMessage) and core properties including type, reference, options, and message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntersectSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IntersectSchema<TOptions = unknown, TMessage = unknown> {\n  type: 'intersect';\n  reference: unknown;\n  options?: TOptions;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: BigintSchema Interface Definition with Generics\nDESCRIPTION: TypeScript interface definition for BigintSchema showing its generics parameter TMessage and core schema properties including type, reference, expects and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BigintSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BigintSchema<TMessage> {\n  type: 'bigint';\n  reference: 'BigintSchema';\n  expects: 'bigint';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of intersectAsync in Valibot\nDESCRIPTION: Basic syntax for creating an intersect schema using the intersectAsync function. This schema validates that the input matches each of the provided options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/intersectAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.intersectAsync<TOptions, TMessage>(options, message);\n```\n\n----------------------------------------\n\nTITLE: Defining TransformActionAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the TransformActionAsync interface with generics for input and output types. It extends BaseTransformationAsync and includes properties for type, reference, and operation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TransformActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface TransformActionAsync<TInput, TOutput> extends BaseTransformationAsync {\n  type: 'transform';\n  reference: string;\n  operation: (input: TInput) => Promise<TOutput>;\n}\n```\n\n----------------------------------------\n\nTITLE: Email, URL and Date Variant Schema Implementation\nDESCRIPTION: Example of creating a variant schema that validates different types of data including email, URL, and date formats.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/variant/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst VariantSchema = v.variant('type', [\n  v.object({\n    type: v.literal('email'),\n    email: v.pipe(v.string(), v.email()),\n  }),\n  v.object({\n    type: v.literal('url'),\n    url: v.pipe(v.string(), v.url()),\n  }),\n  v.object({\n    type: v.literal('date'),\n    date: v.pipe(v.string(), v.isoDate()),\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Trim Start Action in Valibot\nDESCRIPTION: Creates a trim start transformation action that can be used to remove whitespace from the beginning of strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/trimStart/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.trimStart();\n```\n\n----------------------------------------\n\nTITLE: Creating ISO Time Second Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating an ISO time second validation action with Valibot. This function validates strings with the ISO time format 'hh:mm:ss'.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoTimeSecond/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.isoTimeSecond<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Schema with an Undefinedable Property in TypeScript\nDESCRIPTION: Example showing how to create an object schema in Valibot with a property that can be either a string or undefined.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/undefinedable/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst UndefinedableEntrySchema = v.object({\n  key: v.undefinedable(v.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining EnumIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the structure of the EnumIssue interface. It extends BaseIssue and includes additional properties specific to enum validation issues such as kind, type, and expected values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EnumIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nEnumIssue {\n  kind: 'enum'\n  type: 'enum'\n  expected: unknown[]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Function Arguments Transformation Action with argsAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the argsAsync function to create a function arguments transformation action. It specifies the input type and schema as generic parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/argsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.argsAsync<TInput, TSchema>(schema);\n```\n\n----------------------------------------\n\nTITLE: Defining BigintIssue Interface Properties\nDESCRIPTION: Lists the key properties of the BigintIssue interface including the base issue properties, kind identifier, type information, and expected value specification.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BigintIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `BigintIssue` extends BaseIssue\n  - `kind` - Identifies the kind of validation issue\n  - `type` - Specifies the type information\n  - `expected` - Indicates the expected value or condition\n```\n\n----------------------------------------\n\nTITLE: TypeScript UnionOptions Interface Definition\nDESCRIPTION: Type definition for UnionOptions interface that provides configuration options for union type validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnionOptions/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype UnionOptions<TInput = any> = {\n  /**\n   * Custom error message.\n   */\n  message?: ErrorMessage;\n\n  /** \n   * Pipeline function for special transformations.\n   */\n  pipe?: Pipe<TInput>;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Unique Username Schema with Fallback\nDESCRIPTION: Example schema that validates usernames with a minimum length of 4 characters and checks uniqueness. If validation fails, it will return a unique username generated by getAnyUniqueUsername function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/fallbackAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAnyUniqueUsername, isUsernameUnique } from '~/api';\n\nconst UniqueUsernameSchema = v.fallbackAsync(\n  v.pipeAsync(v.string(), v.minLength(4), v.checkAsync(isUsernameUnique)),\n  getAnyUniqueUsername\n);\n```\n\n----------------------------------------\n\nTITLE: Defining MapItemsAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the MapItemsAction interface. It extends BaseTransformation and includes type, reference, and operation properties. The interface is generic, allowing for flexible input and output types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MapItemsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MapItemsAction<TInput, TOutput> extends BaseTransformation {\n  type: 'map_items';\n  reference: string;\n  operation: (item: TInput) => TOutput;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Partial Check Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates the basic syntax for creating a partial check validation action using the partialCheck function from Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/partialCheck/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.partialCheck<TInput, TPaths, TSelection, TMessage>(\n  paths,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Words Validation Action in Valibot TypeScript\nDESCRIPTION: Basic usage syntax of the words validation action, which checks the number of words in a string based on specified locales. It accepts locales, requirement, and custom error message parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/words/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.words<TInput, TLocales, TRequirement, TMessage>(\n  locales,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Optional String Schema in TypeScript\nDESCRIPTION: Shows how to create an optional string schema that accepts both string and undefined values, with a default value provided.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/optional/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OptionalStringSchema = v.optional(v.string(), \"I'm the default!\");\n```\n\n----------------------------------------\n\nTITLE: MapIssue Interface Properties Definition\nDESCRIPTION: Defines the structure of the MapIssue interface, which extends BaseIssue and includes properties for kind, type, and expected values during map validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MapIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MapIssue extends BaseIssue {\n  kind: 'map'\n  type: string\n  expected: string\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Strict Tuple Schema with strictTupleAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of strictTupleAsync to create a strict tuple schema. It shows the function signature with generics and parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/strictTupleAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.strictTupleAsync<TItems, TMessage>(items, message);\n```\n\n----------------------------------------\n\nTITLE: Base64Issue Interface Definition in TypeScript\nDESCRIPTION: Defines an interface for Base64 validation issues with required properties including kind, type, expected and received values, and validation requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Base64Issue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Base64Issue<TInput> {\n  kind: string;\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MetadataAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the MetadataAction interface with generics for input and metadata types. It includes properties for type, reference, and metadata.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MetadataAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMetadataAction<TInput, TMetadata> {\n  type: 'metadata';\n  reference: BaseSchema<TInput>;\n  metadata_: TMetadata;\n}\n```\n\n----------------------------------------\n\nTITLE: Using fallbackAsync Method in Valibot\nDESCRIPTION: Basic syntax for creating a schema with fallback value using the fallbackAsync method. This ensures that when validation fails, the specified fallback value is returned instead of validation errors.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/fallbackAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.fallbackAsync<TSchema, TFallback>(schema, fallback);\n```\n\n----------------------------------------\n\nTITLE: Defining HashAction Interface Structure\nDESCRIPTION: Interface definition showing the structure of HashAction with its generics TInput and TMessage, along with properties for type, reference, expects, requirement and message fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/HashAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface HashAction<TInput, TMessage> {\n  type: string;\n  reference: string;\n  expects: unknown;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping a Non-Nullish Schema in TypeScript\nDESCRIPTION: Demonstrates how to use the unwrap function to reverse the effect of nonNullish, creating a nullish schema from a non-nullish one.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/nonNullish/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst NonNullishNumberSchema = v.nonNullish(v.nullish(v.number()));\nconst NullishNumberSchema = v.unwrap(NonNullishNumberSchema);\n```\n\n----------------------------------------\n\nTITLE: Creating Emoji Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an emoji validation action using Valibot. It specifies the function signature with generic types for input and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/emoji/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.emoji<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Includes Validation Action in TypeScript\nDESCRIPTION: This snippet shows the basic function signature for creating an 'includes' validation action in Valibot. It specifies the generic types and parameters required.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/includes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.includes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Set Schema - TypeScript\nDESCRIPTION: Basic syntax for creating an async set schema with Valibot. The schema validates the data type and content of a Set against provided validation rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/setAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.setAsync<TValue, TMessage>(value, message);\n```\n\n----------------------------------------\n\nTITLE: UndefinedIssue Interface Structure\nDESCRIPTION: Interface definition showing the structure of an UndefinedIssue, which extends BaseIssue and includes properties for kind, type, and expected values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UndefinedIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UndefinedIssue extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Async Schema in Valibot\nDESCRIPTION: Demonstrates the basic usage of the customAsync function to create a custom schema with asynchronous validation. It shows the function signature with generics for input type and message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/customAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.customAsync<TInput, TMessage>(check, message);\n```\n\n----------------------------------------\n\nTITLE: Using isValiError Type Guard in TypeScript\nDESCRIPTION: Demonstrates how to use the isValiError function to check if an error is a ValiError. It takes a generic type parameter TSchema and an error object as input, returning a boolean result.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/isValiError/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = v.isValiError<TSchema>(error);\n```\n\n----------------------------------------\n\nTITLE: MinLengthAction Interface Definition\nDESCRIPTION: TypeScript interface for minimum length validation with generic types TInput, TRequirement, and TMessage. The interface extends BaseValidation and includes properties for type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinLengthAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MinLengthAction<TInput, TRequirement, TMessage> extends BaseValidation {\n  type: 'min_length';\n  reference: number;\n  expects: string;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of entriesFromObjects in Valibot\nDESCRIPTION: Demonstrates how to create object entries using the entriesFromObjects utility function. This creates a new entries definition by combining multiple object schemas, with later schemas overwriting properties from earlier ones.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/entriesFromObjects/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst entries = v.entriesFromObjects<TSchemas>(schemas);\n```\n\n----------------------------------------\n\nTITLE: Defining Base64Action Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the Base64Action interface. It includes generics for input and message types, and defines properties such as type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Base64Action/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nBase64Action<TInput, TMessage> {\n  type: 'base64';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UlidIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the UlidIssue interface, which extends BaseIssue. It includes properties specific to ULID validation issues such as kind, type, expected, received, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UlidIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nUlidIssue<TInput> extends BaseIssue {\n  kind: 'ulid';\n  type: 'type';\n  expected: 'ulid';\n  received: TInput;\n  requirement?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Using entriesFromList to Create Object Entries Definition in TypeScript\nDESCRIPTION: Basic syntax for creating object entries definitions using the entriesFromList function. This function takes a list of keys and a schema as parameters, returning entries that can be used in object schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/entriesFromList/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst entries = v.entriesFromList<TList, TSchema>(list, schema);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Error Message - TypeScript\nDESCRIPTION: Demonstrates how to retrieve a global error message using the getGlobalMessage function. The function accepts a language parameter and returns the corresponding error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/getGlobalMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst message = v.getGlobalMessage(lang);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Error Message - TypeScript\nDESCRIPTION: Demonstrates how to retrieve a global error message using the getGlobalMessage function. The function accepts a language parameter and returns the corresponding error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/getGlobalMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst message = v.getGlobalMessage(lang);\n```\n\n----------------------------------------\n\nTITLE: NonNullishIssue Interface Structure\nDESCRIPTION: Interface definition showing the structure of NonNullishIssue which extends BaseIssue. It includes properties for validation kind, type, and expected values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullishIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NonNullishIssue extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of checkItemsAsync in Valibot\nDESCRIPTION: Shows the basic syntax for creating a checkItemsAsync validation action, which allows you to validate array items asynchronously.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/checkItemsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.checkItemsAsync<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: TypeScript ExactOptionalSchema Interface Definition\nDESCRIPTION: Interface definition for ExactOptionalSchema that extends BaseSchema with properties for handling exact optional values. Includes type information, reference handling, expectations, wrapped value type, and default value specification.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ExactOptionalSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ExactOptionalSchema<TWrapped, TDefault> extends BaseSchema {\n  type: 'exact_optional';\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MaxLengthAction Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the MaxLengthAction interface, including its generics and properties. It is used to define the shape of max length validation actions in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxLengthAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface MaxLengthAction<TInput, TRequirement, TMessage> {\n  type: 'max_length';\n  reference: number;\n  expects: 'array' | 'string';\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Unique emails schema implementation using awaitAsync\nDESCRIPTION: Example schema that checks a set of emails wrapped in a promise object. It uses pipeAsync to compose multiple validators, first ensuring the input is a promise, then awaiting it, and finally validating that the result is a set of valid email strings.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/awaitAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst UniqueEmailsSchema = v.pipeAsync(\n  v.promise(),\n  v.awaitAsync(),\n  v.set(v.pipe(v.string(), v.email()))\n);\n```\n\n----------------------------------------\n\nTITLE: Defining TrimAction Interface Properties\nDESCRIPTION: Interface definition showing the structure of TrimAction which extends BaseTransformation. Contains properties for type and reference used in string trimming operations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TrimAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TrimAction extends BaseTransformation {\n  type: \"trim\";\n  reference: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Specific Keys Example\nDESCRIPTION: Example showing how to create a modified schema by omitting specific keys from an object schema. The resulting schema only contains the key2 property of type number.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/omit/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst OmittedSchema = v.omit(\n  v.object({\n    key1: v.string(),\n    key2: v.number(),\n    key3: v.boolean(),\n  }),\n  ['key1', 'key3']\n); // { key2: number }\n```\n\n----------------------------------------\n\nTITLE: Defining UuidIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the UuidIssue interface, which extends BaseIssue. It includes properties for the kind of issue, type, expected and received values, and any specific requirements for UUID validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UuidIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nUuidIssue<TInput> extends BaseIssue {\n  kind: 'uuid';\n  type: 'uuid';\n  expected: 'uuid';\n  received: TInput;\n  requirement?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ltValue Action in TypeScript\nDESCRIPTION: Basic syntax for creating a less than value validation action with type parameters for input, requirement, and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ltValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.ltValue<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Getting Default Values from Tuple Schema\nDESCRIPTION: Example demonstrating how to retrieve default values from a tuple schema containing a nullable number with a default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/getDefaults/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst TupleSchema = v.tuple([v.nullable(v.number(), 100)]);\nconst defaultValues = v.getDefaults(TupleSchema); // [100]\n```\n\n----------------------------------------\n\nTITLE: Defining NotSizeAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the NotSizeAction interface with its generics and properties. It extends BaseValidation and includes specific properties for not size validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotSizeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface NotSizeAction<TInput, TRequirement, TMessage> extends BaseValidation {\n  type: 'not_size';\n  reference: TInput;\n  expects: 'not_equal';\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Using nonNullableAsync Schema Function in TypeScript\nDESCRIPTION: Basic usage syntax for creating a non-nullable schema using the nonNullableAsync function from Valibot. The schema will fail validation for null inputs.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonNullableAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonNullableAsync<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Defining ValueIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the ValueIssue interface, which extends BaseIssue. It includes properties for the kind of issue, the type of value, the expected value, and the requirement that wasn't met.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ValueIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nValueIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'value';\n  type: string;\n  expected: string;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: GraphemesAction Interface Definition with Generics\nDESCRIPTION: TypeScript interface definition for GraphemesAction that includes generic type parameters TInput, TRequirement, and TMessage, along with core validation properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GraphemesAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GraphemesAction<TInput, TRequirement, TMessage> {\n  type: 'graphemes';\n  reference: TInput;\n  expects: string;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Product Function Schema with returnsAsync in TypeScript\nDESCRIPTION: This example shows how to use returnsAsync in combination with other Valibot functions to create a schema for a function that returns a product by its ID. It includes input validation and output schema definition.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/returnsAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isValidProductId } from '~/api';\n\nconst ProductFunctionSchema = v.pipeAsync(\n  v.function(),\n  v.argsAsync(\n    v.tupleAsync([v.pipeAsync(v.string(), v.checkAsync(isValidProductId))])\n  ),\n  v.returnsAsync(\n    v.pipeAsync(\n      v.promise(),\n      v.awaitAsync(),\n      v.object({\n        id: v.string(),\n        name: v.string(),\n        price: v.number(),\n      })\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining MinGraphemesAction Interface in TypeScript\nDESCRIPTION: Type interface for minimum graphemes validation action that includes input type, requirement configuration, and validation message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinGraphemesAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MinGraphemesAction<TInput, TRequirement, TMessage> {\n  type: 'min_graphemes';\n  reference: TInput;\n  expects: 'string';\n  requirement: TRequirement;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition of UndefinedableSchemaAsync Interface\nDESCRIPTION: Interface definition showing the structure of UndefinedableSchemaAsync with its generics and properties. Extends BaseSchemaAsync and includes type, reference, expects, wrapped, and default properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UndefinedableSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UndefinedableSchemaAsync<TWrapped, TDefault> extends BaseSchemaAsync {\n  type: 'undefinedable';\n  reference: Input<TWrapped> | undefined;\n  expects: string;\n  wrapped: TWrapped;\n  default?: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Async Schema - Basic Usage\nDESCRIPTION: Basic syntax for creating an optional async schema with wrapped schema and default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/optionalAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.optionalAsync<TWrapped, TDefault>(wrapped, default_);\n```\n\n----------------------------------------\n\nTITLE: Creating Instance Schemas in Valibot\nDESCRIPTION: Shows how to use the instance schema function to validate instances of specific classes, such as Error and URL.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/other/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ErrorSchema = v.instance(Error); // Error\nconst UrlSchema = v.instance(URL); // URL\n```\n\n----------------------------------------\n\nTITLE: Defining MacIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the MacIssue interface, which extends BaseIssue. It specifies the structure for MAC-related validation issues, including properties like kind, type, expected, received, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MacIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nMacIssue<TInput> extends BaseIssue {\n  kind: 'mac';\n  type: 'invalid_type';\n  expected: 'mac';\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: NonOptionalSchemaAsync Interface Structure\nDESCRIPTION: The interface definition showing the type structure for non-optional async schema validation, including generics TWrapped and TMessage. It extends BaseSchemaAsync and includes properties for type, reference, expects, wrapped value, and error message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonOptionalSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NonOptionalSchemaAsync<TWrapped, TMessage> extends BaseSchemaAsync {\n  type: string;\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonNullableIssue Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the NonNullableIssue interface. It extends BaseIssue and includes additional properties specific to non-nullable validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullableIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nNonNullableIssue {\n  kind: BaseIssue['kind'];\n  type: string;\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultValue Type in TypeScript\nDESCRIPTION: Defines the DefaultValue type with a generic parameter TDefault. The type is defined as TDefault | (() => TDefault), allowing for either a static value or a function that returns the default value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DefaultValue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefaultValue<TDefault> = TDefault | (() => TDefault);\n```\n\n----------------------------------------\n\nTITLE: Defining BooleanSchema Interface Structure\nDESCRIPTION: Interface definition showing the core properties of BooleanSchema including type, reference, expects, and message fields. Extends the BaseSchema with TMessage generic type parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BooleanSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BooleanSchema<TMessage> extends BaseSchema {\n  type: 'boolean';\n  reference: boolean;\n  expects: 'boolean';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CreditCardAction Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the CreditCardAction interface. It extends BaseValidation and includes properties for type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/CreditCardAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nCreditCardAction<TInput, TMessage> extends BaseValidation {\n  type: 'credit_card';\n  reference?: string;\n  expects?: string;\n  requirement?: string;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Direction Enum with Valibot in TypeScript\nDESCRIPTION: This example shows how to create and use an enum schema for validating a Direction enum. It defines the enum and creates a schema with a custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/enum/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction {\n  Left,\n  Right,\n}\n\nconst DirectionSchema = v.enum(Direction, 'Invalid direction');\n```\n\n----------------------------------------\n\nTITLE: Defining ObjectSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the ObjectSchemaAsync interface, including its generics and properties. It extends the BaseSchemaAsync interface and includes specific properties for object schema validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ObjectSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nObjectSchemaAsync<TEntries, TMessage> extends BaseSchemaAsync {\n  type: 'object';\n  reference: TEntries;\n  expects: string;\n  entries: TEntries;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating maxSize Validation Action in TypeScript\nDESCRIPTION: Demonstrates how to create a maxSize validation action in Valibot. This action is used to validate the maximum size of maps, sets, or blobs.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxSize/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxSize<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating toUpperCase Action in Valibot (TypeScript)\nDESCRIPTION: Demonstrates how to create a toUpperCase transformation action in Valibot. This action can be used to convert strings to uppercase.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/toUpperCase/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.toUpperCase();\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayRequirementAsync Type in TypeScript\nDESCRIPTION: Type definition for ArrayRequirementAsync which represents an asynchronous validation requirement for arrays. It accepts a generic type parameter TInput that specifies the input type being validated.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArrayRequirementAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nArrayRequirementAsync<TInput>\n```\n\n----------------------------------------\n\nTITLE: Defining StandardResult Interface in TypeScript for Valibot\nDESCRIPTION: This code snippet defines the StandardResult interface used in Valibot's validate function. It includes a generic type parameter TOutput and specifies the structure of the validation result.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StandardResult/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface StandardResult<TOutput> {\n  output: TOutput;\n  issues: Issue[] | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Brand Transformation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a brand transformation action using the 'brand' function from Valibot. It shows the basic syntax and generic types used.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/brand/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.brand<TInput, TName>(name);\n```\n\n----------------------------------------\n\nTITLE: Defining ImeiAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the ImeiAction interface, which extends BaseValidation. It includes properties for type, reference, expects, requirement, and message, used for IMEI validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ImeiAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nImeiAction<TInput, TMessage> extends BaseValidation {\n  type: 'imei';\n  reference: string;\n  expects: boolean;\n  requirement: string;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Validation Errors in TypeScript\nDESCRIPTION: Demonstrates how to use Valibot's flatten function to convert an array of issues into a flat object for easier error handling and display.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/issues/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst ObjectSchema = v.object({\n  foo: v.string('Value of \"foo\" is missing.'),\n  bar: v.object({\n    baz: v.string('Value of \"bar.baz\" is missing.'),\n  }),\n});\n\nconst result = v.safeParse(ObjectSchema, { bar: {} });\n\nif (result.issues) {\n  console.log(v.flatten<typeof ObjectSchema>(result.issues));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WordsAction Interface in TypeScript\nDESCRIPTION: This snippet defines the WordsAction interface with its generics and properties. It extends the BaseValidation interface and includes specific properties for word-based validation actions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/WordsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface WordsAction<TInput, TLocales, TRequirement, TMessage> extends BaseValidation {\n  type: 'words';\n  reference: string;\n  expects: 'less' | 'most';\n  locales?: TLocales;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing React Components in JSX\nDESCRIPTION: Imports various React components including Link from Qwik City and image components for use in the blog post.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/how-valibot-has-evolved-this-year/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link } from '@builder.io/qwik-city';\nimport MonthlyDownloads from './monthly-downloads.jpg?jsx';\nimport PlaygroundDark from './playground-dark.jpg?jsx';\nimport PlaygroundLight from './playground-light.jpg?jsx';\n```\n\n----------------------------------------\n\nTITLE: Defining maxLength Validation Action in TypeScript\nDESCRIPTION: Shows the TypeScript signature for creating a maxLength validation action, which validates that strings or arrays don't exceed a specified length.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxLength/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxLength<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Defining IntersectSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the IntersectSchemaAsync interface, which extends BaseSchemaAsync. It includes properties for type, reference, options, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntersectSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nIntersectSchemaAsync<TOptions, TMessage> extends BaseSchemaAsync {\n  type: 'intersect';\n  reference: unknown;\n  options: TOptions;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CheckItemsAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the CheckItemsAction interface with its properties and generics. It includes type, reference, expects, requirement, and message properties, along with TInput and TMessage generic types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/CheckItemsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CheckItemsAction<TInput, TMessage> {\n  type: 'check_items';\n  reference: string;\n  expects: string;\n  requirement: (item: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Ipv6Issue Interface in TypeScript\nDESCRIPTION: This snippet defines the Ipv6Issue interface, extending BaseIssue with IPv6-specific properties. It includes a generic type parameter TInput and specifies properties like kind, type, expected, received, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Ipv6Issue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Ipv6Issue<TInput> extends BaseIssue {\n  kind: 'ipv6';\n  type: 'Input';\n  expected: 'IPv6';\n  received: TInput;\n  requirement?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: MinBytesAction Interface Type Definition\nDESCRIPTION: Interface definition for MinBytesAction that includes generics for input type, requirement specification, and custom messages. The interface extends BaseValidation and includes properties for type, reference, expects, requirement and message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinBytesAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MinBytesAction<TInput, TRequirement, TMessage> extends BaseValidation {\n  type: 'min_bytes';\n  reference: number;\n  expects: 'bytes';\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing notWords Action in TypeScript\nDESCRIPTION: Creates a not words validation action. It validates the words of a string based on specified locales and requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notWords/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.notWords<TInput, TLocales, TRequirement, TMessage>(\n  locales,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Generic Type Definition for PipeAction in TypeScript\nDESCRIPTION: Generic type definition for pipe actions in Valibot. Takes three type parameters: TInput (input type), TOutput (output type), and TIssue (issue type). Used to define transformation and validation pipe actions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericPipeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericPipeAction<TInput, TOutput, TIssue> = (input: TInput, issues: TIssue[]) => TOutput | undefined;\n```\n\n----------------------------------------\n\nTITLE: Creating maxWords Validation Action in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a maxWords validation action in Valibot. It specifies the generic types and parameters for the action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxWords/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxWords<TInput, TLocales, TRequirement, TMessage>(\n  locales,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Defining LengthInput Type in TypeScript\nDESCRIPTION: Defines the LengthInput type, which represents a length input. It is likely used for validation or processing of length-related data in the valibot library.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LengthInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nLengthInput\n```\n\n----------------------------------------\n\nTITLE: Defining LazySchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the LazySchemaAsync interface, which extends BaseSchemaAsync. It includes properties for type, reference, expects, and getter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LazySchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nLazySchemaAsync<TWrapped> extends BaseSchemaAsync {\n  type: 'lazy';\n  reference: () => Promise<TWrapped>;\n  expects: string;\n  getter: () => Promise<TWrapped>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LazySchema Interface in TypeScript\nDESCRIPTION: This code snippet defines the LazySchema interface with its properties and generics. It extends the BaseSchema and includes specific properties for lazy schema implementation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LazySchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nLazySchema<TWrapped> extends BaseSchema {\n  type: 'lazy';\n  reference: () => TWrapped;\n  expects: string;\n  getter: () => TWrapped;\n}\n```\n\n----------------------------------------\n\nTITLE: RawTransformAction Interface Structure\nDESCRIPTION: Interface definition showing the structure of RawTransformAction with generic types TInput and TOutput, including type and reference properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RawTransformAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RawTransformAction<TInput, TOutput> {\n  type: 'raw';\n  reference: (input: TInput) => TOutput;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Variant Schema with variantAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of variantAsync to create a variant schema. It shows the function signature with generics for key, options, and message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/variantAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.variantAsync<TKey, TOptions, TMessage>(key, options, message);\n```\n\n----------------------------------------\n\nTITLE: Basic Transform Action Usage - TypeScript\nDESCRIPTION: Basic syntax for creating a transform action in Valibot. Shows the generic type signature and basic implementation pattern.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/transform/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.transform<TInput, TOutput>(action);\n```\n\n----------------------------------------\n\nTITLE: Creating Title Metadata Action in Valibot\nDESCRIPTION: This snippet demonstrates the basic usage of the 'title' function in Valibot. It creates a title metadata action for a schema, which can be useful for documentation or when working with AI tools.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/title/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.title<TInput, TTitle>(title_);\n```\n\n----------------------------------------\n\nTITLE: Defining IPv4 Action Interface in TypeScript\nDESCRIPTION: Interface definition for IPv4 validation actions that includes type, reference, expectations, requirements and error message handling. The interface uses generics TInput and TMessage for flexible input and message typing.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Ipv4Action/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Ipv4Action<TInput, TMessage> {\n  type: 'ipv4';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: InstanceSchema Interface Definitions\nDESCRIPTION: Defines the InstanceSchema interface with its generic types and required properties including type, reference, class and message fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InstanceSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface InstanceSchema<TClass, TMessage> extends BaseSchema {\n  type: \"instance\";\n  reference: string;\n  class: TClass;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IncludesIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the IncludesIssue interface, which extends BaseIssue. It includes properties for kind, type, expected, and requirement. The interface is generic, with TInput and TRequirement type parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IncludesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface IncludesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'includes';\n  type: 'array';\n  expected: 'includes';\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring GenericPipeItem Generic Type\nDESCRIPTION: Defines a generic pipe item type that takes three type parameters: TInput for the input value type, TOutput for the transformed output type, and TIssue for any validation issues that may occur.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericPipeItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericPipeItem<TInput, TOutput = TInput, TIssue = unknown> = {\n  input: TInput;\n  output: TOutput;\n  issues?: TIssue[];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ArgsAction Interface in TypeScript\nDESCRIPTION: This snippet defines the ArgsAction interface with its generics and properties. It includes type, reference, and schema properties, extending from BaseTransformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArgsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nArgsAction<TInput, TSchema> extends BaseTransformation {\n  type: 'args';\n  reference: string;\n  schema: TSchema;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Raw Transform Usage - TypeScript\nDESCRIPTION: Basic syntax for creating a raw transform action with generic type parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawTransform/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.rawTransform<TInput, TOutput>(action);\n```\n\n----------------------------------------\n\nTITLE: Creating IP Address Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an IP address validation action using Valibot. It shows the basic syntax and generic types used.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ip/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.ip<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining FunctionIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the FunctionIssue interface, which extends BaseIssue. It includes properties for the kind of issue, the type of function, and the expected result.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FunctionIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface FunctionIssue extends BaseIssue {\n  kind: 'function';\n  type: string;\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Structure - DigitsAction Type Definition\nDESCRIPTION: TypeScript interface definition showing the structure of DigitsAction with its generic parameters and required properties for digit validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DigitsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DigitsAction<TInput, TMessage> {\n  type: 'digits';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ImeiIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the ImeiIssue interface, which extends BaseIssue. It includes properties specific to IMEI validation errors, such as the kind of error, expected and received values, and the validation requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ImeiIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface ImeiIssue<TInput> extends BaseIssue {\n  kind: 'imei';\n  type: 'invalid_type' | 'invalid_length' | 'invalid_digit' | 'invalid_format';\n  expected: 'imei';\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NormalizeAction Interface in TypeScript\nDESCRIPTION: This snippet defines the NormalizeAction interface, which extends BaseTransformation. It includes properties for type, reference, and form, and uses a generic type TForm.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NormalizeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface NormalizeAction<TForm> extends BaseTransformation {\n  type: 'normalize';\n  reference: string;\n  form: TForm;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Language Configuration in Valibot\nDESCRIPTION: Demonstrates how to set the language configuration either globally using setGlobalConfig or locally when parsing data with parse or safeParse functions.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/internationalization/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// Set the language configuration globally\nv.setGlobalConfig({ lang: 'de' });\n\n// Set the language configuration locally\nv.parse(Schema, input, { lang: 'de' });\n```\n\n----------------------------------------\n\nTITLE: Creating Normalize Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a normalize transformation action using Valibot. It uses a generic type TForm for the form structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/normalize/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.normalize<TForm>(form);\n```\n\n----------------------------------------\n\nTITLE: Initializing SortItems Action in TypeScript\nDESCRIPTION: Creates a sort items transformation action that takes a generic type TInput and a comparison operation function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/sortItems/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.sortItems<TInput>(operation);\n```\n\n----------------------------------------\n\nTITLE: Defining GenericPipeItemAsync Type in TypeScript\nDESCRIPTION: This snippet defines the GenericPipeItemAsync type, which is a generic pipe item async type. It uses three generic parameters: TInput, TOutput, and TIssue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericPipeItemAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericPipeItemAsync<TInput, TOutput, TIssue> = PipeItemAsync<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: ExcludesIssue Interface Type Definition\nDESCRIPTION: Type definition showing the structure of the ExcludesIssue interface with its generics and properties including kind, type, expected and requirement fields.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ExcludesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ExcludesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SafeParseResult Type in TypeScript\nDESCRIPTION: This snippet defines the SafeParseResult type, which includes a generic parameter TSchema and four properties: typed, success, output, and issues. It's used to represent the result of a safe parsing operation in a type-safe manner.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SafeParseResult/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nSafeParseResult\n  - `TSchema`\n  - `typed`\n  - `success`\n  - `output`\n  - `issues`\n```\n\n----------------------------------------\n\nTITLE: Declaring a Base64 Validation Action in Valibot\nDESCRIPTION: Shows the basic syntax for creating a Base64 validation action in Valibot. The action validates if a string follows Base64 formatting rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/base64/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.base64<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating Check Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a check validation action with generic types TInput and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/check/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.check<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating IMEI Validation Action - TypeScript\nDESCRIPTION: Basic syntax for creating an IMEI validation action with optional custom error message. The action validates if a string matches the IMEI format.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/imei/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.imei<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Rendering ObjectEntriesAsync Property in JSX\nDESCRIPTION: This code snippet renders the ObjectEntriesAsync property using the Property component and the properties object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ObjectEntriesAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Property {...properties.ObjectEntriesAsync} />\n```\n\n----------------------------------------\n\nTITLE: Defining RawCheckAction Interface in TypeScript\nDESCRIPTION: This snippet defines the RawCheckAction interface with a generic type parameter TInput and two properties: type and reference. It's used for creating raw check actions in validation scenarios.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RawCheckAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface RawCheckAction<TInput> {\n  type: 'check';\n  reference: (input: TInput) => boolean | string | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Literal Type Definition with Property Component\nDESCRIPTION: Uses the Property component to display the properties of the Literal type, passing in the specific properties from an imported properties object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Literal/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<Property {...properties.Literal} />\n```\n\n----------------------------------------\n\nTITLE: Parser Interface Definition with Generics\nDESCRIPTION: Defines the Parser interface with two generic type parameters TSchema and TConfig, along with the core function signature and its required properties schema and config.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Parser/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Parser<TSchema, TConfig> {\n  (schema: TSchema, config?: TConfig): void;\n  schema: TSchema;\n  config?: TConfig;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating minBytes Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a minBytes validation action in Valibot. It validates that the input meets a minimum byte requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minBytes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.minBytes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating Async Check Validation - Basic Usage\nDESCRIPTION: Basic syntax for creating an async check validation action with input type and message generics.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/checkAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.checkAsync<TInput, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Creating IPv6 Address Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an IPv6 address validation action using Valibot. It shows the basic syntax for creating the action with optional generics for input type and error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/ipv6/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.ipv6<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Cloning Valibot Repository\nDESCRIPTION: Command to clone the Valibot repository using SSH\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/i18n/README.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:fabian-hiller/valibot.git\n```\n\n----------------------------------------\n\nTITLE: Defining HexadecimalAction Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the HexadecimalAction interface. It extends BaseValidation and includes properties for type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/HexadecimalAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nHexadecimalAction<TInput, TMessage> extends BaseValidation {\n  type: 'hexadecimal';\n  reference: string;\n  expects: string;\n  requirement: string;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BaseTransformation Interface in TypeScript\nDESCRIPTION: The BaseTransformation interface is defined with generics for input, output, and issue types. It includes properties for kind, type, reference, async flag, run method, and types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseTransformation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nBaseTransformation<TInput, TOutput, TIssue> {\n  kind: 'transformation'\n  type: string\n  reference: string\n  async: boolean\n  ~run: (input: TInput) => TOutput | Promise<TOutput>\n  ~types: {\n    input: TInput\n    output: TOutput\n    issue: TIssue\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReturnsActionAsync Interface in TypeScript\nDESCRIPTION: This snippet shows the structure of the ReturnsActionAsync interface. It extends BaseTransformation and includes properties for type, reference, and schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ReturnsActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nReturnsActionAsync<TInput, TSchema> extends BaseTransformation {\n  type: 'returns';\n  reference: string;\n  schema: TSchema;\n}\n```\n\n----------------------------------------\n\nTITLE: SchemaWithFallback Type Definition\nDESCRIPTION: Defines a generic schema type that includes fallback functionality. It accepts two generic parameters: TSchema for the schema type and TFallback for the fallback value type. The type extends BaseSchema and includes a required fallback property.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SchemaWithFallback/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SchemaWithFallback<TSchema, TFallback> = BaseSchema & {\n  fallback: TFallback;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an Octal Validation Action in Typescript\nDESCRIPTION: Creates an octal validation action that checks if a string is properly formatted as an octal number. The function accepts an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/octal/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.octal<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Find Item Transformation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the findItem function to create a transformation action. It takes a generic type TInput and an operation function as parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/findItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.findItem<TInput>(operation);\n```\n\n----------------------------------------\n\nTITLE: Building Valibot Library\nDESCRIPTION: Commands to navigate to the library directory and build the Valibot library.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/README.md#2025-04-09_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ./library && pnpm build\n```\n\n----------------------------------------\n\nTITLE: RfcEmailAction Interface Type Definition\nDESCRIPTION: Defines the structure of an RFC email action interface with input and message type generics. The interface includes properties for validation type, reference checking, expectations, requirements and custom messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RfcEmailAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RfcEmailAction<TInput, TMessage> {\n  type: 'email';\n  reference: 'rfc';\n  expects: TInput;\n  requirement: boolean;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EmojiAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the structure of the EmojiAction interface. It includes generics for input and message types, and specifies properties such as type, reference, expects, requirement, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EmojiAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EmojiAction<TInput, TMessage> {\n  type: 'emoji';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VariantSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the VariantSchemaAsync interface, which extends BaseSchemaAsync. It includes properties for type, reference, expects, key, options, and message. The interface is generic, allowing for customization of key, options, and message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VariantSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface VariantSchemaAsync<TKey, TOptions, TMessage> extends BaseSchemaAsync {\n  type: 'variant';\n  reference: string;\n  expects: string;\n  key: TKey;\n  options?: TOptions;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Slug Validation Action - TypeScript\nDESCRIPTION: Basic syntax for creating a slug validation action with optional message parameter. Used to validate if a string matches URL slug format.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/slug/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.slug<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Using startsWith Validation Function in Valibot\nDESCRIPTION: Basic syntax for the startsWith validation action which validates if a string begins with a specific substring. The function takes a requirement string and an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/startsWith/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.startsWith<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Basic tupleWithRestAsync Schema Definition\nDESCRIPTION: Basic syntax for creating a tuple with rest schema using tupleWithRestAsync. Shows the generic type parameters and basic function structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/tupleWithRestAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.tupleWithRestAsync<TItems, TRest, TMessage>(\n  items,\n  rest,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Comparing Valibot v0.30.0 and v0.31.0 API for Date Transformation\nDESCRIPTION: Demonstrates how the new pipe method in v0.31.0 simplifies code by reducing function nesting when transforming a string to a Date object and applying a brand.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v0.31.0-is-finally-available/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// With the previous API\nconst BirthdaySchema = v.brand(\n  v.transform(v.string([v.isoDate()]), (input) => new Date(input)),\n  'birthday'\n);\n\n// With the brand new API\nconst BirthdaySchema = v.pipe(\n  v.string(),\n  v.isoDate(),\n  v.transform((input) => new Date(input)),\n  v.brand('birthday')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining ToMinValueAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the ToMinValueAction interface, which extends BaseTransformation. It includes type, reference, and requirement properties for specifying the minimum value transformation action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ToMaxValueAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nToMinValueAction<TInput, TRequirement> extends BaseTransformation {\n  type: 'to_min_value';\n  reference: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mac64Action Interface in TypeScript\nDESCRIPTION: This snippet defines the Mac64Action interface, which extends BaseValidation. It includes properties for type, reference, expects, requirement, and message, all related to 64-bit MAC operations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Mac64Action/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMac64Action<TInput, TMessage> extends BaseValidation {\n  type: 'mac_64';\n  reference: TInput;\n  expects: TInput;\n  requirement: (input: TInput, reference: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Property Component for Literal Type Documentation\nDESCRIPTION: Imports the Property component and properties data to display the definition of the Literal type in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Literal/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Defining MultipleOf Validation Action in TypeScript\nDESCRIPTION: Base syntax for creating a multipleOf validation action with type parameters for input, requirement and custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/multipleOf/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.multipleOf<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Creating ISO Week Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an ISO week validation action using the isoWeek function from Valibot. It specifies generic types for input and message, and accepts a custom error message as a parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoWeek/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.isoWeek<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Importing Valibot Translations\nDESCRIPTION: Shows different ways to import translations from the @valibot/i18n package, from importing all translations to importing only specific language or function translations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/internationalization/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Import every translation (not recommended)\nimport '@valibot/i18n';\n\n// Import every translation for a specific language\nimport '@valibot/i18n/de';\n\n// Import only the translation for schema functions\nimport '@valibot/i18n/de/schema';\n\n// Import only the translation for a specific pipeline function\nimport '@valibot/i18n/de/minLength';\n```\n\n----------------------------------------\n\nTITLE: Number Transformation with Current API\nDESCRIPTION: Shows current API implementation for string to number transformation using transform method and pipeline validations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberSchema = transform(string([toTrimmed(), decimal()]), (input) => {\n  return parseInt(input);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining MacAction Interface TypeScript Types\nDESCRIPTION: Definition of TypeScript interface generics and properties for MAC action validation. Includes input type, message type, type identifier, reference, expectations, requirements and message properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MacAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MacAction<TInput, TMessage> {\n  type: 'mac';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => string | Promise<string>;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IsoDateTimeIssue Interface Structure\nDESCRIPTION: Interface definition for ISO date time validation issues, extending BaseIssue with specific properties for date time validation including kind, type, expected format, received value, and requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IsoDateTimeIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IsoDateTimeIssue<TInput> extends BaseIssue {\n  kind: 'iso_date_time';\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VoidSchema Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the VoidSchema interface. It extends BaseSchema and includes properties for type, reference, expects, and message. The interface is generic, accepting a TMessage type parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VoidSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface VoidSchema<TMessage> extends BaseSchema {\n  type: 'void';\n  reference: {};\n  expects: 'void';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UndefinedSchema Interface in TypeScript\nDESCRIPTION: This code snippet defines the UndefinedSchema interface, which extends BaseSchema. It includes properties for type, reference, expects, and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UndefinedSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UndefinedSchema extends BaseSchema {\n  type: 'undefined';\n  reference: undefined;\n  expects: 'undefined';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Variant Schema Structure in TypeScript\nDESCRIPTION: Basic structure for creating a variant schema with generic types and parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/variant/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.variant<TKey, TOptions, TMessage>(key, options, message);\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for Valibot in tsconfig.json\nDESCRIPTION: Enable strict mode in TypeScript configuration to ensure correct type calculations for Valibot. The minimum required TypeScript version is v5.0.2.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript-like Utility Types in Valibot\nDESCRIPTION: Shows how Valibot's object methods mirror TypeScript's utility types. The example demonstrates partial() to make object properties optional and pick() to select specific properties from an object schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/methods/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// TypeScript\ntype Object1 = Partial<{ key1: string; key2: number }>;\n\n// Valibot\nconst object1 = v.partial(v.object({ key1: v.string(), key2: v.number() }));\n\n// TypeScript\ntype Object2 = Pick<Object1, 'key1'>;\n\n// Valibot\nconst object2 = v.pick(object1, ['key1']);\n```\n\n----------------------------------------\n\nTITLE: Defining StartsWithIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the StartsWithIssue interface, which extends BaseIssue. It specifies properties for the issue kind, type, expected and received values, and the requirement that caused the issue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/StartsWithIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nStartsWithIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'starts_with';\n  type: 'string';\n  expected: string;\n  received: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: IpAction Interface Type Definition\nDESCRIPTION: Interface definition for IP validation action. Includes type parameters for input and message customization, along with core validation properties like type, reference, expects, requirement and message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IpAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IpAction<TInput, TMessage> {\n  type: 'ip'\n  reference: string\n  expects: 'v4' | 'v6'\n  requirement: boolean\n  message?: TMessage\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MaybeReadonly Generic Type Parameter\nDESCRIPTION: Definition of the TValue generic type parameter used in the MaybeReadonly type utility.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaybeReadonly/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTValue\n```\n\n----------------------------------------\n\nTITLE: Creating Not Bytes Validation Action in TypeScript\nDESCRIPTION: Shows the basic syntax for creating a notBytes validation action with generic types for input, requirement and message parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/notBytes/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.notBytes<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: Basic Omit Schema Definition\nDESCRIPTION: Basic syntax for creating an omitted schema using Valibot's omit method with generic type parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(methods)/omit/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.omit<TSchema, TKeys>(schema, keys);\n```\n\n----------------------------------------\n\nTITLE: Extending Schema Pipelines in Valibot v0.31.0\nDESCRIPTION: Shows how to reuse and extend existing schemas with the new pipe method to create more specialized validation rules, similar to class extension in OOP.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v0.31.0-is-finally-available/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst GmailSchema = v.pipe(EmailSchema, v.endsWith('@gmail.com'));\n```\n\n----------------------------------------\n\nTITLE: Migrating Object and Tuple Schemas with Rest Arguments in TypeScript\nDESCRIPTION: Example of migrating object and tuple schemas with rest arguments to the new objectWithRest and tupleWithRest schemas in Valibot v0.31.0.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst ObjectSchema = v.object({ key: v.string() }, v.null_());\nconst TupleSchema = v.tuple([v.string()], v.null_());\n\n// To this\nconst ObjectSchema = v.objectWithRest({ key: v.string() }, v.null_());\nconst TupleSchema = v.tupleWithRest([v.string()], v.null_());\n```\n\n----------------------------------------\n\nTITLE: Defining VariantOptionsAsync Type in TypeScript\nDESCRIPTION: This code snippet defines the VariantOptionsAsync type, which is a variant options async type. It includes a generic parameter TKey and the type definition.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VariantOptionsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nVariantOptionsAsync<TKey extends string | number | symbol>\n```\n\n----------------------------------------\n\nTITLE: Defining IpIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the IpIssue interface, which extends BaseIssue. It specifies properties such as kind, type, expected, received, and requirement for IP address validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IpIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nIpIssue<TInput> extends BaseIssue {\n  kind: 'ip';\n  type: 'ip_address';\n  expected: 'valid IP address';\n  received: TInput;\n  requirement?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Property Component and Properties in TSX\nDESCRIPTION: This snippet imports the Property component and properties object, likely used for rendering and defining the ContentInput type properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ContentInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Using InferTupleInput with String Transformation in TypeScript\nDESCRIPTION: Example showing how to create a tuple schema with string validation and length transformation, then infer its input type using InferTupleInput. The inferred type will be [string] since the input type is captured before the transformation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferTupleInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create tuple items\nconst items = [\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  ),\n];\n\n// Infer items input type\ntype ItemsInput = v.InferTupleInput<typeof items>; // [string]\n```\n\n----------------------------------------\n\nTITLE: Using mapAsync Schema Function in Valibot\nDESCRIPTION: Basic syntax for creating an asynchronous map schema in Valibot. This function validates that the input is a Map and that its keys and values match the specified schemas.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/mapAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.mapAsync<TKey, TValue, TMessage>(key, value, message);\n```\n\n----------------------------------------\n\nTITLE: Inferring Validation Issues with InferIssue in TypeScript\nDESCRIPTION: Example of using the InferIssue utility type to extract possible validation issues from a schema. This creates a union type of all possible validation errors that could occur when validating data against the schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/infer-types/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst LoginSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\ntype Issue = v.InferIssue<typeof LoginSchema>; // v.ObjectIssue | v.StringIssue | v.EmailIssue<string> | v.MinLengthIssue<string, 8>\n```\n\n----------------------------------------\n\nTITLE: Defining UnionOptionsAsync Type in TypeScript\nDESCRIPTION: This snippet defines the UnionOptionsAsync type, which is used for asynchronous union options in Valibot. It's likely a part of a larger type system for validation or data processing.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnionOptionsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nUnionOptionsAsync\n```\n\n----------------------------------------\n\nTITLE: CheckItemsIssue Interface Type Definition in TypeScript\nDESCRIPTION: Type definition for CheckItemsIssue interface that extends BaseIssue. It includes properties for kind, type, expected value, and requirement validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/CheckItemsIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CheckItemsIssue<TInput> extends BaseIssue {\n  kind: 'items';\n  type: string;\n  expected: string;\n  requirement: TInput;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeActionAsync Interface in TypeScript\nDESCRIPTION: Declares the PipeActionAsync interface with generics for input, output, and issue types. This interface is likely used for asynchronous validation or transformation operations in a pipeline structure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PipeActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nPipeActionAsync<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: Using Convention 2: Schema and Types Usage Example\nDESCRIPTION: Shows how to import and use the ImageSchema with separate Input and Output types for validation and type checking.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(advanced)/naming-convention/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { ImageInput, ImageOutput, ImageSchema } from './types';\n\nexport function createImage(input: ImageInput): ImageOutput {\n  return v.parse(ImageSchema, input);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RawTransformActionAsync Interface in TypeScript\nDESCRIPTION: This snippet defines the RawTransformActionAsync interface with generics for input and output types. It extends BaseTransformationAsync and includes properties for type and reference.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RawTransformActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface RawTransformActionAsync<TInput, TOutput> extends BaseTransformationAsync<TInput, TOutput> {\n  type: 'raw';\n  reference: (input: TInput) => Promise<TOutput>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getSpecificMessage Function in TypeScript\nDESCRIPTION: Example of retrieving a specific error message using getSpecificMessage from the valibot library. The function takes a reference and language parameter and returns the corresponding error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/getSpecificMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst message = v.getSpecificMessage(reference, lang);\n```\n\n----------------------------------------\n\nTITLE: Defining LengthIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the LengthIssue interface, which extends BaseIssue. It includes properties for the kind of issue, the type of validation, expected and received lengths, and the requirement that triggered the issue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LengthIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nLengthIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'length';\n  type: 'string' | 'number' | 'bigint' | 'array' | 'set' | 'map';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic rawTransformAsync Usage\nDESCRIPTION: Basic syntax for creating a raw transformation action with async functionality.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/rawTransformAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.rawTransformAsync<TInput, TOutput>(action);\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayPathItem Interface Structure\nDESCRIPTION: Interface definition showing the required properties for an array path item. Includes type identification, origin reference, input value, numeric key, and associated value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArrayPathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ArrayPathItem {\n  type: string;\n  origin: string;\n  input: unknown;\n  key: number;\n  value: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Non-Nullish Input Type with Valibot Schema\nDESCRIPTION: Shows how to create a nullish string schema and infer its non-nullish input type. The example combines string validation, transformation, and type inference using Valibot's utilities.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNonNullishInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create nullish sting schema\nconst NullishStringSchema = v.nullish(\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  )\n);\n\n// Infer non nullish string input type\ntype NonNullishStringInput = v.InferNonNullishInput<typeof NullishStringSchema>; // string\n```\n\n----------------------------------------\n\nTITLE: Defining PartialCheckIssue Interface Structure\nDESCRIPTION: Interface definition showing the structure of a PartialCheckIssue, which extends BaseIssue and includes properties for validation kind, type, expected value, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PartialCheckIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PartialCheckIssue<TInput> extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n  requirement: TInput;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Error Message in Valibot\nDESCRIPTION: Function call to set a specific error message for a validation reference. Takes a reference identifier, custom message string, and optional language code parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/setSpecificMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.setSpecificMessage<TReference>(reference, message, lang);\n```\n\n----------------------------------------\n\nTITLE: Defining MultipleOfIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the MultipleOfIssue interface, which extends BaseIssue. It includes properties for the kind of issue, type, expected and received values, and the requirement that wasn't met.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MultipleOfIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMultipleOfIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'multiple_of';\n  type: 'number';\n  expected: string;\n  received: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IsoDateAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the IsoDateAction interface, which extends BaseValidation. It includes properties for type, reference, expects, requirement, and message, tailored for ISO date validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IsoDateAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nIsoDateAction<TInput, TMessage> extends BaseValidation {\n  type: 'iso_date';\n  reference: 'time' | 'date' | 'date_time';\n  expects: string;\n  requirement: string;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: SetPathItem Interface Structure\nDESCRIPTION: Defines the structure of a SetPathItem object used in validation paths. Contains properties for tracking the type, origin, input value, and transformed value. The input property may differ from the issue input due to parent schema transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SetPathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  type: string;\n  origin: string;\n  input: unknown;\n  value: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: EmailIssue Interface Type Definition\nDESCRIPTION: Interface definition for email validation issues that extends the BaseIssue type. It includes properties for identifying the kind of issue, validation type, expected and received values, and validation requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EmailIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EmailIssue<TInput> extends BaseIssue {\n  kind: 'email';\n  type: 'type';\n  expected: 'email';\n  received: TInput;\n  requirement: 'email';\n}\n```\n\n----------------------------------------\n\nTITLE: VoidIssue Interface Structure\nDESCRIPTION: Demonstrates the structure of the VoidIssue interface with its component properties. The interface extends BaseIssue and includes kind, type, and expected fields for void type validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/VoidIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `VoidIssue` <Property {...properties.BaseIssue} />\n  - `kind` <Property {...properties.kind} />\n  - `type` <Property {...properties.type} />\n  - `expected` <Property {...properties.expected} />\n```\n\n----------------------------------------\n\nTITLE: Deleting Global Configuration in Valibot using TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the deleteGlobalConfig function in Valibot to remove the global configuration. It's a simple function call without any parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/deleteGlobalConfig/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.deleteGlobalConfig();\n```\n\n----------------------------------------\n\nTITLE: Defining NonEmptyIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the NonEmptyIssue interface, which extends the BaseIssue interface. It includes properties for the kind of issue, type, expected value, and received value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonEmptyIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NonEmptyIssue extends BaseIssue {\n  kind: 'non_empty';\n  type: 'non_empty';\n  expected: 'non-empty';\n  received: 'empty';\n}\n```\n\n----------------------------------------\n\nTITLE: OptionalSchemaAsync Interface Definition\nDESCRIPTION: TypeScript interface definition for OptionalSchemaAsync that includes type declarations for wrapped schemas and default values with async support.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/OptionalSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface OptionalSchemaAsync<TWrapped, TDefault> extends BaseSchemaAsync {\n  type: 'optional';\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  default: TDefault;\n}\n```\n\n----------------------------------------\n\nTITLE: OutputDataset Interface Type Parameters\nDESCRIPTION: Definition of generic type parameters used in the OutputDataset interface for specifying value and issue types in validation results.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/OutputDataset/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTValue // Type parameter for the validated value\nTIssue // Type parameter for validation issues\n```\n\n----------------------------------------\n\nTITLE: Defining Config Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the Config interface. It includes generics for issue type and properties for language, message handling, and early abort options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Config/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nConfig<TIssue> {\n  lang: string;\n  message: string | ((issue: TIssue) => string);\n  abortEarly: boolean;\n  abortPipeEarly: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: EmptyIssue Interface Definition\nDESCRIPTION: Defines the EmptyIssue interface that extends BaseIssue with specific properties for handling empty value validation errors. The interface uses a generic type TInput and includes properties for error kind, type, expected and received values.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EmptyIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EmptyIssue<TInput> extends BaseIssue {\n  kind: 'empty';\n  type: 'empty';\n  expected: 'non-empty';\n  received: TInput;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Digits Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating a digits validation action with optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/digits/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.digits<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Interface Properties - DecimalIssue Structure\nDESCRIPTION: Structure showing the properties of the DecimalIssue interface including kind, type, expected, received, and requirement fields that extend from BaseIssue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DecimalIssue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DecimalIssue extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n  received: string;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: TitleAction Interface Generic Type Declaration\nDESCRIPTION: TypeScript interface declaration showing the structure of TitleAction with generic type parameters TInput and TTitle. The interface includes type, reference and title properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TitleAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TitleAction<TInput, TTitle> {\n  type: string;\n  reference: TInput;\n  title: TTitle;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultAsync Type in TypeScript\nDESCRIPTION: This code snippet defines the DefaultAsync type, which is an asynchronous default type. It uses two generic parameters: TWrapped for the wrapped type and TInput for the input type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DefaultAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nDefaultAsync<TWrapped, TInput>\n```\n\n----------------------------------------\n\nTITLE: Defining GenericTransformationAsync Type\nDESCRIPTION: Type definition for a generic asynchronous transformation that takes input type TInput and returns TOutput, with optional error handling of type TIssue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericTransformationAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericTransformationAsync<TInput, TOutput, TIssue> = {\n  TInput: The input type of the transformation\n  TOutput: The output type of the transformation\n  TIssue: The type of validation issues that can occur\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RfcEmailIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the RfcEmailIssue interface, which extends BaseIssue with additional properties specific to RFC email validation issues. It uses a generic type TInput and includes properties for the issue kind, type, expected and received values, and the validation requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RfcEmailIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RfcEmailIssue<TInput> extends BaseIssue {\n  kind: 'email';\n  type: 'rfc';\n  expected: 'RFC email';\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Validation Action in TypeScript\nDESCRIPTION: Basic syntax for creating an integer validation action with optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/integer/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.integer<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Defining NanIssue Interface Structure\nDESCRIPTION: Interface definition showing the structure of NanIssue, which extends BaseIssue with specific properties for NaN validation. It includes kind, type, and expected value properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NanIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nNanIssue {\n  kind: BaseIssue\n  type: string\n  expected: string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BaseValidation Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the BaseValidation interface. It includes generics for input, output, and issue types, as well as properties for kind, type, reference, expects, async, run, and types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseValidation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface BaseValidation<TInput, TOutput, TIssue> {\n  kind: string;\n  type: string;\n  reference: string;\n  expects: string;\n  async: boolean;\n  run: (input: TInput) => TOutput | Promise<TOutput>;\n  types: {\n    input: TInput;\n    output: TOutput;\n    issue: TIssue;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Importing FallbackAsync Components\nDESCRIPTION: Shows the import statements for Property component and properties object used in the documentation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FallbackAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Defining SafeIntegerAction Interface in TypeScript\nDESCRIPTION: The SafeIntegerAction interface extends BaseValidation and includes properties for type, reference, expects, requirement, and message. It uses generics TInput and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SafeIntegerAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SafeIntegerAction<TInput, TMessage> extends BaseValidation {\n  type: 'safe_integer';\n  reference: SafeInteger;\n  expects: 'safe integer';\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: NotSizeIssue Interface Structure\nDESCRIPTION: Defines the interface for size validation issues with generic types TInput and TRequirement. The interface extends BaseIssue and includes properties for kind, type, expected/received values, and validation requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotSizeIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NotSizeIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'not_size';\n  type: string;\n  expected: string;\n  received: string;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the isOfKind Type Guard in TypeScript\nDESCRIPTION: Example usage of the isOfKind function from Valibot to check if an object matches a specific kind. The function takes a kind parameter and an object to check, and returns a boolean result.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(utils)/isOfKind/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = v.isOfKind<TKind, TObject>(kind, object);\n```\n\n----------------------------------------\n\nTITLE: Defining TupleWithRestIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the TupleWithRestIssue interface, which extends BaseIssue. It includes properties for the kind of issue, the type of tuple, and the expected value. The interface is used to represent validation issues specific to tuples with rest elements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/TupleWithRestIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TupleWithRestIssue extends BaseIssue {\n  kind: 'tuple_with_rest';\n  type: 'tuple';\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an endsWith Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an endsWith validation action in Valibot. It validates that a string ends with a specific substring.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/endsWith/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.endsWith<TInput, TRequirement, TMessage>(requirement, message);\n```\n\n----------------------------------------\n\nTITLE: AddIssue Type Definition\nDESCRIPTION: Specifies the AddIssue type which is used to add validation issues in Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawTransform/AddIssue/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nAddIssue\n```\n\n----------------------------------------\n\nTITLE: MaxSizeAction Interface Type Definition\nDESCRIPTION: Type interface for max size validation action with generic parameters TInput, TRequirement, and TMessage. The interface extends BaseValidation and includes properties for type, reference, expects, requirement and message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxSizeAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MaxSizeAction<TInput, TRequirement, TMessage> extends BaseValidation {\n  type: 'max_size';\n  reference: TInput;\n  expects: string;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MaxGraphemesIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the MaxGraphemesIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected and received values, and the validation requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxGraphemesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface MaxGraphemesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_graphemes';\n  type: 'string';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an ISO Date Validation Action in Valibot\nDESCRIPTION: Demonstrates the basic syntax for creating an ISO date validation action in Valibot. This action validates strings against the ISO date format (yyyy-mm-dd).\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/isoDate/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.isoDate<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Using Specialized Object and Tuple Schemas in TypeScript\nDESCRIPTION: Example of migrating to the new specialized object and tuple schemas in Valibot v0.31.0, which provide more explicit control over whether unknown properties are allowed or forbidden.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst LooseObjectSchema = v.object({ key: v.string() }, v.unknown());\nconst LooseTupleSchema = v.tuple([v.string()], v.unknown());\nconst StrictObjectSchema = v.object({ key: v.string() }, v.never());\nconst StrictTupleSchema = v.tuple([v.string()], v.never());\n\n// To this\nconst LooseObjectSchema = v.looseObject({ key: v.string() });\nconst LooseTupleSchema = v.looseTuple([v.string()]);\nconst StrictObjectSchema = v.strictObject({ key: v.string() });\nconst StrictTupleSchema = v.strictTuple([v.string()]);\n```\n\n----------------------------------------\n\nTITLE: Defining MapPathItem Interface in TypeScript\nDESCRIPTION: This code snippet defines the MapPathItem interface with its properties. It includes type, origin, input, key, and value. The interface is used to represent path items in map structures within Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MapPathItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nMapPathItem\n  - type: Property\n  - origin: Property\n  - input: Property\n  - key: Property (type: unknown)\n  - value: Property (type: unknown)\n```\n\n----------------------------------------\n\nTITLE: Creating Dot Path from Issue in TypeScript\nDESCRIPTION: Example of using Valibot's getDotPath function to create a dot-notation path from an issue object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/issues/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst dotPath = v.getDotPath(issue);\n```\n\n----------------------------------------\n\nTITLE: Defining ValueAction Interface in TypeScript\nDESCRIPTION: This snippet defines the ValueAction interface with its properties and generic types. It includes type, reference, expects, requirement, and message properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ValueAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ValueAction<TInput, TRequirement, TMessage> {\n  type: 'value';\n  reference: (input: TInput) => boolean;\n  expects: string;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: SafeParserAsync Interface Definition with Generics\nDESCRIPTION: TypeScript interface definition for SafeParserAsync that includes generic type parameters TSchema and TConfig, along with function parameters for schema and configuration.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SafeParserAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SafeParserAsync<TSchema, TConfig> {\n  (schema: TSchema, config?: TConfig): Promise<Output>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating minLength Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a minLength validation action in Valibot. It shows the function signature with generics for input type, requirement type, and message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/minLength/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.minLength<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Merging Object Schemas in Valibot using TypeScript\nDESCRIPTION: Demonstrates how to merge multiple object schemas in Valibot using the spread operator instead of the deprecated merge function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst ObjectSchema1 = v.object({ foo: v.string() });\nconst ObjectSchema2 = v.object({ bar: v.number() });\n\n// Change this\nconst MergedObject = v.merge([ObjectSchema1, ObjectSchema2]);\n\n// To this\nconst MergedObject = v.object({\n  ...ObjectSchema1.entries,\n  ...ObjectSchema2.entries,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining UnionIssue Generic Interface\nDESCRIPTION: TypeScript interface definition for UnionIssue that extends BaseIssue with union-specific validation properties. Includes kind, type, expected value, and nested issues array.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnionIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UnionIssue<TSubIssue> extends BaseIssue {\n  kind: 'union';\n  type: string;\n  expected: string;\n  issues: TSubIssue[];\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Object and Tuple Schema Definitions\nDESCRIPTION: Demonstrates migration from basic object and tuple schemas to their 'WithRest' variants that support additional properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/codemod/migrate-to-v0.31.0/README.md#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { object, tuple } from 'valibot';\n\nconst ObjectSchema = object({ key: v.string() }, v.null_());\nconst TupleSchema = tuple([v.string()], v.null_());\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\nimport { objectWithRest, tupleWithRest } from 'valibot';\n\nconst ObjectSchema = objectWithRest({ key: v.string() }, v.null_());\nconst TupleSchema = tupleWithRest([v.string()], v.null_());\n```\n\n----------------------------------------\n\nTITLE: Defining BaseSchemaAsync Interface with Generics\nDESCRIPTION: TypeScript interface definition for BaseSchemaAsync that includes generic type parameters for input, output, and issue types, along with core properties for schema validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BaseSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BaseSchemaAsync<TInput, TOutput, TIssue> {\n  reference: string;\n  async: true;\n  ~run: (input: TInput) => Promise<SchemaResult<TOutput, TIssue>>;\n}\n```\n\n----------------------------------------\n\nTITLE: MaybeReadonly Type Implementation\nDESCRIPTION: Implementation of the MaybeReadonly type that makes a type optionally readonly.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaybeReadonly/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nMaybeReadonly\n```\n\n----------------------------------------\n\nTITLE: Creating UUID Validation Action in TypeScript\nDESCRIPTION: Demonstrates how to create a UUID validation action using Valibot. The function takes optional generic type parameters for input and message types, and an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/uuid/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.uuid<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Replacing Coerce with Pipe and Transform in Valibot using TypeScript\nDESCRIPTION: Illustrates how to replace the deprecated coerce method with a combination of pipe and transform actions for type-safe transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Change this\nconst DateSchema = v.coerce(v.date(), (input) => new Date(input));\n\n// To this\nconst DateSchema = v.pipe(\n  v.union([v.string(), v.number()]),\n  v.transform((input) => new Date(input))\n);\n```\n\n----------------------------------------\n\nTITLE: Inferring Non-Nullable Output Type with InferNonNullishOutput in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the InferNonNullishOutput type utility from Valibot to infer the non-nullable output type of a nullish string schema. It creates a schema that allows null or undefined values, transforms valid strings to their length, and then infers the resulting non-nullable type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/InferNonNullishOutput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create nullish sting schema\nconst NullishStringSchema = v.nullish(\n  v.pipe(\n    v.string(),\n    v.transform((input) => input.length)\n  )\n);\n\n// Infer non nullish string output type\ntype NonNullishStringOutput = v.InferNonNullishOutput<\n  typeof NullishStringSchema\n>; // number\n```\n\n----------------------------------------\n\nTITLE: Length Schema Comparison\nDESCRIPTION: Demonstrates the difference in syntax for length transformation between proposed and current API.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// With the new `pipe` function\nconst LengthSchema = pipe(\n  optional(string(), ''),\n  transform((input) => input.length),\n  brand('Length')\n);\n\n// With Valibot's current API\nconst LengthSchema = brand(\n  transform(optional(string(), ''), (input) => input.length),\n  'Length'\n);\n```\n\n----------------------------------------\n\nTITLE: PartialCheckActionAsync Interface Definition\nDESCRIPTION: TypeScript interface definition for PartialCheckActionAsync that extends BaseValidationAsync. It includes properties for type, reference, expects, paths, requirement, and message with generics for input, paths, selection and message types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PartialCheckActionAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PartialCheckActionAsync<TInput, TPaths, TSelection, TMessage> extends BaseValidationAsync {\n  type: 'partial_check';\n  reference: unknown;\n  expects: unknown;\n  paths: TPaths;\n  requirement: (input: TInput, value: TSelection) => Promise<boolean>;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Context Interface Definition\nDESCRIPTION: Defines the Context interface with key properties including dataset, config, addIssue, and NEVER. The interface accepts a generic type parameter TInput.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/rawTransform/Context/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Context<TInput> {\n  dataset: unknown;\n  config: unknown;\n  addIssue: (issue: unknown) => void;\n  NEVER: symbol;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nano ID Validation Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Nano ID validation action using Valibot. It shows the basic function signature with generics for input type and message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/nanoid/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.nanoid<TInput, TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Converting Valibot Schema to JSON Schema Example\nDESCRIPTION: Demonstrates how to convert a Valibot email validation schema to its JSON Schema representation using the @valibot/to-json-schema package\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v1-rc-is-available/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\nconst ValibotEmailSchema = v.pipe(v.string(), v.email());\nconst JsonEmailSchema = toJsonSchema(ValibotEmailSchema);\n// -> { type: 'string', format: 'email' }\n```\n\n----------------------------------------\n\nTITLE: Defining NotLengthAction Interface in TypeScript\nDESCRIPTION: This snippet defines the NotLengthAction interface with its properties. It extends BaseValidation and includes specific properties for not length validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NotLengthAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NotLengthAction<TInput, TRequirement, TMessage> extends BaseValidation<TInput, TMessage> {\n  type: 'not_length';\n  reference: number;\n  expects: boolean;\n  requirement: TRequirement;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Current Object Schema Implementation in TypeScript\nDESCRIPTION: Demonstrates the current behavior where Valibot doesn't distinguish between missing and undefined object entries, causing type mismatches with TypeScript's exactOptionalPropertyTypes.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-the-object-schema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// This throws no error and types `output` as `{ key?: string }`\nconst Schema = v.object({ key: v.optional(v.string()) });\nconst output = v.parse(Schema, { key: undefined });\n\n// TypeScript thinks that `key` is a string if it is present\n// but this is wrong because `key` is actually `undefined`\nif ('key' in output) {\n  const key = output.key;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CustomSchema Interface Structure\nDESCRIPTION: Typescript interface definition showing the structure of a CustomSchema, including generics for input type and message type, along with required properties for schema validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/CustomSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CustomSchema<TInput, TMessage> {\n  type: 'custom';\n  reference: unknown;\n  expects: string;\n  check: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Components and Properties in TypeScript/React\nDESCRIPTION: Import statements for Property component and properties object used in the documentation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GlobalConfig/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Creating a Never Schema in Valibot with TypeScript\nDESCRIPTION: This code demonstrates how to create a never schema using Valibot. A never schema always returns an issue when validated, and accepts an optional custom error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/never/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.never<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: ORM Integration with Valibot Metadata Example\nDESCRIPTION: Shows how to use Valibot's metadata feature to integrate with an ORM, demonstrating table schema definition with primary key and index declarations\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v1-rc-is-available/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as o from 'orm-actions';\nimport * as v from 'valibot';\n\nconst UserTableSchema = v.pipe(\n  v.object({\n    id: v.pipe(v.number(), v.integer(), o.primaryKey()),\n    name: v.pipe(v.string(), v.nonEmpty(), o.index()),\n    email: v.pipe(v.string(), v.email(), o.index()),\n    // ...\n  }),\n  o.table('users')\n);\n```\n\n----------------------------------------\n\nTITLE: Defining OctalAction Interface Type Structure\nDESCRIPTION: Interface definition for OctalAction that includes validation properties like type, reference, expects, requirement, and message. Uses generics TInput and TMessage for flexible typing.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/OctalAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface OctalAction<TInput, TMessage> {\n  type: string;\n  reference: string;\n  expects: string;\n  requirement: (input: TInput) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MinValueIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the MinValueIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected value, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinValueIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMinValueIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'min_value';\n  type: 'number' | 'string' | 'date';\n  expected: string;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenericSchemaAsync Type in TypeScript\nDESCRIPTION: The GenericSchemaAsync type is defined as a generic type with three type parameters: TInput, TOutput, and TIssue. It extends the BaseSchemaAsync type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nGenericSchemaAsync<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: NonOptional Type Definition\nDESCRIPTION: Defines the NonOptional type utility that removes undefined from the input type TValue, resulting in a new type that excludes undefined as a possible value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonOptional/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nNonOptional\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance Schema in Valibot\nDESCRIPTION: Basic syntax for creating an instance schema. This schema validates whether an input is an instance of a specified class and allows customizing the error message on validation failure.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/instance/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.instance<TClass, TMessage>(class_, message);\n```\n\n----------------------------------------\n\nTITLE: Using Pipe Function with Email Validation in TypeScript\nDESCRIPTION: Demonstrates how to use the new pipe function to create nested email validation schemas with composable validation rules.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/first-draft-of-the-new-pipe-function/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst EmailSchema = v.pipe(v.string(), v.email());\nconst GmailSchema = v.pipe(EmailSchema, v.endsWith('@gmail.com'));\n```\n\n----------------------------------------\n\nTITLE: Generic Validation Type Declaration\nDESCRIPTION: Defines a generic validation type that takes three type parameters: TInput for the input type, TOutput for the output type, and TIssue for validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GenericValidation/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericValidation<TInput, TOutput = TInput, TIssue = DefaultIssue> = BaseValidation<TInput, TOutput, TIssue>\n```\n\n----------------------------------------\n\nTITLE: Defining MinBytesIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the MinBytesIssue interface, which extends BaseIssue. It specifies properties for the kind of issue, type, expected and received values, and the requirement that wasn't met.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinBytesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMinBytesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'min_bytes';\n  type: 'bytes';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeItemAsync Type in TypeScript\nDESCRIPTION: This snippet defines the PipeItemAsync type, which is an asynchronous function type used for pipe operations. It takes input of type TInput and returns a Promise that resolves to either TOutput or a SchemaIssues<TIssue> object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PipeItemAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype PipeItemAsync<TInput, TOutput, TIssue> = (input: TInput) => Promise<TOutput | SchemaIssues<TIssue>>;\n```\n\n----------------------------------------\n\nTITLE: FirstTupleItem Type Definition Header\nDESCRIPTION: Markdown and component imports for the FirstTupleItem type documentation page.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FirstTupleItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: FirstTupleItem\ndescription: Extracts first tuple item.\ncontributors:\n  - fabian-hiller\n---\n\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Creating a Promise Schema in Valibot\nDESCRIPTION: This snippet demonstrates how to create a basic promise schema using Valibot. It uses a generic type TMessage for customizing error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/promise/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.promise<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Profile Schema with Type Transformation\nDESCRIPTION: Demonstrates how to create an object schema that transforms nullable input types to non-nullable output types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/first-draft-of-the-new-pipe-function/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\n// This schema\nconst ProfileSchema = v.object({\n  name: v.string(),\n  age: v.pipe(v.nullable(v.number()), v.number()),\n  bio: v.pipe(v.nullable(v.string()), v.string()),\n});\n\n// Has this input type\ntype ProfileInput = {\n  name: string;\n  age: number | null;\n  bio: string | null;\n};\n\n// But this output type\ntype ProfileOutput = {\n  name: string;\n  age: number;\n  bio: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining MaxSizeIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the MaxSizeIssue interface, which extends BaseIssue. It includes properties for the kind of issue, type, expected and received values, and the requirement that triggered the issue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxSizeIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMaxSizeIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_size';\n  type: 'object' | 'array' | 'string';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MaxBytesIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the MaxBytesIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected and received values, and the requirement that triggered the issue.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxBytesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nMaxBytesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_bytes';\n  type: 'bytes';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SizeInput Type in TypeScript\nDESCRIPTION: The SizeInput type is defined as a union of number and string types. It is used to represent size inputs that can be either numeric values or string-based size representations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SizeInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nSizeInput = number | string\n```\n\n----------------------------------------\n\nTITLE: Importing Valibot in Deno using JSR specifiers\nDESCRIPTION: Examples of importing Valibot directly in Deno using JSR specifiers, showing both individual and wildcard import syntax.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// With individual imports\nimport { â€¦ } from 'jsr:@valibot/valibot';\n\n// With a wildcard import\nimport * as v from 'jsr:@valibot/valibot';\n```\n\n----------------------------------------\n\nTITLE: Creating a Symbol Schema in Valibot\nDESCRIPTION: This snippet demonstrates how to create a basic symbol schema using Valibot. It uses a generic type for the error message and an optional custom error message parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/symbol/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.symbol<TMessage>(message);\n```\n\n----------------------------------------\n\nTITLE: Pipeline Validation Abort Configuration\nDESCRIPTION: Demonstrates using abortPipeEarly option to stop pipeline validation after first error, useful for form validation scenarios.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(main-concepts)/parse-data/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\ntry {\n  const EmailSchema = v.pipe(v.string(), v.email(), v.endsWith('@example.com'));\n  const email = v.parse(EmailSchema, 'jane@example.com', {\n    abortPipeEarly: true,\n  });\n\n  // Handle errors if one occurs\n} catch (error) {\n  console.log(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RegexIssue Interface Properties\nDESCRIPTION: Interface definition for RegexIssue that extends BaseIssue. Includes properties for kind, type, expected value, received value, and validation requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RegexIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RegexIssue<TInput> extends BaseIssue {\n  kind: 'regex';\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: RegExp;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RecordIssue Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the RecordIssue interface. It extends BaseIssue and includes additional properties such as kind, type, and expected. These properties are likely used to provide detailed information about validation issues in record-type data structures.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/RecordIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nRecordIssue {\n  kind: 'record'\n  type: 'type' | 'key' | 'value'\n  expected: string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonNullableSchemaAsync Interface in TypeScript\nDESCRIPTION: This snippet shows the structure of the NonNullableSchemaAsync interface. It extends BaseSchemaAsync and includes properties for type, reference, expects, wrapped schema, and error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonNullableSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nNonNullableSchemaAsync<TWrapped, TMessage> extends BaseSchemaAsync {\n  type: 'non_nullable';\n  reference: string;\n  expects: string;\n  wrapped: TWrapped;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Valibot Features in JSON Schema Conversion\nDESCRIPTION: Shows how to use the errorMode configuration to handle unsupported Valibot features during JSON Schema conversion.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/to-json-schema/README.md#2025-04-09_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\ntoJsonSchema(v.file(), { errorMode: 'ignore' }); // {}\n\ntoJsonSchema(v.pipe(v.string(), v.creditCard()), { errorMode: 'ignore' }); // { type: \"string\" }\n```\n\n----------------------------------------\n\nTITLE: Creating a Literal Schema in TypeScript\nDESCRIPTION: This snippet demonstrates the basic syntax for creating a literal schema using Valibot. It shows the function signature with generics for the literal type and error message type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(schemas)/literal/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.literal<TLiteral, TMessage>(literal, message);\n```\n\n----------------------------------------\n\nTITLE: Required Keys Record Schema in TypeScript\nDESCRIPTION: Shows how to create a record schema with required keys using object and entriesFromList utilities.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst RecordSchema = v.object(v.entriesFromList(['key1', 'key2'], v.number())); // { key1: number; key2: number }\n```\n\n----------------------------------------\n\nTITLE: Defining UrlAction Interface in TypeScript\nDESCRIPTION: The UrlAction interface extends BaseValidation and includes properties for type, reference, expects, requirement, and message. It uses generics TInput and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UrlAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UrlAction<TInput, TMessage> extends BaseValidation {\n  type: 'url_action';\n  reference: string;\n  expects: string;\n  requirement: (input: TInput, reference: string, expects: string) => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BlobIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the structure of the BlobIssue interface. It extends BaseIssue and includes additional properties specific to blob validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BlobIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nBlobIssue {\n  kind: BaseIssue['kind'];\n  type: 'blob';\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UnionSchema Interface in TypeScript\nDESCRIPTION: This code snippet defines the UnionSchema interface, which extends BaseSchema. It includes properties for type, reference, options, and message, along with generics for TOptions and TMessage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/UnionSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nUnionSchema<TOptions, TMessage> extends BaseSchema {\n  type: 'union';\n  reference: unknown;\n  options: TOptions;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Building for npm and JSR\nDESCRIPTION: Commands to build the i18n library for npm or JSR distribution\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/i18n/README.md#2025-04-09_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm build.npm      # for npm\npnpm build.jsr      # for JSR\n```\n\n----------------------------------------\n\nTITLE: Creating Non-Optional Async Schema - Basic Usage\nDESCRIPTION: Basic syntax for creating a non-optional async schema using Valibot. Used to ensure values are not undefined during validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonOptionalAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonOptionalAsync<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Importing Valibot in JavaScript/TypeScript (JSR version)\nDESCRIPTION: Examples of importing Valibot in JavaScript or TypeScript files after installation via JSR, showing both individual and wildcard import syntax.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// With individual imports\nimport { â€¦ } from '@valibot/valibot';\n\n// With a wildcard import\nimport * as v from '@valibot/valibot';\n```\n\n----------------------------------------\n\nTITLE: NonOptional Type Generic Parameter Definition\nDESCRIPTION: Defines the generic type parameter TValue used in the NonOptional type utility. TValue represents any input type from which undefined will be extracted.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NonOptional/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTValue\n```\n\n----------------------------------------\n\nTITLE: Defining GraphemesIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the GraphemesIssue interface, which extends BaseIssue. It specifies properties such as kind, type, expected, received, and requirement. The interface uses generics TInput and TRequirement for flexibility.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GraphemesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nGraphemesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'graphemes';\n  type: 'string';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: IsoWeekIssue Interface Definition\nDESCRIPTION: TypeScript interface definition for ISO week validation issues. Extends BaseIssue with specific properties for handling ISO week validation errors including the kind of error, expected and received values, and validation requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IsoWeekIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IsoWeekIssue<TInput> extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Core Library\nDESCRIPTION: Commands to navigate to library directory and build the core library\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/i18n/README.md#2025-04-09_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ./library && pnpm build\n```\n\n----------------------------------------\n\nTITLE: Using forwardAsync in Valibot TypeScript\nDESCRIPTION: Basic usage syntax of the forwardAsync method which forwards the issues of the passed validation action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/forwardAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.forwardAsync<TInput, TIssue, TPath>(action, path);\n```\n\n----------------------------------------\n\nTITLE: Importing Valibot in Deno using deno.land/x URL\nDESCRIPTION: Examples of importing Valibot directly in Deno using the deno.land/x URL, showing both individual and wildcard import syntax.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(get-started)/installation/index.mdx#2025-04-09_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// With individual imports\nimport { â€¦ } from 'https://deno.land/x/valibot/mod.ts';\n\n// With a wildcard import\nimport * as v from 'https://deno.land/x/valibot/mod.ts';\n```\n\n----------------------------------------\n\nTITLE: Defining SetSchemaAsync Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for SetSchemaAsync that specifies the structure for asynchronous set schema validation. The interface includes generic types for value and message, along with properties for type, reference, expects, value, and message handling.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/SetSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SetSchemaAsync<TValue = unknown, TMessage extends string = string> {\n  type: 'set';\n  reference: 'async';\n  expects: string;\n  value: BaseSchema<TValue>;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BicIssue Interface in TypeScript\nDESCRIPTION: This snippet outlines the structure of the BicIssue interface. It extends BaseIssue and includes additional properties specific to Bic validation issues. The interface is generic, allowing for customization of the input type.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/BicIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface BicIssue<TInput> extends BaseIssue {\n  kind: 'bic';\n  type: 'string';\n  expected: 'valid';\n  received: 'invalid';\n  requirement: 'BIC';\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayInput Type in TypeScript\nDESCRIPTION: This snippet defines the ArrayInput type, which represents an array input for validation purposes. It likely extends or is related to other input types in the valibot library.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ArrayInput/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nArrayInput\n```\n\n----------------------------------------\n\nTITLE: Starting Valibot Website\nDESCRIPTION: Commands to navigate to the website directory and start the Valibot website locally.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/README.md#2025-04-09_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd ../website && pnpm start\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of looseObjectAsync in Valibot\nDESCRIPTION: Basic syntax example of creating a loose object schema with looseObjectAsync that allows for asynchronous validation. It defines the schema with entries and optional error message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/looseObjectAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.looseObjectAsync<TEntries, TMessage>(entries, message);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Configuration in Valibot using TypeScript\nDESCRIPTION: This snippet demonstrates how to use the getGlobalConfig function to retrieve the global configuration in Valibot. It allows for optional merging of custom properties and specifies a generic type for issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/getGlobalConfig/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = v.getGlobalConfig<TIssue>(merge);\n```\n\n----------------------------------------\n\nTITLE: MapSchemaAsync Interface Type Definition\nDESCRIPTION: TypeScript interface definition for MapSchemaAsync that extends BaseSchemaAsync with map-specific properties. It includes generics for key, value, and message types, along with type information and validation properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MapSchemaAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MapSchemaAsync<TKey, TValue, TMessage> extends BaseSchemaAsync {\n  type: 'map';\n  reference: Map<unknown, unknown>;\n  expects: string;\n  key: TKey;\n  value: TValue;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EndsWithIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the EndsWithIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected and received values, and the requirement that was not met.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/EndsWithIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nEndsWithIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'ends_with';\n  type: 'string';\n  expected: 'ends with';\n  received: TInput;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IntegerIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the IntegerIssue interface, which extends BaseIssue. It includes properties specific to integer validation issues such as kind, type, expected value, received value, and requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntegerIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface IntegerIssue<TInput> extends BaseIssue {\n  kind: 'integer';\n  type: 'type';\n  expected: 'integer';\n  received: TInput;\n  requirement?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Specific Error Messages in TypeScript\nDESCRIPTION: Function call to delete a specific error message using Valibot. Takes a reference identifier and language code as parameters to target the specific message to be deleted.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/deleteSpecificMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.deleteSpecificMessage(reference, lang);\n```\n\n----------------------------------------\n\nTITLE: Valibot API Documentation Links\nDESCRIPTION: Markdown list of links to individual API documentation pages for Valibot's validation schemas, actions, issues and utility types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/menu.md#2025-04-09_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- [NeverIssue](/api/NeverIssue/)\n- [NeverSchema](/api/NeverSchema/)\n- [NonEmptyAction](/api/NonEmptyAction/)\n[...remaining links omitted for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Deleting Schema Error Messages in Valibot (TypeScript)\nDESCRIPTION: This function deletes a schema error message for a specified language. It takes a language parameter to determine which message to remove. This is useful for managing localized error messages in schema validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/deleteSchemaMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.deleteSchemaMessage(lang);\n```\n\n----------------------------------------\n\nTITLE: Defining IntersectOptionsAsync Type in TypeScript\nDESCRIPTION: Type definition for IntersectOptionsAsync that specifies options for asynchronous intersection validation. Extends base validation options.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntersectOptionsAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IntersectOptionsAsync = BaseValidationOptionsAsync;\n```\n\n----------------------------------------\n\nTITLE: Defining IntersectIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the IntersectIssue interface, which extends BaseIssue. It includes properties for the kind of issue, the type, and the expected value.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntersectIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nIntersectIssue {\n  kind: 'intersect';\n  type: 'intersection';\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: DigitsIssue Interface Structure Definition\nDESCRIPTION: Interface definition for handling digit validation issues. It extends BaseIssue and includes properties for validation type, expected value, received value, and requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DigitsIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DigitsIssue<TInput> extends BaseIssue {\n  kind: 'digits';\n  type: string;\n  expected: string;\n  received: TInput;\n  requirement: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Login Schema Comparison\nDESCRIPTION: Compares the implementation of a login schema between the proposed pipe function and current API.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// With the new `pipe` function\nconst LoginSchema = object({\n  email: pipe(string(), minLength(1), email()),\n  password: pipe(string(), minLength(8)),\n});\n\n// With Valibot's current API\nconst LoginSchema = object({\n  email: string([minLength(1), email()]),\n  password: string([minLength(8)]),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Global Error Message in Valibot (TypeScript)\nDESCRIPTION: This function sets a global error message in Valibot. It takes two parameters: 'message' for the error message content, and 'lang' for specifying the language of the message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/setGlobalMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.setGlobalMessage(message, lang);\n```\n\n----------------------------------------\n\nTITLE: Creating MaxEntries Validation Action in TypeScript\nDESCRIPTION: Shows the basic syntax for creating a maxEntries validation action. The action takes a requirement parameter and an optional message parameter to customize error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(actions)/maxEntries/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.maxEntries<TInput, TRequirement, TMessage>(\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: PicklistIssue Interface Structure\nDESCRIPTION: Defines the structure of a PicklistIssue interface that extends BaseIssue. It includes properties for kind, type, and expected values used in picklist validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/PicklistIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface PicklistIssue extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LooseTupleIssue Interface Properties in TypeScript\nDESCRIPTION: Interface definition showing the structure of LooseTupleIssue, which extends BaseIssue and includes properties for kind, type, and expected values. This interface is used for handling validation issues with loose tuples.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LooseTupleIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface LooseTupleIssue extends BaseIssue {\n  kind: string;\n  type: string;\n  expected: string;\n}\n```\n\n----------------------------------------\n\nTITLE: HashIssue Interface Properties\nDESCRIPTION: Interface definition specifying the structure for hash validation issues. Extends BaseIssue with properties for kind, type, expected/received values, and requirement details.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/HashIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface HashIssue<TInput> extends BaseIssue {\n  kind: 'hash';\n  type: string;\n  expected: string;\n  received: string;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Methods with Current API\nDESCRIPTION: Illustrates the current API's method nesting requirement when applying multiple transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst LengthSchema = brand(\n  transform(optional(string(), ''), (input) => input.length),\n  'Length'\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Command to install project dependencies using pnpm package manager\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/i18n/README.md#2025-04-09_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Using strictObjectAsync Schema Creation Syntax in TypeScript\nDESCRIPTION: Basic syntax for creating a strict object schema with async validation. This shows the function signature with generics and parameters.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/strictObjectAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.strictObjectAsync<TEntries, TMessage>(entries, message);\n```\n\n----------------------------------------\n\nTITLE: Using partialCheckAsync to Create a Validation Action in TypeScript\nDESCRIPTION: The basic syntax for creating a partial check validation action with partialCheckAsync. This function allows validating parts of an input asynchronously, returning a validation action.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/partialCheckAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.partialCheckAsync<TInput, TPaths, TSelection, TMessage>(\n  paths,\n  requirement,\n  message\n);\n```\n\n----------------------------------------\n\nTITLE: Defining ErrorMessage Generic Type Parameters\nDESCRIPTION: Specifies the type parameter TIssue which represents the issue structure in error messages\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ErrorMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTIssue\n```\n\n----------------------------------------\n\nTITLE: FailureDataset Interface Definition with Generics\nDESCRIPTION: Defines a FailureDataset interface that extends UntypedDataset with a generic TIssue parameter. Contains properties for type information, validation value, and validation issues.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/FailureDataset/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface FailureDataset<TIssue> extends UntypedDataset {\n  typed: boolean;\n  value: unknown;\n  issues: TIssue[];\n}\n```\n\n----------------------------------------\n\nTITLE: NanSchema Interface Structure\nDESCRIPTION: Interface definition for NaN schema with generics and properties including type, reference, expects and message fields. Used for validating NaN values with customizable error messages.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/NanSchema/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NanSchema<TMessage> {\n  type: 'nan';\n  reference: 'NaN';\n  expects: 'NaN';\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: New User Schema with Exact Optional Username Field\nDESCRIPTION: Example schema for validating new user details with an exact optional username field. The email and password are required, while username is optional but must pass validation if provided.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/exactOptionalAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailUnique, isUsernameUnique } from '~/api';\n\nconst NewUserSchema = v.objectAsync({\n  email: v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailUnique, 'The email is not unique.')\n  ),\n  username: v.exactOptionalAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  ),\n  password: v.pipe(v.string(), v.minLength(8)),\n});\n\n/*\n  The input and output types of the schema:\n    {\n      email: string;\n      password: string;\n      username?: string;\n    }\n*/\n```\n\n----------------------------------------\n\nTITLE: Setting Schema Error Messages in Valibot (TypeScript)\nDESCRIPTION: Demonstrates how to use the setSchemaMessage function to set a custom error message for schema validation. The function takes a message parameter for the error text and a lang parameter to specify the language for internationalization.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/setSchemaMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.setSchemaMessage(message, lang);\n```\n\n----------------------------------------\n\nTITLE: ContentRequirement Type Declaration Imports\nDESCRIPTION: Component and property imports for the ContentRequirement documentation\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ContentRequirement/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Defining MaxWordsIssue Interface in TypeScript\nDESCRIPTION: This snippet defines the MaxWordsIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected and received values, and the requirement.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxWordsIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nMaxWordsIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_words';\n  type: 'string';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Ipv6Action Interface in TypeScript\nDESCRIPTION: This snippet defines the Ipv6Action interface, which extends BaseValidation. It includes properties for type, reference, expects, requirement, and message, all related to IPv6 validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Ipv6Action/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nIpv6Action<TInput, TMessage> extends BaseValidation {\n  type: 'ipv6';\n  reference: 'ipv6';\n  expects: 'IPv6 address';\n  requirement: () => boolean;\n  message: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating a Number and Email Tuple with strictTupleAsync in TypeScript\nDESCRIPTION: This example creates a schema to validate a strict tuple with one number and one stored email address. It uses strictTupleAsync along with other Valibot functions for more complex validation.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/strictTupleAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmailPresent } from '~/api';\n\nconst TupleSchema = v.strictTupleAsync([\n  v.number(),\n  v.pipeAsync(\n    v.string(),\n    v.email(),\n    v.checkAsync(isEmailPresent, 'The email is not in the database.')\n  ),\n]);\n```\n\n----------------------------------------\n\nTITLE: Getting Schema Error Message in TypeScript\nDESCRIPTION: Demonstrates how to use the getSchemaMessage function to retrieve a schema error message based on a specified language parameter.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/getSchemaMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst message = v.getSchemaMessage(lang);\n```\n\n----------------------------------------\n\nTITLE: Rendering GlobalConfig Property Component\nDESCRIPTION: JSX/MDX code that renders the GlobalConfig property using the Property component with spread properties.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/GlobalConfig/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n<Property {...properties.GlobalConfig} />\n```\n\n----------------------------------------\n\nTITLE: Mac64Issue Interface Structure\nDESCRIPTION: Type interface definition for representing 64-bit MAC address validation issues. Includes generic input type and required properties for error details.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Mac64Issue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Mac64Issue<TInput> extends BaseIssue {\n  kind: 'mac64';\n  type: 'Input';\n  expected: 'MAC64';\n  received: TInput;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MinWordsAction Interface in TypeScript\nDESCRIPTION: This code snippet defines the MinWordsAction interface, which extends BaseValidation. It includes properties for the validation type, reference, expected value, locales, requirement, and custom message.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MinWordsAction/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nMinWordsAction<TInput, TLocales, TRequirement, TMessage> extends BaseValidation {\n  type: 'min_words';\n  reference: number;\n  expects: TInput;\n  locales?: TLocales;\n  requirement?: TRequirement;\n  message?: TMessage;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Null Unique Username Schema with nonNullableAsync\nDESCRIPTION: Example showing how to use nonNullableAsync to override a nullable schema and validate a unique username. This schema enforces that usernames are non-null strings and checks uniqueness using an external API function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonNullableAsync/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isUsernameUnique } from '~/api';\n\nconst UniqueUsernameSchema = v.nonNullableAsync(\n  // Assume this schema is from a different file and reused here.\n  v.nullableAsync(\n    v.pipeAsync(\n      v.string(),\n      v.nonEmpty(),\n      v.checkAsync(isUsernameUnique, 'The username is not unique.')\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Deleting Global Error Messages in Valibot (TypeScript)\nDESCRIPTION: The deleteGlobalMessage function removes a global error message for a specified language. It takes a language parameter that determines which language's error message will be deleted from Valibot's global error message storage.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(storages)/deleteGlobalMessage/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nv.deleteGlobalMessage(lang);\n```\n\n----------------------------------------\n\nTITLE: Defining HashType in TypeScript\nDESCRIPTION: Defines the HashType type, which is likely used for specifying hash algorithms or formats in the Valibot library. The exact implementation details are not provided in the given content.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/HashType/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nHashType\n```\n\n----------------------------------------\n\nTITLE: Defining MaxEntriesIssue Interface in TypeScript\nDESCRIPTION: This code snippet defines the MaxEntriesIssue interface, which extends BaseIssue. It includes properties for the issue kind, type, expected and received values, and the requirement. The interface is generic, allowing for customization of input and requirement types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/MaxEntriesIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MaxEntriesIssue<TInput, TRequirement> extends BaseIssue {\n  kind: 'max_entries';\n  type: 'object' | 'tuple';\n  expected: number;\n  received: number;\n  requirement: TRequirement;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Nullish Schema with nonNullishAsync in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of nonNullishAsync to create a schema that doesn't allow null or undefined values. It specifies the generic types and parameters for the function.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/nonNullishAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Schema = v.nonNullishAsync<TWrapped, TMessage>(wrapped, message);\n```\n\n----------------------------------------\n\nTITLE: Valibot Type References List in Markdown\nDESCRIPTION: Markdown formatted list of links to Valibot type definitions and schemas, including validation types, action types, issue types, and schema types.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/menu.md#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Types\n\n- [AnySchema](/api/AnySchema/)\n- [ArgsAction](/api/ArgsAction/)\n- [ArgsActionAsync](/api/ArgsActionAsync/)\n[...remaining types truncated for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Rendering ContentInput Property in TSX\nDESCRIPTION: This code renders the ContentInput property using the Property component and spreading the properties.ContentInput object.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ContentInput/index.mdx#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<Property {...properties.ContentInput} />\n```\n\n----------------------------------------\n\nTITLE: Defining Cuid2Issue Interface Structure\nDESCRIPTION: TypeScript interface definition for Cuid2Issue that extends BaseIssue with specific properties for CUID2 validation. It includes properties for validation kind, type, expected and received values, and requirements.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/Cuid2Issue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Cuid2Issue<TInput> extends BaseIssue {\n  kind: 'cuid2';\n  type: TInput;\n  expected: string;\n  received: unknown;\n  requirement: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Raw Check Async Action in TypeScript\nDESCRIPTION: Basic syntax for creating a raw check async validation action with Valibot.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(async)/rawCheckAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Action = v.rawCheckAsync<TInput>(action);\n```\n\n----------------------------------------\n\nTITLE: Using Codemod or Grit for Automatic Upgrade in Bash\nDESCRIPTION: Commands to automatically upgrade Valibot schemas to v0.31.0 using either Codemod or Grit CLI tools. Both codemods perform similar functions to migrate code automatically.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(migration)/migrate-to-v0.31.0/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Codemod\nnpx codemod valibot/migrate-to-v0.31.0\n\n# Grit\nnpx @getgrit/cli apply github.com/fabian-hiller/valibot#migrate_to_v0_31_0\n```\n\n----------------------------------------\n\nTITLE: LastTupleItem Generic Type Parameter\nDESCRIPTION: Defines the TTuple generic type parameter representing the input tuple type from which to extract the last item.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/LastTupleItem/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTTuple\n```\n\n----------------------------------------\n\nTITLE: Interface Definition - DecimalIssue Generics\nDESCRIPTION: Type definition showing the generic parameter TInput for the DecimalIssue interface.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/DecimalIssue/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nDecimalIssue<TInput>\n```\n\n----------------------------------------\n\nTITLE: Converting Valibot String Schema to JSON Schema in JavaScript\nDESCRIPTION: Demonstrates how to use the toJsonSchema function to convert a simple Valibot string schema to JSON Schema.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/packages/to-json-schema/README.md#2025-04-09_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { toJsonSchema } from '@valibot/to-json-schema';\nimport * as v from 'valibot';\n\ntoJsonSchema(v.string()); // { type: \"string\" }\n```\n\n----------------------------------------\n\nTITLE: Pipeline Validation for Record Schema in TypeScript\nDESCRIPTION: Demonstrates pipeline validation for record schemas with conditional value validation and error forwarding.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/guides/(schemas)/objects/index.mdx#2025-04-09_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst CalculationSchema = v.pipe(\n  v.record(v.picklist(['a', 'b', 'sum']), v.number()),\n  v.forward(\n    v.check(\n      ({ a, b, sum }) => (a || 0) + (b || 0) === (sum || 0),\n      'The calculation is incorrect.'\n    ),\n    ['sum']\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Cloning Valibot Repository in Bash\nDESCRIPTION: This snippet demonstrates how to clone the forked Valibot repository to the contributor's local machine using Git. It assumes the contributor has already forked the repository on GitHub.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/CONTRIBUTING.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:your-username/valibot.git\n```\n\n----------------------------------------\n\nTITLE: Importing ObjectEntriesAsync Property Component in TypeScript\nDESCRIPTION: This code snippet imports the Property component and properties object, which are used to display the ObjectEntriesAsync interface definition.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/ObjectEntriesAsync/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Property } from '~/components';\nimport { properties } from './properties';\n```\n\n----------------------------------------\n\nTITLE: Running Valibot Codemods using NPX Command\nDESCRIPTION: This command demonstrates how to run codemods directly from source files using npx as a fallback method when the codemod registry cannot be used. It specifies the source file path and sets the workflow engine.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/codemod/README.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx codemod@latest path-to-source-file.ts --engine=workflow\n```\n\n----------------------------------------\n\nTITLE: Email Schema Validation with Current API\nDESCRIPTION: Demonstrates current API implementation for email validation using string schema with pipeline transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst EmailSchema = string([toTrimmed(), email(), endsWith('@example.com')]);\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access with robots.txt\nDESCRIPTION: Standard robots.txt configuration that allows all web crawlers (*) full access to the website and specifies the location of the sitemap file.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/public/robots.txt#2025-04-09_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-agent: *\nDisallow: \n\nSitemap: https://valibot.dev/sitemap.xml\n```\n\n----------------------------------------\n\nTITLE: Defining IntersectOptions Type Reference\nDESCRIPTION: Documentation showing the IntersectOptions type reference and its property details. This appears to be a type used for configuring intersection operations in the valibot validation library.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/api/(types)/IntersectOptions/index.mdx#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# IntersectOptions\n\nIntersect options type.\n\n## Definition\n\n- `IntersectOptions`\n```\n\n----------------------------------------\n\nTITLE: Changelog Entry Format in Markdown\nDESCRIPTION: Standard format used for documenting version changes in the changelog, showing version number, date, and bulleted list of changes.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/library/CHANGELOG.md#2025-04-09_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## vX.X.X (Month DD, YYYY)\n\n- Add `feature` description\n- Change `component` description\n- Fix `bug` description\n```\n\n----------------------------------------\n\nTITLE: Complex Union Schema Comparison\nDESCRIPTION: Compares implementation of complex union schema between proposed and current API.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/should-we-change-valibots-api/index.mdx#2025-04-09_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// With the new `pipe` function\nconst NumberSchema = pipe(\n  union([pipe(string(), decimal()), pipe(number(), integer())]),\n  transform(Number)\n);\n\n// With Valibot's current API\nconst NumberSchema = transform(\n  union([string([decimal()]), number([integer()])]),\n  Number\n);\n```\n\n----------------------------------------\n\nTITLE: Rendering GitHub Profile Links with JSX in a Valibot Project Page\nDESCRIPTION: JSX code that generates a grid of GitHub profile avatars with links to contributor profiles. The code maps through an array of GitHub usernames to create list items with profile pictures for each contributor.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/src/routes/blog/(posts)/valibot-v0.31.0-is-finally-available/index.mdx#2025-04-09_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n{[\n    'Afsoon',\n    'AlexXanderGrib',\n    'Andarist',\n    'AndreyYolkin',\n    'ariskemper',\n    'colinhacks',\n    'Demivan',\n    'DylanThomasFr',\n    'EltonLobo07',\n    'GabrielHangor',\n    'Hugos68',\n    'IlyaSemenov',\n    'MohammedEsafi',\n    'MrGeniusProgrammer',\n    'Saeris',\n    'Sandros94',\n    'Sec-ant',\n    'alexbit-codemod',\n    'ammarriq',\n    'anuraghazra',\n    'arybitskiy',\n    'bingtsingw',\n    'brandonpittman',\n    'brenelz',\n    'chertik77',\n    'chimame',\n    'christophsturm',\n    'dboune',\n    'devcaeg',\n    'dusty',\n    'fredericoo',\n    'gmaxlev',\n    'homersimpsons',\n    'jansedlon',\n    'jchatard',\n    'joshwashywash',\n    'jsudelko',\n    'juliusmarminge',\n    'kovalchukq',\n    'linkb15',\n    'lukemorton',\n    'macarie',\n    'morgante',\n    'mtt-artis',\n    'mutewinter',\n    'mxdvl',\n    'nakanoasaservice',\n    'naveen-bharathi',\n    'sacrosanctic',\n    'samualtnorman',\n    'saturnonearth',\n    'seren5240',\n    'sillvva',\n    'ssalbdivad',\n    'vladshcherbin',\n    'xcfox',\n    'yudinmaxim',\n    'znycheporuk',\n  ].map((sponsor) => (\n    <li key={sponsor} class=\"!m-0 !p-0\">\n      <a\n        href={`https://github.com/${sponsor}`}\n        target=\"_blank\"\n        rel=\"noreferrer\"\n      >\n        <img\n          width=\"88\"\n          height=\"88\"\n          loading=\"lazy\"\n          src={`https://github.com/${sponsor}.png?size=88`}\n          alt={`GitHub profile picture of @${sponsor}`}\n          class=\"w-9 rounded-full md:w-10 lg:w-11\"\n        />\n      </a>\n    </li>\n  ))}\n```\n\n----------------------------------------\n\nTITLE: Updating Brand and Transform Operations\nDESCRIPTION: Demonstrates migration of brand and transform operations to use the new pipe-based syntax for schema transformations.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/codemod/migrate-to-v0.31.0/README.md#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst BrandedSchema = v.brand(v.string(), 'foo');\nconst TransformedSchema = v.transform(v.string(), (input) => input.length);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as v from 'valibot';\n\nconst BrandedSchema = v.pipe(v.string(), v.brand('foo'));\nconst TransformedSchema = v.pipe(\n  v.string(),\n  v.transform((input) => input.length)\n);\n```\n\n----------------------------------------\n\nTITLE: Cloning Valibot Repository\nDESCRIPTION: Command to clone the Valibot repository from GitHub using SSH.\nSOURCE: https://github.com/fabian-hiller/valibot/blob/main/website/README.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:fabian-hiller/valibot.git\n```"
  }
]