[
  {
    "owner": "modelcontextprotocol",
    "repo": "docs",
    "content": "TITLE: Implementing Chat Client with MCP Tool Integration\nDESCRIPTION: Java code snippet showing the setup of a chat client using Spring AI's ChatClient with MCP tool integration and memory advisor.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_22\n\nLANGUAGE: java\nCODE:\n```\nvar chatClient = chatClientBuilder\n    .defaultSystem(\"You are useful assistant, expert in AI and Java.\")\n    .defaultTools((Object[]) mcpToolAdapter.toolCallbacks())\n    .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Processing with Tool Handling\nDESCRIPTION: Core method for processing user queries through Claude with support for tool calls. Manages the conversation flow between Claude and MCP tools, handling responses and tool executions.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n  async processQuery(query: string): Promise<string> {\n    if (!this.client) {\n      throw new Error(\"Client not connected\");\n    }\n\n    // Initialize messages array with user query\n    let messages: Anthropic.MessageParam[] = [\n      {\n        role: \"user\",\n        content: query,\n      },\n    ];\n\n    // Get available tools\n    const toolsResponse = await this.client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema\n    );\n\n    const availableTools = toolsResponse.tools.map((tool: any) => ({\n      name: tool.name,\n      description: tool.description,\n      input_schema: tool.inputSchema,\n    }));\n\n    const finalText: string[] = [];\n    let currentResponse = await this.anthropic.messages.create({\n      model: \"claude-3-5-sonnet-20241022\",\n      max_tokens: 1000,\n      messages,\n      tools: availableTools,\n    });\n\n    // Process the response and any tool calls\n    while (true) {\n      // Add Claude's response to final text and messages\n      for (const content of currentResponse.content) {\n        if (content.type === \"text\") {\n          finalText.push(content.text);\n        } else if (content.type === \"tool_use\") {\n          const toolName = content.name;\n          const toolArgs = content.input;\n\n          // Execute tool call\n          const result = await this.client.request(\n            {\n              method: \"tools/call\",\n              params: {\n                name: toolName,\n                arguments: toolArgs,\n              },\n            },\n            CallToolResultSchema\n          );\n\n          finalText.push(\n            `[Calling tool ${toolName} with args ${JSON.stringify(toolArgs)}]`\n          );\n\n          // Add Claude's response (including tool use) to messages\n          messages.push({\n            role: \"assistant\",\n            content: currentResponse.content,\n          });\n\n          // Add tool result to messages\n          messages.push({\n            role: \"user\",\n            content: [\n              {\n                type: \"tool_result\",\n                tool_use_id: content.id,\n                content: [\n                  { type: \"text\", text: JSON.stringify(result.content) },\n                ],\n              },\n            ],\n          });\n\n          // Get next response from Claude with tool results\n          currentResponse = await this.anthropic.messages.create({\n            model: \"claude-3-5-sonnet-20241022\",\n            max_tokens: 1000,\n            messages,\n            tools: availableTools,\n          });\n\n          // Add Claude's interpretation of the tool results to final text\n          if (currentResponse.content[0]?.type === \"text\") {\n            finalText.push(currentResponse.content[0].text);\n          }\n\n          // Continue the loop to process any additional tool calls\n          continue;\n        }\n      }\n\n      // If we reach here, there were no tool calls in the response\n      break;\n    }\n\n    return finalText.join(\"\\n\");\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing a Synchronous MCP Server in Java\nDESCRIPTION: Creates a synchronous MCP server with custom configuration, tool/resource/prompt registration, and logging support. This example demonstrates server initialization, capability configuration, and proper resource management.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Create a server with custom configuration\nMcpSyncServer syncServer = McpServer.sync(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(true)     // Enable resource support\n        .tools(true)         // Enable tool support\n        .prompts(true)       // Enable prompt support\n        .logging()           // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nsyncServer.addTool(syncToolSpecification);\nsyncServer.addResource(syncResourceSpecification);\nsyncServer.addPrompt(syncPromptSpecification);\n\n// Send logging notifications\nsyncServer.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Server initialized\")\n    .build());\n\n// Close the server when done\nsyncServer.close();\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using MCP Sync Client in Java\nDESCRIPTION: This snippet demonstrates how to create, configure, and use a synchronous MCP client. It covers initialization, tool listing and execution, resource management, prompt handling, and roots manipulation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Create a sync client with custom configuration\nMcpSyncClient client = McpClient.sync(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)      // Enable roots capability\n        .sampling()       // Enable sampling capability\n        .build())\n    .sampling(request -> new CreateMessageResult(response))\n    .build();\n\n// Initialize connection\nclient.initialize();\n\n// List available tools\nListToolsResult tools = client.listTools();\n\n// Call a tool\nCallToolResult result = client.callTool(\n    new CallToolRequest(\"calculator\", \n        Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3))\n);\n\n// List and read resources\nListResourcesResult resources = client.listResources();\nReadResourceResult resource = client.readResource(\n    new ReadResourceRequest(\"resource://uri\")\n);\n\n// List and use prompts\nListPromptsResult prompts = client.listPrompts();\nGetPromptResult prompt = client.getPrompt(\n    new GetPromptRequest(\"greeting\", Map.of(\"name\", \"Spring\"))\n);\n\n// Add/remove roots\nclient.addRoot(new Root(\"file:///path\", \"description\"));\nclient.removeRoot(\"file:///path\");\n\n// Close client\nclient.closeGracefully();\n```\n\n----------------------------------------\n\nTITLE: Query Processing Implementation\nDESCRIPTION: Method for processing user queries, handling tool calls, and managing Claude responses\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nasync processQuery(query: string) {\n  const messages: MessageParam[] = [\n    {\n      role: \"user\",\n      content: query,\n    },\n  ];\n\n  const response = await this.anthropic.messages.create({\n    model: \"claude-3-5-sonnet-20241022\",\n    max_tokens: 1000,\n    messages,\n    tools: this.tools,\n  });\n\n  const finalText = [];\n  const toolResults = [];\n\n  for (const content of response.content) {\n    if (content.type === \"text\") {\n      finalText.push(content.text);\n    } else if (content.type === \"tool_use\") {\n      const toolName = content.name;\n      const toolArgs = content.input as { [x: string]: unknown } | undefined;\n\n      const result = await this.mcp.callTool({\n        name: toolName,\n        arguments: toolArgs,\n      });\n      toolResults.push(result);\n      finalText.push(\n        `[Calling tool ${toolName} with args ${JSON.stringify(toolArgs)}]`\n      );\n\n      messages.push({\n        role: \"user\",\n        content: result.content as string,\n      });\n\n      const response = await this.anthropic.messages.create({\n        model: \"claude-3-5-sonnet-20241022\",\n        max_tokens: 1000,\n        messages,\n      });\n\n      finalText.push(\n        response.content[0].type === \"text\" ? response.content[0].text : \"\"\n      );\n    }\n  }\n\n  return finalText.join(\"\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using MCP Async Client in Java\nDESCRIPTION: This snippet shows how to create, configure, and use an asynchronous MCP client. It covers initialization, tool execution, resource and prompt handling, and roots management using reactive programming patterns.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Create an async client with custom configuration\nMcpAsyncClient client = McpClient.async(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)      // Enable roots capability\n        .sampling()       // Enable sampling capability\n        .build())\n    .sampling(request -> Mono.just(new CreateMessageResult(response)))\n    .toolsChangeConsumer(tools -> Mono.fromRunnable(() -> {\n        logger.info(\"Tools updated: {}\", tools);\n    }))\n    .resourcesChangeConsumer(resources -> Mono.fromRunnable(() -> {\n        logger.info(\"Resources updated: {}\", resources);\n    }))\n    .promptsChangeConsumer(prompts -> Mono.fromRunnable(() -> {\n        logger.info(\"Prompts updated: {}\", prompts);\n    }))\n    .build();\n\n// Initialize connection and use features\nclient.initialize()\n    .flatMap(initResult -> client.listTools())\n    .flatMap(tools -> {\n        return client.callTool(new CallToolRequest(\n            \"calculator\", \n            Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3)\n        ));\n    })\n    .flatMap(result -> {\n        return client.listResources()\n            .flatMap(resources -> \n                client.readResource(new ReadResourceRequest(\"resource://uri\"))\n            );\n    })\n    .flatMap(resource -> {\n        return client.listPrompts()\n            .flatMap(prompts ->\n                client.getPrompt(new GetPromptRequest(\n                    \"greeting\", \n                    Map.of(\"name\", \"Spring\")\n                ))\n            );\n    })\n    .flatMap(prompt -> {\n        return client.addRoot(new Root(\"file:///path\", \"description\"))\n            .then(client.removeRoot(\"file:///path\"));            \n    })\n    .doFinally(signalType -> {\n        client.closeGracefully().subscribe();\n    })\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Class in Python\nDESCRIPTION: This Python code defines the Session class which handles request/response patterns and notification handling within the MCP protocol layer.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Session(BaseSession[RequestT, NotificationT, ResultT]):\n    async def send_request(\n        self,\n        request: RequestT,\n        result_type: type[Result]\n    ) -> Result:\n        \"\"\"\n        Send request and wait for response. Raises McpError if response contains error.\n        \"\"\"\n        # Request handling implementation\n\n    async def send_notification(\n        self,\n        notification: NotificationT\n    ) -> None:\n        \"\"\"Send one-way notification that doesn't expect response.\"\"\"\n        # Notification handling implementation\n\n    async def _received_request(\n        self,\n        responder: RequestResponder[ReceiveRequestT, ResultT]\n    ) -> None:\n        \"\"\"Handle incoming request from other side.\"\"\"\n        # Request handling implementation\n\n    async def _received_notification(\n        self,\n        notification: ReceiveNotificationT\n    ) -> None:\n        \"\"\"Handle incoming notification from other side.\"\"\"\n        # Notification handling implementation\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server Connection Method\nDESCRIPTION: Method for connecting to an MCP server, determining whether it's Python or Node.js, initializing the transport layer, and listing available tools.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n  async connectToServer(serverScriptPath: string): Promise<void> {\n    const isPython = serverScriptPath.endsWith(\".py\");\n    const isJs = serverScriptPath.endsWith(\".js\");\n\n    if (!isPython && !isJs) {\n      throw new Error(\"Server script must be a .py or .js file\");\n    }\n\n    const command = isPython ? \"python\" : \"node\";\n\n    this.transport = new StdioClientTransport({\n      command,\n      args: [serverScriptPath],\n    });\n\n    this.client = new Client(\n      {\n        name: \"mcp-client\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    await this.client.connect(this.transport);\n\n    // List available tools\n    const response = await this.client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema\n    );\n\n    console.log(\n      \"\\nConnected to server with tools:\",\n      response.tools.map((tool: any) => tool.name)\n    );\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing an Asynchronous MCP Server in Java\nDESCRIPTION: Creates an asynchronous MCP server with custom configuration, reactive tool/resource/prompt registration, and logging support. This implementation uses reactive patterns for non-blocking operations and includes success callbacks.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Create an async server with custom configuration\nMcpAsyncServer asyncServer = McpServer.async(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(true)     // Enable resource support\n        .tools(true)         // Enable tool support\n        .prompts(true)       // Enable prompt support\n        .logging()           // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nasyncServer.addTool(asyncToolSpecification)\n    .doOnSuccess(v -> logger.info(\"Tool registered\"))\n    .subscribe();\n\nasyncServer.addResource(asyncResourceSpecification)\n    .doOnSuccess(v -> logger.info(\"Resource registered\"))\n    .subscribe();\n\nasyncServer.addPrompt(asyncPromptSpecification)\n    .doOnSuccess(v -> logger.info(\"Prompt registered\"))\n    .subscribe();\n\n// Send logging notifications\nasyncServer.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Server initialized\")\n    .build());\n\n// Close the server when done\nasyncServer.close()\n    .doOnSuccess(v -> logger.info(\"Server closed\"))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Using MCP Client for Tool Execution in Java\nDESCRIPTION: This snippet demonstrates how to use MCP clients to list available tools and execute them with specific parameters, using both synchronous and asynchronous APIs.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n// List available tools and their names\nvar tools = client.listTools();\ntools.forEach(tool -> System.out.println(tool.getName()));\n\n// Execute a tool with parameters\nvar result = client.callTool(\"calculator\", Map.of(\n    \"operation\", \"add\",\n    \"a\", 1,\n    \"b\", 2\n));\n```\n\nLANGUAGE: java\nCODE:\n```\n// List available tools asynchronously\nclient.listTools()\n    .doOnNext(tools -> tools.forEach(tool -> \n        System.out.println(tool.getName())))\n    .subscribe();\n\n// Execute a tool asynchronously\nclient.callTool(\"calculator\", Map.of(\n        \"operation\", \"add\",\n        \"a\", 1,\n        \"b\", 2\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Processing Queries and Handling Tool Calls in Kotlin\nDESCRIPTION: Implements the core functionality for processing user queries, interacting with the Anthropic API, and handling tool calls. It manages message creation, tool execution, and response generation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_27\n\nLANGUAGE: kotlin\nCODE:\n```\nprivate val messageParamsBuilder: MessageCreateParams.Builder = MessageCreateParams.builder()\n    .model(Model.CLAUDE_3_5_SONNET_20241022)\n    .maxTokens(1024)\n\nsuspend fun processQuery(query: String): String {\n    val messages = mutableListOf(\n        MessageParam.builder()\n            .role(MessageParam.Role.USER)\n            .content(query)\n            .build()\n    )\n\n    val response = anthropic.messages().create(\n        messageParamsBuilder\n            .messages(messages)\n            .tools(tools)\n            .build()\n    )\n\n    val finalText = mutableListOf<String>()\n    response.content().forEach { content ->\n        when {\n            content.isText() -> finalText.add(content.text().getOrNull()?.text() ?: \"\")\n\n            content.isToolUse() -> {\n                val toolName = content.toolUse().get().name()\n                val toolArgs =\n                    content.toolUse().get()._input().convert(object : TypeReference<Map<String, JsonValue>>() {})\n\n                val result = mcp.callTool(\n                    name = toolName,\n                    arguments = toolArgs ?: emptyMap()\n                )\n                finalText.add(\"[Calling tool $toolName with args $toolArgs]\")\n\n                messages.add(\n                    MessageParam.builder()\n                        .role(MessageParam.Role.USER)\n                        .content(\n                            \"\"\"\n                                \"type\": \"tool_result\",\n                                \"tool_name\": $toolName,\n                                \"result\": ${result?.content?.joinToString(\"\\n\") { (it as TextContent).text ?: \"\" }}\n                            \"\"\".trimIndent()\n                        )\n                        .build()\n                )\n\n                val aiResponse = anthropic.messages().create(\n                    messageParamsBuilder\n                        .messages(messages)\n                        .build()\n                )\n\n                finalText.add(aiResponse.content().first().text().getOrNull()?.text() ?: \"\")\n            }\n        }\n    }\n\n    return finalText.joinToString(\"\\n\", prefix = \"\", postfix = \"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Connection for MCP Client in Python\nDESCRIPTION: Method to connect to an MCP server, supporting both Python and Node.js servers. This handles script validation, initializes communication channels, and lists available tools from the server.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def connect_to_server(self, server_script_path: str):\n    \"\"\"Connect to an MCP server\n\n    Args:\n        server_script_path: Path to the server script (.py or .js)\n    \"\"\"\n    is_python = server_script_path.endswith('.py')\n    is_js = server_script_path.endswith('.js')\n    if not (is_python or is_js):\n        raise ValueError(\"Server script must be a .py or .js file\")\n\n    command = \"python\" if is_python else \"node\"\n    server_params = StdioServerParameters(\n        command=command,\n        args=[server_script_path],\n        env=None\n    )\n\n    stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))\n    self.stdio, self.write = stdio_transport\n    self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))\n\n    await self.session.initialize()\n\n    # List available tools\n    response = await self.session.list_tools()\n    tools = response.tools\n    print(\"\\nConnected to server with tools:\", [tool.name for tool in tools])\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Sampling Server in Java MCP\nDESCRIPTION: Implementation of an asynchronous server with AI sampling capabilities using reactive programming patterns.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_15\n\nLANGUAGE: java\nCODE:\n```\nMcpAsyncServer server = McpServer.async(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .build();\n\nvar calculatorTool = new McpServerFeatures.AsyncToolSpecification(\n    new Tool(\"ai-calculator\", \"Performs calculations using AI\", schema),\n    (exchange, arguments) -> {\n        if (exchange.getClientCapabilities().sampling() == null) {\n            return Mono.just(new CallToolResult(\"Client does not support AI capabilities\", false));\n        }\n        \n        McpSchema.CreateMessageRequest request = McpSchema.CreateMessageRequest.builder()\n            .content(new McpSchema.TextContent(\"Calculate: \" + arguments.get(\"expression\")))\n            .modelPreferences(McpSchema.ModelPreferences.builder()\n                .hints(List.of(\n                    McpSchema.ModelHint.of(\"claude-3-sonnet\"),\n                    McpSchema.ModelHint.of(\"claude\")\n                ))\n                .intelligencePriority(0.8)\n                .speedPriority(0.5)\n                .build())\n            .systemPrompt(\"You are a helpful calculator assistant. Provide only the numerical answer.\")\n            .maxTokens(100)\n            .build();\n        \n        return exchange.createMessage(request)\n            .map(result -> {\n                String answer = result.content().text();\n                return new CallToolResult(answer, false);\n            });\n    }\n);\n\nserver.addTool(calculatorTool)\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Chat Interface\nDESCRIPTION: Methods for creating an interactive chat loop using Node's readline interface, handling user queries, and providing a clean shutdown process.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n  async chatLoop(): Promise<void> {\n    console.log(\"\\nMCP Client Started!\");\n    console.log(\"Type your queries or 'quit' to exit.\");\n\n    // Using Node's readline for console input\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    const askQuestion = () => {\n      rl.question(\"\\nQuery: \", async (query: string) => {\n        try {\n          if (query.toLowerCase() === \"quit\") {\n            await this.cleanup();\n            rl.close();\n            return;\n          }\n\n          const response = await this.processQuery(query);\n          console.log(\"\\n\" + response);\n          askQuestion();\n        } catch (error) {\n          console.error(\"\\nError:\", error);\n          askQuestion();\n        }\n      });\n    };\n\n    askQuestion();\n  }\n\n  async cleanup(): Promise<void> {\n    if (this.transport) {\n      await this.transport.close();\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Resource Specification in Java MCP\nDESCRIPTION: Implementation of an asynchronous resource specification using reactive programming for handling resource requests.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_11\n\nLANGUAGE: java\nCODE:\n```\nvar asyncResourceSpecification = new McpServerFeatures.asyncResourceSpecification(\n    new Resource(\"custom://resource\", \"name\", \"description\", \"mime-type\", null),\n    (exchange, request) -> {\n        // Resource read implementation\n        return Mono.just(new ReadResourceResult(contents));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Sync Resource Specification in Java MCP\nDESCRIPTION: Implementation of a synchronous resource specification with handler function for providing context data to AI models.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nvar syncResourceSpecification = new McpServerFeatures.syncResourceSpecification(\n    new Resource(\"custom://resource\", \"name\", \"description\", \"mime-type\", null),\n    (exchange, request) -> {\n        // Resource read implementation\n        return new ReadResourceResult(contents);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Prompt Template Operations in Java\nDESCRIPTION: Demonstrates asynchronous API calls using reactive programming patterns for listing prompt templates and executing prompts. Shows non-blocking operations for template listing and prompt execution with parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_7\n\nLANGUAGE: java\nCODE:\n```\n// List available prompt templates asynchronously\nclient.listPrompts()\n    .doOnNext(prompts -> prompts.forEach(prompt -> \n        System.out.println(prompt.getName())))\n    .subscribe();\n\n// Execute a prompt template asynchronously\nclient.executePrompt(\"echo\", Map.of(\n        \"text\", \"Hello, World!\"\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server Tools in Python\nDESCRIPTION: Example of implementing a basic calculation tool in an MCP server using Python, including tool listing and execution handlers.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\n@app.list_tools()\nasync def list_tools() -> list[types.Tool]:\n    return [\n        types.Tool(\n            name=\"calculate_sum\",\n            description=\"Add two numbers together\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"a\": {\"type\": \"number\"},\n                    \"b\": {\"type\": \"number\"}\n                },\n                \"required\": [\"a\", \"b\"]\n            }\n        )\n    ]\n\n@app.call_tool()\nasync def call_tool(\n    name: str,\n    arguments: dict\n) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:\n    if name == \"calculate_sum\":\n        a = arguments[\"a\"]\n        b = arguments[\"b\"]\n        result = a + b\n        return [types.TextContent(type=\"text\", text=str(result))]\n    raise ValueError(f\"Tool not found: {name}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server in Python\nDESCRIPTION: This Python example shows how to implement a basic MCP server using stdio transport, including server creation, resource listing function, and connection handling.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport mcp.types as types\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\napp = Server(\"example-server\")\n\n@app.list_resources()\nasync def list_resources() -> list[types.Resource]:\n    return [\n        types.Resource(\n            uri=\"example://resource\",\n            name=\"Example Resource\"\n        )\n    ]\n\nasync def main():\n    async with stdio_server() as streams:\n        await app.run(\n            streams[0],\n            streams[1],\n            app.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Sync Prompt Specification in Java MCP\nDESCRIPTION: Implementation of a synchronous prompt specification with argument definitions and handler for processing prompt requests.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_12\n\nLANGUAGE: java\nCODE:\n```\nvar syncPromptSpecification = new McpServerFeatures.syncPromptSpecification(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    (exchange, request) -> {\n        // Prompt implementation\n        return new GetPromptResult(description, messages);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Declaring Roots in MCP Client Configuration\nDESCRIPTION: This JSON snippet demonstrates how an MCP client typically exposes roots to a server. It defines two roots: a local frontend repository and an API endpoint, each with a URI and descriptive name.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/roots.mdx#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"roots\": [\n    {\n      \"uri\": \"file:///home/user/projects/frontend\",\n      \"name\": \"Frontend Repository\"\n    },\n    {\n      \"uri\": \"https://api.example.com/v1\",\n      \"name\": \"API Endpoint\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server in TypeScript\nDESCRIPTION: This TypeScript example demonstrates how to implement a basic MCP server using stdio transport, including server initialization, request handling, and transport connection.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    resources: {}\n  }\n});\n\n// Handle requests\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: \"example://resource\",\n        name: \"Example Resource\"\n      }\n    ]\n  };\n});\n\n// Connect transport\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Implementing Sync Tool Specification in Java MCP\nDESCRIPTION: Implementation of a synchronous calculator tool specification using Java SDK for Model Context Protocol. Includes JSON schema definition for operation parameters and tool handler implementation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nvar schema = \"\"\"\n            {\n              \"type\" : \"object\",\n              \"id\" : \"urn:jsonschema:Operation\",\n              \"properties\" : {\n                \"operation\" : {\n                  \"type\" : \"string\"\n                },\n                \"a\" : {\n                  \"type\" : \"number\"\n                },\n                \"b\" : {\n                  \"type\" : \"number\"\n                }\n              }\n            }\n            \"\"\";\nvar syncToolSpecification = new McpServerFeatures.SyncToolSpecification(\n    new Tool(\"calculator\", \"Basic calculator\", schema),\n    (exchange, arguments) -> {\n        // Tool implementation\n        return new CallToolResult(result, false);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Transport in Python (Server)\nDESCRIPTION: Demonstrates how to set up a server using the Server-Sent Events (SSE) transport in Python. This enables server-to-client streaming with HTTP POST requests for client-to-server communication in a Python environment.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.server.sse import SseServerTransport\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\n\napp = Server(\"example-server\")\nsse = SseServerTransport(\"/messages\")\n\nasync def handle_sse(scope, receive, send):\n    async with sse.connect_sse(scope, receive, send) as streams:\n        await app.run(streams[0], streams[1], app.create_initialization_options())\n\nasync def handle_messages(scope, receive, send):\n    await sse.handle_post_message(scope, receive, send)\n\nstarlette_app = Starlette(\n    routes=[\n        Route(\"/sse\", endpoint=handle_sse),\n        Route(\"/messages\", endpoint=handle_messages, methods=[\"POST\"]),\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Processing Logic with Tool Calls in Python\nDESCRIPTION: Core function for processing user queries using Claude and executing tool calls. This handles the complete conversation flow, including sending queries to Claude, processing tool calls, and handling tool responses.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def process_query(self, query: str) -> str:\n    \"\"\"Process a query using Claude and available tools\"\"\"\n    messages = [\n        {\n            \"role\": \"user\",\n            \"content\": query\n        }\n    ]\n\n    response = await self.session.list_tools()\n    available_tools = [{\n        \"name\": tool.name,\n        \"description\": tool.description,\n        \"input_schema\": tool.inputSchema\n    } for tool in response.tools]\n\n    # Initial Claude API call\n    response = self.anthropic.messages.create(\n        model=\"claude-3-5-sonnet-20241022\",\n        max_tokens=1000,\n        messages=messages,\n        tools=available_tools\n    )\n\n    # Process response and handle tool calls\n    final_text = []\n\n    assistant_message_content = []\n    for content in response.content:\n        if content.type == 'text':\n            final_text.append(content.text)\n            assistant_message_content.append(content)\n        elif content.type == 'tool_use':\n            tool_name = content.name\n            tool_args = content.input\n\n            # Execute tool call\n            result = await self.session.call_tool(tool_name, tool_args)\n            final_text.append(f\"[Calling tool {tool_name} with args {tool_args}]\")\n\n            assistant_message_content.append(content)\n            messages.append({\n                \"role\": \"assistant\",\n                \"content\": assistant_message_content\n            })\n            messages.append({\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": content.id,\n                        \"content\": result.content\n                    }\n                ]\n            })\n\n            # Get next response from Claude\n            response = self.anthropic.messages.create(\n                model=\"claude-3-5-sonnet-20241022\",\n                max_tokens=1000,\n                messages=messages,\n                tools=available_tools\n            )\n\n            final_text.append(response.content[0].text)\n\n    return \"\\n\".join(final_text)\n```\n\n----------------------------------------\n\nTITLE: Complete TypeScript Implementation of MCP Prompts Server\nDESCRIPTION: A complete example showing how to implement prompts functionality in an MCP server using TypeScript, including handling prompts/list and prompts/get requests.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema\n} from \"@modelcontextprotocol/sdk/types\";\n\nconst PROMPTS = {\n  \"git-commit\": {\n    name: \"git-commit\",\n    description: \"Generate a Git commit message\",\n    arguments: [\n      {\n        name: \"changes\",\n        description: \"Git diff or description of changes\",\n        required: true\n      }\n    ]\n  },\n  \"explain-code\": {\n    name: \"explain-code\",\n    description: \"Explain how code works\",\n    arguments: [\n      {\n        name: \"code\",\n        description: \"Code to explain\",\n        required: true\n      },\n      {\n        name: \"language\",\n        description: \"Programming language\",\n        required: false\n      }\n    ]\n  }\n};\n\nconst server = new Server({\n  name: \"example-prompts-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    prompts: {}\n  }\n});\n\n// List available prompts\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  return {\n    prompts: Object.values(PROMPTS)\n  };\n});\n\n// Get specific prompt\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  const prompt = PROMPTS[request.params.name];\n  if (!prompt) {\n    throw new Error(`Prompt not found: ${request.params.name}`);\n  }\n\n  if (request.params.name === \"git-commit\") {\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Generate a concise but descriptive commit message for these changes:\\n\\n${request.params.arguments?.changes}`\n          }\n        }\n      ]\n    };\n  }\n\n  if (request.params.name === \"explain-code\") {\n    const language = request.params.arguments?.language || \"Unknown\";\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Explain how this ${language} code works:\\n\\n${request.params.arguments?.code}`\n          }\n        }\n      ]\n    };\n  }\n\n  throw new Error(\"Prompt implementation not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Server Capabilities in Java\nDESCRIPTION: Configures various capabilities for the MCP server, including resource, tool, and prompt support with list changes notifications, as well as enabling logging functionality. These settings define the core functionality available to clients.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nvar capabilities = ServerCapabilities.builder()\n    .resources(false, true)  // Resource support with list changes notifications\n    .tools(true)            // Tool support with list changes notifications\n    .prompts(true)          // Prompt support with list changes notifications\n    .logging()              // Enable logging support (enabled by default with logging level INFO)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Resources in Python Server\nDESCRIPTION: Shows a Python implementation of an MCP server with resource support, featuring resource listing and content reading using decorators for request handling.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\n@app.list_resources()\nasync def list_resources() -> list[types.Resource]:\n    return [\n        types.Resource(\n            uri=\"file:///logs/app.log\",\n            name=\"Application Logs\",\n            mimeType=\"text/plain\"\n        )\n    ]\n\n@app.read_resource()\nasync def read_resource(uri: AnyUrl) -> str:\n    if str(uri) == \"file:///logs/app.log\":\n        log_contents = await read_log_file()\n        return log_contents\n\n    raise ValueError(\"Resource not found\")\n\n# Start server\nasync with stdio_server() as streams:\n    await app.run(\n        streams[0],\n        streams[1],\n        app.create_initialization_options()\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Stdio Transport in TypeScript (Server)\nDESCRIPTION: Demonstrates how to set up a server using the stdio transport in TypeScript. This allows communication through standard input and output streams, useful for local integrations and command-line tools.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Client Capabilities in Java\nDESCRIPTION: This snippet shows how to configure client capabilities, including roots support and sampling. It also demonstrates how to add and remove roots, and set up a sampling handler.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nvar capabilities = ClientCapabilities.builder()\n    .roots(true)      // Enable filesystem roots support with list changes notifications\n    .sampling()       // Enable LLM sampling support\n    .build();\n\n// Add a root dynamically\nclient.addRoot(new Root(\"file:///path\", \"description\"));\n\n// Remove a root\nclient.removeRoot(\"file:///path\");\n\n// Notify server of roots changes\nclient.rootsListChangedNotification();\n\n// Configure sampling handler\nFunction<CreateMessageRequest, CreateMessageResult> samplingHandler = request -> {\n    // Sampling implementation that interfaces with LLM\n    return new CreateMessageResult(response);\n};\n\n// Create client with sampling support\nvar client = McpClient.sync(transport)\n    .capabilities(ClientCapabilities.builder()\n        .sampling()\n        .build())\n    .sampling(samplingHandler)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Resources in TypeScript Server\nDESCRIPTION: Demonstrates a complete TypeScript example of implementing resource support in an MCP server, including server initialization, resource listing, and content reading.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    resources: {}\n  }\n});\n\n// List available resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: \"file:///logs/app.log\",\n        name: \"Application Logs\",\n        mimeType: \"text/plain\"\n      }\n    ]\n  };\n});\n\n// Read resource contents\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  const uri = request.params.uri;\n\n  if (uri === \"file:///logs/app.log\") {\n    const logContents = await readLogFile();\n    return {\n      contents: [\n        {\n          uri,\n          mimeType: \"text/plain\",\n          text: logContents\n        }\n      ]\n    };\n  }\n\n  throw new Error(\"Resource not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Client-Server Architecture using Mermaid\nDESCRIPTION: A flowchart diagram showing the core MCP architecture where a host application connects to multiple MCP servers, which in turn connect to local data sources and remote services. Demonstrates the relationship between hosts, clients, servers, and data sources.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/introduction.mdx#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    subgraph \"Your Computer\"\n        Host[\"Host with MCP Client\\n(Claude, IDEs, Tools)\"]\n        S1[\"MCP Server A\"]\n        S2[\"MCP Server B\"]\n        S3[\"MCP Server C\"]\n        Host <-->|\"MCP Protocol\"| S1\n        Host <-->|\"MCP Protocol\"| S2\n        Host <-->|\"MCP Protocol\"| S3\n        S1 <--> D1[(\"Local\\nData Source A\")]\n        S2 <--> D2[(\"Local\\nData Source B\")]\n    end\n    subgraph \"Internet\"\n        S3 <-->|\"Web APIs\"| D3[(\"Remote\\nService C\")]\n    end\n```\n\n----------------------------------------\n\nTITLE: TypeScript Response Schema for Resource Content\nDESCRIPTION: Defines the response schema when reading resources, allowing for both text and binary (base64 encoded) resource types with appropriate metadata.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  contents: [\n    {\n      uri: string;        // The URI of the resource\n      mimeType?: string;  // Optional MIME type\n\n      // One of:\n      text?: string;      // For text resources\n      blob?: string;      // For binary resources (base64 encoded)\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Python Implementation of MCP Prompts Server\nDESCRIPTION: A complete example showing how to implement prompts functionality in an MCP server using Python, including handling prompts/list and prompts/get requests.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.server import Server\nimport mcp.types as types\n\n# Define available prompts\nPROMPTS = {\n    \"git-commit\": types.Prompt(\n        name=\"git-commit\",\n        description=\"Generate a Git commit message\",\n        arguments=[\n            types.PromptArgument(\n                name=\"changes\",\n                description=\"Git diff or description of changes\",\n                required=True\n            )\n        ],\n    ),\n    \"explain-code\": types.Prompt(\n        name=\"explain-code\",\n        description=\"Explain how code works\",\n        arguments=[\n            types.PromptArgument(\n                name=\"code\",\n                description=\"Code to explain\",\n                required=True\n            ),\n            types.PromptArgument(\n                name=\"language\",\n                description=\"Programming language\",\n                required=False\n            )\n        ],\n    )\n}\n\n# Initialize server\napp = Server(\"example-prompts-server\")\n\n@app.list_prompts()\nasync def list_prompts() -> list[types.Prompt]:\n    return list(PROMPTS.values())\n\n@app.get_prompt()\nasync def get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> types.GetPromptResult:\n    if name not in PROMPTS:\n        raise ValueError(f\"Prompt not found: {name}\")\n\n    if name == \"git-commit\":\n        changes = arguments.get(\"changes\") if arguments else \"\"\n        return types.GetPromptResult(\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"Generate a concise but descriptive commit message \"\n                        f\"for these changes:\\n\\n{changes}\"\n                    )\n                )\n            ]\n        )\n\n    if name == \"explain-code\":\n        code = arguments.get(\"code\") if arguments else \"\"\n        language = arguments.get(\"language\", \"Unknown\") if arguments else \"Unknown\"\n        return types.GetPromptResult(\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"Explain how this {language} code works:\\n\\n{code}\"\n                    )\n                )\n            ]\n        )\n\n    raise ValueError(\"Prompt implementation not found\")\n```\n\n----------------------------------------\n\nTITLE: Main Entry Point for MCP Client in Kotlin\nDESCRIPTION: Implements the main execution function for the MCP client. It handles command-line arguments, initializes the client, connects to the server, and starts the chat loop.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_29\n\nLANGUAGE: kotlin\nCODE:\n```\nfun main(args: Array<String>) = runBlocking {\n    if (args.isEmpty()) throw IllegalArgumentException(\"Usage: java -jar <your_path>/build/libs/kotlin-mcp-client-0.1.0-all.jar <path_to_server_script>\")\n    val serverPath = args.first()\n    val client = MCPClient()\n    client.use {\n        client.connectToServer(serverPath)\n        client.chatLoop()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Tool Specification in Java MCP\nDESCRIPTION: Implementation of an asynchronous calculator tool specification using reactive programming patterns. Defines schema and handler for async tool operations.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nvar schema = \"\"\"\n            {\n              \"type\" : \"object\",\n              \"id\" : \"urn:jsonschema:Operation\",\n              \"properties\" : {\n                \"operation\" : {\n                  \"type\" : \"string\"\n                },\n                \"a\" : {\n                  \"type\" : \"number\"\n                },\n                \"b\" : {\n                  \"type\" : \"number\"\n                }\n              }\n            }\n            \"\"\";\nvar asyncToolSpecification = new McpServerFeatures.AsyncToolSpecification(\n    new Tool(\"calculator\", \"Basic calculator\", schema),\n    (exchange, arguments) -> {\n        // Tool implementation\n        return Mono.just(new CallToolResult(result, false));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring WebFlux SSE Transport Provider for MCP Server in Java\nDESCRIPTION: Implements the Spring WebFlux-based SSE server transport for MCP server. This configuration requires the mcp-spring-webflux dependency and provides reactive HTTP streaming with WebFlux for concurrent client connections.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\nclass McpConfig {\n    @Bean\n    WebFluxSseServerTransportProvider webFluxSseServerTransportProvider(ObjectMapper mapper) {\n        return new WebFluxSseServerTransportProvider(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction<?> mcpRouterFunction(WebFluxSseServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Layer in TypeScript\nDESCRIPTION: This code defines the Protocol class in TypeScript which handles message framing, request/response linking and high-level communication patterns in MCP.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass Protocol<Request, Notification, Result> {\n    // Handle incoming requests\n    setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void\n\n    // Handle incoming notifications\n    setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void\n\n    // Send requests and await responses\n    request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>\n\n    // Send one-way notifications\n    notification(notification: Notification): Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Prompt Template Operations in Java\nDESCRIPTION: Demonstrates synchronous API calls for listing available prompt templates and executing a specific template with parameters. Shows how to retrieve template names and execute the 'echo' prompt with a text parameter.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n// List available prompt templates\nvar prompts = client.listPrompts();\nprompts.forEach(prompt -> System.out.println(prompt.getName()));\n\n// Execute a prompt template with parameters\nvar response = client.executePrompt(\"echo\", Map.of(\n    \"text\", \"Hello, World!\"\n));\n```\n\n----------------------------------------\n\nTITLE: MCP Client Base Class Implementation\nDESCRIPTION: Core TypeScript implementation of the MCP client class with imports and initialization\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Anthropic } from \"@anthropic-ai/sdk\";\nimport {\n  MessageParam,\n  Tool,\n} from \"@anthropic-ai/sdk/resources/messages/messages.mjs\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport readline from \"readline/promises\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;\nif (!ANTHROPIC_API_KEY) {\n  throw new Error(\"ANTHROPIC_API_KEY is not set\");\n}\n\nclass MCPClient {\n  private mcp: Client;\n  private anthropic: Anthropic;\n  private transport: StdioClientTransport | null = null;\n  private tools: Tool[] = [];\n\n  constructor() {\n    this.anthropic = new Anthropic({\n      apiKey: ANTHROPIC_API_KEY,\n    });\n    this.mcp = new Client({ name: \"mcp-client-cli\", version: \"1.0.0\" });\n  }\n  // methods will go here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server Tools in TypeScript\nDESCRIPTION: Example of implementing a basic calculation tool in an MCP server using TypeScript, including tool listing and execution handlers.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    tools: {}\n  }\n});\n\n// Define available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: [{\n      name: \"calculate_sum\",\n      description: \"Add two numbers together\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          a: { type: \"number\" },\n          b: { type: \"number\" }\n        },\n        required: [\"a\", \"b\"]\n      }\n    }]\n  };\n});\n\n// Handle tool execution\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  if (request.params.name === \"calculate_sum\") {\n    const { a, b } = request.params.arguments;\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: String(a + b)\n        }\n      ]\n    };\n  }\n  throw new Error(\"Tool not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Resource URI Structure in MCP\nDESCRIPTION: Demonstrates the standard format for resource URIs in Model Context Protocol, showing the protocol, host, and path components with examples for different types of resources.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n[protocol]://[host]/[path]\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Client Class with TypeScript\nDESCRIPTION: Basic implementation of the MCPClient class with imports, interface definition, and constructor that initializes the Anthropic client.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport Anthropic from \"@anthropic-ai/sdk\";\nimport dotenv from \"dotenv\";\nimport {\n  CallToolResultSchema,\n  ListToolsResultSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as readline from \"node:readline\";\n\ndotenv.config();\n\ninterface MCPClientConfig {\n  name?: string;\n  version?: string;\n}\n\nclass MCPClient {\n  private client: Client | null = null;\n  private anthropic: Anthropic;\n  private transport: StdioClientTransport | null = null;\n\n  constructor(config: MCPClientConfig = {}) {\n    this.anthropic = new Anthropic();\n  }\n\n  // Methods will go here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Processing with Claude Integration\nDESCRIPTION: Core functionality for processing user queries, handling tool calls, and streaming responses from Claude using Microsoft.Extensions.AI. This sets up an interactive chat loop that continues until the user types 'quit'.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\nusing IChatClient anthropicClient = new AnthropicClient(new APIAuthentication(builder.Configuration[\"ANTHROPIC_API_KEY\"]))\n    .Messages\n    .AsBuilder()\n    .UseFunctionInvocation()\n    .Build();\n\nvar options = new ChatOptions\n{\n    MaxOutputTokens = 1000,\n    ModelId = \"claude-3-5-sonnet-20241022\",\n    Tools = [.. tools]\n};\n\nwhile (true)\n{\n    Console.WriteLine(\"MCP Client Started!\");\n    Console.WriteLine(\"Type your queries or 'quit' to exit.\");\n\n    string? query = Console.ReadLine();\n\n    if (string.IsNullOrWhiteSpace(query))\n    {\n        continue;\n    }\n    if (string.Equals(query, \"quit\", StringComparison.OrdinalIgnoreCase))\n    {\n        break;\n    }\n\n    var response = anthropicClient.GetStreamingResponseAsync(query, options);\n\n    await foreach (var message in response)\n    {\n        Console.Write(message.Text);\n    }\n    Console.WriteLine();\n}\n```\n\n----------------------------------------\n\nTITLE: Tool Definition Structure in TypeScript\nDESCRIPTION: Basic structure for defining a tool in MCP with name, description and input schema.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: string;          // Unique identifier for the tool\n  description?: string;  // Human-readable description\n  inputSchema: {         // JSON Schema for the tool's parameters\n    type: \"object\",\n    properties: { ... }  // Tool-specific parameters\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Host-Server Architecture with Mermaid\nDESCRIPTION: This diagram shows the client-server architecture of MCP where clients exist inside host applications and maintain connections with servers in separate processes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    subgraph \"Host\"\n        client1[MCP Client]\n        client2[MCP Client]\n    end\n    subgraph \"Server Process\"\n        server1[MCP Server]\n    end\n    subgraph \"Server Process\"\n        server2[MCP Server]\n    end\n\n    client1 <-->|Transport Layer| server1\n    client2 <-->|Transport Layer| server2\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Client with Server Connection Logic\nDESCRIPTION: Sets up the Model Context Protocol client that connects to a server specified via command line arguments. The code handles different script types (.py, .js, .csproj) and lists available tools from the connected server.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nvar (command, arguments) = args switch\n{\n    [var script] when script.EndsWith(\".py\") => (\"python\", script),\n    [var script] when script.EndsWith(\".js\") => (\"node\", script),\n    [var script] when Directory.Exists(script) || (File.Exists(script) && script.EndsWith(\".csproj\")) => (\"dotnet\", $\"run --project {script} --no-build\"),\n    _ => throw new NotSupportedException(\"An unsupported server script was provided. Supported scripts are .py, .js, or .csproj\")\n};\n\nawait using var mcpClient = await McpClientFactory.CreateAsync(new()\n{\n    Id = \"demo-server\",\n    Name = \"Demo Server\",\n    TransportType = TransportTypes.StdIo,\n    TransportOptions = new()\n    {\n        [\"command\"] = command,\n        [\"arguments\"] = arguments,\n    }\n});\n\nvar tools = await mcpClient.ListToolsAsync();\nforeach (var tool in tools)\n{\n    Console.WriteLine($\"Connected to server with tools: {tool.Name}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring STDIO Transport Provider for MCP Server in Java\nDESCRIPTION: Creates an in-process based STDIO transport provider for MCP server. This implementation handles bidirectional JSON-RPC message handling over standard input/output streams with non-blocking message processing.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nStdioServerTransportProvider transportProvider = new StdioServerTransportProvider(new ObjectMapper());\n```\n\n----------------------------------------\n\nTITLE: GitHub API Integration Tool Definition\nDESCRIPTION: Example of a tool definition for creating GitHub issues with title, body, and labels parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"github_create_issue\",\n  description: \"Create a GitHub issue\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      title: { type: \"string\" },\n      body: { type: \"string\" },\n      labels: { type: \"array\", items: { type: \"string\" } }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON-RPC Message Structures in TypeScript\nDESCRIPTION: Defines the structure of JSON-RPC 2.0 messages used in MCP, including requests, responses, and notifications. These structures form the basis of communication in the protocol.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  id: number | string,\n  method: string,\n  params?: object\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  id: number | string,\n  result?: object,\n  error?: {\n    code: number,\n    message: string,\n    data?: unknown\n  }\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  method: string,\n  params?: object\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebMvc SSE Transport Provider for MCP Server in Java\nDESCRIPTION: Implements the Spring WebMvc-based SSE server transport for MCP server. This configuration requires the mcp-spring-webmvc dependency and supports server-side event streaming for traditional web applications.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\n@EnableWebMvc\nclass McpConfig {\n    @Bean\n    WebMvcSseServerTransportProvider webMvcSseServerTransportProvider(ObjectMapper mapper) {\n        return new WebMvcSseServerTransportProvider(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction<ServerResponse> mcpRouterFunction(WebMvcSseServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Prompts with prompts/get Endpoint\nDESCRIPTION: Example of request and response for the prompts/get endpoint that allows clients to utilize a specific prompt with arguments.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Request\n{\n  method: \"prompts/get\",\n  params: {\n    name: \"analyze-code\",\n    arguments: {\n      language: \"python\"\n    }\n  }\n}\n\n// Response\n{\n  description: \"Analyze Python code for potential improvements\",\n  messages: [\n    {\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Please analyze the following Python code for potential improvements:\\n\\n```python\\ndef calculate_sum(numbers):\\n    total = 0\\n    for num in numbers:\\n        total = total + num\\n    return total\\n\\nresult = calculate_sum([1, 2, 3, 4, 5])\\nprint(result)\\n```\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Sampling Request for MCP\nDESCRIPTION: Sample JSON request demonstrating how to structure a sampling request to get information about files in the current directory.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/sampling.mdx#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"method\": \"sampling/createMessage\",\n  \"params\": {\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": {\n          \"type\": \"text\",\n          \"text\": \"What files are in the current directory?\"\n        }\n      }\n    ],\n    \"systemPrompt\": \"You are a helpful file system assistant.\",\n    \"includeContext\": \"thisServer\",\n    \"maxTokens\": 100\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Transport in Python\nDESCRIPTION: Demonstrates how to implement a custom transport in Python using anyio for wider compatibility. This example shows the basic structure and error handling for a custom transport.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@contextmanager\nasync def create_transport(\n    read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception],\n    write_stream: MemoryObjectSendStream[JSONRPCMessage]\n):\n    \"\"\"\n    Transport interface for MCP.\n\n    Args:\n        read_stream: Stream to read incoming messages from\n        write_stream: Stream to write outgoing messages to\n    \"\"\"\n    async with anyio.create_task_group() as tg:\n        try:\n            # Start processing messages\n            tg.start_soon(lambda: process_messages(read_stream))\n\n            # Send messages\n            async with write_stream:\n                yield write_stream\n\n        except Exception as exc:\n            # Handle errors\n            raise exc\n        finally:\n            # Clean up\n            tg.cancel_scope.cancel()\n            await write_stream.aclose()\n            await read_stream.aclose()\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Transport in Python (Client)\nDESCRIPTION: Shows how to set up a client using the Server-Sent Events (SSE) transport in Python. This allows the client to receive server-to-client streaming updates in a Python environment.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nasync with sse_client(\"http://localhost:8000/sse\") as streams:\n    async with ClientSession(streams[0], streams[1]) as session:\n        await session.initialize()\n```\n\n----------------------------------------\n\nTITLE: Defining Typescript Message Format for MCP Sampling\nDESCRIPTION: TypeScript interface defining the structure for sampling request messages, including conversation history, model preferences, and sampling parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/sampling.mdx#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  messages: [\n    {\n      role: \"user\" | \"assistant\",\n      content: {\n        type: \"text\" | \"image\",\n\n        // For text:\n        text?: string,\n\n        // For images:\n        data?: string,             // base64 encoded\n        mimeType?: string\n      }\n    }\n  ],\n  modelPreferences?: {\n    hints?: [{\n      name?: string                // Suggested model name/family\n    }],\n    costPriority?: number,         // 0-1, importance of minimizing cost\n    speedPriority?: number,        // 0-1, importance of low latency\n    intelligencePriority?: number  // 0-1, importance of capabilities\n  },\n  systemPrompt?: string,\n  includeContext?: \"none\" | \"thisServer\" | \"allServers\",\n  temperature?: number,\n  maxTokens: number,\n  stopSequences?: string[],\n  metadata?: Record<string, unknown>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Entry Point for MCP Client in Python\nDESCRIPTION: Main function for running the MCP client application. This handles command-line arguments, initializes the client, connects to the server, runs the chat loop, and ensures proper cleanup.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    if len(sys.argv) < 2:\n        print(\"Usage: python client.py <path_to_server_script>\")\n        sys.exit(1)\n\n    client = MCPClient()\n    try:\n        await client.connect_to_server(sys.argv[1])\n        await client.chat_loop()\n    finally:\n        await client.cleanup()\n\nif __name__ == \"__main__\":\n    import sys\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Configuring Servlet-based SSE Transport Provider for MCP Server in Java\nDESCRIPTION: Implements a Servlet-based SSE server transport for MCP server using the traditional Servlet API. This implementation can be used with any Servlet container and provides asynchronous message handling using Servlet 6.0 async support.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\n@EnableWebMvc\npublic class McpServerConfig implements WebMvcConfigurer {\n\n    @Bean\n    public HttpServletSseServerTransportProvider servletSseServerTransportProvider() {\n        return new HttpServletSseServerTransportProvider(new ObjectMapper(), \"/mcp/message\");\n    }\n\n    @Bean\n    public ServletRegistrationBean customServletBean(HttpServletSseServerTransportProvider transportProvider) {\n        return new ServletRegistrationBean(transportProvider);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stdio Transport in Python (Client)\nDESCRIPTION: Shows how to set up a client using the stdio transport in Python. This enables communication with a server through standard input and output streams in a Python environment.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nparams = StdioServerParameters(\n    command=\"./server\",\n    args=[\"--option\", \"value\"]\n)\n\nasync with stdio_client(params) as streams:\n    async with ClientSession(streams[0], streams[1]) as session:\n        await session.initialize()\n```\n\n----------------------------------------\n\nTITLE: Sending Logging Notifications from MCP Server in Java\nDESCRIPTION: Demonstrates how to send structured log messages to clients with configurable severity levels. The example shows creating a log notification with an INFO level, custom logger name, and message data.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_7\n\nLANGUAGE: java\nCODE:\n```\n// Send a log message to clients\nserver.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Custom log message\")\n    .build());\n```\n\n----------------------------------------\n\nTITLE: Connecting to MCP Server in Kotlin\nDESCRIPTION: Implements a method to connect to an MCP server, start the server process, establish transport, and retrieve available tools. It handles different script types (JS, Python, JAR) and sets up the connection using StdioClientTransport.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_25\n\nLANGUAGE: kotlin\nCODE:\n```\nsuspend fun connectToServer(serverScriptPath: String) {\n    try {\n        val command = buildList {\n            when (serverScriptPath.substringAfterLast(\".\")) {\n                \"js\" -> add(\"node\")\n                \"py\" -> add(if (System.getProperty(\"os.name\").lowercase().contains(\"win\")) \"python\" else \"python3\")\n                \"jar\" -> addAll(listOf(\"java\", \"-jar\"))\n                else -> throw IllegalArgumentException(\"Server script must be a .js, .py or .jar file\")\n            }\n            add(serverScriptPath)\n        }\n\n        val process = ProcessBuilder(command).start()\n        val transport = StdioClientTransport(\n            input = process.inputStream.asSource().buffered(),\n            output = process.outputStream.asSink().buffered()\n        )\n\n        mcp.connect(transport)\n\n        val toolsResult = mcp.listTools()\n        tools = toolsResult?.tools?.map { tool ->\n            ToolUnion.ofTool(\n                Tool.builder()\n                    .name(tool.name)\n                    .description(tool.description ?: \"\")\n                    .inputSchema(\n                        Tool.InputSchema.builder()\n                            .type(JsonValue.from(tool.inputSchema.type))\n                            .properties(tool.inputSchema.properties.toJsonValue())\n                            .putAdditionalProperty(\"required\", JsonValue.from(tool.inputSchema.required))\n                            .build()\n                    )\n                    .build()\n            )\n        } ?: emptyList()\n        println(\"Connected to server with tools: ${tools.joinToString(\", \") { it.tool().get().name() }}\")\n    } catch (e: Exception) {\n        println(\"Failed to connect to MCP server: $e\")\n        throw e\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stdio Transport in Python (Server)\nDESCRIPTION: Demonstrates how to set up a server using the stdio transport in Python. This allows communication through standard input and output streams in a Python environment.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\nasync with stdio_server() as streams:\n    await app.run(\n        streams[0],\n        streams[1],\n        app.create_initialization_options()\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Transport Interface in TypeScript\nDESCRIPTION: Specifies the interface for implementing custom transports in TypeScript. This interface defines the required methods and callbacks for a transport implementation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Transport {\n  // Start processing messages\n  start(): Promise<void>;\n\n  // Send a JSON-RPC message\n  send(message: JSONRPCMessage): Promise<void>;\n\n  // Close the connection\n  close(): Promise<void>;\n\n  // Callbacks\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Transport in TypeScript (Server)\nDESCRIPTION: Demonstrates how to set up a server using the Server-Sent Events (SSE) transport in TypeScript. This enables server-to-client streaming with HTTP POST requests for client-to-server communication.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\n\nconst app = express();\n\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nlet transport: SSEServerTransport | null = null;\n\napp.get(\"/sse\", (req, res) => {\n  transport = new SSEServerTransport(\"/messages\", res);\n  server.connect(transport);\n});\n\napp.post(\"/messages\", (req, res) => {\n  if (transport) {\n    transport.handlePostMessage(req, res);\n  }\n});\n\napp.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Implementing Sync Sampling Server in Java MCP\nDESCRIPTION: Implementation of a synchronous server with AI sampling capabilities, including model preferences and request handling.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_14\n\nLANGUAGE: java\nCODE:\n```\nMcpSyncServer server = McpServer.sync(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .build();\n\nvar calculatorTool = new McpServerFeatures.SyncToolSpecification(\n    new Tool(\"ai-calculator\", \"Performs calculations using AI\", schema),\n    (exchange, arguments) -> {\n        if (exchange.getClientCapabilities().sampling() == null) {\n            return new CallToolResult(\"Client does not support AI capabilities\", false);\n        }\n        \n        McpSchema.CreateMessageRequest request = McpSchema.CreateMessageRequest.builder()\n            .messages(List.of(new McpSchema.SamplingMessage(McpSchema.Role.USER,\n                new McpSchema.TextContent(\"Calculate: \" + arguments.get(\"expression\")))\n            .modelPreferences(McpSchema.ModelPreferences.builder()\n                .hints(List.of(\n                    McpSchema.ModelHint.of(\"claude-3-sonnet\"),\n                    McpSchema.ModelHint.of(\"claude\")\n                ))\n                .intelligencePriority(0.8)\n                .speedPriority(0.5)\n                .build())\n            .systemPrompt(\"You are a helpful calculator assistant. Provide only the numerical answer.\")\n            .maxTokens(100)\n            .build();\n        \n        McpSchema.CreateMessageResult result = exchange.createMessage(request);\n        \n        String answer = result.content().text();\n        return new CallToolResult(answer, false);\n    }\n);\n\nserver.addTool(calculatorTool);\n```\n\n----------------------------------------\n\nTITLE: TypeScript Resource Template Schema for Dynamic Resources\nDESCRIPTION: Shows the structure for resource templates that allow clients to construct valid URIs for dynamic resources, following RFC 6570 for URI templates.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  uriTemplate: string;   // URI template following RFC 6570\n  name: string;          // Human-readable name for this type\n  description?: string;  // Optional description\n  mimeType?: string;     // Optional MIME type for all matching resources\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Transport in TypeScript (Client)\nDESCRIPTION: Shows how to set up a client using the Server-Sent Events (SSE) transport in TypeScript. This allows the client to receive server-to-client streaming updates.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  name: \"example-client\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new SSEClientTransport(\n  new URL(\"http://localhost:3000/sse\")\n);\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Client Class Structure in Python\nDESCRIPTION: Basic client structure with imports and class initialization. This sets up the MCP client class with necessary dependencies including the Anthropic client for LLM interactions and MCP session management.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom typing import Optional\nfrom contextlib import AsyncExitStack\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nfrom anthropic import Anthropic\nfrom dotenv import load_dotenv\n\nload_dotenv()  # load environment variables from .env\n\nclass MCPClient:\n    def __init__(self):\n        # Initialize session and client objects\n        self.session: Optional[ClientSession] = None\n        self.exit_stack = AsyncExitStack()\n        self.anthropic = Anthropic()\n    # methods will go here\n```\n\n----------------------------------------\n\nTITLE: Defining Typescript Response Format for MCP Sampling\nDESCRIPTION: TypeScript interface defining the structure for sampling response messages, including model information and generated content.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/sampling.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  model: string,  // Name of the model used\n  stopReason?: \"endTurn\" | \"stopSequence\" | \"maxTokens\" | string,\n  role: \"user\" | \"assistant\",\n  content: {\n    type: \"text\" | \"image\",\n    text?: string,\n    data?: string,\n    mimeType?: string\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Execution Logic\nDESCRIPTION: Main function and export for the MCP client that handles command-line arguments, connects to the specified server, and starts the chat loop with proper error handling.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Main execution\nasync function main() {\n  if (process.argv.length < 3) {\n    console.log(\"Usage: ts-node client.ts <path_to_server_script>\");\n    process.exit(1);\n  }\n\n  const client = new MCPClient();\n  try {\n    await client.connectToServer(process.argv[2]);\n    await client.chatLoop();\n  } catch (error) {\n    console.error(\"Error:\", error);\n    await client.cleanup();\n    process.exit(1);\n  }\n}\n\n// Run main if this is the main module\nif (import.meta.url === new URL(process.argv[1], \"file:\").href) {\n  main();\n}\n\nexport default MCPClient;\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for Node.js MCP Client\nDESCRIPTION: JSON configuration for package.json that sets the module type to ES modules and defines build and start scripts for the TypeScript project.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node build/client.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Filesystem MCP Server for MacOS/Linux in Claude Desktop\nDESCRIPTION: JSON configuration for adding the Filesystem MCP Server to Claude for Desktop on MacOS/Linux. It specifies the command to run the server and the directories to access.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \"/Users/username/Desktop\",\n        \"/Users/username/Downloads\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Data Processing Tool Definition\nDESCRIPTION: Example of a tool definition for analyzing CSV files with filepath and operations parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"analyze_csv\",\n  description: \"Analyze a CSV file\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      filepath: { type: \"string\" },\n      operations: {\n        type: \"array\",\n        items: {\n          enum: [\"sum\", \"average\", \"count\"]\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-step Workflows in TypeScript\nDESCRIPTION: TypeScript example that defines a multi-step workflow prompt to handle error debugging with a conversation pattern.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst debugWorkflow = {\n  name: \"debug-error\",\n  async getMessages(error: string) {\n    return [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Here's an error I'm seeing: ${error}`\n        }\n      },\n      {\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"I'll help analyze this error. What have you tried so far?\"\n        }\n      },\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: \"I've tried restarting the service, but the error persists.\"\n        }\n      }\n    ];\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Filesystem MCP Server for Windows in Claude Desktop\nDESCRIPTION: JSON configuration for adding the Filesystem MCP Server to Claude for Desktop on Windows. It specifies the command to run the server and the directories to access.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \"C:\\\\Users\\\\username\\\\Desktop\",\n        \"C:\\\\Users\\\\username\\\\Downloads\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Connection Lifecycle with Mermaid\nDESCRIPTION: This diagram illustrates the initialization sequence between client and server in MCP, showing the request-response pattern and final notification that establishes the connection.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: initialize request\n    Server->>Client: initialize response\n    Client->>Server: initialized notification\n\n    Note over Client,Server: Connection ready for use\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Chat Loop in Kotlin\nDESCRIPTION: Creates an interactive chat loop that continuously prompts for user input, processes queries, and displays responses. It allows users to exit the chat by typing 'quit'.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_28\n\nLANGUAGE: kotlin\nCODE:\n```\nsuspend fun chatLoop() {\n    println(\"\\nMCP Client Started!\")\n    println(\"Type your queries or 'quit' to exit.\")\n\n    while (true) {\n        print(\"\\nQuery: \")\n        val message = readLine() ?: break\n        if (message.lowercase() == \"quit\") break\n        val response = processQuery(message)\n        println(\"\\n$response\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Describing MCP Server Requirements to Claude\nDESCRIPTION: Example of how to specify the requirements for an MCP server to Claude, including database connection, resource exposure, tool provision, and external system interactions.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-mcp-with-llms.mdx#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\nBuild an MCP server that:\n- Connects to my company's PostgreSQL database\n- Exposes table schemas as resources\n- Provides tools for running read-only SQL queries\n- Includes prompts for common data analysis tasks\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic MCP Client Structure in Kotlin\nDESCRIPTION: Kotlin class definition for a basic MCP client, including Anthropic client initialization and MCP setup.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_24\n\nLANGUAGE: kotlin\nCODE:\n```\nclass MCPClient : AutoCloseable {\n    private val anthropic = AnthropicOkHttpClient.fromEnv()\n    private val mcp: Client = Client(clientInfo = Implementation(name = \"mcp-client-cli\", version = \"1.0.0\"))\n    private lateinit var tools: List<ToolUnion>\n\n    // methods will go here\n\n    override fun close() {\n        runBlocking {\n            mcp.close()\n            anthropic.close()\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Resource Schema for Direct Resources\nDESCRIPTION: Defines the TypeScript schema for direct resources in MCP, showing the required URI and name fields along with optional description and MIME type properties.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/resources.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  uri: string;           // Unique identifier for the resource\n  name: string;          // Human-readable name\n  description?: string;  // Optional description\n  mimeType?: string;     // Optional MIME type\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Context in prompts/get Response\nDESCRIPTION: Example JSON response for a prompts/get request that includes embedded resources from system logs and code files.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"text\",\n        \"text\": \"Analyze these system logs and the code file for any issues:\"\n      }\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"resource\",\n        \"resource\": {\n          \"uri\": \"logs://recent?timeframe=1h\",\n          \"text\": \"[2024-03-14 15:32:11] ERROR: Connection timeout in network.py:127\\n[2024-03-14 15:32:15] WARN: Retrying connection (attempt 2/3)\\n[2024-03-14 15:32:20] ERROR: Max retries exceeded\",\n          \"mimeType\": \"text/plain\"\n        }\n      }\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"resource\",\n        \"resource\": {\n          \"uri\": \"file:///path/to/code.py\",\n          \"text\": \"def connect_to_service(timeout=30):\\n    retries = 3\\n    for attempt in range(retries):\\n        try:\\n            return establish_connection(timeout)\\n        except TimeoutError:\\n            if attempt == retries - 1:\\n                raise\\n            time.sleep(5)\\n\\ndef establish_connection(timeout):\\n    # Connection implementation\\n    pass\",\n          \"mimeType\": \"text/x-python\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Error Codes Enum in TypeScript\nDESCRIPTION: This TypeScript enum defines standard error codes used in MCP, based on the standard JSON-RPC error codes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nenum ErrorCode {\n  // Standard JSON-RPC error codes\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Prompts with Embedded Resource Context\nDESCRIPTION: JSON definition of a dynamic prompt that can include embedded resource context from logs and code files.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"analyze-project\",\n  \"description\": \"Analyze project logs and code\",\n  \"arguments\": [\n    {\n      \"name\": \"timeframe\",\n      \"description\": \"Time period to analyze logs\",\n      \"required\": true\n    },\n    {\n      \"name\": \"fileUri\",\n      \"description\": \"URI of code file to review\",\n      \"required\": true\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Required Using Statements for MCP Client\nDESCRIPTION: Namespace imports required for using the Model Context Protocol client classes and transport functionality.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nusing ModelContextProtocol.Client;\nusing ModelContextProtocol.Protocol.Transport;\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic .NET Console Application Structure\nDESCRIPTION: Sets up the foundation for a .NET console application that can read API keys from user secrets, using the Host Builder pattern.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = Host.CreateEmptyApplicationBuilder(settings: null);\n\nbuilder.Configuration\n    .AddUserSecrets<Program>();\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Servers for Claude\nDESCRIPTION: JSON configuration example showing how to set up multiple MCP servers including memory, filesystem, and GitHub with their respective commands, arguments, and environment variables\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/examples.mdx#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"memory\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-memory\"]\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"<YOUR_TOKEN>\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Server Connection Method Implementation\nDESCRIPTION: Method for establishing connection with MCP server and retrieving available tools\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nasync connectToServer(serverScriptPath: string) {\n  try {\n    const isJs = serverScriptPath.endsWith(\".js\");\n    const isPy = serverScriptPath.endsWith(\".py\");\n    if (!isJs && !isPy) {\n      throw new Error(\"Server script must be a .js or .py file\");\n    }\n    const command = isPy\n      ? process.platform === \"win32\"\n        ? \"python\"\n        : \"python3\"\n      : process.execPath;\n    \n    this.transport = new StdioClientTransport({\n      command,\n      args: [serverScriptPath],\n    });\n    this.mcp.connect(this.transport);\n    \n    const toolsResult = await this.mcp.listTools();\n    this.tools = toolsResult.tools.map((tool) => {\n      return {\n        name: tool.name,\n        description: tool.description,\n        input_schema: tool.inputSchema,\n      };\n    });\n    console.log(\n      \"Connected to server with tools:\",\n      this.tools.map(({ name }) => name)\n    );\n  } catch (e) {\n    console.log(\"Failed to connect to MCP server: \", e);\n    throw e;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig.json for Node.js MCP Client\nDESCRIPTION: TypeScript configuration that specifies ES2022 target, Node16 module system, and other compiler options necessary for the MCP client implementation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Chat Loop Implementation\nDESCRIPTION: Methods for handling interactive chat functionality and cleanup\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nasync chatLoop() {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  try {\n    console.log(\"\\nMCP Client Started!\");\n    console.log(\"Type your queries or 'quit' to exit.\");\n\n    while (true) {\n      const message = await rl.question(\"\\nQuery: \");\n      if (message.toLowerCase() === \"quit\") {\n        break;\n      }\n      const response = await this.processQuery(message);\n      console.log(\"\\n\" + response);\n    }\n  } finally {\n    rl.close();\n  }\n}\n\nasync cleanup() {\n  await this.mcp.close();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stdio Transport in TypeScript (Client)\nDESCRIPTION: Shows how to set up a client using the stdio transport in TypeScript. This enables communication with a server through standard input and output streams.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  name: \"example-client\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new StdioClientTransport({\n  command: \"./server\",\n  args: [\"--option\", \"value\"]\n});\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Adding MCP Core Dependency in Maven\nDESCRIPTION: Maven dependency configuration for including the core MCP functionality in a project. The core module provides default STDIO and SSE transport implementations without requiring external web frameworks.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Sending Log Messages in Python MCP Server\nDESCRIPTION: This Python code snippet demonstrates how to send a log message from an MCP server to the client. It uses the server's request context to send an info-level log message.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nserver.request_context.session.send_log_message(\n  level=\"info\",\n  data=\"Server started successfully\",\n)\n```\n\n----------------------------------------\n\nTITLE: Using MCP Client for Resource Access in Java\nDESCRIPTION: This snippet shows how to use MCP clients to list available resources and retrieve their contents using URI templates, with both synchronous and asynchronous APIs.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n// List available resources and their names\nvar resources = client.listResources();\nresources.forEach(resource -> System.out.println(resource.getName()));\n\n// Retrieve resource content using a URI template\nvar content = client.getResource(\"file\", Map.of(\n    \"path\", \"/path/to/file.txt\"\n));\n```\n\nLANGUAGE: java\nCODE:\n```\n// List available resources asynchronously\nclient.listResources()\n    .doOnNext(resources -> resources.forEach(resource -> \n        System.out.println(resource.getName())))\n    .subscribe();\n\n// Retrieve resource content asynchronously\nclient.getResource(\"file\", Map.of(\n        \"path\", \"/path/to/file.txt\"\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Adding Optional Spring Framework Dependencies in Maven\nDESCRIPTION: Maven configuration for optional Spring-specific transport implementations. These dependencies are useful when integrating MCP with Spring WebFlux for reactive applications or Spring WebMVC for servlet-based applications.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<!-- Optional: Spring WebFlux-based SSE client and server transport -->\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp-spring-webflux</artifactId>\n</dependency>\n\n<!-- Optional: Spring WebMVC-based SSE server transport -->\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp-spring-webmvc</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Sending Log Messages in TypeScript MCP Server\nDESCRIPTION: This TypeScript code snippet shows how to send a log message from an MCP server to the client. It uses the server's sendLoggingMessage method to send an info-level log message.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nserver.sendLoggingMessage({\n  level: \"info\",\n  data: \"Server started successfully\",\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Python Transport\nDESCRIPTION: Demonstrates error handling implementation in a Python transport using anyio. This example shows how to handle various error scenarios and properly clean up resources.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@contextmanager\nasync def example_transport(scope: Scope, receive: Receive, send: Send):\n    try:\n        # Create streams for bidirectional communication\n        read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n        write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n        async def message_handler():\n            try:\n                async with read_stream_writer:\n                    # Message handling logic\n                    pass\n            except Exception as exc:\n                logger.error(f\"Failed to handle message: {exc}\")\n                raise exc\n\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(message_handler)\n            try:\n                # Yield streams for communication\n                yield read_stream, write_stream\n            except Exception as exc:\n                logger.error(f\"Transport error: {exc}\")\n                raise exc\n            finally:\n                tg.cancel_scope.cancel()\n                await write_stream.aclose()\n                await read_stream.aclose()\n    except Exception as exc:\n        logger.error(f\"Failed to initialize transport: {exc}\")\n        raise exc\n```\n\n----------------------------------------\n\nTITLE: Main Entry Point Implementation\nDESCRIPTION: Main function for executing the MCP client application\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nasync function main() {\n  if (process.argv.length < 3) {\n    console.log(\"Usage: node index.ts <path_to_server_script>\");\n    return;\n  }\n  const mcpClient = new MCPClient();\n  try {\n    await mcpClient.connectToServer(process.argv[2]);\n    await mcpClient.chatLoop();\n  } finally {\n    await mcpClient.cleanup();\n    process.exit(0);\n  }\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Configuring Spring AI and MCP Client Properties\nDESCRIPTION: YAML configuration for enabling and setting up the MCP client and Anthropic API in a Spring application.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nspring:\n  ai:\n    mcp:\n      client:\n        enabled: true\n        name: brave-search-client\n        version: 1.0.0\n        type: SYNC\n        request-timeout: 20s\n        stdio:\n          root-change-notification: true\n          servers-configuration: classpath:/mcp-servers-config.json\n    anthropic:\n      api-key: ${ANTHROPIC_API_KEY}\n```\n\n----------------------------------------\n\nTITLE: Configuring BOM in Gradle for Version Management\nDESCRIPTION: Gradle configuration using a Bill of Materials (BOM) to manage MCP dependency versions. This approach leverages Gradle's native support for Maven BOMs through the platform dependency handler.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_5\n\nLANGUAGE: groovy\nCODE:\n```\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-bom:0.8.1\")\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in TypeScript Transport\nDESCRIPTION: Shows an example of error handling implementation in a TypeScript transport. This demonstrates how to handle connection errors and message sending failures.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/transports.mdx#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nclass ExampleTransport implements Transport {\n  async start() {\n    try {\n      // Connection logic\n    } catch (error) {\n      this.onerror?.(new Error(`Failed to connect: ${error}`));\n      throw error;\n    }\n  }\n\n  async send(message: JSONRPCMessage) {\n    try {\n      // Sending logic\n    } catch (error) {\n      this.onerror?.(new Error(`Failed to send message: ${error}`));\n      throw error;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the MCP Client with Different Server Types\nDESCRIPTION: Commands for running the .NET MCP client with different types of servers (dotnet, python, node.js), showing how to specify the path to the server implementation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- path/to/server.csproj # dotnet server\ndotnet run -- path/to/server.py # python server\ndotnet run -- path/to/server.js # node server\n```\n\n----------------------------------------\n\nTITLE: Inspecting Locally Developed Python Servers with MCP Inspector\nDESCRIPTION: Command for inspecting locally developed Python servers. This approach uses uv to run the Python package with arguments from a specified directory.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/inspector.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector \\\n  uv \\\n  --directory path/to/server \\\n  run \\\n  package-name \\\n  args...\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Client Transport in Java\nDESCRIPTION: This snippet demonstrates how to configure different transport options for MCP clients, including STDIO for in-process communication, SSE with HttpClient, and SSE with WebFlux.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-client.mdx#2025-04-22_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nServerParameters params = ServerParameters.builder(\"npx\")\n    .args(\"-y\", \"@modelcontextprotocol/server-everything\", \"dir\")\n    .build();\nMcpTransport transport = new StdioClientTransport(params);\n```\n\nLANGUAGE: java\nCODE:\n```\nMcpTransport transport = new HttpClientSseClientTransport(\"http://your-mcp-server\");\n```\n\nLANGUAGE: java\nCODE:\n```\nWebClient.Builder webClientBuilder = WebClient.builder()\n    .baseUrl(\"http://your-mcp-server\");\nMcpTransport transport = new WebFluxSseClientTransport(webClientBuilder);\n```\n\n----------------------------------------\n\nTITLE: Error Handling in TypeScript Tools\nDESCRIPTION: Example of proper error handling in MCP tools using TypeScript, including success and error cases.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  // Tool operation\n  const result = performOperation();\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Operation successful: ${result}`\n      }\n    ]\n  };\n} catch (error) {\n  return {\n    isError: true,\n    content: [\n      {\n        type: \"text\",\n        text: `Error: ${error.message}`\n      }\n    ]\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Locally Developed TypeScript Servers with MCP Inspector\nDESCRIPTION: Command for inspecting locally developed TypeScript servers. This approach allows testing of servers that are under development or have been downloaded as a repository.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/inspector.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector node path/to/server/index.js args...\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Chat Loop and Cleanup in Python\nDESCRIPTION: Methods for managing the interactive chat interface and resource cleanup. This provides a command-line interface for interacting with the chatbot and ensures proper resource management.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def chat_loop(self):\n    \"\"\"Run an interactive chat loop\"\"\"\n    print(\"\\nMCP Client Started!\")\n    print(\"Type your queries or 'quit' to exit.\")\n\n    while True:\n        try:\n            query = input(\"\\nQuery: \").strip()\n\n            if query.lower() == 'quit':\n                break\n\n            response = await self.process_query(query)\n            print(\"\\n\" + response)\n\n        except Exception as e:\n            print(f\"\\nError: {str(e)}\")\n\nasync def cleanup(self):\n    \"\"\"Clean up resources\"\"\"\n    await self.exit_stack.aclose()\n```\n\n----------------------------------------\n\nTITLE: System Operations Tool Definition\nDESCRIPTION: Example of a tool definition for executing system commands with command and arguments parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"execute_command\",\n  description: \"Run a shell command\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      command: { type: \"string\" },\n      args: { type: \"array\", items: { type: \"string\" } }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding MCP Core Dependency in Gradle\nDESCRIPTION: Gradle dependency configuration for including the core MCP functionality in a project. The implementation platform approach allows for version management through a Bill of Materials.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_2\n\nLANGUAGE: groovy\nCODE:\n```\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp\")\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Python Tools\nDESCRIPTION: Example of proper error handling in MCP tools using Python, including success and error cases.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/tools.mdx#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    # Tool operation\n    result = perform_operation()\n    return types.CallToolResult(\n        content=[\n            types.TextContent(\n                type=\"text\",\n                text=f\"Operation successful: {result}\"\n            )\n        ]\n    )\nexcept Exception as error:\n    return types.CallToolResult(\n        isError=True,\n        content=[\n            types.TextContent(\n                type=\"text\",\n                text=f\"Error: {str(error)}\"\n            )\n        ]\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting up Anthropic API Key with .NET User Secrets\nDESCRIPTION: Instructions for initializing and setting the Anthropic API key using .NET user secrets for secure credential management.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ndotnet user-secrets init\ndotnet user-secrets set \"ANTHROPIC_API_KEY\" \"<your key here>\"\n```\n\n----------------------------------------\n\nTITLE: Viewing MCP Logs in Real-time using Bash\nDESCRIPTION: This command follows the MCP logs in real-time, displaying the last 20 lines. It captures server connection events, configuration issues, runtime errors, and message exchanges.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntail -n 20 -F ~/Library/Logs/Claude/mcp*.log\n```\n\n----------------------------------------\n\nTITLE: Defining Request Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of request messages in MCP, specifying a required method and optional parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Request {\n  method: string;\n  params?: { ... };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for API Keys\nDESCRIPTION: Commands to set the required API keys as environment variables for Anthropic and Brave Search.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nexport ANTHROPIC_API_KEY='your-anthropic-api-key-here'\nexport BRAVE_API_KEY='your-brave-api-key-here'\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Servers for Brave Search\nDESCRIPTION: JSON configuration for setting up the Brave Search MCP server, including command, arguments, and environment variables.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"brave-search\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-brave-search\"\n      ],\n      \"env\": {\n        \"BRAVE_API_KEY\": \"<PUT YOUR BRAVE API KEY>\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Notification Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of one-way notification messages in MCP, which don't expect a response.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Notification {\n  method: string;\n  params?: { ... };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Result Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of successful responses to requests in MCP, allowing for arbitrary key-value pairs.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Result {\n  [key: string]: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Running MCP Client with Gradle in Bash\nDESCRIPTION: Provides commands to build and run the MCP client using Gradle. It includes examples for running the client with different types of server scripts (JAR, Python, Node.js).\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew build\n\n# Run the client\njava -jar build/libs/<your-jar-name>.jar path/to/server.jar # jvm server\njava -jar build/libs/<your-jar-name>.jar path/to/server.py # python server\njava -jar build/libs/<your-jar-name>.jar path/to/build/index.js # node server\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Prompt Specification in Java MCP\nDESCRIPTION: Implementation of an asynchronous prompt specification using reactive programming patterns for handling prompt requests.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-server.mdx#2025-04-22_snippet_13\n\nLANGUAGE: java\nCODE:\n```\nvar asyncPromptSpecification = new McpServerFeatures.asyncPromptSpecification(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    (exchange, request) -> {\n        // Prompt implementation\n        return Mono.just(new GetPromptResult(description, messages));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Error Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of error responses in MCP, including required code and message fields with an optional data field.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/architecture.mdx#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Error {\n  code: number;\n  message: string;\n  data?: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Running the MCP Client\nDESCRIPTION: Commands for building the TypeScript code and running the MCP client with either Python or Node.js servers, showing the basic workflow.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Build the TypeScript code. Make sure to rerun this every time you update `client.ts`!\nnpm run build\n\n# Run the client\nnode build/client.js path/to/server.py  # for Python servers\nnode build/client.js path/to/server.js  # for Node.js servers\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Structure in TypeScript\nDESCRIPTION: The basic structure of a Prompt object in TypeScript, showing the required and optional fields including name, description, and arguments.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: string;              // Unique identifier for the prompt\n  description?: string;      // Human-readable description\n  arguments?: [              // Optional list of arguments\n    {\n      name: string;          // Argument identifier\n      description?: string;  // Argument description\n      required?: boolean;    // Whether argument is required\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Running MCP Inspector Commands with npx\nDESCRIPTION: Basic syntax for running the MCP Inspector directly through npx without requiring installation. The first example shows a simple command, and the second shows a command with arguments.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/inspector.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector <command>\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector <command> <arg1> <arg2>\n```\n\n----------------------------------------\n\nTITLE: Setting up Node.js MCP Project Environment with bash commands\nDESCRIPTION: Commands to create a new Node.js project directory, initialize npm, install required dependencies including the MCP SDK, and set up TypeScript configuration.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create project directory\nmkdir mcp-client\ncd mcp-client\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk @anthropic-ai/sdk dotenv\nnpm install -D typescript @types/node\n\n# Create TypeScript config\nnpx tsc --init\n\n# Create necessary files\nmkdir src\ntouch src/client.ts\ntouch .env\n```\n\n----------------------------------------\n\nTITLE: Running Filesystem MCP Server Manually on MacOS/Linux\nDESCRIPTION: Bash command to manually run the Filesystem MCP Server on MacOS/Linux for troubleshooting purposes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/server-filesystem /Users/username/Desktop /Users/username/Downloads\n```\n\n----------------------------------------\n\nTITLE: Discovering Prompts with prompts/list Endpoint\nDESCRIPTION: Example of request and response for the prompts/list endpoint that allows clients to discover available prompts.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/concepts/prompts.mdx#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Request\n{\n  method: \"prompts/list\"\n}\n\n// Response\n{\n  prompts: [\n    {\n      name: \"analyze-code\",\n      description: \"Analyze code for potential improvements\",\n      arguments: [\n        {\n          name: \"language\",\n          description: \"Programming language\",\n          required: true\n        }\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Running the MCP Client Application\nDESCRIPTION: Command to run the MCP client with a server script. This shows how to execute the client application, providing the path to either a Python or Node.js server script.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nuv run client.py path/to/server.py # python server\nuv run client.py path/to/build/index.js # node server\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Server with Absolute Paths in JSON\nDESCRIPTION: This JSON configuration for claude_desktop_config.json demonstrates the use of absolute paths when specifying the command and arguments for an MCP server. It ensures reliable operation regardless of the working directory.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"command\": \"npx\",\n  \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/Users/username/data\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Environment Files for API Keys\nDESCRIPTION: Commands to create and configure environment files for storing API keys securely. This includes creating a .env file for the Anthropic API key and updating .gitignore to exclude it from version control.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Create .env file\ntouch .env\n```\n\nLANGUAGE: bash\nCODE:\n```\nANTHROPIC_API_KEY=<your key here>\n```\n\nLANGUAGE: bash\nCODE:\n```\necho \".env\" >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Installing MCP Client Dependencies - Bash Setup\nDESCRIPTION: Commands for creating project directory and installing required npm packages for MacOS/Linux\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Create project directory\nmkdir mcp-client-typescript\ncd mcp-client-typescript\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv\n\n# Install dev dependencies\nnpm install -D @types/node typescript\n\n# Create source file\ntouch index.ts\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for MCP Server in JSON\nDESCRIPTION: This JSON configuration shows how to specify environment variables for an MCP server in claude_desktop_config.json. It allows overriding default variables or providing custom ones.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"myserver\": {\n    \"command\": \"mcp-server-myapp\",\n    \"env\": {\n      \"MYAPP_API_KEY\": \"some_key\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maven Dependencies for Spring AI and MCP\nDESCRIPTION: XML snippet showing the required Maven dependencies for integrating Spring AI and MCP client in a project.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_19\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-starter-mcp-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-starter-model-anthropic</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Converting JsonObject to JsonValue in Kotlin\nDESCRIPTION: Helper function to convert a JsonObject to JsonValue for use with the Anthropic API. It uses ObjectMapper to read the JSON string and create a JsonValue object.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_26\n\nLANGUAGE: kotlin\nCODE:\n```\nprivate fun JsonObject.toJsonValue(): JsonValue {\n    val mapper = ObjectMapper()\n    val node = mapper.readTree(this.toString())\n    return JsonValue.fromJsonNode(node)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Correct Path Usage for ModelContextProtocol Server Scripts\nDESCRIPTION: This snippet shows examples of correct path usage for running ModelContextProtocol server scripts, including relative paths, absolute paths, and Windows-specific path formats. It demonstrates how to properly specify the server script path when executing the client.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Relative path\nnode build/client.js ./server/weather.js\n\n# Absolute path\nnode build/client.js /Users/username/projects/mcp-server/weather.js\n\n# Windows path (either format works)\nnode build/client.js C:/projects/mcp-server/weather.js\nnode build/client.js C:\\\\projects\\\\mcp-server\\\\weather.js\n```\n\n----------------------------------------\n\nTITLE: Configuring Kotlin Project Dependencies for MCP Client\nDESCRIPTION: Kotlin build script snippet showing the required dependencies for setting up an MCP client with Anthropic integration.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_23\n\nLANGUAGE: kotlin\nCODE:\n```\nval mcpVersion = \"0.4.0\"\nval slf4jVersion = \"2.0.9\"\nval anthropicVersion = \"0.8.0\"\n\ndependencies {\n    implementation(\"io.modelcontextprotocol:kotlin-sdk:$mcpVersion\")\n    implementation(\"org.slf4j:slf4j-nop:$slf4jVersion\")\n    implementation(\"com.anthropic:anthropic-java:$anthropicVersion\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BOM in Maven for Version Management\nDESCRIPTION: Maven dependency management configuration using a Bill of Materials (BOM) to manage MCP dependency versions. This approach ensures consistent and tested versions across all MCP components.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>io.modelcontextprotocol.sdk</groupId>\n            <artifactId>mcp-bom</artifactId>\n            <version>0.8.1</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n----------------------------------------\n\nTITLE: Server Path Examples\nDESCRIPTION: Examples of correct path usage for different environments\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n# Relative path\nuv run client.py ./server/weather.py\n\n# Absolute path\nuv run client.py /Users/username/projects/mcp-server/weather.py\n\n# Windows path (either format works)\nuv run client.py C:/projects/mcp-server/weather.py\nuv run client.py C:\\\\projects\\\\mcp-server\\\\weather.py\n```\n\n----------------------------------------\n\nTITLE: Enabling Chrome DevTools for Claude Desktop using Bash\nDESCRIPTION: This command creates a developer_settings.json file to enable Chrome DevTools in Claude Desktop. It allows access to the developer tools for investigating client-side errors.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/debugging.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\necho '{\"allowDevTools\": true}' > ~/Library/Application\\ Support/Claude/developer_settings.json\n```\n\n----------------------------------------\n\nTITLE: Client Details Documentation in Markdown\nDESCRIPTION: Detailed markdown documentation for specific MCP clients including Claude Desktop App, Claude Code, 5ire, and BeeAI Framework. Contains feature lists and implementation notes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/clients.mdx#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Claude Desktop App\nThe Claude desktop application provides comprehensive support for MCP, enabling deep integration with local tools and data sources.\n\n**Key features:**\n- Full support for resources, allowing attachment of local files and data\n- Support for prompt templates\n- Tool integration for executing commands and scripts\n- Local server connections for enhanced privacy and security\n```\n\n----------------------------------------\n\nTITLE: Adding Optional Spring Framework Dependencies in Gradle\nDESCRIPTION: Gradle configuration for optional Spring-specific transport implementations. These dependencies enable integration with Spring WebFlux or Spring WebMVC when using the Spring Framework.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/sdk/java/mcp-overview.mdx#2025-04-22_snippet_3\n\nLANGUAGE: groovy\nCODE:\n```\n// Optional: Spring WebFlux-based SSE client and server transport\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-spring-webflux\")\n}\n\n// Optional: Spring WebMVC-based SSE server transport\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-spring-webmvc\")\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript MCP Servers with NPX\nDESCRIPTION: Command to install and run TypeScript-based MCP servers using NPX package runner\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/examples.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/server-memory\n```\n\n----------------------------------------\n\nTITLE: Installing NPM Globally on Windows\nDESCRIPTION: Bash command to install NPM globally on Windows, which may be necessary if the 'npx' command fails.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g npm\n```\n\n----------------------------------------\n\nTITLE: Installing MCP Client Dependencies - Windows Setup\nDESCRIPTION: Commands for creating project directory and installing required npm packages for Windows\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\n# Create project directory\nmd mcp-client-typescript\ncd mcp-client-typescript\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv\n\n# Install dev dependencies\nnpm install -D @types/node typescript\n\n# Create source file\nnew-item index.ts\n```\n\n----------------------------------------\n\nTITLE: Installing Python MCP Servers\nDESCRIPTION: Commands to install and run Python-based MCP servers using either uvx (recommended) or pip package manager\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/examples.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Using uvx\nuvx mcp-server-git\n\n# Using pip\npip install mcp-server-git\npython -m mcp_server_git\n```\n\n----------------------------------------\n\nTITLE: Checking Claude's MCP Logs on Windows\nDESCRIPTION: Bash command to view recent MCP-related logs on Windows for debugging purposes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntype \"%APPDATA%\\Claude\\logs\\mcp*.log\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Package.json for MCP Client\nDESCRIPTION: Package.json configuration with module type and build script settings\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc && chmod 755 build/index.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Windows MCP Server\nDESCRIPTION: JSON configuration example showing how to add environment variables, specifically APPDATA, to resolve path-related issues on Windows.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"brave-search\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-brave-search\"],\n    \"env\": {\n      \"APPDATA\": \"C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\\",\n      \"BRAVE_API_KEY\": \"...\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting PyPi Server Packages with MCP Inspector\nDESCRIPTION: Command syntax for inspecting server packages from PyPi. The example shows how to inspect a Git server package with a local repository path.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/inspector.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector uvx <package-name> <args>\n# For example\nnpx @modelcontextprotocol/inspector uvx mcp-server-git --repository ~/code/mcp/servers.git\n```\n\n----------------------------------------\n\nTITLE: Setting up Environment for MCP Client using UV\nDESCRIPTION: Commands to create a new Python project, set up a virtual environment, and install required packages using the UV package manager.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create project directory\nuv init mcp-client\ncd mcp-client\n\n# Create virtual environment\nuv venv\n\n# Activate virtual environment\n# On Windows:\n.venv\\Scripts\\activate\n# On Unix or MacOS:\nsource .venv/bin/activate\n\n# Install required packages\nuv add mcp anthropic python-dotenv\n\n# Remove boilerplate files\nrm main.py\n\n# Create our main file\ntouch client.py\n```\n\n----------------------------------------\n\nTITLE: Inspecting NPM Server Packages with MCP Inspector\nDESCRIPTION: Command syntax for inspecting server packages from NPM. The example demonstrates how to inspect a Postgres server package with connection parameters.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/docs/tools/inspector.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/inspector npx <package-name> <args>\n# For example\nnpx -y @modelcontextprotocol/inspector npx server-postgres postgres://127.0.0.1/testdb\n```\n\n----------------------------------------\n\nTITLE: Image Analysis Command Example\nDESCRIPTION: Example showing proper format for documenting image analysis commands with quotes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/CLAUDE.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ claude \"Analyze this image: /path/to/image.png\"\n```\n\n----------------------------------------\n\nTITLE: Building MCP Documentation Locally\nDESCRIPTION: Command to preview documentation changes on local development environment using Mintlify.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/CLAUDE.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev\n```\n\n----------------------------------------\n\nTITLE: Checking Claude's MCP Logs on MacOS/Linux\nDESCRIPTION: Bash command to view recent MCP-related logs and follow new log entries on MacOS/Linux for debugging purposes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntail -n 20 -f ~/Library/Logs/Claude/mcp*.log\n```\n\n----------------------------------------\n\nTITLE: CLI Command Format Example\nDESCRIPTION: Example showing the two-line format for documenting CLI commands with prompt.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/CLAUDE.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ claude\n> /command\n```\n\n----------------------------------------\n\nTITLE: Running Filesystem MCP Server Manually on Windows\nDESCRIPTION: Bash command to manually run the Filesystem MCP Server on Windows for troubleshooting purposes.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/server-filesystem C:\\Users\\username\\Desktop C:\\Users\\username\\Downloads\n```\n\n----------------------------------------\n\nTITLE: Setting up Anthropic API key in .env file\nDESCRIPTION: Environment variable configuration for storing the Anthropic API key securely in a .env file.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nANTHROPIC_API_KEY=your_key_here\n```\n\n----------------------------------------\n\nTITLE: Adding .env to .gitignore\nDESCRIPTION: Command to ensure the .env file containing sensitive API keys is excluded from version control.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/tutorials/building-a-client-node.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\necho \".env\" >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: TypeScript Configuration for MCP Client\nDESCRIPTION: TypeScript compiler options and project configuration\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/client.mdx#2025-04-22_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"index.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Feature Support Matrix in Markdown\nDESCRIPTION: A markdown table showing MCP feature support across different client applications. Includes checkmarks and crosses to indicate feature availability.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/clients.mdx#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Client                                      | [Resources] | [Prompts] | [Tools] | [Sampling] | Roots | Notes                                                                        |\n|---------------------------------------------|-------------|-----------|---------|------------|--------|-----------------------------------------------------------------------------|\n| [Claude Desktop App][Claude]                |           |         |       |          |     | Full support for all MCP features                                           |\n```\n\n----------------------------------------\n\nTITLE: Installing Mintlify CLI for MCP Documentation Development\nDESCRIPTION: Command to install the Mintlify CLI globally using npm. This tool is required for previewing documentation changes locally.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g mintlify\n```\n\n----------------------------------------\n\nTITLE: Running Mintlify for Local MCP Documentation Preview\nDESCRIPTION: Command to start the Mintlify development server for previewing local changes to the MCP documentation.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev\n```\n\n----------------------------------------\n\nTITLE: Verifying Node.js Installation\nDESCRIPTION: Bash command to check the installed version of Node.js, which is a prerequisite for running the Filesystem MCP Server.\nSOURCE: https://github.com/modelcontextprotocol/docs/blob/main/quickstart/user.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnode --version\n```"
  }
]