[
  {
    "owner": "jlowin",
    "repo": "fastmcp",
    "content": "TITLE: Defining a Simple Tool with `@tool` Decorator\nDESCRIPTION: This snippet demonstrates the basic usage of the `@mcp.tool()` decorator to transform a regular Python function into a tool that can be invoked by an LLM via the MCP protocol. The function `add` takes two integers as input, adds them, and returns the sum. The tool name and description are inferred from the function name and docstring, respectively.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"CalculatorServer\")\n\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Adds two integer numbers together.\"\"\"\n    return a + b\n```\n\n----------------------------------------\n\nTITLE: Defining a Tool with the @mcp.tool Decorator in Python\nDESCRIPTION: Demonstrates defining a simple function `multiply` as a FastMCP tool using the `@mcp.tool()` decorator. Tools represent functions that the client can invoke remotely to perform actions.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@mcp.tool()\ndef multiply(a: float, b: float) -> float:\n    \"\"\"Multiplies two numbers together.\"\"\"\n    return a * b\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Dynamic Resources with Decorator - FastMCP - Python\nDESCRIPTION: Demonstrates the basic usage of the `@mcp.resource` decorator to define dynamic resources tied to Python functions. It shows examples of returning a simple string and a dictionary (auto-serialized to JSON). The decorated functions are executed lazily only when a client requests their specific resource URI.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Basic dynamic resource returning a string\n@mcp.resource(\"resource://greeting\")\ndef get_greeting() -> str:\n    \"\"\"Provides a simple greeting message.\"\"\"\n    return \"Hello from FastMCP Resources!\"\n\n# Resource returning JSON data (dict is auto-serialized)\n@mcp.resource(\"data://config\")\ndef get_config() -> dict:\n    \"\"\"Provides application configuration as JSON.\"\"\"\n    return {\n        \"theme\": \"dark\",\n        \"version\": \"1.2.0\",\n        \"features\": [\"tools\", \"resources\"],\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing a FastMCP Server in Python\nDESCRIPTION: Shows how to create basic and instruction-equipped `FastMCP` server instances using the class constructor. Key parameters include `name` for identification and `instructions` to guide client interaction.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\n# Create a basic server instance\nmcp = FastMCP(name=\"MyAssistantServer\")\n\n# You can also add instructions for how to interact with the server\nmcp_with_instructions = FastMCP(\n    name=\"HelpfulAssistant\",\n    instructions=\"This server provides data analysis tools. Call get_average() to analyze numerical data.\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Resource Template with @mcp.resource in Python\nDESCRIPTION: Shows how to create a parameterized resource `get_user_profile` using `@mcp.resource(\"users://{user_id}/profile\")`. URI path parameters like `{user_id}` are automatically extracted and passed as arguments to the decorated function.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n@mcp.resource(\"users://{user_id}/profile\")\ndef get_user_profile(user_id: int) -> dict:\n    \"\"\"Retrieves a user's profile by ID.\"\"\"\n    # The {user_id} in the URI is extracted and passed to this function\n    return {\"id\": user_id, \"name\": f\"User {user_id}\", \"status\": \"active\"}\n```\n\n----------------------------------------\n\nTITLE: Accessing Context in a Tool Function - Python\nDESCRIPTION: Demonstrates how to access the `Context` object within a FastMCP tool function. The `Context` object provides access to MCP features like logging and resource access. The context parameter is type-hinted as `Context` and injected automatically by FastMCP.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"ContextDemo\")\n\n@mcp.tool()\nasync def process_file(file_uri: str, ctx: Context) -> str:\n    \"\"\"Processes a file, using context for logging and resource access.\"\"\"\n    request_id = ctx.request_id\n    await ctx.info(f\"[{request_id}] Starting processing for {file_uri}\")\n\n    try:\n        # Use context to read a resource\n        contents_list = await ctx.read_resource(file_uri)\n        if not contents_list:\n            await ctx.warning(f\"Resource {file_uri} is empty.\")\n            return \"Resource empty\"\n\n        data = contents_list[0].content # Assuming TextResourceContents\n        await ctx.debug(f\"Read {len(data)} bytes from {file_uri}\")\n\n        # Report progress\n        await ctx.report_progress(progress=50, total=100)\n        \n        # Simulate work\n        processed_data = data.upper() # Example processing\n\n        await ctx.report_progress(progress=100, total=100)\n        await ctx.info(f\"Processing complete for {file_uri}\")\n\n        return f\"Processed data length: {len(processed_data)}\"\n\n    except Exception as e:\n        # Use context to log errors\n        await ctx.error(f\"Error processing {file_uri}: {str(e)}\")\n        raise # Re-raise to send error back to client\n```\n\n----------------------------------------\n\nTITLE: Defining a Resource with the @mcp.resource Decorator in Python\nDESCRIPTION: Illustrates how to define a data resource `get_config` using the `@mcp.resource(\"data://config\")` decorator. Resources expose data sources, identified by a URI, that clients can read.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@mcp.resource(\"data://config\")\ndef get_config() -> dict:\n    \"\"\"Provides the application configuration.\"\"\"\n    return {\"theme\": \"dark\", \"version\": \"1.0\"}\n```\n\n----------------------------------------\n\nTITLE: Running a FastMCP Server using the `__main__` Block in Python\nDESCRIPTION: Presents the standard pattern for making a FastMCP server executable directly (`python my_server.py`). It defines a simple tool and calls `mcp.run()` within an `if __name__ == \"__main__\":` block, ensuring compatibility with MCP clients and preventing execution on import. Comments illustrate specifying transport options.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n# my_server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    \"\"\"Greet a user by name.\"\"\"\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # This code only runs when the file is executed directly\n    \n    # Basic run with default settings (stdio transport)\n    mcp.run()\n    \n    # Or with specific transport and parameters\n    # mcp.run(transport=\"sse\", host=\"127.0.0.1\", port=9000)\n```\n\n----------------------------------------\n\nTITLE: Running the FastMCP Server with __main__ Block in Python\nDESCRIPTION: This snippet shows how to run the FastMCP server directly by adding a __main__ block that calls the 'run' method on the FastMCP server instance. It assumes you have an existing server and tools defined in the same file. Running 'python my_server.py' will start the MCP server using the default stdio transport. Including the __main__ guard is recommended as best practice to ensure consistent server execution, although FastMCP CLI does not require it.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Adding a Tool to the FastMCP Server in Python\nDESCRIPTION: This snippet adds a functional tool to the FastMCP server by defining a Python function decorated with @mcp.tool(). The tool named 'greet' takes a string parameter 'name' and returns a greeting message. Prerequisites include an existing FastMCP server instance 'mcp'. This enables the server to expose the 'greet' tool for remote invocation. The input is a string 'name', and the output is a personalized greeting string.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Prompts with @prompt Decorator in Python\nDESCRIPTION: Demonstrates how to create basic prompts using the @mcp.prompt decorator. The first example returns a string which is converted to a UserMessage, and the second returns a specific UserMessage object.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\nfrom fastmcp.prompts.prompt import UserMessage, AssistantMessage, Message\n\nmcp = FastMCP(name=\"PromptServer\")\n\n# Basic prompt returning a string (converted to UserMessage)\n@mcp.prompt()\ndef ask_about_topic(topic: str) -> str:\n    \"\"\"Generates a user message asking for an explanation of a topic.\"\"\"\n    return f\"Can you please explain the concept of '{topic}'?\"\n\n# Prompt returning a specific message type\n@mcp.prompt()\ndef generate_code_request(language: str, task_description: str) -> UserMessage:\n    \"\"\"Generates a user message requesting code generation.\"\"\"\n    content = f\"Write a {language} function that performs the following task: {task_description}\"\n    return UserMessage(content=content)\n```\n\n----------------------------------------\n\nTITLE: Complete FastMCP OpenAPI Integration Example\nDESCRIPTION: A full working example that demonstrates creating an MCP server from a PetStore OpenAPI spec. Shows how to configure the client, create the server, list the generated components, and start the MCP server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport httpx\nfrom fastmcp import FastMCP\n\n# Sample OpenAPI spec for a Pet Store API\npetstore_spec = {\n    \"openapi\": \"3.0.0\",\n    \"paths\": {\n        \"/pets\": {\n            \"get\": {\n                \"operationId\": \"listPets\",\n                \"summary\": \"List all pets\"\n            },\n            \"post\": {\n                \"operationId\": \"createPet\",\n                \"summary\": \"Create a new pet\"\n            }\n        },\n        \"/pets/{petId}\": {\n            \"get\": {\n                \"operationId\": \"getPet\",\n                \"summary\": \"Get a pet by ID\",\n                \"parameters\": [\n                    {\n                        \"name\": \"petId\",\n                        \"in\": \"path\",\n                        \"required\": True,\n                        \"schema\": {\"type\": \"string\"}\n                    }\n                ]\n            }\n        }\n    }\n}\n\nasync def main():\n    # Client for the Pet Store API\n    client = httpx.AsyncClient(base_url=\"https://petstore.example.com/api\")\n    \n    # Create the MCP server\n    mcp = await FastMCP.from_openapi(\n        openapi_spec=petstore_spec,\n        client=client,\n        name=\"PetStore\"\n    )\n    \n    # List what components were created\n    tools = await mcp.list_tools()\n    resources = await mcp.list_resources()\n    templates = await mcp.list_resource_templates()\n    \n    print(f\"Tools: {len(tools)}\")          # Should include createPet\n    print(f\"Resources: {len(resources)}\")  # Should include listPets\n    print(f\"Templates: {len(templates)}\")  # Should include getPet\n    \n    # Start the MCP server\n    mcp.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Tool with Pydantic Models for Structured Inputs\nDESCRIPTION: This example utilizes Pydantic models to handle structured and validated inputs. It defines a `ReservationRequest` model, which specifies the expected structure for reservation details, including validation rules (e.g., `gt=0` for guests, `date` field).  The `make_reservation` tool function uses the `ReservationRequest` as a parameter type and receives validated data from incoming requests. This shows how to combine Pydantic and FastMCP for robust data validation and handling.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\nfrom datetime import date\n\nclass ReservationRequest(BaseModel):\n    guest_name: str = Field(description=\"Full name of the guest making the reservation.\")\n    check_in: date\n    check_out: date\n    room_type: Literal[\"standard\", \"deluxe\", \"suite\"] = Field(default=\"standard\", description=\"Type of room requested.\")\n    guests: int = Field(gt=0, description=\"Number of guests (must be positive).\")\n    special_requests: Optional[str] = Field(default=None, description=\"Any special requests for the stay.\")\n\n@mcp.tool()\ndef make_reservation(request: ReservationRequest) -> dict:\n    \"\"\"Creates a new hotel reservation based on the provided details.\"\"\"\n    # Pydantic automatically validates the incoming 'request' data\n    # against the ReservationRequest model before this function runs.\n    print(f\"Making reservation for {request.guest_name}...\")\n    # Implementation...\n    return {\n        \"reservation_id\": \"R12345\",\n        \"status\": \"confirmed\",\n        \"guest\": request.guest_name,\n        \"dates\": f\"{request.check_in} to {request.check_out}\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating a Proxy with from_client (Python)\nDESCRIPTION: This Python code snippet demonstrates the core functionality of creating a proxy server using the `FastMCP.from_client()` method.  It configures a `Client` object that points to a backend server.  It then uses this client to create a proxy `FastMCP` server.  The proxy server forwards requests to the backend server specified in the client. No special handling is necessary for different transports.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/proxy.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\n\n# Create a client configured to talk to the backend server\n# This could be any MCP server - remote, local, or using any transport\nbackend_client = Client(\"backend_server.py\")  # Could be \"http://remote.server/sse\", etc.\n\n# Create the proxy server with from_client()\nproxy_server = FastMCP.from_client(\n    backend_client,\n    name=\"MyProxyServer\"  # Optional settings for the proxy\n)\n\n# That's it! You now have a proxy FastMCP server that can be used\n# with any transport (SSE, stdio, etc.) just like any other FastMCP server\n```\n\n----------------------------------------\n\nTITLE: Proxying an MCP Server using FastMCP in Python\nDESCRIPTION: Demonstrates creating a FastMCP server that acts as a proxy for another MCP server (local or remote). It initializes an MCP `Client` connected to the target server (`backend`) and then uses `FastMCP.from_client(backend)` to create a new FastMCP instance that mirrors the backend's interface.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\n\nbackend = Client(\"http://example.com/mcp/sse\")\nproxy = FastMCP.from_client(backend, name=\"ProxyServer\")\n# Now use the proxy like any FastMCP server\n```\n\n----------------------------------------\n\nTITLE: Composing FastMCP Servers using `mount` in Python\nDESCRIPTION: Shows a basic example of server composition. A `sub` server instance (with a `hello` tool) is mounted onto a `main` server instance using `main.mount(\"sub\", sub)`. This makes the sub-server's components accessible under the specified prefix (`sub/`) on the main server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n# Example: Importing a subserver\nfrom fastmcp import FastMCP\nimport asyncio\n\nmain = FastMCP(name=\"Main\")\nsub = FastMCP(name=\"Sub\")\n\n@sub.tool()\ndef hello(): \n    return \"hi\"\n\nmain.mount(\"sub\", sub)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running a FastMCP Server in Python\nDESCRIPTION: This snippet demonstrates how to create a FastMCP server named \"Demo ðŸš€\" using the FastMCP Python library. It defines a tool called 'add' decorated with @mcp.tool(), which takes two integers and returns their sum. The main entry point calls mcp.run() to start the server and handle incoming MCP requests. The snippet requires the fastmcp package and Python 3. Key inputs are two integers (a and b) provided when the tool is invoked, and the output is their integer sum. This setup abstracts the MCP protocol complexity, allowing rapid development of MCP servers with minimal boilerplate.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/welcome.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"Demo ðŸš€\")\n\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n----------------------------------------\n\nTITLE: LLM Sampling with System Prompt - Python\nDESCRIPTION: Demonstrates LLM sampling with a system prompt and user message. Shows how to use the `system_prompt`, `temperature`, and `max_tokens` parameters to control the LLM's behavior.  Uses the `ctx.sample` to create and send a message to an LLM.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def generate_example(concept: str, ctx: Context) -> str:\n    \"\"\"Generate a Python code example for a given concept.\"\"\"\n    # Using a system prompt and a user message\n    response = await ctx.sample(\n        messages=f\"Write a simple Python code example demonstrating '{concept}'.\",\n        system_prompt=\"You are an expert Python programmer. Provide concise, working code examples without explanations.\",\n        temperature=0.7,\n        max_tokens=300\n    )\n    \n    code_example = response.text\n    return f\"```python\\n{code_example}\\n```\"\n```\n\n----------------------------------------\n\nTITLE: LLM Sampling with Context - Python\nDESCRIPTION: Shows how to request the client's LLM to generate text using the `Context` object. Demonstrates the use of the `ctx.sample` method to send prompts to the LLM. Shows how to process the LLM's response.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def analyze_sentiment(text: str, ctx: Context) -> dict:\n    \"\"\"Analyze the sentiment of a text using the client's LLM.\"\"\"\n    # Create a sampling prompt asking for sentiment analysis\n    prompt = f\"Analyze the sentiment of the following text as positive, negative, or neutral. Just output a single word - 'positive', 'negative', or 'neutral'. Text to analyze: {text}\"\n    \n    # Send the sampling request to the client's LLM\n    response = await ctx.sample(prompt)\n    \n    # Process the LLM's response\n    sentiment = response.text.strip().lower()\n    \n    # Map to standard sentiment values\n    if \"positive\" in sentiment:\n        sentiment = \"positive\"\n    elif \"negative\" in sentiment:\n        sentiment = \"negative\"\n    else:\n        sentiment = \"neutral\"\n    \n    return {\"text\": text, \"sentiment\": sentiment}\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Templates with FastMCP in Python\nDESCRIPTION: This snippet shows how to define a resource template using FastMCP where required function parameters must appear in the URI template and optional parameters can have default values. It demonstrates creating a FastMCP instance, registering a resource with a URI template containing a required parameter, and implementing a function that uses default values for parameters not in the template. Dependencies include the fastmcp package. Inputs are the URI parameters parsed from the URI and function parameters with defaults, and the output is a dictionary with the search query and results.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"search://{query}\")\ndef search_resources(query: str, max_results: int = 10, include_archived: bool = False) -> dict:\n    \"\"\"Search for resources matching the query string.\"\"\"\n    # Only 'query' is required in the URI, the other parameters use their defaults\n    results = perform_search(query, limit=max_results, archived=include_archived)\n    return {\n        \"query\": query,\n        \"max_results\": max_results,\n        \"include_archived\": include_archived,\n        \"results\": results\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating a Full MCP Server with Tools and Resources\nDESCRIPTION: A more complete example showing how to create an MCP server with tools for calculations and a dynamic resource for greetings.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# server.py\nfrom fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n# Add an addition tool\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n# Add a dynamic greeting resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -> str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n```\n\n----------------------------------------\n\nTITLE: Testing FastMCP Server with Asynchronous Client in Python\nDESCRIPTION: This snippet illustrates testing the FastMCP server by creating an asynchronous client that connects to the server instance and calls the 'greet' tool. It imports both FastMCP and Client classes. The asynchronous function 'call_tool' opens a client context, invokes the 'greet' tool with a 'name' parameter, and prints the result. It uses 'asyncio.run' to execute the async call. Inputs include the name string, and output is the greeting message printed to console. Requires an asynchronous execution environment.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nclient = Client(mcp)\n\nasync def call_tool(name: str):\n    async with client:\n        result = await client.call_tool(\"greet\", {\"name\": name})\n        print(result)\n\nasyncio.run(call_tool(\"Ford\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Asynchronous Resources with Decorator - FastMCP - Python\nDESCRIPTION: Shows how to define a dynamic resource function as an asynchronous function (`async def`) using the `@mcp.resource` decorator. This pattern is essential for resource functions that perform I/O operations (like reading files or making network calls) to prevent blocking the FastMCP server's event loop. Includes an example using `aiofiles` for asynchronous file reading.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport aiofiles\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"file:///app/data/important_log.txt\", mime_type=\"text/plain\")\nasync def read_important_log() -> str:\n    \"\"\"Reads content from a specific log file asynchronously.\"\"\"\n    try:\n        async with aiofiles.open(\"/app/data/important_log.txt\", mode=\"r\") as f:\n            content = await f.read()\n        return content\n    except FileNotFoundError:\n        return \"Log file not found.\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Tool with Type Annotations and Optional Parameter\nDESCRIPTION: This code shows how to use type annotations and optional parameters to create a tool that processes numerical data. The `process_data` function accepts a list of floats (`data`), an operation type (`operation`), an optional precision (`precision`) with a default value of 2, and an optional description. The function returns a dictionary containing the operation performed, the result, and the description.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Optional, Union\nfrom pydantic import BaseModel, Field\n\n# Example using various type hints\n@mcp.tool()\ndef process_data(\n    data: list[float],                             # List of floats\n    operation: Literal[\"sum\", \"average\", \"max\"],   # Fixed choices\n    precision: int = 2,                            # Optional int with default\n    description: str | None = None                 # Optional string (can be None)\n) -> dict:\n    \"\"\"Process numerical data with the specified operation.\"\"\"\n    result = 0.0\n    if operation == \"sum\":\n        result = sum(data)\n    elif operation == \"average\":\n        result = sum(data) / len(data) if data else 0.0\n    elif operation == \"max\":\n        result = float(max(data)) if data else 0.0\n\n    return {\n        \"operation\": operation,\n        \"result\": round(result, precision),\n        \"description\": description\n    }\n```\n\n----------------------------------------\n\nTITLE: Using Type Annotations in FastMCP Prompts in Python\nDESCRIPTION: Demonstrates how to use type annotations with Pydantic Fields in prompt functions to validate parameters, provide descriptions, and generate schemas for the MCP protocol.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import Field\nfrom typing import Literal, Optional\n\n@mcp.prompt()\ndef generate_content_request(\n    topic: str = Field(description=\"The main subject to cover\"),\n    format: Literal[\"blog\", \"email\", \"social\"] = \"blog\",\n    tone: str = \"professional\",\n    word_count: Optional[int] = None\n) -> str:\n    \"\"\"Create a request for generating content in a specific format.\"\"\"\n    prompt = f\"Please write a {format} post about {topic} in a {tone} tone.\"\n    \n    if word_count:\n        prompt += f\" It should be approximately {word_count} words long.\"\n        \n    return prompt\n```\n\n----------------------------------------\n\nTITLE: Configuring Required vs Optional Parameters in FastMCP Prompts in Python\nDESCRIPTION: Shows how to define required parameters (without default values) and optional parameters (with default values) in prompt functions.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@mcp.prompt()\ndef data_analysis_prompt(\n    data_uri: str,                        # Required - no default value\n    analysis_type: str = \"summary\",       # Optional - has default value\n    include_charts: bool = False          # Optional - has default value\n) -> str:\n    \"\"\"Creates a request to analyze data with specific parameters.\"\"\"\n    prompt = f\"Please perform a '{analysis_type}' analysis on the data found at {data_uri}.\"\n    if include_charts:\n        prompt += \" Include relevant charts and visualizations.\"\n    return prompt\n```\n\n----------------------------------------\n\nTITLE: Interacting with FastMCP Server Using Python Client\nDESCRIPTION: This snippet demonstrates how to interact with a FastMCP server from a separate Python client file. It creates a Client instance pointed at the server file and defines an async function to call the 'greet' tool remotely. Within an asynchronous client context, it invokes the tool passing the 'name' parameter and prints the received greeting. This example requires an asynchronous runtime environment and FastMCP installed on the client side.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\n\nclient = Client(\"my_server.py\")\n\nasync def call_tool(name: str):\n    async with client:\n        result = await client.call_tool(\"greet\", {\"name\": name})\n        print(result)\n\nasyncio.run(call_tool(\"Ford\"))\n```\n\n----------------------------------------\n\nTITLE: Tool with Optional and Required Parameters\nDESCRIPTION: This snippet demonstrates the use of required and optional parameters with default values. The `search_products` function has a required `query` parameter (a string) and two optional parameters: `max_results` (an integer with a default value of 10) and `sort_by` (a string with a default value of \"relevance\"). This shows how to structure function signatures to define which parameters are required and to provide default values for others.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\ndef search_products(\n    query: str,                # Required - no default value\n    max_results: int = 10,     # Optional - has default value\n    sort_by: str = \"relevance\" # Optional - has default value\n) -> list[dict]:\n    \"\"\"Search the product catalog.\"\"\"\n    # Implementation...\n    print(f\"Searching for '{query}', max {max_results}, sorted by {sort_by}\")\n    return [{\"id\": 1, \"name\": \"Sample Product\"}]\n```\n\n----------------------------------------\n\nTITLE: Resource Access with Context - Python\nDESCRIPTION: Demonstrates reading data from resources registered with the FastMCP server using the `Context` object. Shows how to use the `ctx.read_resource` method to access resource content. Assumes resources are registered and accessible by URI.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def summarize_document(document_uri: str, ctx: Context) -> str:\n    \"\"\"Summarize a document by its resource URI.\"\"\"\n    # Read the document content\n    content_list = await ctx.read_resource(document_uri)\n    \n    if not content_list:\n        return \"Document is empty\"\n    \n    document_text = content_list[0].content\n    \n    # Example: Generate a simple summary (length-based)\n    words = document_text.split()\n    total_words = len(words)\n    \n    await ctx.info(f\"Document has {total_words} words\")\n    \n    # Return a simple summary\n    if total_words > 100:\n        summary = \" \".join(words[:100]) + \"...\"\n        return f\"Summary ({total_words} words total): {summary}\"\n    else:\n        return f\"Full document ({total_words} words): {document_text}\"\n```\n\n----------------------------------------\n\nTITLE: Error Handling in FastMCP Tools\nDESCRIPTION: Shows how to handle errors in FastMCP tools by raising standard Python exceptions, which are automatically converted to MCP error responses for the client/LLM.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\ndef divide(a: float, b: float) -> float:\n    \"\"\"Divide a by b.\"\"\"\n    if b == 0:\n        # Raise a standard exception\n        raise ValueError(\"Division by zero is not allowed.\")\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers.\")\n    return a / b\n```\n\n----------------------------------------\n\nTITLE: Accessing MCP Session Context in Prompts in Python\nDESCRIPTION: Demonstrates how to access the MCP Context object in prompt functions to use features like logging, resource access, and LLM sampling.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Context\n\n@mcp.prompt()\nasync def generate_report_request(report_type: str, ctx: Context) -> str:\n    \"\"\"Generates a request for a report based on available data.\"\"\"\n    # Log the request\n    await ctx.info(f\"Generating prompt for report type: {report_type}\")\n    \n    # Could potentially use ctx.read_resource to fetch data\n    # Or ctx.sample to get additional input from the LLM\n    \n    return f\"Please create a {report_type} report based on the available data.\"\n```\n\n----------------------------------------\n\nTITLE: Using FastMCP Client Methods for Full MCP Protocol Interaction in Python\nDESCRIPTION: This snippet details the various methods exposed by fastmcp.Client to interact with MCP servers. Functions include listing tools and resources, calling tools, reading resources, requesting prompts, reporting progress, and connectivity testing. Inputs are typically string identifiers; outputs are results or server responses. All operations are async. Requires a valid Client instance for an accessible MCP server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nasync with Client(\"path/to/server\") as client:\n    # List available tools\n    tools = await client.list_tools()\n    \n    # List available resources\n    resources = await client.list_resources()\n    \n    # Call a tool with arguments\n    result = await client.call_tool(\"generate_report\", {\"user_id\": 123})\n    \n    # Read a resource\n    user_data = await client.read_resource(\"db://users/123/profile\")\n        \n    # Get a prompt\n    greeting = await client.get_prompt(\"welcome\", {\"name\": \"Alice\"})\n    \n    # Send progress updates\n    await client.progress(\"task-123\", 50, 100)  # 50% complete\n    \n    # Basic connectivity testing\n    await client.ping()\n\n```\n\n----------------------------------------\n\nTITLE: Returning Different Data Types in FastMCP\nDESCRIPTION: Demonstrates how to return different data types (like images) from FastMCP tool functions and how these are automatically converted to appropriate MCP content formats.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.utilities.types import Image\nfrom PIL import Image as PILImage\nimport io\n\n@mcp.tool()\ndef generate_image(width: int, height: int, color: str) -> Image:\n    \"\"\"Generates a solid color image.\"\"\"\n    # Create image using Pillow\n    img = PILImage.new(\"RGB\", (width, height), color=color)\n\n    # Save to a bytes buffer\n    buffer = io.BytesIO()\n    img.save(buffer, format=\"PNG\")\n    img_bytes = buffer.getvalue()\n\n    # Return using FastMCP's Image helper\n    return Image(data=img_bytes, format=\"png\")\n\n@mcp.tool()\ndef do_nothing() -> None:\n    \"\"\"This tool performs an action but returns no data.\"\"\"\n    print(\"Performing a side effect...\")\n    return None\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple MCP Server\nDESCRIPTION: Demonstrates how to create a basic MCP server with a tool function that adds two numbers. The server can be run using the fastmcp CLI.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"Demo ðŸš€\")\n\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Using Context Object in FastMCP Tools\nDESCRIPTION: Demonstrates how to access MCP features like logging, resource reading, and progress reporting through the Context object in FastMCP tools.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"ContextDemo\")\n\n@mcp.tool()\nasync def process_data(data_uri: str, ctx: Context) -> dict:\n    \"\"\"Process data from a resource with progress reporting.\"\"\"\n    await ctx.info(f\"Processing data from {data_uri}\")\n    \n    # Read a resource\n    resource = await ctx.read_resource(data_uri)\n    data = resource[0].content if resource else \"\"\n    \n    # Report progress\n    await ctx.report_progress(progress=50, total=100)\n    \n    # Example request to the client's LLM for help\n    summary = await ctx.sample(f\"Summarize this in 10 words: {data[:200]}\")\n    \n    await ctx.report_progress(progress=100, total=100)\n    return {\n        \"length\": len(data),\n        \"summary\": summary.text\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Prompt with the @mcp.prompt Decorator in Python\nDESCRIPTION: Demonstrates creating a reusable prompt template function `analyze_data` using the `@mcp.prompt()` decorator. Prompts generate formatted strings based on input parameters, typically for guiding LLM interactions.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n@mcp.prompt()\ndef analyze_data(data_points: list[float]) -> str:\n    \"\"\"Creates a prompt asking for analysis of numerical data.\"\"\"\n    formatted_data = \", \".join(str(point) for point in data_points)\n    return f\"Please analyze these data points: {formatted_data}\"\n```\n\n----------------------------------------\n\nTITLE: Registering Tools and Resources Using MCPMixin in FastMCP (Python)\nDESCRIPTION: This snippet demonstrates how to subclass MCPMixin and use the @mcp_tool and @mcp_resource decorators to define methods as FastMCP tools and resources. Dependencies include the fastmcp library and specifically the MCPMixin and decorator imports. The code shows both tool and resource method definition, object instantiation, and two ways to register all decorated methods with a FastMCP serverâ€”optionally using a prefix to avoid naming collisions for multiple instances. Key parameters include the decorator arguments (such as name, description, uri) and the optional prefix for registration; the expected input is a FastMCP instance and an instance of the user subclass, and the registered names/URIs can be controlled via prefix and separators.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/contrib/mcp_mixin/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\nfrom fastmcp.contrib.mcp_mixin import MCPMixin, mcp_tool, mcp_resource\n\nclass MyComponent(MCPMixin):\n    @mcp_tool(name=\"my_tool\", description=\"Does something cool.\")\n    def tool_method(self):\n        return \"Tool executed!\"\n\n    @mcp_resource(uri=\"component://data\")\n    def resource_method(self):\n        return {\"data\": \"some data\"}\n\nmcp_server = FastMCP()\ncomponent = MyComponent()\n\n# Register all decorated methods with a prefix\n# Useful if you will have multiple instantiated objects of the same class\n# and want to avoid name collisions.\ncomponent.register_all(mcp_server, prefix=\"my_comp\") \n\n# Register without a prefix\n# component.register_all(mcp_server) \n\n# Now 'my_comp_my_tool' tool and 'my_comp+component://data' resource are registered (if prefix used)\n# Or 'my_tool' and 'component://data' are registered (if no prefix used)\n```\n\n----------------------------------------\n\nTITLE: Calling a Tool on FastMCP Server (Python)\nDESCRIPTION: Shows how to invoke a specific tool on the connected server using the `call_tool()` method. It takes the tool name and an optional dictionary of arguments, returning a list of content objects (e.g., text, image) produced by the tool.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nresult = await client.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n# result -> list[mcp.types.TextContent | mcp.types.ImageContent | ...]\nprint(result[0].text) # Assuming TextContent, e.g., '8'\n```\n\n----------------------------------------\n\nTITLE: Tool with Custom Name, Description, and Tags\nDESCRIPTION: This snippet shows how to override the default tool name and description, and add tags using arguments of the `@mcp.tool` decorator.  The `find_products` tool is given a custom name and description, and tags are provided for categorization. This demonstrates how to customize the tool's metadata as exposed to the LLM.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool(\n    name=\"find_products\",           # Custom tool name for the LLM\n    description=\"Search the product catalog with optional category filtering.\", # Custom description\n    tags={\"catalog\", \"search\"}      # Optional tags for organization/filtering\n)\ndef search_products_implementation(query: str, category: str | None = None) -> list[dict]:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    # Implementation...\n    print(f\"Searching for '{query}' in category '{category}'\")\n    return [{\"id\": 2, \"name\": \"Another Product\"}]\n```\n\n----------------------------------------\n\nTITLE: Registering Instance Methods with FastMCP in Python\nDESCRIPTION: This snippet demonstrates how to properly register instance methods with FastMCP by first creating an object instance, then binding its methods, and finally registering the bound methods. This approach ensures that 'self' is correctly bound, preventing errors when calling the registered tools or resources.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/decorating-methods.mdx#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    def add(self, x, y):\n        return x + y\n    \n    def get_resource(self, param: str):\n        return f\"Resource data for {param}\"\n\n# Create an instance of MyClass\nobj = MyClass()\n\n# Register bound methods\nmcp.add_tool(obj.add)\nmcp.add_resource_fn(obj.get_resource, uri=\"resource://{param}\")\n\n# Call the tool\nawait mcp.call_tool('add', {'x': 1, 'y': 2})  # Returns 3\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with Auto-Inferred Transports (Python)\nDESCRIPTION: Demonstrates how the FastMCP `Client` automatically infers the correct `ClientTransport` based on the type of input provided during initialization. It shows examples for an in-memory server instance, SSE and WebSocket URLs, and a path to a Python script, printing the inferred transport type for each.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom fastmcp import Client, FastMCP\n\n# Example transports (more details in Transports page)\nserver_instance = FastMCP(name=\"TestServer\") # In-memory server\nsse_url = \"http://localhost:8000/sse\"       # SSE server URL\nws_url = \"ws://localhost:9000\"             # WebSocket server URL\nserver_script = \"my_mcp_server.py\"         # Path to a Python server file\n\n# Client automatically infers the transport type\nclient_in_memory = Client(server_instance)\nclient_sse = Client(sse_url)\nclient_ws = Client(ws_url)\nclient_stdio = Client(server_script)\n\nprint(client_in_memory.transport)\nprint(client_sse.transport)\nprint(client_ws.transport)\nprint(client_stdio.transport)\n\n# Expected Output (types may vary slightly based on environment):\n# <FastMCP(server='TestServer')>\n# <SSE(url='http://localhost:8000/sse')>\n# <WebSocket(url='ws://localhost:9000')>\n# <PythonStdioTransport(command='python', args=['/path/to/your/my_mcp_server.py'])>\n```\n\n----------------------------------------\n\nTITLE: Importing FastMCP Subservers Using Python\nDESCRIPTION: This Python snippet demonstrates how to statically compose multiple FastMCP subservers into a main server by copying their components with prefixed names. The example defines two subservers (WeatherService and CalculatorService) with tools, resources, and prompts. The `import_server()` method asynchronously copies these components into the main server with a prefix to avoid naming conflicts. The snippet shows how to run the import asynchronously and then run the main server containing the combined components. Dependencies include the FastMCP framework and Python's asyncio library. Inputs include subservers and prefix strings, while outputs are the prefixed components accessible via the main server instance. Changes in subservers after import do not affect the main server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\nimport asyncio\n\n# --- Define Subservers ---\n\n# Weather Service\nweather_mcp = FastMCP(name=\"WeatherService\")\n\n@weather_mcp.tool()\ndef get_forecast(city: str) -> dict:\n    \"\"\"Get weather forecast.\"\"\"\n    return {\"city\": city, \"forecast\": \"Sunny\"}\n\n@weather_mcp.resource(\"data://cities/supported\")\ndef list_supported_cities() -> list[str]:\n    \"\"\"List cities with weather support.\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]\n\n# Calculator Service\ncalc_mcp = FastMCP(name=\"CalculatorService\")\n\n@calc_mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\n@calc_mcp.prompt()\ndef explain_addition() -> str:\n    \"\"\"Explain the concept of addition.\"\"\"\n    return \"Addition is the process of combining two or more numbers.\"\n\n# --- Define Main Server ---\nmain_mcp = FastMCP(name=\"MainApp\")\n\n# --- Import Subservers ---\nasync def setup():\n    # Import weather service with prefix \"weather\"\n    await main_mcp.import_server(\"weather\", weather_mcp)\n\n    # Import calculator service with prefix \"calc\"\n    await main_mcp.import_server(\"calc\", calc_mcp)\n\n# --- Now, main_mcp contains *copied* components ---\n# Tools:\n# - \"weather_get_forecast\"\n# - \"calc_add\"\n# Resources:\n# - \"weather+data://cities/supported\" (prefixed URI)\n# Prompts:\n# - \"calc_explain_addition\"\n\nif __name__ == \"__main__\":\n    # In a real app, you might run this async or setup imports differently\n    asyncio.run(setup())\n    # Run the main server, which now includes components from both subservers\n    main_mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Registering Class Methods with FastMCP Correctly in Python\nDESCRIPTION: This snippet illustrates how to properly register class methods with FastMCP by defining the class method normally, then registering it after the class is fully defined. This approach ensures the decorator captures the method with correct binding to the class, enabling proper method invocation without parameter errors.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/decorating-methods.mdx#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @classmethod\n    def from_string(cls, s):\n        return cls(s)\n\n# Register the class method after class definition\nmcp.add_tool(MyClass.from_string)\n\n# Can now use the registered method as needed\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in fastmcp Client Tool Calls Using Python\nDESCRIPTION: This asynchronous Python snippet demonstrates robust error handling when calling a remote tool named 'divide' via the fastmcp client. It uses an async context manager to manage the client lifecycle and catches specific exceptions such as fastmcp.client.ClientError for tool execution errors, ConnectionError for connectivity issues, and a generic Exception as a fallback. The example shows how to safely attempt a division operation and capture errors like division by zero from the server side. Dependencies include the fastmcp client library and proper async support. Inputs include tool name and parameters, outputs either the tool result or error messages printed to the console. The snippet is designed to be run inside an async environment and illustrates handling of server-side and connection errors gracefully.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nasync def safe_call_tool():\n    async with client:\n        try:\n            # Assume 'divide' tool exists and might raise ZeroDivisionError\n            result = await client.call_tool(\"divide\", {\"a\": 10, \"b\": 0})\n            print(f\"Result: {result}\")\n        except ClientError as e:\n            print(f\"Tool call failed: {e}\")\n        except ConnectionError as e:\n            print(f\"Connection failed: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example Output if division by zero occurs:\n# Tool call failed: Division by zero is not allowed.\n```\n\n----------------------------------------\n\nTITLE: Handling Different Return Types in FastMCP Prompts in Python\nDESCRIPTION: Shows how to return different types from prompt functions, including lists of messages to create conversations and dictionaries that are parsed as Message objects.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@mcp.prompt()\ndef roleplay_scenario(character: str, situation: str) -> list[Message]:\n    \"\"\"Sets up a roleplaying scenario with initial messages.\"\"\"\n    return [\n        UserMessage(f\"Let's roleplay. You are {character}. The situation is: {situation}\"),\n        AssistantMessage(\"Okay, I understand. I am ready. What happens next?\")\n    ]\n\n@mcp.prompt()\ndef ask_for_feedback() -> dict:\n    \"\"\"Generates a user message asking for feedback.\"\"\"\n    return {\"role\": \"user\", \"content\": \"What did you think of my previous response?\"}\n```\n\n----------------------------------------\n\nTITLE: Server-Side and Client-Side LLM Sampling with FastMCP in Python\nDESCRIPTION: This snippet covers advanced sampling in FastMCP where the server requests LLM completions by calling context.sample. Dependencies are fastmcp, marvin (or another LLM client), and fastmcp.client.sampling. Server tool functions (generate_poem, summarize_document) request completions using system prompts and document contents; the client supplies a sampling_handler to fulfill these requests using their preferred LLM. Async operation and coordination between server and client are required. Inputs are strings and URIs, and outputs are typically LLM-generated text. Proper error management and LLM integration are assumed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport marvin  # Or any other LLM client\nfrom fastmcp import Client, Context, FastMCP\nfrom fastmcp.client.sampling import RequestContext, SamplingMessage, SamplingParams\n\n# -- SERVER SIDE --\n# Create a server that requests LLM completions from the client\n\nmcp = FastMCP(\"Sampling Example\")\n\n@mcp.tool()\nasync def generate_poem(topic: str, context: Context) -> str:\n    \"\"\"Generate a short poem about the given topic.\"\"\"\n    # The server requests a completion from the client LLM\n    response = await context.sample(\n        f\"Write a short poem about {topic}\",\n        system_prompt=\"You are a talented poet who writes concise, evocative verses.\"\n    )\n    return response.text\n\n@mcp.tool()\nasync def summarize_document(document_uri: str, context: Context) -> str:\n    \"\"\"Summarize a document using client-side LLM capabilities.\"\"\"\n    # First read the document as a resource\n    doc_resource = await context.read_resource(document_uri)\n    doc_content = doc_resource[0].content  # Assuming single text content\n    \n    # Then ask the client LLM to summarize it\n    response = await context.sample(\n        f\"Summarize the following document:\\n\\n{doc_content}\",\n        system_prompt=\"You are an expert summarizer. Create a concise summary.\"\n    )\n    return response.text\n\n# -- CLIENT SIDE --\n# Create a client that handles the sampling requests\n\nasync def sampling_handler(\n    messages: list[SamplingMessage],\n    params: SamplingParams,\n    ctx: RequestContext,\n) -> str:\n    \"\"\"Handle sampling requests from the server using your preferred LLM.\"\"\"\n    # Extract the messages and system prompt\n    prompt = [m.content.text for m in messages if m.content.type == \"text\"]\n    system_instruction = params.systemPrompt or \"You are a helpful assistant.\"\n    \n    # Use your preferred LLM client to generate completions\n    return await marvin.say_async(\n        message=prompt,\n        instructions=system_instruction,\n    )\n\n# Connect them together\nasync with Client(mcp, sampling_handler=sampling_handler) as client:\n    result = await client.call_tool(\"generate_poem\", {\"topic\": \"autumn leaves\"})\n    print(result.content[0].text)\n\n```\n\n----------------------------------------\n\nTITLE: Mounting FastMCP Subservers Dynamically Using Python\nDESCRIPTION: This Python example shows how to compose FastMCP servers dynamically by mounting a subserver onto a main server using the `mount()` method. Unlike import, mounting creates a live link so that changes to the subserver (such as adding new tools) are immediately accessible through the main server via prefix-based delegation. The example defines a subserver with initial tools, mounts it synchronously to the main server, then adds additional tools dynamically. It demonstrates retrieving tool names and calling tools asynchronously via a client. Dependencies include FastMCP and its Client class, as well as Python's asyncio. Inputs are the subservers and prefix strings, with output being live-accessible, dynamic components.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom fastmcp import FastMCP, Client\n\n# --- Define Subserver ---\ndynamic_mcp = FastMCP(name=\"DynamicService\")\n@dynamic_mcp.tool()\ndef initial_tool(): return \"Initial Tool Exists\"\n\n# --- Define Main Server ---\nmain_mcp = FastMCP(name=\"MainAppLive\")\n\n# --- Mount Subserver (Sync operation) ---\nmain_mcp.mount(\"dynamic\", dynamic_mcp)\n\nprint(\"Mounted dynamic_mcp.\")\n\n# --- Add a tool AFTER mounting ---\n@dynamic_mcp.tool()\ndef added_later(): return \"Tool Added Dynamically!\"\n\nprint(\"Added 'added_later' tool to dynamic_mcp.\")\n\n# --- Test Access ---\nasync def test_dynamic_mount():\n    # Need to use await for get_tools now\n    tools_before = await main_mcp.get_tools()\n    print(\"Tools available via main_mcp:\", list(tools_before.keys()))\n    # Expected: ['dynamic_initial_tool', 'dynamic_added_later']\n\n    async with Client(main_mcp) as client:\n        # Call the dynamically added tool via the main server\n        result = await client.call_tool(\"dynamic_added_later\")\n        print(\"Result of calling dynamic_added_later:\", result[0].text)\n        # Expected: Tool Added Dynamically!\n\nif __name__ == \"__main__\":\n     # Need async context to test\n     asyncio.run(test_dynamic_mount())\n     # To run the server itself:\n     # main_mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Logging with Context - Python\nDESCRIPTION: Shows how to use the `Context` object for logging within a FastMCP tool function. Demonstrates the use of `ctx.debug`, `ctx.info`, `ctx.warning`, and `ctx.error` methods for sending log messages back to the client. The messages can be used for debugging and providing visibility into tool execution.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def analyze_data(data: list[float], ctx: Context) -> dict:\n    \"\"\"Analyze numerical data with logging.\"\"\"\n    await ctx.debug(\"Starting analysis of numerical data\")\n    await ctx.info(f\"Analyzing {len(data)} data points\")\n    \n    try:\n        result = sum(data) / len(data)\n        await ctx.info(f\"Analysis complete, average: {result}\")\n        return {\"average\": result, \"count\": len(data)}\n    except ZeroDivisionError:\n        await ctx.warning(\"Empty data list provided\")\n        return {\"error\": \"Empty data list\"}\n    except Exception as e:\n        await ctx.error(f\"Analysis failed: {str(e)}\")\n        raise\n```\n\n----------------------------------------\n\nTITLE: Composing FastMCP Servers using Mounting in Python\nDESCRIPTION: Illustrates how to structure larger MCP applications by defining modular FastMCP servers (e.g., for weather and news) and combining them using the `mount` method on a parent server. Mounting automatically prefixes tool names (e.g., `weather/get_forecast`) and resource URIs (e.g., `weather+data://temp/{city}`) to prevent naming conflicts between the sub-applications.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\n# --- Weather MCP ---\nweather_mcp = FastMCP(\"Weather Service\")\n\n@weather_mcp.tool()\ndef get_forecast(city: str): \n    return f\"Sunny in {city}\"\n\n@weather_mcp.resource(\"data://temp/{city}\")\ndef get_temp(city: str): \n    return 25.0\n\n# --- News MCP ---\nnews_mcp = FastMCP(\"News Service\")\n\n@news_mcp.tool()\ndef fetch_headlines():\n    return [\"Big news!\", \"Other news\"]\n\n@news_mcp.resource(\"data://latest_story\")\ndef get_story():\n    return \"A story happened.\"\n\n# --- Composite MCP ---\n\nmcp = FastMCP(\"Composite\")\n\n# Mount sub-apps with prefixes\nmcp.mount(\"weather\", weather_mcp) # Tools prefixed \"weather/\", resources prefixed \"weather+\"\nmcp.mount(\"news\", news_mcp)       # Tools prefixed \"news/\", resources prefixed \"news+\"\n\n@mcp.tool()\ndef ping(): \n    return \"Composite OK\"\n\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple URI Templates for a Single FastMCP Resource Function in Python\nDESCRIPTION: This snippet demonstrates how to register a single function as a resource with multiple URI templates using stacked @mcp.resource decorators in FastMCP. The function can handle different parameters that are conditionally provided based on the URI used. It shows how parameters default to None if not included in the URI template. The example includes a user lookup function accessible by either email or name, using FastMCP's resource registration. Required dependency is fastmcp. The function expects either 'name' or 'email' parameters and returns user lookup results or an error dictionary if none are provided.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Define a user lookup function that can be accessed by different identifiers\n@mcp.resource(\"users://email/{email}\")\n@mcp.resource(\"users://name/{name}\")\ndef lookup_user(name: str | None = None, email: str | None = None) -> dict:\n    \"\"\"Look up a user by either name or email.\"\"\"\n    if email:\n        return find_user_by_email(email) # pseudocode\n    elif name:\n        return find_user_by_name(name) # pseudocode\n    else:\n        return {\"error\": \"No lookup parameters provided\"}\n```\n\n----------------------------------------\n\nTITLE: Running a FastMCP Server with STDIO Transport in Python\nDESCRIPTION: Shows how to explicitly run a FastMCP server using the default Standard Input/Output (STDIO) transport by calling `mcp.run()` or `mcp.run(transport=\"stdio\")`. This mode is common for single-session client interactions where the client manages the server process lifecycle.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n# Run with stdio (default)\nmcp.run()  # or explicitly: mcp.run(transport=\"stdio\")\n```\n\n----------------------------------------\n\nTITLE: Setting Up FastMCP Utility Servers in Python\nDESCRIPTION: Initializes and imports FastMCP servers asynchronously, registers the 'process_and_analyze' tool with the main app, and begins the FastMCP main server. This script depends on the FastMCP library, as well as 'text_mcp' and 'data_mcp' servers. The tool function takes a record ID, simulates fetching record data, counts the words in its string representation, and returns an analysis string. The function expects an integer ID and outputs a formatted string summary.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Setup function for async imports\nasync def setup():\n    # Import the utility servers\n    await app.import_server(\"text\", text_mcp)\n    await app.import_server(\"data\", data_mcp)\n\n@app.tool()\ndef process_and_analyze(record_id: int) -> str:\n    \"\"\"Fetches a record and analyzes its string representation.\"\"\"\n    # In a real application, you'd use proper methods to interact between\n    # imported tools rather than accessing internal managers\n    \n    # Get record data\n    record = {\"id\": record_id, \"value\": random.random()}\n    \n    # Count words in the record string representation\n    word_count = len(str(record).split())\n    \n    return (\n        f\"Record {record_id} has {word_count} words in its string \"\n        f\"representation.\"\n    )\n\nif __name__ == \"__main__\":\n    # Run async setup before starting the server\n    asyncio.run(setup())\n    # Run the server\n    app.run()\n```\n\n----------------------------------------\n\nTITLE: Defining Data API Tools with FastMCP in Python\nDESCRIPTION: Implements a FastMCP server called 'DataAPI' for simulating data record fetching and table schema retrieval. The fetch_record tool provides dummy records keyed by ID and using random values. The get_table_schema resource outputs a sample schema definition for requested table names. This snippet employs FastMCP and Python standard libraries; expected input types are integers for record IDs and strings for table names. Outputs are dictionaries modeling records and table schemas.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\nimport random\nfrom typing import dict\n\ndata_mcp = FastMCP(name=\"DataAPI\")\n\n@data_mcp.tool()\ndef fetch_record(record_id: int) -> dict:\n    \"\"\"Fetches a dummy data record.\"\"\"\n    return {\"id\": record_id, \"value\": random.random()}\n\n@data_mcp.resource(\"data://schema/{table}\")\ndef get_table_schema(table: str) -> dict:\n    \"\"\"Provides a dummy schema for a table.\"\"\"\n    return {\"table\": table, \"columns\": [\"id\", \"value\"]}\n```\n\n----------------------------------------\n\nTITLE: Handling Images with FastMCP Image Helper in Python\nDESCRIPTION: This snippet shows how to use the fastmcp.Image class for input/output of image data in tool functions. It demonstrates creating thumbnails with PIL and loading images from disk as Image objects. Dependencies include fastmcp, PIL, and io. Inputs and outputs are Image instances with required bytes or file path. Outputs are automatically base64-encoded for MCP protocol compatibility. Limitations: image processing assumes valid images and error handling should be managed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Image\nfrom PIL import Image as PILImage\nimport io\n\nmcp = FastMCP(\"Image Demo\")\n\n@mcp.tool()\ndef create_thumbnail(image_data: Image) -> Image:\n    \"\"\"Creates a 100x100 thumbnail from the provided image.\"\"\"\n    img = PILImage.open(io.BytesIO(image_data.data)) # Assumes image_data received as Image with bytes\n    img.thumbnail((100, 100))\n    buffer = io.BytesIO()\n    img.save(buffer, format=\"PNG\")\n    # Return a new Image object with the thumbnail data\n    return Image(data=buffer.getvalue(), format=\"png\")\n\n@mcp.tool()\ndef load_image_from_disk(path: str) -> Image:\n    \"\"\"Loads an image from the specified path.\"\"\"\n    # Handles reading file and detecting format based on extension\n    return Image(path=path)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Text Processing Tools with FastMCP in Python\nDESCRIPTION: Creates a FastMCP server named 'TextUtilities' to provide text-related tools and resources. The count_words tool counts the number of words in a provided string, returning an integer. The get_stopwords resource exposes a static list of stopwords and can be used by connected services. This snippet requires FastMCP to be installed and expects text input as a string. Outputs include word counts and stopword lists.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\ntext_mcp = FastMCP(name=\"TextUtilities\")\n\n@text_mcp.tool()\ndef count_words(text: str) -> int:\n    \"\"\"Counts words in a text.\"\"\"\n    return len(text.split())\n\n@text_mcp.resource(\"resource://stopwords\")\ndef get_stopwords() -> list[str]:\n    \"\"\"Return a list of common stopwords.\"\"\"\n    return [\"the\", \"a\", \"is\", \"in\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Templates with URI Parameters - FastMCP - Python\nDESCRIPTION: Explains how to create dynamic resource templates that accept parameters embedded within the requested URI. The `@mcp.resource` decorator is used with a URI string containing `{parameter_name}` placeholders, and the corresponding parameters are automatically extracted from the URI and passed as arguments to the decorated function when the template is requested by a client.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Template URI includes {city} placeholder\n@mcp.resource(\"weather://{city}/current\")\ndef get_weather(city: str) -> dict:\n    \"\"\"Provides weather information for a specific city.\"\"\"\n    # In a real implementation, this would call a weather API\n    # Here we're using simplified logic for example purposes\n    return {\n        \"city\": city.capitalize(),\n        \"temperature\": 22,\n        \"condition\": \"Sunny\",\n        \"unit\": \"celsius\"\n    }\n\n# Template with multiple parameters\n@mcp.resource(\"repos://{owner}/{repo}/info\")\ndef get_repo_info(owner: str, repo: str) -> dict:\n    \"\"\"Retrieves information about a GitHub repository.\"\"\"\n    # In a real implementation, this would call the GitHub API\n    return {\n        \"owner\": owner,\n        \"name\": repo,\n        \"full_name\": f\"{owner}/{repo}\",\n        \"stars\": 120,\n        \"forks\": 48\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with NodeStdioTransport (Python)\nDESCRIPTION: Shows how to create a FastMCP client connecting to a Node.js MCP server script via stdio. Includes inferred transport from a `.js` file path and explicit instantiation of `NodeStdioTransport`, allowing specification of the Node executable path. Requires a target JavaScript file (e.g., `my_mcp_server.js`) that starts an MCP server listening on stdio.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\nfrom fastmcp.client.transports import NodeStdioTransport\n\nnode_server_script = \"my_mcp_server.js\" # Assumes this JS file starts an MCP server on stdio\n\n# Option 1: Inferred transport\nclient_inferred = Client(node_server_script)\n\n# Option 2: Explicit transport\ntransport_explicit = NodeStdioTransport(\n    script_path=node_server_script,\n    node_cmd=\"node\" # Or specify path to Node executable\n)\nclient_explicit = Client(transport_explicit)\n\n# Usage is the same as other clients\n# async with client_explicit:\n#    tools = await client_explicit.list_tools()\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Tools with Pydantic Models\nDESCRIPTION: Demonstrates creating tools with complex input types using Pydantic models and async functions.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\nfrom pydantic import BaseModel\n\nclass UserInfo(BaseModel):\n    user_id: int\n    notify: bool = False\n\n@mcp.tool()\nasync def send_notification(user: UserInfo, message: str) -> dict:\n    \"\"\"Sends a notification to a user if requested.\"\"\"\n    if user.notify:\n        # Simulate sending notification\n        print(f\"Notifying user {user.user_id}: {message}\")\n        return {\"status\": \"sent\", \"user_id\": user.user_id}\n    return {\"status\": \"skipped\", \"user_id\": user.user_id}\n\n@mcp.tool()\ndef get_stock_price(ticker: str) -> float:\n    \"\"\"Gets the current price for a stock ticker.\"\"\"\n    # Replace with actual API call\n    prices = {\"AAPL\": 180.50, \"GOOG\": 140.20}\n    return prices.get(ticker.upper(), 0.0)\n```\n\n----------------------------------------\n\nTITLE: Managing FastMCP Client Connection Lifecycle (Python)\nDESCRIPTION: Illustrates the asynchronous connection management using an `async with` block. The context manager handles establishing the connection upon entry and closing it upon exit. Example calls like `list_tools` and `call_tool` are shown executing within the active session.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom fastmcp import Client\n\nclient = Client(\"my_mcp_server.py\") # Assumes my_mcp_server.py exists\n\nasync def main():\n    # Connection is established here\n    async with client:\n        print(f\"Client connected: {client.is_connected()}\")\n\n        # Make MCP calls within the context\n        tools = await client.list_tools()\n        print(f\"Available tools: {tools}\")\n\n        if any(tool.name == \"greet\" for tool in tools):\n            result = await client.call_tool(\"greet\", {\"name\": \"World\"})\n            print(f\"Greet result: {result}\")\n\n    # Connection is closed automatically here\n    print(f\"Client connected: {client.is_connected()}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Listing Available Tools on FastMCP Server (Python)\nDESCRIPTION: Demonstrates how to use the `list_tools()` method on a connected client to retrieve a list of tools exposed by the server. This method returns an asynchronous result containing metadata about each available tool.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntools = await client.list_tools()\n# tools -> list[mcp.types.Tool]\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Servers using the FastMCP CLI\nDESCRIPTION: Provides examples of using the `fastmcp run` command-line interface to launch server applications defined in Python files. It demonstrates specifying the server object, selecting transports (stdio, sse), and configuring options like host, port, and log level via command-line arguments.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\n# Run a server (defaults to stdio transport)\nfastmcp run my_server.py:mcp\n\n# Explicitly specify a transport\nfastmcp run my_server.py:mcp --transport sse\n\n# Configure SSE transport with host and port\nfastmcp run my_server.py:mcp --transport sse --host 127.0.0.1 --port 8888\n\n# With log level\nfastmcp run my_server.py:mcp --transport sse --log-level DEBUG\n```\n\n----------------------------------------\n\nTITLE: Synchronous and Asynchronous Tool Implementations\nDESCRIPTION: This code demonstrates both synchronous and asynchronous tool implementations within FastMCP. The `calculate_distance` tool is a synchronous function, suitable for quick or CPU-bound operations. The `fetch_weather` tool uses `async def` and `aiohttp` to handle a network request, showcasing how to implement an asynchronous tool for I/O-bound operations to prevent blocking the server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport aiohttp\n\n# Synchronous tool (suitable for CPU-bound or quick tasks)\n@mcp.tool()\ndef calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"Calculate the distance between two coordinates.\"\"\"\n    # Implementation...\n    return 42.5\n\n# Asynchronous tool (ideal for I/O-bound operations)\n@mcp.tool()\nasync def fetch_weather(city: str) -> dict:\n    \"\"\"Retrieve current weather conditions for a city.\"\"\"\n    # Use 'async def' for operations involving network calls, file I/O, etc.\n    # This prevents blocking the server while waiting for external operations.\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"https://api.example.com/weather/{city}\") as response:\n            # Check response status before returning\n            response.raise_for_status()\n            return await response.json()\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with PythonStdioTransport (Python)\nDESCRIPTION: Demonstrates creating a FastMCP client to connect to a Python MCP server script via stdio. Shows both inferred transport (passing the script path) and explicit instantiation of `PythonStdioTransport` to customize execution (python path, args, env, cwd). Requires a target Python script (e.g., `my_mcp_server.py`) that starts an MCP server listening on stdio. Includes an example async function to use the client.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\nfrom fastmcp.client.transports import PythonStdioTransport\n\nserver_script = \"my_mcp_server.py\" # Assumes this file exists and runs mcp.run()\n\n# Option 1: Inferred transport\nclient_inferred = Client(server_script)\n\n# Option 2: Explicit transport (e.g., to use a specific python executable or add args)\ntransport_explicit = PythonStdioTransport(\n    script_path=server_script,\n    python_cmd=\"/usr/bin/python3.11\", # Specify python version\n    # args=[\"--some-server-arg\"], # Pass args to the script\n    # env={\"MY_VAR\": \"value\"},   # Set environment variables\n    # cwd=\"/path/to/run/in\"       # Set working directory\n)\nclient_explicit = Client(transport_explicit)\n\nasync def use_stdio_client(client):\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Connected via Python Stdio, found tools: {tools}\")\n\n# asyncio.run(use_stdio_client(client_inferred))\n# asyncio.run(use_stdio_client(client_explicit))\n```\n\n----------------------------------------\n\nTITLE: Creating a FastMCP Proxy Server in Python\nDESCRIPTION: Demonstrates how to create a FastMCP server that acts as a proxy to another MCP endpoint. It initializes a `Client` with a specified transport (here, `PythonStdioTransport` connecting to a local script) and then uses the `FastMCP.from_client` class method to dynamically build the proxy server based on the target's capabilities. The proxy is then run using the SSE transport.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom fastmcp import FastMCP, Client\nfrom fastmcp.client.transports import PythonStdioTransport\n\n# Create a client that connects to the original server\nproxy_client = Client(\n    transport=PythonStdioTransport('path/to/original_stdio_server.py'),\n)\n\n# Create a proxy server that connects to the client and exposes its capabilities\nproxy = FastMCP.from_client(proxy_client, name=\"Stdio-to-SSE Proxy\")\n\nif __name__ == \"__main__\":\n    proxy.run(transport='sse')\n```\n\n----------------------------------------\n\nTITLE: Pinging the FastMCP Server (Python)\nDESCRIPTION: Shows the usage of the `ping()` method within an active client session. This utility method sends a basic ping request to the server to confirm that the connection is live and the server is responsive.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def check_connection():\n    async with client:\n        await client.ping()\n        print(\"Server is reachable\")\n```\n\n----------------------------------------\n\nTITLE: Listing Available Resources on FastMCP Server (Python)\nDESCRIPTION: Illustrates fetching a list of static resources available on the connected server using the `list_resources()` method. The method returns an asynchronous result containing metadata about each resource.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresources = await client.list_resources()\n# resources -> list[mcp.types.Resource]\n```\n\n----------------------------------------\n\nTITLE: Handling Server Log Messages (Python)\nDESCRIPTION: Explains how to configure the `log_handler` callback to receive log messages sent by the server. This function is triggered by server-side logging calls and receives the log level, message string, and optional logger name.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.client.session import LoggingFnT, LogLevel\n\ndef my_log_handler(level: LogLevel, message: str, logger_name: str | None):\n    print(f\"[Server Log - {level.upper()}] {logger_name or 'default'}: {message}\")\n\nclient_with_logging = Client(\n    \"my_server.py\",\n    log_handler=my_log_handler\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Available Resource Templates on FastMCP Server (Python)\nDESCRIPTION: Shows how to retrieve a list of resource templates provided by the connected server using the `list_resource_templates()` method. The result is an asynchronous list containing metadata for each template.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntemplates = await client.list_resource_templates()\n# templates -> list[mcp.types.ResourceTemplate]\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with NpxStdioTransport (Python)\nDESCRIPTION: Demonstrates using `NpxStdioTransport` to run an MCP server packaged as an NPM package via `npx`. Requires explicit instantiation, specifying the target NPM package name and optional arguments (`args`) passed to the package's script. Assumes the target NPM package, when run via `npx`, starts an MCP server listening on stdio.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.client.transports import NpxStdioTransport\n\n# Example: Run a hypothetical 'npm-mcp-server-package' via npx\ntransport = NpxStdioTransport(\n    package=\"npm-mcp-server-package\",\n    # args=[\"--port\", \"stdio\"] # Args passed to the package script\n)\nclient = Client(transport)\n\n# async with client:\n#     response = await client.call_tool(\"get_npm_data\", {})\n```\n\n----------------------------------------\n\nTITLE: Request Information with Context - Python\nDESCRIPTION: Shows how to access metadata about the current request using the `Context` object. Demonstrates how to access the `request_id` and `client_id` properties of the context object.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def request_info(ctx: Context) -> dict:\n    \"\"\"Return information about the current request.\"\"\"\n    return {\n        \"request_id\": ctx.request_id,\n        \"client_id\": ctx.client_id or \"Unknown client\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Running a FastMCP Server with SSE Transport in Python\nDESCRIPTION: Demonstrates running a FastMCP server using the Server-Sent Events (SSE) transport by calling `mcp.run(transport=\"sse\")`. SSE runs a persistent web server suitable for long-running services accessible by multiple clients over HTTP.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# Run with SSE on default host/port (0.0.0.0:8000)\nmcp.run(transport=\"sse\")\n```\n\n----------------------------------------\n\nTITLE: Reading a Resource or Resolved Template (Python)\nDESCRIPTION: Demonstrates reading the content of a resource or a resolved template using the `read_resource()` method with a URI. This method fetches the actual content, returning a list of content objects relevant to the resource type (e.g., text, blob).\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Read a static resource\nreadme_content = await client.read_resource(\"file:///path/to/README.md\")\n# readme_content -> list[mcp.types.TextResourceContents | mcp.types.BlobResourceContents]\nprint(readme_content[0].text) # Assuming text\n\n# Read a resource generated from a template\nweather_content = await client.read_resource(\"data://weather/london\")\nprint(weather_content[0].text) # Assuming text JSON\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with WSTransport (Python)\nDESCRIPTION: Shows how to connect a FastMCP client to a server using the WebSocket protocol. Includes inferred transport from a `ws://` or `wss://` URL and explicit instantiation of `WSTransport`. Requires a running MCP server accessible at the specified WebSocket URL.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\nfrom fastmcp.client.transports import WSTransport\n\nws_url = \"ws://localhost:9000\"\n\n# Option 1: Inferred transport\nclient_inferred = Client(ws_url)\n\n# Option 2: Explicit transport\ntransport_explicit = WSTransport(url=ws_url)\nclient_explicit = Client(transport_explicit)\n\nasync def use_ws_client(client):\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Connected via WebSocket, found tools: {tools}\")\n\n# asyncio.run(use_ws_client(client_inferred))\n# asyncio.run(use_ws_client(client_explicit))\n```\n\n----------------------------------------\n\nTITLE: Providing Client Root Directories to Server (Python)\nDESCRIPTION: Explains how to provide the server with a list of root directories the client allows access to by setting the `roots` callback during client initialization. This can be a static list or a dynamic function that returns roots based on request context.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom fastmcp.client.roots import RootsHandler, RootsList\nfrom mcp.shared.context import RequestContext # For type hint\n\n# Option 1: Static list\nstatic_roots: RootsList = [str(Path.home() / \"Documents\")]\n\n# Option 2: Dynamic function\ndef dynamic_roots_handler(context: RequestContext) -> RootsList:\n    # Logic to determine accessible roots based on context\n    print(f\"Server requested roots (Request ID: {context.request_id})\")\n    return [str(Path.home() / \"Downloads\")]\n\nclient_with_roots = Client(\n    \"my_server.py\",\n    roots=dynamic_roots_handler # or roots=static_roots\n)\n\n# Tell the server the roots might have changed (if needed)\n# async with client_with_roots:\n#     await client_with_roots.send_roots_list_changed()\n```\n\n----------------------------------------\n\nTITLE: In-Memory Proxy Example (Python)\nDESCRIPTION: This Python code creates an in-memory proxy. It creates an original `FastMCP` server, defines a tool on it and then creates a proxy of it using `FastMCP.from_client()`. The proxy is then used. This pattern can be utilized to customize the configuration or behaviour of a server you don't fully control.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/proxy.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\n# Original server\noriginal_server = FastMCP(name=\"Original\")\n\n@original_server.tool()\ndef tool_a() -> str: \n    return \"A\"\n\n# Create a proxy of the original server\nproxy = FastMCP.from_client(\n    original_server,\n    name=\"Proxy Server\"\n)\n\n# proxy is now a regular FastMCP server that forwards\n# requests to original_server\n```\n\n----------------------------------------\n\nTITLE: Communicating with MCP Servers Using FastMCP Client in Python\nDESCRIPTION: This snippet demonstrates the use of the fastmcp.Client class to connect and interact with MCP servers asynchronously. It shows how to call server tools, read resources, and print output. Dependencies are fastmcp. The connection string or transport protocol string is required as input. Outputs are typically the results of invoked tools or resource fetches. Proper server access and corresponding tool/resource registration on the server are prerequisites.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\n\nasync with Client(\"path/to/server\") as client:\n    # Call a tool\n    result = await client.call_tool(\"weather\", {\"location\": \"San Francisco\"})\n    print(result)\n    \n    # Read a resource\n    res = await client.read_resource(\"db://users/123/profile\")\n    print(res)\n\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with FastMCPTransport (Python)\nDESCRIPTION: Demonstrates connecting a FastMCP client directly to a `FastMCP` server instance within the same Python process using `FastMCPTransport`. Shows inferred transport by passing the server instance and explicit instantiation. Ideal for testing and embedding, as it uses efficient in-memory queues instead of subprocesses or network calls. Includes an example server definition and async usage.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\nfrom fastmcp.client.transports import FastMCPTransport\n\n# 1. Create your FastMCP server instance\nserver = FastMCP(name=\"InMemoryServer\")\n@server.tool()\ndef ping(): return \"pong\"\n\n# 2. Create a client pointing directly to the server instance\n# Option A: Inferred\nclient_inferred = Client(server)\n\n# Option B: Explicit\ntransport_explicit = FastMCPTransport(mcp=server)\nclient_explicit = Client(transport_explicit)\n\n# 3. Use the client (no subprocess or network involved)\nasync def test_in_memory():\n    async with client_inferred: # Or client_explicit\n        result = await client_inferred.call_tool(\"ping\")\n        print(f\"In-memory call result: {result[0].text}\") # Output: pong\n\n# asyncio.run(test_in_memory())\n```\n\n----------------------------------------\n\nTITLE: Generating FastMCP Server from OpenAPI Spec in Python\nDESCRIPTION: Demonstrates creating a FastMCP server from an OpenAPI specification dictionary using `FastMCP.from_openapi`. This requires the OpenAPI spec as a Python dictionary and an `httpx.AsyncClient` instance configured with the base URL of the actual API endpoint to handle the underlying HTTP requests.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\nimport json\nfrom fastmcp import FastMCP\n\n# Load the OpenAPI spec (dict)\n# with open(\"my_api_spec.json\", \"r\") as f:\n#     openapi_spec = json.load(f)\nopenapi_spec = { ... } # Your spec dict\n\n# Create an HTTP client to make requests to the actual API endpoint\nhttp_client = httpx.AsyncClient(base_url=\"https://api.yourservice.com\")\n\n# Generate the MCP server\nmcp_server = FastMCP.from_openapi(openapi_spec, client=http_client)\n\nif __name__ == \"__main__\":\n    mcp_server.run()\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronous and Asynchronous Prompts in FastMCP in Python\nDESCRIPTION: Shows how to create both synchronous and asynchronous prompt functions, with the latter being useful for I/O operations like API calls.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Synchronous prompt\n@mcp.prompt()\ndef simple_question(question: str) -> str:\n    \"\"\"Generates a simple question to ask the LLM.\"\"\"\n    return f\"Question: {question}\"\n\n# Asynchronous prompt\n@mcp.prompt()\nasync def data_based_prompt(data_id: str) -> str:\n    \"\"\"Generates a prompt based on data that needs to be fetched.\"\"\"\n    # In a real scenario, you might fetch data from a database or API\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"https://api.example.com/data/{data_id}\") as response:\n            data = await response.json()\n            return f\"Analyze this data: {data['content']}\"\n```\n\n----------------------------------------\n\nTITLE: Transport Bridging Example (Python)\nDESCRIPTION: This snippet showcases a transport bridging example, specifically making a remote SSE server accessible locally via Stdio. It creates a `Client` targeting a remote SSE server, then generates a proxy `FastMCP` server using `from_client`. This demonstrates the flexibility of the proxy, working with any transport without extra code.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/proxy.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP, Client\n\n# Client targeting a remote SSE server\nclient = Client(\"http://example.com/mcp/sse\")\n\n# Create a proxy server - it's just a regular FastMCP server\nproxy = FastMCP.from_client(client, name=\"SSE to Stdio Proxy\")\n\n# The proxy can now be used with any transport\n# No special handling needed - it works like any FastMCP server\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Server with CLI Command in Bash\nDESCRIPTION: This snippet shows how to run the FastMCP server using the FastMCP CLI tool. The command 'fastmcp run my_server.py:mcp' starts the server defined by the 'mcp' object inside 'my_server.py' and keeps it running with the default stdio transport. Using the CLI does not require a __main__ block in the server file. This approach is useful for deployment and development convenience.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp run my_server.py:mcp\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicate Prompt Handling in FastMCP in Python\nDESCRIPTION: Shows how to configure the FastMCP server's behavior when duplicate prompt names are registered, with options for warning, raising errors, replacing, or ignoring duplicates.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"PromptServer\",\n    on_duplicate_prompts=\"error\"  # Raise an error if a prompt name is duplicated\n)\n\n@mcp.prompt()\ndef greeting(): return \"Hello, how can I help you today?\"\n\n# This registration attempt will raise a ValueError because\n# \"greeting\" is already registered and the behavior is \"error\".\n# @mcp.prompt()\n# def greeting(): return \"Hi there! What can I do for you?\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Route Maps in FastMCP\nDESCRIPTION: Demonstrates how to create and apply custom route maps to override the default mapping behavior. Custom route maps are applied first, before the default maps, allowing specific routes to be handled differently.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.server.openapi import RouteMap, RouteType\n\n# Custom mapping rules\ncustom_maps = [\n    # Force all analytics endpoints to be Tools\n    RouteMap(methods=[\"GET\"], \n             pattern=r\"^/analytics/.*\", \n             route_type=RouteType.TOOL)\n]\n\n# Apply custom mappings\nmcp = await FastMCP.from_openapi(\n    openapi_spec=spec,\n    client=api_client,\n    route_maps=custom_maps\n)\n```\n\n----------------------------------------\n\nTITLE: Customizing Prefix Separators When Importing FastMCP Servers in Python\nDESCRIPTION: This snippet illustrates how to customize separators used for prefixing tool names, resource URIs, and prompt names during static composition by the `import_server()` method in Python. Instead of default separators (`_` for tools/prompts and `+` for resources), this example shows usage of `/`, `:`, and `.` to match client requirements or naming conventions. Dependencies include the FastMCP framework. The customized separators allow fine-grained control over how component names from subservers are merged to prevent conflicts or improve readability.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nawait main_mcp.import_server(\n    prefix=\"api\",\n    app=some_subserver,\n    tool_separator=\"/\",       # Tool name becomes: \"api/sub_tool_name\"\n    resource_separator=\":\",   # Resource URI becomes: \"api:data://sub_resource\"\n    prompt_separator=\".\"      # Prompt name becomes: \"api.sub_prompt_name\"\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Static and Predefined Resources - FastMCP - Python\nDESCRIPTION: Explains how to register resources that are not dynamically generated by a function, such as static files or simple predefined text, using concrete `Resource` subclasses and the `mcp.add_resource()` method. Examples demonstrate registering `FileResource`, `TextResource`, and `DirectoryResource` instances, showing how to provide path/text data and optional custom storage keys.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom fastmcp import FastMCP\nfrom fastmcp.resources import FileResource, TextResource, DirectoryResource\n\nmcp = FastMCP(name=\"DataServer\")\n\n# 1. Exposing a static file directly\nreadme_path = Path(\"./README.md\").resolve()\nif readme_path.exists():\n    # Use a file:// URI scheme\n    readme_resource = FileResource(\n        uri=f\"file://{readme_path.as_posix()}\",\n        path=readme_path, # Path to the actual file\n        name=\"README File\",\n        description=\"The project's README.\",\n        mime_type=\"text/markdown\",\n        tags={\"documentation\"}\n    )\n    mcp.add_resource(readme_resource)\n\n# 2. Exposing simple, predefined text\nnotice_resource = TextResource(\n    uri=\"resource://notice\",\n    name=\"Important Notice\",\n    text=\"System maintenance scheduled for Sunday.\",\n    tags={\"notification\"}\n)\nmcp.add_resource(notice_resource)\n\n# 3. Using a custom key different from the URI\nspecial_resource = TextResource(\n    uri=\"resource://common-notice\",\n    name=\"Special Notice\",\n    text=\"This is a special notice with a custom storage key.\",\n)\nmcp.add_resource(special_resource, key=\"resource://custom-key\")\n\n# 4. Exposing a directory listing\ndata_dir_path = Path(\"./app_data\").resolve()\nif data_dir_path.is_dir():\n    data_listing_resource = DirectoryResource(\n        uri=\"resource://data-files\",\n        path=data_dir_path, # Path to the directory\n        name=\"Data Directory Listing\",\n        description=\"Lists files available in the data directory.\",\n        recursive=False # Set to True to list subdirectories\n    )\n    mcp.add_resource(data_listing_resource) # Returns JSON list of files\n```\n\n----------------------------------------\n\nTITLE: Progress Reporting with Context - Python\nDESCRIPTION: Illustrates how to use the `Context` object to report progress updates to the client.  Uses the `ctx.report_progress` method to send progress values. Requires the client to have sent a `progressToken` in the initial request. Shows how to indicate completion of a long-running operation.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def process_items(items: list[str], ctx: Context) -> dict:\n    \"\"\"Process a list of items with progress updates.\"\"\"\n    total = len(items)\n    results = []\n    \n    for i, item in enumerate(items):\n        # Report progress as percentage\n        await ctx.report_progress(progress=i, total=total)\n        \n        # Process the item (simulated with a sleep)\n        await asyncio.sleep(0.1)\n        results.append(item.upper())\n    \n    # Report 100% completion\n    await ctx.report_progress(progress=total, total=total)\n    \n    return {\"processed\": len(results), \"results\": results}\n```\n\n----------------------------------------\n\nTITLE: Customizing Prefix Separators When Mounting FastMCP Servers in Python\nDESCRIPTION: This snippet demonstrates how to specify custom separators for prefixed tool names, resource URIs, and prompt names during dynamic server mounting using the `mount()` method. As with `import_server`, this allows developers to control naming conventions and address client compatibility concerns. The dependencies include FastMCP. Inputs are the subserver, prefix string, and optional separator characters. Outputs are dynamically delegating prefixes reflecting these customized separators.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/composition.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmain_mcp.mount(\n    prefix=\"api\",\n    app=some_subserver,\n    tool_separator=\"/\",       # Tool name becomes: \"api/sub_tool_name\"\n    resource_separator=\":\",   # Resource URI becomes: \"api:data://sub_resource\"\n    prompt_separator=\".\"      # Prompt name becomes: \"api.sub_prompt_name\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with UvxStdioTransport (Python)\nDESCRIPTION: Illustrates using `UvxStdioTransport` to run an MCP server packaged as a Python tool via `uvx` (from the `uv` toolchain) without prior installation. Requires explicit instantiation and allows specifying the tool name, optional source package, additional dependencies (`with_packages`), and arguments (`tool_args`) passed to the tool. Assumes the target tool starts an MCP server on stdio when executed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.client.transports import UvxStdioTransport\n\n# Example: Run a hypothetical 'cloud-analyzer-mcp' tool via uvx\n# Assume this tool, when run, starts an MCP server on stdio\ntransport = UvxStdioTransport(\n    tool_name=\"cloud-analyzer-mcp\",\n    # from_package=\"cloud-analyzer-cli\", # Optionally specify package if tool name differs\n    # with_packages=[\"boto3\", \"requests\"], # Add dependencies if needed\n    # tool_args=[\"--config\", \"prod.yaml\"] # Pass args to the tool itself\n)\nclient = Client(transport)\n\n# async with client:\n#     analysis = await client.call_tool(\"analyze_bucket\", {\"name\": \"my-data\"})\n```\n\n----------------------------------------\n\nTITLE: Creating an MCP server from OpenAPI specification\nDESCRIPTION: Demonstrates how to create a FastMCP server from an OpenAPI specification with a client. The snippet shows the basic setup including creating an API client, loading the OpenAPI spec, and initializing the MCP server.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\nfrom fastmcp import FastMCP\n\n# Create a client for your API\napi_client = httpx.AsyncClient(base_url=\"https://api.example.com\")\n\n# Load your OpenAPI spec\nspec = {...} \n\n# Create an MCP server from your OpenAPI spec\nmcp = FastMCP.from_openapi(openapi_spec=spec, client=api_client)\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom ResourceTemplate Keys and Registering with FastMCP in Python\nDESCRIPTION: This snippet explains how to create a custom resource template key using FastMCP's ResourceTemplate API. It shows how to construct a ResourceTemplate from an existing function with a specified URI template and a custom name. The template is then registered with a FastMCP resource manager using a custom key URI, allowing multiple URI patterns to point to the same resource logic. This enables flexible routing configurations. Prerequisites include fastmcp and relevant imports. The expected input is a function to expose and a URI template, while the output is the registration of the template under a given key.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.resources import ResourceTemplate\n\n# Create a template with a function\ntemplate = ResourceTemplate.from_function(\n    my_function,\n    uri_template=\"data://{id}/details\",\n    name=\"Data Details\"\n)\n\n# Register with a custom key\nmcp._resource_manager.add_template(template, key=\"custom://{id}/view\")\n```\n\n----------------------------------------\n\nTITLE: Adding Direct Execution Guard in Python FastMCP Server\nDESCRIPTION: Provides the standard Python code structure `if __name__ == \"__main__\":` needed within a server script (`your_server_file.py`) to enable direct execution. This block typically calls the `run()` method on the FastMCP instance (assumed to be named `mcp`).\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == \"__main__\":\n    mcp.run() # Assuming 'mcp' is your FastMCP instance\n```\n\n----------------------------------------\n\nTITLE: Default Route Mapping Rules in FastMCP\nDESCRIPTION: Shows the default route mapping rules used by FastMCP to determine component types from OpenAPI routes. Maps GET requests with path parameters to ResourceTemplates, GET without path parameters to Resources, and other HTTP methods to Tools.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Simplified version of the actual mapping rules\nDEFAULT_ROUTE_MAPPINGS = [\n    # GET with path parameters -> ResourceTemplate\n    RouteMap(methods=[\"GET\"], pattern=r\".*\\{.*\\}.*\", \n             route_type=RouteType.RESOURCE_TEMPLATE),\n    \n    # GET without path parameters -> Resource\n    RouteMap(methods=[\"GET\"], pattern=r\".*\", \n             route_type=RouteType.RESOURCE),\n    \n    # All other methods -> Tool\n    RouteMap(methods=[\"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\", \"HEAD\"],\n             pattern=r\".*\", route_type=RouteType.TOOL),\n]\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Metadata to FastMCP Prompts in Python\nDESCRIPTION: Demonstrates how to override default metadata for prompts by providing custom names, descriptions, and tags to the @mcp.prompt decorator.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@mcp.prompt(\n    name=\"analyze_data_request\",          # Custom prompt name\n    description=\"Creates a request to analyze data with specific parameters\",  # Custom description\n    tags={\"analysis\", \"data\"}             # Optional categorization tags\n)\ndef data_analysis_prompt(\n    data_uri: str = Field(description=\"The URI of the resource containing the data.\"),\n    analysis_type: str = Field(default=\"summary\", description=\"Type of analysis.\")\n) -> str:\n    \"\"\"This docstring is ignored when description is provided.\"\"\"\n    return f\"Please perform a '{analysis_type}' analysis on the data found at {data_uri}.\"\n```\n\n----------------------------------------\n\nTITLE: Passing Advanced Transport Options via **kwargs in Python\nDESCRIPTION: Explains that `mcp.run()` accepts arbitrary keyword arguments (`**transport_kwargs`) which are passed down to the specific transport's underlying run method (`run_sse_async` or `run_stdio_async`). This provides flexibility for future transport-specific configurations.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n# For SSE transport, kwargs are passed to run_sse_async()\nmcp.run(transport=\"sse\", **transport_kwargs)\n\n# For stdio transport, kwargs are passed to run_stdio_async()\nmcp.run(transport=\"stdio\", **transport_kwargs)\n```\n\n----------------------------------------\n\nTITLE: Accessing FastMCP Server Context in Python Resource and Tool Functions\nDESCRIPTION: This snippet demonstrates the use of the fastmcp.Context type for server-side resource functions. It enables access to logging, progress reporting, resource reads, and client metadata within async endpoints. Dependencies are fastmcp and FastMCP. Inputs include a context object and function-specific arguments; outputs are typically structured data (dict or string). Functions exploit async/await for non-blocking server operations.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Context, FastMCP\n\nmcp = FastMCP(\"Context Demo\")\n\n@mcp.resource(\"system://status\")\nasync def get_system_status(ctx: Context) -> dict:\n    \"\"\"Checks system status and logs information.\"\"\"\n    await ctx.info(\"Checking system status...\")\n    # Perform checks\n    await ctx.report_progress(1, 1) # Report completion\n    return {\"status\": \"OK\", \"load\": 0.5, \"client\": ctx.client_id}\n\n@mcp.tool()\nasync def process_large_file(file_uri: str, ctx: Context) -> str:\n    \"\"\"Processes a large file, reporting progress and reading resources.\"\"\"\n    await ctx.info(f\"Starting processing for {file_uri}\")\n    # Read the resource using the context\n    file_content_resource = await ctx.read_resource(file_uri)\n    file_content = file_content_resource[0].content # Assuming single text content\n    lines = file_content.splitlines()\n    total_lines = len(lines)\n\n    for i, line in enumerate(lines):\n        # Process line...\n        if (i + 1) % 100 == 0: # Report progress every 100 lines\n            await ctx.report_progress(i + 1, total_lines)\n\n    await ctx.info(f\"Finished processing {file_uri}\")\n    return f\"Processed {total_lines} lines.\"\n\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Server Directly using Bash\nDESCRIPTION: Shows the command-line instructions for running a FastMCP server script directly using either the standard Python interpreter or `uv run`. This method requires the user to manage the Python environment and dependencies manually.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\npython your_server_file.py\n# or\nuv run python your_server_file.py\n```\n\n----------------------------------------\n\nTITLE: Defining Prompts Using FastMCP's Prompt Decorator in Python\nDESCRIPTION: This snippet illustrates how to create reusable LLM prompt templates by decorating functions with @mcp.prompt(). Dependencies include fastmcp.prompts.base and the main mcp object. Functions can return prompt strings, UserMessage or AssistantMessage instances, or lists thereof. Input parameters (e.g., code_snippet, error_message) are interpolated into the prompt. Output forms are flexible, depending on downstream requirements.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.prompts.base import UserMessage, AssistantMessage\n\n@mcp.prompt()\ndef ask_review(code_snippet: str) -> str:\n    \"\"\"Generates a standard code review request.\"\"\"\n    return f\"Please review the following code snippet for potential bugs and style issues:\\n```python\\n{code_snippet}\\n```\"\n\n@mcp.prompt()\ndef debug_session_start(error_message: str) -> list[Message]:\n    \"\"\"Initiates a debugging help session.\"\"\"\n    return [\n        UserMessage(f\"I encountered an error:\\n{error_message}\"),\n        AssistantMessage(\"Okay, I can help with that. Can you provide the full traceback and tell me what you were trying to do?\")\n    ]\n```\n\n----------------------------------------\n\nTITLE: Customizing Resource Metadata with Decorator - FastMCP - Python\nDESCRIPTION: Illustrates how to provide explicit metadata such as URI, name, description, MIME type, and tags for a dynamic resource using arguments to the `@mcp.resource` decorator. This allows overriding the default inferred values derived from the function signature and docstring, providing more control over resource properties.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Example specifying metadata\n@mcp.resource(\n    uri=\"data://app-status\",      # Explicit URI (required)\n    name=\"ApplicationStatus\",     # Custom name\n    description=\"Provides the current status of the application.\", # Custom description\n    mime_type=\"application/json\", # Explicit MIME type\n    tags={\"monitoring\", \"status\"} # Categorization tags\n)\ndef get_application_status() -> dict:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    return {\"status\": \"ok\", \"uptime\": 12345, \"version\": mcp.settings.version} # Example usage\n```\n\n----------------------------------------\n\nTITLE: Generating FastMCP Server from FastAPI App in Python\nDESCRIPTION: Shows how to automatically generate a FastMCP server instance from an existing FastAPI application object using the `FastMCP.from_fastapi` class method. By default, GET requests map to MCP resources and other HTTP methods map to MCP tools, leveraging the existing API structure.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import FastAPI\nfrom fastmcp import FastMCP\n\n# Your existing FastAPI application\nfastapi_app = FastAPI(title=\"My Existing API\")\n\n@fastapi_app.get(\"/status\")\ndef get_status(): \n    return {\"status\": \"running\"}\n\n@fastapi_app.post(\"/items\")\ndef create_item(name: str, price: float): \n    return {\"id\": 1, \"name\": name, \"price\": price}\n\n# Generate an MCP server directly from the FastAPI app\nmcp_server = FastMCP.from_fastapi(fastapi_app)\n\nif __name__ == \"__main__\":\n    mcp_server.run()\n```\n\n----------------------------------------\n\nTITLE: Accessing Advanced FastMCP Context Properties in Python Tool Functions\nDESCRIPTION: Demonstrates how to access the underlying FastMCP server instance and low-level session objects from within a tool function. This example shows accessing the server name property and references to the session and request context objects.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def advanced_tool(ctx: Context) -> str:\n    \"\"\"Demonstrate advanced context access.\"\"\"\n    # Access the FastMCP server instance\n    server_name = ctx.fastmcp.name\n    \n    # Low-level session access (rarely needed)\n    session = ctx.session\n    request_context = ctx.request_context\n    \n    return f\"Server: {server_name}\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up FastMCP Development Environment (Bash)\nDESCRIPTION: Clones the FastMCP repository, navigates into the directory, and uses `uv sync` to install all dependencies (including development ones) into a virtual environment. Requires `git` and `uv`.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/jlowin/fastmcp.git\ncd fastmcp\nuv sync\n```\n\n----------------------------------------\n\nTITLE: Installing FastMCP Server for Claude Desktop using Bash\nDESCRIPTION: Illustrates the `fastmcp install` command to package and register a FastMCP server for persistent use within the Claude Desktop application. It handles environment isolation using `uv`. Options allow customizing the display name (`--name`), including extra packages (`--with`), and setting environment variables (`-v`, `-f`).\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp install your_server_file.py\n# With a custom name in Claude\nfastmcp install your_server_file.py --name \"My Analysis Tool\"\n# With extra packages and environment variables\nfastmcp install server.py --with requests -v API_KEY=123 -f .env\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Tests using Bash and uv\nDESCRIPTION: Shows the command used in the development environment to execute the project's test suite. It utilizes `uv run` to execute `pytest` with verbose output (`-vv`), ensuring tests pass during contribution.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nuv run pytest -vv\n```\n\n----------------------------------------\n\nTITLE: Installing FastMCP using Pip (Bash)\nDESCRIPTION: Installs the FastMCP library directly into the current Python environment using the standard `pip` package installer. Requires `pip` (usually included with Python) to be installed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install fastmcp\n```\n\n----------------------------------------\n\nTITLE: Using Static Methods with FastMCP Decorators in Python\nDESCRIPTION: This example shows that static methods can be decorated with FastMCP decorators directly, as they are essentially plain functions within the class namespace. Static methods do not require special binding, making them straightforward to register with tools like add_tool() or add_resource().\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/decorating-methods.mdx#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @staticmethod\n    def utility(x, y):\n        return x + y\n\n    @staticmethod\n    def get_data():\n        return \"Static resource data\"\n\n# Register static methods directly\nmcp.add_tool(MyClass.utility)\n# Or register static resource method\nmcp.add_resource_fn(MyClass.get_data, uri=\"resource://data\")\n```\n\n----------------------------------------\n\nTITLE: Installing FastMCP using UV Pip (Bash)\nDESCRIPTION: Installs the FastMCP library directly into the current Python environment using `uv pip`. This is an alternative to adding it as a project dependency. Requires `uv` to be installed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv pip install fastmcp\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with SSETransport (Python)\nDESCRIPTION: Explains how to connect a FastMCP client to a server using Server-Sent Events (SSE) over HTTP/S. Shows inferred transport from an `http://` or `https://` URL and explicit instantiation of `SSETransport` to provide custom headers. Requires a running MCP server accessible at the specified URL and configured for SSE.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\nfrom fastmcp.client.transports import SSETransport\n\nsse_url = \"http://localhost:8000/sse\"\n\n# Option 1: Inferred transport\nclient_inferred = Client(sse_url)\n\n# Option 2: Explicit transport (e.g., to add custom headers)\nheaders = {\"Authorization\": \"Bearer mytoken\"}\ntransport_explicit = SSETransport(url=sse_url, headers=headers)\nclient_explicit = Client(transport_explicit)\n\nasync def use_sse_client(client):\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Connected via SSE, found tools: {tools}\")\n\n# asyncio.run(use_sse_client(client_inferred))\n# asyncio.run(use_sse_client(client_explicit))\n```\n\n----------------------------------------\n\nTITLE: Adding FastMCP Dependency using UV (Bash)\nDESCRIPTION: Adds FastMCP as a dependency to the current Python project using the `uv` package manager. Run this command in the project's root directory. Requires `uv` to be installed.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuv add fastmcp\n```\n\n----------------------------------------\n\nTITLE: Verifying FastMCP Installation (Bash)\nDESCRIPTION: Checks if FastMCP is installed correctly and displays its version information along with related environment details. Run this command after attempting installation.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp version\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Tests (Bash)\nDESCRIPTION: Executes the FastMCP test suite using `pytest`. This should be run from the root of the cloned repository after setting up the development environment via `uv sync`. Requires `pytest` (installed by `uv sync`).\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/installation.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npytest\n```\n\n----------------------------------------\n\nTITLE: Configuring SSE Transport Parameters in Python\nDESCRIPTION: Illustrates customizing the SSE transport by passing parameters like `host`, `port`, and `log_level` to `mcp.run()`. It also shows the asynchronous equivalent using `asyncio.run(mcp.run_sse_async(...))` for integration into async applications.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# Configure with specific parameters\nmcp.run(\n    transport=\"sse\", \n    host=\"127.0.0.1\",  # Override default host\n    port=8888,         # Override default port\n    log_level=\"debug\"  # Set logging level\n)\n\n# You can also run asynchronously with the same parameters\nimport asyncio\nasyncio.run(\n    mcp.run_sse_async(\n        host=\"127.0.0.1\", \n        port=8888, \n        log_level=\"debug\"\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Specifying FastMCP Object Name for Dev/Install Commands using Bash\nDESCRIPTION: Explains how to specify the FastMCP instance variable name if it's not the default (`mcp`, `server`, or `app`) when using the `fastmcp dev` or `fastmcp install` commands. This is done using the `filename:objectname` syntax.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp dev my_module.py:my_mcp_instance\nfastmcp install api.py:api_app\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP Server in Development Mode using Bash\nDESCRIPTION: Shows the usage of the `fastmcp dev` command-line tool to run a FastMCP server defined in a Python file. This mode is recommended for development and testing, providing an interactive environment. Options allow adding temporary package dependencies (`--with`) or local editable packages (`--with-editable`).\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp dev your_server_file.py\n# With temporary dependencies\nfastmcp dev your_server_file.py --with pandas --with numpy\n# With local package in editable mode\nfastmcp dev your_server_file.py --with-editable .\n```\n\n----------------------------------------\n\nTITLE: Running an MCP Server Locally\nDESCRIPTION: Shows how to run a FastMCP server using the command-line interface.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp run server.py\n```\n\n----------------------------------------\n\nTITLE: Installing an MCP Server in Claude Desktop\nDESCRIPTION: Shows how to install a FastMCP server in Claude Desktop for easy interaction.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp install server.py\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring a FastMCP Server\nDESCRIPTION: Shows how to create a FastMCP server with optional configurations like specifying dependencies.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\n# Create a named server\nmcp = FastMCP(\"My App\")\n\n# Specify dependencies needed when deployed via `fastmcp install`\nmcp = FastMCP(\"My App\", dependencies=[\"pandas\", \"numpy\"])\n```\n\n----------------------------------------\n\nTITLE: Connecting to MCP Servers via Different Transports Using FastMCP Client in Python\nDESCRIPTION: This snippet demonstrates connecting to MCP servers using various transport classes such as SSETransport, PythonStdioTransport, and FastMCPTransport from fastmcp.client.transports. Inputs include server URLs, script paths, or server objects. Dependencies include fastmcp and specific transport classes. The appropriate asynchronous context is required. This enables flexible deployment for both local and remote MCP server communication.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client\nfrom fastmcp.client.transports import (\n    SSETransport, \n    PythonStdioTransport, \n    FastMCPTransport\n)\n\n# Connect to a server over SSE (common for web-based MCP servers)\nasync with Client(SSETransport(\"http://localhost:8000/mcp\")) as client:\n    # Use client here...\n\n# Connect to a Python script using stdio (useful for local tools)\nasync with Client(PythonStdioTransport(\"path/to/script.py\")) as client:\n    # Use client here...\n\n# Connect directly to a FastMCP server object in the same process\nfrom your_app import mcp_server\nasync with Client(FastMCPTransport(mcp_server)) as client:\n    # Use client here...\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Secure File Access with FastMCP Client Roots in Python\nDESCRIPTION: This snippet presents the use of FastMCP's roots functionality to restrict server access to specified client-side file system directories. It involves passing a list of allowed directory URIs (roots) when instantiating the Client. Dependencies are fastmcp. The server must be configured to honor and respect specified roots. Inputs are roots URIs and tool parameters; output is typically server responses after executing file operations within allowed boundaries.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Client, RootsList\n\n# Specify file roots that the client can access\nroots = [\"file:///path/to/allowed/directory\"]\n\nasync with Client(mcp_server, roots=roots) as client:\n    # Now tools in the MCP server can access files in the specified roots\n    await client.call_tool(\"process_file\", {\"filename\": \"data.csv\"})\n\n```\n\n----------------------------------------\n\nTITLE: Creating Static and Dynamic Resources\nDESCRIPTION: Shows how to implement various types of resources including static, dynamic, and JSON-returning resources.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Static resource returning simple text\n@mcp.resource(\"config://app-version\")\ndef get_app_version() -> str:\n    \"\"\"Returns the application version.\"\"\"\n    return \"v2.1.0\"\n\n# Dynamic resource template expecting a 'user_id' from the URI\n@mcp.resource(\"db://users/{user_id}/email\")\nasync def get_user_email(user_id: str) -> str:\n    \"\"\"Retrieves the email address for a given user ID.\"\"\"\n    # Replace with actual database lookup\n    emails = {\"123\": \"alice@example.com\", \"456\": \"bob@example.com\"}\n    return emails.get(user_id, \"not_found@example.com\")\n\n# Resource returning JSON data\n@mcp.resource(\"data://product-categories\")\ndef get_categories() -> list[str]:\n    \"\"\"Returns a list of available product categories.\"\"\"\n    return [\"Electronics\", \"Books\", \"Home Goods\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Server Sampling Requests (Python)\nDESCRIPTION: Details setting up the `sampling_handler` callback to process `sampling/createMessage` requests from the server. This function receives messages and parameters from the server and should contain the logic to interact with an LLM or similar model to produce a response.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.client.sampling import SamplingHandler, MessageResult\nfrom mcp.types import SamplingMessage, SamplingParams, TextContent\nfrom mcp.shared.context import RequestContext # For type hint\n\nasync def my_llm_handler(\n    messages: list[SamplingMessage],\n    params: SamplingParams,\n    context: RequestContext\n) -> str | MessageResult:\n    print(f\"Server requested sampling (Request ID: {context.request_id})\")\n    # In a real scenario, call your LLM API here\n    last_user_message = next((m for m in reversed(messages) if m.role == 'user'), None)\n    prompt = last_user_message.content.text if last_user_message and isinstance(last_user_message.content, TextContent) else \"Default prompt\"\n\n    # Simulate LLM response\n    response_text = f\"LLM processed: {prompt[:50]}...\"\n    # Return simple string (becomes TextContent) or a MessageResult object\n    return response_text\n\nclient_with_sampling = Client(\n    \"my_server.py\",\n    sampling_handler=my_llm_handler\n)\n```\n\n----------------------------------------\n\nTITLE: Running FastMCP server with Inspector via Node.js\nDESCRIPTION: Commands to launch the FastMCP server with Inspector, a Node.js application for inspecting the server. Users need Node.js and npm installed to run the command that opens the web app at localhost:5173 for inspection purposes.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/Windows_Notes.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfastmcp dev server.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Git remote for working with a fork\nDESCRIPTION: Instructions to add a fork as a new remote in your local git repository, verify the remote, commit changes, push to the fork, and create a pull request on GitHub. This facilitates contribution workflows for development.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/Windows_Notes.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add fork git@github.com:YOUR-USERNAME/REPOSITORY-NAME.git\n\ngit remote -v\n\ngit push fork <branch>\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicate Tool Behavior in FastMCP\nDESCRIPTION: Shows how to configure the FastMCP server's behavior when duplicate tool names are registered, with options for warning, error, replacement, or ignoring.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"StrictServer\",\n    # Configure behavior for duplicate tool names\n    on_duplicate_tools=\"error\"\n)\n\n@mcp.tool()\ndef my_tool(): return \"Version 1\"\n\n# This will now raise a ValueError because 'my_tool' already exists\n# and on_duplicate_tools is set to \"error\".\n# @mcp.tool()\n# def my_tool(): return \"Version 2\"\n```\n\n----------------------------------------\n\nTITLE: Fixing AttributeError in collections module for Python compatibility\nDESCRIPTION: Instructions to modify the 'py3k_compat.py' file in the virtual environment to replace the deprecated 'collections.Callable' with 'collections.abc.Callable', ensuring compatibility with newer Python versions.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/Windows_Notes.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nreturn isinstance(x, Callable)\n```\n\n----------------------------------------\n\nTITLE: Configuring FastMCP Server Behavior for Duplicate Resource Registrations in Python\nDESCRIPTION: This snippet showcases configuring FastMCP to handle duplicate resource registrations with different behaviors using the 'on_duplicate_resources' setting during server initialization. It provides an example where the server is configured to raise an error on duplicates, and registering a resource for an already registered URI raises a ValueError. Alternatives such as 'warn', 'replace', or 'ignore' policies are described. Dependencies include fastmcp. The input is the server config and resource registrations, and output is the acceptance, warning, replacement, or rejection of duplicate registrations based on the setting.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/resources.mdx#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"ResourceServer\",\n    on_duplicate_resources=\"error\" # Raise error on duplicates\n)\n\n@mcp.resource(\"data://config\")\ndef get_config_v1(): return {\"version\": 1}\n\n# This registration attempt will raise a ValueError because\n# \"data://config\" is already registered and the behavior is \"error\".\n# @mcp.resource(\"data://config\")\n# def get_config_v2(): return {\"version\": 2}\n```\n\n----------------------------------------\n\nTITLE: Rendering Version Badge Component in React\nDESCRIPTION: Defines a React functional component named VersionBadge that accepts a 'version' prop and renders a styled span element with a badge emoji and version information. Dependencies include React and the component's usage context must include React environment setup.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/snippets/version-badge.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const VersionBadge = ({ version }) => {\n    return (\n        <span className=\"version-badge\">\n            <span className=\"badge-emoji\" aria-hidden=\"true\" style={{ marginRight: '0.3em', verticalAlign: 'middle' }}>âœ¨</span>\n            New in version {version}\n        </span>\n    );\n};\n```\n\n----------------------------------------\n\nTITLE: Uninstalling and reinstalling FastMCP locally for development\nDESCRIPTION: Series of commands to uninstall existing FastMCP package, clean build artifacts, and reinstall in editable mode from a local directory. This process is performed within Windows command prompt to update the package in a development environment.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/Windows_Notes.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# First uninstall\nuv pip uninstall fastmcp\n\n# Clean any build artifacts in your fastmcp directory\ncd C:\\\\path\\\\to\\\\fastmcp\ndel /s /q *.egg-info\n\n# Then reinstall in your weather project\ncd C:\\\\path\\\\to\\\\new\\\\fastmcp_server\nuv pip install --no-cache-dir -e C:\\\\Users\\\\justj\\\\PycharmProjects\\\\fastmcp\n\n# Check that it installed properly and has the correct git hash\npip show fastmcp\n```\n\n----------------------------------------\n\nTITLE: Importing a FastMCP Contrib Module - Python\nDESCRIPTION: This code snippet demonstrates how to import a contrib module from the `fastmcp.contrib` package. It assumes that the contrib package and the module named `my_module` are available.  This import allows the user to access the functionalities implemented within the `my_module`. There are no explicit dependencies in this import statement; the dependency lies with the presence of the `my_module` within the `fastmcp.contrib` package.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/contrib.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.contrib import my_module\n```\n\n----------------------------------------\n\nTITLE: Initializing a FastMCP Server in Python\nDESCRIPTION: This snippet demonstrates creating a basic FastMCP server instance by importing the FastMCP class and instantiating it with a server name. It requires the fastmcp package to be installed. The code initializes the server object, which acts as a container for tools and other MCP components. No inputs or outputs occur in this snippet as it only sets up the server instance.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n```\n\n----------------------------------------\n\nTITLE: Importing a contrib module in Python\nDESCRIPTION: Demonstrates how to import a community-contributed module from the fastmcp.contrib package in Python. This is the standard way to access any functionality provided by the contrib modules in the FastMCP project.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/contrib/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp.contrib import my_module\n```\n\n----------------------------------------\n\nTITLE: Configuring FastMCP Server Settings at Initialization in Python\nDESCRIPTION: Illustrates configuring `ServerSettings`, such as `port` for SSE transport or `on_duplicate_tools` for handling naming conflicts, by passing them as keyword arguments directly to the `FastMCP` constructor. Settings are then accessible via the `mcp.settings` attribute.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\n# Configure during initialization\nmcp = FastMCP(\n    name=\"ConfiguredServer\",\n    port=8080, # Directly maps to ServerSettings\n    on_duplicate_tools=\"error\" # Set duplicate handling\n)\n\n# Settings are accessible via mcp.settings\nprint(mcp.settings.port) # Output: 8080\nprint(mcp.settings.on_duplicate_tools) # Output: \"error\"\n```\n\n----------------------------------------\n\nTITLE: Automatic Registration of Methods During Object Initialization\nDESCRIPTION: This pattern involves registering instance methods automatically within a class's constructor. It encapsulates registration logic, promoting organized code where methods are bound to the instance and registered immediately upon creation, reducing manual registration steps.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/decorating-methods.mdx#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass ComponentProvider:\n    def __init__(self, mcp_instance):\n        # Register instance methods\n        mcp_instance.add_tool(self.tool_method)\n        mcp_instance.add_resource_fn(self.resource_method, uri=\"resource://data\")\n    \n    def tool_method(self, x):\n        return x * 2\n    \n    def resource_method(self):\n        return \"Resource data\"\n\n# Instantiate the class, which automatically registers methods\nprovider = ComponentProvider(mcp)\n\n# Methods are now registered and available for use\n```\n\n----------------------------------------\n\nTITLE: Setting up Python virtual environment and installing dependencies\nDESCRIPTION: Commands for creating a Python virtual environment, activating it, and installing the FastMCP package in editable mode including development dependencies. Dependencies are managed via pip within a Windows environment.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/Windows_Notes.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuv venv\n.venv\\Scripts\\activate\nuv pip install -e \".[dev]\"\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Pre-Commit Hooks using Bash\nDESCRIPTION: Provides the commands for setting up and running pre-commit hooks, part of the contribution workflow. `pre-commit install` sets up the hooks (e.g., for `ruff`), and `pre-commit run --all-files` executes the checks on all files.\nSOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```"
  }
]